# 【转载】幂等复制文章链接

> 一般而言，如果使用相同的输入参数多次调用它，幂等操作是具有相同输出的操作

## 什么是幂等

幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。
在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。

## 什么情况下需要保证幂等性

以SQL为例，有下面三种场景，只有第三种场景需要开发人员使用其他策略保证幂等性：

1. `SELECT col1 FROM tab1 WHER col2=2`，无论执行多少次都不会改变状态，是天然的幂等。
2. `UPDATE tab1 SET col1=1 WHERE col2=2`，无论执行**成功**多少次**状态**都是一致的，因此也是幂等操作。
3. `UPDATE tab1 SET col1=col1+1 WHERE col2=2`，每次执行的结果都会发生变化，这种不是幂等的。

## 为什么要设计幂等性的服务

幂等可以使得客户端逻辑处理变得简单，但是却以服务逻辑变得复杂为代价。满足幂等服务的需要在逻辑中至少包含两点：

1. 首先去查询上一次的执行状态，如果没有则认为是第一次请求
2. 在服务改变状态的业务逻辑前，保证防重复提交的逻辑

## 幂等场景

1. 前端重复提交选中的数据给后台服务器，则后台只产生唯一的结果；
2. 我们发起一笔付款请求，服务器只能扣用户账户一次钱，即使遇到网络断开后重发或系统其他的原因重发，也必须只能扣一次钱；
3. 我们支付一次款项只能产生一条流水数据，如果产生多条流水则会出现问题；
4. 幂等的HTTP方法
    1. GET方法用于获取资源，不应有副作用，因此是幂等的
    2. POST方法用于创建资源，每次请求都会产生新的资源，因此不具备幂等性；
    3. PUT方法用于更新资源，是幂等的；
    4. DELETE方法用于删除资源，也是幂等的。
5. 消息幂等

## 消息幂等

为了防止消息重复消费导致业务处理异常，消息队列 MQ 的消费者在接收到消息后，有必要根据业务上的唯一 Key 对消息做幂等处理。本文介绍消息幂等的概念、适用场景以及处理方法。

### 什么是消息幂等

当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响，那么这整个过程就实现可消息幂等。

例如，在支付场景下，消费者消费扣款消息，对一笔订单执行扣款操作，扣款金额为 100 元。如果因网络不稳定等原因导致扣款消息重复投递，消费者重复消费了该扣款消息，但最终的业务结果是只扣款一次，扣费 100 元，且用户的扣款记录中对应的订单只有一条扣款流水，不会多次扣除费用。那么这次扣款操作是符合要求的，整个消费过程实现了消费幂等。

### 适用场景

在互联网应用中，尤其在网络不稳定的情况下，消息队列 MQ 的消息有可能会出现重复。如果消息重复会影响您的业务处理，请对消息做幂等处理。

消息重复的场景如下：

- 发送时消息重复

    当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败。 如果此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。

- 投递时消息重复

    消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。为了保证消息至少被消费一次，消息队列 MQ 的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。

- 负载均衡时消息重复（包括但不限于网络抖动、Broker 重启以及消费者应用重启）

    当消息队列 MQ 的 Broker 或客户端重启、扩容或缩容时，会触发 Rebalance，此时消费者可能会收到重复消息。

### 处理方法

因为 Message ID 有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据。最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息 Key 设置。

以支付场景为例，可以将消息的 Key 设置为订单号，作为幂等处理的依据。具体代码示例如下：

```java
Message message = new Message();
message.setKey("ORDERID_100");
SendResult sendResult = producer.send(message);
```

消费者收到消息时可以根据消息的 Key，即订单号来实现消息幂等：

```java
consumer.subscribe("ons_test", "*", new MessageListener() {
    public Action consume(Message message, ConsumeContext context) {
        String key = message.getKey()
        // 根据业务唯一标识的 Key 做幂等处理
    }
});
```

## 技术方案

### 乐观锁机制

合理的使用乐观锁，通过version或者updateTime（timestamp）等其他条件，来做乐观锁的判断条件。

```sql
select * from tablename where condition=#condition# //取出要更新的对象，带有版本versoin
update tableName set name=#name#,version=version+1 where version=#version#
```

### 悲观锁机制

每次操作数据时都会被加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起；现实中考虑的并发的要求，可能很少使用该方案；

### 唯一索引机制

在核心的流水表中，使用流水号作为唯一索引，在前端支付或其他POST请求时，利用该唯一索引来防止产生重复数据；

### SELECT + INSERT机制

也就是在插入前先查询下是否已经存在，判断是否已经执行过；这种机制适用于并发不高的后台管理系统；select不一定是从关系型数据库中获取。

### token机制 防止页面重复提交

**实际需求：**

前端页面维护数据只能被提交一次，但往往会由于卡顿导致重复点击或者网络重发或者NGINX重发等情况会导致重复请求。
**解决办法：**
如果是单个服务器可以采用TOKEN加REDIS或TOKEN加其它框架来利用JVM内存，如果是集群环境可以采用TOKEN加REDIS机制；

### 打标处理

利用分布式缓存（如redis），做已处理标识位，每次处理消息的时候都去check一下。