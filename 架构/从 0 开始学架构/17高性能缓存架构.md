# 17 \| 高性能缓存架构

虽然我们可以通过各种手段来提升存储系统的性能，但在某些复杂的业务场景下，单纯依靠存储系统的性能提升不够的，典型的场景有：

- 需要经过复杂运算后得出的数据，存储系统无能为力

例如，一个论坛需要在首页展示当前有多少用户同时在线，如果使用 MySQL 来存储当前用户状态，则每次获取这个总数都要“count(\*)”大量数据，这样的操作无论怎么优化 MySQL，性能都不会太高。如果要实时展示用户同时在线数，则 MySQL 性能无法支撑。

- 读多写少的数据，存储系统有心无力

绝大部分在线业务都是读多写少。例如，微博、淘宝、微信这类互联网业务，读业务占了整体业务量的 90%以上。以微博为例：一个明星发一条微博，可能几千万人来浏览。如果使用 MySQL 来存储微博，用户写微博只有一条 insert 语句，但每个用户浏览时都要 select 一次，即使有索引，几千万条 select 语句对 MySQL 数据库的压力也会非常大。

缓存就是为了弥补存储系统在这些复杂业务场景下的不足，其基本原理是将可能重复使用的数据放到内存中，一次生成、多次使用，避免每次使用都去访问存储系统。

缓存能够带来性能的大幅提升，以 Memcache 为例，单台 Memcache 服务器简单的 key-value 查询能够达到 TPS 50000 以上，其基本的架构是：

<img src="17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/c70fdcaab49fe730380d2207017c4215.jpg" style="zoom: 25%;" />

缓存虽然能够大大减轻存储系统的压力，但同时也给架构引入了更多复杂性。架构设计时如果没有针对缓存的复杂性进行处理，某些场景下甚至会导致整个系统崩溃。今天，我来逐一分析缓存的架构设计要点。

## 缓存穿透

**缓存穿透**是指缓存没有发挥作用，业务系统虽然去缓存查询数据，但缓存中没有数据，业务系统需要再次去存储系统查询数据。通常情况下有两种情况：

1\.存储数据不存在

第一种情况是被访问的数据确实不存在。一般情况下，如果存储系统中没有某个数据，则不会在缓存中存储相应的数据，这样就导致用户查询的时候，在缓存中找不到对应的数据，每次都要去存储系统中再查询一遍，然后返回数据不存在。缓存在这个场景中并没有起到分担存储系统访问压力的作用。

通常情况下，业务上读取不存在的数据的请求量并不会太大，但如果出现一些异常情况，例如被黑客攻击，故意大量访问某些读取不存在数据的业务，有可能会将存储系统拖垮。

这种情况的解决办法比较简单，如果查询存储系统的数据没有找到，则直接设置一个默认值（可以是空值，也可以是具体的值）存到缓存中，这样第二次读取缓存时就会获取到默认值，而不会继续访问存储系统。

2\.缓存数据生成耗费大量时间或者资源

第二种情况是存储系统中存在数据，但生成缓存数据需要耗费较长时间或者耗费大量资源。如果刚好在业务访问的时候缓存失效了，那么也会出现缓存没有发挥作用，访问压力全部集中在存储系统上的情况。

典型的就是电商的商品分页，假设我们在某个电商平台上选择“手机”这个类别查看，由于数据巨大，不能把所有数据都缓存起来，只能按照分页来进行缓存，由于难以预测用户到底会访问哪些分页，因此业务上最简单的就是每次点击分页的时候按分页计算和生成缓存。通常情况下这样实现是基本满足要求的，但是如果被竞争对手用爬虫来遍历的时候，系统性能就可能出现问题。

具体的场景有：

- 分页缓存的有效期设置为 1 天，因为设置太长时间的话，缓存不能反应真实的数据。

- 通常情况下，用户不会从第 1 页到最后 1 页全部看完，一般用户访问集中在前 10 页，因此第 10 页以后的缓存过期失效的可能性很大。

- 竞争对手每周来爬取数据，爬虫会将所有分类的所有数据全部遍历，从第 1 页到最后 1 页全部都会读取，此时很多分页缓存可能都失效了。

- 由于很多分页都没有缓存数据，从数据库中生成缓存数据又非常耗费性能（order by limit 操作），因此爬虫会将整个数据库全部拖慢。

这种情况并没有太好的解决方案，因为爬虫会遍历所有的数据，而且什么时候来爬取也是不确定的，可能是每天都来，也可能是每周，也可能是一个月来一次，我们也不可能为了应对爬虫而将所有数据永久缓存。通常的应对方案要么就是识别爬虫然后禁止访问，但这可能会影响 SEO 和推广；要么就是做好监控，发现问题后及时处理，因为爬虫不是攻击，不会进行暴力破坏，对系统的影响是逐步的，监控发现问题后有时间进行处理。

## 缓存雪崩

**缓存雪崩**是指当缓存失效（过期）后引起系统性能急剧下降的情况。当缓存过期被清除后，业务系统需要重新生成缓存，因此需要再次访问存储系统，再次进行运算，这个处理步骤耗时几十毫秒甚至上百毫秒。而对于一个高并发的业务系统来说，几百毫秒内可能会接到几百上千个请求。由于旧的缓存已经被清除，新的缓存还未生成，并且处理这些请求的线程都不知道另外有一个线程正在生成缓存，因此所有的请求都会去重新生成缓存，都会去访问存储系统，从而对存储系统造成巨大的性能压力。这些压力又会拖慢整个系统，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。

缓存雪崩的常见解决方法有两种：**更新锁机制**和**后台更新机制**。

1\.更新锁

对缓存更新操作进行加锁保护，保证只有一个线程能够进行缓存更新，未能获取更新锁的线程要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。

对于采用分布式集群的业务系统，由于存在几十上百台服务器，即使单台服务器只有一个线程更新缓存，但几十上百台服务器一起算下来也会有几十上百个线程同时来更新缓存，同样存在雪崩的问题。因此分布式集群的业务系统要实现更新锁机制，需要用到分布式锁，如 ZooKeeper。

2\.后台更新

由后台线程来更新缓存，而不是由业务线程来更新缓存，缓存本身的有效期设置为永久，后台线程定时更新缓存。

后台定时机制需要考虑一种特殊的场景，当缓存系统内存不够时，会“踢掉”一些缓存数据，从缓存被“踢掉”到下一次定时更新缓存的这段时间内，业务线程读取缓存返回空值，而业务线程本身又不会去更新缓存，因此业务上看到的现象就是数据丢了。解决的方式有两种：

- 后台线程除了定时更新缓存，还要频繁地去读取缓存（例如，1 秒或者 100 毫秒读取一次），如果发现缓存被“踢了”就立刻更新缓存，这种方式实现简单，但读取时间间隔不能设置太长，因为如果缓存被踢了，缓存读取间隔时间又太长，这段时间内业务访问都拿不到真正的数据而是一个空的缓存值，用户体验一般。

- 业务线程发现缓存失效后，通过消息队列发送一条消息通知后台线程更新缓存。可能会出现多个业务线程都发送了缓存更新消息，但其实对后台线程没有影响，后台线程收到消息后更新缓存前可以判断缓存是否存在，存在就不执行更新操作。这种方式实现依赖消息队列，复杂度会高一些，但缓存更新更及时，用户体验更好。

后台更新既适应单机多线程的场景，也适合分布式集群的场景，相比更新锁机制要简单一些。

后台更新机制还适合业务刚上线的时候进行缓存预热。缓存预热指系统上线后，将相关的缓存数据直接加载到缓存系统，而不是等待用户访问才来触发缓存加载。

## 缓存热点

虽然缓存系统本身的性能比较高，但对于一些特别热点的数据，如果大部分甚至所有的业务请求都命中同一份缓存数据，则这份数据所在的缓存服务器的压力也很大。例如，某明星微博发布“我们”来宣告恋爱了，短时间内上千万的用户都会来围观。

**缓存热点的解决方案就是复制多份缓存副本，将请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力**。以微博为例，对于粉丝数超过 100 万的明星，每条微博都可以生成 100 份缓存，缓存的数据是一样的，通过在缓存的 key 里面加上编号进行区分，每次读缓存时都随机读取其中某份缓存。

缓存副本设计有一个细节需要注意，就是不同的缓存副本不要设置统一的过期时间，否则就会出现所有缓存副本同时生成同时失效的情况，从而引发缓存雪崩效应。正确的做法是设定一个过期时间范围，不同的缓存副本的过期时间是指定范围内的随机值。

## 实现方式

由于缓存的各种访问策略和存储的访问策略是相关的，因此上面的各种缓存设计方案通常情况下都是集成在存储访问方案中，可以采用“程序代码实现”的中间层方式，也可以采用独立的中间件来实现。

## 小结

今天我为你讲了高性能架构设计中缓存设计需要注意的几个关键点，这些关键点本身在技术上都不复杂，但可能对业务产生很大的影响，轻则系统响应变慢，重则全站宕机，架构师在设计架构的时候要特别注意这些细节，希望这些设计关键点和技术方案对你有所帮助。

这就是今天的全部内容，留一道思考题给你吧，分享一下你所在的业务发生过哪些因为缓存导致的线上问题？采取了什么样的解决方案？效果如何？

欢迎你把答案写到留言区，和我一起讨论。相信经过深度思考的回答，也会让你对知识的理解更加深刻。（编辑乱入：精彩的留言有机会获得丰厚福利哦！）

## 精选留言(130)

- 我们的系统就出现过类似的问题，开始的时候没有缓存，每次做活动访问量大的时候就会导致反应特别慢。后来通过加 redis 缓存解决了问题。  对于缓存雪崩问题，我们采取了双 key 策略：要缓存的 key 过期时间是 t，key1 没有过期时间。每次缓存读取不到 key 时就返回 key1 的内容，然后触发一个事件。这个事件会同时更新 key 和 key1。

  作者回复: 很有创意👍👍

  2018-06-05

  **31

  **331

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572392796.jpeg)

  王磊

  经常我说到缓存的时候，面试官问我，数据库自身不是有缓存吗，标准答案是怎么回击他?

  作者回复: 我对 mysql 比较熟，以下仅限 mysql： 1. mysql 第一种缓存叫 sql 语句结果缓存，但条件比较苛刻，程序员不可控，我们的 dba 线上都关闭这个功能，具体实现可以查一下 2. mysql 第二种缓存是 innodb buffer pool，缓存的是磁盘上的分页数据，不是 sql 的查询结果，sql 的执行过程省不了。而 mc，redis 这些实际上都是缓存 sql 的结果，两种缓存方式，性能差很远。 因此，可控性，性能是数据库缓存和独立缓存的主要区别

  2018-06-05

  **8

  **190

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572392797.jpeg)

  loveluckystar

  讲一个头两天发生的事情，我们的一个业务背后是 es 做 db，之前是通过 redis 做缓存，缓存一段时间后失效再从 es 读取，是业务访问加载缓存的方式。有一天线上 es 集群机器单台出现问题，返回慢，由于分布式的缘故，渐渐拖满了所有请求，缓存失效来查询 es 发生了超时，加载失败，于是下次访问还是直接访问 es。最终缓存全部失效，qps 翻了好多倍，直接雪崩，es 集群彻底没有响应了。。。之后我们只好先下线这个缓存加载功能，让集群活过来，最终改造缓存加载方式，用后台进程去更新缓存，而不用业务访问加载。

  作者回复: 现学现用的案例，很赞👍👍

  2018-06-05

  **7

  **82

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572392798.jpeg)

  三月沙@wecatch

  好的缓存方案应该从这几个方面入手设计： 1.什么数据应该缓存 2.什么时机触发缓存和以及触发方式是什么 3.缓存的层次和粒度（ 网关缓存如 nginx，本地缓存如单机文件，分布式缓存如 redis cluster，进程内缓存如全局变量） 4.缓存的命名规则和失效规则 5.缓存的监控指标和故障应对方案 6.可视化缓存数据如 redis 具体 key 内容和大小

  作者回复: 确实，细节不少，可以写本书了😃

  2018-06-05

  **

  **73

- ![img](https://static001.geekbang.org/account/avatar/00/11/05/d8/cd269378.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  一叶

  笔记： 书籍： 《高性能 Mysql》 《unix 编程艺术》：宁花机器一分，不花程序员一秒 提升性能： 先单机，有压力后优先考虑 sql 优化、db 参数调优，还有硬件性能(32 核/16G/SSD)优化，不行还可以再考虑业务逻辑优化、缓存。不要一上来就读写分离、集群等，能单库搞定的就毫不犹豫的单库。 --- 主从读写分离 适用于单机无法应付所有请求，且读比写多时，读写分离还可以分别针对读写节点建索引来优化。 对实时性要求不高：刚写入就读会有延迟，同步数据特别大时，延迟可能达到分钟级（可用缓存解决：2-8 原则，挑选占访问量 80%的前 20%来缓存）。 TODO 主从还能设置自增长 key 不一样？ 分库分表（甚用，增加很多复杂度） 几千万或上亿 分库时机：单机性能瓶颈，1 业务不复杂，但整体数据量影响到数据库性能；2 业务复杂，需要分系统由不同团队开发，使用分库减少团队耦合。（分库导致不能 join 和事务（有方案但性能太低用了跟没分库差别不大，用最终一致性/事件驱动）） 分表时机：单表数据量大拖慢了 sql 性能，做垂直（将常用和不常用字段分开）或水平拆分（id 分段、hash 路由、添加路由表等）提高速度。（那么 join、count、分页排序等就变得复杂） TODO 环状 hash 一致性 hash？ nosql （nosql——not noly sql 本质上是牺牲 ACID 中的某个或某几个属性，以解决关系数据库某些复杂的问题） 关系数据库：强大的 sql 功能和 ACID 属性，发展了几十年技术相当成熟 Mysql / Postgresql  k-v 存储：解决关系数据库无法存储数据结构的问题 Redis / Memcache （redis 不太适合 key 的 value 特别大，这种情况会导致整个 redis 变慢，这种场景 mc 更好->参考 IO 模型 redis 单 Reactor 单进程读写大 value 会阻塞所有业务 持久化也会） 文档数据库：解决关系数据库强 schema 约束，查询不存在的列会报错，扩充很麻烦还会长时间锁表  MongoDB  列式数据库：解决关系数据库处理大数据分析或统计时 IO 高的问题，关系数据库即使只处理某列也会把整行查询到内存中 HBase / Greenplum 全文搜索引擎：解决关系数据库全文搜索 like 扫描全表性能问题 ElasticSearch / solr LevelDB 内存型？ 时序数据库？：实时计算统计实时监控 influxDB OLAP OLTP HTAP？ 缓存（千万千万不要设计复杂的缓存，到时候各种不一致问题烦死你） cdn、nginx 缓存、网关缓存、数据层缓存 redis、db 本身也有缓存(sql 结果缓存、读取的磁盘分页缓存) 缓存穿透：1 本身无数据(添加默认值缓存/布隆过滤器[整型自增 key？]) 2 未生成缓存(识别爬虫并禁止 但可能影响 seo) 缓存雪崩：缓存实效后大家都在更新缓存导致系统性能急剧下降（1 消息队列通知后台更新、2 使用分布式更新锁） 缓存热点：大部分业务都会命中的同一份缓存，比如 1000w+粉丝的微博消息，复制多分缓存副本，key 里面加副本编号将请求分散，且设置过期范围，而不是所有副本固定同一过期时间。 缓存框架看一下设计思路：echcache、网友分享https://github.com/qiujiayu/AutoLoadCache

  作者回复: 很用心，赞👍

  2018-09-23

  **2

  **60

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572392800.jpeg)

  家榆

  我是实现了个框架:https://github.com/qiujiayu/AutoLoadCache，用于解决一下问题: 1. 缓存操作与业务代码耦合问题； 2. 缓存穿透问题； 3. 异步在缓存快要过期时，异步刷新缓存； 4. 使用“拿来主义机制”，降低回源并发量；

  2018-07-05

  **5

  **38

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572392801.jpeg)

  mapping

  计算机界两大难题：命名和缓存过期。没用缓存的时候，想着怎么用缓存提升性能，用了缓存又担心数据更新不及时。技术上希望所有的请求都能命中缓存，业务上又恨不得数据实时最新。所以就会引入各种缓存过期策略，如设置过期时间，按规则删除，打版本。这些应该在前期设计缓存系统时规划好，我们最早是将 sql md5 作 key 查询结果存入缓存，结果业务系统数据不一致，要清除缓存简直是噩梦，只能祭出绝招重启 memcache，后面改成按规则删除，在 key 中加上业务和用户的前缀，可以很方便删除某个业务或某个用户的缓存。以上过期策略在前端浏览器也是这样，最简单就是 web 服务器设置静态资源缓存过期时间，如果业务频繁发新版本，过期时间不宜设置太长，但其实每次变动的文件很少，这种策略会导致大部分缓存命中率不高。按规则删除，早期很多网站上会有诊断助手类的东西，页面加载错误点下诊断助手就帮你清除缓存，原理就是对静态文件逐一带上 no-cache 请求头发送 ajax 请求强制覆盖缓存（跟 DevTools 中 disable cache 原理一样）。打版本其实就相当于让浏览器请求一个新版本文件，对于老版本文件就让它在缓存中自生自灭。

  作者回复: 你们的缓存设计有点复杂，还不如调整业务，越复杂的方案越容易出错，参考架构设计原则

  2018-06-05

  **

  **25

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572392802.jpeg)![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,w_14.png)

  醇梨子

  华仔，请教一下，针对这种高并发缓存架构设计中，缓存和存储系统一致性问题怎么保证？比如说商品浏览人数，需要存库，然后又需要放缓存，需要频繁更新数据库。

  作者回复: 没法保证，这类数据允许一定的不一致，一定范围内的对用户也没有影响，不要只从技术的角度考虑问题，结合业务考虑技术

  2018-06-17

  **4

  **19

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572392803.jpeg)![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,w_14.png)

  公号-技术夜未眠![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/89yyff4c4c2e2b73ce4931bb01a6a943.png)

  上缓存架构的时候，结合以前的实际经历，会有几个值得注意的地方: 1 哪些数据才真正的需要缓存？缓存也并非银弹。既然允许数据缓存，那么在你是可以接受在一定时间区间内的数据不一致性的。(当然可以做到最终一致性) 2 确定好 1 后，就需要会数据类型进行分类，比如业务数据缓存，http 缓存等 3 根据数据类型及访问特点的不同选择不同缓存类型的技术方案。 请问华仔，热点数据存在相当的突发性，临时的扩容似乎也来不及，能否从缓存架构角度如何避免类似微博宕机的事件？

  作者回复: 1. 限流 2. 容器化+动态化 3. 业务降级，例如限制评论

  2018-06-05

  **

  **18

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572392804.jpeg)

  钱

  我们的服务严重依赖缓存，正好顺便回顾一下： 1：使用缓存的目的？ 1-1：加快速度，提升性能  2：刷新缓存的方式？ 2-1：定时任务，每天一刷 2-2：手动触发，随时随地 2-3：为防止数据量大有间隙，先增后删 2-4：为防止数据量大任务多，采用分布式刷新 2-5：刷入缓存的信息基本会经过加工处理 2-6：使用缓存时，会填充本地缓存 2-7：可控制本地缓存是否失效 3：使用缓存的方式？ 3-1：字符串类型使用最多,有时也用字典和列表 3-2：计数 3-3：共享回话信息 3-4：队列 3-5：分布式锁 3-6：如果缓存没有，我们不会读库，怕库扛不住 4：使用缓存遇到的问题？ 4-1：重启服务导致缓存读不到，可用率下降 4-2：缓存集群扩缩容缓存读不到，可用率下降 4-3：大 value，导致性能下降 4-4：大 value，导致带宽打满 4-5：公用机器别的服务打满连接跟踪表，导致不能新建链接 4-6：之前还有先删后插，数据量大时有间隙，读不到缓存，可用率下降 4-7：代码逻辑存在问题，导致缓存错乱引起的问题 4-8：昨晚遇到一个，写本地缓存的 bug，控制不住缓本地存啦，导致业务异常 5：缓存集群的维护？ 维护的事比较弱，公司有专门的基础架构部，专门提供各种缓存、MQ、RPC、数据库中间件、容器扩缩容、监控等的团队，业务开发主要以使用为主，出问题可以一起排查。 这种分工，好处是专业的人负责专业的事，不过也会让业务开发技术实力更弱，一些基础服务大概知道原理，实现细节不太深入。 当然，学习是自己的事情，自己最好要积极主动。

  2019-08-28

  **

  **14

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572392805.jpeg)

  blacknccccc

  对于像淘宝商品列表筛选项特别多，组合起来会更多，这样在后台做更新缓存怎么处理，难道是把每一种组合的分页数据都缓存下来吗

  作者回复: 淘宝的具体实现没有研究，我们有类似的案例，针对常用的分类会统一缓存，缓存会主动更新；不常用的根据查询条件计算 md5 作为 key 进行缓存，缓存时间不长，例如 60 分钟，防止短时间内大量访问压垮存储，例如爬虫

  2018-07-22

  **

  **12

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572392806.jpeg)

  jacy

  商品列表中，像商品描述等信息，缓存更新不及时影响不大，但某些重要数据，如价格，需要及时更新的数据，有没什么好的办法做到刷新。对于价格这种关键数据，不缓存，直接从数据库查询，是否可行。或者在用户查看商品详情时再去数据库查询价格，但可能出现列表中的价格和详情页中的价格不一致。

  作者回复: 通常有几种做法： 1. 同步刷新缓存：当更新了某些信息后，立刻让缓存失效。 这种做法的优点是用户体验好，缺点是修改一个数据可能需要让很多缓存失效 2. 适当容忍不一致：例如某东的商品就是这样，我查询的时候显示有货，下单的时候提示我没货了 3. 关键信息不缓存：库存，价格等不缓存，因为这类信息查询简单，效率高，关系数据库查询性能也很高

  2018-06-05

  **2

  **11

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572402807.jpeg)

  鹅米豆发

  ​       1、最早也是采用后台用数据库，前台用关系型数据库+被动缓存的模式。结果是经常的性能抖动，且缓存一致性问题很难解决。后来我们的多数系统，都采用了前后台分离的模式——后台原始数据仍然是关系型数据库，前台使用缓存作为数据源，两者之间数据实时同步+定时同步+人工触发结合。       这个模式，基本根除了穿透，雪崩，不一致，性能抖动这些。但带来了新的问题，比如数据丢失且不可恢复。我们的做法是，让缓存具备相对可靠的持久化机制+运维体系。       2、遇到过几次热点问题，感觉这个更加棘手些。第一种情况，单 Key 数据结构本身过大，单个分片出现热点，单次访问的复杂度变大。这个相对容易，可以对 key 进行拆分，使用 hashtag 机制分片。第二种情况，数据分片普遍不均衡，较少遇到，遇到就比较棘手。第三种情况，数据分片均衡，但访问不均衡，可以增加副本数量。

  作者回复: 缓存持久化是一个不错的方法

  2018-06-05

  **

  **11

- ![img](https://static001.geekbang.org/account/avatar/00/11/6c/3d/f9ec02ea.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  倔强小小🐤

  我们系统是做美术馆的 3d 展示的，后台配置的数据有点多，画框数据有几 m，单个模型数据有几百 k，最早直接 mysql 直接读取，后来用 redis 但是感觉效果不理想，又引入 ehcache，发现不经过网络传输性能很好，经过网络传输后网络一般还是卡的很，后来又在前端用 local storage 进行缓存，后端通过 rabbitmq 进行消息通知前端清除本地缓存，缓存设置有效期都是一天，请问下我们这种情况有更好的方案吗

  作者回复: 前后端分离，在 node 上缓存和渲染试试

  2018-06-05

  **

  **8

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572402809.jpeg)

  🔰夏天的味道

  线上遇到的一个错误：业务查询的结果序列化后放到 redis，下次从 redis 取出来时报错。原来是结果类虽然实现了 Serializable 接口，但是没有重写 serialVersionUID，导致不能成功反序列化。

  2018-06-06

  **2

  **7

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572402810.jpeg)

  何磊

  遇到过一次缓存失效导致缓存穿透，很多请求的压力直接到了 db。为了处理这种情况，我采用的方案就是：key 永不过期，后台有个进程定时更新所有缓存。 文中提到的结合消息队列来更新更具有时效性，非常棒，看到评论中的有一个双 key 机制，设计很巧妙，不过成本太高了。相当于成本翻倍。

  作者回复: 除非特殊场景，一般我还是建议尽量用简单直观甚至粗暴的方案😂

  2018-06-06

  **

  **7

- ![img](https://static001.geekbang.org/account/avatar/00/0f/58/50/abb7bfe3.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  june peng

  你好，在缓存雪崩后台更新策略里，比如 1000 个同时访问一个失效的缓存 key，如果给这个 key 加读写锁，这样保证只有一个访问存储系统，其它 999 个人虽然慢点，但是至少能保证业务不会挂。如果用消息队列，就是前台只拿缓存 key 里的数据（不能访问存储系统），如果 key 不存在就发给消息队列更新，如果启多个进程去接受这些消息，依然不能避免后台击穿存储系统，难道只有启用一个进程？这样又太慢，可否进一步说明这种方案的复杂点在哪？谢谢

  作者回复: 你的分析很对👍 具体在实现的时候，后台更新线程既不能只有一个，也不能和业务线程一样多，一般 8~32 个就差不多了，因为缓存更新并不会非常频繁。 假如 8 个线程后台更新也可能导致缓存雪崩，那就要做更多事情了，例如：后台线程更新前先读取一下缓存，存在就不更新。

  2018-06-06

  **

  **7

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572402812.jpeg)

  cqc

  1 个问题：关于后台更新，既然缓存服务器内存不足，需要剔除数据，那么后台更新再次触发查询，是否又会导致其他一些缓存数据被剔除，这感觉像是陷入一个循环了 1 个思路：我们之前的 web 项目，对于缓存热点数据，为了减少服务器的压力，在客户端引入了缓存：CDN 加 local storage，感觉对服务器端压力分散还是很有效果的。

  作者回复: 1.是的，所以加内存才是根本解决方式 2. 这是分级缓存策略

  2018-06-05

  **

  **7

- ![img](https://static001.geekbang.org/account/avatar/00/10/1d/a1/459e4bd5.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  刘磊

  对缓存的 key 也需要进行 valid，避免无效的 key 查询缓存

  2018-06-05

  **

  **7

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572402814.jpeg)

  byte

  业务上通过 Redis 集群缓存网络数据，分布在北上广三地，3 个数据中心，集群规模是 80 台物理机共 1000 个左右实例 1 主 3 从。线上出现过跨地域集群数据频繁全量同步打爆交换机的问题，导致整个服务不可用。通过排查发现是网络延时导致频繁全量同步以及服务器电源过热导致从服务器频繁重启。解决方案是跨地数据同步通过 kafka 试下，再接入各地 Redis 集群，电源问题通过更换硬件解决。

  作者回复: 缓存集群间一般不要跨数据中心同步，存储可以用跨数据中心同步

  2018-06-05

  **

  **6

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572402815.jpeg)![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,w_14.png)

  escray![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/d57fddfa5b2c2ce3071e92304da8af62.png)

  本来是看在《数据结构和算法之美》看一致性哈希，然后看到了雪崩效应，然后找到缓存雪崩，然后找到了这里。 我对于缓存雪崩 Cache avalanche 的定义有一点疑问，感觉似乎更像是缓存击穿 Cache breakdown，当然这两个的定义本来就有相似的地方。缓存击穿更多的强调大量缓存同时过期，而缓存雪崩在缓存过期的基础上，又加上了缓存服务器宕机。 就好比，一台缓存服务器宕机，然后导致其他的缓存服务器压力变大，进而影响整个缓存系统。就好像是雪崩时的第一片掉落的雪花。 不过，定义本身并不重要，主要还是对于场景的描述和解决方案。 有意思的是，似乎在维基百科上并没有 Cache avalanche, Cache breakdown, Cache penetration 的定义。

  作者回复: 大量缓存同时到期基本不会出现，因为缓存的 key 很多，每个 key 访问是随机的，每个 key 的有效期也是不同的，除非缓存服务器故障，或者程序出 bug，例如某个死循环写入大量缓存，导致大量缓存被踢

  2020-05-01

  **

  **5

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572402816.jpeg)![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,w_14.png)

  李

  感觉概念理解上有点差异，缓存穿透出现在缓存失效要去查数据库。缓存击穿则是一个 key 失效导致高并发访问数据库压力增大。缓存雪崩则是大量缓存 key 失效或者缓存宕机了，导致数据库并发压力增大。感觉老师您把缓存穿透说成了击穿，击穿说成了雪崩。不知道我是否理解有问题？

  作者回复: 穿透和击穿是一个概念，雪崩不是你理解的那样，雪崩的意思就是开始一个小问题越来越大越来越严重，缓存宕机导致的问题算缓存穿透，就是指缓存没作用了

  2018-11-23

  **

  **5

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572402817.jpeg)

  Sic Pavis

  刚好前段时间就有一个问题。 产品反馈：后台更新的配置不生效，需要过几小时到半天不等的时间才能生效。 从数据库确认持久化数据没问题，因此怀疑是缓存问题。 我们的缓存设计是：业务 key 加一个缓存版本号做 key，每次更新数据对应缓存的版本号就+1。 前台定期扫描缓存版本号来实现缓存的更新。 于是我查到了线上最新的版本号去缓存服务器查询，见鬼，数据也是正常的。排查了几天没有结果，无奈上线一个版本打了 debug 日志，终于找到原因了。 我们的服务是双中心的，两边各存有一份缓存版本号，不知道什么原因，导致一边的缓存版本号比另外一个集群的多了 3。由于我们的更新策略不是删掉无效的缓存，而是更新缓存的 key，因此旧版本的缓存数据实际上还在缓存服务器上。更要命的是缓存服务器做了双中心同步（为啥同步暂且不提），这样就导致实际上一边集群读取的实际上是另外一个集群几个版本前留下的缓存数据。需要等待这个数据过期后，才能正常从数据库加载数据。

  作者回复: 这种做法会经常出现一些线上小问题

  2018-08-23

  **3

  **5

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572392796.jpeg)

  王磊

  关于缓存雪崩的定义，文中的例子是说单条缓存在生成的时间间隔内有大量相同请求查询存储系统，除此之外，记得还有一个更典型的场景，是大量缓存同时过期，导致大量不同请求去查询存储系统(数据库)。请点评。

  作者回复: 一般不会出现这种情况，但缓存服务器宕机的场景和你说的类似，我们一般会要求线上进行模拟测试，假如一台缓存服务器宕机，系统是否能够顶住，如果顶不住，就要增加缓存服务器，或者优化某些 key 的设计

  2018-06-05

  **

  **5

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572402818.jpeg)

  kissrain

  请教一下华仔，像用户下单场景，是先写入数据库再失效缓存还是先失效缓存再写入数据库呢？

  作者回复: 先失效缓存再写数据库吧，因为失效缓存失败的话，也就不会写入数据库了，写入数据库失败的话，缓存还会加载原来的值

  2019-01-05

  **7

  **4

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572402819.jpeg)

  100kg

  你好，我想请教下，如果两台 mysql 互为主从，其中一台主键自增步长设置为 2，另一个为 1，这样做会影响性能吗？比如索引的连贯性之类的

  作者回复: 不会，索性是对已经存在的值建立索性数据结构，值的连续性和大小对数据结构本身没有影响，值的数量才会影响索性的大小和性能

  2018-06-06

  **2

  **4

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572392796.jpeg)

  王磊

  '后台更新既适应单机多线程的场景，也适合分布式集群的场景，相比更新锁机制要简单一些.' - 没觉得简单啊，因为如文中所说，后台更新也可能会出现多个业务线程都发送了缓存更新消息，这种情况我理解也需要有分布式锁来避免多个相同请求查询存储系统，否则在判断的时候，因为缓存在构建还没有准备好。

  作者回复: 通常情况下，业务线程数量要远远大于后台更新线程数量。假设 20 台 64 核机器，每台机器 256 线程，业务线程就是 5120 个，后台缓存更新线程数量一般 8~32 就足够了。 如果缓存设计是只能一个线程更新，那确实也只能用锁了

  2018-06-05

  **

  **4

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572402820.jpeg)

  sunny

  之前系统用阿里云 memcached.有一段时间缓存总是失效。后来发现随着业务的增长，缓存的值越来越多。同一个 value 下的值过多会导致缓存系统存储失效。进而导致了文中提到的缓存血崩的情况。后来限制了缓存内容大小。解决了问题。

  2018-06-05

  **

  **4

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572402821.jpeg)

  探索无止境

  文中提到了缓存穿透存储数据不存在的情况，存储空对象，但是如果黑客恶意发起连续的攻击，而且 key 不相同，那么也会让缓存服务器的内存被迅速占满，这个方案感觉还是有些问题的

  作者回复: 确实没办法😃😃

  2018-06-05

  **4

  **4

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572402822.jpeg)

  Only U

  我来说说我做过的一个项目设计的缓存策略吧，因为需要实时查询所有 open 状态的基础订单列表信息，所以有个后台进程每分钟刷新一次缓存。但因为 open 态 order 太多，导致 redis 序列化与反序列化过程太久而连接中断，后来我采用的一个方案就是根据每次查询必选的组合查询条件分别分组然后以单个查询值作为 key 放到缓存中，这样既达到了按照查询条件过滤的情况，又缩减了每次存取数据的字节数。可能比较简单吧，感觉也没有什么特别的。哈哈😄

  作者回复: 我们用过另外一种方式：将查询条件组合成字符串再计算 md5，作为缓存的 key，优点是简单灵活，缺点是浪费一部分缓存

  2018-06-11

  **3

  **3

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572412823.jpeg)

  星火燎原

  如果用 redis 做分布式锁 从业务上设置超时时间为 1s 但是有一些逻辑单元确实需要执行比如 3s 才能释放掉锁。那么这种“正常的异常情况”应该怎么解决呢？

  作者回复: 那为何不直接设置为 3 秒超时？

  2018-06-05

  **3

  **3

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572412824.jpeg)

  Snway

  订单设置的缓存有效期是永久的，但再一次上线后，更新缓存的后台线程出问题，导致用户查看不了最新订单数据，引起大量客诉！

  作者回复: 重启缓存服务器😂

  2018-06-05

  **

  **3

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572412825.jpeg)

  姜泮昌

  目前我们还没用上缓存技术，所有请求都直接访问了数据库，导致数据库集群压力大，cpu、内存、IO 常常过高，请问项目初用缓存，比如 redis ，有什么指导原则或技巧吗？是缓存热点 sql 还是热点功能还是根据其他原则缓存呢？

  作者回复: 数据库压力大就可以考虑缓存了

  2018-06-05

  **

  **3

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572412826.jpeg)

  J.Smile

  要点总结： ● 缓存穿透 ○ 访问的数据在 DB 和 cache 都不存在。 	■ 这种情况下 cache 访问不到，查 DB，DB 也没有所有不缓存。形成了一个恶心循环，每次都要穿透到 DB，导致 DB 访问压力。办法就是：给访问的 Key 设置缓存一个默认值。这样就不会再查 DB 了。 ○ DB 中虽然存在数据，但放入 Cache‘需要很久时间。 	■ 因为查 DB 得到的数据放入 Cache 需要很长时间，在这段时间内都会有大量请求穿透到 DB。解决办法就是优化程序加快缓存速度。 ● 缓存雪崩        指的是缓存失效后引起的系统性能急剧下降的情况。从小范围引起大范围的性能问题。 比如分布式集群环境中，当缓存失效之后，集群中每台机器都会受到大量请求读取缓存失败，那么这些请求就会去读取 DB 来生成缓存，导致数据库压力。 解决办法： ○ 更新锁 	■ 分布式集群系统中要保证每台业务机器只有一个业务线程能去生成缓存。同时利用分布式锁🔐机制来保证集群所有业务机器中也只有一台机器能够生成缓存，避免因为集群规模太大的时候每台机器都更新缓存导致的雪崩。 ○ 后台线程定时更新缓存 	■ 缓存本身设置为永久，由后台线程定时更新缓存。这种方案可能出现缓存系统由于内存不够踢到一部分缓存数据。那么就会有一些请求读取不到缓存导致看起来数据丢失了。所以后台线程可以多一个职责，即定时读取缓存，发现缓存被踢立即更新缓存。定时间隔不能太长，不然缓存踢掉之后太久不能被读取到，导致用户体验变差。

  2020-12-10

  **

  **2

- ![img](data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QN5aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0MCA3OS4xNjA0NTEsIDIwMTcvMDUvMDYtMDE6MDg6MjEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YWE3YmZhMDItMzBhMC00MDg3LTg3MmYtOGMwMjMxNjNhZWRjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI2MTlEODM3NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2MTlEODM2NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTYyRTNCMDNBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTYyRTNCMDRBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRm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)

  木头旮瘩

  二楼@loveluckystar 童鞋说的问题，感觉问题并不是出在缓存机制上啊，有一台 es 出问题了，拖慢了整个系统，那把这台 es 拿掉呗，从其他 es 中查到数据后再更新缓存，缓存就可以继续命中了，等 es 问题修复后再重新加入集群。

  作者回复: 很多时候 es 出问题的时候你不一定知道，而是事后定位才发现根因是 ES

  2018-11-01

  **

  **2

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572412827.jpeg)

  刘鹏

  缓存的用法还是不清楚，目前只是把基础数据放在 redis 中，但是基础数据并没有很大的性能问题，所以我感觉用处不大，而有性能问题查询列表因为有经常性的修改，所以没有存在 redis。我现在的理解是讲读多修改少即时性要求不高的热点数据存储到 redis，那对于上述查询列表怎么使用 redis 呢

  作者回复: 就算是修改频率是一分钟，缓存在这一分钟也是有很大作用的，因为一分钟可能就是几千上万次读操作了，所以不要以为要一天都不修改的数据才能用缓存

  2018-10-15

  **

  **2

- ![img](data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QN5aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0MCA3OS4xNjA0NTEsIDIwMTcvMDUvMDYtMDE6MDg6MjEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YWE3YmZhMDItMzBhMC00MDg3LTg3MmYtOGMwMjMxNjNhZWRjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI2MTlEODM3NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2MTlEODM2NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTYyRTNCMDNBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTYyRTNCMDRBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRm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)

  hello

  华仔，请教一下文中提到缓存热点问题，通过多副本方式解决，给每个副本的 key 设置一个编号，再随机读取，那么随机到的副本过期了要重新生成缓存吗？不生成怎么返回数据呢？

  作者回复: 所有缓存过期都要重新生成呀，如果正好读到一个过期的副本，可以继续用，缓存本来就不要求强一致性的

  2018-10-09

  **

  **2

- ![img](https://static001.geekbang.org/account/avatar/00/12/66/d9/8953d6c6.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  秋天来了

  对于前面提到的双 key 机制，可以改成这样的，还是一个 key，但是他的 value 附加一个有效时间，如果你读这个 key 中的数据，根据有效时间判断，他是已经失效了，这次，先把这个结果返回，然后通知去更新缓存，这样可以节省一个 key1。

  作者回复: 这样做的性能代价有点大，每个 key 读取的时候都要进行这个解析，而缓存的访问量又很大

  2018-08-14

  **

  **2

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572412829.jpeg)

  yisshengyouni

  如果发现某个业务的缓存可能存在不一致问题，如何批量失效这些缓存呢，因为不能拿到所有的 key。 我们现在的做法是对每个业务加上一个前缀，如果不能确定哪些 key 出现不一致，就升级这个前缀，不知道还有没有好的方式？

  作者回复: 没有太好的办法，一种是缓存服务器重启，一种是将 key 前缀配置在文件中，全部失效的时候换一下配置就可以

  2018-08-05

  **

  **2

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/132.jpeg)

  大光头

  我们遇到的问题是代码 bug 导致缓存没有过期时间，缓存很快满了，缓存命中率降低，造成对业务很大的压力

  作者回复: 做好监控就可以及时发现

  2018-06-06

  **2

  **2

- ![img](https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  冰糕不冰

  老师请教一下，比如数据库连表查询的分页结果，这样的数据怎么设计存入缓存了？  比如就用一个 key，然后存储数据库查询结果的 json 吗？这个一直比较困惑。不知道 key 的设计怎么比较好。  感谢

  作者回复: 一般分页缓存，缓存 id 列表，不要缓存所有数据

  2018-06-05

  **

  **2

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572412831.jpeg)

  Regular

  在 缓存雪崩的 2.后台更新中“缓存系统内存不够时，会‘踢掉’一些缓存数据”，既然是内存不够那么总会有不在缓存里面的数据。后面的两种解决方式怎么能解决这个问题呢？

  作者回复: 一定程度上缓解，不能完全解决

  2018-06-05

  **

  **2

- ![img](https://static001.geekbang.org/account/avatar/00/0f/ba/78/3821b5b1.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  啊哈

  如果采用商品分页缓存，怎么实现更新呢，商品对实时性还是有要求的吧？比如更改价格，或者新上架的商品，怎么能比较实时的展现？还有商品页还是很复杂的，除了筛选还有很多的排序等等，这些场景怎么应用缓存吗？

  作者回复: 缓存常见的列表操作，没法缓存所有的列表，因为搜索的条件太复杂了

  2018-06-05

  **

  **2

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572402814.jpeg)

  byte

  想请教下对于流式音视频数据，类似优酷和爱奇艺这种网站后台的缓存系统如何设计比较合理？有没有推荐的方案或者书籍？谢谢！

  作者回复: 如果是媒体内容的缓存，那是 CDN 流式缓存的范畴，普通的后台缓存没什么特别的

  2018-06-05

  **

  **2

- ![img](https://static001.geekbang.org/account/avatar/00/10/ed/00/d89a657c.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  钱浩亮

  老师我想问一下，redis 有更新锁吗。再高并发的情况下，可以用吗

  作者回复: redis 的 SETNX 可以当锁来用，至于高并发是否可用，要看你期望达到多高的并发了，毕竟这是跨网络的访问，而且是单机支持，具体性能你要实测

  2018-06-05

  **

  **2

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572412834.jpeg)

  ZHANGPING![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/8ac15yy848f71919ef784a1c9065e495.png)

  在网上看到过一个有意思的方案：把所有确定的 Key 都放在布隆过滤器，先判断 Key 是否存在，来避免缓存穿透。

  作者回复: 这个方案有以下几个落地的问题： 1）要求每次写的时候都更新布隆过滤器，读的时候判断布隆过滤，对于缓存这种高性能计算场景，这个影响还是比较大的 2）布隆过滤器也只能放在缓存中，不能放在各个应用程序内，布隆过滤器本身的读写需要做到高可用高性能，全局互斥 3）布隆过滤器不能删除数据，缓存过期后布隆过滤器会失效 所以布隆过滤器一般用在爬虫 URL、事件数据（带时间戳，只增不删）这种场景

  2021-06-28

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572412835.jpeg)

  汝林外史

  感觉缓存雪崩的那两条解决方案都是应对热点大 key 过期导致的缓存击穿的吧？？缓存雪崩是因为大量 key 同时过期引起的，只需要为不同的 key 设置不同的过期时间就好了。

  作者回复: 你说的缓存击穿就是文中的缓存穿透，穿透的意思就是缓存没起作用，也就是说缓存中没有对应的数据；大量 key 同时过期在实际情况中反而比较少见，因为不同的 key 生成时间、过期时间本来就是不同的，除非缓存不够被踢出，自然过期的场景下不会出现大量 key 同时过期，真正雪崩比较常见的是一两个热点 key 过期后引起系统性能急剧下降。

  2020-11-30

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/0f/b5/28/65f8ef3c.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  govern

  “业务线程发现缓存失效后，通过消息队列发送一条消息通知后台线程更新缓存。” 这里怎么确定失效的数据是被“踢掉”的，还是被攻击的不存在数据，如果是后者，感觉又陷入了一个循环。

  作者回复: 后台更新线程来判断，可以生成一个空缓存来应对攻击

  2020-07-24

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/16/a7/8e/588d737e.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  马威

  我觉得还有一点 就是缓存 key 的问题 比如 缓存的数据结构发生了变更，这时候需要将对应的缓存 key 进行升级 进行区分  上线时，将新的缓存 key 进行缓存预热  可以直接过渡到新的缓存，避免出现脏缓存的问题

  作者回复: 确实可以这样做，但是一般会建议代码兼容，因为有时候找出所有需要预热的键并不那么简单

  2020-06-11

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572422838.jpeg)

  信信

  缓存雪崩的后台更新方式，解决“踢掉”的第二种方式提到“存在就不执行更新操作”。 那量大的时候，还是可能多个后台线程读取到更新消息，然后操作数据库吧？ 要不就是设计同一个缓存打到消息队列的同一个分区，然后只能被同一个后台线程读取？ 这里配合更新锁会好点么？

  作者回复: 加锁当然是最可靠的方式

  2020-04-11

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572422839.jpeg)

  benamazing

  为了避免大量缓存在同时间雪崩，我们的做法是，每个 key 设的缓存过期时间是在一个时间范围内的随机数。比如说随机缓存 1-7 天

  作者回复: 你这个随机范围有点大啊😂

  2020-03-29

  **2

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572422840.jpeg)

  胖胖的程序猿

  《缓存热点的解决方案就是复制多份缓存副本，将请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力》 如果只是单纯解决缓存服务器压力，那么只有一个副本，也可以用 redis 集群可以解决吧。 多个副本不同失效时间，解决的是保证缓存一直都有效

  作者回复: 是的，redis 可以的

  2020-01-19

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572422841.jpeg)![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,w_14.png)

  技术修行者![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/89yyff4c4c2e2b73ce4931bb01a6a943.png)

  在设计缓存架构的同时，要考虑下面几件事情： 1. 缓存穿透 2. 缓存血崩 3. 缓存热点 缓存穿透是指业务没有在缓存中找到想要的数据，从而去存储系统中重新查询。 缓存血崩是指在缓存过期但还没有刷新之前，业务请求数据时，因为缓存中没有，所以每个线程都查询 db，从而拖垮整个系统。 缓存热点是针对热点进行单独的缓存管理。注意不要把所有缓存的过期时间设置成相同的，否则容易引发系统血崩。

  2020-01-04

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/10/ce/be/5cf3f1a0.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  junshuaizhang

  评论区更精彩呀

  2019-08-16

  **

  **1

- ![img](data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QN5aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0MCA3OS4xNjA0NTEsIDIwMTcvMDUvMDYtMDE6MDg6MjEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YWE3YmZhMDItMzBhMC00MDg3LTg3MmYtOGMwMjMxNjNhZWRjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI2MTlEODM3NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2MTlEODM2NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTYyRTNCMDNBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTYyRTNCMDRBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRm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)

  whhbbq

  “分页缓存的有效期设置为 1 天” 请问大神，这个 1 天时间指的是这个缓存在 1 天时间内一次访问都没有就过期吧，还是不管有没有访问，到了 1 天时间，就过期？

  作者回复: 后一种情况

  2019-04-12

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572422843.jpeg)

  xiao 皮孩。。

  这种情况的解决办法比较简单，如果查询存储系统的数据没有找到，则直接设置一个默认值（可以是空值，也可以是具体的值）存到缓存中，这样第二次读取缓存时就会获取到默认值，而不会继续访问存储系统。 用布隆过滤器解决这个合适，不存在是一定不存在的。

  作者回复: 布隆过滤器怎么做分布式呢？好像也挺麻烦的呀

  2019-03-27

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572422844.jpeg)

  挨踢民工

  我所遇到的业务场景是这样，在现有的资源情况下，我司只有一台 oracle 服务器，一方面做 OLTP 业务，又做 OLAP 业务，订单表接近 900w。基于订单数据开发 boss 系统，以日单位。复杂 sql 查询通过后台 java 应用写入到缓存中，前端用 PHP 调用缓存。后来发现这条路有问题，针对此项目大部分 SQL 命中率低，所以改变策略，在 PHP 前端项目中分出了一道缓存层，用完整的 sql 语句 hash 后做为 key，数据作为内容。由于 boss 系统单一个页面都会调用 20 个左右的 sql 语句。问题又出现了，用户首次访问效率极低（由于 SQL 复杂，最快的 SQL 响应都要 1s，最慢 4s）。前端所有请求改为 webstocket 方式进行通信，PHP 项目层改为协程并发访问缓存层。项目越来越复杂

  作者回复: 想省钱，拿 MySQL 做 OLAP 呀，你们现在这样太复杂了

  2019-03-22

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572402818.jpeg)

  kissrain

  华仔，请教以下几个关于缓存引起的问题 1. 缓存是不淘汰还是淘汰还是更新缓存？ 2. 如果是不淘汰缓存那么如何解决数据的一致性问题？ 3. 定时缓存过期后，缓存生成时间比较久(如需要 2s 生成)，这种是否可以用双缓存 key 的形式（两个相同 key，一个过期一个不过期）？   是否还有更好的办法解决呢？ 4. 使用缓存淘汰方式，缓存和数据库的一致性问题根本原因是非原子操作，如果 A 删除了缓存后 B 去读，发现没有缓存，   然后 B 再去读数据库的旧数据，这时候 A 才去更新数据，如何避免一致性问题？关键:B 比 A 先访问数据库。

  作者回复: 1. 缓存策略要根据业务需求来看，不是固定的，请参考架构设计原则的合适原则 2. 强缓存一致性需要用锁保证

  2019-01-07

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572422845.jpeg)

  allen.huang

  我遇到过缓存穿透的问题，当时整个系统都进不去～_～！当时的设计也是通过先读缓存，如果没有在从数据库中读取。 结果刚好外访问的时候，redis 缓存失效，大量请求数据库，导致数据库崩掉。 解决，先把系统关闭，服务器重启，再对缓存进行预热，最后启动系统

  作者回复: 这样处理耗时有点长吧，不过也没办法了

  2018-12-27

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/132-16617956572422846.jpeg)

  咩咩咩

  小白不是很理解热评第一的双 key 策略。双 key 浪费了一半的储存空间，不如给 key 的值添加一个时间戳，然后读取数据的时候判断值的时间戳和当前时间戳大小看是否需要异步更新数据，这样是不是更好？

  作者回复: 这样浪费 CPU 运算能力呀😀

  2018-12-13

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572422847.jpeg)![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,w_14.png)

  Geek_fb3db2

  我们缓存采用文中说的代码实现方式，在系统启动把所有需要缓存数据加载到内存，其实是使用 AOP 方式缓存对应的方法，指定缓存何时重加载等操作，然后集群之间通过中间件通知其他机器更新缓存，有一次由于其他机器未收到缓存更新通知，导致该机器缓存是旧的，最终导致系统切日不对。 另外问下：文中提到的缓存穿透解决方案为 对未命中缓存的 key 设置一个默认值，那如果源源不断发送未命中缓存的请求，那么缓存里面不就存了很多数据吗，会把系统搞挂掉，我们策略是未命中是否需要从数据库获取，感觉也不太好。

  作者回复: 缓存有过期时间，缓存系统也有 LRU 之类的淘汰策略，不会导致缓存系统挂掉。

  2018-12-06

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  jaryoung

  因为缓存的不及时更新导致得到的数据不是最新的，最后直接不使用缓存。事实告诉我，系统不是达到一定的系统查询性能瓶颈，别一开始就用缓存。

  作者回复: 你一定踩过坑😂

  2018-11-08

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/0f/67/29/b0ec5430.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  greatcl

  对于文中后台更新的例子有个疑问，如果当缓存系统内存不够时，一部分缓存被踢掉，后台去频繁读取缓存，发现被踢掉之后就立刻更新缓存。那这个时候因为内存不够，不是会有其它缓存被踢掉然后产生问题吗？

  作者回复: 1. 缓存被踢是正常的 2. 不是每个缓存被踢都会引起问题，缓存有算法的，例如 LRU

  2018-09-29

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572422850.jpeg)

  黄哲

  有个榜单的计算过程比较复杂，大概要算 3 秒多，用户反馈榜单数据不对，由于对业务不熟悉，不知道计算过程这么复杂，就直接删了缓存，重新计算榜单，结果很悲剧，整个业务线挂了，一个典型的缓存雪崩案例。 不过用了另一种解决的方式，将榜单计算的结果存在一张榜单表，缓存失效时直接读取这张榜单表，也算是一种思路吧。

  作者回复: 相当于双保险

  2018-09-25

  **2

  **1

- ![img](data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QN5aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0MCA3OS4xNjA0NTEsIDIwMTcvMDUvMDYtMDE6MDg6MjEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YWE3YmZhMDItMzBhMC00MDg3LTg3MmYtOGMwMjMxNjNhZWRjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI2MTlEODM3NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2MTlEODM2NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTYyRTNCMDNBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTYyRTNCMDRBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRm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)

  laurencezl

  后台更新策略怎么选择哪些数据是需要缓存的？缓存的数据不是依赖查询么？

  作者回复: 是你选择的，程序员设计的时候需要确定哪类缓存要后台更新

  2018-08-28

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572422851.jpeg)

  正是那朵玫瑰

  引用“我们用过另外一种方式：将查询条件组合成字符串再计算 md5，作为缓存的 key，优点是简单灵活，缺点是浪费一部分缓存” — — — — — — — — — — — — — — — — — 没有太明白，为什么会浪费一部分缓存呢？

  作者回复: 用户输入的查询条件千变万化，排列组合太多了，很多的查询只会出现一下，缓存其实没有必要

  2018-08-27

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/10/25/2f/3266c0da.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  lawlielt

  我们也是双 key，一个存数据不过期，另一个存过期时间。过期时间的 key 用作多线程锁。

  2018-08-22

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/12/16/eb/5ce7e617.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  周威

  我们是 cdn 缓存通用 url 数据，rocksdb 缓存持久化实体数据，redis 缓存易变业务数据，空数据缓存防止穿透，每次数据库返回同时异步写 rocks 作为降级雪崩网络延迟等意外情况的数据，设置开关可以开启本地缓存，同时启动定时任务去尝试读取最新 db。由于分布式，真正开启降级方案由于每个机器本地不一样，会出现状态不一致，没有方案似乎

  作者回复: 你们的缓存方案很完善，但太复杂，容易出小问题，通常建议宁愿多花点机器成本，而不是设计这么复杂的缓存方案，《unix 编程艺术》中有个原则：宁花机器一分，不花程序员一秒

  2018-08-09

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572432854.jpeg)

  走神儿

  我们的缓存系统设计为三种，一种行级，就是数据库一条记录，表级，数据库表的查询结果，库级，连表查询结果，三种策略都是根据业务查询来缓存的。失效策略为更新 A 表，则 A 表的行级，表级，所有库级都失效；这样下来其实库级命中最低，但我们的代码规范是不到万不得已不能使用 join

  作者回复: 看起来性能高，实际上付出的复杂度代价更高，缓存管理会比较麻烦，一般不建议这么复杂的设计，很容易出各种数据不一致的问题

  2018-08-02

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  又双叒叕是一年啊

  大神们的智慧也提供一个互相交流学习的机会赞一个👍

  作者回复: 读者卧虎藏龙👍👍

  2018-07-22

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572432856.jpeg)

  krugle

  我们的缓存都是下载业务代码里面，有数据不一致的地方要到处翻代码，有什么好的方法解决这个吗，百度了好多没结果

  作者回复: 缓存框架，由框架统一管理缓存,看看 Ehcache

  2018-07-16

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/11/d9/c9/66feceac.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Simple_Zhang

  华哥，请问如何保证缓存和数据库的一致性，例如用户修改了一项配置，是先更新缓存还是先更新库？如何保证缓存和库都更新一致呢😊 

  作者回复: 先更新库好些，因为更新库成功后即使更新缓存失败，缓存也有过期时间。 如果要保证一致，更新库前先删除缓存，然后更新库，再更新缓存，但即使这样，也可能出现缓存和库不一致，因此要做到绝对一致是很复杂的，需要用到 zk 这类协调软件，一般不建议这么做，没必要

  2018-07-04

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/10/d5/41/99b90510.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  孟老师

  做游戏开发，数据先写入 redis，用一个线程去读，然后写入 mysql。遇到 redis 满了的情况，就是读的速度赶不上写的。很崩溃

  作者回复: 读的时候可以一次读取多个，进行批量操作，性能会好很多

  2018-07-04

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572432859.jpeg)

  郭柱

  华哥，我现在来阿里云工作了，有机会希望能拜访华哥，和你分享一下之前我在上家公司做的一个系统。 之前做过一个销售规则系统，这个系统服务于产品查询和销售。查询 TPS 峰值过万，查定比在 100 到 200 之间。规则系统的规则放到缓存中，同时支持规则实时发布到生产系统，性能测试指标是 50ms 就可以加载到生产系统。上线当晚，我就不停的在做规则修改，几分钟后查询系统变慢，开始大面积报警，当晚查询系统也在上线，后来过了一段时间发现是我们拖慢了整个业务链条，因为我们是新系统被迫下线改造，后来把缓存系统设计为 AB 缓存，每次加载新规则就加载到备用缓存中假设当前为 B 缓存，然后从日志中取 1000 生产查询请求，去查询最新更新的缓存，当 100%成功后，将生产请求切换到 B 缓存，实际时间也就是秒级切换完成，这样保障了销售规则系统正常运转下去的，目前也还是这个架构。这种不考虑成本的方案是不是只有在国企才会用到？

  作者回复: 互联网用得更多啊，现在内存不值钱了，缓存大胆用😂

  2018-06-27

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/0f/56/cb/0b731cd6.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,w_14.png)

  想飞的鱼

  我 off 业务中涉及到很多金融各个分类的数据(股票，基金，债券，期货，宏观...),每个分类又有不同的业务类别数据，例如，股票有基础行情数据，还有各个上市公司的基础信息数据，财务数据......，由于业务场景，我们做缓存用了主动后台程序缓存，可以缓解数据库压力。但是这样造成了部分及时的行情数据无法及时更新到缓存中，后面我们部分业务改成了近期查库，及时查缓存，从一定程度解决问题。 但是感觉现在开发业务复杂度变大了，需要主动缓存，业务程序查历史缓存，最新数据，进行合并。 我们深知还需要继续学习，寻找更好的解决方案。感谢老师的分享。

  作者回复: 希望对你有帮助😊

  2018-06-22

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572432861.jpeg)

  bigticket

  为应对读写不平衡，高并发读取的业务场景，加入缓存机制；缓存又涉及到缓存穿透、缓存雪崩等问题，需要设计合理的过期时间，分页读取等

  2018-06-08

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/10/af/f5/5580f53a.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  万岁爷

  要是能写些 demo 就完美了。demo 可以课件形式，放到网盘

  作者回复: 你可以自己写，不难

  2018-06-06

  **

  **1

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572432863.jpeg)

  顾海

  恶意攻击导致的缓存穿透，如果你的 key 不是非常多，可以使用布隆过滤器

  作者回复: 实际应用比较难把所有 key 列出来

  2018-06-06

  **

  **1

- ![img](http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqGaJsoQicG7Bp8cUjUkevAp5Sm8ZXy5vl5TVk4CDrq5UAoI9VicK5wwjCdk66FVRbGziaWXHgO52l1Q/132)![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,w_14.png)

  Geek_06d12d

  后台更新是利用不过期加后台更新，一旦淘汰就使用消息去主动更新，并发上来了会发很多消息感觉有点白费，用锁移步去更新不是更好吗。还有既然用到消息为啥不每次更新数据的时候发消息去更新缓存，还要去定时

  作者回复: 用锁的话，就需要业务代码里面嵌入缓存更新逻辑了；后台更新可以和业务代码解耦。 定时更新适合生成缓存需要时间较长的缓存，如果发消息的话，会有很多业务线程发重复消息。

  2022-08-12

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572432865.jpeg)

  杨恒

  建议参考 HTTP 协议中描述的 cache。

  2022-07-27

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/12/da/c1/b438893e.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,w_14.png)

  湖

  可以参考下开源项目 layering-cache 的实现

  2022-07-21

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/2b/c2/e9/892185ca.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  肖向东

  未能获取更新锁的线程要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。这句感觉不对，未能获取更新锁的线程应该可以读缓存，但没法更新缓存。

  作者回复: 没有获取更新锁的线程此时读取缓存就是得到空值，没有说它要更新缓存呀

  2022-05-26

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/1f/bd/d0/070824d1.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,w_14.png)

  空城。

  应对缓存雪崩时，第一条留言的双 key 方案会造成内存消耗翻倍。 我的理解是 redis 的 key 本身可以获取到过期时间，我们能不能设置一个阈值，每次查询 redis 的时候，去看这个 key 的过期时间，如果低于阈值，比如 10 分钟，则重新更新缓存，延长时间。这个方案和双 key 的方案对比有什么缺点吗

  作者回复: 双 key 方案只是用在一些特殊的 key 上，不会所有的 key 都用双 key 方案，所以内存消耗总体上其实不一定有很大影响； 你的这个方案确实是不会浪费内存，但是每个线程每次读取 key 都要两次读取，实际上是耗费了 CPU 和网络。

  2022-04-10

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572432869.jpeg)

  Geek_eb522e

  这里之前做存储的时候遇到很多 case，有存储空间设计不合理导致大量无效缓存，有热点的等等。一个印象比较生成的例子是，es query 缓存，举个例子，a 用户搜索“周杰伦歌曲”，会返回《东风破》《告白气球》等 10 首歌曲的各种详细信息，b 用户搜索“jayzhou 歌曲”，也会返回 10 首周杰伦的歌曲，甚至是和 a 用户完全一样的，那么问题来了，如果粗暴的以每个 query 为 key、返回结果为 value 来缓存的话，每首歌曲的详细信息都缓存两遍，造成资源的极大浪费。如果将可以以 id 或者歌曲名为 key，歌曲信息为 value 缓存在 redis 里，已 query 为 key，歌曲 id 列表为 value 缓存的话，读取两遍 redis 就可以获取信息，虽然多了一次 redis 访问，但是资源空间上却是优化不少，记得差不多存储减少到之前的 5%左右了。

  作者回复: 这个优化技巧不错，以时间换空间，时间上的损失对业务没有影响

  2022-03-26

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572432870.jpeg)

  八喜

  缓存热点这个之前的确是没有想到，学习了

  作者回复: 加油 ：）

  2021-12-22

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572432871.jpeg)

  grey927

  缓存穿透的状况可以通过布隆过滤器来解决

  作者回复: 理论上可以，但是实际上不太可行，你想过没有，大部分的情况下访问是 OK 的，只是在缓存失效或者被攻击的时候才会出现缓存穿透，但是为了维护布隆过滤器，每次读写都要去访问布隆过滤器，因为程序并不知道什么时候被攻击了，这就导致了正常的时候，布隆过滤器实际上没有什么作用还影响性能； 另外，缓存的 key 并不一定是简单的和数据库或者存储系统的主键一一对应的，这就导致你不同的缓存访问失效后要进行的布隆过滤器的判断逻辑不同，这就很麻烦了

  2021-12-10

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/10/33/b0/6b37f63d.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  cppby

  我要早看到这个文章。 当初设计业务热点缓存的方案就不会被人喷了。。。

  作者回复: 说出你的故事 ：）

  2021-10-07

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572442873.jpeg)

  jian

  请问华仔，热点数据存在相当的突发性，临时的扩容似乎也来不及，能否从缓存架构角度如何避免类似微博宕机的事件？ 作者回复: 1. 限流 2. 容器化+动态化 3. 业务降级，例如限制评论 ---------------------------------------------------------------------------------------------------- 请问老师， 容器化+动态化是如何解决热点数据？

  作者回复: 用容器来建更多的缓存副本

  2021-09-29

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/13/36/94/0b969588.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  青年祭司![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/2012c563b22c76a7f1f97c22c3ddf830.png)

  老师，曾经接触过一个 c2c 的电商项目，买家在浏览商品列表时会生成缓存，但是如果卖家修改商品信息或者增加商品就需要及时更新缓存，以展示最新信息。如果持续有大量卖家更改商品信息那缓存会更新的很频繁，也就失去了意义，请问这种情况怎么设计缓存。

  作者回复: 列表页缓存不需要卖家更新商品就更新缓存，列表页的信息只是商品详情页的一些关键信息，就算短时间不一致，用户进入商品详情页后看到的是最新的信息就可以了； 另外，列表缓存是按页缓存的，一页里面 10 个商品，这 10 个商品的更新频率不会太高，你不要一个商品更新就更新所有列表页的缓存

  2021-09-23

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572442875.jpeg)

  11 月的萧邦

  后台更新方案除了缓存被踢掉这个问题之外，还会有个问题：就是如果数据库的业务数据有更新了，那么缓存在定时任务更新之前读到的都是旧数据。

  作者回复: 是的，一般会通过消息队列发个更新消息给后台进程触发立即更新

  2021-07-26

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572442875.jpeg)

  11 月的萧邦

  我之前一个项目的缓存方案有点像后台更新，由后台刷新缓存并设置永久有效期。但有一点区别：就是如果数据库数据有更新了，在下一次定时任务更新缓存之前用户读取到的都是旧数据，而我们业务要求数据更新后要立即生效，所以我们在数据库更新业务数据之后会立即更新下对应的数据。

  作者回复: 方案可以灵活组合的，课程中介绍的方案你可以理解为基础方案，你可以排列组合调整

  2021-07-26

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572412834.jpeg)

  ZHANGPING![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/8ac15yy848f71919ef784a1c9065e495.png)

  内容和评论都很精彩，学习了~~~

  2021-06-28

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/10/23/4b/5578cbd1.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  IsaacGao

  「业务线程发现缓存失效后，通过消息队列发送一条消息通知后台线程更新缓存」这里是不是也要加锁？如果不加锁应该会出现缓存击穿

  作者回复: 可以加

  2021-04-27

  **2

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572442877.jpeg)![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,w_14.png)

  DFighting

  简单总结下今天的学习内容： 前提：缓存是为了减轻存储系统的压力，不能要求缓存和存储系统一样(数据完全正确、准确的同时还得快) 1、缓存穿透：缓存不生效，导致压力如洪峰般涌入存储系统。记得之前看过一个博客说可以加个熔断保护机制 2、缓存雪崩：缓存挂了，拖垮整个业务系统。关键问题是何时同步缓存数据，可以分布式锁：减小并发或者消息队列削峰填谷程序更新缓存 3、缓存热点。每次有大瓜，微博总会挂。解决方案多份数据，注意设置不同的过期时间，不然也会在未来某一刻给存储系统带来很大的压力。 总结一下，我理解的缓存，定位和业务系统是不一样的，设计架构的适合不能单独只考虑性能如何，多个结构之间的协调联动以及问题发生的时候如何防范也得考虑清楚

  2021-03-08

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/15/4a/86/c7bd910e.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  程辉

  后台更新缓存的方式，需要多维护一套缓存列表吧？

  作者回复: 什么叫“多维护一套缓存列表”？如果是说后台要记录哪些缓存要更新的话，那是肯定需要的。

  2021-03-08

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572402815.jpeg)![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,w_14.png)

  escray![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/d57fddfa5b2c2ce3071e92304da8af62.png)

  好像有一点专栏里面没有提及，就是缓存其实是比较贵的，不能把过多的数据放到缓存里。 看到留言里面 @bluefantasy 提到的 Redis 双缓存策略，这个还真是挺巧妙的，不过成本也高一些。 Memcached 和 Redis 的选择，估计也会成为面试题目。在之前的专栏里面提到过，Memcache 是纯内存缓存，支持基于一致性 hash 的集群；而 Redis 支持持久化、数据字典、主备、集群…… 后来简单的检索了一下，发现这个问题几乎不需要考虑，无论是从 Google Trends 上看，还是 Stack Overflow 上的回答，Redis 都是更好的选择，除非你本人是 Memcached 专家或者团队在 Memcached 上投入很大。 Redis is more powerful, more popular, and better supported than memcached. Memcached can only do a small fraction of the things Redis can do. Redis is better even where their features overlap.  — https://stackoverflow.com/questions/10558465/memcached-vs-redis 在留言里面还看到有人两个都用的，Memcached 用于缓存对象，减轻数据库负载；Redis 用于有序集合，适用于时间序列数据。 在简书上的《memcached redis 对比分析》https://www.jianshu.com/p/e94fa7340923，可能是中文网络里阅读量比较大的一篇。 Memcached 的优势似乎只有小型静态数据（HTML 代码片段），我怀疑其实优势也没那么大；另外有人说 Memcached 的扩展性更好，我有点怀疑；最后就是有人提到，Memcached 可能相对来说占用内存稍微小一点，这个我觉的有可能。 如果只讨论 Redis，可能对于架构设计来说过于局限了，高性能缓存架构不止于此。

  作者回复: Redis 会更复杂一些

  2020-09-08

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572442879.jpeg)![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,w_14.png)

  piboye

  缓存的一致性问题这里讨论的比较少，自己的写读一致。

  2020-08-26

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572442879.jpeg)![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,w_14.png)

  piboye

  缓存更新还有一种方式，读写都使用一致性 hash，正常情况下都写都会落到相同的机器，因为写还没设置的缓存，可以在当前进程内缓存解决，对于失效的更新，本地的锁机制也可以防止雪崩。hash 方式就是会牺牲一定的可用性，再比较短的时间内出现服务不可用。hash 不一致可能导致多个线程去拉数据库，但是这种情况下并发还是更少很多。

  2020-08-26

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572442880.jpeg)

  yyl

  “读多写少的数据，存储系统有心无力” 为什么存储系统有心无力？

  作者回复: 存储系统不适合做复杂逻辑处理

  2020-08-06

  **2

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572442881.jpeg)

  鱼

  关于缓存穿透第二类问题“缓存数据生成耗费大量时间或者资源”，爬虫这类恶意攻击导致的缓存无法发挥作用，老师提到“这种情况并没有太好的解决方案”。我倒是觉得 MySQL 给了我们很好的一个解决方案：实际像爬虫这种场景，MySQL 每时每刻都在经历--All 全表扫描，但是 MySQL 又要维护 Buffer Pool 缓存提高查询效率。是不是和老师提到的爬虫问题非常相似，大量数据只读一次导致常用的数据被淘汰。 MySQL 给出的解决方案是：优化 LRU 淘汰机制，将其分为 Young 区（链前部）+Old 区（链后部）。新刷新的数据智能放在 Old 的头部，只有再次读取到该数据，设置一个条件比如缓存被读了多少次、存活多长时间才能进入 Young 区。达到了这样的效果： 1.访问最多的数据能够保持在链表头部，快速访问。 2.那些偶尔刷一次的数据（爬虫访问量远比正常访问量少）很快被淘汰。 篇幅有限，没办法详细描述 buffer pool。抛砖引玉吧，感兴趣的同学自行查看《高性能 MySQL》

  作者回复: 你理解错了，这个问题的根本原因是生成缓存数据太耗费资源，不管你放在 old 区还是 new 区，生成缓存这个动作消耗资源都一样的

  2020-07-11

  **2

  **

- ![img](https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo6qUrJUgVNIMeWy4ffwR7AiahZSuiaOSGeicwSydRm0s5WUwzqxTib8hCuf6ticP8sKmabTf9WSgYHRxw/132)

  李卫卫

  缓存分片保证消除热点 key，是这个不错思路，不过缓存中不同 key 的数据一致性如何保证？

  作者回复: 后台统一异步更新

  2020-06-26

  **

  **

- ![img](https://wx.qlogo.cn/mmopen/vi_32/kibibtNMahiafQ3qM51Hu4yiaF3rybBiaJobRlBhUDTF67DtBKibKib66LcSSVOiaTmloA2noSic9hfntYlAsu9icIPKicE6Q/132)

  Ahaochan

  \1. 缓存穿透 Q1: 缓存不存在，流量直接打在 db 上 A1: 给不存在的数据加上 null 的缓存，或者用布隆过滤器，过滤不存在数据的请求 Q2: 缓存更新太久，流量直接打在 db 上 A2: 后台线程检测过期时间，及时续命 2. 缓存雪崩 Q1: 缓存同时失效，流量全打在 db 上 A1: 1 失效重新生成缓存的动作加锁，2 还是后台线程及时续命 3. 缓存热点 Q1: 热点数据导致缓存服务器压力过大 A1: 缓存副本分流

  2020-03-30

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572442884.jpeg)

  小喵喵

  关于缓存热点的解决方案有一个疑问：如果读取的谋一份缓存过期了，那就会穿透到数据库查询，然后写进入缓存，并设置一个随机的过期时间吗？

  作者回复: 是的，有一个更新后，其它的副本也更新了

  2019-10-21

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572442885.jpeg)

  @@fighting

  关于分页的存储我看到过的一个缓存方案是：不缓存整个页面，而是将页面的每一条商品单独缓存，第二次请求数据库的话只请求 id，然后根据 id 去缓存拿具体数据；这样虽然多了好多的内存访问 io，但是减少了内存的消耗

  作者回复: 这个就是简单的商品数据缓存，和分页关系不大

  2019-03-22

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/132-16617956572442886.jpeg)

  gkb111

  缓存就是为了减少存储系统压力。如何解决缓存和存储系统不一致的问题，及时更新缓存，防止多机多线程同时更新缓存，这也会导致系统崩溃，两种方式，分布式锁，或者后台更新机制。

  2019-01-23

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572422845.jpeg)

  allen.huang

  像有些配置类的，商品类的数据，我之前的做法是直接通过后台预热到缓存中，并且没有失效时间。采用 AOP 思想，后台有改动了信息，缓存也跟着变动。

  2018-12-27

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572422847.jpeg)![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,w_14.png)

  Geek_fb3db2

  缓存穿透： 不通过缓存 ，直接获取数据库数据，可能会把应用拖的非常满 缓存雪崩，大量缓存失效，需要重新加载缓存，导致线程间加载缓存缓存 缓存热点： 大量数据都通过一个缓存服务器，导致访问量非常大

  2018-12-06

  **

  **

- ![img](data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QN5aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0MCA3OS4xNjA0NTEsIDIwMTcvMDUvMDYtMDE6MDg6MjEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YWE3YmZhMDItMzBhMC00MDg3LTg3MmYtOGMwMjMxNjNhZWRjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI2MTlEODM3NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2MTlEODM2NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTYyRTNCMDNBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTYyRTNCMDRBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRm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)

  zero

  怎么没有讲讲缓存更新的问题，我觉得这也挺麻烦的

  作者回复: 缓存雪崩部分就讲了怎么更新啊，其它的更新没什么复杂的吧😄

  2018-11-23

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/11/70/23/972dcd30.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  allan

  想问下老师，您对分布式和集群的理解？

  作者回复: 后面有很多章节讲这部分

  2018-11-14

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/10/e9/e9/1f95e422.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,w_14.png)

  杨陆伟

  将查询条件组合成字符串再计算 md5，作为缓存的 key。======//请问这种方式有什么作用？例如查询出的商品变多或变少了，这个 key 马上就失效了

  作者回复: 查询结果不会影响 key 呢，至于说缓存不实时，这个没法避免，电商的商品缓存问题不大

  2018-09-17

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572452889.jpeg)

  文竹

  还没怎么深入接触过 Redis，业务规模小，主要用来保存 session，还没出现过问题。 缓存穿透重在缓存无数据或失效，缓存雪崩重在缓存穿透后引起的崩溃，缓存热点重在热点数据。

  2018-08-19

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  又双叒叕是一年啊

  华哥，请问下 redis 由于是单线程模型他的 setnx 分布式锁在高并发场景下会不会有性能问题？另外他的队列结构在 redis 多节点集群环境下是不是会有数据不一致问题？

  作者回复: 可以测试验证一下，我没有详细研究过

  2018-07-22

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/0f/42/4f/ff1ac464.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  又双叒叕是一年啊

  看评论也能科普不少好东西啊

  作者回复: 必须的，我也能学到很多😀

  2018-07-22

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/10/d5/b0/b560e561.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  bubble

  我们用过另外一种方式：将查询条件组合成字符串再计算 md5，作为缓存的 key，优点是简单灵活，缺点是浪费一部分缓存 这个有创意

  作者回复: 黑猫白猫理论😄

  2018-07-21

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/10/d5/b0/b560e561.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  bubble

  我们的系统就出现过类似的问题，开始的时候没有缓存，每次做活动访问量大的时候就会导致反应特别慢。后来通过加 redis 缓存解决了问题。 对于缓存雪崩问题，我们采取了双 key 策略：要缓存的 key 过期时间是 t，key1 没有过期时间。每次缓存读取不到 key 时就返回 key1 的内容，然后触发一个事件。这个事件会同时更新 key 和 key1。 对以上疑问，既然是雪崩了，多少个 key 也没用吧！雪崩在此作何理解？？

  作者回复: 雪崩是缓存读不到，大家都去读存储，你的场景是读取不到 key 就返回 key1，因此不会雪崩

  2018-07-21

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572452891.jpeg)

  孙振超

  在对 qps 有高要求的系统通常都会采用缓存，正所谓解决了一个问题之后就会有一个新问题出现，引入缓存在提升 qps 后最大的问题在于缓存 db 数据一致性问题。使用缓存的通常做法是先读缓存，缓存没有命中，就查询 db，而后将查询到的数据添加到缓存中。在这种使用方法下导致缓存 db 不一致的主要情况是 db 和缓存没有同步更新，比如先更新 db 后更新缓存可能会出现 db 更新成功而缓存更新失败的情况，如果是先更新缓存后更新 db 则可能会出现缓存更新成功而 db 更新失败的情况。而解决这个问题可能要引入消息中间件或者利用分布式锁来保证，这样又给系统带来了复杂性。

  2018-06-24

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572452892.jpeg)

  孙晓明

  我们的一个系统缓存是这样的：在数据库中定义了视图，将视图的结果缓存，永不过期；如果数据发生变动，先更新视图，然后再将视图结果更新到缓存中。后来也有用存储过程定时统计复杂的数据，并将统计结果存储到临时表中，程序访问时读取临时表的数据。

  2018-06-22

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/10/f2/53/2af50978.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  zwfec

  使用 update  +1 的系统挂过，其实就是一个信息页统计访问数，修改了解决方法，使用 js 写入内存，再定时写入库

  2018-06-11

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/10/cc/d9/20d4f7c2.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  大雁小鱼

  分布式缓存的设计关键点是什么？

  2018-06-10

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/10/7d/da/780f149e.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  echo＿陈

  关于缓存穿透，比如，对用户缓存，因为每个用户的访问时间是均匀分布的……也不会同时缓存失效……这时候缓存穿透问题不大吧

  作者回复: 这种是正常的，只有短时间内大量数据都没法命中缓存才算缓存穿透

  2018-06-08

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/10/d9/a3/2856b5b5.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Sonny721

  在以往的开发中遇到过这样的问题，某个数据做了缓存，key 为 k1，在后面的业务中发现也需要这个缓存数据，但是查询的 key 不是 key1，而是 key2，这种情况有什么好的解决方案么，曾经用过的方案是把 key1 与 key2 的对应关系也做了缓存，根据对应关系去缓存中查询想要的数据。类似的业务需求，有好的解决方案么？

  作者回复: 没明白，直接查 key1 为何不行？

  2018-06-07

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572452897.jpeg)

  正直 D 令狐勇

  老师这里把缓存击穿和缓存雪崩合并在一起讲了。

  作者回复: 你是说爬虫的案例是缓存雪崩？我理解不是的，雪崩是由于缓存不存在且高并发访问，穿透是由于缓存不存在或生成缓存需要耗费大量资源

  2018-06-06

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/11/13/e8/08b829a9.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  天天平安

  请问 阿里 hybiddb for mysql,hybiddb for postgresql 和 maxcompute 这三个产品有什么区别，分别在哪些情况选择对应的数据库合适？

  2018-06-05

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  小文同学

  公司业务部署在某公司云上，有一次 memcache 故障，导致返回的数据总是为 null。刚好系统设计是数据都先加载到缓存的，于是处理逻辑就认为系统里都没有数据，导致出现很大的数据问题。后来我们重新编写逻辑，不完全信任缓存进程，把一部分使用量较高的，数据不大的数据用 JVM 本地进行缓存。

  作者回复: 这里主要的问题是缓存使用不当，正常缓存返回 null 后应该去存储查

  2018-06-05

  **

  **

- ![img](data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QN5aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0MCA3OS4xNjA0NTEsIDIwMTcvMDUvMDYtMDE6MDg6MjEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YWE3YmZhMDItMzBhMC00MDg3LTg3MmYtOGMwMjMxNjNhZWRjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI2MTlEODM3NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2MTlEODM2NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTYyRTNCMDNBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTYyRTNCMDRBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRm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)

  十七

  现在项目重度依赖 redis 做统计计算，在请求量非常大的情况下，达不到低延时要求，不知道行业内有没有性能更好的实现方案

  作者回复: 之前看到有证券公司将依赖 redis+lua 的计算改为 go 去计算，redis 只做存储

  2018-06-05

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/10/e7/97/c9cc72f0.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  李唐

  曾经设计过某安卓游戏平台，前台采用 redis+solr+mysql 多级缓存方案，考虑过缓存穿透，后来被新来的架构师否决了。个人感觉，业务架构重于技术架构

  作者回复: 否决的理由是什么？如果评估缓存穿透的可能性很低，不做确实也可以

  2018-06-05

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572462901.jpeg)

  yushing

  1、文本提到可以监控爬虫，发现问题后及时处理，请问具体是怎么处理呢？ 2、分页数据有很多排序规则，而且可能在某个时间点要上架新商品，就会有实时性的要求，请问这样使用分页缓存真的合适么？

  作者回复: 1. 监控数据库的各项指标，发现逐步变慢后看看是不是爬虫，只要系统还撑得住就让它爬，撑不住就不让它爬 2. 缓存是为了解决性能问题，实时性要求很高就不能用缓存了，或者要做缓存及时更新机制

  2018-06-05

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572462901.jpeg)

  yushing

  业务系统中有使用 reids 存储商品 list 列表，每次添加、更新商品时，跟该商品有关的列表缓存都要跟着刷新；后来改成列表缓存中只保存商品 id，查询时再关联商品信息，但这样只是在更新商品时不用更新商品列表缓存，在商品有添加、删除操作时，列表缓存更新的问题依然存在，请问对列表缓存的更新有什么好的方式呢？

  作者回复: 我觉得这样设计没什么问题呀，除非你们的 list 很大，如果 list 很大，分段缓存就可以

  2018-06-05

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572462902.jpeg)

  李志博

  最近有一个 redis 存储数据过大的问题，字符串 key ，大小 2.5mb 导致压测的时候发现带宽不够了，我优化的方式类似于后台更新的方式，启动的时候查一次，放到一个 concurrent hash map 上，然后写个定时器每隔半小时更新一次，业务线程直接读 map 里的数据，如果读不到，说明是新增的数据，我搞了个 jdk 自带 sync 开头的 queue ，先通过 offer 往 queue 里添加一个 new object 触发一个异步线程更新缓存，同时业务线程在根据 id 查单条，我还利用开关的观察者机制，留了个后门，可以通过人工方式触发缓存更新

  作者回复: 最好优化缓存设计，这么大的缓存，带宽都很浪费

  2018-06-05

  **

  **

- ![img](17%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.resource/resize,m_fill,h_34,w_34-16617956572462903.jpeg)

  浪子恒心

  朗读者声音不错，很清晰！

  2018-06-05
