{"compress":true,"commitItems":[["21bd25cd-ea21-4bf4-8caf-f9451277635d",1559307184869,"",[[1559307126503,["GJX@GJXAIOU",[[1,0,"# 图\n\n\n\n"]],[0,0],[6,6]]],[1559307126610,["GJX@GJXAIOU",[[1,7,"\n"]],[6,6],[7,7]]],[1559307200420,["GJX@GJXAIOU",[[1,6,"## 6"]],[6,6],[10,10]]],[1559307201788,["GJX@GJXAIOU",[[-1,9,"6"]],[10,10],[9,9]]],[1559307204292,["GJX@GJXAIOU",[[1,9,"7.1 5"]],[9,9],[14,14]]],[1559307205884,["GJX@GJXAIOU",[[-1,13,"5"]],[14,14],[13,13]]],[1559307208683,["GJX@GJXAIOU",[[1,13,"图的定义"]],[13,13],[17,17]]],[1559307209164,["GJX@GJXAIOU",[[1,19,"\n"]],[17,17],[18,18]]],[1559307256394,["GJX@GJXAIOU",[[1,19,"图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合"]],[19,19],[93,93]]],[1559308050983,["GJX@GJXAIOU",[[1,93,"。"]],[93,93],[94,94]]],[1559308096277,["GJX@GJXAIOU",[[1,95,"\n"]],[94,94],[95,95]]],[1559308102576,["GJX@GJXAIOU",[[-1,95,"\n"],[1,96,"顶点"]],[95,95],[97,97]]],[1559308132906,["GJX@GJXAIOU",[[1,97,"：图中的数据元素，"]],[97,97],[106,106]]],[1559308134060,["GJX@GJXAIOU",[[-1,105,"，"]],[106,106],[105,105]]],[1559308142952,["GJX@GJXAIOU",[[1,105,"；    线性表中数据"]],[105,105],[116,116]]],[1559308168105,["GJX@GJXAIOU",[[1,116,"元素称为：元素； 树中数据元素称为：结点"]],[116,116],[136,136]]],[1559308201346,["GJX@GJXAIOU",[[1,136,"\n\n"]],[136,136],[137,137]]],[1559308204638,["GJX@GJXAIOU",[[-1,137,"\n"],[1,138,"边"]],[137,137],[138,138]]],[1559308209722,["GJX@GJXAIOU",[[1,138,"：定制店址的"]],[138,138],[144,144]]],[1559308211006,["GJX@GJXAIOU",[[-1,139,"定制店址的"]],[144,144],[139,139]]],[1559308237324,["GJX@GJXAIOU",[[1,139,"顶点之间的逻辑关系使用边来表示，边集可以是空的；"]],[139,139],[163,163]]],[1559308237957,["GJX@GJXAIOU",[[1,163,"\n\n"]],[163,163],[164,164]]],[1559308238147,["GJX@GJXAIOU",[[1,165,"\n"]],[164,164],[165,165]]],[1559308243886,["GJX@GJXAIOU",[[-1,165,"\n"]],[165,165],[164,164]]],[1559308248094,["GJX@GJXAIOU",[[1,19,"- "]],[19,19],[21,21]]],[1559308250508,["GJX@GJXAIOU",[[1,97,"- "]],[97,97],[99,99]]],[1559308253814,["GJX@GJXAIOU",[[1,141,"- "]],[141,141],[143,143]]],[1559308256166,["GJX@GJXAIOU",[[1,170,"- \n"]],[169,169],[172,172]]],[1559308475344,["GJX@GJXAIOU",[[1,172,"无向图："]],[172,172],[176,176]]],[1559308572369,["GJX@GJXAIOU",[[1,176,"若顶点Vi到Vj之间的边没有方向，则称这条边为无向边(Edge)，用无序偶(Vi,Vj)来表示"]],[176,176],[223,223]]],[1559308575347,["GJX@GJXAIOU",[[-1,174,"图"]],[175,175],[174,174]]],[1559308576541,["GJX@GJXAIOU",[[1,174,"边"]],[174,174],[175,175]]],[1559308586125,["GJX@GJXAIOU",[[1,223,"；"]],[223,223],[224,224]]],[1559308597087,["GJX@GJXAIOU",[[1,225,"- \n"]],[224,224],[227,227]]],[1559308623518,["GJX@GJXAIOU",[[1,227,"无向图：即图中任意两个顶点之间的边都是"]],[227,227],[246,246]]],[1559308645419,["GJX@GJXAIOU",[[1,246,"无向边，构成的图示无向图；"]],[246,246],[259,259]]],[1559308656537,["GJX@GJXAIOU",[[1,260,"- \n"]],[259,259],[262,262]]],[1559308657877,["GJX@GJXAIOU",[[-1,260,"- "]],[262,262],[260,260]]],[1559309176483,["GJX@GJXAIOU",[[1,261,"![无向图示例]($resource/%E6%97%A0%E5%90%91%E5%9B%BE%E7%A4%BA%E4%BE%8B.jpg)\n"]],[261,261],[331,331]]],[1559309178307,["GJX@GJXAIOU",[[1,332,"\n"]],[331,331],[332,332]]],[1559309239717,["GJX@GJXAIOU",[[-1,263,"无"]],[264,264],[263,263]]],[1559309241247,["GJX@GJXAIOU",[[1,263,"有"]],[263,263],[264,264]]],[1559309245911,["GJX@GJXAIOU",[[1,260,"- \n"]],[259,259],[262,262]]],[1559309257582,["GJX@GJXAIOU",[[1,262,"•有向边：若从顶点Vi到Vj的边有方向，则称这条边为有向边，也成为弧(Arc)，用有序偶<Vi,Vj>来表示，Vi称为弧尾，Vj称为弧头。"]],[262,262],[331,331]]],[1559309260358,["GJX@GJXAIOU",[[-1,262,"•"]],[263,263],[262,262]]],[1559309289517,["GJX@GJXAIOU",[[1,330,"，"]],[330,330],[331,331]]],[1559309290189,["GJX@GJXAIOU",[[-1,330,"，"]],[331,331],[330,330]]],[1559309300795,["GJX@GJXAIOU",[[1,330,"表示方法不能颠倒；"]],[330,330],[339,339]]],[1559309342547,["GJX@GJXAIOU",[[1,340,"- \n"]],[339,339],[342,342]]],[1559309373552,["GJX@GJXAIOU",[[1,342,"无向边使用小括号``"]],[342,342],[352,352]]],[1559309375259,["GJX@GJXAIOU",[[1,351,"()"]],[351,351],[353,353]]],[1559309406088,["GJX@GJXAIOU",[[1,354,"表示，有向边使用尖括号``"]],[354,354],[367,367]]],[1559309409304,["GJX@GJXAIOU",[[1,366,"<>"]],[366,366],[368,368]]],[1559309418258,["GJX@GJXAIOU",[[1,369,"表示；"]],[369,369],[372,372]]],[1559309419038,["GJX@GJXAIOU",[[-1,371,"；"]],[372,372],[371,371]]],[1559309419972,["GJX@GJXAIOU",[[1,371,"。"]],[371,371],[372,372]]],[1559309437291,["GJX@GJXAIOU",[[1,373,"- \n"]],[372,372],[375,375]]],[1559309469160,["GJX@GJXAIOU",[[1,375,"简单图：在图中不存在顶点到自身的边，且同一个边"]],[375,375],[398,398]]],[1559309479093,["GJX@GJXAIOU",[[1,398,"不重复出现；"]],[398,398],[404,404]]],[1559309502922,["GJX@GJXAIOU",[[1,392,"（）"]],[392,392],[394,394]]],[1559309518461,["GJX@GJXAIOU",[[1,393,"就是两个顶点之间"]],[393,393],[401,401]]],[1559309547131,["GJX@GJXAIOU",[[1,401,"不存在两条一样的路径"]],[401,401],[411,411]]],[1559309577053,["GJX@GJXAIOU",[[1,423,"（）"]],[423,423],[425,425]]],[1559309578391,["GJX@GJXAIOU",[[1,424,"就是两个顶点之间不存在两条一样的路径"]],[424,424],[442,442]]],[1559309586280,["GJX@GJXAIOU",[[-1,395,"两个顶点之间不存在两条一样的路径"],[1,411,"没有"]],[395,395],[397,397]]],[1559309598319,["GJX@GJXAIOU",[[1,397,"自己到自己的边"]],[397,397],[404,404]]],[1559309611530,["GJX@GJXAIOU",[[-1,340,"- 无向边使用小括号`()`表示，有向边使用尖括号`<>`表示。\n- 简单图：在图中不存在顶点到自身的边（就是没有自己到自己的边），且同一个边不重复出现（就是两个顶点之间不存在两条一样的路径）；"]],[340,437],[340,340]]],[1559309613382,["GJX@GJXAIOU",[[1,413,"- 无向边使用小括号`()`表示，有向边使用尖括号`<>`表示。\n- 简单图：在图中不存在顶点到自身的边（就是没有自己到自己的边），且同一个边不重复出现（就是两个顶点之间不存在两条一样的路径）；"]],[413,413],[510,510]]],[1559309615488,["GJX@GJXAIOU",[[1,511,"- \n"]],[510,510],[513,513]]],[1559309708397,["GJX@GJXAIOU",[[1,513,"无向完全图：无向图中如果"]],[513,513],[525,525]]],[1559309749874,["GJX@GJXAIOU",[[1,525,"任意两个顶点之间都有边；即含有n个顶点的无向完全图拥有n"]],[525,525],[553,553]]],[1559309751207,["GJX@GJXAIOU",[[-1,552,"n"]],[553,553],[552,552]]],[1559309752581,["GJX@GJXAIOU",[[1,552,"``"]],[552,552],[554,554]]],[1559309756884,["GJX@GJXAIOU",[[1,553,"b*()"]],[553,553],[557,557]]],[1559309759657,["GJX@GJXAIOU",[[-1,553,"b"]],[554,554],[553,553]]],[1559309760106,["GJX@GJXAIOU",[[1,553,"n"]],[553,553],[554,554]]],[1559309762714,["GJX@GJXAIOU",[[1,556,"n-1"]],[556,556],[559,559]]],[1559309768247,["GJX@GJXAIOU",[[1,560,"/2"]],[560,560],[562,562]]],[1559309774523,["GJX@GJXAIOU",[[1,563,"条边；"]],[563,563],[566,566]]],[1559310046288,["GJX@GJXAIOU",[[1,567,"- \n"]],[566,566],[569,569]]],[1559310058828,["GJX@GJXAIOU",[[1,569,"有向完全图：如果任意"]],[569,569],[579,579]]],[1559310069246,["GJX@GJXAIOU",[[1,575,"有向图中，"]],[575,575],[580,580]]],[1559310076194,["GJX@GJXAIOU",[[1,584,"两个鼎电子"]],[584,584],[589,589]]],[1559310077333,["GJX@GJXAIOU",[[-1,586,"鼎电子"]],[589,589],[586,586]]],[1559310118318,["GJX@GJXAIOU",[[1,586,"顶点之间都存在方向互为相反的两条弧，则"]],[586,586],[605,605]]],[1559310119928,["GJX@GJXAIOU",[[-1,603,"，则"]],[605,605],[603,603]]],[1559310120308,["GJX@GJXAIOU",[[1,603,"；"]],[603,603],[604,604]]],[1559310149242,["GJX@GJXAIOU",[[1,604,"则有向图最多拥有``"]],[604,604],[614,614]]],[1559310151424,["GJX@GJXAIOU",[[1,613,"n()"]],[613,613],[616,616]]],[1559310153336,["GJX@GJXAIOU",[[1,615,"n-1"]],[615,615],[618,618]]],[1559310159005,["GJX@GJXAIOU",[[1,620,"条边。"]],[620,620],[623,623]]],[1559310218703,["GJX@GJXAIOU",[[1,624,"- \n"]],[623,623],[626,626]]],[1559310218817,["GJX@GJXAIOU",[[-1,624,"- "]],[626,626],[625,625]]],[1559310218939,["GJX@GJXAIOU",[[1,625,"\n"]],[625,625],[626,626]]],[1559310219057,["GJX@GJXAIOU",[[1,626,"\n"]],[626,626],[627,627]]],[1559310219177,["GJX@GJXAIOU",[[1,627,"\n"]],[627,627],[628,628]]],[1559310219310,["GJX@GJXAIOU",[[1,628,"\n"]],[628,628],[629,629]]],[1559310219430,["GJX@GJXAIOU",[[1,629,"\n"]],[629,629],[630,630]]],[1559310219558,["GJX@GJXAIOU",[[1,630,"\n"]],[630,630],[631,631]]],[1559310219813,["GJX@GJXAIOU",[[1,631,"\n"]],[631,631],[632,632]]],[1559310219944,["GJX@GJXAIOU",[[1,632,"\n"]],[632,632],[633,633]]],[1559310220046,["GJX@GJXAIOU",[[1,633,"\n"]],[633,633],[634,634]]],[1559310233926,["GJX@GJXAIOU",[[-1,633,"\n"]],[625,625],[624,624]]],[1559310243542,["GJX@GJXAIOU",[[1,624,"- 网：带有权值的图"]],[624,624],[634,634]]],[1559310278190,["GJX@GJXAIOU",[[1,635,"- \n"]],[634,634],[637,637]]],[1559310279026,["GJX@GJXAIOU",[[1,637,"•假设有两个图G1=(V1,E1)和G2=(V2,E2)，如果V2⊆V1，E2⊆E1，则称G2为G1的子图(Subgraph)。"]],[637,637],[701,701]]],[1559310282335,["GJX@GJXAIOU",[[-1,637,"•"]],[638,638],[637,637]]],[1559310285104,["GJX@GJXAIOU",[[1,637,"子图："]],[637,637],[640,640]]],[1559310592710,["GJX@GJXAIOU",[[1,704,"•对于无向图G=(V,E)，如果边(V1,V2)∈E，则称顶点V1和V2互为邻接点(Adjacent)，即V1和V2相邻接。边(V1,V2)依附(incident)于顶点V1和V2，或者说边(V1,V2)与顶点V1和V2相关联。\n\n顶点V的度(Degree)是和V相关联的边的数目，记为TD(V)"]],[704,704],[852,852]]],[1559310594360,["GJX@GJXAIOU",[[-1,704,"•"]],[705,705],[704,704]]],[1559310594761,["GJX@GJXAIOU",[[1,704,"- "]],[704,704],[706,706]]],[1559310596868,["GJX@GJXAIOU",[[1,821,"- "]],[821,821],[823,823]]],[1559310603259,["GJX@GJXAIOU",[[1,836,"："]],[836,836],[837,837]]],[1559310649365,["GJX@GJXAIOU",[[1,856,"；整个图的边数是各个顶点读书"]],[856,856],[870,870]]],[1559310649975,["GJX@GJXAIOU",[[-1,868,"读书"]],[870,870],[868,868]]],[1559310660430,["GJX@GJXAIOU",[[1,868,"度数和的一半；"]],[868,868],[875,875]]],[1559310717786,["GJX@GJXAIOU",[[1,883,"\n"]],[876,876],[877,877]]],[1559310718201,["GJX@GJXAIOU",[[1,877,"•对于有向图G=(V,E)，如果有<V1,V2>∈E，则称顶点V1邻接到顶点V2，顶点V2邻接自顶点V1。\n\n•以顶点V为头的弧的数目称为V的入度(InDegree)，记为ID(V)，以V为尾的弧的数目称为V的出度(OutDegree)，记为OD(V)，因此顶点V的度为TD(V)=ID(V)+OD(V)。"]],[877,877],[1030,1030]]],[1559310722713,["GJX@GJXAIOU",[[-1,877,"•"]],[878,878],[877,877]]],[1559310723483,["GJX@GJXAIOU",[[1,877,"- "]],[877,877],[879,879]]],[1559310725930,["GJX@GJXAIOU",[[-1,933,"•"]],[934,934],[933,933]]],[1559310726371,["GJX@GJXAIOU",[[1,933,"- "]],[933,933],[935,935]]],[1559310730554,["GJX@GJXAIOU",[[1,984,"**"],[1,986,"**"]],[984,986],[984,990]]],[1559310734914,["GJX@GJXAIOU",[[1,950,"**"],[1,952,"**"]],[950,952],[950,956]]],[1559310767801,["GJX@GJXAIOU",[[1,936,"**"],[1,943,"**"]],[936,943],[936,947]]],[1559310841050,["GJX@GJXAIOU",[[1,1046,"路径的长度是路径上的边或弧的数目"]],[1046,1046],[1062,1062]]],[1559310850886,["GJX@GJXAIOU",[[1,1046,"- 顶点到另一个"]],[1046,1046],[1054,1054]]],[1559310852223,["GJX@GJXAIOU",[[1,1054,"顶点"]],[1054,1054],[1056,1056]]],[1559310859677,["GJX@GJXAIOU",[[1,1072,"；"]],[1072,1072],[1073,1073]]],[1559310860227,["GJX@GJXAIOU",[[1,1074,"- \n"]],[1073,1073],[1076,1076]]],[1559310883988,["GJX@GJXAIOU",[[1,1076,"第一个顶点到最后一个顶点相同的路径称为回路或环；"]],[1076,1076],[1100,1100]]],[1559310884356,["GJX@GJXAIOU",[[1,1101,"- \n"]],[1100,1100],[1103,1103]]],[1559310898503,["GJX@GJXAIOU",[[1,1103,"•序列中顶点不重复出现的路径称为简单路径，除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。"]],[1103,1103],[1165,1165]]],[1559310901290,["GJX@GJXAIOU",[[-1,1103,"•"]],[1104,1104],[1103,1103]]],[1559310925104,["GJX@GJXAIOU",[[1,1165,"- \n"]],[1164,1164],[1167,1167]]],[1559310925215,["GJX@GJXAIOU",[[-1,1165,"- "]],[1167,1167],[1166,1166]]],[1559311044964,["GJX@GJXAIOU",[[1,1166,"![简单环]($resource/%E7%AE%80%E5%8D%95%E7%8E%AF.jpg)"]],[1166,1166],[1216,1216]]],[1559311047443,["GJX@GJXAIOU",[[1,1219,"\n"]],[1216,1216],[1217,1217]]],[1559311047978,["GJX@GJXAIOU",[[1,1217,"- "]],[1217,1217],[1219,1219]]],[1559311069313,["GJX@GJXAIOU",[[1,706,"\n- "]],[703,703],[706,706]]],[1559311069434,["GJX@GJXAIOU",[[-1,704,"- "]],[706,706],[705,705]]],[1559311069567,["GJX@GJXAIOU",[[1,705,"\n"]],[705,705],[706,706]]],[1559311069696,["GJX@GJXAIOU",[[1,706,"\n"]],[706,706],[707,707]]],[1559311077824,["GJX@GJXAIOU",[[1,705,"### 7.1.1"]],[705,705],[714,714]]],[1559311078947,["GJX@GJXAIOU",[[-1,713,"1"]],[714,714],[713,713]]],[1559311089158,["GJX@GJXAIOU",[[1,713,"2 图的顶点和边间关系"]],[713,713],[724,724]]],[1559311099984,["GJX@GJXAIOU",[[-1,1239,"- "]],[1241,1241],[1239,1239]]],[1559311100115,["GJX@GJXAIOU",[[-1,1241,"\n"]],[1239,1239],[1238,1238]]],[1559311101154,["GJX@GJXAIOU",[[1,1241,"\n"]],[1238,1238],[1239,1239]]],[1559311116870,["GJX@GJXAIOU",[[1,1239,"### 7.1.3 连通图相关术语"]],[1239,1239],[1256,1256]]],[1559311117291,["GJX@GJXAIOU",[[1,1259,"\n"]],[1256,1256],[1257,1257]]],[1559311127625,["GJX@GJXAIOU",[[1,1260,"\n"]],[1257,1257],[1258,1258]]],[1559311133467,["GJX@GJXAIOU",[[1,1258,"- 在无向图G中，如果从顶点V1到顶点V2有路径，则称V1和V2是连通的，如果对于图中任意两个顶点Vi和Vj都是连通的，则称G是连通图；"]],[1258,1258],[1326,1326]]],[1559311232803,["GJX@GJXAIOU",[[1,1327,"- \n"]],[1326,1326],[1329,1329]]],[1559311233777,["GJX@GJXAIOU",[[1,1329,"•无向图中的极大连通子图称为连通分量。\n\n•注意以下概念：\n\n–首先要是子图，并且子图是要连通的；\n\n–连通子图含有极大顶点数；\n\n–具有极大顶点数的连通子图包含依附于这些顶点的所有边。"]],[1329,1329],[1422,1422]]],[1559311236689,["GJX@GJXAIOU",[[-1,1350,"•"]],[1351,1351],[1350,1350]]],[1559311238784,["GJX@GJXAIOU",[[-1,1359,"–"]],[1360,1360],[1359,1359]]],[1559311240587,["GJX@GJXAIOU",[[-1,1377,"\n"]],[1377,1377],[1377,1377]]],[1559311241553,["GJX@GJXAIOU",[[-1,1391,"\n"]],[1391,1391],[1391,1391]]],[1559311243560,["GJX@GJXAIOU",[[-1,1377,"–"]],[1377,1377],[1377,1377]]],[1559311244467,["GJX@GJXAIOU",[[-1,1390,"–"]],[1390,1390],[1390,1390]]],[1559311245656,["GJX@GJXAIOU",[[-1,1358,"\n"]],[1358,1358],[1358,1358]]],[1559311246936,["GJX@GJXAIOU",[[-1,1349,"\n"]],[1349,1349],[1349,1349]]],[1559311248328,["GJX@GJXAIOU",[[-1,1329,"•"]],[1329,1329],[1329,1329]]],[1559311253352,["GJX@GJXAIOU",[[1,1348,"- "],[1,1356,"- "],[1,1374,"- "],[1,1387,"- "]],[1348,1413],[1350,1421]]],[1559311255041,["GJX@GJXAIOU",[[1,1348,"  "],[1,1358,"  "],[1,1378,"  "],[1,1393,"  "]],[1350,1421],[1352,1429]]],[1559311320360,["GJX@GJXAIOU",[[1,1430,"  - \n"]],[1429,1429],[1434,1434]]],[1559311322328,["GJX@GJXAIOU",[[-1,1430,"  "]],[1434,1434],[1432,1432]]],[1559311329170,["GJX@GJXAIOU",[[1,1432,"在有向图G中，如果对于每一对Vi到Vj都存在路径，则称G是强连通图、"]],[1432,1432],[1466,1466]]],[1559311330296,["GJX@GJXAIOU",[[-1,1465,"、"]],[1466,1466],[1465,1465]]],[1559311330699,["GJX@GJXAIOU",[[1,1465,"‘"]],[1465,1465],[1466,1466]]],[1559311331762,["GJX@GJXAIOU",[[-1,1465,"‘"]],[1466,1466],[1465,1465]]],[1559311332107,["GJX@GJXAIOU",[[1,1465,"；"]],[1465,1465],[1466,1466]]],[1559311336508,["GJX@GJXAIOU",[[1,1432,"强连通图："]],[1432,1432],[1437,1437]]],[1559311371759,["GJX@GJXAIOU",[[1,1471,"•有向图中的极大强连通子图称为有向图的强连通分量。"]],[1471,1471],[1496,1496]]],[1559311374967,["GJX@GJXAIOU",[[-1,1471,"•"]],[1472,1472],[1471,1471]]],[1559311375178,["GJX@GJXAIOU",[[1,1471,"\n"]],[1471,1471],[1472,1472]]],[1559311387732,["GJX@GJXAIOU",[[1,1472,"- 强连通分量："]],[1472,1472],[1480,1480]]],[1559311400493,["GJX@GJXAIOU",[[1,1461,"（）"]],[1461,1461],[1463,1463]]],[1559311412486,["GJX@GJXAIOU",[[1,1462,"即任意两个结点之间可达"]],[1462,1462],[1473,1473]]],[1559311489910,["GJX@GJXAIOU",[[1,1518,"- 一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。（）"]],[1518,1518],[1572,1572]]],[1559311511743,["GJX@GJXAIOU",[[1,1571,"如果一个图有"]],[1571,1571],[1577,1577]]],[1559311524297,["GJX@GJXAIOU",[[1,1577,"n个顶点和小于no"]],[1577,1577],[1586,1586]]],[1559311524973,["GJX@GJXAIOU",[[-1,1585,"o"]],[1586,1586],[1585,1585]]],[1559311555263,["GJX@GJXAIOU",[[1,1585,"-1条边，则是非连通图，多余n-1条边则必定构成环"]],[1585,1585],[1610,1610]]],[1559311577756,["GJX@GJXAIOU",[[1,1611,"。"]],[1611,1611],[1612,1612]]],[1559311579085,["GJX@GJXAIOU",[[1,1613,"- \n"]],[1612,1612],[1615,1615]]],[1559311580072,["GJX@GJXAIOU",[[1,1615,"•如果一个有向图恰有一个顶点入度为0，其余顶点的入度均为1，则是一棵有向树。"]],[1615,1615],[1653,1653]]],[1559311583366,["GJX@GJXAIOU",[[-1,1615,"•"]],[1616,1616],[1615,1615]]],[1559311993594,["GJX@GJXAIOU",[[-1,1653,"\n"],[1,1654,"`"]],[1653,1653],[1654,1654]]],[1559311993929,["GJX@GJXAIOU",[[1,1654,"``"]],[1654,1654],[1656,1656]]],[1559311993957,["GJX@GJXAIOU",[[1,1656,"language\n```\n"]],[1656,1656],[1656,1664]]],[1559311995546,["GJX@GJXAIOU",[[-1,1656,"language"],[1,1664,"c"]],[1656,1664],[1657,1657]]],[1559311995705,["GJX@GJXAIOU",[[1,1658,"\n"]],[1657,1657],[1658,1658]]],[1559311996882,["GJX@GJXAIOU",[[1,1658,"ADT 图(Graph) \n\nData \n\n 顶点的有穷非空集合和边的集合 \n\nOperation \n\n CreateGraph(*G,V,VR):按照顶点集合V和边弧集VR的定义构造图G。 \n\n DestroyGraph(*G):图G存在则销毁。 \n\n LocateVex(G,u):若图G中存在顶点u，则返回图中的位置。 \n\n GetVex(G,v):返回图G中顶点v的值。 \n\n PutVex(G,v,value):将图G中顶点v赋值value。 \n\n FirstAdjvex(G,*v):返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。 \n\n NextAdjVex(G,v,*w):返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个邻接点则返回“空”。 \n\n InsertVex(*G,v):在图G中增添新顶点v. \n\n DeleteVex(*G,v):删除图G中顶点v及其相关的弧。 \n\n InsertArc(*G,v,w):在图G中增添弧<v,w>,若G是无向图，还需要增添对称弧<w,v>。 \n\n DeleteArc(*G,v,w):在图G中删除弧<v,w>，若G是无向图，则还删除对称弧<w,v>。 \n\n DESTraverse(G):对图G中进行深度优先遍历，在遍历过程中对每个顶点调用。 \n\n HFSTraverse(G):对图G中进行广度优先遍历，在遍历过程中对每个顶点调用。 \n\nendADT"]],[1658,1658],[2274,2274]]]],null,"GJX@GJXAIOU"],["78614f3f-4891-44db-af35-113caa2689a2",1559352306225,"# 图\n\n\n## 7.1 图的定义\n\n- 图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。\n- 顶点：图中的数据元素；    线性表中数据元素称为：元素； 树中数据元素称为：结点\n- 边：顶点之间的逻辑关系使用边来表示，边集可以是空的；\n- 无向边：若顶点Vi到Vj之间的边没有方向，则称这条边为无向边(Edge)，用无序偶(Vi,Vj)来表示；\n- 无向图：即图中任意两个顶点之间的边都是无向边，构成的图示无向图；\n- 有向边：若从顶点Vi到Vj的边有方向，则称这条边为有向边，也成为弧(Arc)，用有序偶<Vi,Vj>来表示，Vi称为弧尾，Vj称为弧头。表示方法不能颠倒；\n\n\n![有向图示例]($resource/%E6%97%A0%E5%90%91%E5%9B%BE%E7%A4%BA%E4%BE%8B.jpg)\n\n- 无向边使用小括号`()`表示，有向边使用尖括号`<>`表示。\n- 简单图：在图中不存在顶点到自身的边（就是没有自己到自己的边），且同一个边不重复出现（就是两个顶点之间不存在两条一样的路径）；\n- 无向完全图：无向图中如果任意两个顶点之间都有边；即含有n个顶点的无向完全图拥有`n*(n-1)/2`条边；\n- 有向完全图：有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧；则有向图最多拥有`n(n-1)`条边。\n- 网：带有权值的图\n- 子图：假设有两个图G1=(V1,E1)和G2=(V2,E2)，如果V2⊆V1，E2⊆E1，则称G2为G1的子图(Subgraph)。\n\n### 7.1.2 图的顶点和边间关系\n\n- 对于无向图G=(V,E)，如果边(V1,V2)∈E，则称顶点V1和V2互为邻接点(Adjacent)，即V1和V2相邻接。边(V1,V2)依附(incident)于顶点V1和V2，或者说边(V1,V2)与顶点V1和V2相关联。\n\n- 顶点V的度(Degree)：是和V相关联的边的数目，记为TD(V)；整个图的边数是各个顶点度数和的一半；\n\n- 对于有向图G=(V,E)，如果有<V1,V2>∈E，则称顶点V1邻接到顶点V2，顶点V2邻接自顶点V1。\n\n- 以**顶点V为头的弧**的数目称为V的**入度**(InDegree)，记为ID(V)，以V为尾的弧的数目称为V的**出度**(OutDegree)，记为OD(V)，因此顶点V的度为TD(V)=ID(V)+OD(V)。\n\n- 顶点到另一个顶点路径的长度是路径上的边或弧的数目；\n- 第一个顶点到最后一个顶点相同的路径称为回路或环；\n- 序列中顶点不重复出现的路径称为简单路径，除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。\n\n![简单环]($resource/%E7%AE%80%E5%8D%95%E7%8E%AF.jpg)\n\n### 7.1.3 连通图相关术语\n\n- 在无向图G中，如果从顶点V1到顶点V2有路径，则称V1和V2是连通的，如果对于图中任意两个顶点Vi和Vj都是连通的，则称G是连通图；\n- 无向图中的极大连通子图称为连通分量。\n  - 注意以下概念：\n  - 首先要是子图，并且子图是要连通的；\n  - 连通子图含有极大顶点数；\n  - 具有极大顶点数的连通子图包含依附于这些顶点的所有边。\n- 强连通图：在有向图G中，如果对于每一对Vi到Vj都存在路径（即任意两个结点之间可达），则称G是强连通图；\n- 强连通分量：有向图中的极大强连通子图称为有向图的强连通分量。\n- 一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。（如果一个图有n个顶点和小于n-1条边，则是非连通图，多余n-1条边则必定构成环）。\n- 如果一个有向图恰有一个顶点入度为0，其余顶点的入度均为1，则是一棵有向树。\n```c\nADT 图(Graph) \n\nData \n\n 顶点的有穷非空集合和边的集合 \n\nOperation \n\n CreateGraph(*G,V,VR):按照顶点集合V和边弧集VR的定义构造图G。 \n\n DestroyGraph(*G):图G存在则销毁。 \n\n LocateVex(G,u):若图G中存在顶点u，则返回图中的位置。 \n\n GetVex(G,v):返回图G中顶点v的值。 \n\n PutVex(G,v,value):将图G中顶点v赋值value。 \n\n FirstAdjvex(G,*v):返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。 \n\n NextAdjVex(G,v,*w):返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个邻接点则返回“空”。 \n\n InsertVex(*G,v):在图G中增添新顶点v. \n\n DeleteVex(*G,v):删除图G中顶点v及其相关的弧。 \n\n InsertArc(*G,v,w):在图G中增添弧<v,w>,若G是无向图，还需要增添对称弧<w,v>。 \n\n DeleteArc(*G,v,w):在图G中删除弧<v,w>，若G是无向图，则还删除对称弧<w,v>。 \n\n DESTraverse(G):对图G中进行深度优先遍历，在遍历过程中对每个顶点调用。 \n\n HFSTraverse(G):对图G中进行广度优先遍历，在遍历过程中对每个顶点调用。 \n\nendADT\n```\n",[[1559352253176,["GJX@GJXAIOU",[[1,2279,"\n"]],[2278,2278],[2279,2279]]],[1559352253294,["GJX@GJXAIOU",[[1,2280,"\n"]],[2279,2279],[2280,2280]]],[1559352253448,["GJX@GJXAIOU",[[1,2281,"\n"]],[2280,2280],[2281,2281]]],[1559352253598,["GJX@GJXAIOU",[[1,2282,"\n"]],[2281,2281],[2282,2282]]],[1559352253733,["GJX@GJXAIOU",[[1,2283,"\n"]],[2282,2282],[2283,2283]]],[1559352253865,["GJX@GJXAIOU",[[1,2284,"\n"]],[2283,2283],[2284,2284]]],[1559352254005,["GJX@GJXAIOU",[[1,2285,"\n"]],[2284,2284],[2285,2285]]],[1559352257490,["GJX@GJXAIOU",[[1,2282,"### "]],[2282,2282],[2286,2286]]],[1559352265648,["GJX@GJXAIOU",[[1,1653,"- \n"]],[1652,1652],[1655,1655]]],[1559352265800,["GJX@GJXAIOU",[[-1,1653,"- "]],[1655,1655],[1654,1654]]],[1559352265979,["GJX@GJXAIOU",[[1,1654,"\n"]],[1654,1654],[1655,1655]]],[1559352268757,["GJX@GJXAIOU",[[1,1613,"## "]],[1614,1614],[1655,1655]]],[1559352271837,["GJX@GJXAIOU",[[-1,1613,"## "]],[1655,1655],[1614,1614]]],[1559352283036,["GJX@GJXAIOU",[[1,1654,"##  7.2 图的抽芯数据"]],[1654,1654],[1668,1668]]],[1559352285377,["GJX@GJXAIOU",[[-1,1664,"抽芯数据"]],[1668,1668],[1664,1664]]],[1559352292119,["GJX@GJXAIOU",[[1,1664,"抽象数据类型"]],[1664,1664],[1670,1670]]],[1559352302712,["GJX@GJXAIOU",[[-1,2302,"# "]],[2304,2304],[2302,2302]]],[1559352303695,["GJX@GJXAIOU",[[1,2302," "]],[2302,2302],[2303,2303]]],[1559352314241,["GJX@GJXAIOU",[[1,2303,"7.3 图的存储结果"]],[2303,2303],[2313,2313]]],[1559352314819,["GJX@GJXAIOU",[[-1,2311,"结果"]],[2313,2313],[2311,2311]]],[1559352316249,["GJX@GJXAIOU",[[1,2311,"结构"]],[2311,2311],[2313,2313]]],[1559352316961,["GJX@GJXAIOU",[[1,2317,"\n"]],[2313,2313],[2314,2314]]],[1559352317100,["GJX@GJXAIOU",[[1,2318,"\n"]],[2314,2314],[2315,2315]]],[1559352464472,["GJX@GJXAIOU",[[1,2315,"-"]],[2315,2315],[2316,2316]]],[1559352477031,["GJX@GJXAIOU",[[1,2314,"常见的存储方式："]],[2314,2314],[2322,2322]]],[1559352480330,["GJX@GJXAIOU",[[1,2314,"\n"]],[2314,2314],[2315,2315]]],[1559352485008,["GJX@GJXAIOU",[[1,2325," "]],[2325,2325],[2326,2326]]],[1559352516314,["GJX@GJXAIOU",[[1,2326,"顺序存储：因为无法使用数据元素在内存中的物理位置来表示元素之间的关系，不行；"]],[2326,2326],[2364,2364]]],[1559352517185,["GJX@GJXAIOU",[[1,2365,"- \n"]],[2364,2364],[2367,2367]]],[1559352529056,["GJX@GJXAIOU",[[1,2367,"多重两边"]],[2367,2367],[2371,2371]]],[1559352530005,["GJX@GJXAIOU",[[-1,2369,"两边"]],[2371,2371],[2369,2369]]],[1559352544265,["GJX@GJXAIOU",[[1,2369,"链表：即以一个数据域和多个指针"]],[2369,2369],[2384,2384]]],[1559352583257,["GJX@GJXAIOU",[[1,2384,"域组成的结点表示图中的一个顶点，但是打、、"]],[2384,2384],[2405,2405]]],[1559352584584,["GJX@GJXAIOU",[[-1,2402,"打、、"]],[2405,2405],[2402,2402]]],[1559352588409,["GJX@GJXAIOU",[[1,2402,"如果结点"]],[2402,2402],[2406,2406]]],[1559352591781,["GJX@GJXAIOU",[[-1,2404,"结点"]],[2406,2406],[2404,2404]]],[1559352603019,["GJX@GJXAIOU",[[1,2404,"顶点的度相差很大，会造成"]],[2404,2404],[2416,2416]]],[1559352607618,["GJX@GJXAIOU",[[-1,2413,"会造成"]],[2416,2416],[2413,2413]]],[1559352611892,["GJX@GJXAIOU",[[1,2413,"按照最大的"]],[2413,2413],[2418,2418]]],[1559352613850,["GJX@GJXAIOU",[[-1,2415,"最大的"]],[2418,2418],[2415,2415]]],[1559352653804,["GJX@GJXAIOU",[[1,2415,"度数最大的结点设计结点结构会造成浪费，如果每个结点结构不同"]],[2415,2415],[2444,2444]]],[1559352659065,["GJX@GJXAIOU",[[1,2438,"顶点"]],[2438,2438],[2440,2440]]],[1559352664275,["GJX@GJXAIOU",[[1,2446,"，会"]],[2446,2446],[2448,2448]]],[1559352673194,["GJX@GJXAIOU",[[1,2448,"造成操作上的麻烦；"]],[2448,2448],[2457,2457]]],[1559352686585,["GJX@GJXAIOU",[[1,2458,"- \n"]],[2457,2457],[2460,2460]]],[1559352686949,["GJX@GJXAIOU",[[-1,2458,"- "]],[2460,2460],[2459,2459]]],[1559352687942,["GJX@GJXAIOU",[[1,2462,"\n"]],[2459,2459],[2460,2460]]],[1559352692467,["GJX@GJXAIOU",[[1,2460,"图中国"]],[2460,2460],[2463,2463]]],[1559352693738,["GJX@GJXAIOU",[[-1,2462,"国"]],[2463,2463],[2462,2462]]],[1559352700649,["GJX@GJXAIOU",[[1,2462,"的存储结构："]],[2462,2462],[2468,2468]]],[1559352700984,["GJX@GJXAIOU",[[1,2471,"\n"]],[2468,2468],[2469,2469]]],[1559352710055,["GJX@GJXAIOU",[[1,2469,"- 邻接矩阵："]],[2469,2469],[2476,2476]]],[1559352757714,["GJX@GJXAIOU",[[1,2476,"使用两个数组来表示图，，"]],[2476,2476],[2488,2488]]],[1559352758508,["GJX@GJXAIOU",[[-1,2487,"，"]],[2488,2488],[2487,2487]]],[1559352762785,["GJX@GJXAIOU",[[1,2487,"一个以为"]],[2487,2487],[2491,2491]]],[1559352763722,["GJX@GJXAIOU",[[-1,2489,"以为"]],[2491,2491],[2489,2489]]],[1559352784763,["GJX@GJXAIOU",[[1,2489,"一维数组表示顶点信息，一个二维数组表示图中顶点"]],[2489,2489],[2512,2512]]],[1559352785946,["GJX@GJXAIOU",[[1,2512,"信息"]],[2512,2512],[2514,2514]]],[1559352791525,["GJX@GJXAIOU",[[-1,2506,"表示图中顶点信息"]],[2514,2514],[2506,2506]]],[1559352793026,["GJX@GJXAIOU",[[1,2506,"（）"]],[2506,2506],[2508,2508]]],[1559352797641,["GJX@GJXAIOU",[[1,2507,"邻接矩阵"]],[2507,2507],[2511,2511]]],[1559352814585,["GJX@GJXAIOU",[[1,2512,"表示图中的边或者弧的关系"]],[2512,2512],[2524,2524]]],[1559352818006,["GJX@GJXAIOU",[[-1,2521,"的关系"]],[2524,2524],[2521,2521]]],[1559352821112,["GJX@GJXAIOU",[[1,2521,"的信息。"]],[2521,2521],[2525,2525]]],[1559353443923,["GJX@GJXAIOU",[[1,2526,"![邻接矩阵（无向图）]($resource/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%89.png)"]],[2526,2526],[2636,2636]]],[1559353445956,["GJX@GJXAIOU",[[1,2637,"\n"]],[2636,2636],[2637,2637]]],[1559353669621,["GJX@GJXAIOU",[[1,2637,"![邻接矩阵（有向图）]($resource/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%89.png)\n"]],[2637,2637],[2747,2747]]],[1559353671882,["GJX@GJXAIOU",[[1,2748,"\n"]],[2747,2747],[2748,2748]]],[1559353796806,["GJX@GJXAIOU",[[1,2748,"![邻接矩阵(网图)]($resource/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5(%E7%BD%91%E5%9B%BE).png)\n"]],[2748,2748],[2832,2832]]],[1559353804647,["GJX@GJXAIOU",[[-1,2825,")"]],[2826,2826],[2825,2825]]],[1559353807520,["GJX@GJXAIOU",[[1,2832,"\n"]],[2831,2831],[2832,2832]]],[1559353928229,["GJX@GJXAIOU",[[1,2833,"\n"]],[2831,2831],[2832,2832]]],[1559353940578,["GJX@GJXAIOU",[[1,2832,"邻接矩阵的创建代码："]],[2832,2832],[2842,2842]]],[1559353940896,["GJX@GJXAIOU",[[1,2844,"\n"]],[2842,2842],[2843,2843]]],[1559353942500,["GJX@GJXAIOU",[[1,2843,"```"]],[2843,2843],[2846,2846]]],[1559353942528,["GJX@GJXAIOU",[[1,2846,"language\n```\n"]],[2846,2846],[2846,2854]]],[1559353943481,["GJX@GJXAIOU",[[-1,2846,"language"],[1,2854,"c"]],[2846,2854],[2847,2847]]],[1559353943708,["GJX@GJXAIOU",[[1,2848,"\n"]],[2847,2847],[2848,2848]]],[1559353956547,["GJX@GJXAIOU",[[1,2848,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码，如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义  */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\ntypedef struct\n{\n\tVertexType vexs[MAXVEX]; /* 顶点表 */\n\tEdgeType arc[MAXVEX][MAXVEX];/* 邻接矩阵，可看作边表 */\n\tint numNodes, numEdges; /* 图中当前的顶点数和边数  */\n}MGraph;\n"]],[2848,2848],[3142,3142]]],[1559353965459,["GJX@GJXAIOU",[[1,3149,"\n"]],[3146,3146],[3147,3147]]],[1559353965740,["GJX@GJXAIOU",[[1,3150,"\n"]],[3147,3147],[3148,3148]]],[1559353971434,["GJX@GJXAIOU",[[1,3148,"li"]],[3148,3148],[3150,3150]]],[1559353972869,["GJX@GJXAIOU",[[-1,3148,"li"]],[3150,3150],[3148,3148]]],[1559353974475,["GJX@GJXAIOU",[[1,3148,"建立"]],[3148,3148],[3150,3150]]],[1559354006979,["GJX@GJXAIOU",[[1,3150,"无向网图的邻接矩阵表示："]],[3150,3150],[3162,3162]]],[1559354008309,["GJX@GJXAIOU",[[1,3165,"\n"]],[3162,3162],[3163,3163]]],[1559354010034,["GJX@GJXAIOU",[[1,3163,"``"]],[3163,3163],[3165,3165]]],[1559354011443,["GJX@GJXAIOU",[[-1,3163,"``"]],[3165,3165],[3163,3163]]],[1559354012297,["GJX@GJXAIOU",[[1,3163,"```"]],[3163,3163],[3166,3166]]],[1559354012326,["GJX@GJXAIOU",[[1,3166,"language\n```\n"]],[3166,3166],[3166,3174]]],[1559354013395,["GJX@GJXAIOU",[[-1,3166,"language"],[1,3174,"c"]],[3166,3174],[3167,3167]]],[1559354013748,["GJX@GJXAIOU",[[1,3168,"\n"]],[3167,3167],[3168,3168]]],[1559354044257,["GJX@GJXAIOU",[[1,3169,"void CreateMGraph(MGraph *G)\n{\n\tint i,j,k,w;\n\tprintf(\"输入顶点数和边数:\\n\");\n\tscanf(\"%d,%d\",&G->numNodes,&G->numEdges); /* 输入顶点数和边数 */\n\tfor(i = 0;i <G->numNodes;i++) /* 读入顶点信息,建立顶点表 */\n\t\tscanf(&G->vexs[i]);\n\tfor(i = 0;i <G->numNodes;i++)\n\t\tfor(j = 0;j <G->numNodes;j++)\n\t\t\tG->arc[i][j]=INFINITY;\t/* 邻接矩阵初始化 */\n\tfor(k = 0;k <G->numEdges;k++) /* 读入numEdges条边，建立邻接矩阵 */\n\t{\n\t\tprintf(\"输入边(vi,vj)上的下标i，下标j和权w:\\n\");\n\t\tscanf(\"%d,%d,%d\",&i,&j,&w); /* 输入边(vi,vj)上的权w */\n\t\tG->arc[i][j]=w; \n\t\tG->arc[j][i]= G->arc[i][j]; /* 因为是无向图，矩阵对称 */\n\t}\n}\n"]],[3168,3168],[3692,3692]]],[1559354049911,["GJX@GJXAIOU",[[-1,3168,"\n"]],[3168,3168],[3167,3167]]],[1559354058138,["GJX@GJXAIOU",[[1,3699,"\n"]],[3696,3696],[3697,3697]]],[1559354060202,["GJX@GJXAIOU",[[1,3700,"\n"]],[3697,3697],[3698,3698]]],[1559354064202,["GJX@GJXAIOU",[[1,3698,"- lingji"]],[3698,3698],[3706,3706]]],[1559354065371,["GJX@GJXAIOU",[[-1,3700,"lingji"]],[3706,3706],[3700,3700]]],[1559354066561,["GJX@GJXAIOU",[[1,3700,"Lingji"]],[3700,3700],[3706,3706]]],[1559354067507,["GJX@GJXAIOU",[[-1,3700,"Lingji"]],[3706,3706],[3700,3700]]],[1559354071491,["GJX@GJXAIOU",[[1,3700,"邻接表："]],[3700,3700],[3704,3704]]],[1559354088725,["GJX@GJXAIOU",[[1,2526,"- \n"]],[2525,2525],[2528,2528]]],[1559354090634,["GJX@GJXAIOU",[[1,2526,"  "]],[2528,2528],[2530,2530]]],[1559354094074,["GJX@GJXAIOU",[[1,2530,"缺点;"]],[2530,2530],[2533,2533]]],[1559354094932,["GJX@GJXAIOU",[[-1,2532,";"]],[2533,2533],[2532,2532]]],[1559354096257,["GJX@GJXAIOU",[[1,2532,":duiy"]],[2532,2532],[2537,2537]]],[1559354097060,["GJX@GJXAIOU",[[-1,2532,":duiy"]],[2537,2537],[2532,2532]]],[1559354105170,["GJX@GJXAIOU",[[1,2532,":对于边数相比"]],[2532,2532],[2539,2539]]],[1559354129457,["GJX@GJXAIOU",[[1,2539,"顶点树很少的的图，该结构较为浪费"]],[2539,2539],[2555,2555]]],[1559354132756,["GJX@GJXAIOU",[[-1,2545,"的"]],[2546,2546],[2545,2545]]],[1559354136076,["GJX@GJXAIOU",[[1,2554,"；"]],[2554,2554],[2555,2555]]],[1559354141641,["GJX@GJXAIOU",[[1,2533,"**"],[1,2554,"**"]],[2533,2554],[2533,2558]]],[1559354237191,["GJX@GJXAIOU",[[1,3739,"–图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。\n\n–图中每个顶点Vi的所有邻接点构成一个线性表，由于邻接点的个数不确定，所以我们选择用单链表来存储。"]],[3739,3739],[3843,3843]]],[1559354239578,["GJX@GJXAIOU",[[-1,3739,"–"]],[3740,3740],[3739,3739]]],[1559354241319,["GJX@GJXAIOU",[[-1,3792,"\n"]],[3792,3792],[3792,3792]]],[1559354243535,["GJX@GJXAIOU",[[-1,3792,"–"]],[3793,3793],[3792,3792]]],[1559354244825,["GJX@GJXAIOU",[[1,3792,"- "]],[3792,3792],[3794,3794]]],[1559354246841,["GJX@GJXAIOU",[[1,3739,"- "]],[3739,3739],[3741,3741]]],[1559354249779,["GJX@GJXAIOU",[[1,3739,"  "],[1,3794,"  "]],[3740,3844],[3742,3848]]],[1559354264401,["GJX@GJXAIOU",[[1,3738,"将数组和链表相结合"]],[3738,3738],[3747,3747]]],[1559354842981,["GJX@GJXAIOU",[[1,3858,"![邻接表(有向图入度)]($resource/%E9%82%BB%E6%8E%A5%E8%A1%A8(%E6%9C%89%E5%90%91%E5%9B%BE%E5%85%A5%E5%BA%A6).png)\n![邻接表（无向图）]($resource/%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%89.png)\n![邻接表（有向图出度）]($resource/%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E6%9C%89%E5%90%91%E5%9B%BE%E5%87%BA%E5%BA%A6%EF%BC%89.png)\n"]],[3858,3858],[4182,4182]]],[1559354846599,["GJX@GJXAIOU",[[-1,3955,")"]],[3956,3956],[3955,3955]]],[1559354862542,["GJX@GJXAIOU",[[1,3955,")"]],[3955,3955],[3956,3956]]],[1559354886345,["GJX@GJXAIOU",[[1,2859,")"]],[2859,2859],[2860,2860]]],[1559354893323,["GJX@GJXAIOU",[[1,4184,"\n"]],[4183,4183],[4184,4184]]],[1559354893466,["GJX@GJXAIOU",[[1,4185,"\n"]],[4184,4184],[4185,4185]]],[1559355074864,["GJX@GJXAIOU",[[1,4184,"![邻接表（网）]($resource/%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E7%BD%91%EF%BC%89.png)"]],[4184,4184],[4264,4264]]],[1559355151828,["GJX@GJXAIOU",[[1,4265,"\n"]],[4263,4263],[4264,4264]]],[1559355151961,["GJX@GJXAIOU",[[1,4266,"\n"]],[4264,4264],[4265,4265]]],[1559355155214,["GJX@GJXAIOU",[[1,4265,"lingjie"]],[4265,4265],[4272,4272]]],[1559355156400,["GJX@GJXAIOU",[[-1,4265,"lingjie"]],[4272,4272],[4265,4265]]],[1559355164042,["GJX@GJXAIOU",[[1,4265,"邻接点"]],[4265,4265],[4268,4268]]],[1559355170421,["GJX@GJXAIOU",[[-1,4267,"点"]],[4268,4268],[4267,4267]]],[1559355178948,["GJX@GJXAIOU",[[1,4267,"表结点的定义代码："]],[4267,4267],[4276,4276]]],[1559355179189,["GJX@GJXAIOU",[[1,4278,"\n"]],[4276,4276],[4277,4277]]],[1559355180881,["GJX@GJXAIOU",[[1,4277,"```"]],[4277,4277],[4280,4280]]],[1559355180924,["GJX@GJXAIOU",[[1,4280,"language\n```\n"]],[4280,4280],[4280,4288]]],[1559355183867,["GJX@GJXAIOU",[[-1,4280,"language"],[1,4288,"c"]],[4280,4288],[4281,4281]]],[1559355184474,["GJX@GJXAIOU",[[1,4282,"\n"]],[4281,4281],[4282,4282]]],[1559355189950,["GJX@GJXAIOU",[[1,4831,"\n"]],[4828,4828],[4829,4829]]],[1559355191538,["GJX@GJXAIOU",[[1,4832,"\n"]],[4829,4829],[4830,4830]]],[1559355193115,["GJX@GJXAIOU",[[1,4830,"lingj"]],[4830,4830],[4835,4835]]],[1559355194585,["GJX@GJXAIOU",[[-1,4830,"lingj"]],[4835,4835],[4830,4830]]],[1559355200174,["GJX@GJXAIOU",[[1,4830,"邻接表的创建："]],[4830,4830],[4837,4837]]],[1559355200993,["GJX@GJXAIOU",[[1,4840,"\n"]],[4837,4837],[4838,4838]]],[1559355202032,["GJX@GJXAIOU",[[1,4837,"    "]],[4837,4837],[4841,4841]]],[1559355203364,["GJX@GJXAIOU",[[-1,4839,"  "]],[4841,4841],[4839,4839]]],[1559355204411,["GJX@GJXAIOU",[[1,4843,"\n"]],[4839,4839],[4840,4840]]],[1559355204874,["GJX@GJXAIOU",[[1,4840,"·"]],[4840,4840],[4841,4841]]],[1559355206032,["GJX@GJXAIOU",[[-1,4840,"·"]],[4841,4841],[4840,4840]]],[1559355207211,["GJX@GJXAIOU",[[1,4840,"```"]],[4840,4840],[4843,4843]]],[1559355207246,["GJX@GJXAIOU",[[1,4843,"language\n```\n"]],[4843,4843],[4843,4851]]],[1559355208339,["GJX@GJXAIOU",[[-1,4843,"language"],[1,4851,"c"]],[4843,4851],[4844,4844]]],[1559355208566,["GJX@GJXAIOU",[[1,4845,"\n"]],[4844,4844],[4845,4845]]],[1559355218009,["GJX@GJXAIOU",[[1,4845,"/* 建立图的邻接表结构 */\nvoid  CreateALGraph(GraphAdjList *G)\n{\n\tint i,j,k;\n\tEdgeNode *e;\n\tprintf(\"输入顶点数和边数:\\n\");\n\tscanf(\"%d,%d\",&G->numNodes,&G->numEdges); /* 输入顶点数和边数 */\n\tfor(i = 0;i < G->numNodes;i++) /* 读入顶点信息,建立顶点表 */\n\t{\n\t\tscanf(&G->adjList[i].data); \t/* 输入顶点信息 */\n\t\tG->adjList[i].firstedge=NULL; \t/* 将边表置为空表 */\n\t}\n\t\n\t\n\tfor(k = 0;k < G->numEdges;k++)/* 建立边表 */\n\t{\n\t\tprintf(\"输入边(vi,vj)上的顶点序号:\\n\");\n\t\tscanf(\"%d,%d\",&i,&j); /* 输入边(vi,vj)上的顶点序号 */\n\t\te=(EdgeNode *)malloc(sizeof(EdgeNode)); /* 向内存申请空间,生成边表结点 */\n\t\te->adjvex=j;\t\t\t\t\t/* 邻接序号为j */                         \n\t\te->next=G->adjList[i].firstedge;\t/* 将e的指针指向当前顶点上指向的结点 */\n\t\tG->adjList[i].firstedge=e;\t\t/* 将当前顶点的指针指向e */               \n\t\t\n\t\te=(EdgeNode *)malloc(sizeof(EdgeNode)); /* 向内存申请空间,生成边表结点 */\n\t\te->adjvex=i;\t\t\t\t\t/* 邻接序号为i */                         \n\t\te->next=G->adjList[j].firstedge;\t/* 将e的指针指向当前顶点上指向的结点 */\n\t\tG->adjList[j].firstedge=e;\t\t/* 将当前顶点的指针指向e */               \n\t}\n}"]],[4845,4845],[5776,5776]]],[1559355305536,[null,[[-1,4282,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4319,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4321,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4326,"\n邻接表的创建：  \n```"],[1,5259,"\n```\n\n\n\n\n"]],[4282,4282],[5268,5268]]],[1559355305536,[null,[[1,4282,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4282,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4790,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4829,"\n邻接表的创建：  \n```"],[-1,5776,"\n```\n\n\n\n\n"]],[5268,5268],[4282,4282]]],[1559355247349,["GJX@GJXAIOU",[[1,5785,"\n"]],[5780,5780],[5781,5781]]],[1559355247738,["GJX@GJXAIOU",[[1,5786,"\n"]],[5781,5781],[5782,5782]]],[1559355249898,["GJX@GJXAIOU",[[1,5782,"dui"]],[5782,5782],[5785,5785]]],[1559355250527,["GJX@GJXAIOU",[[-1,5782,"dui"]],[5785,5785],[5782,5782]]],[1559355264348,["GJX@GJXAIOU",[[1,5782,"对于n条边"]],[5782,5782],[5787,5787]]],[1559355265708,["GJX@GJXAIOU",[[-1,5785,"条边"]],[5787,5787],[5785,5785]]],[1559355269221,["GJX@GJXAIOU",[[1,5785,"个顶点,"]],[5785,5785],[5789,5789]]],[1559355269904,["GJX@GJXAIOU",[[-1,5788,","]],[5789,5789],[5788,5788]]],[1559355273118,["GJX@GJXAIOU",[[1,5788,"e条表"]],[5788,5788],[5791,5791]]],[1559355274343,["GJX@GJXAIOU",[[-1,5790,"表"]],[5791,5791],[5790,5790]]],[1559355280327,["GJX@GJXAIOU",[[1,5790,"边来说是件"]],[5790,5790],[5795,5795]]],[1559355281145,["GJX@GJXAIOU",[[-1,5793,"是件"]],[5795,5795],[5793,5793]]],[1559355288141,["GJX@GJXAIOU",[[1,5793,"时间复杂度第"]],[5793,5793],[5799,5799]]],[1559355290240,["GJX@GJXAIOU",[[-1,5795,"复杂度第"]],[5799,5799],[5795,5795]]],[1559355293924,["GJX@GJXAIOU",[[1,5795,"复杂度是："]],[5795,5795],[5800,5800]]],[1559355605581,[null,[[-1,4282,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4319,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4321,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4326,"\n邻接表的创建：  \n```"],[-1,5260,"\ndui"],[1,5264,"```\n\n"],[-1,5267,"条边"],[-1,5272,","],[-1,5275,"表"],[-1,5279,"是件"],[-1,5283,"复杂度第"],[1,5292,"\n\n\n\n\n"]],[4282,4282],[5297,5297]]],[1559355605581,[null,[[1,4282,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4282,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4790,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4829,"\n邻接表的创建：  \n```"],[1,5777,"\ndui"],[-1,5777,"```\n\n"],[1,5785,"条边"],[1,5788,","],[1,5790,"表"],[1,5793,"是件"],[1,5795,"复杂度第"],[-1,5800,"\n\n\n\n\n"]],[5297,5297],[4282,4282]]],[1559355548796,["GJX@GJXAIOU",[[1,5800,"O（）"]],[5800,5800],[5803,5803]]],[1559355550633,["GJX@GJXAIOU",[[-1,5801,"（）"]],[5803,5803],[5801,5801]]],[1559355552044,["GJX@GJXAIOU",[[1,5801,"()"]],[5801,5801],[5803,5803]]],[1559355556051,["GJX@GJXAIOU",[[1,5802,"n+e"]],[5802,5802],[5805,5805]]],[1559355560280,["GJX@GJXAIOU",[[1,5800,"**"],[1,5806,"**"]],[5800,5806],[5800,5810]]],[1559355571240,["GJX@GJXAIOU",[[1,3733,"\n"]],[3731,3731],[3732,3732]]],[1559355580675,["GJX@GJXAIOU",[[1,3732,"dui"]],[3732,3732],[3735,3735]]],[1559355581492,["GJX@GJXAIOU",[[-1,3732,"dui"]],[3735,3735],[3732,3732]]],[1559355589129,["GJX@GJXAIOU",[[1,3732,"对于n个结点e个"]],[3732,3732],[3740,3740]]],[1559355589899,["GJX@GJXAIOU",[[-1,3739,"个"]],[3740,3740],[3739,3739]]],[1559355592360,["GJX@GJXAIOU",[[1,3739,"条边的"]],[3739,3739],[3742,3742]]],[1559355665570,[null,[[-1,4293,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4330,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4332,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4337,"\n邻接表的创建：  \n```"],[-1,5271,"\ndui"],[1,5275,"```\n\n"],[-1,5278,"条边"],[-1,5283,","],[-1,5286,"表"],[-1,5290,"是件"],[-1,5297,"第复杂度"],[1,5303,"**"],[-1,5304,"（）"],[-1,5307,")"],[1,5311,")"],[-1,5313,"**"],[1,5315,"\n\n\n\n\n"]],[4293,4293],[5320,5320]]],[1559355665570,[null,[[1,4293,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4293,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4801,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4840,"\n邻接表的创建：  \n```"],[1,5788,"\ndui"],[-1,5788,"```\n\n"],[1,5796,"条边"],[1,5799,","],[1,5801,"表"],[1,5804,"是件"],[1,5809,"第复杂度"],[-1,5811,"**"],[1,5814,"（）"],[1,5815,")"],[-1,5818,")"],[1,5821,"**"],[-1,5821,"\n\n\n\n\n"]],[5320,5320],[4293,4293]]],[1559355622146,["GJX@GJXAIOU",[[1,3742,"无向网图创建的时间复杂度为：0"]],[3742,3742],[3757,3757]]],[1559355623058,["GJX@GJXAIOU",[[-1,3756,"0"]],[3757,3757],[3756,3756]]],[1559355623539,["GJX@GJXAIOU",[[1,3756,")"]],[3756,3756],[3757,3757]]],[1559355624156,["GJX@GJXAIOU",[[-1,3756,")"]],[3757,3757],[3756,3756]]],[1559355626330,["GJX@GJXAIOU",[[1,3756,"O()"]],[3756,3756],[3759,3759]]],[1559355636169,["GJX@GJXAIOU",[[1,3758,"n+n62"]],[3758,3758],[3763,3763]]],[1559355637043,["GJX@GJXAIOU",[[-1,3761,"62"]],[3763,3763],[3761,3761]]],[1559355640362,["GJX@GJXAIOU",[[1,3761,"^2 __"]],[3761,3761],[3765,3765]]],[1559355642074,["GJX@GJXAIOU",[[1,3765,"e"]],[3765,3765],[3766,3766]]],[1559355643353,["GJX@GJXAIOU",[[-1,3765,"e_"]],[3766,3766],[3764,3764]]],[1559355644653,["GJX@GJXAIOU",[[-1,3764,"_"]],[3765,3765],[3764,3764]]],[1559355645624,["GJX@GJXAIOU",[[1,3764,"_+"]],[3764,3764],[3766,3766]]],[1559355645661,["GJX@GJXAIOU",[[-1,3765,"+"],[1,3766,"_"]],[3766,3766],[3765,3765]]],[1559355646268,["GJX@GJXAIOU",[[-1,3765,"_"]],[3765,3765],[3764,3764]]],[1559355647403,["GJX@GJXAIOU",[[-1,3764,"_"]],[3765,3765],[3764,3764]]],[1559355650250,["GJX@GJXAIOU",[[1,3764,"+e"]],[3764,3764],[3766,3766]]],[1559355655869,["GJX@GJXAIOU",[[1,3756,"**"],[1,3767,"**"]],[3756,3767],[3756,3771]]],[1559355785589,[null,[[-1,4322,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4359,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4361,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4366,"\n邻接表的创建：  \n```"],[-1,5300,"\ndui"],[1,5304,"```\n\n"],[-1,5307,"条边"],[-1,5312,","],[-1,5315,"表"],[-1,5319,"是件"],[-1,5326,"第复杂度"],[1,5332,"**"],[-1,5333,"（）"],[-1,5336,")"],[1,5340,")"],[-1,5342,"**"],[1,5344,"\n\n\n\n\n"]],[4322,4322],[5349,5349]]],[1559355785589,[null,[[1,4322,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4322,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4830,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4869,"\n邻接表的创建：  \n```"],[1,5817,"\ndui"],[-1,5817,"```\n\n"],[1,5825,"条边"],[1,5828,","],[1,5830,"表"],[1,5833,"是件"],[1,5838,"第复杂度"],[-1,5840,"**"],[1,5843,"（）"],[1,5844,")"],[-1,5847,")"],[1,5850,"**"],[-1,5850,"\n\n\n\n\n"]],[5349,5349],[4322,4322]]],[1559355772155,["GJX@GJXAIOU",[[1,3899,"  - \n"]],[3898,3898],[3903,3903]]],[1559355772371,["GJX@GJXAIOU",[[-1,3899,"  - "]],[3903,3903],[3900,3900]]],[1559355775227,["GJX@GJXAIOU",[[1,3900,"\n"]],[3899,3899],[3900,3900]]],[1559355777403,["GJX@GJXAIOU",[[1,3900,"****"]],[3900,3900],[3902,3902]]],[1559355782714,["GJX@GJXAIOU",[[1,3902,"lignji"]],[3902,3902],[3908,3908]]],[1559355783979,["GJX@GJXAIOU",[[-1,3902,"lignji"]],[3908,3908],[3902,3902]]],[1559355845595,[null,[[-1,4328,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4365,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4367,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4372,"\n邻接表的创建：  \n```"],[-1,5306,"\ndui"],[1,5310,"```\n\n"],[-1,5313,"条边"],[-1,5318,","],[-1,5321,"表"],[-1,5325,"是件"],[-1,5332,"第复杂度"],[1,5338,"**"],[-1,5339,"（）"],[-1,5342,")"],[1,5346,")"],[-1,5348,"**"],[1,5350,"\n\n\n\n\n"]],[4328,4328],[5355,5355]]],[1559355845595,[null,[[1,4328,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4328,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4836,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4875,"\n邻接表的创建：  \n```"],[1,5823,"\ndui"],[-1,5823,"```\n\n"],[1,5831,"条边"],[1,5834,","],[1,5836,"表"],[1,5839,"是件"],[1,5844,"第复杂度"],[-1,5846,"**"],[1,5849,"（）"],[1,5850,")"],[-1,5853,")"],[1,5856,"**"],[-1,5856,"\n\n\n\n\n"]],[5355,5355],[4328,4328]]],[1559355825233,["GJX@GJXAIOU",[[1,3902,"邻接表只关心出度，必须通过遍历整个图才能了解入度，逆邻接表反之"]],[3902,3902],[3933,3933]]],[1559355833413,["GJX@GJXAIOU",[[1,5892,"\n"]],[5889,5889],[5890,5890]]],[1559355840759,["GJX@GJXAIOU",[[1,5890,"- 十字链表"]],[5890,5890],[5896,5896]]],[1559355905589,[null,[[-1,4359,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4396,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4398,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4403,"\n邻接表的创建：  \n```"],[-1,5337,"\ndui"],[1,5341,"```\n\n"],[-1,5344,"条边"],[-1,5349,","],[-1,5352,"表"],[-1,5356,"是件"],[-1,5363,"第复杂度"],[1,5369,"**"],[-1,5370,"（）"],[-1,5373,")"],[1,5377,")"],[-1,5379,"**"],[1,5381,"\n\n"],[1,5388,"\n\n\n"]],[4359,4359],[5391,5391]]],[1559355905589,[null,[[1,4359,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4359,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4867,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4906,"\n邻接表的创建：  \n```"],[1,5854,"\ndui"],[-1,5854,"```\n\n"],[1,5862,"条边"],[1,5865,","],[1,5867,"表"],[1,5870,"是件"],[1,5875,"第复杂度"],[-1,5877,"**"],[1,5880,"（）"],[1,5881,")"],[-1,5884,")"],[1,5887,"**"],[-1,5887,"\n\n"],[-1,5896,"\n\n\n"]],[5391,5391],[4359,4359]]],[1559355853908,["GJX@GJXAIOU",[[1,3902,"针对于有向图："]],[3902,3902],[3909,3909]]],[1559356026119,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[1,5384,")"],[-1,5386,"**"],[1,5388,"\n\n"],[1,5395,"\n\n\n"]],[4366,4366],[5398,5398]]],[1559356026119,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[-1,5891,")"],[1,5894,"**"],[-1,5894,"\n\n"],[-1,5903,"\n\n\n"]],[5398,5398],[4366,4366]]],[1559355993876,["GJX@GJXAIOU",[[1,5903,"：针对于有向图，结合邻接表和逆邻接表；"]],[5903,5903],[5922,5922]]],[1559356878121,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n\n"]],[4366,4366],[5417,5417]]],[1559356878121,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n\n"]],[5417,5417],[4366,4366]]],[1559356868939,["GJX@GJXAIOU",[[1,5924,"![十字链表结点结构]($resource/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84.jpg)\n"]],[5924,5924],[6024,6024]]],[1559356872250,["GJX@GJXAIOU",[[1,6025,"\n"]],[6024,6024],[6025,6025]]],[1559357238128,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[1,5513,"\n"]],[4366,4366],[5514,5514]]],[1559357238128,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[-1,6023,"\n"]],[5514,5514],[4366,4366]]],[1559357234108,["GJX@GJXAIOU",[[1,6025,"![十字链表示例]($resource/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E7%A4%BA%E4%BE%8B.jpg)\n"]],[6025,6025],[6105,6105]]],[1559357236302,["GJX@GJXAIOU",[[1,6106,"\n"]],[6105,6105],[6106,6106]]],[1559357358131,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[1,5594,"\n"]],[4366,4366],[5595,5595]]],[1559357358131,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[-1,6104,"\n"]],[5595,5595],[4366,4366]]],[1559357315526,["GJX@GJXAIOU",[[1,6107,"\n"]],[6105,6105],[6106,6106]]],[1559357342966,["GJX@GJXAIOU",[[1,6106,"时间复杂度和邻接表相同；"]],[6106,6106],[6118,6118]]],[1559357418134,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[1,5609,"\n\n"]],[4366,4366],[5611,5611]]],[1559357418134,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[-1,6118,"\n\n"]],[5611,5611],[4366,4366]]],[1559357384300,["GJX@GJXAIOU",[[1,6120,"\n"]],[6118,6118],[6119,6119]]],[1559357384434,["GJX@GJXAIOU",[[1,6121,"\n"]],[6119,6119],[6120,6120]]],[1559357658169,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[1,5611,"\n\n"]],[4366,4366],[5613,5613]]],[1559357658169,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[-1,6120,"\n\n"]],[5613,5613],[4366,4366]]],[1559357656827,["GJX@GJXAIOU",[[1,6122,"\n"]],[6119,6119],[6120,6120]]],[1559357656963,["GJX@GJXAIOU",[[1,6123,"\n"]],[6120,6120],[6121,6121]]],[1559357657235,["GJX@GJXAIOU",[[1,6124,"\n"]],[6121,6121],[6122,6122]]],[1559357658100,["GJX@GJXAIOU",[[1,6122,"- "]],[6122,6122],[6124,6124]]],[1559357718166,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[1,5616,"\n\n\n"]],[4366,4366],[5619,5619]]],[1559357718166,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[-1,6124,"\n\n\n"]],[5619,5619],[4366,4366]]],[1559357673175,["GJX@GJXAIOU",[[1,6124,"邻接多重表："]],[6124,6124],[6130,6130]]],[1559357778166,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[1,5622,"\n\n\n"]],[4366,4366],[5625,5625]]],[1559357778166,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[-1,6130,"\n\n\n"]],[5625,5625],[4366,4366]]],[1559357735673,["GJX@GJXAIOU",[[1,6130,"针对无向图的邻接表"]],[6130,6130],[6139,6139]]],[1559357898168,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[1,5631,"\n\n\n"]],[4366,4366],[5634,5634]]],[1559357898168,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[-1,6139,"\n\n\n"]],[5634,5634],[4366,4366]]],[1559357875073,["GJX@GJXAIOU",[[1,6139,"的优化"]],[6139,6139],[6142,6142]]],[1559357875460,["GJX@GJXAIOU",[[1,6143,"- \n"]],[6142,6142],[6145,6145]]],[1559357878835,["GJX@GJXAIOU",[[1,6143,"  "]],[6145,6145],[6147,6147]]],[1559357890681,["GJX@GJXAIOU",[[1,6147,"邻接表主要关注"]],[6147,6147],[6154,6154]]],[1559358018176,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[1,5646,"\n\n\n"]],[4366,4366],[5649,5649]]],[1559358018176,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[-1,6154,"\n\n\n"]],[5649,5649],[4366,4366]]],[1559358010559,["GJX@GJXAIOU",[[1,6154,"顶点，邻接多重表主要关注边的擦偶"]],[6154,6154],[6170,6170]]],[1559358011213,["GJX@GJXAIOU",[[-1,6168,"擦偶"]],[6170,6170],[6168,6168]]],[1559358014376,["GJX@GJXAIOU",[[1,6168,"操作，"]],[6168,6168],[6171,6171]]],[1559358078171,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5638," -"],[-1,5660,"擦偶"],[1,5665,"\n\n\n"]],[4366,4366],[5668,5668]]],[1559358078171,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6144," -"],[1,6168,"擦偶"],[-1,6171,"\n\n\n"]],[5668,5668],[4366,4366]]],[1559358018980,["GJX@GJXAIOU",[[-1,6170,"，"]],[6171,6171],[6170,6170]]],[1559358064874,["GJX@GJXAIOU",[[1,6170,"，例如对"]],[6170,6170],[6174,6174]]],[1559358066461,["GJX@GJXAIOU",[[-1,6173,"对"]],[6174,6174],[6173,6173]]],[1559358075592,["GJX@GJXAIOU",[[1,6173,"对已访问的边的"]],[6173,6173],[6180,6180]]],[1559358138176,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- \n "],[1,5638,"\n  -"],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5668,"对"],[1,5676,"\n\n\n"]],[4366,4366],[5679,5679]]],[1559358138176,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- \n "],[-1,6142,"\n  -"],[1,6168,"擦偶"],[1,6170,"，"],[1,6173,"对"],[-1,6180,"\n\n\n"]],[5679,5679],[4366,4366]]],[1559358093430,["GJX@GJXAIOU",[[1,6180,"标记，删除某一条边等；"]],[6180,6180],[6191,6191]]],[1559358110349,["GJX@GJXAIOU",[[1,6192,"  - \n"]],[6191,6191],[6196,6196]]],[1559358110484,["GJX@GJXAIOU",[[-1,6192,"  - "]],[6196,6196],[6193,6193]]],[1559358122462,["GJX@GJXAIOU",[[1,6193,"重新定义边表的结点结构："]],[6193,6193],[6205,6205]]],[1559358123884,["GJX@GJXAIOU",[[1,6207,"\n"]],[6205,6205],[6206,6206]]],[1559358438184,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5705,"\n\n"]],[4366,4366],[5707,5707]]],[1559358438184,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6206,"\n\n"]],[5707,5707],[4366,4366]]],[1559358429217,["GJX@GJXAIOU",[[1,6206,"![邻接多重表]($resource/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8.jpg)"]],[6206,6206],[6276,6276]]],[1559358431340,["GJX@GJXAIOU",[[1,6277,"\n"]],[6276,6276],[6277,6277]]],[1559358498184,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5665,"，"],[-1,5668,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5775,"\n\n"]],[4366,4366],[5777,5777]]],[1559358498184,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6171,"，"],[1,6173,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6276,"\n\n"]],[5777,5777],[4366,4366]]],[1559358444055,["GJX@GJXAIOU",[[1,6213,"边表结点结构"]],[6213,6213],[6219,6219]]],[1559358678186,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5665,"，"],[-1,5668,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n\n"]],[4366,4366],[5783,5783]]],[1559358678186,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6171,"，"],[1,6173,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n\n"]],[5783,5783],[4366,4366]]],[1559358658254,["GJX@GJXAIOU",[[1,6283,"![邻接多重表示例]($resource/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E7%A4%BA%E4%BE%8B.jpg)\n"]],[6283,6283],[6373,6373]]],[1559358660333,["GJX@GJXAIOU",[[1,6374,"\n"]],[6373,6373],[6374,6374]]],[1559358674318,["GJX@GJXAIOU",[[1,6375,"\n"]],[6374,6374],[6375,6375]]],[1559358674445,["GJX@GJXAIOU",[[1,6376,"\n"]],[6375,6375],[6376,6376]]],[1559358674969,["GJX@GJXAIOU",[[-1,6376,"\n"],[1,6377,"-"]],[6376,6376],[6377,6377]]],[1559358675320,["GJX@GJXAIOU",[[1,6377," "]],[6377,6377],[6378,6378]]],[1559358738184,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- \n "],[1,5638,"\n  -"],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5668,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"]],[4366,4366],[5782,5782]]],[1559358738184,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- \n "],[-1,6142,"\n  -"],[1,6168,"擦偶"],[1,6170,"，"],[1,6173,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"]],[5782,5782],[4366,4366]]],[1559358702634,["GJX@GJXAIOU",[[1,6378,"边集数组：\n- "]],[6378,6378],[6386,6386]]],[1559358704152,["GJX@GJXAIOU",[[-1,6385," "]],[6386,6386],[6385,6385]]],[1559358704579,["GJX@GJXAIOU",[[-1,6384,"-"],[1,6385,"\n"]],[6385,6385],[6384,6384]]],[1559358705475,["GJX@GJXAIOU",[[1,6384,"由两个一维数组构成，一个是存储顶点的信息，另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标(begin)、终点下标(end)和权(weight)组成"]],[6384,6384],[6465,6465]]],[1559358707940,["GJX@GJXAIOU",[[1,6466,"\n"]],[6465,6465],[6466,6466]]],[1559358737435,["GJX@GJXAIOU",[[1,6383,"关注的是边的集合，查找"]],[6383,6383],[6394,6394]]],[1559358798191,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- \n "],[1,5638,"\n  -"],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5668,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找"],[-1,5967,"关注的是边的集合，查找"],[1,5978,"\n"]],[4366,4366],[5979,5979]]],[1559358798191,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- \n "],[-1,6142,"\n  -"],[1,6168,"擦偶"],[1,6170,"，"],[1,6173,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找"],[1,6477,"关注的是边的集合，查找"],[-1,6477,"\n"]],[5979,5979],[4366,4366]]],[1559358753537,["GJX@GJXAIOU",[[1,6394,"顶点需要扫描整个边数组，适合随"]],[6394,6394],[6409,6409]]],[1559358756980,["GJX@GJXAIOU",[[-1,6408,"随"]],[6409,6409],[6408,6408]]],[1559358765402,["GJX@GJXAIOU",[[1,6408,"对边进行操作；"]],[6408,6408],[6415,6415]]],[1559358858207,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,"\n"]],[4366,4366],[6001,6001]]],[1559358858207,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,"\n"]],[6001,6001],[4366,4366]]],[1559358801874,["GJX@GJXAIOU",[[1,6499,"\n"]],[6498,6498],[6499,6499]]],[1559358836376,["GJX@GJXAIOU",[[1,6499,"![边集数组示例]($resource/%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84%E7%A4%BA%E4%BE%8B.png)\n"]],[6499,6499],[6579,6579]]],[1559358838635,["GJX@GJXAIOU",[[1,6580,"\n"]],[6579,6579],[6580,6580]]],[1559358856152,["GJX@GJXAIOU",[[1,6581,"\n"]],[6580,6580],[6581,6581]]],[1559358856300,["GJX@GJXAIOU",[[1,6582,"\n"]],[6581,6581],[6582,6582]]],[1559358858133,["GJX@GJXAIOU",[[1,6582,"## "]],[6582,6582],[6585,6585]]],[1559358918204,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6087,""],[1,6087,"\n"]],[4366,4366],[6088,6088]]],[1559358918204,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6585,""],[-1,6585,"\n"]],[6088,6088],[4366,4366]]],[1559358870544,["GJX@GJXAIOU",[[1,6585,"7.5 图的遍历"]],[6585,6585],[6593,6593]]],[1559358871057,["GJX@GJXAIOU",[[1,6594,"\n"]],[6593,6593],[6594,6594]]],[1559358871547,["GJX@GJXAIOU",[[1,6595,"\n"]],[6594,6594],[6595,6595]]],[1559364501143,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6095,""],[1,6095,"\n"]],[4366,4366],[6096,6096]]],[1559364501143,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6593,""],[-1,6593,"\n"]],[6096,6096],[4366,4366]]],[1559364481107,["GJX@GJXAIOU",[[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n"]],[6595,6595],[6694,6694]]],[1559364494152,["GJX@GJXAIOU",[[-1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)"]],[6595,6693],[6595,6595]]],[1559364621141,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)"],[1,6195,"\n"]],[4366,4366],[6196,6196]]],[1559364621141,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)"],[-1,6595,"\n"]],[6196,6196],[4366,4366]]],[1559364584775,["GJX@GJXAIOU",[[1,6596,"### 7.5.1 深度优先遍历"]],[6596,6596],[6612,6612]]],[1559364585275,["GJX@GJXAIOU",[[1,6613,"\n"]],[6612,6612],[6613,6613]]],[1559364585410,["GJX@GJXAIOU",[[1,6614,"\n"]],[6613,6613],[6614,6614]]],[1559364586146,["GJX@GJXAIOU",[[1,6615,"\n"]],[6614,6614],[6615,6615]]],[1559364586289,["GJX@GJXAIOU",[[1,6616,"\n"]],[6615,6615],[6616,6616]]],[1559364599071,["GJX@GJXAIOU",[[1,6616,"### 7.5.2 广度优先遍历"]],[6616,6616],[6632,6632]]],[1559364620955,["GJX@GJXAIOU",[[1,6595,"从图中某一顶点"]],[6595,6595],[6602,6602]]],[1559364681147,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)"],[1,6195,"从图中某一顶点"],[-1,6232,"从图中某一顶点"],[1,6239,"\n"]],[4366,4366],[6240,6240]]],[1559364681147,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)"],[-1,6595,"从图中某一顶点"],[1,6639,"从图中某一顶点"],[-1,6639,"\n"]],[6240,6240],[4366,4366]]],[1559364662125,["GJX@GJXAIOU",[[1,6602,"出发访遍图中其余结点，且每一个界定啊"]],[6602,6602],[6620,6620]]],[1559364663809,["GJX@GJXAIOU",[[-1,6617,"界定啊"]],[6620,6620],[6617,6617]]],[1559364666301,["GJX@GJXAIOU",[[1,6617,"顶点"]],[6617,6617],[6619,6619]]],[1559364670607,["GJX@GJXAIOU",[[-1,6610,"结"]],[6611,6611],[6610,6610]]],[1559364672843,["GJX@GJXAIOU",[[1,6610,"顶"]],[6610,6610],[6611,6611]]],[1559364741150,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)"],[1,6195,"从图中某一顶点出发访遍图中其余顶点，且每一个顶点"],[-1,6232,"从图中某一顶点出发访遍图中其余结点，且每一个界定啊顶点顶"],[1,6260,"\n"]],[4366,4366],[6261,6261]]],[1559364741150,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)"],[-1,6595,"从图中某一顶点出发访遍图中其余顶点，且每一个顶点"],[1,6656,"从图中某一顶点出发访遍图中其余结点，且每一个界定啊顶点顶"],[-1,6656,"\n"]],[6261,6261],[4366,4366]]],[1559364688349,["GJX@GJXAIOU",[[1,6619,"仅能被访问一次，"]],[6619,6619],[6627,6627]]],[1559364689187,["GJX@GJXAIOU",[[-1,6626,"，"]],[6627,6627],[6626,6626]]],[1559364689750,["GJX@GJXAIOU",[[1,6626,"；"]],[6626,6626],[6627,6627]]],[1559364714288,["GJX@GJXAIOU",[[1,6644,"DepthFirstSearch（）"]],[6644,6644],[6662,6662]]],[1559364716791,["GJX@GJXAIOU",[[1,6661,"DFS"]],[6661,6661],[6664,6664]]],[1559365101160,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[6312,6312]]],[1559365101160,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n\n\n\n### 7.5.2 广度优先遍历\n"]],[6312,6312],[4366,4366]]],[1559365088727,["GJX@GJXAIOU",[[1,6666,"可以假定右手原则，"]],[6666,6666],[6675,6675]]],[1559365161170,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[1,6299,"\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[6319,6319]]],[1559365161170,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[-1,6675,"\n\n\n### 7.5.2 广度优先遍历\n"]],[6319,6319],[4366,4366]]],[1559365159127,["GJX@GJXAIOU",[[1,6675,"在没有碰到重复顶点的"]],[6675,6675],[6685,6685]]],[1559365221168,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[1,6309,"\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[6329,6329]]],[1559365221168,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[-1,6685,"\n\n\n### 7.5.2 广度优先遍历\n"]],[6329,6329],[4366,4366]]],[1559365170169,["GJX@GJXAIOU",[[1,6685,"情况下，时钟"]],[6685,6685],[6691,6691]]],[1559365170990,["GJX@GJXAIOU",[[-1,6689,"时钟"]],[6691,6691],[6689,6689]]],[1559365179921,["GJX@GJXAIOU",[[1,6689,"始终走右手边"]],[6689,6689],[6695,6695]]],[1559365281173,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[1,6321,"\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[6341,6341]]],[1559365281173,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[-1,6695,"\n\n\n### 7.5.2 广度优先遍历\n"]],[6341,6341],[4366,4366]]],[1559365271797,["GJX@GJXAIOU",[[1,6695,"                "]],[6695,6695],[6711,6711]]],[1559366901250,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[1,6337,"\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[6357,6357]]],[1559366901250,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[-1,6711,"\n\n\n### 7.5.2 广度优先遍历\n"]],[6357,6357],[4366,4366]]],[1559366895527,["GJX@GJXAIOU",[[1,6695,"，如果"]],[6695,6695],[6698,6698]]],[1559366961257,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[1,6321,"，如果"],[-1,6337,"，如果"],[1,6340,"\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[6360,6360]]],[1559366961257,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[-1,6695,"，如果"],[1,6714,"，如果"],[-1,6714,"\n\n\n### 7.5.2 广度优先遍历\n"]],[6360,6360],[4366,4366]]],[1559366907751,["GJX@GJXAIOU",[[1,6698,"顶底"]],[6698,6698],[6700,6700]]],[1559366935257,["GJX@GJXAIOU",[[-1,6698,"顶底"]],[6700,6700],[6698,6698]]],[1559366959680,["GJX@GJXAIOU",[[1,6698,"遍历"]],[6698,6698],[6700,6700]]],[1559367021262,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[1,6321,"，如果遍历"],[-1,6337,"，如果顶底"],[1,6342,"\n\n\n### 7.5.2 广度优先"],[1,6344,"\n"]],[4366,4366],[6345,6345]]],[1559367021262,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[-1,6695,"，如果遍历"],[1,6716,"，如果顶底"],[-1,6716,"\n\n\n### 7.5.2 广度优先"],[-1,6735,"\n"]],[6345,6345],[4366,4366]]],[1559366977304,["GJX@GJXAIOU",[[1,6700,"又回到该顶点，则从"]],[6700,6700],[6709,6709]]],[1559366981184,["GJX@GJXAIOU",[[-1,6707,"则从"]],[6709,6709],[6707,6707]]],[1559367003010,["GJX@GJXAIOU",[[1,6707,"并且图中任有顶点未被访问，则从"]],[6707,6707],[6722,6722]]],[1559367012806,["GJX@GJXAIOU",[[-1,6721,"从"]],[6722,6722],[6721,6721]]],[1559367020482,["GJX@GJXAIOU",[[1,6721,"另选图中一个"]],[6721,6721],[6727,6727]]],[1559367081261,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[1,6374,"                \n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[6410,6410]]],[1559367081261,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[-1,6727,"                \n\n\n### 7.5.2 广度优先遍历\n"]],[6410,6410],[4366,4366]]],[1559367047560,["GJX@GJXAIOU",[[1,6727,"未被访问过的顶点作为起始点，重复上述过程，知道"]],[6727,6727],[6750,6750]]],[1559367048533,["GJX@GJXAIOU",[[-1,6748,"知道"]],[6750,6750],[6748,6748]]],[1559367059362,["GJX@GJXAIOU",[[1,6748,"直到图中所有的顶点军备"]],[6748,6748],[6759,6759]]],[1559367060607,["GJX@GJXAIOU",[[-1,6757,"军备"]],[6759,6759],[6757,6757]]],[1559367072818,["GJX@GJXAIOU",[[1,6757,"均背范文"]],[6757,6757],[6761,6761]]],[1559367074389,["GJX@GJXAIOU",[[-1,6758,"背范文"]],[6761,6761],[6758,6758]]],[1559367079164,["GJX@GJXAIOU",[[1,6758,"被访问过；"]],[6758,6758],[6763,6763]]],[1559367141271,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[1,6417,"                \n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[6453,6453]]],[1559367141271,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[-1,6763,"                \n\n\n### 7.5.2 广度优先遍历\n"]],[6453,6453],[4366,4366]]],[1559367101326,["GJX@GJXAIOU",[[1,6763,"\n"]],[6763,6763],[6764,6764]]],[1559367102110,["GJX@GJXAIOU",[[-1,6764,"                "],[1,6780,"\n"]],[6764,6764],[6765,6765]]],[1559367116543,["GJX@GJXAIOU",[[1,6765,"深度优先搜索的过程本指导喊"]],[6765,6765],[6778,6778]]],[1559367117768,["GJX@GJXAIOU",[[-1,6774,"本指导喊"]],[6778,6778],[6774,6774]]],[1559367140717,["GJX@GJXAIOU",[[1,6774,"本质上是一个递归的过程，并且通过图"]],[6774,6774],[6791,6791]]],[1559367201267,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[1,6449,"\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[6469,6469]]],[1559367201267,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[-1,6791,"\n\n\n### 7.5.2 广度优先遍历\n"]],[6469,6469],[4366,4366]]],[1559367174110,["GJX@GJXAIOU",[[1,6791,"转换之后，变成下图的有图之后，就是一棵树的前序遍历。"]],[6791,6791],[6817,6817]]],[1559367177881,["GJX@GJXAIOU",[[1,6820,"\n"]],[6819,6819],[6820,6820]]],[1559367178049,["GJX@GJXAIOU",[[1,6821,"\n"]],[6820,6820],[6821,6821]]],[1559367178673,["GJX@GJXAIOU",[[1,6822,"\n"]],[6821,6821],[6822,6822]]],[1559367742154,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[1,6478,"\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[6498,6498]]],[1559367742154,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[-1,6820,"\n\n\n### 7.5.2 广度优先遍历\n"]],[6498,6498],[4366,4366]]],[1559367702222,["GJX@GJXAIOU",[[1,6819,"![深度优先遍历转换图]($resource/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)"]],[6819,6819],[6929,6929]]],[1559367704401,["GJX@GJXAIOU",[[1,6932,"\n"]],[6929,6929],[6930,6930]]],[1559367734562,["GJX@GJXAIOU",[[1,6930,"使用邻接矩阵存储的"]],[6930,6930],[6939,6939]]],[1559367802152,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6475,"\n"],[1,6588,"\n"],[1,6597,"\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[6617,6617]]],[1559367802152,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6817,"\n"],[-1,6929,"\n"],[-1,6939,"\n\n\n### 7.5.2 广度优先遍历\n"]],[6617,6617],[4366,4366]]],[1559367754024,["GJX@GJXAIOU",[[1,6939,"图的深度搜索操作代码："]],[6939,6939],[6950,6950]]],[1559367754511,["GJX@GJXAIOU",[[1,6953,"\n"]],[6950,6950],[6951,6951]]],[1559367754803,["GJX@GJXAIOU",[[1,6954,"\n"]],[6951,6951],[6952,6952]]],[1559367757621,["GJX@GJXAIOU",[[-1,6954,"\n"]],[6952,6952],[6951,6951]]],[1559367759526,["GJX@GJXAIOU",[[1,6951,"```"]],[6951,6951],[6954,6954]]],[1559367759562,["GJX@GJXAIOU",[[1,6954,"language\n```\n"]],[6954,6954],[6954,6962]]],[1559367760777,["GJX@GJXAIOU",[[-1,6954,"language"],[1,6962,"c"]],[6954,6962],[6955,6955]]],[1559367761084,["GJX@GJXAIOU",[[1,6956,"\n"]],[6955,6955],[6956,6956]]],[1559367922159,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6475,"\n"],[1,6588,"\n"],[-1,6609,"\n"],[-1,6613,"language"],[1,6621,"c\n"],[-1,6626,"c"],[1,6627,"\n\n\n### 7.5.2 广度优先遍历"]],[4366,4366],[6646,6646]]],[1559367922159,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6817,"\n"],[-1,6929,"\n"],[1,6951,"\n"],[1,6954,"language"],[-1,6954,"c\n"],[1,6961,"c"],[-1,6961,"\n\n\n### 7.5.2 广度优先遍历"]],[6646,6646],[4366,4366]]],[1559367914700,["GJX@GJXAIOU",[[1,6956,"typedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->adjvex);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿嶄綔\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}"]],[6956,6956],[7568,7568]]],[1559367982160,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6475,"\n"],[1,6588,"\n"],[-1,6609,"\n"],[-1,6613,"language\n```\n"],[-1,7240,""],[1,7240,"\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[7265,7265]]],[1559367982160,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6817,"\n"],[-1,6929,"\n"],[1,6951,"\n"],[1,6954,"language\n```\n"],[1,7568,""],[-1,7568,"\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[7265,7265],[4366,4366]]],[1559367926199,["GJX@GJXAIOU",[[-1,6980,"杩欓噷鎴戜滑瀹氫箟"],[-1,6990,"oolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE"]],[6980,7020],[6981,6981]]],[1559367927506,["GJX@GJXAIOU",[[1,6981,"oolen"]],[6981,6981],[6986,6986]]],[1559367928068,["GJX@GJXAIOU",[[-1,6985,"n"]],[6986,6986],[6985,6985]]],[1559367937632,["GJX@GJXAIOU",[[1,6985,"an代表布尔类型，trueor"]],[6985,6985],[7000,7000]]],[1559367940678,["GJX@GJXAIOU",[[1,6998," "]],[6998,6998],[6999,6999]]],[1559367948259,["GJX@GJXAIOU",[[1,7001," false"]],[7001,7001],[7007,7007]]],[1559367955916,["GJX@GJXAIOU",[[-1,7033,"璁块棶鏍囧織鐨勬暟缁?"],[1,7044,"访问"]],[7033,7033],[7035,7035]]],[1559367967880,["GJX@GJXAIOU",[[1,7035,"标志的数组"]],[7035,7035],[7040,7040]]],[1559367973565,["GJX@GJXAIOU",[[1,7042,"\n"]],[7041,7041],[7042,7042]]],[1559367981047,["GJX@GJXAIOU",[[1,7042,"//邻接矩阵的"]],[7042,7042],[7049,7049]]],[1559368042167,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[1,6588,"\n"],[-1,6609,"\n"],[-1,6613,"language\n```\n"],[-1,6652,"杩欓噷鎴戜滑瀹氫箟"],[-1,6668,"涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE"],[1,6692,"代表布尔类型，true or false"],[-1,6718,"璁块棶鏍囧織鐨勬暟缁?\n"],[1,6730,"访问标志的数组\n\n//邻接矩阵的"],[-1,6980,"Foolean代表布尔类型，true or false"],[1,7007,"嶄綔\nvoid DFSTraverse(GraphAdjList GL)\n{\n\t"],[-1,7033,"访问标志的数组"],[1,7040,"->numVertex"],[-1,7042,"//邻接矩阵的\n"],[-1,7231,""],[1,7231,"\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[7256,7256]]],[1559368042167,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[-1,6929,"\n"],[1,6951,"\n"],[1,6954,"language\n```\n"],[1,6980,"杩欓噷鎴戜滑瀹氫箟"],[1,6987,"涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE"],[-1,6987,"代表布尔类型，true or false"],[1,7033,"璁块棶鏍囧織鐨勬暟缁?\n"],[-1,7033,"访问标志的数组\n\n//邻接矩阵的"],[1,7299,"Foolean代表布尔类型，true or false"],[-1,7299,"嶄綔\nvoid DFSTraverse(GraphAdjList GL)\n{\n\t"],[1,7365,"访问标志的数组"],[-1,7365,"->numVertex"],[1,7378,"//邻接矩阵的\n"],[1,7559,""],[-1,7559,"\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[7256,7256],[4366,4366]]],[1559367991093,["GJX@GJXAIOU",[[1,7051,"优先递归算法"]],[7051,7051],[7057,7057]]],[1559368014652,["GJX@GJXAIOU",[[1,7164," //打印顶点，这里的操作可以自定义"]],[7164,7164],[7182,7182]]],[1559368102168,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6475,"\n"],[1,6588,"\n"],[-1,6609,"\n```language\n"],[-1,6625,"\n"],[-1,6652,"杩欓噷鎴戜滑瀹氫箟"],[-1,6668,"涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE"],[1,6692,"代表布尔类型，true or false"],[-1,6718,"璁块棶鏍囧織鐨勬暟缁?\n"],[1,6730,"访问标志的数组\n\n//邻接矩阵的深度优先递归算法"],[-1,6837,""],[1,6837," //打印顶点，这里的操作可以自定义"],[-1,6980,"Foolean代表布尔类型，true or false"],[1,7007,"嶄綔\nvoid DFSTraverse(GraphAdjList GL)\n{\n\t"],[-1,7033,"访问标志的数组"],[1,7040,"->numVertex"],[-1,7042,"//邻接矩阵的\n"],[-1,7051,"优先递归算法"],[-1,7164," //打印顶点，这里的操作可以自定义"],[1,7182,""],[-1,7255,""],[1,7255,"\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[7280,7280]]],[1559368102168,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6817,"\n"],[-1,6929,"\n"],[1,6951,"\n```language\n"],[1,6954,"\n"],[1,6980,"杩欓噷鎴戜滑瀹氫箟"],[1,6987,"涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE"],[-1,6987,"代表布尔类型，true or false"],[1,7033,"璁块棶鏍囧織鐨勬暟缁?\n"],[-1,7033,"访问标志的数组\n\n//邻接矩阵的深度优先递归算法"],[1,7164,""],[-1,7164," //打印顶点，这里的操作可以自定义"],[1,7325,"Foolean代表布尔类型，true or false"],[-1,7325,"嶄綔\nvoid DFSTraverse(GraphAdjList GL)\n{\n\t"],[1,7391,"访问标志的数组"],[-1,7391,"->numVertex"],[1,7404,"//邻接矩阵的\n"],[1,7405,"优先递归算法"],[1,7512," //打印顶点，这里的操作可以自定义"],[-1,7512,""],[1,7585,""],[-1,7585,"\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[7280,7280],[4366,4366]]],[1559368054725,["GJX@GJXAIOU",[[-1,7046,"矩阵"],[1,7048,"表"]],[7046,7046],[7047,7047]]],[1559368065860,["GJX@GJXAIOU",[[1,7282," 、、"]],[7282,7282],[7285,7285]]],[1559368067015,["GJX@GJXAIOU",[[-1,7283,"、、"]],[7285,7285],[7283,7283]]],[1559368086950,["GJX@GJXAIOU",[[1,7283,"//对未访问的邻接顶点递归调用"]],[7283,7283],[7298,7298]]],[1559368162169,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6475,"\n"],[1,6588,"\n"],[-1,6609,"\n"],[-1,6613,"language\n```\n"],[-1,6652,"杩欓噷鎴戜滑瀹氫箟"],[-1,6668,"涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE"],[1,6692,"代表布尔类型，true or false"],[-1,6718,"璁块棶鏍囧織鐨勬暟缁?\n"],[1,6730,"访问标志的数组\n\n//邻接表的深度优先递归算法"],[-1,6837,""],[1,6837," //打印顶点，这里的操作可以自定义"],[1,6938," //对未访问的邻接顶点递归调用"],[-1,6980,"Foolean代表布尔类型，true or false"],[1,7007,"嶄綔\nvoid DFSTraverse(GraphAdjList GL)\n{\n\t"],[-1,7033,"访问标志的数组"],[1,7040,"->numVertex"],[-1,7042,"//邻接表的\n"],[-1,7050,"优先递归算法"],[-1,7163," //打印顶点，这里的操作可以自定义"],[1,7181,""],[-1,7254," 、、//对未访问的邻接顶点递归调用"],[1,7272,"\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[7297,7297]]],[1559368162169,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6817,"\n"],[-1,6929,"\n"],[1,6951,"\n"],[1,6954,"language\n```\n"],[1,6980,"杩欓噷鎴戜滑瀹氫箟"],[1,6987,"涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE"],[-1,6987,"代表布尔类型，true or false"],[1,7033,"璁块棶鏍囧織鐨勬暟缁?\n"],[-1,7033,"访问标志的数组\n\n//邻接表的深度优先递归算法"],[1,7163,""],[-1,7163," //打印顶点，这里的操作可以自定义"],[-1,7282," //对未访问的邻接顶点递归调用"],[1,7340,"Foolean代表布尔类型，true or false"],[-1,7340,"嶄綔\nvoid DFSTraverse(GraphAdjList GL)\n{\n\t"],[1,7406,"访问标志的数组"],[-1,7406,"->numVertex"],[1,7419,"//邻接表的\n"],[1,7420,"优先递归算法"],[1,7527," //打印顶点，这里的操作可以自定义"],[-1,7527,""],[1,7600," 、、//对未访问的邻接顶点递归调用"],[-1,7600,"\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[7297,7297],[4366,4366]]],[1559368106540,["GJX@GJXAIOU",[[-1,7327,"閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿嶄綔"],[1,7342,"邻接表"]],[7327,7327],[7330,7330]]],[1559368114155,["GJX@GJXAIOU",[[1,7330,"的深度遍历操作"]],[7330,7330],[7337,7337]]],[1559368130967,["GJX@GJXAIOU",[[-1,7451,"鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7477,"初始化"]],[7451,7451],[7454,7454]]],[1559368144251,["GJX@GJXAIOU",[[1,7454,"所有顶点状态都是未访问过状态"]],[7454,7454],[7468,7468]]],[1559368155597,["GJX@GJXAIOU",[[-1,7539,"鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7558,"对"]],[7539,7539],[7540,7540]]],[1559368162032,["GJX@GJXAIOU",[[1,7540,"未访问的顶点"]],[7540,7540],[7546,7546]]],[1559368222181,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6475,"\n"],[1,6588,"\n"],[-1,6609,"\n"],[-1,6613,"language\n```\n"],[-1,6652,"杩欓噷鎴戜滑瀹氫箟"],[-1,6668,"涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE"],[1,6692,"代表布尔类型，true or false"],[-1,6718,"璁块棶鏍囧織鐨勬暟缁?\n"],[1,6730,"访问标志的数组\n\n//邻接表的深度优先递归算法"],[-1,6837,""],[1,6837," //打印顶点，这里的操作可以自定义"],[1,6938," //对未访问的邻接顶点递归调用"],[-1,6967,"閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿Foolean代表布尔类型，true or false"],[1,7007,"邻接表的深度遍历操作\nvoid DFSTraverse(GraphAdjList GL)\n{\n\t"],[-1,7033,"访问标志的数组"],[1,7040,"->numVertex"],[-1,7042,"//邻接表的\n"],[-1,7050,"优先递归算法"],[-1,7092,"鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7118,"初始化所有顶点状态都是未访问过状态"],[-1,7163," //打印顶点，这里的操作可以自定义"],[-1,7207,"鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7226,"对未访问的顶点"],[-1,7254," 、、//对未访问的邻接顶点递归调用邻接表的深度遍历操作初始化所有顶点状态都是未访问过状态对未访问的顶点"],[1,7306,"\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[7331,7331]]],[1559368222181,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6817,"\n"],[-1,6929,"\n"],[1,6951,"\n"],[1,6954,"language\n```\n"],[1,6980,"杩欓噷鎴戜滑瀹氫箟"],[1,6987,"涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE"],[-1,6987,"代表布尔类型，true or false"],[1,7033,"璁块棶鏍囧織鐨勬暟缁?\n"],[-1,7033,"访问标志的数组\n\n//邻接表的深度优先递归算法"],[1,7163,""],[-1,7163," //打印顶点，这里的操作可以自定义"],[-1,7282," //对未访问的邻接顶点递归调用"],[1,7327,"閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿Foolean代表布尔类型，true or false"],[-1,7327,"邻接表的深度遍历操作\nvoid DFSTraverse(GraphAdjList GL)\n{\n\t"],[1,7401,"访问标志的数组"],[-1,7401,"->numVertex"],[1,7414,"//邻接表的\n"],[1,7415,"优先递归算法"],[1,7451,"鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7451,"初始化所有顶点状态都是未访问过状态"],[1,7513," //打印顶点，这里的操作可以自定义"],[1,7539,"鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7539,"对未访问的顶点"],[1,7574," 、、//对未访问的邻接顶点递归调用邻接表的深度遍历操作初始化所有顶点状态都是未访问过状态对未访问的顶点"],[-1,7574,"\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[7331,7331],[4366,4366]]],[1559368180138,["GJX@GJXAIOU",[[1,7546,"调用DFS，若是连通图，只执行一次"]],[7546,7546],[7563,7563]]],[1559368189607,["GJX@GJXAIOU",[[-1,6934,"矩阵"]],[6936,6936],[6934,6934]]],[1559368191803,["GJX@GJXAIOU",[[1,6934,"表"]],[6934,6934],[6935,6935]]],[1559368197356,["GJX@GJXAIOU",[[1,6930,"\n"]],[6929,6929],[6930,6930]]],[1559368197489,["GJX@GJXAIOU",[[1,6931,"\n"]],[6930,6930],[6931,6931]]],[1559368197611,["GJX@GJXAIOU",[[1,6932,"\n"]],[6931,6931],[6932,6932]]],[1559368197732,["GJX@GJXAIOU",[[1,6933,"\n"]],[6932,6932],[6933,6933]]],[1559368197871,["GJX@GJXAIOU",[[1,6934,"\n"]],[6933,6933],[6934,6934]]],[1559368198016,["GJX@GJXAIOU",[[1,6935,"\n"]],[6934,6934],[6935,6935]]],[1559368198139,["GJX@GJXAIOU",[[1,6936,"\n"]],[6935,6935],[6936,6936]]],[1559368198238,["GJX@GJXAIOU",[[1,6937,"\n"]],[6936,6936],[6937,6937]]],[1559368198352,["GJX@GJXAIOU",[[1,6938,"\n"]],[6937,6937],[6938,6938]]],[1559368201709,["GJX@GJXAIOU",[[1,6931,"使用邻接表存储的图的深度搜索操作代码："]],[6931,6931],[6950,6950]]],[1559368204801,["GJX@GJXAIOU",[[-1,6935,"表"]],[6936,6936],[6935,6935]]],[1559368206696,["GJX@GJXAIOU",[[1,6935,"矩阵"]],[6935,6935],[6937,6937]]],[1559368212062,["GJX@GJXAIOU",[[1,6953,"```c"]],[6953,6953],[6957,6957]]],[1559368212445,["GJX@GJXAIOU",[[1,6963,"\n"]],[6957,6957],[6958,6958]]],[1559368212595,["GJX@GJXAIOU",[[1,6964,"\n"]],[6958,6958],[6959,6959]]],[1559368212734,["GJX@GJXAIOU",[[1,6965,"\n"]],[6959,6959],[6960,6960]]],[1559368212854,["GJX@GJXAIOU",[[1,6966,"\n"]],[6960,6960],[6961,6961]]],[1559368214089,["GJX@GJXAIOU",[[1,6961,"ccc"]],[6961,6961],[6964,6964]]],[1559368215712,["GJX@GJXAIOU",[[-1,6961,"ccc"]],[6964,6964],[6961,6961]]],[1559368215812,["GJX@GJXAIOU",[[-1,6966,"\n"]],[6961,6961],[6960,6960]]],[1559368215985,["GJX@GJXAIOU",[[-1,6965,"\n"]],[6960,6960],[6959,6959]]],[1559368217097,["GJX@GJXAIOU",[[1,6959,"```"]],[6959,6959],[6962,6962]]],[1559368282178,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[1,6588,"\n\n"],[-1,6613,"language"],[1,6621,"c\n"],[1,6626,"\n\n\n\n\n使用邻接表存储的图的深度搜索操作代码：\n```"],[-1,6652,"杩欓噷鎴戜滑瀹氫箟"],[-1,6668,"涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE"],[1,6692,"代表布尔类型，true or false"],[-1,6718,"璁块棶鏍囧織鐨勬暟缁?\n"],[1,6730,"访问标志的数组\n\n//邻接表的深度优先递归算法"],[-1,6837,""],[1,6837," //打印顶点，这里的操作可以自定义"],[-1,6930,"\n使用邻接矩阵存储的图的深度搜索操作代码：\n\n```c\n\n```\n\n\n\n\n\n"],[-1,6972,"表"],[1,6973,"ex"],[1,6975," //对未访问的邻接顶点递归调用"],[-1,7004,"閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿Foolean代表布尔类型，true or false"],[1,7044,"邻接表的深度遍历操作\nvoid DFSTraverse(GraphAdjList GL)\n{\n\t"],[-1,7070,"访问标志的数组"],[1,7077,"->numVertex"],[-1,7079,"//邻接表的\n"],[-1,7087,"优先递归算法"],[-1,7129,"鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7155,"初始化所有顶点状态都是未访问过状态"],[-1,7200," //打印顶点，这里的操作可以自定义"],[-1,7244,"鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7263,"对未访问的顶点调用DFS，若是连通图，只执行一次"],[-1,7291," 、、//对未访问的邻接顶点递归调用邻接表的深度遍历操作初始化所有顶点状态都是未访问过状态对未访问的顶点调用DFS，若是连通图，只执行一次"],[1,7360,"\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[7385,7385]]],[1559368282178,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[-1,6929,"\n\n"],[1,6956,"language"],[-1,6956,"c\n"],[-1,6963,"\n\n\n\n\n使用邻接表存储的图的深度搜索操作代码：\n```"],[1,7017,"杩欓噷鎴戜滑瀹氫箟"],[1,7024,"涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE"],[-1,7024,"代表布尔类型，true or false"],[1,7070,"璁块棶鏍囧織鐨勬暟缁?\n"],[-1,7070,"访问标志的数组\n\n//邻接表的深度优先递归算法"],[1,7200,""],[-1,7200," //打印顶点，这里的操作可以自定义"],[1,7311,"\n使用邻接矩阵存储的图的深度搜索操作代码：\n\n```c\n\n```\n\n\n\n\n\n"],[1,7315,"表"],[-1,7315,"ex"],[-1,7319," //对未访问的邻接顶点递归调用"],[1,7364,"閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿Foolean代表布尔类型，true or false"],[-1,7364,"邻接表的深度遍历操作\nvoid DFSTraverse(GraphAdjList GL)\n{\n\t"],[1,7438,"访问标志的数组"],[-1,7438,"->numVertex"],[1,7451,"//邻接表的\n"],[1,7452,"优先递归算法"],[1,7488,"鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7488,"初始化所有顶点状态都是未访问过状态"],[1,7550," //打印顶点，这里的操作可以自定义"],[1,7576,"鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7576,"对未访问的顶点调用DFS，若是连通图，只执行一次"],[1,7628," 、、//对未访问的邻接顶点递归调用邻接表的深度遍历操作初始化所有顶点状态都是未访问过状态对未访问的顶点调用DFS，若是连通图，只执行一次"],[-1,7628,"\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[7385,7385],[4366,4366]]],[1559368242289,["GJX@GJXAIOU",[[1,6958,"typedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(MGraph G, int i)\n{\n\tint j;\n\t\n\tvisited[j] = TRUE;\t\t\t// 璁块棶杩囩殑椤剁偣璁剧疆涓篢RUE\n\tprintf(\"%c \", G.vexs[i]);\t// 鎵撳嵃椤剁偣\n\tfor( j=0; j < G.numVertexes; j++ )\n\t{\n\t\tif( G.arc[i][j]==1 && !visited[j] )\n\t\t{\n\t\t\tDFS(G, j);\t\t\t// 瀵逛负璁块棶鐨勯偦鎺ラ《鐐归€掑綊璋冪敤\n\t\t}\n\t}\n}\n\n// 閭绘帴鐭╅樀鐨勬繁搴﹂亶鍘嗘搷浣?\nvoid DFSTraverse(MGraph G)\n{\n\tint i;\n\t\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?\n\t}\n\t\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?\n\t\t{\n\t\t\tDFS(G, i);\n\t\t}\n\t}"]],[6958,6958],[7574,7574]]],[1559368252327,["GJX@GJXAIOU",[[-1,6982,"杩欓噷鎴戜滑瀹氫箟"],[-1,6998,"涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE"],[1,7022,"代表布尔类型，true or false"],[-1,7048,"璁块棶鏍囧織鐨勬暟缁?"],[1,7059,"访问标志的数组"]],[6958,7059],[7042,7042]]],[1559368264381,["GJX@GJXAIOU",[[-1,7107,"璁块棶杩囩殑椤剁偣璁剧疆涓篢RUE"]],[7108,7124],[7107,7107]]],[1559368272482,["GJX@GJXAIOU",[[-1,7138,"鎵撳嵃椤剁偣"]],[7138,7144],[7138,7138]]],[1559368342202,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码："],[-1,6610,"```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->\n"],[-1,7544,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7594,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7620,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7646,"\nBoolean visited[MAX];\t// "],[-1,7653,"es"],[1,7655,"\n\n"],[-1,7661,"\n;"],[1,7663,"深度"],[-1,7669," i++ )\n\t{"],[1,7678,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7680,"\n"],[-1,7694,"FALS"],[1,7698,"TRU"],[-1,7700,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7733,"}\n\t\n\tfor( i=0; i <"],[1,7751,"printf(\"%c \""],[-1,7756,"numVertexes; i++ )\n\t"],[1,7776,"adjList[i].data);"],[1,7794,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7811,"i"],[1,7812,"p->adjvex"],[-1,7815,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7855,"i"],[1,7856,"p->adjvex"],[-1,7858,"\n\t\t}\n\t}\n}"],[-1,7868,"、、"],[1,7885,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7895,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7912,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7936,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[7989,7989]]],[1559368342202,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码："],[1,6931,"```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->\n"],[1,7544,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7544,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7620,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7620,"\nBoolean visited[MAX];\t// "],[1,7653,"es"],[-1,7653,"\n\n"],[1,7661,"\n;"],[-1,7661,"深度"],[1,7669," i++ )\n\t{"],[-1,7669,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7720,"\n"],[1,7735,"FALS"],[-1,7735,"TRU"],[1,7740,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7742,"}\n\t\n\tfor( i=0; i <"],[-1,7742,"printf(\"%c \""],[1,7759,"numVertexes; i++ )\n\t"],[-1,7759,"adjList[i].data);"],[-1,7794,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7856,"i"],[-1,7856,"p->adjvex"],[1,7868,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7884,"i"],[-1,7884,"p->adjvex"],[1,7895,"\n\t\t}\n\t}\n}"],[1,7896,"、、"],[-1,7911,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7950,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8081,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8176,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[7989,7989],[4366,4366]]],[1559368282201,["GJX@GJXAIOU",[[1,7138,"打印顶点，这里的操作可以自定义"]],[7138,7138],[7153,7153]]],[1559368284224,["GJX@GJXAIOU",[[-1,7104,"// "]],[7107,7107],[7104,7104]]],[1559368339751,["GJX@GJXAIOU",[[-1,7251,"瀵逛负璁块棶鐨勯偦鎺ラ《鐐归€掑綊璋冪敤"],[1,7271,"对未访问的邻接顶点递归调用"]],[7251,7271],[7264,7264]]],[1559368402214,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码："],[-1,6610,"```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->\n"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[7994,7994]]],[1559368402214,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码："],[1,6931,"```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->\n"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[7994,7994],[4366,4366]]],[1559368346714,["GJX@GJXAIOU",[[-1,7278,"閭绘帴鐭╅樀鐨勬繁搴﹂亶鍘嗘搷浣?"],[1,7295,"l"]],[7278,7295],[7279,7279]]],[1559368347506,["GJX@GJXAIOU",[[1,7279,"injie"]],[7279,7279],[7284,7284]]],[1559368349135,["GJX@GJXAIOU",[[-1,7278,"linjie"]],[7284,7284],[7278,7278]]],[1559368358891,["GJX@GJXAIOU",[[1,7278,"邻接矩阵的深度遍历操作"]],[7278,7278],[7289,7289]]],[1559368372104,["GJX@GJXAIOU",[[-1,7394,"鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7420,"初始"]],[7394,7394],[7396,7396]]],[1559368391538,["GJX@GJXAIOU",[[1,7396,"所有顶点状态都是未访问过状态"]],[7396,7396],[7410,7410]]],[1559368400335,["GJX@GJXAIOU",[[-1,7479,"鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7498,"对"]],[7479,7479],[7480,7480]]],[1559368462205,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码："],[-1,6610,"```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->\n"],[-1,7515,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7565,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7591,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7617,"\nBoolean visited[MAX];\t// "],[-1,7624,"es"],[1,7626,"\n\n"],[-1,7632,"\n;"],[1,7634,"深度"],[-1,7640," i++ )\n\t{"],[1,7649,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7651,"\n"],[-1,7665,"FALS"],[1,7669,"TRU"],[-1,7671,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7704,"}\n\t\n\tfor( i=0; i <"],[1,7722,"printf(\"%c \""],[-1,7727,"numVertexes; i++ )\n\t"],[1,7747,"adjList[i].data);"],[1,7765,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7782,"i"],[1,7783,"p->adjvex"],[-1,7786,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7826,"i"],[1,7827,"p->adjvex"],[-1,7829,"\n\t\t}\n\t}\n}"],[-1,7839,"、、"],[1,7856,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7866,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7883,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7907,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[7960,7960]]],[1559368462210,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码："],[1,6931,"```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->\n"],[1,7515,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7515,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7591,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7591,"\nBoolean visited[MAX];\t// "],[1,7624,"es"],[-1,7624,"\n\n"],[1,7632,"\n;"],[-1,7632,"深度"],[1,7640," i++ )\n\t{"],[-1,7640,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7691,"\n"],[1,7706,"FALS"],[-1,7706,"TRU"],[1,7711,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7713,"}\n\t\n\tfor( i=0; i <"],[-1,7713,"printf(\"%c \""],[1,7730,"numVertexes; i++ )\n\t"],[-1,7730,"adjList[i].data);"],[-1,7765,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7827,"i"],[-1,7827,"p->adjvex"],[1,7839,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7855,"i"],[-1,7855,"p->adjvex"],[1,7866,"\n\t\t}\n\t}\n}"],[1,7867,"、、"],[-1,7882,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7921,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8052,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8147,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n\n\n### 7.5.2 广度优先遍历\n"]],[7960,7960],[4366,4366]]],[1559368422598,["GJX@GJXAIOU",[[1,7480,"未访问过的顶点调用DFS，若是连通图，只会执行一次"]],[7480,7480],[7505,7505]]],[1559368461470,["GJX@GJXAIOU",[[1,8206,"使用两种存储"]],[8206,8206],[8212,8212]]],[1559368522208,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码："],[-1,6610,"```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->\n"],[-1,7540,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7590,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7616,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7642,"\nBoolean visited[MAX];\t// "],[-1,7649,"es"],[1,7651,"\n\n"],[-1,7657,"\n;"],[1,7659,"深度"],[-1,7665," i++ )\n\t{"],[1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7676,"\n"],[-1,7690,"FALS"],[1,7694,"TRU"],[-1,7696,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7729,"}\n\t\n\tfor( i=0; i <"],[1,7747,"printf(\"%c \""],[-1,7752,"numVertexes; i++ )\n\t"],[1,7772,"adjList[i].data);"],[1,7790,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7807,"i"],[1,7808,"p->adjvex"],[-1,7811,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7851,"i"],[1,7852,"p->adjvex"],[-1,7854,"\n\t\t}\n\t}\n}"],[-1,7864,"、、"],[1,7881,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7891,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7908,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7932,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,7938,"\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[7957,7957]]],[1559368522208,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码："],[1,6931,"```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->\n"],[1,7540,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7540,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7616,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7616,"\nBoolean visited[MAX];\t// "],[1,7649,"es"],[-1,7649,"\n\n"],[1,7657,"\n;"],[-1,7657,"深度"],[1,7665," i++ )\n\t{"],[-1,7665,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7716,"\n"],[1,7731,"FALS"],[-1,7731,"TRU"],[1,7736,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7738,"}\n\t\n\tfor( i=0; i <"],[-1,7738,"printf(\"%c \""],[1,7755,"numVertexes; i++ )\n\t"],[-1,7755,"adjList[i].data);"],[-1,7790,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7852,"i"],[-1,7852,"p->adjvex"],[1,7864,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7880,"i"],[-1,7880,"p->adjvex"],[1,7891,"\n\t\t}\n\t}\n}"],[1,7892,"、、"],[-1,7907,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7946,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8077,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8172,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,8212,"\n\n### 7.5.2 广度优先遍历\n"]],[7957,7957],[4366,4366]]],[1559368475859,["GJX@GJXAIOU",[[1,8212,"结构的深度优先遍历算法比价"]],[8212,8212],[8225,8225]]],[1559368476665,["GJX@GJXAIOU",[[-1,8223,"比价"]],[8225,8225],[8223,8223]]],[1559368479029,["GJX@GJXAIOU",[[1,8223,"比较："]],[8223,8223],[8226,8226]]],[1559368479367,["GJX@GJXAIOU",[[1,8228,"\n"]],[8226,8226],[8227,8227]]],[1559368494371,["GJX@GJXAIOU",[[1,8227,"对于n条边e个顶点的"]],[8227,8227],[8237,8237]]],[1559368498380,["GJX@GJXAIOU",[[-1,8229,"n条边e个顶点的"]],[8237,8237],[8229,8229]]],[1559368522035,["GJX@GJXAIOU",[[1,8229,"n个顶点e条边的图：连接"]],[8229,8229],[8241,8241]]],[1559368582277,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码："],[-1,6610,"```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->\n"],[-1,7540,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7590,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7616,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7642,"\nBoolean visited[MAX];\t// "],[-1,7649,"es"],[1,7651,"\n\n"],[-1,7657,"\n;"],[1,7659,"深度"],[-1,7665," i++ "],[1,7670,"\nvoid DFS(GraphAdjList GL, int i"],[-1,7672,"\t"],[1,7676,"EdgeNode *p;\n\t\n"],[-1,7690,"FALS"],[1,7694,"TRU"],[-1,7696,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7729,"}\n\t\n\tfor( i=0; i <"],[1,7747,"printf(\"%c \""],[-1,7752,"numVertexes; i++ )\n\t"],[1,7772,"adjList[i].data);"],[1,7790,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7807,"i"],[1,7808,"p->adjvex"],[-1,7811,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7851,"i"],[1,7852,"p->adjvex"],[-1,7854,"\n\t\t}\n\t}\n}"],[-1,7864,"、、"],[1,7881,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7891,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7908,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7932,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7949,"比价"],[-1,7958,"条边e个顶点的n"],[1,7977,"\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[7996,7996]]],[1559368582277,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码："],[1,6931,"```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->\n"],[1,7540,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7540,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7616,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7616,"\nBoolean visited[MAX];\t// "],[1,7649,"es"],[-1,7649,"\n\n"],[1,7657,"\n;"],[-1,7657,"深度"],[1,7665," i++ "],[-1,7665,"\nvoid DFS(GraphAdjList GL, int i"],[1,7699,"\t"],[-1,7702,"EdgeNode *p;\n\t\n"],[1,7731,"FALS"],[-1,7731,"TRU"],[1,7736,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7738,"}\n\t\n\tfor( i=0; i <"],[-1,7738,"printf(\"%c \""],[1,7755,"numVertexes; i++ )\n\t"],[-1,7755,"adjList[i].data);"],[-1,7790,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7852,"i"],[-1,7852,"p->adjvex"],[1,7864,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7880,"i"],[-1,7880,"p->adjvex"],[1,7891,"\n\t\t}\n\t}\n}"],[1,7892,"、、"],[-1,7907,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7946,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8077,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8172,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8223,"比价"],[1,8230,"条边e个顶点的n"],[-1,8241,"\n\n### 7.5.2 广度优先遍历\n"]],[7996,7996],[4366,4366]]],[1559368523217,["GJX@GJXAIOU",[[-1,8239,"连接"]],[8241,8241],[8239,8239]]],[1559368533658,["GJX@GJXAIOU",[[1,8239,"邻接矩阵使用二维数组："]],[8239,8239],[8250,8250]]],[1559368534177,["GJX@GJXAIOU",[[-1,8249,"："]],[8250,8250],[8249,8249]]],[1559368543699,["GJX@GJXAIOU",[[1,8249,"，时间复杂度为：）"]],[8249,8249],[8258,8258]]],[1559368544157,["GJX@GJXAIOU",[[-1,8257,"）"]],[8258,8258],[8257,8257]]],[1559368546131,["GJX@GJXAIOU",[[1,8257,"O()"]],[8257,8257],[8260,8260]]],[1559368549751,["GJX@GJXAIOU",[[1,8259,"n^2"]],[8259,8259],[8262,8262]]],[1559368551682,["GJX@GJXAIOU",[[1,8265,"\n"]],[8263,8263],[8264,8264]]],[1559368554383,["GJX@GJXAIOU",[[1,8264,"shi"]],[8264,8264],[8267,8267]]],[1559368555041,["GJX@GJXAIOU",[[-1,8264,"shi"]],[8267,8267],[8264,8264]]],[1559368582148,["GJX@GJXAIOU",[[1,8264,"邻接表所需的时间取决于顶点和边"]],[8264,8264],[8279,8279]]],[1559368642272,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码："],[-1,6610,"```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->\n"],[-1,7540,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7590,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7616,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7642,"\nBoolean visited[MAX];\t// "],[-1,7649,"es"],[1,7651,"\n\n"],[-1,7657,"\n;"],[1,7659,"深度"],[1,7665,"\nvoid DFS(GraphAdjList GL,"],[-1,7667,"++ "],[1,7670,"nt i"],[-1,7672,"\t"],[1,7676,"EdgeNode *p;\n\t\n"],[-1,7690,"FALS"],[1,7694,"TRU"],[-1,7696,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7729,"}\n\t\n\tfor( i=0; i <"],[1,7747,"printf(\"%c \""],[-1,7752,"numVertexes; i++ )\n\t"],[1,7772,"adjList[i].data);"],[1,7790,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7807,"i"],[1,7808,"p->adjvex"],[-1,7811,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7851,"i"],[1,7852,"p->adjvex"],[-1,7854,"\n\t\t}\n\t}\n}"],[-1,7864,"、、"],[1,7881,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7891,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7908,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7932,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7950,"价比"],[-1,7958,"条边e个顶点的n"],[-1,7975,"连接"],[-1,7987,"："],[-1,7996,"）"],[-1,7999,")"],[1,8003,")"],[-1,8004,"shi"],[1,8022,"\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[8041,8041]]],[1559368642272,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码："],[1,6931,"```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->\n"],[1,7540,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7540,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7616,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7616,"\nBoolean visited[MAX];\t// "],[1,7649,"es"],[-1,7649,"\n\n"],[1,7657,"\n;"],[-1,7657,"深度"],[-1,7665,"\nvoid DFS(GraphAdjList GL,"],[1,7693,"++ "],[-1,7693,"nt i"],[1,7699,"\t"],[-1,7702,"EdgeNode *p;\n\t\n"],[1,7731,"FALS"],[-1,7731,"TRU"],[1,7736,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7738,"}\n\t\n\tfor( i=0; i <"],[-1,7738,"printf(\"%c \""],[1,7755,"numVertexes; i++ )\n\t"],[-1,7755,"adjList[i].data);"],[-1,7790,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7852,"i"],[-1,7852,"p->adjvex"],[1,7864,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7880,"i"],[-1,7880,"p->adjvex"],[1,7891,"\n\t\t}\n\t}\n}"],[1,7892,"、、"],[-1,7907,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7946,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8077,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8172,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8224,"价比"],[1,8230,"条边e个顶点的n"],[1,8239,"连接"],[1,8249,"："],[1,8257,"）"],[1,8259,")"],[-1,8262,")"],[1,8264,"shi"],[-1,8279,"\n\n### 7.5.2 广度优先遍历\n"]],[8041,8041],[4366,4366]]],[1559368590353,["GJX@GJXAIOU",[[1,8279,"的数量，时间复杂度为：O()"]],[8279,8279],[8293,8293]]],[1559368594463,["GJX@GJXAIOU",[[1,8292,"n+e"]],[8292,8292],[8295,8295]]],[1559368596009,["GJX@GJXAIOU",[[1,8296,";"]],[8296,8296],[8297,8297]]],[1559368598634,["GJX@GJXAIOU",[[1,8263,";"]],[8263,8263],[8264,8264]]],[1559368702286,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码："],[-1,6610,"```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->\n"],[-1,7540,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7590,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7616,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7642,"\nBoolean visited[MAX];\t// "],[-1,7649,"es"],[1,7651,"\n\n"],[-1,7657,"\n;"],[1,7659,"深度"],[-1,7665," i++ "],[1,7670,"\nvoid DFS(GraphAdjList GL, int i"],[-1,7672,"\t"],[1,7676,"EdgeNode *p;\n\t\n"],[-1,7690,"FALS"],[1,7694,"TRU"],[-1,7696,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?\n\t}"],[-1,7732,"\n\tfor( i=0; i <"],[1,7747,"printf(\"%c \""],[-1,7752,"numVertexes; i++ )\n\t"],[1,7772,"adjList[i].data);"],[1,7790,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7807,"i"],[1,7808,"p->adjvex"],[-1,7811,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7851,"i"],[1,7852,"p->adjvex"],[-1,7854,"\n\t\t}\n\t}\n}"],[-1,7864,"、、"],[1,7881,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7891,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7908,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7932,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7950,"价比"],[-1,7958,"条边e个顶点的n"],[-1,7975,"连接"],[-1,7987,"："],[-1,7996,"）"],[-1,7999,")"],[1,8003,");"],[-1,8004,"shi"],[-1,8035,")"],[-1,8039,";;"],[1,8041,");\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[8062,8062]]],[1559368702286,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码："],[1,6931,"```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->\n"],[1,7540,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7540,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7616,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7616,"\nBoolean visited[MAX];\t// "],[1,7649,"es"],[-1,7649,"\n\n"],[1,7657,"\n;"],[-1,7657,"深度"],[1,7665," i++ "],[-1,7665,"\nvoid DFS(GraphAdjList GL, int i"],[1,7699,"\t"],[-1,7702,"EdgeNode *p;\n\t\n"],[1,7731,"FALS"],[-1,7731,"TRU"],[1,7736,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?\n\t}"],[1,7738,"\n\tfor( i=0; i <"],[-1,7738,"printf(\"%c \""],[1,7755,"numVertexes; i++ )\n\t"],[-1,7755,"adjList[i].data);"],[-1,7790,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7852,"i"],[-1,7852,"p->adjvex"],[1,7864,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7880,"i"],[-1,7880,"p->adjvex"],[1,7891,"\n\t\t}\n\t}\n}"],[1,7892,"、、"],[-1,7907,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7946,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8077,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8172,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8224,"价比"],[1,8230,"条边e个顶点的n"],[1,8239,"连接"],[1,8249,"："],[1,8257,"）"],[1,8259,")"],[-1,8262,");"],[1,8265,"shi"],[1,8293,")"],[1,8296,";;"],[-1,8296,");\n\n### 7.5.2 广度优先遍历\n"]],[8062,8062],[4366,4366]]],[1559368662742,["GJX@GJXAIOU",[[1,8300,"\n"]],[8298,8298],[8299,8299]]],[1559368668095,["GJX@GJXAIOU",[[1,8299,"= "]],[8299,8299],[8301,8301]]],[1559368669696,["GJX@GJXAIOU",[[-1,8299,"= "]],[8301,8301],[8299,8299]]],[1559368670944,["GJX@GJXAIOU",[[1,8301,"\n"]],[8299,8299],[8300,8300]]],[1559368675183,["GJX@GJXAIOU",[[1,8299,"==duiyu"]],[8299,8299],[8306,8306]]],[1559368676506,["GJX@GJXAIOU",[[-1,8301,"duiyu"]],[8306,8306],[8301,8301]]],[1559368687417,["GJX@GJXAIOU",[[1,8301,"对于点多变少"]],[8301,8301],[8307,8307]]],[1559368688426,["GJX@GJXAIOU",[[-1,8305,"变少"]],[8307,8307],[8305,8305]]],[1559368696032,["GJX@GJXAIOU",[[1,8305,"边少的稀疏图："]],[8305,8305],[8312,8312]]],[1559368762272,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码："],[-1,6610,"```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->\n"],[-1,7540,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7590,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7616,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7642,"\nBoolean visited[MAX];\t// "],[-1,7649,"es"],[1,7651,"\n\n"],[-1,7657,"\n;"],[1,7659,"深度"],[1,7665,"\nvoid DFS(GraphAdjList GL,"],[-1,7667,"++ "],[1,7670,"nt i"],[-1,7672,"\t"],[1,7676,"EdgeNode *p;\n\t\n"],[-1,7690,"FALS"],[1,7694,"TRU"],[-1,7696,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7729,"}\n\t\n\tfor( i=0; i <"],[1,7747,"printf(\"%c \""],[-1,7752,"numVertexes; i++ )\n\t"],[1,7772,"adjList[i].data);"],[1,7790,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7807,"i"],[1,7808,"p->adjvex"],[-1,7811,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7851,"i"],[1,7852,"p->adjvex"],[-1,7854,"\n\t\t}\n\t}\n}"],[-1,7864,"、、"],[1,7881,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7891,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7908,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7932,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7950,"价比"],[-1,7958,"条边e个顶点的n"],[-1,7975,"连接"],[-1,7987,"："],[-1,7996,"）"],[-1,7999,")"],[1,8003,");"],[-1,8004,"shi"],[-1,8035,")"],[-1,8039,";;\n= "],[1,8044,");"],[-1,8047,"duiyu"],[-1,8056,"变少"],[1,8065,"\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[8085,8085]]],[1559368762272,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码："],[1,6931,"```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->\n"],[1,7540,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7540,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7616,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7616,"\nBoolean visited[MAX];\t// "],[1,7649,"es"],[-1,7649,"\n\n"],[1,7657,"\n;"],[-1,7657,"深度"],[-1,7665,"\nvoid DFS(GraphAdjList GL,"],[1,7693,"++ "],[-1,7693,"nt i"],[1,7699,"\t"],[-1,7702,"EdgeNode *p;\n\t\n"],[1,7731,"FALS"],[-1,7731,"TRU"],[1,7736,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7738,"}\n\t\n\tfor( i=0; i <"],[-1,7738,"printf(\"%c \""],[1,7755,"numVertexes; i++ )\n\t"],[-1,7755,"adjList[i].data);"],[-1,7790,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7852,"i"],[-1,7852,"p->adjvex"],[1,7864,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7880,"i"],[-1,7880,"p->adjvex"],[1,7891,"\n\t\t}\n\t}\n}"],[1,7892,"、、"],[-1,7907,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7946,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8077,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8172,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8224,"价比"],[1,8230,"条边e个顶点的n"],[1,8239,"连接"],[1,8249,"："],[1,8257,"）"],[1,8259,")"],[-1,8262,");"],[1,8265,"shi"],[1,8293,")"],[1,8296,";;\n= "],[-1,8296,");"],[1,8301,"duiyu"],[1,8305,"变少"],[-1,8312,"\n\n\n### 7.5.2 广度优先遍历\n"]],[8085,8085],[4366,4366]]],[1559368735490,["GJX@GJXAIOU",[[1,8312,"邻接表结构效率更高=="]],[8312,8312],[8323,8323]]],[1559368759731,["GJX@GJXAIOU",[[1,6930,"下面以无向图为例："]],[6930,6930],[6939,6939]]],[1559368822279,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE"],[-1,6693,"Boolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[1,7674,"\nvoid DFS(GraphAdjList GL,"],[-1,7676,"++ "],[1,7679,"nt i"],[-1,7681,"\t"],[1,7685,"EdgeNode *p;\n\t\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";;\n= "],[1,8053,");"],[-1,8056,"duiyu"],[-1,8065,"变少"],[1,8085,"\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[8105,8105]]],[1559368822279,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE"],[1,6930,"Boolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[-1,7674,"\nvoid DFS(GraphAdjList GL,"],[1,7702,"++ "],[-1,7702,"nt i"],[1,7708,"\t"],[-1,7711,"EdgeNode *p;\n\t\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";;\n= "],[-1,8305,");"],[1,8310,"duiyu"],[1,8314,"变少"],[-1,8332,"\n\n\n### 7.5.2 广度优先遍历\n"]],[8105,8105],[4366,4366]]],[1559368802218,["GJX@GJXAIOU",[[1,8352,"\n"]],[8351,8351],[8352,8352]]],[1559368802346,["GJX@GJXAIOU",[[1,8353,"\n"]],[8352,8352],[8353,8353]]],[1559368802469,["GJX@GJXAIOU",[[1,8354,"\n"]],[8353,8353],[8354,8354]]],[1559368802591,["GJX@GJXAIOU",[[1,8355,"\n"]],[8354,8354],[8355,8355]]],[1559368802717,["GJX@GJXAIOU",[[1,8356,"\n"]],[8355,8355],[8356,8356]]],[1559368802849,["GJX@GJXAIOU",[[1,8357,"\n"]],[8356,8356],[8357,8357]]],[1559368802963,["GJX@GJXAIOU",[[1,8358,"\n"]],[8357,8357],[8358,8358]]],[1559368803096,["GJX@GJXAIOU",[[1,8359,"\n"]],[8358,8358],[8359,8359]]],[1559368803217,["GJX@GJXAIOU",[[1,8360,"\n"]],[8359,8359],[8360,8360]]],[1559368803337,["GJX@GJXAIOU",[[1,8361,"\n"]],[8360,8360],[8361,8361]]],[1559368803466,["GJX@GJXAIOU",[[1,8362,"\n"]],[8361,8361],[8362,8362]]],[1559368803599,["GJX@GJXAIOU",[[1,8363,"\n"]],[8362,8362],[8363,8363]]],[1559368803718,["GJX@GJXAIOU",[[1,8364,"\n"]],[8363,8363],[8364,8364]]],[1559368803854,["GJX@GJXAIOU",[[1,8365,"\n"]],[8364,8364],[8365,8365]]],[1559368803994,["GJX@GJXAIOU",[[1,8366,"\n"]],[8365,8365],[8366,8366]]],[1559368804134,["GJX@GJXAIOU",[[1,8367,"\n"]],[8366,8366],[8367,8367]]],[1559368804257,["GJX@GJXAIOU",[[1,8368,"\n"]],[8367,8367],[8368,8368]]],[1559368804394,["GJX@GJXAIOU",[[1,8369,"\n"]],[8368,8368],[8369,8369]]],[1559368804515,["GJX@GJXAIOU",[[1,8370,"\n"]],[8369,8369],[8370,8370]]],[1559368804773,["GJX@GJXAIOU",[[1,8371,"\n"]],[8370,8370],[8371,8371]]],[1559368882283,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE"],[-1,6693,"Boolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[1,7674,"\nvoid DFS(GraphAdjList GL,"],[-1,7676,"++ "],[1,7679,"nt i"],[-1,7681,"\t"],[1,7685,"EdgeNode *p;\n\t\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";;\n= "],[1,8053,");"],[-1,8056,"duiyu"],[-1,8065,"变少"],[1,8085,"\n\n\n### 7.5.2 广度优先遍历\n"]],[4366,4366],[8105,8105]]],[1559368882283,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE"],[1,6930,"Boolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[-1,7674,"\nvoid DFS(GraphAdjList GL,"],[1,7702,"++ "],[-1,7702,"nt i"],[1,7708,"\t"],[-1,7711,"EdgeNode *p;\n\t\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";;\n= "],[-1,8305,");"],[1,8310,"duiyu"],[1,8314,"变少"],[-1,8332,"\n\n\n### 7.5.2 广度优先遍历\n"]],[8105,8105],[4366,4366]]],[1559368856363,["GJX@GJXAIOU",[[1,8351,"BreadthFirstSearch"]],[8351,8351],[8369,8369]]],[1559368858673,["GJX@GJXAIOU",[[1,8351,"（"]],[8351,8351],[8352,8352]]],[1559368868723,["GJX@GJXAIOU",[[1,8370,"）BFS"]],[8370,8370],[8374,8374]]],[1559368942282,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码："],[-1,6609,"\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[1,8128,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[8149,8149]]],[1559368942282,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码："],[1,6930,"\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[-1,8374,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[8149,8149],[4366,4366]]],[1559368940971,["GJX@GJXAIOU",[[1,8375,"树的广度"]],[8375,8375],[8379,8379]]],[1559369002286,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码："],[-1,6609,"\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[1,8128,"\n"],[1,8132,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[8152,8152]]],[1559369002286,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码："],[1,6930,"\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[-1,8374,"\n"],[-1,8379,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[8152,8152],[4366,4366]]],[1559368947012,["GJX@GJXAIOU",[[1,8379,"优先遍历类似于"]],[8379,8379],[8386,8386]]],[1559368967849,["GJX@GJXAIOU",[[-1,8382,"历类似于"]],[8386,8386],[8382,8382]]],[1559368975100,["GJX@GJXAIOU",[[1,8382,"历"]],[8382,8382],[8383,8383]]],[1559368997316,["GJX@GJXAIOU",[[1,8375,"**"],[1,8383,"**类似于层次遍历"]],[8375,8383],[8392,8392]]],[1559369062286,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6477,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码："],[-1,6609,"\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[1,8128,"\n**"],[-1,8139,"历****类似于"],[1,8151,"**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[8173,8173]]],[1559369062286,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6819,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码："],[1,6930,"\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[-1,8374,"\n**"],[1,8388,"历****类似于"],[-1,8392,"**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[8173,8173],[4366,4366]]],[1559369005631,["GJX@GJXAIOU",[[-1,8377,"树"]],[8378,8378],[8377,8377]]],[1559369006766,["GJX@GJXAIOU",[[1,8377,"图"]],[8377,8377],[8378,8378]]],[1559369011355,["GJX@GJXAIOU",[[1,8388,"树的"]],[8388,8388],[8390,8390]]],[1559369362298,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码："],[-1,6609,"\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ "],[1,7679,"\nvoid DFS(GraphAdjList GL, int i"],[-1,7681,"\t"],[1,7685,"EdgeNode *p;\n\t\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";;\n= "],[1,8053,");"],[-1,8056,"duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[8176,8176]]],[1559369362298,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码："],[1,6930,"\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ "],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i"],[1,7708,"\t"],[-1,7711,"EdgeNode *p;\n\t\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";;\n= "],[-1,8305,");"],[1,8310,"duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[8176,8176],[4366,4366]]],[1559369317863,["GJX@GJXAIOU",[[1,8398,"![广度优先遍历转换图]($resource/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)"]],[8398,8398],[8508,8508]]],[1559369422307,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码："],[-1,6609,"\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ "],[1,7679,"\nvoid DFS(GraphAdjList GL, int i"],[-1,7681,"\t"],[1,7685,"EdgeNode *p;\n\t\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";;\n= "],[1,8053,");"],[-1,8056,"duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[8281,8281]]],[1559369422307,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码："],[1,6930,"\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ "],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i"],[1,7708,"\t"],[-1,7711,"EdgeNode *p;\n\t\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";;\n= "],[-1,8305,");"],[1,8310,"duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[8281,8281],[4366,4366]]],[1559369371270,["GJX@GJXAIOU",[[1,8525,"\n"]],[8508,8508],[8509,8509]]],[1559369395001,["GJX@GJXAIOU",[[1,8509,"可以使用队列实现对图的广度优先遍历："]],[8509,8509],[8527,8527]]],[1559369395226,["GJX@GJXAIOU",[[1,8544,"\n"]],[8527,8527],[8528,8528]]],[1559369403430,["GJX@GJXAIOU",[[1,8528,"![使用队列实现广度优先遍历]($resource/%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.jpg)"]],[8528,8528],[8668,8668]]],[1559369404821,["GJX@GJXAIOU",[[1,8684,"\n"]],[8668,8668],[8669,8669]]],[1559369482309,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码："],[-1,6609,"\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ "],[1,7679,"\nvoid DFS(GraphAdjList GL, int i"],[-1,7681,"\t"],[1,7685,"EdgeNode *p;\n\t\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";;\n= "],[1,8053,");"],[-1,8056,"duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[8440,8440]]],[1559369482309,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码："],[1,6930,"\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ "],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i"],[1,7708,"\t"],[-1,7711,"EdgeNode *p;\n\t\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";;\n= "],[-1,8305,");"],[1,8310,"duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[8440,8440],[4366,4366]]],[1559369481124,["GJX@GJXAIOU",[[1,8669,"使用邻接矩阵实现的"]],[8669,8669],[8678,8678]]],[1559369542321,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6428,"本指导喊"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码："],[-1,6609,"\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ "],[1,7679,"\nvoid DFS(GraphAdjList GL, int i"],[-1,7681,"\t"],[1,7685,"EdgeNode *p;\n\t\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";;\n= "],[1,8053,");"],[-1,8056,"duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[1,8432,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[8448,8448]]],[1559369542321,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6774,"本指导喊"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码："],[1,6930,"\n```language\n```\nc\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ "],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i"],[1,7708,"\t"],[-1,7711,"EdgeNode *p;\n\t\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";;\n= "],[-1,8305,");"],[1,8310,"duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[-1,8678,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[8448,8448],[4366,4366]]],[1559369487377,["GJX@GJXAIOU",[[1,8678,"广度遍历算法："]],[8678,8678],[8685,8685]]],[1559369487997,["GJX@GJXAIOU",[[1,8701,"\n"]],[8685,8685],[8686,8686]]],[1559369490088,["GJX@GJXAIOU",[[1,8686,"```"]],[8686,8686],[8689,8689]]],[1559369490127,["GJX@GJXAIOU",[[1,8689,"language\n```\n"]],[8689,8689],[8689,8697]]],[1559369491064,["GJX@GJXAIOU",[[-1,8689,"language"],[1,8697,"c"]],[8689,8697],[8690,8690]]],[1559369491338,["GJX@GJXAIOU",[[1,8691,"\n"]],[8690,8690],[8691,8691]]],[1559369492590,["GJX@GJXAIOU",[[1,8691,"// 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?\nvoid BFSTraverse(MGraph G)\n{\n\tint i, j;\n\tQueue Q;\n\t\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\n\t}\n\t\n\tinitQueue( &Q );\n\t\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\n\t\t{\n\t\t\tprintf(\"%c \", G.vex[i]);\n\t\t\tvisited[i] = TRUE;\n\t\t\tEnQueue(&Q, i);\n\t\t\t\n\t\t\twhile( !QueueEmpty(Q) )\n\t\t\t{\n\t\t\t\tDeQueue(&Q, &i);\n\t\t\t\tfor( j=0; j < G.numVertexes; j++ )\n\t\t\t\t{\n\t\t\t\t\tif( G.art[i][j]==1 && !visited[j] )\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE;\n\t\t\t\t\t\tEnQueue(&Q, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"]],[8691,8691],[9236,9236]]],[1559369497760,["GJX@GJXAIOU",[[-1,8694,"閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8711,"l"]],[8694,8711],[8695,8695]]],[1559369498499,["GJX@GJXAIOU",[[1,8695,"injie"]],[8695,8695],[8700,8700]]],[1559369499964,["GJX@GJXAIOU",[[-1,8693," linjie"]],[8700,8700],[8693,8693]]],[1559369500666,["GJX@GJXAIOU",[[1,8693," "]],[8693,8693],[8694,8694]]],[1559369501485,["GJX@GJXAIOU",[[-1,8693," "]],[8694,8694],[8693,8693]]],[1559369514757,["GJX@GJXAIOU",[[1,8693,"邻接矩阵的广度遍历算法"]],[8693,8693],[8704,8704]]],[1559369535036,["GJX@GJXAIOU",[[1,8840," //初始化一辅助用的队列"]],[8840,8840],[8853,8853]]],[1559369541080,["GJX@GJXAIOU",[[1,8891," //d"]],[8891,8891],[8895,8895]]],[1559369541638,["GJX@GJXAIOU",[[-1,8894,"d"]],[8895,8895],[8894,8894]]],[1559369602320,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[1,8614," //初始化一辅助用的队列"],[1,8652," //"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]);\n\t\t\t"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //"],[-1,9012,""],[1,9012,"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[9033,9033]]],[1559369602320,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //"],[1,8935,"邻接矩阵的广度遍历算法"],[-1,8935," \", G.vex[i]);\n\t\t\t"],[1,9089," //初始化一辅助用的队列"],[1,9127," //"],[1,9245,""],[-1,9245,"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[9033,9033],[4366,4366]]],[1559369548682,["GJX@GJXAIOU",[[1,8894,"对每一个顶点做循环"]],[8894,8894],[8903,8903]]],[1559369564880,["GJX@GJXAIOU",[[1,8926," //若是未访问过就处理"]],[8926,8926],[8938,8938]]],[1559369583252,["GJX@GJXAIOU",[[1,8992," //设置当前顶点访问过"]],[8992,8992],[9004,9004]]],[1559369662325,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]);\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8992," //设置当前顶点访问过"],[-1,9045,""],[1,9045,"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[9066,9066]]],[1559369662325,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]);\n\t\t\t"],[-1,8992," //设置当前顶点访问过"],[1,9122," //初始化一辅助用的队列"],[1,9160," //对每一个顶点做循环"],[1,9183," //若是未访问过就处理"],[1,9237," //设置当前顶点访问过"],[1,9278,""],[-1,9278,"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[9066,9066],[4366,4366]]],[1559369604155,["GJX@GJXAIOU",[[1,9008,"\n\t\t\t"]],[9004,9004],[9008,9008]]],[1559369611308,["GJX@GJXAIOU",[[1,9008,"printf()"]],[9008,9008],[9016,9016]]],[1559369620380,["GJX@GJXAIOU",[[-1,9005,"\t\t\tprintf()"]],[9005,9016],[9005,9005]]],[1559369620786,["GJX@GJXAIOU",[[-1,9005,"\n"]],[9005,9005],[9004,9004]]],[1559369623176,["GJX@GJXAIOU",[[1,8970,"//"]],[8970,8970],[8972,8972]]],[1559369626678,["GJX@GJXAIOU",[[-1,8970,"//"]],[8972,8972],[8970,8970]]],[1559369630114,["GJX@GJXAIOU",[[1,8970," //day"]],[8970,8970],[8976,8976]]],[1559369631493,["GJX@GJXAIOU",[[-1,8973,"day"]],[8976,8976],[8973,8973]]],[1559369645290,["GJX@GJXAIOU",[[1,8973,"打印该结点，其他操作均可"]],[8973,8973],[8985,8985]]],[1559369657451,["GJX@GJXAIOU",[[1,9038," //将测"]],[9038,9038],[9043,9043]]],[1559369659660,["GJX@GJXAIOU",[[-1,9042,"测"]],[9043,9043],[9042,9042]]],[1559369660675,["GJX@GJXAIOU",[[1,9042,"此"]],[9042,9042],[9043,9043]]],[1559369722311,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,9007," //设置当前顶点访问过n\t\t\t"],[1,9023,"nQue"],[-1,9038," //将此"],[1,9065,"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[9086,9086]]],[1559369722311,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此"],[1,9142," //初始化一辅助用的队列"],[1,9180," //对每一个顶点做循环"],[1,9203," //若是未访问过就处理"],[1,9235," //打印该结点，其他操作均可"],[1,9257," //设置当前顶点访问过n\t\t\t"],[-1,9257,"nQue"],[1,9276," //将此"],[-1,9298,"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[9086,9086],[4366,4366]]],[1559369664915,["GJX@GJXAIOU",[[1,9043,"点点"]],[9043,9043],[9045,9045]]],[1559369666748,["GJX@GJXAIOU",[[-1,9043,"点点"]],[9045,9045],[9043,9043]]],[1559369670528,["GJX@GJXAIOU",[[1,9043,"顶点如"]],[9043,9043],[9046,9046]]],[1559369671429,["GJX@GJXAIOU",[[-1,9045,"如"]],[9046,9046],[9045,9045]]],[1559369675501,["GJX@GJXAIOU",[[1,9045,"入队列"]],[9045,9045],[9048,9048]]],[1559369782335,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,9007," //设置当前顶点访问过n\t\t\t"],[1,9023,"nQue"],[-1,9038," //将此顶点入队列"],[1,9070,"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[9091,9091]]],[1559369782335,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[1,9147," //初始化一辅助用的队列"],[1,9185," //对每一个顶点做循环"],[1,9208," //若是未访问过就处理"],[1,9240," //打印该结点，其他操作均可"],[1,9262," //设置当前顶点访问过n\t\t\t"],[-1,9262,"nQue"],[1,9281," //将此顶点入队列"],[-1,9303,"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[9091,9091],[4366,4366]]],[1559369744474,["GJX@GJXAIOU",[[1,9079,"、"]],[9079,9079],[9080,9080]]],[1559369745517,["GJX@GJXAIOU",[[-1,9079,"、"]],[9080,9080],[9079,9079]]],[1559369757540,["GJX@GJXAIOU",[[1,9079," //若当前队列不为空"]],[9079,9079],[9090,9090]]],[1559369764327,["GJX@GJXAIOU",[[1,9116," //jiang dui"]],[9116,9116],[9128,9128]]],[1559369766033,["GJX@GJXAIOU",[[-1,9119,"jiang dui"]],[9128,9128],[9119,9119]]],[1559369766343,["GJX@GJXAIOU",[[1,9119,"j"]],[9119,9119],[9120,9120]]],[1559369766746,["GJX@GJXAIOU",[[-1,9119,"j"]],[9120,9120],[9119,9119]]],[1559369781912,["GJX@GJXAIOU",[[1,9119,"将队中元素出队列，赋值给id"]],[9119,9119],[9133,9133]]],[1559369842320,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给id"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,9007," //设置当前顶点访问过n\t\t\t"],[1,9023,"nQue"],[-1,9038," //将此顶点入队列"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id"],[1,9109,"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[9130,9130]]],[1559369842320,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给id"],[1,9175," //初始化一辅助用的队列"],[1,9213," //对每一个顶点做循环"],[1,9236," //若是未访问过就处理"],[1,9268," //打印该结点，其他操作均可"],[1,9290," //设置当前顶点访问过n\t\t\t"],[-1,9290,"nQue"],[1,9309," //将此顶点入队列"],[1,9331,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id"],[-1,9331,"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[9130,9130],[4366,4366]]],[1559369783013,["GJX@GJXAIOU",[[-1,9132,"d"]],[9133,9133],[9132,9132]]],[1559369822586,["GJX@GJXAIOU",[[1,9182,"\n\t\t\t\t"]],[9177,9177],[9182,9182]]],[1559369841874,["GJX@GJXAIOU",[[1,9182,"  //判断其他顶点若与当前"]],[9182,9182],[9196,9196]]],[1559369902323,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,9007," //设置当前顶点访问过n\t\t\t"],[1,9023,"nQue"],[-1,9038," //将此顶点入队列"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前"],[1,9128,"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[9149,9149]]],[1559369902323,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前\n\t\t\t\t"],[1,9231," //对每一个顶点做循环"],[1,9254," //若是未访问过就处理"],[1,9286," //打印该结点，其他操作均可"],[1,9308," //设置当前顶点访问过n\t\t\t"],[-1,9308,"nQue"],[1,9327," //将此顶点入队列"],[1,9349,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前"],[-1,9349,"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[9149,9149],[4366,4366]]],[1559369853515,["GJX@GJXAIOU",[[1,9196,"顶点存在边且未被访问过"]],[9196,9196],[9207,9207]]],[1559370802357,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,9007," //设置当前顶点访问过n\t\t\t"],[1,9023,"nQue"],[-1,9038," //将此顶点入队列"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过"],[1,9139,"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[9160,9160]]],[1559370802357,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9319," //设置当前顶点访问过n\t\t\t"],[-1,9319,"nQue"],[1,9338," //将此顶点入队列"],[1,9360,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过"],[-1,9360,"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[9160,9160],[4366,4366]]],[1559370780402,["GJX@GJXAIOU",[[1,9311," //将找到的此顶点标记为已访问"]],[9311,9311],[9327,9327]]],[1559370797654,["GJX@GJXAIOU",[[1,9349," //将找到的此顶点入队列"]],[9349,9349],[9362,9362]]],[1559370862360,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[1,8840,"\t\t{\n\t\t\t\t "],[-1,8843,"初始化一辅助用的队列\t\t{"],[1,8856,"判断其他顶点若与当前顶点存在边且未被访问过"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t"],[1,9023,"\t\tEnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[9189,9189]]],[1559370862360,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[-1,9174,"\t\t{\n\t\t\t\t "],[1,9186,"初始化一辅助用的队列\t\t{"],[-1,9186,"判断其他顶点若与当前顶点存在边且未被访问过"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t"],[-1,9332,"\t\tEnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[9189,9189],[4366,4366]]],[1559370833823,["GJX@GJXAIOU",[[1,9396,"使用邻接矩阵实现的广度遍历算法：\n```c\n//邻接矩阵的广度遍历算法\nvoid BFSTraverse(MGraph G)\n{\n\tint i, j;\n\tQueue Q;\n\t\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\n\t}\n\t\n\tinitQueue( &Q ); //初始化一辅助用的队列\n\t\n\tfor( i=0; i < G.numVertexes; i++ ) //对每一个顶点做循环\n\t{\n\t\tif( !visited[i] ) //若是未访问过就处理\n\t\t{\n\t\t\tprintf(\"%c \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\tvisited[i] = TRUE; //设置当前顶点访问过\n\t\t\tEnQueue(&Q, i); //将此顶点入队列\n\t\t\t\n\t\t\twhile( !QueueEmpty(Q) ) //若当前队列不为空\n\t\t\t{\n\t\t\t\tDeQueue(&Q, &i); //将队中元素出队列，赋值给i\n\t\t\t\tfor( j=0; j < G.numVertexes; j++ )\n\t\t\t\t{\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t\tif( G.art[i][j]==1 && !visited[j] )\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n"]],[9396,9396],[10121,10121]]],[1559370836451,["GJX@GJXAIOU",[[-1,9400,"矩阵"]],[9402,9402],[9400,9400]]],[1559370838484,["GJX@GJXAIOU",[[1,9400,"表"]],[9400,9400],[9401,9401]]],[1559370840591,["GJX@GJXAIOU",[[-1,9421,"矩阵"]],[9423,9423],[9421,9421]]],[1559370842044,["GJX@GJXAIOU",[[1,9421,"表"]],[9421,9421],[9422,9422]]],[1559370854542,["GJX@GJXAIOU",[[-1,9447,"M"]],[9447,9453],[9452,9452]]],[1559370862146,["GJX@GJXAIOU",[[1,9452,"AdjLi"]],[9452,9452],[9457,9457]]],[1559370922387,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t"],[1,9023,"\t\tEnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjLi"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9447,"t"],[-1,9452,"AdjLi"],[-1,9894,""],[1,9894,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[9908,9908]]],[1559370922387,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t"],[-1,9332,"\t\tEnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjLi"],[1,9630,"表"],[-1,9630,"循环"],[1,9652,"表"],[-1,9652,"] "],[-1,9679,"t"],[1,9685,"AdjLi"],[1,10122,""],[-1,10122,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[9908,9908],[4366,4366]]],[1559370862788,["GJX@GJXAIOU",[[1,9457,"st"]],[9457,9457],[9459,9459]]],[1559370866164,["GJX@GJXAIOU",[[1,9461,"L"]],[9461,9461],[9462,9462]]],[1559370882358,["GJX@GJXAIOU",[[1,9478,"\n\t"]],[9476,9476],[9478,9478]]],[1559370900109,["GJX@GJXAIOU",[[1,9478,"EdgeNode *p;"]],[9478,9478],[9490,9490]]],[1559370908562,["GJX@GJXAIOU",[[1,9519,"L"]],[9519,9519],[9520,9520]]],[1559370910342,["GJX@GJXAIOU",[[-1,9520,"."]],[9521,9521],[9520,9520]]],[1559370911947,["GJX@GJXAIOU",[[1,9520,"->"]],[9520,9520],[9522,9522]]],[1559370982371,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t"],[1,9023,"\t\tEnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9447,"t"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9519,"L->"],[1,9522," "],[-1,9913,""],[1,9913,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[9927,9927]]],[1559370982371,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t"],[-1,9332,"\t\tEnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9649,"表"],[-1,9649,"循环"],[1,9671,"表"],[-1,9671,"] "],[-1,9698,"t"],[1,9704,"AdjList"],[1,9706,"L"],[1,9722,"EdgeNode *p;\n\t"],[1,9749,"L->"],[-1,9749," "],[1,10141,""],[-1,10141,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[9927,9927],[4366,4366]]],[1559370936906,["GJX@GJXAIOU",[[-1,9572,"i"],[1,9573,"I"]],[9572,9573],[9573,9573]]],[1559370946586,["GJX@GJXAIOU",[[-1,8824,"i"]],[8825,8825],[8824,8824]]],[1559370948123,["GJX@GJXAIOU",[[1,8824,"I"]],[8824,8824],[8825,8825]]],[1559370957884,["GJX@GJXAIOU",[[-1,9620,"."]],[9621,9621],[9620,9620]]],[1559370960025,["GJX@GJXAIOU",[[1,9620,"L->"]],[9620,9620],[9623,9623]]],[1559370977451,["GJX@GJXAIOU",[[-1,9736,"\t\t\tvisited[i] = TRUE; //设置当前顶点访问过"]],[9736,9769],[9736,9736]]],[1559370978731,["GJX@GJXAIOU",[[-1,9736,"\n"]],[9736,9736],[9736,9736]]],[1559370980962,["GJX@GJXAIOU",[[1,9695,"\n\t\t"]],[9692,9692],[9695,9695]]],[1559371042375,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9441,"\t\n"],[1,9443,"\t"],[1,9447,"t"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9695,"\n\t\t"],[1,9698,""],[-1,9739,""],[1,9739,"f( G.art[i][j]==1 && !visited[j] )"],[-1,9884,""],[1,9884,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[9898,9898]]],[1559371042375,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9694,"\t\n"],[-1,9698,"\t"],[-1,9703,"t"],[1,9709,"AdjList"],[1,9711,"L"],[1,9727,"EdgeNode *p;\n\t"],[1,9742,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9771,"I"],[-1,9771,"\n"],[1,9819,"L->"],[-1,9819,"D"],[1,9892,"\n\t\t"],[-1,9892,""],[1,9933,""],[-1,9933,"f( G.art[i][j]==1 && !visited[j] )"],[1,10112,""],[-1,10112,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[9898,9898],[4366,4366]]],[1559370985154,["GJX@GJXAIOU",[[1,9697,"  \t\t\tvisited[i] = TRUE; //设置当前顶点访问过"]],[9697,9697],[9732,9732]]],[1559370988092,["GJX@GJXAIOU",[[-1,9699,"\t\t\t"]],[9699,9702],[9699,9699]]],[1559371002576,["GJX@GJXAIOU",[[-1,9748,".vex[i]"]],[9747,9755],[9748,9748]]],[1559371012578,["GJX@GJXAIOU",[[1,9748,"L->adjLise"]],[9748,9748],[9758,9758]]],[1559371013324,["GJX@GJXAIOU",[[-1,9757,"e"]],[9758,9758],[9757,9757]]],[1559371019212,["GJX@GJXAIOU",[[1,9757,"t[i].data"]],[9757,9757],[9766,9766]]],[1559371040997,["GJX@GJXAIOU",[[1,9901,"\n\t\t\t\t"]],[9896,9896],[9901,9901]]],[1559371102385,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t"],[1,9023,"\t\tEnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9242,";\n\tEdgeNode *p"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[1,9659,"\n\t\t\t\t"],[-1,9695,"\n\t  visited[i] = TRUE; //设置当前顶点访问过\t"],[-1,9748,"L->adjList[i].data"],[1,9766,"点若与当前顶点"],[1,9782,"f( G.art[i][j]==1 && !visited[j] )"],[-1,9897,"\t\t\t\t\n"],[-1,9932,""],[1,9932,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[9946,9946]]],[1559371102385,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t"],[-1,9332,"\t\tEnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9475,";\n\tEdgeNode *p"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[-1,9901,"\n\t\t\t\t"],[1,9942,"\n\t  visited[i] = TRUE; //设置当前顶点访问过\t"],[1,9960,"L->adjList[i].data"],[-1,9960,"点若与当前顶点"],[-1,9983,"f( G.art[i][j]==1 && !visited[j] )"],[1,10132,"\t\t\t\t\n"],[1,10162,""],[-1,10162,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[9946,9946],[4366,4366]]],[1559371076075,["GJX@GJXAIOU",[[1,9901,"p = GL->adjList[i].firstedge;//"]],[9901,9901],[9932,9932]]],[1559371077891,["GJX@GJXAIOU",[[1,9930," "]],[9930,9930],[9931,9931]]],[1559371095361,["GJX@GJXAIOU",[[1,9933,"找到当前顶点边表链表头指针"]],[9933,9933],[9946,9946]]],[1559371162390,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5613,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[1,9659,"p = GL->adjList[i].firstedge; //找到当前顶点边表链表头指针\n\t\t\t\t"],[-1,9695,"\n\t  visited[i] = TRUE; //设置当前顶点访问过\t"],[-1,9748,"L->adjList[i].data"],[1,9766,"点若与当前顶点"],[1,9782,"f( G.art[i][j]==1 && !visited[j] )"],[-1,9897,"\t\t\t\tp = GL->adjList[i].firstedge; //找到当前顶点边表链表头指针\n"],[-1,9977,""],[1,9977,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[9991,9991]]],[1559371162390,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6122,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[-1,9901,"p = GL->adjList[i].firstedge; //找到当前顶点边表链表头指针\n\t\t\t\t"],[1,9987,"\n\t  visited[i] = TRUE; //设置当前顶点访问过\t"],[1,10005,"L->adjList[i].data"],[-1,10005,"点若与当前顶点"],[-1,10028,"f( G.art[i][j]==1 && !visited[j] )"],[1,10177,"\t\t\t\tp = GL->adjList[i].firstedge; //找到当前顶点边表链表头指针\n"],[1,10207,""],[-1,10207,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[9991,9991],[4366,4366]]],[1559371138119,["GJX@GJXAIOU",[[-1,9951,"for( j=0; j < G.numVertexes; j++ )\n\t\t\t\t{\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t\tif( G.art[i][j]==1 && !visited[j] )\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t\t}\n\t\t\t\t}"]],[9951,10189],[9951,9951]]],[1559371144955,["GJX@GJXAIOU",[[1,9951,"while()"]],[9951,9951],[9958,9958]]],[1559371147339,["GJX@GJXAIOU",[[1,9957,"p"]],[9957,9957],[9958,9958]]],[1559371150357,["GJX@GJXAIOU",[[1,9959,"{"]],[9959,9959],[9960,9960]]],[1559371150921,["GJX@GJXAIOU",[[1,9964,"\t\n\t\t\t"]],[9960,9960],[9965,9965]]],[1559371152470,["GJX@GJXAIOU",[[-1,9961,"\t\t\t\t"],[1,9965,"\n"]],[9965,9965],[9962,9962]]],[1559371152915,["GJX@GJXAIOU",[[1,9962,"{"]],[9962,9962],[9963,9963]]],[1559371154302,["GJX@GJXAIOU",[[-1,9962,"{"]],[9963,9963],[9962,9962]]],[1559371154732,["GJX@GJXAIOU",[[-1,9962,"\n"]],[9962,9962],[9961,9961]]],[1559371158293,["GJX@GJXAIOU",[[1,9961,"            "]],[9961,9961],[9973,9973]]],[1559371158889,["GJX@GJXAIOU",[[-1,9961,"            "],[1,9973,"\n"]],[9973,9973],[9962,9962]]],[1559371161025,["GJX@GJXAIOU",[[1,9962,"              "]],[9962,9962],[9976,9976]]],[1559371222399,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[1,9977,"\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[10009,10009]]],[1559371222399,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[-1,9977,"\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[10009,10009],[4366,4366]]],[1559371162571,["GJX@GJXAIOU",[[1,9976,"}"]],[9976,9976],[9977,9977]]],[1559371171251,["GJX@GJXAIOU",[[1,9961,"                  IF"]],[9961,9961],[9981,9981]]],[1559371172300,["GJX@GJXAIOU",[[-1,9979,"IF"]],[9981,9981],[9979,9979]]],[1559371177131,["GJX@GJXAIOU",[[1,9979,"if()"]],[9979,9979],[9983,9983]]],[1559371183236,["GJX@GJXAIOU",[[1,9982,"!vist"]],[9982,9982],[9987,9987]]],[1559371183886,["GJX@GJXAIOU",[[-1,9986,"t"]],[9987,9987],[9986,9986]]],[1559371187805,["GJX@GJXAIOU",[[1,9986,"itted"]],[9986,9986],[9991,9991]]],[1559371188430,["GJX@GJXAIOU",[[-1,9988,"ted"]],[9991,9991],[9988,9988]]],[1559371197778,["GJX@GJXAIOU",[[1,9988,"ed[p->adk"]],[9988,9988],[9997,9997]]],[1559371198226,["GJX@GJXAIOU",[[-1,9996,"k"]],[9997,9997],[9996,9996]]],[1559371202787,["GJX@GJXAIOU",[[1,9996,"jvex]"]],[9996,9996],[10001,10001]]],[1559371211091,["GJX@GJXAIOU",[[1,10002,"{"]],[10002,10002],[10003,10003]]],[1559371211803,["GJX@GJXAIOU",[[1,10018,"    \n              "]],[10003,10003],[10022,10022]]],[1559371212848,["GJX@GJXAIOU",[[-1,10004,"                  "],[1,10022,"\n"]],[10022,10022],[10005,10005]]],[1559371217147,["GJX@GJXAIOU",[[1,10005,"                }"]],[10005,10005],[10022,10022]]],[1559371221530,["GJX@GJXAIOU",[[1,10004,"                                "]],[10004,10004],[10036,10036]]],[1559371282410,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[-1,10070,""],[1,10070,"\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[10102,10102]]],[1559371282410,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[1,10070,""],[-1,10070,"\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[10102,10102],[4366,4366]]],[1559371224734,["GJX@GJXAIOU",[[-1,10025,"           "]],[10036,10036],[10025,10025]]],[1559371231850,["GJX@GJXAIOU",[[1,10025,"visitec"]],[10025,10025],[10032,10032]]],[1559371232493,["GJX@GJXAIOU",[[-1,10031,"c"]],[10032,10032],[10031,10031]]],[1559371240821,["GJX@GJXAIOU",[[1,10031,"d[p->adkvex"]],[10031,10031],[10042,10042]]],[1559371242132,["GJX@GJXAIOU",[[-1,10038,"kvex"]],[10042,10042],[10038,10038]]],[1559371253531,["GJX@GJXAIOU",[[1,10038,"jvex] = TRUE;"]],[10038,10038],[10051,10051]]],[1559371261573,["GJX@GJXAIOU",[[1,10068,"     \n                "]],[10051,10051],[10073,10073]]],[1559371266696,["GJX@GJXAIOU",[[1,10073,"printf()"]],[10073,10073],[10081,10081]]],[1559371281771,["GJX@GJXAIOU",[[1,10080,"\"%c\",GL->adjList"]],[10080,10080],[10096,10096]]],[1559371342415,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[-1,10131,""],[1,10131,"\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[10163,10163]]],[1559371342415,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[1,10131,""],[-1,10131,"\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[10163,10163],[4366,4366]]],[1559371286774,["GJX@GJXAIOU",[[1,10096,"[p0"]],[10096,10096],[10099,10099]]],[1559371287159,["GJX@GJXAIOU",[[-1,10098,"0"]],[10099,10099],[10098,10098]]],[1559371287964,["GJX@GJXAIOU",[[1,10098,"-0"]],[10098,10098],[10100,10100]]],[1559371288759,["GJX@GJXAIOU",[[-1,10099,"0"]],[10100,10100],[10099,10099]]],[1559371292067,["GJX@GJXAIOU",[[1,10099,">adk"]],[10099,10099],[10103,10103]]],[1559371292591,["GJX@GJXAIOU",[[-1,10102,"k"]],[10103,10103],[10102,10102]]],[1559371294186,["GJX@GJXAIOU",[[1,10102,"jlest"]],[10102,10102],[10107,10107]]],[1559371298912,["GJX@GJXAIOU",[[-1,10103,"le"]],[10105,10105],[10103,10103]]],[1559371300467,["GJX@GJXAIOU",[[1,10103,"Li"]],[10103,10103],[10105,10105]]],[1559371305216,["GJX@GJXAIOU",[[-1,10103,"List"]],[10107,10107],[10103,10103]]],[1559371314036,["GJX@GJXAIOU",[[1,10103,"vex]/"]],[10103,10103],[10108,10108]]],[1559371314934,["GJX@GJXAIOU",[[-1,10107,"/"]],[10108,10108],[10107,10107]]],[1559371317798,["GJX@GJXAIOU",[[1,10107,"、data"]],[10107,10107],[10112,10112]]],[1559371318622,["GJX@GJXAIOU",[[-1,10107,"、data"]],[10112,10112],[10107,10107]]],[1559371319605,["GJX@GJXAIOU",[[1,10107,"、"]],[10107,10107],[10108,10108]]],[1559371320269,["GJX@GJXAIOU",[[-1,10107,"、"]],[10108,10108],[10107,10107]]],[1559371320805,["GJX@GJXAIOU",[[1,10107,"/"]],[10107,10107],[10108,10108]]],[1559371321574,["GJX@GJXAIOU",[[-1,10107,"/"]],[10108,10108],[10107,10107]]],[1559371325363,["GJX@GJXAIOU",[[1,10107,".data"]],[10107,10107],[10112,10112]]],[1559371329163,["GJX@GJXAIOU",[[1,10113,";"]],[10113,10113],[10114,10114]]],[1559371329507,["GJX@GJXAIOU",[[1,10131,"     \n                "]],[10114,10114],[10136,10136]]],[1559371338214,["GJX@GJXAIOU",[[1,10136,"EnQueue()"]],[10136,10136],[10145,10145]]],[1559371341923,["GJX@GJXAIOU",[[1,10144,"&"]],[10144,10144],[10145,10145]]],[1559371402412,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[-1,10180,""],[1,10180,"\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[10212,10212]]],[1559371402412,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[1,10180,""],[-1,10180,"\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[10212,10212],[4366,4366]]],[1559371351754,["GJX@GJXAIOU",[[1,10145,"Q,p->adjvex"]],[10145,10145],[10156,10156]]],[1559371354387,["GJX@GJXAIOU",[[1,10157,";"]],[10157,10157],[10158,10158]]],[1559371362948,["GJX@GJXAIOU",[[1,10191,"  \n              "]],[10176,10176],[10193,10193]]],[1559371372292,["GJX@GJXAIOU",[[1,10193,"p = p->next;  "]],[10193,10193],[10207,10207]]],[1559371372904,["GJX@GJXAIOU",[[-1,10206," "]],[10207,10207],[10206,10206]]],[1559371373675,["GJX@GJXAIOU",[[1,10206,"、、"]],[10206,10206],[10208,10208]]],[1559371374431,["GJX@GJXAIOU",[[-1,10206,"、、"]],[10208,10208],[10206,10206]]],[1559371389813,["GJX@GJXAIOU",[[1,10206,"//指针指向下一个邻接点"]],[10206,10206],[10218,10218]]],[1559371398467,["GJX@GJXAIOU",[[1,10003," //若此"]],[10003,10003],[10008,10008]]],[1559371462417,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[-1,10239,""],[1,10239,"\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[10271,10271]]],[1559371462417,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[1,10239,""],[-1,10239,"\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[10271,10271],[4366,4366]]],[1559371409388,["GJX@GJXAIOU",[[1,10008,"顶点未被访问"]],[10008,10008],[10014,10014]]],[1559371416194,["GJX@GJXAIOU",[[1,10169," //jiang ce"]],[10169,10169],[10180,10180]]],[1559371417564,["GJX@GJXAIOU",[[-1,10172,"jiang ce"]],[10180,10180],[10172,10172]]],[1559371417869,["GJX@GJXAIOU",[[1,10172,"j"]],[10172,10172],[10173,10173]]],[1559371418242,["GJX@GJXAIOU",[[-1,10172,"j"]],[10173,10173],[10172,10172]]],[1559371428038,["GJX@GJXAIOU",[[1,10172,"将此顶点入队列"]],[10172,10172],[10179,10179]]],[1559371437768,["GJX@GJXAIOU",[[1,10288,"\n"]],[10273,10273],[10274,10274]]],[1559371461812,["GJX@GJXAIOU",[[1,10274,"图的深度优先遍历和"]],[10274,10274],[10283,10283]]],[1559371522424,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10266,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[10281,10281]]],[1559371522424,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[-1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10283,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[10281,10281],[4366,4366]]],[1559371465501,["GJX@GJXAIOU",[[1,10283,"官渡"]],[10283,10283],[10285,10285]]],[1559371466538,["GJX@GJXAIOU",[[-1,10283,"官渡"]],[10285,10285],[10283,10283]]],[1559371484205,["GJX@GJXAIOU",[[1,10283,"广度优先遍历的时间复杂度是一样的，直视啊"]],[10283,10283],[10303,10303]]],[1559371485812,["GJX@GJXAIOU",[[-1,10300,"直视啊"]],[10303,10303],[10300,10300]]],[1559371495299,["GJX@GJXAIOU",[[1,10300,"只是对顶点的访问书序"]],[10300,10300],[10310,10310]]],[1559371496131,["GJX@GJXAIOU",[[-1,10308,"书序"]],[10310,10310],[10308,10308]]],[1559371497710,["GJX@GJXAIOU",[[1,10308,"顺醋"]],[10308,10308],[10310,10310]]],[1559371498336,["GJX@GJXAIOU",[[-1,10308,"顺醋"]],[10310,10310],[10308,10308]]],[1559371503004,["GJX@GJXAIOU",[[1,10308,"顺序不同，"]],[10308,10308],[10313,10313]]],[1559371513189,["GJX@GJXAIOU",[[-1,10312,"，"]],[10313,10313],[10312,10312]]],[1559371513852,["GJX@GJXAIOU",[[1,10312,"；"]],[10312,10312],[10313,10313]]],[1559371514120,["GJX@GJXAIOU",[[1,10328,"\n"]],[10313,10313],[10314,10314]]],[1559371521333,["GJX@GJXAIOU",[[1,10314,"深度优先适合目标"]],[10314,10314],[10322,10322]]],[1559371582512,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10266,"官渡"],[-1,10285,"直视啊"],[-1,10296,"书序顺醋"],[-1,10304,"，"],[1,10315,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[10330,10330]]],[1559371582512,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[-1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10283,"官渡"],[1,10300,"直视啊"],[1,10308,"书序顺醋"],[1,10312,"，"],[-1,10322,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[10330,10330],[4366,4366]]],[1559371550990,["GJX@GJXAIOU",[[1,10322,"比较明确，以找到目标为主要目的的情况；"]],[10322,10322],[10341,10341]]],[1559371551240,["GJX@GJXAIOU",[[1,10356,"\n"]],[10341,10341],[10342,10342]]],[1559371582324,["GJX@GJXAIOU",[[1,10342,"广度优先适合在不断扩大遍历返回时候找到相对最优解的情况；"]],[10342,10342],[10370,10370]]],[1559371642508,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10266,"官渡"],[-1,10285,"直视啊"],[-1,10296,"书序顺醋"],[-1,10304,"，"],[1,10363,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[10378,10378]]],[1559371642508,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[-1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10283,"官渡"],[1,10300,"直视啊"],[1,10308,"书序顺醋"],[1,10312,"，"],[-1,10370,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[10378,10378],[4366,4366]]],[1559371600473,["GJX@GJXAIOU",[[1,10385,"\n"]],[10370,10370],[10371,10371]]],[1559371600606,["GJX@GJXAIOU",[[1,10386,"\n"]],[10371,10371],[10372,10372]]],[1559371600745,["GJX@GJXAIOU",[[1,10387,"\n"]],[10372,10372],[10373,10373]]],[1559371600873,["GJX@GJXAIOU",[[1,10388,"\n"]],[10373,10373],[10374,10374]]],[1559371601040,["GJX@GJXAIOU",[[1,10389,"\n"]],[10374,10374],[10375,10375]]],[1559371601147,["GJX@GJXAIOU",[[1,10390,"\n"]],[10375,10375],[10376,10376]]],[1559371610736,["GJX@GJXAIOU",[[1,10376,"## 7.6 最小生成树"]],[10376,10376],[10388,10388]]],[1559371611522,["GJX@GJXAIOU",[[1,10403,"\n"]],[10388,10388],[10389,10389]]],[1559371612370,["GJX@GJXAIOU",[[1,10404,"\n"]],[10389,10389],[10390,10390]]],[1559372662542,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10266,"官渡"],[-1,10285,"直视啊"],[-1,10296,"书序顺醋"],[-1,10304,"，"],[-1,10381,""],[1,10381,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[10396,10396]]],[1559372662542,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[-1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10283,"官渡"],[1,10300,"直视啊"],[1,10308,"书序顺醋"],[1,10312,"，"],[1,10388,""],[-1,10388,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[10396,10396],[4366,4366]]],[1559372660141,["GJX@GJXAIOU",[[1,10390,"概念："]],[10390,10390],[10393,10393]]],[1559372722571,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10266,"官渡"],[-1,10285,"直视啊"],[-1,10296,"书序顺醋"],[-1,10304,"，"],[-1,10386,""],[1,10386,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[10401,10401]]],[1559372722571,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[-1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10283,"官渡"],[1,10300,"直视啊"],[1,10308,"书序顺醋"],[1,10312,"，"],[1,10393,""],[-1,10393,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[10401,10401],[4366,4366]]],[1559372682198,["GJX@GJXAIOU",[[1,10393,"构造连通网的最小代价生成树；"]],[10393,10393],[10407,10407]]],[1559372694512,["GJX@GJXAIOU",[[1,10422,"\n"]],[10407,10407],[10408,10408]]],[1559372695345,["GJX@GJXAIOU",[[1,10423,"\n"]],[10408,10408],[10409,10409]]],[1559372715919,["GJX@GJXAIOU",[[1,10409,"- 普里姆（）"]],[10409,10409],[10416,10416]]],[1559372719022,["GJX@GJXAIOU",[[1,10415,"prim"]],[10415,10415],[10419,10419]]],[1559372721913,["GJX@GJXAIOU",[[1,10420,"算法"]],[10420,10420],[10422,10422]]],[1559372722397,["GJX@GJXAIOU",[[1,10423,"- \n"]],[10422,10422],[10425,10425]]],[1559372782567,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10266,"官渡"],[-1,10285,"直视啊"],[-1,10296,"书序顺醋"],[-1,10304,"，"],[-1,10408,"）"],[1,10413,"）"],[1,10415,"\n"],[1,10418,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[10432,10432]]],[1559372782567,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[-1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10283,"官渡"],[1,10300,"直视啊"],[1,10308,"书序顺醋"],[1,10312,"，"],[1,10415,"）"],[-1,10419,"）"],[-1,10422,"\n"],[-1,10426,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[10432,10432],[4366,4366]]],[1559372737050,["GJX@GJXAIOU",[[1,10425,"克鲁斯卡尔（）"]],[10425,10425],[10432,10432]]],[1559372744025,["GJX@GJXAIOU",[[1,10431,"Kruskal"]],[10431,10431],[10438,10438]]],[1559372748181,["GJX@GJXAIOU",[[-1,10415,"p"]],[10416,10416],[10415,10415]]],[1559372748532,["GJX@GJXAIOU",[[1,10415,"P"]],[10415,10415],[10416,10416]]],[1559372755544,["GJX@GJXAIOU",[[1,10439,"算法"]],[10439,10439],[10441,10441]]],[1559372842567,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10266,"官渡"],[-1,10285,"直视啊"],[-1,10296,"书序顺醋"],[-1,10304,"，"],[-1,10408,"）p"],[1,10410,"P"],[1,10413,"）"],[-1,10415,"P \n"],[1,10418,"\n- "],[-1,10424,"）"],[1,10432,"）"],[1,10434,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[10449,10449]]],[1559372842567,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[-1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10283,"官渡"],[1,10300,"直视啊"],[1,10308,"书序顺醋"],[1,10312,"，"],[1,10415,"）p"],[-1,10415,"P"],[-1,10419,"）"],[1,10422,"P \n"],[-1,10422,"\n- "],[1,10431,"）"],[-1,10438,"）"],[-1,10441,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[10449,10449],[4366,4366]]],[1559372806104,["GJX@GJXAIOU",[[1,10425,"\n- "]],[10422,10422],[10425,10425]]],[1559372806240,["GJX@GJXAIOU",[[-1,10423,"- "]],[10425,10425],[10424,10424]]],[1559372806365,["GJX@GJXAIOU",[[1,10424,"\n"]],[10424,10424],[10425,10425]]],[1559372806476,["GJX@GJXAIOU",[[1,10425,"\n"]],[10425,10425],[10426,10426]]],[1559372806600,["GJX@GJXAIOU",[[1,10426,"\n"]],[10426,10426],[10427,10427]]],[1559372809024,["GJX@GJXAIOU",[[1,10427,"\n"]],[10423,10423],[10424,10424]]],[1559372821493,["GJX@GJXAIOU",[[1,10424,"首先构造图的邻接矩阵："]],[10424,10424],[10435,10435]]],[1559372822009,["GJX@GJXAIOU",[[1,10439,"\n"]],[10435,10435],[10436,10436]]],[1559372829649,["GJX@GJXAIOU",[[1,10436,"![普里姆算法]($resource/%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95.png)"]],[10436,10436],[10506,10506]]],[1559372831575,["GJX@GJXAIOU",[[1,10509,"\n"]],[10506,10506],[10507,10507]]],[1559373022572,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10266,"官渡"],[-1,10285,"直视啊"],[-1,10296,"书序顺醋"],[-1,10304,"，"],[-1,10408,"）p"],[1,10410,"P"],[1,10413,"）"],[-1,10415,"P "],[-1,10418,"克鲁斯卡尔"],[1,10512,"克鲁斯卡尔（"],[1,10519,"）"],[1,10521,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[10536,10536]]],[1559373022572,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[-1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10283,"官渡"],[1,10300,"直视啊"],[1,10308,"书序顺醋"],[1,10312,"，"],[1,10415,"）p"],[-1,10415,"P"],[-1,10419,"）"],[1,10422,"P "],[1,10423,"克鲁斯卡尔"],[-1,10512,"克鲁斯卡尔（"],[-1,10525,"）"],[-1,10528,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[10536,10536],[4366,4366]]],[1559372984894,["GJX@GJXAIOU",[[1,10507,"算法程序代码如下："]],[10507,10507],[10516,10516]]],[1559372985278,["GJX@GJXAIOU",[[1,10519,"\n"]],[10516,10516],[10517,10517]]],[1559372986967,["GJX@GJXAIOU",[[1,10517,"```"]],[10517,10517],[10520,10520]]],[1559372987005,["GJX@GJXAIOU",[[1,10520,"language\n```\n"]],[10520,10520],[10520,10528]]],[1559372987887,["GJX@GJXAIOU",[[-1,10520,"language"],[1,10528,"c"]],[10520,10528],[10521,10521]]],[1559372988193,["GJX@GJXAIOU",[[1,10522,"\n"]],[10521,10521],[10522,10522]]],[1559373082590,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10266,"官渡"],[-1,10285,"直视啊"],[-1,10296,"书序顺醋"],[-1,10304,"，"],[-1,10408,"）p"],[1,10410,"P"],[1,10413,"）"],[-1,10415,"P "],[-1,10418,"克鲁斯卡尔"],[1,10532,"克鲁斯卡尔（"],[1,10539,"）"],[1,10541,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[10556,10556]]],[1559373082590,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[-1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10283,"官渡"],[1,10300,"直视啊"],[1,10308,"书序顺醋"],[1,10312,"，"],[1,10415,"）p"],[-1,10415,"P"],[-1,10419,"）"],[1,10422,"P "],[1,10423,"克鲁斯卡尔"],[-1,10532,"克鲁斯卡尔（"],[-1,10545,"）"],[-1,10548,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[10556,10556],[4366,4366]]],[1559373049025,["GJX@GJXAIOU",[[1,10522,"/* Prim算法生成最小生成树  */\nvoid MiniSpanTree_Prim(MGraph G)\n{\n\tint min, i, j, k;\n\tint adjvex[MAXVEX];\t\t/* 保存相关顶点下标 */\n\tint lowcost[MAXVEX];\t/* 保存相关顶点间边的权值 */\n\tlowcost[0] = 0;/* 初始化第一个权值为0，即v0加入生成树 */\n\t\t\t/* lowcost的值为0，在这里就是此下标的顶点已经加入生成树 */\n\tadjvex[0] = 0;\t\t\t/* 初始化第一个顶点下标为0 */\n\tfor(i = 1; i < G.numVertexes; i++)\t/* 循环除下标为0外的全部顶点 */\n\t{\n\t\tlowcost[i] = G.arc[0][i];\t/* 将v0顶点与之有边的权值存入数组 */\n\t\tadjvex[i] = 0;\t\t\t\t\t/* 初始化都为v0的下标 */\n\t}\n\tfor(i = 1; i < G.numVertexes; i++)\n\t{\n\t\tmin = INFINITY;\t/* 初始化最小权值为∞， */\n\t\t\t\t\t\t/* 通常设置为不可能的大数字如32767、65535等 */\n\t\tj = 1;k = 0;\n\t\twhile(j < G.numVertexes)\t/* 循环全部顶点 */\n\t\t{\n\t\t\tif(lowcost[j]!=0 && lowcost[j] < min)/* 如果权值不为0且权值小于min */\n\t\t\t{\t\n\t\t\t\tmin = lowcost[j];\t/* 则让当前权值成为最小值 */\n\t\t\t\tk = j;\t\t\t/* 将当前最小值的下标存入k */\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tprintf(\"(%d, %d)\\n\", adjvex[k], k);/* 打印当前顶点边中权值最小的边 */\n\t\tlowcost[k] = 0;/* 将当前顶点的权值设置为0,表示此顶点已经完成任务 */\n\t\tfor(j = 1; j < G.numVertexes; j++)\t/* 循环所有顶点 */\n\t\t{\n\t\t\tif(lowcost[j]!=0 && G.arc[k][j] < lowcost[j]) \n\t\t\t{/* 如果下标为k顶点各边权值小于此前这些顶点未被加入生成树权值 */\n\t\t\t\tlowcost[j] = G.arc[k][j];/* 将较小的权值存入lowcost相应位置 */\n\t\t\t\tadjvex[j] = k;\t\t\t\t/* 将下标为k的顶点存入adjvex */\n\t\t\t}\n\t\t}\n\t}\n}"]],[10522,10522],[11635,11635]]],[1559375007875,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10266,"官渡"],[-1,10285,"直视啊"],[-1,10296,"书序顺醋"],[-1,10304,"，"],[-1,10408,"）p"],[1,10410,"P"],[1,10413,"）"],[-1,10415,"P "],[-1,10418,"克鲁斯卡尔"],[1,11645,"克鲁斯卡尔（"],[1,11652,"）"],[1,11654,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[11669,11669]]],[1559375007875,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[-1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10283,"官渡"],[1,10300,"直视啊"],[1,10308,"书序顺醋"],[1,10312,"，"],[1,10415,"）p"],[-1,10415,"P"],[-1,10419,"）"],[1,10422,"P "],[1,10423,"克鲁斯卡尔"],[-1,11645,"克鲁斯卡尔（"],[-1,11658,"）"],[-1,11661,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[11669,11669],[4366,4366]]],[1559375005784,["GJX@GJXAIOU",[[1,10507,"\n"]],[10506,10506],[10507,10507]]],[1559375005932,["GJX@GJXAIOU",[[1,10508,"\n"]],[10507,10507],[10508,10508]]],[1559375006089,["GJX@GJXAIOU",[[1,10509,"\n"]],[10508,10508],[10509,10509]]],[1559375006213,["GJX@GJXAIOU",[[1,10510,"\n"]],[10509,10509],[10510,10510]]],[1559375006339,["GJX@GJXAIOU",[[1,10511,"\n"]],[10510,10510],[10511,10511]]],[1559375067885,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10266,"官渡"],[-1,10285,"直视啊"],[-1,10296,"书序顺醋"],[-1,10304,"，"],[-1,10408,"）p"],[1,10410,"P"],[1,10413,"）"],[-1,10415,"P "],[-1,10418,"克鲁斯卡尔"],[1,11650,"克鲁斯卡尔（"],[1,11657,"）"],[1,11659,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[11674,11674]]],[1559375067885,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[-1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10283,"官渡"],[1,10300,"直视啊"],[1,10308,"书序顺醋"],[1,10312,"，"],[1,10415,"）p"],[-1,10415,"P"],[-1,10419,"）"],[1,10422,"P "],[1,10423,"克鲁斯卡尔"],[-1,11650,"克鲁斯卡尔（"],[-1,11663,"）"],[-1,11666,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[11674,11674],[4366,4366]]],[1559375009460,["GJX@GJXAIOU",[[1,10507,"hi"]],[10507,10507],[10509,10509]]],[1559375009964,["GJX@GJXAIOU",[[-1,10507,"hi"]],[10509,10509],[10507,10507]]],[1559375012935,["GJX@GJXAIOU",[[1,10507,"示例理解："]],[10507,10507],[10512,10512]]],[1559375013183,["GJX@GJXAIOU",[[1,10517,"\n"]],[10512,10512],[10513,10513]]],[1559375029291,["GJX@GJXAIOU",[[1,10514,"初始状态：\n\n\n\n设置2个数据结构：\n\nlowcost[i]:表示以i为终点的边的最小权值,当lowcost[i]=0说明以i为终点的边的最小权值=0,也就是表示i点加入了MST\n\nmst[i]:表示对应lowcost[i]的起点，即说明边<mst[i],i>是MST的一条边，当mst[i]=0表示起点i加入MST\n\n\n\n我们假设V1是起始点，进行初始化（*代表无限大，即无通路）：\n\n\n\nlowcost[2]=6，lowcost[3]=1，lowcost[4]=5，lowcost[5]=*，lowcost[6]=*\n\nmst[2]=1，mst[3]=1，mst[4]=1，mst[5]=1，mst[6]=1，（所有点默认起点是V1）\n\n\n\n明显看出，以V3为终点的边的权值最小=1，所以边<mst[3],3>=1加入MST\n\n\n\n此时，因为点V3的加入，需要更新lowcost数组和mst数组：\n\nlowcost[2]=5，lowcost[3]=0，lowcost[4]=5，lowcost[5]=6，lowcost[6]=4\n\nmst[2]=3，mst[3]=0，mst[4]=1，mst[5]=3，mst[6]=3\n\n\n明显看出，以V6为终点的边的权值最小=4，所以边<mst[6],6>=4加入MST\n\n\n\n\n此时，因为点V6的加入，需要更新lowcost数组和mst数组：\n\nlowcost[2]=5，lowcost[3]=0，lowcost[4]=2，lowcost[5]=6，lowcost[6]=0\n\nmst[2]=3，mst[3]=0，mst[4]=6，mst[5]=3，mst[6]=0\n\n\n明显看出，以V4为终点的边的权值最小=2，所以边<mst[4],4>=4加入MST\n\n\n\n\n此时，因为点V4的加入，需要更新lowcost数组和mst数组：\n\nlowcost[2]=5，lowcost[3]=0，lowcost[4]=0，lowcost[5]=6，lowcost[6]=0\n\nmst[2]=3，mst[3]=0，mst[4]=0，mst[5]=3，mst[6]=0\n\n\n明显看出，以V2为终点的边的权值最小=5，所以边<mst[2],2>=5加入MST\n\n\n\n\n此时，因为点V2的加入，需要更新lowcost数组和mst数组：\n\nlowcost[2]=0，lowcost[3]=0，lowcost[4]=0，lowcost[5]=3，lowcost[6]=0\n\nmst[2]=0，mst[3]=0，mst[4]=0，mst[5]=2，mst[6]=0\n\n\n很明显，以V5为终点的边的权值最小=3，所以边<mst[5],5>=3加入MST\n\n\nlowcost[2]=0，lowcost[3]=0，lowcost[4]=0，lowcost[5]=0，lowcost[6]=0\n\nmst[2]=0，mst[3]=0，mst[4]=0，mst[5]=0，mst[6]=0\n\n\n至此，MST构建成功，如图所示：\n\n"]],[10514,10514],[11782,11782]]],[1559375247873,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10266,"官渡"],[-1,10285,"直视啊"],[-1,10296,"书序顺醋"],[-1,10304,"，"],[-1,10408,"）p"],[1,10410,"P"],[1,10413,"）"],[-1,10415,"P "],[-1,10418,"克鲁斯卡尔"],[1,12924,"克鲁斯卡尔（"],[1,12931,"）"],[1,12933,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[12948,12948]]],[1559375247873,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[-1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10283,"官渡"],[1,10300,"直视啊"],[1,10308,"书序顺醋"],[1,10312,"，"],[1,10415,"）p"],[-1,10415,"P"],[-1,10419,"）"],[1,10422,"P "],[1,10423,"克鲁斯卡尔"],[-1,12924,"克鲁斯卡尔（"],[-1,12937,"）"],[-1,12940,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[12948,12948],[4366,4366]]],[1559375222232,["GJX@GJXAIOU",[[1,10521,"![1]($resource/1.jpg)\n![2]($resource/2.jpg)\n![3]($resource/3.jpg)\n![4]($resource/4.jpg)\n![5]($resource/5.jpg)\n![6]($resource/6.jpg)"]],[10521,10521],[10653,10653]]],[1559375359423,[null,[[-1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4403,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4405,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4410,"\n邻接表的创建：  \n```"],[-1,5344,"\ndui"],[1,5348,"```\n\n"],[-1,5351,"条边"],[-1,5356,","],[-1,5359,"表"],[-1,5363,"是件"],[-1,5370,"第复杂度"],[1,5376,"**"],[-1,5377,"（）"],[-1,5380,")"],[-1,5384,"**"],[1,5386,")"],[1,5388,"\n\n"],[1,5414,"\n\n"],[-1,5596,"\n"],[-1,5609,"\n"],[-1,5634,"- "],[1,5639,"- "],[-1,5660,"擦偶"],[-1,5664,"，"],[-1,5669,"对"],[-1,5687,"  - "],[1,5691,"\n"],[1,5712,"边表结点结构"],[-1,5775,"边表结点结构"],[1,5781,"\n"],[-1,5881,"\n- "],[1,5884,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5967,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6000,""],[-1,6097,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6247,"结"],[1,6248,"顶"],[-1,6254,"界定啊"],[-1,6259,"顶"],[-1,6267,"，"],[1,6269,"\n### 7.5.1 深度优先遍历"],[-1,6286,"）"],[1,6290,"）\n"],[-1,6313,"时钟"],[-1,6321,"                "],[-1,6340,"顶底"],[-1,6351,"则从"],[-1,6367,"从"],[-1,6395,"知道"],[-1,6406,"军备"],[-1,6409,"背范文"],[-1,6429,"指导喊本"],[-1,6475,"\n"],[-1,6588,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6626,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7599,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7651,"\nBoolean visited[MAX];\t// "],[-1,7658,"es"],[1,7660,"\n\n"],[-1,7666,"\n;"],[1,7668,"深度"],[-1,7674," i++ )\n\t{"],[1,7683,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7685,"\n"],[-1,7699,"FALS"],[1,7703,"TRU"],[-1,7705,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7738,"}\n\t\n\tfor( i=0; i <"],[1,7756,"printf(\"%c \""],[-1,7761,"numVertexes; i++ )\n\t"],[1,7781,"adjList[i].data);"],[1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7816,"i"],[1,7817,"p->adjvex"],[-1,7820,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7860,"i"],[1,7861,"p->adjvex"],[-1,7863,"\n\t\t}\n\t}\n}"],[-1,7873,"、、"],[1,7890,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7900,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7917,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7941,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7959,"价比"],[-1,7967,"条边e个顶点的n"],[-1,7984,"连接"],[-1,7996,"："],[-1,8005,"）"],[-1,8008,")"],[1,8012,");"],[-1,8013,"shi"],[-1,8044,")"],[-1,8048,";"],[1,8049,")"],[-1,8052," \n"],[-1,8055,"=duiyu"],[-1,8065,"变少"],[-1,8088,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8105,"### 7.5.2 广度优先遍历（"],[-1,8123,"（"],[-1,8128,"树"],[1,8129,"\n**图"],[-1,8139,"历****类似于"],[1,8147,"树的"],[-1,8151,"图树的"],[1,8154,"**\n\n"],[1,8263,"\n"],[1,8423,"\n"],[-1,8443,"language\n```\n"],[-1,8460," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8478,"邻接矩阵的广度遍历算法"],[-1,8598,"i"],[1,8599,"I"],[1,8614," //初始化一辅助用的队列"],[1,8652," //对每一个顶点做循环"],[1,8675," //若是未访问过就处理"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8704," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8722," //设置当前顶点访问过"],[1,8741," //将此顶点入队列"],[1,8772," //若当前队列不为空"],[1,8798," //将队中元素出队列，赋值给i"],[-1,8824,"I"],[1,8825,"r"],[-1,8840," //初始化一辅助用的队列"],[1,8861,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[-1,8970," //打印该结点，其他操作均可"],[-1,8999,"\n\t\t\t\t\t\tE"],[-1,9010,"设置当前"],[1,9014,"将找到的此"],[1,9016,"标记为已"],[-1,9018,"过n"],[1,9020,"\n\t\t\t"],[1,9023,"EnQue"],[-1,9033,"\n\t\t\t\t"],[1,9042,"找到的"],[1,9048,"\n\t\t\t\t"],[-1,9070,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9168,"\n```\n\n\n"],[-1,9172,"矩阵"],[1,9174,"表"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9221,"M"],[1,9227,"AdjList"],[1,9229,"L"],[1,9245,"EdgeNode *p;\n\t"],[-1,9272,"."],[1,9273,"L->"],[-1,9323,"i"],[1,9324,"I"],[-1,9371,"."],[1,9372,"L->"],[-1,9400,"表"],[1,9401,"循环"],[-1,9421,"表"],[1,9422,"] "],[1,9442,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9447,"t"],[-1,9452,"A"],[1,9453," \", GL->a"],[-1,9459," \"L, G.vex"],[1,9472,".data"],[-1,9478,"EdgeNode *p;\n\t"],[-1,9507,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9572,"I"],[1,9573,"\n"],[-1,9620,"L->"],[1,9623,"D"],[-1,9659,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9960,"\t"],[1,9961,"\n"],[1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10266,"官渡"],[-1,10285,"直视啊"],[-1,10296,"书序顺醋"],[-1,10304,"，"],[-1,10408,"）p"],[1,10410,"P"],[1,10413,"）"],[-1,10415,"P "],[-1,10418,"克鲁斯卡尔"],[1,13055,"克鲁斯卡尔（"],[1,13062,"）"],[1,13064,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4366,4366],[13079,13079]]],[1559375359423,[null,[[1,4366,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4366,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4874,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4913,"\n邻接表的创建：  \n```"],[1,5861,"\ndui"],[-1,5861,"```\n\n"],[1,5869,"条边"],[1,5872,","],[1,5874,"表"],[1,5877,"是件"],[1,5882,"第复杂度"],[-1,5884,"**"],[1,5887,"（）"],[1,5888,")"],[1,5891,"**"],[-1,5891,")"],[-1,5894,"\n\n"],[-1,5922,"\n\n"],[1,6106,"\n"],[1,6118,"\n"],[1,6142,"- "],[-1,6145,"- "],[1,6168,"擦偶"],[1,6170,"，"],[1,6174,"对"],[1,6191,"  - "],[-1,6191,"\n"],[-1,6213,"边表结点结构"],[1,6282,"边表结点结构"],[-1,6282,"\n"],[1,6383,"\n- "],[-1,6383,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6498,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6498,""],[1,6595,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6610,"结"],[-1,6610,"顶"],[1,6617,"界定啊"],[1,6619,"顶"],[1,6626,"，"],[-1,6627,"\n### 7.5.1 深度优先遍历"],[1,6661,"）"],[-1,6664,"）\n"],[1,6689,"时钟"],[1,6695,"                "],[1,6698,"顶底"],[1,6707,"则从"],[1,6721,"从"],[1,6748,"知道"],[1,6757,"军备"],[1,6758,"背范文"],[1,6775,"指导喊本"],[1,6817,"\n"],[1,6929,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6930,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7549,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7549,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7625,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7625,"\nBoolean visited[MAX];\t// "],[1,7658,"es"],[-1,7658,"\n\n"],[1,7666,"\n;"],[-1,7666,"深度"],[1,7674," i++ )\n\t{"],[-1,7674,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7725,"\n"],[1,7740,"FALS"],[-1,7740,"TRU"],[1,7745,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7747,"}\n\t\n\tfor( i=0; i <"],[-1,7747,"printf(\"%c \""],[1,7764,"numVertexes; i++ )\n\t"],[-1,7764,"adjList[i].data);"],[-1,7799,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7861,"i"],[-1,7861,"p->adjvex"],[1,7873,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7889,"i"],[-1,7889,"p->adjvex"],[1,7900,"\n\t\t}\n\t}\n}"],[1,7901,"、、"],[-1,7916,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7955,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8086,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8181,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8233,"价比"],[1,8239,"条边e个顶点的n"],[1,8248,"连接"],[1,8258,"："],[1,8266,"）"],[1,8268,")"],[-1,8271,");"],[1,8274,"shi"],[1,8302,")"],[1,8305,";"],[-1,8305,")"],[1,8309," \n"],[1,8310,"=duiyu"],[1,8314,"变少"],[1,8335,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8335,"### 7.5.2 广度优先遍历（"],[1,8370,"（"],[1,8374,"树"],[-1,8374,"\n**图"],[1,8388,"历****类似于"],[-1,8388,"树的"],[1,8394,"图树的"],[-1,8394,"**\n\n"],[-1,8507,"\n"],[-1,8668,"\n"],[1,8689,"language\n```\n"],[1,8693," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8693,"邻接矩阵的广度遍历算法"],[1,8824,"i"],[-1,8824,"I"],[-1,8840," //初始化一辅助用的队列"],[-1,8891," //对每一个顶点做循环"],[-1,8926," //若是未访问过就处理"],[1,8956,"邻接矩阵的广度遍历算法"],[-1,8956," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9007," //设置当前顶点访问过"],[-1,9038," //将此顶点入队列"],[-1,9079," //若当前队列不为空"],[-1,9116," //将队中元素出队列，赋值给i"],[1,9158,"I"],[-1,9158,"r"],[1,9174," //初始化一辅助用的队列"],[-1,9182,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9242," //对每一个顶点做循环"],[1,9265," //若是未访问过就处理"],[1,9297," //打印该结点，其他操作均可"],[1,9311,"\n\t\t\t\t\t\tE"],[1,9314,"设置当前"],[-1,9314,"将找到的此"],[-1,9321,"标记为已"],[1,9327,"过n"],[-1,9327,"\n\t\t\t"],[-1,9334,"EnQue"],[1,9349,"\n\t\t\t\t"],[-1,9353,"找到的"],[-1,9362,"\n\t\t\t\t"],[1,9389,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9389,"\n```\n\n\n"],[1,9400,"矩阵"],[-1,9400,"表"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9447,"M"],[-1,9452,"AdjList"],[-1,9461,"L"],[-1,9478,"EdgeNode *p;\n\t"],[1,9519,"."],[-1,9519,"L->"],[1,9572,"i"],[-1,9572,"I"],[1,9620,"."],[-1,9620,"L->"],[1,9651,"表"],[-1,9651,"循环"],[1,9673,"表"],[-1,9673,"] "],[-1,9695,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9737,"t"],[1,9743,"A"],[-1,9743," \", GL->a"],[1,9758," \"L, G.vex"],[-1,9761,".data"],[1,9772,"EdgeNode *p;\n\t"],[1,9787,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9816,"I"],[-1,9816,"\n"],[1,9864,"L->"],[-1,9864,"D"],[1,9901,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9960,"\t"],[-1,9960,"\n"],[-1,10256,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10283,"官渡"],[1,10300,"直视啊"],[1,10308,"书序顺醋"],[1,10312,"，"],[1,10415,"）p"],[-1,10415,"P"],[-1,10419,"）"],[1,10422,"P "],[1,10423,"克鲁斯卡尔"],[-1,13055,"克鲁斯卡尔（"],[-1,13068,"）"],[-1,13071,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[13079,13079],[4366,4366]]],[1559375309427,["GJX@GJXAIOU",[[-1,10543,"![2]($resource/2.jpg)\n![3]($resource/3.jpg)\n![4]($resource/4.jpg)\n![5]($resource/5.jpg)\n![6]($resource/6.jpg)"]],[10543,10652],[10543,10543]]],[1559375315567,["GJX@GJXAIOU",[[1,10901,"![2]($resource/2.jpg)\n![3]($resource/3.jpg)\n![4]($resource/4.jpg)\n![5]($resource/5.jpg)\n![6]($resource/6.jpg)"]],[10901,10901],[11010,11010]]],[1559375318013,["GJX@GJXAIOU",[[-1,10923,"![3]($resource/3.jpg)\n![4]($resource/4.jpg)\n![5]($resource/5.jpg)\n![6]($resource/6.jpg)\n"]],[10923,11011],[10923,10923]]],[1559375323667,["GJX@GJXAIOU",[[1,11115,"![3]($resource/3.jpg)\n![4]($resource/4.jpg)\n![5]($resource/5.jpg)\n![6]($resource/6.jpg)\n"]],[11115,11115],[11203,11203]]],[1559375326020,["GJX@GJXAIOU",[[-1,11137,"![4]($resource/4.jpg)\n![5]($resource/5.jpg)\n![6]($resource/6.jpg)"]],[11137,11202],[11137,11137]]],[1559375331824,["GJX@GJXAIOU",[[1,11330,"![4]($resource/4.jpg)\n![5]($resource/5.jpg)\n![6]($resource/6.jpg)"]],[11330,11330],[11395,11395]]],[1559375334719,["GJX@GJXAIOU",[[-1,11352,"![5]($resource/5.jpg)\n![6]($resource/6.jpg)"]],[11352,11395],[11352,11352]]],[1559375337161,["GJX@GJXAIOU",[[1,11546,"![5]($resource/5.jpg)\n![6]($resource/6.jpg)"]],[11546,11546],[11589,11589]]],[1559375339203,["GJX@GJXAIOU",[[-1,11568,"![6]($resource/6.jpg)"]],[11568,11589],[11568,11568]]],[1559375342559,["GJX@GJXAIOU",[[1,11891,"![6]($resource/6.jpg)"]],[11891,11891],[11912,11912]]],[1559375359202,["GJX@GJXAIOU",[[1,0,"---\nstyle: ocean\n---\n"]],[11912,11912],[11933,11933]]],[1559375362174,[null,[[-1,4387,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4424,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4426,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4431,"\n邻接表的创建：  \n```"],[-1,5365,"\ndui"],[1,5369,"```\n\n"],[-1,5372,"条边"],[-1,5377,","],[-1,5380,"表"],[-1,5384,"是件"],[-1,5391,"第复杂度"],[1,5397,"**"],[-1,5398,"（）"],[-1,5401,")"],[-1,5405,"**"],[1,5407,")"],[1,5409,"\n\n"],[1,5435,"\n\n"],[-1,5617,"\n"],[-1,5630,"\n"],[-1,5655,"- "],[1,5660,"- "],[-1,5681,"擦偶"],[-1,5685,"，"],[-1,5690,"对"],[-1,5708,"  - "],[1,5712,"\n"],[1,5733,"边表结点结构"],[-1,5796,"边表结点结构"],[1,5802,"\n"],[-1,5902,"\n- "],[1,5905,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5988,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6021,""],[-1,6118,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6268,"结"],[1,6269,"顶"],[-1,6275,"界定啊"],[-1,6280,"顶"],[-1,6288,"，"],[1,6290,"\n### 7.5.1 深度优先遍历"],[-1,6307,"）"],[1,6311,"）\n"],[-1,6334,"时钟"],[-1,6342,"                "],[-1,6361,"顶底"],[-1,6372,"则从"],[-1,6388,"从"],[-1,6416,"知道"],[-1,6427,"军备"],[-1,6430,"背范文"],[-1,6450,"指导喊本"],[-1,6496,"\n"],[-1,6609,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6647,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7570,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7620,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7646,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7672,"\nBoolean visited[MAX];\t// "],[-1,7679,"es"],[1,7681,"\n\n"],[-1,7687,"\n;"],[1,7689,"深度"],[-1,7695," i++ )\n\t{"],[1,7704,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7706,"\n"],[-1,7720,"FALS"],[1,7724,"TRU"],[-1,7726,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7759,"}\n\t\n\tfor( i=0; i <"],[1,7777,"printf(\"%c \""],[-1,7782,"numVertexes; i++ )\n\t"],[1,7802,"adjList[i].data);"],[1,7820,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7837,"i"],[1,7838,"p->adjvex"],[-1,7841,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7881,"i"],[1,7882,"p->adjvex"],[-1,7884,"\n\t\t}\n\t}\n}"],[-1,7894,"、、"],[1,7911,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7921,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7938,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7962,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7980,"价比"],[-1,7988,"条边e个顶点的n"],[-1,8005,"连接"],[-1,8017,"："],[-1,8026,"）"],[-1,8029,")"],[1,8033,");"],[-1,8034,"shi"],[-1,8065,")"],[-1,8069,";"],[1,8070,")"],[-1,8073," \n"],[-1,8076,"=duiyu"],[-1,8086,"变少"],[-1,8109,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8126,"### 7.5.2 广度优先遍历（"],[-1,8144,"（"],[-1,8149,"树"],[1,8150,"\n**图"],[-1,8160,"历****类似于"],[1,8168,"树的"],[-1,8172,"图树的"],[1,8175,"**\n\n"],[1,8284,"\n"],[1,8444,"\n"],[-1,8464,"language\n```\n"],[-1,8481," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8499,"邻接矩阵的广度遍历算法"],[-1,8619,"i"],[1,8620,"I"],[1,8635," //初始化一辅助用的队列"],[1,8673," //对每一个顶点做循环"],[1,8696," //若是未访问过就处理"],[-1,8714,"邻接矩阵的广度遍历算法"],[1,8725," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8743," //设置当前顶点访问过"],[1,8762," //将此顶点入队列"],[1,8793," //若当前队列不为空"],[1,8819," //将队中元素出队列，赋值给i"],[-1,8845,"I"],[1,8846,"r"],[-1,8861," //初始化一辅助用的队列"],[1,8882,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8912," //对每一个顶点做循环"],[-1,8947," //若是未访问过就处理"],[-1,8991," //打印该结点，其他操作均可"],[-1,9020,"\n\t\t\t\t\t\tE"],[-1,9031,"设置当前"],[1,9035,"将找到的此"],[1,9037,"标记为已"],[-1,9039,"过n"],[1,9041,"\n\t\t\t"],[1,9044,"EnQue"],[-1,9054,"\n\t\t\t\t"],[1,9063,"找到的"],[1,9069,"\n\t\t\t\t"],[-1,9091,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9189,"\n```\n\n\n"],[-1,9193,"矩阵"],[1,9195,"表"],[-1,9215,"矩阵"],[1,9217,"表"],[-1,9242,"M"],[1,9248,"AdjList"],[1,9250,"L"],[1,9266,"EdgeNode *p;\n\t"],[-1,9293,"."],[1,9294,"L->"],[-1,9344,"i"],[1,9345,"I"],[-1,9392,"."],[1,9393,"L->"],[-1,9421,"表"],[1,9422,"循环"],[-1,9442,"表"],[1,9443,"] "],[1,9463,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9468,"t"],[-1,9473,"A"],[1,9474," \", GL->a"],[-1,9480," \"L, G.vex"],[1,9493,".data"],[-1,9499,"EdgeNode *p;\n\t"],[-1,9528,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9593,"I"],[1,9594,"\n"],[-1,9641,"L->"],[1,9644,"D"],[-1,9680,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9981,"\t"],[1,9982,"\n"],[1,10277,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10287,"官渡"],[-1,10306,"直视啊"],[-1,10317,"书序顺醋"],[-1,10325,"，"],[-1,10429,"）p"],[1,10431,"P"],[1,10434,"）"],[-1,10436,"P "],[-1,10439,"克鲁斯卡尔"],[1,13076,"克鲁斯卡尔（"],[1,13083,"）"],[1,13085,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4387,4387],[13100,13100]]],[1559375362174,[null,[[1,4387,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4387,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4895,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4934,"\n邻接表的创建：  \n```"],[1,5882,"\ndui"],[-1,5882,"```\n\n"],[1,5890,"条边"],[1,5893,","],[1,5895,"表"],[1,5898,"是件"],[1,5903,"第复杂度"],[-1,5905,"**"],[1,5908,"（）"],[1,5909,")"],[1,5912,"**"],[-1,5912,")"],[-1,5915,"\n\n"],[-1,5943,"\n\n"],[1,6127,"\n"],[1,6139,"\n"],[1,6163,"- "],[-1,6166,"- "],[1,6189,"擦偶"],[1,6191,"，"],[1,6195,"对"],[1,6212,"  - "],[-1,6212,"\n"],[-1,6234,"边表结点结构"],[1,6303,"边表结点结构"],[-1,6303,"\n"],[1,6404,"\n- "],[-1,6404,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6519,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6519,""],[1,6616,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6631,"结"],[-1,6631,"顶"],[1,6638,"界定啊"],[1,6640,"顶"],[1,6647,"，"],[-1,6648,"\n### 7.5.1 深度优先遍历"],[1,6682,"）"],[-1,6685,"）\n"],[1,6710,"时钟"],[1,6716,"                "],[1,6719,"顶底"],[1,6728,"则从"],[1,6742,"从"],[1,6769,"知道"],[1,6778,"军备"],[1,6779,"背范文"],[1,6796,"指导喊本"],[1,6838,"\n"],[1,6950,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6951,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7570,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7570,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7646,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7646,"\nBoolean visited[MAX];\t// "],[1,7679,"es"],[-1,7679,"\n\n"],[1,7687,"\n;"],[-1,7687,"深度"],[1,7695," i++ )\n\t{"],[-1,7695,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7746,"\n"],[1,7761,"FALS"],[-1,7761,"TRU"],[1,7766,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7768,"}\n\t\n\tfor( i=0; i <"],[-1,7768,"printf(\"%c \""],[1,7785,"numVertexes; i++ )\n\t"],[-1,7785,"adjList[i].data);"],[-1,7820,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7882,"i"],[-1,7882,"p->adjvex"],[1,7894,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7910,"i"],[-1,7910,"p->adjvex"],[1,7921,"\n\t\t}\n\t}\n}"],[1,7922,"、、"],[-1,7937,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7976,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8107,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8202,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8254,"价比"],[1,8260,"条边e个顶点的n"],[1,8269,"连接"],[1,8279,"："],[1,8287,"）"],[1,8289,")"],[-1,8292,");"],[1,8295,"shi"],[1,8323,")"],[1,8326,";"],[-1,8326,")"],[1,8330," \n"],[1,8331,"=duiyu"],[1,8335,"变少"],[1,8356,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8356,"### 7.5.2 广度优先遍历（"],[1,8391,"（"],[1,8395,"树"],[-1,8395,"\n**图"],[1,8409,"历****类似于"],[-1,8409,"树的"],[1,8415,"图树的"],[-1,8415,"**\n\n"],[-1,8528,"\n"],[-1,8689,"\n"],[1,8710,"language\n```\n"],[1,8714," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8714,"邻接矩阵的广度遍历算法"],[1,8845,"i"],[-1,8845,"I"],[-1,8861," //初始化一辅助用的队列"],[-1,8912," //对每一个顶点做循环"],[-1,8947," //若是未访问过就处理"],[1,8977,"邻接矩阵的广度遍历算法"],[-1,8977," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9028," //设置当前顶点访问过"],[-1,9059," //将此顶点入队列"],[-1,9100," //若当前队列不为空"],[-1,9137," //将队中元素出队列，赋值给i"],[1,9179,"I"],[-1,9179,"r"],[1,9195," //初始化一辅助用的队列"],[-1,9203,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9263," //对每一个顶点做循环"],[1,9286," //若是未访问过就处理"],[1,9318," //打印该结点，其他操作均可"],[1,9332,"\n\t\t\t\t\t\tE"],[1,9335,"设置当前"],[-1,9335,"将找到的此"],[-1,9342,"标记为已"],[1,9348,"过n"],[-1,9348,"\n\t\t\t"],[-1,9355,"EnQue"],[1,9370,"\n\t\t\t\t"],[-1,9374,"找到的"],[-1,9383,"\n\t\t\t\t"],[1,9410,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9410,"\n```\n\n\n"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9442,"矩阵"],[-1,9442,"表"],[1,9468,"M"],[-1,9473,"AdjList"],[-1,9482,"L"],[-1,9499,"EdgeNode *p;\n\t"],[1,9540,"."],[-1,9540,"L->"],[1,9593,"i"],[-1,9593,"I"],[1,9641,"."],[-1,9641,"L->"],[1,9672,"表"],[-1,9672,"循环"],[1,9694,"表"],[-1,9694,"] "],[-1,9716,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9758,"t"],[1,9764,"A"],[-1,9764," \", GL->a"],[1,9779," \"L, G.vex"],[-1,9782,".data"],[1,9793,"EdgeNode *p;\n\t"],[1,9808,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9837,"I"],[-1,9837,"\n"],[1,9885,"L->"],[-1,9885,"D"],[1,9922,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9981,"\t"],[-1,9981,"\n"],[-1,10277,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10304,"官渡"],[1,10321,"直视啊"],[1,10329,"书序顺醋"],[1,10333,"，"],[1,10436,"）p"],[-1,10436,"P"],[-1,10440,"）"],[1,10443,"P "],[1,10444,"克鲁斯卡尔"],[-1,13076,"克鲁斯卡尔（"],[-1,13089,"）"],[-1,13092,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[13100,13100],[4387,4387]]],[1559375361961,["GJX@GJXAIOU",[[-1,11,"ocea"],[1,15,"plai"]],[11933,11933],[11933,11933]]],[1559375362986,[null,[[-1,4387,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4424,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4426,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4431,"\n邻接表的创建：  \n```"],[-1,5365,"\ndui"],[1,5369,"```\n\n"],[-1,5372,"条边"],[-1,5377,","],[-1,5380,"表"],[-1,5384,"是件"],[-1,5391,"第复杂度"],[1,5397,"**"],[-1,5398,"（）"],[-1,5401,")"],[-1,5405,"**"],[1,5407,")"],[1,5409,"\n\n"],[1,5435,"\n\n"],[-1,5617,"\n"],[-1,5630,"\n"],[-1,5655,"- "],[1,5660,"- "],[-1,5681,"擦偶"],[-1,5685,"，"],[-1,5690,"对"],[-1,5708,"  - "],[1,5712,"\n"],[1,5733,"边表结点结构"],[-1,5796,"边表结点结构"],[1,5802,"\n"],[-1,5902,"\n- "],[1,5905,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5988,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6021,""],[-1,6118,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6268,"结"],[1,6269,"顶"],[-1,6275,"界定啊"],[-1,6280,"顶"],[-1,6288,"，"],[1,6290,"\n### 7.5.1 深度优先遍历"],[-1,6307,"）"],[1,6311,"）\n"],[-1,6334,"时钟"],[-1,6342,"                "],[-1,6361,"顶底"],[-1,6372,"则从"],[-1,6388,"从"],[-1,6416,"知道"],[-1,6427,"军备"],[-1,6430,"背范文"],[-1,6450,"指导喊本"],[-1,6496,"\n"],[-1,6609,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6647,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7570,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7620,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7646,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7672,"\nBoolean visited[MAX];\t// "],[-1,7679,"es"],[1,7681,"\n\n"],[-1,7687,"\n;"],[1,7689,"深度"],[-1,7695," i++ )\n\t{"],[1,7704,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7706,"\n"],[-1,7720,"FALS"],[1,7724,"TRU"],[-1,7726,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7759,"}\n\t\n\tfor( i=0; i <"],[1,7777,"printf(\"%c \""],[-1,7782,"numVertexes; i++ )\n\t"],[1,7802,"adjList[i].data);"],[1,7820,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7837,"i"],[1,7838,"p->adjvex"],[-1,7841,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7881,"i"],[1,7882,"p->adjvex"],[-1,7884,"\n\t\t}\n\t}\n}"],[-1,7894,"、、"],[1,7911,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7921,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7938,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7962,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7980,"价比"],[-1,7988,"条边e个顶点的n"],[-1,8005,"连接"],[-1,8017,"："],[-1,8026,"）"],[-1,8029,")"],[1,8033,");"],[-1,8034,"shi"],[-1,8065,")"],[-1,8069,";"],[1,8070,")"],[-1,8073," \n"],[-1,8076,"=duiyu"],[-1,8086,"变少"],[-1,8109,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8126,"### 7.5.2 广度优先遍历（"],[-1,8144,"（"],[-1,8149,"树"],[1,8150,"\n**图"],[-1,8160,"历****类似于"],[1,8168,"树的"],[-1,8172,"图树的"],[1,8175,"**\n\n"],[1,8284,"\n"],[1,8444,"\n"],[-1,8464,"language\n```\n"],[-1,8481," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8499,"邻接矩阵的广度遍历算法"],[-1,8619,"i"],[1,8620,"I"],[1,8635," //初始化一辅助用的队列"],[1,8673," //对每一个顶点做循环"],[1,8696," //若是未访问过就处理"],[-1,8714,"邻接矩阵的广度遍历算法"],[1,8725," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8743," //设置当前顶点访问过"],[1,8762," //将此顶点入队列"],[1,8793," //若当前队列不为空"],[1,8819," //将队中元素出队列，赋值给i"],[-1,8845,"I"],[1,8846,"r"],[-1,8861," //初始化一辅助用的队列"],[1,8882,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8912," //对每一个顶点做循环"],[-1,8947," //若是未访问过就处理"],[-1,8991," //打印该结点，其他操作均可"],[-1,9020,"\n\t\t\t\t\t\tE"],[-1,9031,"设置当前"],[1,9035,"将找到的此"],[1,9037,"标记为已"],[-1,9039,"过n"],[1,9041,"\n\t\t\t"],[1,9044,"EnQue"],[-1,9054,"\n\t\t\t\t"],[1,9063,"找到的"],[1,9069,"\n\t\t\t\t"],[-1,9091,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9189,"\n```\n\n\n"],[-1,9193,"矩阵"],[1,9195,"表"],[-1,9215,"矩阵"],[1,9217,"表"],[-1,9242,"M"],[1,9248,"AdjList"],[1,9250,"L"],[1,9266,"EdgeNode *p;\n\t"],[-1,9293,"."],[1,9294,"L->"],[-1,9344,"i"],[1,9345,"I"],[-1,9392,"."],[1,9393,"L->"],[-1,9421,"表"],[1,9422,"循环"],[-1,9442,"表"],[1,9443,"] "],[1,9463,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9468,"t"],[-1,9473,"A"],[1,9474," \", GL->a"],[-1,9480," \"L, G.vex"],[1,9493,".data"],[-1,9499,"EdgeNode *p;\n\t"],[-1,9528,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9593,"I"],[1,9594,"\n"],[-1,9641,"L->"],[1,9644,"D"],[-1,9680,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9981,"\t"],[1,9982,"\n"],[1,10277,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10287,"官渡"],[-1,10306,"直视啊"],[-1,10317,"书序顺醋"],[-1,10325,"，"],[-1,10429,"）p"],[1,10431,"P"],[1,10434,"）"],[-1,10436,"P "],[-1,10439,"克鲁斯卡尔"],[1,13076,"克鲁斯卡尔（"],[1,13083,"）"],[1,13085,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4387,4387],[13100,13100]]],[1559375362986,[null,[[1,4387,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4387,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4895,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4934,"\n邻接表的创建：  \n```"],[1,5882,"\ndui"],[-1,5882,"```\n\n"],[1,5890,"条边"],[1,5893,","],[1,5895,"表"],[1,5898,"是件"],[1,5903,"第复杂度"],[-1,5905,"**"],[1,5908,"（）"],[1,5909,")"],[1,5912,"**"],[-1,5912,")"],[-1,5915,"\n\n"],[-1,5943,"\n\n"],[1,6127,"\n"],[1,6139,"\n"],[1,6163,"- "],[-1,6166,"- "],[1,6189,"擦偶"],[1,6191,"，"],[1,6195,"对"],[1,6212,"  - "],[-1,6212,"\n"],[-1,6234,"边表结点结构"],[1,6303,"边表结点结构"],[-1,6303,"\n"],[1,6404,"\n- "],[-1,6404,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6519,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6519,""],[1,6616,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6631,"结"],[-1,6631,"顶"],[1,6638,"界定啊"],[1,6640,"顶"],[1,6647,"，"],[-1,6648,"\n### 7.5.1 深度优先遍历"],[1,6682,"）"],[-1,6685,"）\n"],[1,6710,"时钟"],[1,6716,"                "],[1,6719,"顶底"],[1,6728,"则从"],[1,6742,"从"],[1,6769,"知道"],[1,6778,"军备"],[1,6779,"背范文"],[1,6796,"指导喊本"],[1,6838,"\n"],[1,6950,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6951,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7570,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7570,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7646,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7646,"\nBoolean visited[MAX];\t// "],[1,7679,"es"],[-1,7679,"\n\n"],[1,7687,"\n;"],[-1,7687,"深度"],[1,7695," i++ )\n\t{"],[-1,7695,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7746,"\n"],[1,7761,"FALS"],[-1,7761,"TRU"],[1,7766,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7768,"}\n\t\n\tfor( i=0; i <"],[-1,7768,"printf(\"%c \""],[1,7785,"numVertexes; i++ )\n\t"],[-1,7785,"adjList[i].data);"],[-1,7820,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7882,"i"],[-1,7882,"p->adjvex"],[1,7894,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7910,"i"],[-1,7910,"p->adjvex"],[1,7921,"\n\t\t}\n\t}\n}"],[1,7922,"、、"],[-1,7937,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7976,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8107,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8202,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8254,"价比"],[1,8260,"条边e个顶点的n"],[1,8269,"连接"],[1,8279,"："],[1,8287,"）"],[1,8289,")"],[-1,8292,");"],[1,8295,"shi"],[1,8323,")"],[1,8326,";"],[-1,8326,")"],[1,8330," \n"],[1,8331,"=duiyu"],[1,8335,"变少"],[1,8356,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8356,"### 7.5.2 广度优先遍历（"],[1,8391,"（"],[1,8395,"树"],[-1,8395,"\n**图"],[1,8409,"历****类似于"],[-1,8409,"树的"],[1,8415,"图树的"],[-1,8415,"**\n\n"],[-1,8528,"\n"],[-1,8689,"\n"],[1,8710,"language\n```\n"],[1,8714," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8714,"邻接矩阵的广度遍历算法"],[1,8845,"i"],[-1,8845,"I"],[-1,8861," //初始化一辅助用的队列"],[-1,8912," //对每一个顶点做循环"],[-1,8947," //若是未访问过就处理"],[1,8977,"邻接矩阵的广度遍历算法"],[-1,8977," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9028," //设置当前顶点访问过"],[-1,9059," //将此顶点入队列"],[-1,9100," //若当前队列不为空"],[-1,9137," //将队中元素出队列，赋值给i"],[1,9179,"I"],[-1,9179,"r"],[1,9195," //初始化一辅助用的队列"],[-1,9203,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9263," //对每一个顶点做循环"],[1,9286," //若是未访问过就处理"],[1,9318," //打印该结点，其他操作均可"],[1,9332,"\n\t\t\t\t\t\tE"],[1,9335,"设置当前"],[-1,9335,"将找到的此"],[-1,9342,"标记为已"],[1,9348,"过n"],[-1,9348,"\n\t\t\t"],[-1,9355,"EnQue"],[1,9370,"\n\t\t\t\t"],[-1,9374,"找到的"],[-1,9383,"\n\t\t\t\t"],[1,9410,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9410,"\n```\n\n\n"],[1,9421,"矩阵"],[-1,9421,"表"],[1,9442,"矩阵"],[-1,9442,"表"],[1,9468,"M"],[-1,9473,"AdjList"],[-1,9482,"L"],[-1,9499,"EdgeNode *p;\n\t"],[1,9540,"."],[-1,9540,"L->"],[1,9593,"i"],[-1,9593,"I"],[1,9641,"."],[-1,9641,"L->"],[1,9672,"表"],[-1,9672,"循环"],[1,9694,"表"],[-1,9694,"] "],[-1,9716,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9758,"t"],[1,9764,"A"],[-1,9764," \", GL->a"],[1,9779," \"L, G.vex"],[-1,9782,".data"],[1,9793,"EdgeNode *p;\n\t"],[1,9808,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9837,"I"],[-1,9837,"\n"],[1,9885,"L->"],[-1,9885,"D"],[1,9922,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9981,"\t"],[-1,9981,"\n"],[-1,10277,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10304,"官渡"],[1,10321,"直视啊"],[1,10329,"书序顺醋"],[1,10333,"，"],[1,10436,"）p"],[-1,10436,"P"],[-1,10440,"）"],[1,10443,"P "],[1,10444,"克鲁斯卡尔"],[-1,13076,"克鲁斯卡尔（"],[-1,13089,"）"],[-1,13092,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[13100,13100],[4387,4387]]],[1559375362793,["GJX@GJXAIOU",[[-1,11,"plain"],[1,16,"summer"]],[11933,11933],[11934,11934]]],[1559377103059,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[1,13086,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4388,4388],[13101,13101]]],[1559377103059,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[-1,13093,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[13101,13101],[4388,4388]]],[1559377044943,["GJX@GJXAIOU",[[1,13095,"联通图"]],[13095,13095],[13098,13098]]],[1559377048019,["GJX@GJXAIOU",[[-1,13095,"联通图"]],[13098,13098],[13095,13095]]],[1559377048172,["GJX@GJXAIOU",[[-1,13107,"\n"]],[13095,13095],[13094,13094]]],[1559377076286,["GJX@GJXAIOU",[[1,13094,"首先通过连通图构建边集数组（）"]],[13094,13094],[13109,13109]]],[1559377089221,["GJX@GJXAIOU",[[1,13108,"按照权值从小到大排序"]],[13108,13108],[13118,13118]]],[1559377091141,["GJX@GJXAIOU",[[1,13132,"\n"]],[13119,13119],[13120,13120]]],[1559377096206,["GJX@GJXAIOU",[[1,13120,"[link](https://img-blog.csdn.net/20180118213606067?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV29uZGVyMjMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)"]],[13120,13120],[13304,13304]]],[1559377163047,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[1,13114,"）"],[1,13299,"\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4388,4388],[13312,13312]]],[1559377163047,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[-1,13118,"）"],[-1,13304,"\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[13312,13312],[4388,4388]]],[1559377119025,["GJX@GJXAIOU",[[-1,13120,"[link](https://img-blog.csdn.net/20180118213606067?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV29uZGVyMjMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n"]],[13120,13305],[13120,13120]]],[1559377223050,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link"],[1,13120,"）\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[4388,4388],[13134,13134]]],[1559377223050,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link"],[-1,13118,"）\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[13134,13134],[4388,4388]]],[1559377207530,["GJX@GJXAIOU",[[1,13121,"基本思想\n假设 N=(V,{E})N=(V,{E}) 是连通网：\n\n令最小生成树的初始状态为只有 nn 个顶点并且没有边的非连通图 T={V,{}}T={V,{}} ，图中每个顶点自成一个连通分量。\n在 EE 中选择代价最小的边，若该边的两个顶点落在 TT 中不同的连通分量上，则将此边加入到 TT 中，否则就舍去此边而选择下一条代价最小的边。\n以此类推，直至 TT 中所有顶点都在同一连通分量上为止。\n克鲁斯卡尔算法主要针对边来展开，边数少时效率会非常高，所以对稀疏图有很大的优势； \n而普里姆算法对于稠密图，即边数非常多的情况会更好一些。\n\n图解\n1、将连通网中的边转化为边集数组，并对它们按权值从小到大排序。 \n \n2、去掉所有边，得到 T={A,B,C,D,E,F,G,H,I,{}}T={A,B,C,D,E,F,G,H,I,{}}。 \n3、对边集数组做循环遍历，开始时，i=0，找到第 1 条边，两顶点为 EE 与 HH，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H)}}T={A,B,C,D,E,F,G,H,I,{(E,H)}}。 \n \n4、i=1，找到第 2 条边，两顶点为 CC 与 II，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I)}}。 \n5、i=2，找到第 3 条边，两顶点为 AA 与 BB，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B)}}。 \n \n6、i=3，找到第 4 条边，两顶点为 AA 与 FF，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F)}} \n7、i=4，找到第 5 条边，两顶点为 BB 与 II，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I)}} \n \n8、i=5，找到第 6 条边，两顶点为 DD 与 HH，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H)}} \n9、i=6，找到第 7 条边，两顶点为 BB 与 GG，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H),(B,G)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H),(B,G)}} \n \n10、i=7，找到第 8 条边，两顶点为 GG 与 FF，它们属于同一棵树，舍去。再找 i=8，两顶点为 BB 与 CC，它们属于同一棵树，舍去。再找 i=9，两顶点为 GG 与 HH，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H),(B,G),(G,H)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H),(B,G),(G,H)}}。 \n11、此后的循环均造成环路，最终最小生成树如下。 \n\n\n时间复杂度\n找边的两顶点是否属于同一棵树的时间复杂度为 O(loge)O(loge)，而外面有一个 for 循环 ee 次。所以克鲁斯卡尔算法的时间复杂度为 O(eloge)O(eloge)（ee 表示边的条数）。"]],[13121,13121],[14937,14937]]],[1559377215691,["GJX@GJXAIOU",[[1,13323,"\n"]],[13322,13322],[13323,13323]]],[1559377218452,["GJX@GJXAIOU",[[1,13121,"**"],[1,13125,"**"]],[13121,13125],[13121,13129]]],[1559377283054,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13328,"克"],[-1,14941,""],[1,14941,"\n\n\n\n\n\n\n\n\n\n\n"]],[4388,4388],[14952,14952]]],[1559377283054,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13328,"克"],[1,14942,""],[-1,14942,"\n\n\n\n\n\n\n\n\n\n\n"]],[14952,14952],[4388,4388]]],[1559377223325,["GJX@GJXAIOU",[[1,13399,"**"],[1,13401,"**"]],[13399,13401],[13399,13405]]],[1559377239807,["GJX@GJXAIOU",[[1,13441,"![1]($resource/1.png)\n"]],[13440,13440],[13463,13463]]],[1559377251827,["GJX@GJXAIOU",[[1,13525,"\n"]],[13524,13524],[13525,13525]]],[1559377259514,["GJX@GJXAIOU",[[1,13525,"![2]($resource/2.png)"]],[13525,13525],[13547,13547]]],[1559377269677,["GJX@GJXAIOU",[[-1,13441,"![1]($resource/1.png)"]],[13441,13462],[13441,13441]]],[1559377271652,["GJX@GJXAIOU",[[-1,13504,"![2]($resource/2.png)"]],[13504,13525],[13504,13504]]],[1559377343061,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13328,"克"],[-1,13398,"图"],[1,13401,"图"],[-1,13402,"\n"],[1,13405,"\n"],[-1,13440,"2"],[1,13442,"2"],[-1,13503,"3"],[1,13505,"3"],[-1,14947,""],[1,14947,"\n\n\n\n\n\n\n\n\n\n\n"]],[4388,4388],[14958,14958]]],[1559377343061,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13328,"克"],[1,13399,"图"],[-1,13401,"图"],[1,13403,"\n"],[-1,13405,"\n"],[1,13441,"2"],[-1,13442,"2"],[1,13504,"3"],[-1,13505,"3"],[1,14948,""],[-1,14948,"\n\n\n\n\n\n\n\n\n\n\n"]],[14958,14958],[4388,4388]]],[1559377286630,["GJX@GJXAIOU",[[1,13441,"![1]($resource/1.png)\n![2]($resource/2.png)"]],[13440,13440],[13485,13485]]],[1559377297167,["GJX@GJXAIOU",[[1,13676,"![7]($resource/7.jpg)\n"]],[13675,13675],[13698,13698]]],[1559377300205,["GJX@GJXAIOU",[[-1,13676,"![7]($resource/7.jpg)"]],[13676,13697],[13676,13676]]],[1559377307996,["GJX@GJXAIOU",[[1,13676,"![8]($resource/8.jpg)"]],[13676,13676],[13698,13698]]],[1559377324001,["GJX@GJXAIOU",[[1,13958,"![9]($resource/9.jpg)\n"]],[13957,13957],[13980,13980]]],[1559377403064,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13328,"克"],[-1,13398,"图"],[1,13401,"图"],[-1,13402,"\n"],[1,13405,"\n"],[-1,13440,"2"],[1,13485,"2"],[-1,13546,"3"],[1,13548,"3"],[-1,13675,"4"],[1,13698,"4"],[-1,13957,"6"],[1,13980,"6"],[-1,15034,""],[1,15034,"\n\n\n\n\n\n\n\n\n\n\n"]],[4388,4388],[15045,15045]]],[1559377403064,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13328,"克"],[1,13399,"图"],[-1,13401,"图"],[1,13403,"\n"],[-1,13405,"\n"],[1,13441,"2"],[-1,13485,"2"],[1,13547,"3"],[-1,13548,"3"],[1,13676,"4"],[-1,13698,"4"],[1,13958,"6"],[-1,13980,"6"],[1,15035,""],[-1,15035,"\n\n\n\n\n\n\n\n\n\n\n"]],[15045,15045],[4388,4388]]],[1559377351957,["GJX@GJXAIOU",[[1,14286,"![10]($resource/10.jpg)\n"]],[14285,14285],[14310,14310]]],[1559377363098,["GJX@GJXAIOU",[[1,14664,"![11]($resource/11.jpg)\n"]],[14663,14663],[14688,14688]]],[1559377374473,["GJX@GJXAIOU",[[1,14974,"![12]($resource/12.jpg)"]],[14974,14974],[14998,14998]]],[1559377379787,["GJX@GJXAIOU",[[1,14999,"**"],[1,15004,"**"]],[14999,15004],[14999,15008]]],[1559377394720,["GJX@GJXAIOU",[[-1,15090,"O(eloge)"]],[15090,15098],[15090,15090]]],[1559377397228,["GJX@GJXAIOU",[[-1,15038,"O(loge)"]],[15038,15045],[15038,15038]]],[1559377400838,["GJX@GJXAIOU",[[-1,15054,"e"]],[15055,15055],[15054,15054]]],[1559377402246,["GJX@GJXAIOU",[[-1,15085," "]],[15086,15086],[15085,15085]]],[1559377463061,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13328,"克"],[-1,13398,"图"],[1,13401,"图"],[-1,13402,"\n"],[1,13405,"\n"],[-1,13440,"2"],[1,13485,"2"],[-1,13546,"3"],[1,13548,"3"],[-1,13675,"4"],[1,13698,"4"],[-1,13957,"6"],[1,13980,"6"],[-1,14285,"8"],[1,14310,"8"],[-1,14663,"1"],[1,14688,"1"],[-1,14973,"\n"],[-1,14998,"时"],[1,14999,"\n"],[1,15001,"时"],[-1,15005,"\n"],[1,15008,"\n"],[-1,15037,"O"],[1,15038,"，"],[-1,15053,"e"],[1,15054," "],[-1,15081,"Oee "],[1,15085,"（ee表"],[1,15092,"\n\n\n\n\n\n\n\n\n\n\n"]],[4388,4388],[15103,15103]]],[1559377463061,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13328,"克"],[1,13399,"图"],[-1,13401,"图"],[1,13403,"\n"],[-1,13405,"\n"],[1,13441,"2"],[-1,13485,"2"],[1,13547,"3"],[-1,13548,"3"],[1,13676,"4"],[-1,13698,"4"],[1,13958,"6"],[-1,13980,"6"],[1,14286,"8"],[-1,14310,"8"],[1,14664,"1"],[-1,14688,"1"],[1,14974,"\n"],[1,14998,"时"],[-1,14998,"\n"],[-1,15001,"时"],[1,15006,"\n"],[-1,15008,"\n"],[1,15038,"O"],[-1,15038,"，"],[1,15054,"e"],[-1,15054," "],[1,15082,"Oee "],[-1,15082,"（ee表"],[-1,15093,"\n\n\n\n\n\n\n\n\n\n\n"]],[15103,15103],[4388,4388]]],[1559377403611,["GJX@GJXAIOU",[[-1,15084,"e"]],[15085,15085],[15084,15084]]],[1559377523082,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13328,"克"],[-1,13398,"图"],[1,13401,"图"],[-1,13402,"\n"],[1,13405,"\n"],[-1,13440,"2"],[1,13485,"2"],[-1,13546,"3"],[1,13548,"3"],[-1,13675,"4"],[1,13698,"4"],[-1,13957,"6"],[1,13980,"6"],[-1,14285,"8"],[1,14310,"8"],[-1,14663,"1"],[1,14688,"1"],[-1,14973,"\n"],[-1,14998,"时"],[1,14999,"\n"],[1,15001,"时"],[-1,15005,"\n"],[1,15008,"\n"],[-1,15037,"O"],[1,15038,"，"],[-1,15053,"e"],[1,15054," "],[-1,15081,"Oee"],[1,15084,"（e表"],[1,15091,"\n\n\n\n\n\n\n\n\n\n\n"]],[4388,4388],[15102,15102]]],[1559377523082,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13328,"克"],[1,13399,"图"],[-1,13401,"图"],[1,13403,"\n"],[-1,13405,"\n"],[1,13441,"2"],[-1,13485,"2"],[1,13547,"3"],[-1,13548,"3"],[1,13676,"4"],[-1,13698,"4"],[1,13958,"6"],[-1,13980,"6"],[1,14286,"8"],[-1,14310,"8"],[1,14664,"1"],[-1,14688,"1"],[1,14974,"\n"],[1,14998,"时"],[-1,14998,"\n"],[-1,15001,"时"],[1,15006,"\n"],[-1,15008,"\n"],[1,15038,"O"],[-1,15038,"，"],[1,15054,"e"],[-1,15054," "],[1,15082,"Oee"],[-1,15082,"（e表"],[-1,15092,"\n\n\n\n\n\n\n\n\n\n\n"]],[15102,15102],[4388,4388]]],[1559377513843,["GJX@GJXAIOU",[[1,15094,"代码："]],[15094,15094],[15097,15097]]],[1559377514295,["GJX@GJXAIOU",[[1,15106,"\n"]],[15097,15097],[15098,15098]]],[1559377515656,["GJX@GJXAIOU",[[1,15098,"```"]],[15098,15098],[15101,15101]]],[1559377515705,["GJX@GJXAIOU",[[1,15101,"language\n```\n"]],[15101,15101],[15101,15109]]],[1559377517046,["GJX@GJXAIOU",[[-1,15101,"language"],[1,15109,"c"]],[15101,15109],[15102,15102]]],[1559377517237,["GJX@GJXAIOU",[[1,15103,"\n"]],[15102,15102],[15103,15103]]],[1559377518339,["GJX@GJXAIOU",[[1,15104,"int Find(int *parent, int f)\n{\n\twhile( parent[f] > 0 )\n\t{\n\t\tf = parent[f];\n\t}\n\t\n\treturn f;\n}\n\n// Kruskal绠楁硶鐢熸垚鏈€灏忕敓鎴愭爲\nvoid MiniSpanTree_Kruskal(MGraph G)\n{\n\tint i, n, m;\n\tEdge edges[MAGEDGE];\t// 瀹氫箟杈归泦鏁扮粍\n\tint parent[MAXVEX];\t\t// 瀹氫箟parent鏁扮粍鐢ㄦ潵鍒ゆ柇杈逛笌杈规槸鍚﹀舰鎴愮幆璺?\n\t\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tparent[i] = 0;\n\t}\n\t\n\tfor( i=0; i < G.numEdges; i++ )\n\t{\n\t\tn = Find(parent, edges[i].begin);\t// 4 2 0 1 5 3 8 6 6 6 7\n\t\tm = Find(parent, edges[i].end);\t\t// 7 8 1 5 8 7 6 6 6 7 7\n\t\t\n\t\tif( n != m )\t\t// 濡傛灉n==m锛屽垯褰㈡垚鐜矾锛屼笉婊¤冻锛?\n\t\t{\n\t\t\tparent[n] = m;\t// 灏嗘杈圭殑缁撳熬椤剁偣鏀惧叆涓嬫爣涓鸿捣鐐圭殑parent鏁扮粍涓紝琛ㄧず姝ら《鐐瑰凡缁忓湪鐢熸垚鏍戦泦鍚堜腑\n\t\t\tprintf(\"(%d, %d) %d \", edges[i].begin, edges[i].end, edges[i].weight);\n\t\t}\n\t}\n}\n"]],[15103,15103],[15800,15800]]],[1559377583073,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13328,"克"],[-1,13398,"图"],[1,13401,"图"],[-1,13402,"\n"],[1,13405,"\n"],[-1,13440,"2"],[1,13485,"2"],[-1,13546,"3"],[1,13548,"3"],[-1,13675,"4"],[1,13698,"4"],[-1,13957,"6"],[1,13980,"6"],[-1,14285,"8"],[1,14310,"8"],[-1,14663,"1"],[1,14688,"1"],[-1,14973,"\n"],[-1,14998,"时"],[1,14999,"\n"],[1,15001,"时"],[-1,15005,"\n"],[1,15008,"\n"],[-1,15037,"O"],[1,15038,"，"],[-1,15053,"e"],[1,15054," "],[-1,15081,"Oee"],[1,15084,"（e表"],[1,15091,"\n\n"],[-1,15098,"lanc`"],[1,15103,"c\n"],[-1,15800,""],[1,15800,"\n```\n\n\n\n\n\n\n\n"]],[4388,4388],[15812,15812]]],[1559377583073,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13328,"克"],[1,13399,"图"],[-1,13401,"图"],[1,13403,"\n"],[-1,13405,"\n"],[1,13441,"2"],[-1,13485,"2"],[1,13547,"3"],[-1,13548,"3"],[1,13676,"4"],[-1,13698,"4"],[1,13958,"6"],[-1,13980,"6"],[1,14286,"8"],[-1,14310,"8"],[1,14664,"1"],[-1,14688,"1"],[1,14974,"\n"],[1,14998,"时"],[-1,14998,"\n"],[-1,15001,"时"],[1,15006,"\n"],[-1,15008,"\n"],[1,15038,"O"],[-1,15038,"，"],[1,15054,"e"],[-1,15054," "],[1,15082,"Oee"],[-1,15082,"（e表"],[-1,15092,"\n\n"],[1,15101,"lanc`"],[-1,15101,"c\n"],[1,15800,""],[-1,15800,"\n```\n\n\n\n\n\n\n\n"]],[15812,15812],[4388,4388]]],[1559377529681,["GJX@GJXAIOU",[[1,15103,"、"]],[15103,15103],[15104,15104]]],[1559377530496,["GJX@GJXAIOU",[[-1,15103,"、"]],[15104,15104],[15103,15103]]],[1559377536624,["GJX@GJXAIOU",[[1,15103,"/*  8"]],[15103,15103],[15108,15108]]],[1559377537443,["GJX@GJXAIOU",[[-1,15107,"8"]],[15108,15108],[15107,15107]]],[1559377538642,["GJX@GJXAIOU",[[1,15107,"*/"]],[15107,15107],[15109,15109]]],[1559377544802,["GJX@GJXAIOU",[[1,15106,"查找联想"]],[15106,15106],[15110,15110]]],[1559377548811,["GJX@GJXAIOU",[[-1,15108,"联想"]],[15110,15110],[15108,15108]]],[1559377559195,["GJX@GJXAIOU",[[1,15108,"连线顶点的尾部下标"]],[15108,15108],[15117,15117]]],[1559377572761,["GJX@GJXAIOU",[[1,15175," //表示有环路"]],[15175,15175],[15183,15183]]],[1559377578176,["GJX@GJXAIOU",[[-1,15233,"绠楁硶鐢熸垚鏈€灏忕敓鎴愭爲"],[1,15247,"d"]],[15233,15247],[15234,15234]]],[1559377578338,["GJX@GJXAIOU",[[1,15234,"u"]],[15234,15234],[15235,15235]]],[1559377578793,["GJX@GJXAIOU",[[-1,15233,"du"]],[15235,15235],[15233,15233]]],[1559377582706,["GJX@GJXAIOU",[[1,15233,"算法生成"]],[15233,15233],[15237,15237]]],[1559377643086,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13328,"克"],[-1,13398,"图"],[1,13401,"图"],[-1,13402,"\n"],[1,13405,"\n"],[-1,13440,"2"],[1,13485,"2"],[-1,13546,"3"],[1,13548,"3"],[-1,13675,"4"],[1,13698,"4"],[-1,13957,"6"],[1,13980,"6"],[-1,14285,"8"],[1,14310,"8"],[-1,14663,"1"],[1,14688,"1"],[-1,14973,"\n"],[-1,14998,"时"],[1,14999,"\n"],[1,15001,"时"],[-1,15005,"\n"],[1,15008,"\n"],[-1,15037,"O"],[1,15038,"，"],[-1,15053,"e"],[1,15054," "],[-1,15081,"Oee"],[1,15084,"（e表"],[1,15091,"\n\n"],[-1,15098,"lanc`"],[1,15103,"c\n"],[-1,15815,""],[1,15815,"\n```\n\n\n\n\n\n\n\n"]],[4388,4388],[15827,15827]]],[1559377643086,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13328,"克"],[1,13399,"图"],[-1,13401,"图"],[1,13403,"\n"],[-1,13405,"\n"],[1,13441,"2"],[-1,13485,"2"],[1,13547,"3"],[-1,13548,"3"],[1,13676,"4"],[-1,13698,"4"],[1,13958,"6"],[-1,13980,"6"],[1,14286,"8"],[-1,14310,"8"],[1,14664,"1"],[-1,14688,"1"],[1,14974,"\n"],[1,14998,"时"],[-1,14998,"\n"],[-1,15001,"时"],[1,15006,"\n"],[-1,15008,"\n"],[1,15038,"O"],[-1,15038,"，"],[1,15054,"e"],[-1,15054," "],[1,15082,"Oee"],[-1,15082,"（e表"],[-1,15092,"\n\n"],[1,15101,"lanc`"],[-1,15101,"c\n"],[1,15815,""],[-1,15815,"\n```\n\n\n\n\n\n\n\n"]],[15827,15827],[4388,4388]]],[1559377589100,["GJX@GJXAIOU",[[1,15237,"最小生成树"]],[15237,15237],[15242,15242]]],[1559377600046,["GJX@GJXAIOU",[[1,15278," //生成最小生成树"]],[15278,15278],[15288,15288]]],[1559377605057,["GJX@GJXAIOU",[[-1,15330,"瀹氫箟杈归泦鏁扮粍"],[1,15339,"d"]],[15330,15339],[15331,15331]]],[1559377605720,["GJX@GJXAIOU",[[1,15331,"ingyi"]],[15331,15331],[15336,15336]]],[1559377606899,["GJX@GJXAIOU",[[-1,15330,"dingyi"]],[15336,15336],[15330,15330]]],[1559377610982,["GJX@GJXAIOU",[[1,15330,"定义编辑"]],[15330,15330],[15334,15334]]],[1559377613106,["GJX@GJXAIOU",[[-1,15332,"编辑"]],[15334,15334],[15332,15332]]],[1559377615259,["GJX@GJXAIOU",[[1,15332,"边集数组"]],[15332,15332],[15336,15336]]],[1559377621878,["GJX@GJXAIOU",[[-1,15362,"瀹氫箟parent鏁扮粍鐢ㄦ潵鍒ゆ柇杈逛笌杈规槸鍚﹀舰鎴愮幆璺?"],[1,15394,"定义"]],[15362,15362],[15364,15364]]],[1559377628588,["GJX@GJXAIOU",[[1,15364,"一数组永凯"]],[15364,15364],[15369,15369]]],[1559377630260,["GJX@GJXAIOU",[[-1,15367,"永凯"]],[15369,15369],[15367,15367]]],[1559377636637,["GJX@GJXAIOU",[[1,15367,"用来判断"]],[15367,15367],[15371,15371]]],[1559377703093,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13328,"克"],[-1,13398,"图"],[1,13401,"图"],[-1,13402,"\n"],[1,13405,"\n"],[-1,13440,"2"],[1,13485,"2"],[-1,13546,"3"],[1,13548,"3"],[-1,13675,"4"],[1,13698,"4"],[-1,13957,"6"],[1,13980,"6"],[-1,14285,"8"],[1,14310,"8"],[-1,14663,"1"],[1,14688,"1"],[-1,14973,"\n"],[-1,14998,"时"],[1,14999,"\n"],[1,15001,"时"],[-1,15005,"\n"],[1,15008,"\n"],[-1,15037,"O"],[1,15038,"，"],[-1,15053,"e"],[1,15054," "],[-1,15081,"Oee"],[1,15084,"（e表"],[1,15091,"\n\n"],[-1,15098,"lanc`"],[1,15103,"c\n"],[-1,15804,""],[1,15804,"\n```\n\n\n\n\n\n\n\n"]],[4388,4388],[15816,15816]]],[1559377703098,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13328,"克"],[1,13399,"图"],[-1,13401,"图"],[1,13403,"\n"],[-1,13405,"\n"],[1,13441,"2"],[-1,13485,"2"],[1,13547,"3"],[-1,13548,"3"],[1,13676,"4"],[-1,13698,"4"],[1,13958,"6"],[-1,13980,"6"],[1,14286,"8"],[-1,14310,"8"],[1,14664,"1"],[-1,14688,"1"],[1,14974,"\n"],[1,14998,"时"],[-1,14998,"\n"],[-1,15001,"时"],[1,15006,"\n"],[-1,15008,"\n"],[1,15038,"O"],[-1,15038,"，"],[1,15054,"e"],[-1,15054," "],[1,15082,"Oee"],[-1,15082,"（e表"],[-1,15092,"\n\n"],[1,15101,"lanc`"],[-1,15101,"c\n"],[1,15804,""],[-1,15804,"\n```\n\n\n\n\n\n\n\n"]],[15816,15816],[4388,4388]]],[1559377650068,["GJX@GJXAIOU",[[1,15371,"边与边是够"]],[15371,15371],[15376,15376]]],[1559377650673,["GJX@GJXAIOU",[[-1,15374,"是够"]],[15376,15376],[15374,15374]]],[1559377658221,["GJX@GJXAIOU",[[1,15374,"是否形成环路"]],[15374,15374],[15380,15380]]],[1559377763084,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13328,"克"],[-1,13398,"图"],[1,13401,"图"],[-1,13402,"\n"],[1,13405,"\n"],[-1,13440,"2"],[1,13485,"2"],[-1,13546,"3"],[1,13548,"3"],[-1,13675,"4"],[1,13698,"4"],[-1,13957,"6"],[1,13980,"6"],[-1,14285,"8"],[1,14310,"8"],[-1,14663,"1"],[1,14688,"1"],[-1,14973,"\n"],[-1,14998,"时"],[1,14999,"\n"],[1,15001,"时"],[-1,15005,"\n"],[1,15008,"\n"],[-1,15037,"O"],[1,15038,"，"],[-1,15053,"e"],[1,15054," "],[-1,15081,"Oee"],[1,15084,"（e表"],[1,15091,"\n\n"],[-1,15098,"lanc`"],[1,15103,"c\n"],[-1,15813,""],[1,15813,"\n```\n\n\n\n\n\n\n\n"]],[4388,4388],[15825,15825]]],[1559377763084,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13328,"克"],[1,13399,"图"],[-1,13401,"图"],[1,13403,"\n"],[-1,13405,"\n"],[1,13441,"2"],[-1,13485,"2"],[1,13547,"3"],[-1,13548,"3"],[1,13676,"4"],[-1,13698,"4"],[1,13958,"6"],[-1,13980,"6"],[1,14286,"8"],[-1,14310,"8"],[1,14664,"1"],[-1,14688,"1"],[1,14974,"\n"],[1,14998,"时"],[-1,14998,"\n"],[-1,15001,"时"],[1,15006,"\n"],[-1,15008,"\n"],[1,15038,"O"],[-1,15038,"，"],[1,15054,"e"],[-1,15054," "],[1,15082,"Oee"],[-1,15082,"（e表"],[-1,15092,"\n\n"],[1,15101,"lanc`"],[-1,15101,"c\n"],[1,15813,""],[-1,15813,"\n```\n\n\n\n\n\n\n\n"]],[15825,15825],[4388,4388]]],[1559377747106,["GJX@GJXAIOU",[[1,15382,"/*  */"]],[15382,15382],[15388,15388]]],[1559377750375,["GJX@GJXAIOU",[[1,15385,"d"]],[15385,15385],[15386,15386]]],[1559377750855,["GJX@GJXAIOU",[[-1,15385,"d"]],[15386,15386],[15385,15385]]],[1559377762067,["GJX@GJXAIOU",[[1,15385,"此处省略将邻接矩阵"]],[15385,15385],[15394,15394]]],[1559377823083,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13328,"克"],[-1,13398,"图"],[1,13401,"图"],[-1,13402,"\n"],[1,13405,"\n"],[-1,13440,"2"],[1,13485,"2"],[-1,13546,"3"],[1,13548,"3"],[-1,13675,"4"],[1,13698,"4"],[-1,13957,"6"],[1,13980,"6"],[-1,14285,"8"],[1,14310,"8"],[-1,14663,"1"],[1,14688,"1"],[-1,14973,"\n"],[-1,14998,"时"],[1,14999,"\n"],[1,15001,"时"],[-1,15005,"\n"],[1,15008,"\n"],[-1,15037,"O"],[1,15038,"，"],[-1,15053,"e"],[1,15054," "],[-1,15081,"Oee"],[1,15084,"（e表"],[1,15091,"\n\n"],[-1,15098,"lanc`"],[1,15103,"c\n"],[-1,15828,""],[1,15828,"\n```\n\n\n\n\n\n\n\n"]],[4388,4388],[15840,15840]]],[1559377823084,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13328,"克"],[1,13399,"图"],[-1,13401,"图"],[1,13403,"\n"],[-1,13405,"\n"],[1,13441,"2"],[-1,13485,"2"],[1,13547,"3"],[-1,13548,"3"],[1,13676,"4"],[-1,13698,"4"],[1,13958,"6"],[-1,13980,"6"],[1,14286,"8"],[-1,14310,"8"],[1,14664,"1"],[-1,14688,"1"],[1,14974,"\n"],[1,14998,"时"],[-1,14998,"\n"],[-1,15001,"时"],[1,15006,"\n"],[-1,15008,"\n"],[1,15038,"O"],[-1,15038,"，"],[1,15054,"e"],[-1,15054," "],[1,15082,"Oee"],[-1,15082,"（e表"],[-1,15092,"\n\n"],[1,15101,"lanc`"],[-1,15101,"c\n"],[1,15828,""],[-1,15828,"\n```\n\n\n\n\n\n\n\n"]],[15840,15840],[4388,4388]]],[1559377771884,["GJX@GJXAIOU",[[1,15394,"G转换为边集数组edgesa"]],[15394,15394],[15408,15408]]],[1559377772643,["GJX@GJXAIOU",[[-1,15407,"a"]],[15408,15408],[15407,15407]]],[1559377788173,["GJX@GJXAIOU",[[1,15407,"并按照权值大小进行排序的代码"]],[15407,15407],[15421,15421]]],[1559377797986,["GJX@GJXAIOU",[[1,15480," //出书和"]],[15480,15480],[15486,15486]]],[1559377798928,["GJX@GJXAIOU",[[-1,15483,"出书和"]],[15486,15486],[15483,15483]]],[1559377805503,["GJX@GJXAIOU",[[1,15483,"初始化数组值为0"]],[15483,15483],[15491,15491]]],[1559377811062,["GJX@GJXAIOU",[[1,15529," 、、"]],[15529,15529],[15532,15532]]],[1559377811830,["GJX@GJXAIOU",[[-1,15530,"、、"]],[15532,15532],[15530,15530]]],[1559377818268,["GJX@GJXAIOU",[[1,15530,"//循环每一条边"]],[15530,15530],[15538,15538]]],[1559377883095,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13328,"克"],[-1,13398,"图"],[1,13401,"图"],[-1,13402,"\n"],[1,13405,"\n"],[-1,13440,"2"],[1,13485,"2"],[-1,13546,"3"],[1,13548,"3"],[-1,13675,"4"],[1,13698,"4"],[-1,13957,"6"],[1,13980,"6"],[-1,14285,"8"],[1,14310,"8"],[-1,14663,"1"],[1,14688,"1"],[-1,14973,"\n"],[-1,14998,"时"],[1,14999,"\n"],[1,15001,"时"],[-1,15005,"\n"],[1,15008,"\n"],[-1,15037,"O"],[1,15038,"，"],[-1,15053,"e"],[1,15054," "],[-1,15081,"Oee"],[1,15084,"（e表"],[1,15091,"\n\n"],[-1,15098,"lanc`"],[1,15103,"c\n"],[-1,15875,""],[1,15875,"\n```\n\n\n\n\n\n\n\n"]],[4388,4388],[15887,15887]]],[1559377883095,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13328,"克"],[1,13399,"图"],[-1,13401,"图"],[1,13403,"\n"],[-1,13405,"\n"],[1,13441,"2"],[-1,13485,"2"],[1,13547,"3"],[-1,13548,"3"],[1,13676,"4"],[-1,13698,"4"],[1,13958,"6"],[-1,13980,"6"],[1,14286,"8"],[-1,14310,"8"],[1,14664,"1"],[-1,14688,"1"],[1,14974,"\n"],[1,14998,"时"],[-1,14998,"\n"],[-1,15001,"时"],[1,15006,"\n"],[-1,15008,"\n"],[1,15038,"O"],[-1,15038,"，"],[1,15054,"e"],[-1,15054," "],[1,15082,"Oee"],[-1,15082,"（e表"],[-1,15092,"\n\n"],[1,15101,"lanc`"],[-1,15101,"c\n"],[1,15875,""],[-1,15875,"\n```\n\n\n\n\n\n\n\n"]],[15887,15887],[4388,4388]]],[1559377824694,["GJX@GJXAIOU",[[-1,15581,"4 2 0 1 5 3 8 6 6 "]],[15582,15599],[15581,15581]]],[1559377825732,["GJX@GJXAIOU",[[-1,15578,"// 6 7"]],[15578,15584],[15578,15578]]],[1559377826995,["GJX@GJXAIOU",[[-1,15614,"// 7 8 1 5 8 7 6 6 6 7 7"]],[15614,15638],[15614,15614]]],[1559377830079,["GJX@GJXAIOU",[[-1,15637,"濡傛灉n==m锛屽垯褰㈡垚鐜矾锛屼笉婊¤冻锛?"]],[15637,15661],[15637,15637]]],[1559377847189,["GJX@GJXAIOU",[[1,15637,"加入n与mbu"]],[15637,15637],[15644,15644]]],[1559377847965,["GJX@GJXAIOU",[[-1,15642,"bu"]],[15644,15644],[15642,15642]]],[1559377862276,["GJX@GJXAIOU",[[1,15642,"不等，说明此边没有雨现有"]],[15642,15642],[15654,15654]]],[1559377866274,["GJX@GJXAIOU",[[-1,15651,"雨现有"]],[15654,15654],[15651,15651]]],[1559377876477,["GJX@GJXAIOU",[[1,15651,"与现有生成树形成环路"]],[15651,15651],[15661,15661]]],[1559377882609,["GJX@GJXAIOU",[[-1,15687,"灏嗘杈圭殑缁撳熬椤剁偣鏀惧叆涓嬫爣涓鸿捣鐐圭殑parent鏁扮粍涓紝琛ㄧず姝ら《鐐瑰凡缁忓湪鐢熸垚鏍戦泦鍚堜腑"]],[15687,15744],[15687,15687]]],[1559377943119,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13328,"克"],[-1,13398,"图"],[1,13401,"图"],[-1,13402,"\n"],[1,13405,"\n"],[-1,13440,"2"],[1,13485,"2"],[-1,13546,"3"],[1,13548,"3"],[-1,13675,"4"],[1,13698,"4"],[-1,13957,"6"],[1,13980,"6"],[-1,14285,"8"],[1,14310,"8"],[-1,14663,"1"],[1,14688,"1"],[-1,14973,"\n"],[-1,14998,"时"],[1,14999,"\n"],[1,15001,"时"],[-1,15005,"\n"],[1,15008,"\n"],[-1,15037,"O"],[1,15038,"，"],[-1,15053,"e"],[1,15054," "],[-1,15081,"Oee"],[1,15084,"（e表"],[1,15091,"\n\n"],[-1,15098,"lanc`"],[1,15103,"c\n"],[-1,15770,""],[1,15770,"\n```\n\n\n\n\n\n\n\n"]],[4388,4388],[15782,15782]]],[1559377943119,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13328,"克"],[1,13399,"图"],[-1,13401,"图"],[1,13403,"\n"],[-1,13405,"\n"],[1,13441,"2"],[-1,13485,"2"],[1,13547,"3"],[-1,13548,"3"],[1,13676,"4"],[-1,13698,"4"],[1,13958,"6"],[-1,13980,"6"],[1,14286,"8"],[-1,14310,"8"],[1,14664,"1"],[-1,14688,"1"],[1,14974,"\n"],[1,14998,"时"],[-1,14998,"\n"],[-1,15001,"时"],[1,15006,"\n"],[-1,15008,"\n"],[1,15038,"O"],[-1,15038,"，"],[1,15054,"e"],[-1,15054," "],[1,15082,"Oee"],[-1,15082,"（e表"],[-1,15092,"\n\n"],[1,15101,"lanc`"],[-1,15101,"c\n"],[1,15770,""],[-1,15770,"\n```\n\n\n\n\n\n\n\n"]],[15782,15782],[4388,4388]]],[1559377917312,["GJX@GJXAIOU",[[1,15687,"将此边的结尾结点放入下标为起点的parent中，说明此顶点已经在生成树的集合中；"]],[15687,15687],[15727,15727]]],[1559378003090,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13328,"克"],[-1,13398,"图"],[1,13401,"图"],[-1,13402,"\n"],[1,13405,"\n"],[-1,13440,"2"],[1,13485,"2"],[-1,13546,"3"],[1,13548,"3"],[-1,13675,"4"],[1,13698,"4"],[-1,13957,"6"],[1,13980,"6"],[-1,14285,"8"],[1,14310,"8"],[-1,14663,"1"],[1,14688,"1"],[-1,14973,"\n"],[-1,14998,"时"],[1,14999,"\n"],[1,15001,"时"],[-1,15005,"\n"],[1,15008,"\n"],[-1,15037,"O"],[1,15038,"，"],[-1,15053,"e"],[1,15054," "],[-1,15081,"Oee"],[1,15084,"（e表"],[1,15091,"\n\n"],[-1,15098,"lanc`"],[1,15103,"c\n"],[-1,15810,""],[1,15810,"\n```\n\n\n\n\n\n\n\n"]],[4388,4388],[15822,15822]]],[1559378003090,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13328,"克"],[1,13399,"图"],[-1,13401,"图"],[1,13403,"\n"],[-1,13405,"\n"],[1,13441,"2"],[-1,13485,"2"],[1,13547,"3"],[-1,13548,"3"],[1,13676,"4"],[-1,13698,"4"],[1,13958,"6"],[-1,13980,"6"],[1,14286,"8"],[-1,14310,"8"],[1,14664,"1"],[-1,14688,"1"],[1,14974,"\n"],[1,14998,"时"],[-1,14998,"\n"],[-1,15001,"时"],[1,15006,"\n"],[-1,15008,"\n"],[1,15038,"O"],[-1,15038,"，"],[1,15054,"e"],[-1,15054," "],[1,15082,"Oee"],[-1,15082,"（e表"],[-1,15092,"\n\n"],[1,15101,"lanc`"],[-1,15101,"c\n"],[1,15810,""],[-1,15810,"\n```\n\n\n\n\n\n\n\n"]],[15822,15822],[4388,4388]]],[1559377950280,["GJX@GJXAIOU",[[1,13328,"**"],[1,13368,"**"]],[13328,13368],[13328,13372]]],[1559377959071,["GJX@GJXAIOU",[[1,13374,"**"],[1,13401,"**"]],[13374,13401],[13374,13405]]],[1559377966933,["GJX@GJXAIOU",[[1,15832,"\n"]],[15824,15824],[15825,15825]]],[1559377967081,["GJX@GJXAIOU",[[1,15833,"\n"]],[15825,15825],[15826,15826]]],[1559377976401,["GJX@GJXAIOU",[[1,15826,"## 7.7 最短路径、"]],[15826,15826],[15838,15838]]],[1559377976498,["GJX@GJXAIOU",[[1,15846,"\n"]],[15838,15838],[15839,15839]]],[1559377977819,["GJX@GJXAIOU",[[-1,15846,"\n"]],[15839,15839],[15838,15838]]],[1559377977940,["GJX@GJXAIOU",[[-1,15837,"、"]],[15838,15838],[15837,15837]]],[1559377978779,["GJX@GJXAIOU",[[1,15845,"\n"]],[15837,15837],[15838,15838]]],[1559379083140,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[1,15834,"\n\n\n\n\n\n\n"]],[4388,4388],[15841,15841]]],[1559379083140,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[-1,15837,"\n\n\n\n\n\n\n"]],[15841,15841],[4388,4388]]],[1559379026081,["GJX@GJXAIOU",[[1,15839,"•在网图和非网图中，最短路径的含义是不同的。\n\n–网图是两顶点经过的边上权值之和最少的路径。\n\n–非网图是两顶点之间经过的边数最少的路径。"]],[15839,15839],[15908,15908]]],[1559379028321,["GJX@GJXAIOU",[[-1,15839,"•"]],[15840,15840],[15839,15839]]],[1559379323159,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•"],[1,15839,"图"],[1,15904,"\n\n\n\n\n\n\n"]],[4388,4388],[15911,15911]]],[1559379323159,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•"],[-1,15841,"图"],[-1,15907,"\n\n\n\n\n\n\n"]],[15911,15911],[4388,4388]]],[1559379276808,["GJX@GJXAIOU",[[-1,15862,"–"]],[15863,15863],[15862,15862]]],[1559379278854,["GJX@GJXAIOU",[[-1,15884,"\n"]],[15884,15884],[15883,15883]]],[1559379281994,["GJX@GJXAIOU",[[-1,15884,"–"]],[15885,15885],[15884,15884]]],[1559379283748,["GJX@GJXAIOU",[[1,15884,"- "]],[15884,15884],[15886,15886]]],[1559379286012,["GJX@GJXAIOU",[[1,15862,"- "]],[15862,15862],[15864,15864]]],[1559379287315,["GJX@GJXAIOU",[[-1,15861,"\n"]],[15861,15861],[15861,15861]]],[1559379293622,["GJX@GJXAIOU",[[1,15907,"飞往图"]],[15907,15907],[15910,15910]]],[1559379295098,["GJX@GJXAIOU",[[-1,15907,"飞往图"]],[15910,15910],[15907,15907]]],[1559379319141,["GJX@GJXAIOU",[[1,15907,"非网图可以理解称为所有边权值均为1的网；"]],[15907,15907],[15927,15927]]],[1559379319905,["GJX@GJXAIOU",[[1,15928,"- \n"]],[15927,15927],[15930,15930]]],[1559379320016,["GJX@GJXAIOU",[[-1,15928,"- "]],[15930,15930],[15929,15929]]],[1559379383151,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•"],[1,15839,"图"],[-1,15858,"\n–网"],[1,15863,"网图是"],[-1,15882,"\n–非"],[1,15887,"非网图"],[-1,15904,"飞往图"],[-1,15927,"-"],[1,15928,"\n\n\n\n\n\n\n\n"]],[4388,4388],[15936,15936]]],[1559379383151,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•"],[-1,15841,"图"],[1,15861,"\n–网"],[-1,15863,"网图是"],[1,15885,"\n–非"],[-1,15887,"非网图"],[1,15907,"飞往图"],[1,15927,"-"],[-1,15927,"\n\n\n\n\n\n\n\n"]],[15936,15936],[4388,4388]]],[1559379354437,["GJX@GJXAIOU",[[1,15929,"- 迪杰斯克拉（）"]],[15929,15929],[15938,15938]]],[1559379363630,["GJX@GJXAIOU",[[1,15937,"Dijkstra"]],[15937,15937],[15945,15945]]],[1559379367310,["GJX@GJXAIOU",[[1,15946,"算法"]],[15946,15946],[15948,15948]]],[1559379368153,["GJX@GJXAIOU",[[1,15949,"- \n"]],[15948,15948],[15951,15951]]],[1559379376042,["GJX@GJXAIOU",[[1,15951,"弗洛伊德（）"]],[15951,15951],[15957,15957]]],[1559379381125,["GJX@GJXAIOU",[[1,15956,"Floyd"]],[15956,15956],[15961,15961]]],[1559379382929,["GJX@GJXAIOU",[[1,15962,"sau"]],[15962,15962],[15965,15965]]],[1559379443164,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•"],[1,15839,"图"],[-1,15858,"\n–网"],[1,15863,"网图是"],[-1,15882,"\n–非"],[1,15887,"非网图"],[-1,15904,"飞往图"],[-1,15927,"-"],[1,15928,"\n\n"],[-1,15936,"）"],[1,15945,"）"],[1,15947,"\n"],[-1,15949,"\n"],[-1,15955,"）"],[1,15961,"）"],[1,15964,"\n\n\n\n\n\n"]],[4388,4388],[15970,15970]]],[1559379443164,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•"],[-1,15841,"图"],[1,15861,"\n–网"],[-1,15863,"网图是"],[1,15885,"\n–非"],[-1,15887,"非网图"],[1,15907,"飞往图"],[1,15927,"-"],[-1,15927,"\n\n"],[1,15937,"）"],[-1,15945,"）"],[-1,15948,"\n"],[1,15951,"\n"],[1,15956,"）"],[-1,15961,"）"],[-1,15965,"\n\n\n\n\n\n"]],[15970,15970],[4388,4388]]],[1559379383749,["GJX@GJXAIOU",[[-1,15962,"saun"]],[15966,15966],[15962,15962]]],[1559379386544,["GJX@GJXAIOU",[[1,15962,"算法"]],[15962,15962],[15964,15964]]],[1559379388857,["GJX@GJXAIOU",[[1,15951,"\n- "]],[15948,15948],[15951,15951]]],[1559379388969,["GJX@GJXAIOU",[[-1,15949,"- "]],[15951,15951],[15950,15950]]],[1559379389105,["GJX@GJXAIOU",[[1,15950,"\n"]],[15950,15950],[15951,15951]]],[1559379983184,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•"],[1,15839,"图"],[-1,15858,"\n–网"],[1,15863,"网图是"],[-1,15882,"\n–非"],[1,15887,"非网图"],[-1,15904,"飞往图"],[-1,15927,"-"],[1,15928,"\n\n"],[-1,15936,"）"],[1,15945,"）"],[-1,15947,"- "],[1,15949,"\n"],[1,15953,"弗"],[-1,15957,"）"],[-1,15963,"s"],[1,15964,"）"],[1,15966,"\n\n\n\n\n\n"]],[4388,4388],[15972,15972]]],[1559379983184,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•"],[-1,15841,"图"],[1,15861,"\n–网"],[-1,15863,"网图是"],[1,15885,"\n–非"],[-1,15887,"非网图"],[1,15907,"飞往图"],[1,15927,"-"],[-1,15927,"\n\n"],[1,15937,"）"],[-1,15945,"）"],[1,15948,"- "],[-1,15948,"\n"],[-1,15953,"弗"],[1,15958,"）"],[1,15963,"s"],[-1,15963,"）"],[-1,15966,"\n\n\n\n\n\n"]],[15972,15972],[4388,4388]]],[1559379952380,["GJX@GJXAIOU",[[1,15949,"![迪杰斯克拉邻接矩阵]($resource/%E8%BF%AA%E6%9D%B0%E6%96%AF%E5%85%8B%E6%8B%89%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png)"]],[15949,15949],[16059,16059]]],[1559379954876,["GJX@GJXAIOU",[[1,15949,"- \n"]],[15948,15948],[15951,15951]]],[1559379955010,["GJX@GJXAIOU",[[-1,15949,"- "]],[15951,15951],[15950,15950]]],[1559379959512,["GJX@GJXAIOU",[[1,15949,"原理将"]],[15949,15949],[15952,15952]]],[1559379960700,["GJX@GJXAIOU",[[-1,15951,"将"]],[15952,15952],[15951,15951]]],[1559379972941,["GJX@GJXAIOU",[[1,15951,"见书本P259"]],[15951,15951],[15958,15958]]],[1559379975702,["GJX@GJXAIOU",[[1,16070,"\n"]],[16068,16068],[16069,16069]]],[1559379975818,["GJX@GJXAIOU",[[1,16071,"\n"]],[16069,16069],[16070,16070]]],[1559379979830,["GJX@GJXAIOU",[[1,16070,"程序代码："]],[16070,16070],[16075,16075]]],[1559379980361,["GJX@GJXAIOU",[[1,16077,"\n"]],[16075,16075],[16076,16076]]],[1559379981812,["GJX@GJXAIOU",[[1,16076,"```"]],[16076,16076],[16079,16079]]],[1559379981857,["GJX@GJXAIOU",[[1,16079,"language\n```\n"]],[16079,16079],[16079,16087]]],[1559379982847,["GJX@GJXAIOU",[[-1,16079,"language"],[1,16087,"c"]],[16079,16087],[16080,16080]]],[1559380163188,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•"],[1,15839,"图"],[-1,15858,"\n–网"],[1,15863,"网图是"],[-1,15882,"\n–非"],[1,15887,"非网图"],[-1,15904,"飞往图"],[-1,15927,"-"],[1,15928,"\n\n"],[-1,15936,"）"],[1,15945,"）"],[-1,15947,"- "],[1,15949,"\n"],[1,16089,"弗"],[-1,16093,"）"],[-1,16099,"s"],[1,16100,"）"],[1,16102,"\n\n\n\n\n\n"]],[4388,4388],[16108,16108]]],[1559380163188,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•"],[-1,15841,"图"],[1,15861,"\n–网"],[-1,15863,"网图是"],[1,15885,"\n–非"],[-1,15887,"非网图"],[1,15907,"飞往图"],[1,15927,"-"],[-1,15927,"\n\n"],[1,15937,"）"],[-1,15945,"）"],[1,15948,"- "],[-1,15948,"\n"],[-1,16089,"弗"],[1,16094,"）"],[1,16099,"s"],[-1,16099,"）"],[-1,16102,"\n\n\n\n\n\n"]],[16108,16108],[4388,4388]]],[1559380121246,["GJX@GJXAIOU",[[1,16081,"#define MAXVEX\t9\n#define\tINFINITY\t65535\n\ntypedef\tint\tPatharc[MAXVEX];\t\t\t// 鐢ㄤ簬瀛樺偍鏈€鐭矾寰勪笅鏍囩殑鏁扮粍\ntypedef int\tShortPathTable[MAXVEX];\t\t// 鐢ㄤ簬瀛樺偍鍒板悇鐐规渶鐭矾寰勭殑鏉冨€煎拰\n\nvoid ShortestPath_Dijkstar(MGraph G, int V0, Patharc *P, ShortPathTable *D)\n{\n\tint v, w, k, min;\n\tint final[MAXVEX];\t\t// final[w] = 1 琛ㄧず宸茬粡姹傚緱椤剁偣V0鍒癡w鐨勬渶鐭矾寰?\n\t\n\t// 鍒濆鍖栨暟鎹?\n\tfor( v=0; v < G.numVertexes; v++ )\n\t{\n\t\tfinal[v] = 0;\t\t\t\t// 鍏ㄩ儴椤剁偣鍒濆鍖栦负鏈壘鍒版渶鐭矾寰?\n\t\t(*D)[V] = G.arc[V0][v];\t\t// 灏嗕笌V0鐐规湁杩炵嚎鐨勯《鐐瑰姞涓婃潈鍊?\n\t\t(*P)[V] = 0;\t\t\t\t// 鍒濆鍖栬矾寰勬暟缁凱涓?\n\t}\n\t(*D)[V0] = 0;\t\t// V0鑷砎0鐨勮矾寰勪负0\n\tfinal[V0] = 1;\t\t// V0鑷砎0涓嶉渶瑕佹眰璺緞\n\t\n\t// 寮€濮嬩富寰幆锛屾瘡娆℃眰寰梀0鍒版煇涓猇椤剁偣鐨勬渶鐭矾寰?\n\tfor( v=1; v < G.numVertexes; v++ )\n\t{\n\t\tmin = INFINITY;\n\t\tfor( w=0; w < G.numVertexes; w++ )\n\t\t{\n\t\t\tif( !final[w] && (*D)[w]<min )\n\t\t\t{\n\t\t\t\tk = w;\n\t\t\t\tmin = (*D)[w];\n\t\t\t}\n\t\t}\n\t\tfinal[k] = 1;\t// 灏嗙洰鍓嶆壘鍒扮殑鏈€杩戠殑椤剁偣缃?\n\t\t\n\t\t// 淇褰撳墠鏈€鐭矾寰勫強璺濈\n\t\tfor( w=0; w < G.numVextexes; w++ )\n\t\t{\n\t\t\t// 濡傛灉缁忚繃v椤剁偣鐨勮矾寰勬瘮鐜板湪杩欐潯璺緞鐨勯暱搴︾煭鐨勮瘽锛屾洿鏂帮紒\n\t\t\tif( !final[w] && (min+G.arc[k][w] < (*D)[w]) )\n\t\t\t{\n\t\t\t\t(*D)[w] = min + G.arc[k][w];\t// 淇敼褰撳墠璺緞闀垮害\n\t\t\t\t(*p)[w] = k;\t\t\t\t\t// 瀛樻斁鍓嶉┍椤剁偣\n\t\t\t}\n\t\t}\n\t}\n}"]],[16081,16081],[17180,17180]]],[1559380124606,["GJX@GJXAIOU",[[-1,16081,"#define MAXVEX\t9\n#define\tINFINITY\t65535\n\ntypedef\tint\tPatharc[MAXVEX];\t\t\t// 鐢ㄤ簬瀛樺偍鏈€鐭矾寰勪笅鏍囩殑鏁扮粍\ntypedef int\tShortPathTable[MAXVEX];\t\t// 鐢ㄤ簬瀛樺偍鍒板悇鐐规渶鐭矾寰勭殑鏉冨€煎拰\n\nvoid ShortestPath_Dijkstar(MGraph G, int V0, Patharc *P, ShortPathTable *D)\n{\n\tint v, w, k, min;\n\tint final[MAXVEX];\t\t// final[w] = 1 琛ㄧず宸茬粡姹傚緱椤剁偣V0鍒癡w鐨勬渶鐭矾寰?\n\t\n\t// 鍒濆鍖栨暟鎹?\n\tfor( v=0; v < G.numVertexes; v++ )\n\t{\n\t\tfinal[v] = 0;\t\t\t\t// 鍏ㄩ儴椤剁偣鍒濆鍖栦负鏈壘鍒版渶鐭矾寰?\n\t\t(*D)[V] = G.arc[V0][v];\t\t// 灏嗕笌V0鐐规湁杩炵嚎鐨勯《鐐瑰姞涓婃潈鍊?\n\t\t(*P)[V] = 0;\t\t\t\t// 鍒濆鍖栬矾寰勬暟缁凱涓?\n\t}\n\t(*D)[V0] = 0;\t\t// V0鑷砎0鐨勮矾寰勪负0\n\tfinal[V0] = 1;\t\t// V0鑷砎0涓嶉渶瑕佹眰璺緞\n\t\n\t// 寮€濮嬩富寰幆锛屾瘡娆℃眰寰梀0鍒版煇涓猇椤剁偣鐨勬渶鐭矾寰?\n\tfor( v=1; v < G.numVertexes; v++ )\n\t{\n\t\tmin = INFINITY;\n\t\tfor( w=0; w < G.numVertexes; w++ )\n\t\t{\n\t\t\tif( !final[w] && (*D)[w]<min )\n\t\t\t{\n\t\t\t\tk = w;\n\t\t\t\tmin = (*D)[w];\n\t\t\t}\n\t\t}\n\t\tfinal[k] = 1;\t// 灏嗙洰鍓嶆壘鍒扮殑鏈€杩戠殑椤剁偣缃?\n\t\t\n\t\t// 淇褰撳墠鏈€鐭矾寰勫強璺濈\n\t\tfor( w=0; w < G.numVextexes; w++ )\n\t\t{\n\t\t\t// 濡傛灉缁忚繃v椤剁偣鐨勮矾寰勬瘮鐜板湪杩欐潯璺緞鐨勯暱搴︾煭鐨勮瘽锛屾洿鏂帮紒\n\t\t\tif( !final[w] && (min+G.arc[k][w] < (*D)[w]) )\n\t\t\t{\n\t\t\t\t(*D)[w] = min + G.arc[k][w];\t// 淇敼褰撳墠璺緞闀垮害\n\t\t\t\t(*p)[w] = k;\t\t\t\t\t// 瀛樻斁鍓嶉┍椤剁偣\n\t\t\t}\n\t\t}\n\t}\n}"]],[17180,17180],[16081,16081]]],[1559380128389,["GJX@GJXAIOU",[[1,16081,"#define MAXVEX\t9\n#define\tINFINITY\t65535\n\ntypedef\tint\tPatharc[MAXVEX];\t\t\t// 鐢ㄤ簬瀛樺偍鏈€鐭矾寰勪笅鏍囩殑鏁扮粍\ntypedef int\tShortPathTable[MAXVEX];\t\t// 鐢ㄤ簬瀛樺偍鍒板悇鐐规渶鐭矾寰勭殑鏉冨€煎拰\n\nvoid ShortestPath_Dijkstar(MGraph G, int V0, Patharc *P, ShortPathTable *D)\n{\n\tint v, w, k, min;\n\tint final[MAXVEX];\t\t// final[w] = 1 琛ㄧず宸茬粡姹傚緱椤剁偣V0鍒癡w鐨勬渶鐭矾寰?\n\t\n\t// 鍒濆鍖栨暟鎹?\n\tfor( v=0; v < G.numVertexes; v++ )\n\t{\n\t\tfinal[v] = 0;\t\t\t\t// 鍏ㄩ儴椤剁偣鍒濆鍖栦负鏈壘鍒版渶鐭矾寰?\n\t\t(*D)[V] = G.arc[V0][v];\t\t// 灏嗕笌V0鐐规湁杩炵嚎鐨勯《鐐瑰姞涓婃潈鍊?\n\t\t(*P)[V] = 0;\t\t\t\t// 鍒濆鍖栬矾寰勬暟缁凱涓?\n\t}\n\t(*D)[V0] = 0;\t\t// V0鑷砎0鐨勮矾寰勪负0\n\tfinal[V0] = 1;\t\t// V0鑷砎0涓嶉渶瑕佹眰璺緞\n\t\n\t// 寮€濮嬩富寰幆锛屾瘡娆℃眰寰梀0鍒版煇涓猇椤剁偣鐨勬渶鐭矾寰?\n\tfor( v=1; v < G.numVertexes; v++ )\n\t{\n\t\tmin = INFINITY;\n\t\tfor( w=0; w < G.numVertexes; w++ )\n\t\t{\n\t\t\tif( !final[w] && (*D)[w]<min )\n\t\t\t{\n\t\t\t\tk = w;\n\t\t\t\tmin = (*D)[w];\n\t\t\t}\n\t\t}\n\t\tfinal[k] = 1;\t// 灏嗙洰鍓嶆壘鍒扮殑鏈€杩戠殑椤剁偣缃?\n\t\t\n\t\t// 淇褰撳墠鏈€鐭矾寰勫強璺濈\n\t\tfor( w=0; w < G.numVextexes; w++ )\n\t\t{\n\t\t\t// 濡傛灉缁忚繃v椤剁偣鐨勮矾寰勬瘮鐜板湪杩欐潯璺緞鐨勯暱搴︾煭鐨勮瘽锛屾洿鏂帮紒\n\t\t\tif( !final[w] && (min+G.arc[k][w] < (*D)[w]) )\n\t\t\t{\n\t\t\t\t(*D)[w] = min + G.arc[k][w];\t// 淇敼褰撳墠璺緞闀垮害\n\t\t\t\t(*p)[w] = k;\t\t\t\t\t// 瀛樻斁鍓嶉┍椤剁偣\n\t\t\t}\n\t\t}\n\t}\n}"]],[16081,16081],[17180,17180]]],[1559380130082,["GJX@GJXAIOU",[[-1,16081,"#define MAXVEX\t9\n#define\tINFINITY\t65535\n\ntypedef\tint\tPatharc[MAXVEX];\t\t\t// 鐢ㄤ簬瀛樺偍鏈€鐭矾寰勪笅鏍囩殑鏁扮粍\ntypedef int\tShortPathTable[MAXVEX];\t\t// 鐢ㄤ簬瀛樺偍鍒板悇鐐规渶鐭矾寰勭殑鏉冨€煎拰\n\nvoid ShortestPath_Dijkstar(MGraph G, int V0, Patharc *P, ShortPathTable *D)\n{\n\tint v, w, k, min;\n\tint final[MAXVEX];\t\t// final[w] = 1 琛ㄧず宸茬粡姹傚緱椤剁偣V0鍒癡w鐨勬渶鐭矾寰?\n\t\n\t// 鍒濆鍖栨暟鎹?\n\tfor( v=0; v < G.numVertexes; v++ )\n\t{\n\t\tfinal[v] = 0;\t\t\t\t// 鍏ㄩ儴椤剁偣鍒濆鍖栦负鏈壘鍒版渶鐭矾寰?\n\t\t(*D)[V] = G.arc[V0][v];\t\t// 灏嗕笌V0鐐规湁杩炵嚎鐨勯《鐐瑰姞涓婃潈鍊?\n\t\t(*P)[V] = 0;\t\t\t\t// 鍒濆鍖栬矾寰勬暟缁凱涓?\n\t}\n\t(*D)[V0] = 0;\t\t// V0鑷砎0鐨勮矾寰勪负0\n\tfinal[V0] = 1;\t\t// V0鑷砎0涓嶉渶瑕佹眰璺緞\n\t\n\t// 寮€濮嬩富寰幆锛屾瘡娆℃眰寰梀0鍒版煇涓猇椤剁偣鐨勬渶鐭矾寰?\n\tfor( v=1; v < G.numVertexes; v++ )\n\t{\n\t\tmin = INFINITY;\n\t\tfor( w=0; w < G.numVertexes; w++ )\n\t\t{\n\t\t\tif( !final[w] && (*D)[w]<min )\n\t\t\t{\n\t\t\t\tk = w;\n\t\t\t\tmin = (*D)[w];\n\t\t\t}\n\t\t}\n\t\tfinal[k] = 1;\t// 灏嗙洰鍓嶆壘鍒扮殑鏈€杩戠殑椤剁偣缃?\n\t\t\n\t\t// 淇褰撳墠鏈€鐭矾寰勫強璺濈\n\t\tfor( w=0; w < G.numVextexes; w++ )\n\t\t{\n\t\t\t// 濡傛灉缁忚繃v椤剁偣鐨勮矾寰勬瘮鐜板湪杩欐潯璺緞鐨勯暱搴︾煭鐨勮瘽锛屾洿鏂帮紒\n\t\t\tif( !final[w] && (min+G.arc[k][w] < (*D)[w]) )\n\t\t\t{\n\t\t\t\t(*D)[w] = min + G.arc[k][w];\t// 淇敼褰撳墠璺緞闀垮害\n\t\t\t\t(*p)[w] = k;\t\t\t\t\t// 瀛樻斁鍓嶉┍椤剁偣\n\t\t\t}\n\t\t}\n\t}\n}"]],[17180,17180],[16081,16081]]],[1559380143323,["GJX@GJXAIOU",[[1,16081,"#define MAXVEX 20\n#define INFINITY 65535"]],[16081,16081],[16121,16121]]],[1559380144405,["GJX@GJXAIOU",[[1,16122,"\n"]],[16121,16121],[16122,16122]]],[1559380155622,["GJX@GJXAIOU",[[1,16122,"typedef int Patharc[MAXVEX];    /* 用于存储最短路径下标的数组 */\ntypedef int ShortPathTable[MAXVEX];/* 用于存储到各点最短路径的权值和 */"]],[16122,16122],[16230,16230]]],[1559380157811,["GJX@GJXAIOU",[[1,16231,"\n"]],[16230,16230],[16231,16231]]],[1559380223209,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•"],[1,15839,"图"],[-1,15858,"\n–网"],[1,15863,"网图是"],[-1,15882,"\n–非"],[1,15887,"非网图"],[-1,15904,"飞往图"],[-1,15927,"-"],[1,15928,"\n\n"],[-1,15936,"）"],[1,15945,"）"],[-1,15947,"- "],[1,15949,"\n"],[-1,16121,"`"],[1,16122,"\n"],[1,16234,"`"],[1,16239,"弗"],[-1,16243,"）"],[-1,16249,"s"],[1,16250,"）"],[1,16252,"\n\n\n\n\n\n"]],[4388,4388],[16258,16258]]],[1559380223209,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•"],[-1,15841,"图"],[1,15861,"\n–网"],[-1,15863,"网图是"],[1,15885,"\n–非"],[-1,15887,"非网图"],[1,15907,"飞往图"],[1,15927,"-"],[-1,15927,"\n\n"],[1,15937,"）"],[-1,15945,"）"],[1,15948,"- "],[-1,15948,"\n"],[1,16121,"`"],[-1,16121,"\n"],[-1,16234,"`"],[-1,16240,"弗"],[1,16245,"）"],[1,16250,"s"],[-1,16250,"）"],[-1,16253,"\n\n\n\n\n\n"]],[16258,16258],[4388,4388]]],[1559380189940,["GJX@GJXAIOU",[[1,16232,"\n"]],[16231,16231],[16232,16232]]],[1559380190480,["GJX@GJXAIOU",[[1,16232,"/*  Dijkstra算法，求有向网G的v0顶点到其余顶点v的最短路径P[v]及带权长度D[v] */    \n/*  P[v]的值为前驱顶点下标,D[v]表示v0到v的最短路径长度和 */  \nvoid ShortestPath_Dijkstra(MGraph G, int v0, Patharc *P, ShortPathTable *D)\n{    \n\tint v,w,k,min;    \n\tint final[MAXVEX];/* final[w]=1表示求得顶点v0至vw的最短路径 */\n\tfor(v=0; v<G.numVertexes; v++)    /* 初始化数据 */\n\t{        \n\t\tfinal[v] = 0;\t\t\t/* 全部顶点初始化为未知最短路径状态 */\n\t\t(*D)[v] = G.arc[v0][v];/* 将与v0点有连线的顶点加上权值 */\n\t\t(*P)[v] = -1;\t\t\t\t/* 初始化路径数组P为-1  */       \n\t}\n\n\t(*D)[v0] = 0;  /* v0至v0路径为0 */  \n\tfinal[v0] = 1;    /* v0至v0不需要求路径 */        \n\t/* 开始主循环，每次求得v0到某个v顶点的最短路径 */   \n\tfor(v=1; v<G.numVertexes; v++)   \n\t{\n\t\tmin=INFINITY;    /* 当前所知离v0顶点的最近距离 */        \n\t\tfor(w=0; w<G.numVertexes; w++) /* 寻找离v0最近的顶点 */    \n\t\t{            \n\t\t\tif(!final[w] && (*D)[w]<min)             \n\t\t\t{                   \n\t\t\t\tk=w;                    \n\t\t\t\tmin = (*D)[w];    /* w顶点离v0顶点更近 */            \n\t\t\t}        \n\t\t}        \n\t\tfinal[k] = 1;    /* 将目前找到的最近的顶点置为1 */\n\t\tfor(w=0; w<G.numVertexes; w++) /* 修正当前最短路径及距离 */\n\t\t{\n\t\t\t/* 如果经过v顶点的路径比现在这条路径的长度短的话 */\n\t\t\tif(!final[w] && (min+G.arc[k][w]<(*D)[w]))   \n\t\t\t{ /*  说明找到了更短的路径，修改D[w]和P[w] */\n\t\t\t\t(*D)[w] = min + G.arc[k][w];  /* 修改当前路径长度 */               \n\t\t\t\t(*P)[w]=k;        \n\t\t\t}       \n\t\t}   \n\t}\n}"]],[16232,16232],[17445,17445]]],[1559380205741,["GJX@GJXAIOU",[[1,17450,"===="]],[17450,17450],[17452,17452]]],[1559380207981,["GJX@GJXAIOU",[[1,17452,"saun"]],[17452,17452],[17456,17456]]],[1559380209884,["GJX@GJXAIOU",[[-1,17452,"saun"]],[17456,17456],[17452,17452]]],[1559380216755,["GJX@GJXAIOU",[[1,17452,"算法时间复杂度：P"]],[17452,17452],[17461,17461]]],[1559380217174,["GJX@GJXAIOU",[[-1,17460,"P"]],[17461,17461],[17460,17460]]],[1559380218839,["GJX@GJXAIOU",[[1,17460,"O()"]],[17460,17460],[17463,17463]]],[1559380222915,["GJX@GJXAIOU",[[1,17462,"n^2"]],[17462,17462],[17465,17465]]],[1559380283198,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•"],[1,15839,"图"],[-1,15858,"\n–网"],[1,15863,"网图是"],[-1,15882,"\n–非"],[1,15887,"非网图"],[-1,15904,"飞往图"],[-1,15927,"-"],[1,15928,"\n\n"],[-1,15936,"）"],[1,15945,"）"],[-1,15947,"- "],[1,15949,"\n"],[-1,16121,"`"],[1,16122,"\n"],[-1,17448,"\n"],[1,17449,"`"],[1,17469,"\n"],[1,17471,"弗"],[-1,17475,"）"],[-1,17481,"s"],[1,17482,"）"],[1,17484,"\n\n\n\n\n\n"]],[4388,4388],[17490,17490]]],[1559380283198,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•"],[-1,15841,"图"],[1,15861,"\n–网"],[-1,15863,"网图是"],[1,15885,"\n–非"],[-1,15887,"非网图"],[1,15907,"飞往图"],[1,15927,"-"],[-1,15927,"\n\n"],[1,15937,"）"],[-1,15945,"）"],[1,15948,"- "],[-1,15948,"\n"],[1,16121,"`"],[-1,16121,"\n"],[1,17448,"\n"],[-1,17448,"`"],[-1,17469,"\n"],[-1,17472,"弗"],[1,17477,"）"],[1,17482,"s"],[-1,17482,"）"],[-1,17485,"\n\n\n\n\n\n"]],[17490,17490],[4388,4388]]],[1559380231034,["GJX@GJXAIOU",[[1,17460,"$"]],[17460,17460],[17461,17461]]],[1559380233668,["GJX@GJXAIOU",[[1,17467,"$"]],[17467,17467],[17468,17468]]],[1559380244494,["GJX@GJXAIOU",[[-1,17450,"=="]],[17452,17452],[17450,17450]]],[1559380247174,["GJX@GJXAIOU",[[-1,17465,"$=="]],[17466,17468],[17465,17465]]],[1559380249685,["GJX@GJXAIOU",[[-1,17458,"$"]],[17459,17459],[17458,17458]]],[1559380463197,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•"],[1,15839,"图"],[-1,15858,"\n–网"],[1,15863,"网图是"],[-1,15882,"\n–非"],[1,15887,"非网图"],[-1,15904,"飞往图"],[-1,15927,"-"],[1,15928,"\n\n"],[-1,15936,"）"],[1,15945,"）"],[-1,15947,"- "],[1,15949,"\n"],[-1,16121,"`"],[1,16122,"\n"],[-1,17448,"\n"],[1,17449,"`"],[1,17465,"\n"],[1,17467,"弗"],[-1,17471,"）"],[-1,17477,"s"],[1,17478,"）"],[1,17480,"\n\n\n\n\n\n"]],[4388,4388],[17486,17486]]],[1559380463197,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•"],[-1,15841,"图"],[1,15861,"\n–网"],[-1,15863,"网图是"],[1,15885,"\n–非"],[-1,15887,"非网图"],[1,15907,"飞往图"],[1,15927,"-"],[-1,15927,"\n\n"],[1,15937,"）"],[-1,15945,"）"],[1,15948,"- "],[-1,15948,"\n"],[1,16121,"`"],[-1,16121,"\n"],[1,17448,"\n"],[-1,17448,"`"],[-1,17465,"\n"],[-1,17468,"弗"],[1,17473,"）"],[1,17478,"s"],[-1,17478,"）"],[-1,17481,"\n\n\n\n\n\n"]],[17486,17486],[4388,4388]]],[1559380433133,["GJX@GJXAIOU",[[1,17458,"￥￥"]],[17458,17458],[17460,17460]]],[1559380434576,["GJX@GJXAIOU",[[-1,17458,"￥￥"]],[17460,17460],[17458,17458]]],[1559380440723,["GJX@GJXAIOU",[[1,17458,"$$ "]],[17458,17458],[17461,17461]]],[1559380445184,["GJX@GJXAIOU",[[-1,17450,"算法时间复杂度："]],[17450,17458],[17450,17450]]],[1559380448719,["GJX@GJXAIOU",[[1,17450,"\n"]],[17449,17449],[17450,17450]]],[1559380452550,["GJX@GJXAIOU",[[-1,17452,"$ "]],[17451,17454],[17452,17452]]],[1559380452849,["GJX@GJXAIOU",[[1,17452,"$\n\n$$\n"]],[17452,17452],[17454,17454]]],[1559380457697,["GJX@GJXAIOU",[[-1,17458,"O(n^2)"]],[17458,17464],[17458,17458]]],[1559380459271,["GJX@GJXAIOU",[[1,17454,"O(n^2)"]],[17454,17454],[17460,17460]]],[1559380583202,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•"],[1,15839,"图"],[-1,15858,"\n–网"],[1,15863,"网图是"],[-1,15882,"\n–非"],[1,15887,"非网图"],[-1,15904,"飞往图"],[-1,15927,"-"],[1,15928,"\n\n"],[-1,15936,"）"],[1,15945,"）"],[-1,15947,"- "],[1,15949,"\n"],[-1,16121,"`"],[1,16122,"\n"],[-1,17448,"\n"],[1,17449,"`"],[1,17465,"\n"],[1,17467,"弗"],[-1,17471,"）"],[-1,17477,"s"],[1,17478,"）"],[1,17480,"\n\n\n\n\n\n"]],[4388,4388],[17486,17486]]],[1559380583202,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•"],[-1,15841,"图"],[1,15861,"\n–网"],[-1,15863,"网图是"],[1,15885,"\n–非"],[-1,15887,"非网图"],[1,15907,"飞往图"],[1,15927,"-"],[-1,15927,"\n\n"],[1,15937,"）"],[-1,15945,"）"],[1,15948,"- "],[-1,15948,"\n"],[1,16121,"`"],[-1,16121,"\n"],[1,17448,"\n"],[-1,17448,"`"],[-1,17465,"\n"],[-1,17468,"弗"],[1,17473,"）"],[1,17478,"s"],[-1,17478,"）"],[-1,17481,"\n\n\n\n\n\n"]],[17486,17486],[4388,4388]]],[1559380550009,["GJX@GJXAIOU",[[-1,17451,"$$\n"],[-1,17460,"\n$$\n"]],[17451,17464],[17457,17457]]],[1559380564672,["GJX@GJXAIOU",[[-1,17451,"O(n^2)\n"],[1,17458,"算法"]],[17451,17451],[17453,17453]]],[1559380573398,["GJX@GJXAIOU",[[1,17453,"的时间复杂度：O()"]],[17453,17453],[17463,17463]]],[1559380576243,["GJX@GJXAIOU",[[1,17462,"n^2"]],[17462,17462],[17465,17465]]],[1559380578668,["GJX@GJXAIOU",[[1,17466,";"]],[17466,17466],[17467,17467]]],[1559380579003,["GJX@GJXAIOU",[[1,17468,"\n"]],[17467,17467],[17468,17468]]],[1559380579159,["GJX@GJXAIOU",[[1,17469,"\n"]],[17468,17468],[17469,17469]]],[1559386086250,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•"],[1,15839,"图"],[-1,15858,"\n–网"],[1,15863,"网图是"],[-1,15882,"\n–非"],[1,15887,"非网图"],[-1,15904,"飞往图"],[-1,15927,"-"],[1,15928,"\n\n"],[-1,15936,"）"],[1,15945,"）"],[-1,15947,"- "],[1,15949,"\n"],[-1,16121,"`"],[1,16122,"\n"],[-1,17448,"\n"],[1,17449,"`"],[-1,17467,"-"],[1,17468,"\n"],[1,17470,"-"],[1,17471,"弗"],[-1,17475,"）"],[-1,17481,"s"],[1,17482,"）"],[1,17484,"\n\n\n\n\n\n"]],[4388,4388],[17490,17490]]],[1559386086250,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•"],[-1,15841,"图"],[1,15861,"\n–网"],[-1,15863,"网图是"],[1,15885,"\n–非"],[-1,15887,"非网图"],[1,15907,"飞往图"],[1,15927,"-"],[-1,15927,"\n\n"],[1,15937,"）"],[-1,15945,"）"],[1,15948,"- "],[-1,15948,"\n"],[1,16121,"`"],[-1,16121,"\n"],[1,17448,"\n"],[-1,17448,"`"],[1,17467,"-"],[-1,17467,"\n"],[-1,17470,"-"],[-1,17472,"弗"],[1,17477,"）"],[1,17482,"s"],[-1,17482,"）"],[-1,17485,"\n\n\n\n\n\n"]],[17490,17490],[4388,4388]]],[1559386073032,["GJX@GJXAIOU",[[1,15949,"- \n"]],[15948,15948],[15951,15951]]],[1559386074802,["GJX@GJXAIOU",[[-1,15949,"- "]],[15951,15951],[15949,15949]]],[1559386076328,["GJX@GJXAIOU",[[1,15950,"\n"]],[15949,15949],[15950,15950]]],[1559386077778,["GJX@GJXAIOU",[[1,15950,"===="]],[15950,15950],[15952,15952]]],[1559386079528,["GJX@GJXAIOU",[[1,15952,"jiejiu"]],[15952,15952],[15958,15958]]],[1559386080508,["GJX@GJXAIOU",[[-1,15952,"jiejiu"]],[15958,15958],[15952,15952]]],[1559386085369,["GJX@GJXAIOU",[[1,15952,"解决了某公益"]],[15952,15952],[15958,15958]]],[1559386146245,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•"],[1,15839,"图"],[-1,15858,"\n–网"],[1,15863,"网图是"],[-1,15882,"\n–非"],[1,15887,"非网图"],[-1,15904,"飞往图"],[-1,15927,"-"],[1,15928,"\n\n"],[-1,15936,"）"],[1,15945,"）"],[-1,15947,"- "],[1,15949,"\n"],[-1,16133,"`"],[1,16134,"\n"],[-1,17460,"\n"],[1,17461,"`"],[-1,17479,"-"],[1,17480,"\n"],[1,17482,"-"],[1,17483,"弗"],[-1,17487,"）"],[-1,17493,"s"],[1,17494,"）"],[1,17496,"\n\n\n\n\n\n"]],[4388,4388],[17502,17502]]],[1559386146245,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•"],[-1,15841,"图"],[1,15861,"\n–网"],[-1,15863,"网图是"],[1,15885,"\n–非"],[-1,15887,"非网图"],[1,15907,"飞往图"],[1,15927,"-"],[-1,15927,"\n\n"],[1,15937,"）"],[-1,15945,"）"],[1,15948,"- "],[-1,15948,"\n"],[1,16133,"`"],[-1,16133,"\n"],[1,17460,"\n"],[-1,17460,"`"],[1,17479,"-"],[-1,17479,"\n"],[-1,17482,"-"],[-1,17484,"弗"],[1,17489,"）"],[1,17494,"s"],[-1,17494,"）"],[-1,17497,"\n\n\n\n\n\n"]],[17502,17502],[4388,4388]]],[1559386087273,["GJX@GJXAIOU",[[-1,15955,"某公益"]],[15958,15958],[15955,15955]]],[1559386107827,["GJX@GJXAIOU",[[1,15955,"某个源点到其余各顶点的最短路径"]],[15955,15955],[15970,15970]]],[1559386136626,["GJX@GJXAIOU",[[1,15105,"这里的"]],[15105,15105],[15108,15108]]],[1559386141266,["GJX@GJXAIOU",[[-1,15105,"这里的"]],[15108,15108],[15105,15105]]],[1559386206355,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•"],[1,15839,"图"],[-1,15858,"\n–网"],[1,15863,"网图是"],[-1,15882,"\n–非"],[1,15887,"非网图"],[-1,15904,"飞往图"],[-1,15927,"-"],[1,15928,"\n\n"],[-1,15936,"）"],[1,15945,"）"],[-1,15947,"- "],[1,15949,"\n"],[-1,16145,"`"],[1,16146,"\n"],[-1,17472,"\n"],[1,17473,"`"],[-1,17491,"-"],[1,17492,"\n"],[1,17494,"-"],[1,17495,"弗"],[-1,17499,"）"],[-1,17505,"s"],[1,17506,"）"],[1,17508,"\n\n\n\n\n\n"]],[4388,4388],[17514,17514]]],[1559386206355,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•"],[-1,15841,"图"],[1,15861,"\n–网"],[-1,15863,"网图是"],[1,15885,"\n–非"],[-1,15887,"非网图"],[1,15907,"飞往图"],[1,15927,"-"],[-1,15927,"\n\n"],[1,15937,"）"],[-1,15945,"）"],[1,15948,"- "],[-1,15948,"\n"],[1,16145,"`"],[-1,16145,"\n"],[1,17472,"\n"],[-1,17472,"`"],[1,17491,"-"],[-1,17491,"\n"],[-1,17494,"-"],[-1,17496,"弗"],[1,17501,"）"],[1,17506,"s"],[-1,17506,"）"],[-1,17509,"\n\n\n\n\n\n"]],[17514,17514],[4388,4388]]],[1559386191045,["GJX@GJXAIOU",[[1,15949,"这里的迪杰斯克拉算法仅仅适用于无孤立点的图"]],[15949,15949],[15970,15970]]],[1559386266273,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•"],[1,15839,"图"],[-1,15858,"\n–网"],[1,15863,"网图是"],[-1,15882,"\n–非"],[1,15887,"非网图"],[-1,15904,"飞往图"],[-1,15927,"-"],[1,15928,"\n\n"],[-1,15936,"）"],[1,15945,"）"],[-1,15947,"- "],[1,15949,"\n"],[-1,16166,"`"],[1,16167,"\n"],[-1,17493,"\n"],[1,17494,"`"],[-1,17512,"-"],[1,17513,"\n"],[1,17515,"-"],[1,17516,"弗"],[-1,17520,"）"],[-1,17526,"s"],[1,17527,"）"],[1,17529,"\n\n\n\n\n\n"]],[4388,4388],[17535,17535]]],[1559386266273,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•"],[-1,15841,"图"],[1,15861,"\n–网"],[-1,15863,"网图是"],[1,15885,"\n–非"],[-1,15887,"非网图"],[1,15907,"飞往图"],[1,15927,"-"],[-1,15927,"\n\n"],[1,15937,"）"],[-1,15945,"）"],[1,15948,"- "],[-1,15948,"\n"],[1,16166,"`"],[-1,16166,"\n"],[1,17493,"\n"],[-1,17493,"`"],[1,17512,"-"],[-1,17512,"\n"],[-1,17515,"-"],[-1,17517,"弗"],[1,17522,"）"],[1,17527,"s"],[-1,17527,"）"],[-1,17530,"\n\n\n\n\n\n"]],[17535,17535],[4388,4388]]],[1559386249128,["GJX@GJXAIOU",[[1,17513,"则所有"]],[17513,17513],[17516,17516]]],[1559386249773,["GJX@GJXAIOU",[[-1,17514,"所有"]],[17516,17516],[17514,17514]]],[1559386259978,["GJX@GJXAIOU",[[1,17514,"求得所有顶点（）"]],[17514,17514],[17522,17522]]],[1559386326275,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•"],[1,15839,"图"],[-1,15858,"\n–网"],[1,15863,"网图是"],[-1,15882,"\n–非"],[1,15887,"非网图"],[-1,15904,"飞往图"],[-1,15927,"-"],[1,15928,"\n\n"],[-1,15936,"）"],[1,15945,"）"],[-1,15947,"- "],[1,15949,"\n"],[-1,16166,"`"],[1,16167,"\n"],[-1,17493,"\n"],[1,17494,"`"],[-1,17512,"-"],[1,17513,"\n"],[1,17524,"-"],[1,17525,"弗"],[-1,17529,"）"],[-1,17535,"s"],[1,17536,"）"],[1,17538,"\n\n\n\n\n\n"]],[4388,4388],[17544,17544]]],[1559386326275,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•"],[-1,15841,"图"],[1,15861,"\n–网"],[-1,15863,"网图是"],[1,15885,"\n–非"],[-1,15887,"非网图"],[1,15907,"飞往图"],[1,15927,"-"],[-1,15927,"\n\n"],[1,15937,"）"],[-1,15945,"）"],[1,15948,"- "],[-1,15948,"\n"],[1,16166,"`"],[-1,16166,"\n"],[1,17493,"\n"],[-1,17493,"`"],[1,17512,"-"],[-1,17512,"\n"],[-1,17524,"-"],[-1,17526,"弗"],[1,17531,"）"],[1,17536,"s"],[-1,17536,"）"],[-1,17539,"\n\n\n\n\n\n"]],[17544,17544],[4388,4388]]],[1559386268017,["GJX@GJXAIOU",[[1,17521,"任一顶点"]],[17521,17521],[17525,17525]]],[1559386296342,["GJX@GJXAIOU",[[1,17526,"到其他任意顶点的最短距离时间复杂度为O()"]],[17526,17526],[17547,17547]]],[1559386299921,["GJX@GJXAIOU",[[1,17546,"n^3"]],[17546,17546],[17549,17549]]],[1559388126476,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•"],[1,15839,"图"],[-1,15858,"\n–网"],[1,15863,"网图是"],[-1,15882,"\n–非"],[1,15887,"非网图"],[-1,15904,"飞往图"],[-1,15927,"-"],[1,15928,"\n\n"],[-1,15936,"）"],[1,15945,"）"],[-1,15947,"- "],[1,15949,"\n"],[-1,16166,"`"],[1,16167,"\n"],[-1,17493,"\n"],[1,17494,"`"],[-1,17512,"-"],[1,17513,"\n"],[1,17552,"-"],[1,17553,"弗"],[-1,17557,"）"],[-1,17563,"s"],[1,17564,"）"],[1,17566,"\n\n\n\n\n\n"]],[4388,4388],[17572,17572]]],[1559388126476,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•"],[-1,15841,"图"],[1,15861,"\n–网"],[-1,15863,"网图是"],[1,15885,"\n–非"],[-1,15887,"非网图"],[1,15907,"飞往图"],[1,15927,"-"],[-1,15927,"\n\n"],[1,15937,"）"],[-1,15945,"）"],[1,15948,"- "],[-1,15948,"\n"],[1,16166,"`"],[-1,16166,"\n"],[1,17493,"\n"],[-1,17493,"`"],[1,17512,"-"],[-1,17512,"\n"],[-1,17552,"-"],[-1,17554,"弗"],[1,17559,"）"],[1,17564,"s"],[-1,17564,"）"],[-1,17567,"\n\n\n\n\n\n"]],[17572,17572],[4388,4388]]],[1559388074136,["GJX@GJXAIOU",[[1,15839,"\n"]],[15838,15838],[15839,15839]]],[1559388074363,["GJX@GJXAIOU",[[1,15840,"\n"]],[15839,15839],[15840,15840]]],[1559388077209,["GJX@GJXAIOU",[[1,15839,"===="]],[15839,15839],[15841,15841]]],[1559388093753,["GJX@GJXAIOU",[[1,15841,"dijie"]],[15841,15841],[15846,15846]]],[1559388096344,["GJX@GJXAIOU",[[-1,15841,"dijie"]],[15846,15846],[15841,15841]]],[1559388117014,["GJX@GJXAIOU",[[1,15841,"迪杰斯克拉算法求的是一个顶点到所有顶点的最短路径；"]],[15841,15841],[15866,15866]]],[1559388186347,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15870,"在网图"],[-1,15889,"\n–网"],[1,15894,"网图是"],[-1,15913,"\n–非"],[1,15918,"非网图"],[-1,15935,"飞往图"],[-1,15958,"-"],[1,15959,"\n\n"],[-1,15967,"）"],[1,15976,"）"],[-1,15978,"- "],[1,15980,"\n"],[-1,16197,"`"],[1,16198,"\n"],[-1,17524,"\n"],[1,17525,"`"],[-1,17543,"-"],[1,17544,"\n"],[1,17583,"-"],[1,17584,"弗"],[-1,17588,"）"],[-1,17594,"s"],[1,17595,"）"],[1,17597,"\n\n\n\n\n\n"]],[4388,4388],[17603,17603]]],[1559388186347,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15870,"在网图"],[1,15892,"\n–网"],[-1,15894,"网图是"],[1,15916,"\n–非"],[-1,15918,"非网图"],[1,15938,"飞往图"],[1,15958,"-"],[-1,15958,"\n\n"],[1,15968,"）"],[-1,15976,"）"],[1,15979,"- "],[-1,15979,"\n"],[1,16197,"`"],[-1,16197,"\n"],[1,17524,"\n"],[-1,17524,"`"],[1,17543,"-"],[-1,17543,"\n"],[-1,17583,"-"],[-1,17585,"弗"],[1,17590,"）"],[1,17595,"s"],[-1,17595,"）"],[-1,17598,"\n\n\n\n\n\n"]],[17603,17603],[4388,4388]]],[1559388151136,["GJX@GJXAIOU",[[1,15870,"\n"]],[15868,15868],[15869,15869]]],[1559388151716,["GJX@GJXAIOU",[[1,15869,"--"]],[15869,15869],[15871,15871]]],[1559388160633,["GJX@GJXAIOU",[[1,15869,"\n"]],[15868,15868],[15869,15869]]],[1559388161277,["GJX@GJXAIOU",[[-1,15869,"\n"]],[15869,15869],[15868,15868]]],[1559388161432,["GJX@GJXAIOU",[[-1,15867,"="]],[15868,15868],[15867,15867]]],[1559388164469,["GJX@GJXAIOU",[[1,15867,"="]],[15867,15867],[15868,15868]]],[1559388167831,["GJX@GJXAIOU",[[-1,15869,"--"],[1,15871,"="]],[15869,15869],[15870,15870]]],[1559388173376,["GJX@GJXAIOU",[[1,15870,"= ===="]],[15870,15870],[15874,15874]]],[1559388174945,["GJX@GJXAIOU",[[-1,15874,"=="]],[15874,15874],[15872,15872]]],[1559388185329,["GJX@GJXAIOU",[[1,15872,"弗洛伊德"]],[15872,15872],[15876,15876]]],[1559388246355,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15880,"在网图"],[-1,15899,"\n–网"],[1,15904,"网图是"],[-1,15923,"\n–非"],[1,15928,"非网图"],[-1,15945,"飞往图"],[-1,15968,"-"],[1,15969,"\n\n"],[-1,15977,"）"],[1,15986,"）"],[-1,15988,"- "],[1,15990,"\n"],[-1,16207,"`"],[1,16208,"\n"],[-1,17534,"\n"],[1,17535,"`"],[-1,17553,"-"],[1,17554,"\n"],[1,17593,"-"],[1,17594,"弗"],[-1,17598,"）"],[-1,17604,"s"],[1,17605,"）"],[1,17607,"\n\n\n\n\n\n"]],[4388,4388],[17613,17613]]],[1559388246355,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15880,"在网图"],[1,15902,"\n–网"],[-1,15904,"网图是"],[1,15926,"\n–非"],[-1,15928,"非网图"],[1,15948,"飞往图"],[1,15968,"-"],[-1,15968,"\n\n"],[1,15978,"）"],[-1,15986,"）"],[1,15989,"- "],[-1,15989,"\n"],[1,16207,"`"],[-1,16207,"\n"],[1,17534,"\n"],[-1,17534,"`"],[1,17553,"-"],[-1,17553,"\n"],[-1,17593,"-"],[-1,17595,"弗"],[1,17600,"）"],[1,17605,"s"],[-1,17605,"）"],[-1,17608,"\n\n\n\n\n\n"]],[17613,17613],[4388,4388]]],[1559388189028,["GJX@GJXAIOU",[[1,15876,"算法"]],[15876,15876],[15878,15878]]],[1559388191805,["GJX@GJXAIOU",[[-1,15871," "]],[15872,15872],[15871,15871]]],[1559388226172,["GJX@GJXAIOU",[[1,15877,"求的是所有顶点到所有顶点的最短路径；"]],[15877,15877],[15895,15895]]],[1559388241704,["GJX@GJXAIOU",[[1,15991,"**"],[1,16008,"**"]],[15991,16008],[15991,16012]]],[1559388366372,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[1,17617,"弗"],[-1,17621,"）"],[-1,17627,"s"],[1,17628,"）"],[1,17630,"\n\n\n\n\n\n"]],[4388,4388],[17636,17636]]],[1559388366372,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[-1,17618,"弗"],[1,17623,"）"],[1,17628,"s"],[-1,17628,"）"],[-1,17631,"\n\n\n\n\n\n"]],[17636,17636],[4388,4388]]],[1559388315003,["GJX@GJXAIOU",[[1,17618,"**"],[1,17631,"**"]],[17618,17631],[17618,17635]]],[1559389926686,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[1,17634,"\n\n\n\n\n\n"]],[4388,4388],[17640,17640]]],[1559389926686,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[-1,17635,"\n\n\n\n\n\n"]],[17640,17640],[4388,4388]]],[1559389897935,["GJX@GJXAIOU",[[1,17637,"![弗洛伊德示例]($resource/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%A4%BA%E4%BE%8B.png)"]],[17637,17637],[17717,17717]]],[1559390166754,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[1,17634,"\n\n"],[1,17713,"\n\n\n\n"]],[4388,4388],[17717,17717]]],[1559390166754,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[-1,17635,"\n\n"],[-1,17716,"\n\n\n\n"]],[17717,17717],[4388,4388]]],[1559390132205,["GJX@GJXAIOU",[[1,17637,"\n"]],[17636,17636],[17637,17637]]],[1559390132465,["GJX@GJXAIOU",[[1,17638,"\n"]],[17637,17637],[17638,17638]]],[1559390141444,["GJX@GJXAIOU",[[1,17637,"![弗洛伊德算法]($resource/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95.jpg)"]],[17637,17637],[17717,17717]]],[1559390146715,["GJX@GJXAIOU",[[1,17718,"\n"]],[17717,17717],[17718,17718]]],[1559390406632,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[-1,17634,"![弗"],[1,17637,"\n\n"],[1,17719,"![弗"],[1,17795,"\n\n\n\n"]],[4388,4388],[17799,17799]]],[1559390406632,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[1,17635,"![弗"],[-1,17635,"\n\n"],[-1,17719,"![弗"],[-1,17798,"\n\n\n\n"]],[17799,17799],[4388,4388]]],[1559390395630,["GJX@GJXAIOU",[[1,17718,"![3]($resource/3.png)"]],[17718,17718],[17740,17740]]],[1559390403241,["GJX@GJXAIOU",[[1,17740,"\n"]],[17739,17739],[17740,17740]]],[1559390405841,["GJX@GJXAIOU",[[1,17824,"\n"]],[17821,17821],[17822,17822]]],[1559390466606,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[-1,17634,"![弗"],[1,17637,"\n\n"],[1,17741,"![弗"],[1,17818,"\n\n\n\n"]],[4388,4388],[17822,17822]]],[1559390466607,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[1,17635,"![弗"],[-1,17635,"\n\n"],[-1,17741,"![弗"],[-1,17821,"\n\n\n\n"]],[17822,17822],[4388,4388]]],[1559390419165,["GJX@GJXAIOU",[[1,17822,"程序代码如下："]],[17822,17822],[17829,17829]]],[1559390420136,["GJX@GJXAIOU",[[1,17832,"\n"]],[17829,17829],[17830,17830]]],[1559390421792,["GJX@GJXAIOU",[[1,17830,"```"]],[17830,17830],[17833,17833]]],[1559390421973,["GJX@GJXAIOU",[[1,17833,"language\n```\n"]],[17833,17833],[17833,17841]]],[1559390423038,["GJX@GJXAIOU",[[-1,17833,"language"],[1,17841,"c"]],[17833,17841],[17834,17834]]],[1559390423256,["GJX@GJXAIOU",[[1,17835,"\n"]],[17834,17834],[17835,17835]]],[1559390454973,["GJX@GJXAIOU",[[1,17835,"#define MAXVEX\t9\n#define INFINITY\t65535\n\ntypedef int Pathmatirx[MAXVEX][MAXVEX];\ntypedef int ShortPathTable[MAXVEX][MAXVEX];\n\nvoid ShortestPath_Floyd(MGraph G, Pathmatirx *P, ShortPathTable *D)\n{\n\tint v, w, k;\n\t\n\t// 鍒濆鍖朌鍜孭\n\tfor( v=0; v < G.numVertexes; v++ )\n\t{\n\t\tfor( w=0; w < G.numVertexes; w++ )\n\t\t{\n\t\t\t(*D)[v][w] = G.matirx[v][w];\n\t\t\t(*P)[v][w] = w;\n\t\t}\n\t}\n\t\n\t// 浼樼編鐨勫紬娲涗紛寰风畻娉?\n\tfor( k=0; k < G.numVertexes; k++ )\n\t{\n\t\tfor( v=0; v < G.numVertexes; v++ )\n\t\t{\n\t\t\tfor( w=0; w < G.numVertexes; w++ )\n\t\t\t{\n\t\t\t\tif( (*D)[v][w] > (*D)[v][k] + (*D)[k][w] )\n\t\t\t\t{\n\t\t\t\t\t(*D)[v][w] = (*D)[v][k] + (*D)[k][w];\n\t\t\t\t\t(*P)[v][w] = (*P)[v][k];\t\t// 璇锋€濊€冿細杩欓噷鎹㈡垚(*P)[k][w]鍙互鍚楋紵涓轰粈涔堬紵\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"]],[17835,17835],[18526,18526]]],[1559390526607,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[-1,17634,"![弗"],[1,17637,"\n\n"],[1,17741,"![弗"],[1,17818,"\n"],[-1,17829,"lang"],[-1,18526,""],[1,18526,"\n```\n\n\n"]],[4388,4388],[18533,18533]]],[1559390526607,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[1,17635,"![弗"],[-1,17635,"\n\n"],[-1,17741,"![弗"],[-1,17821,"\n"],[1,17833,"lang"],[1,18526,""],[-1,18526,"\n```\n\n\n"]],[18533,18533],[4388,4388]]],[1559390468781,["GJX@GJXAIOU",[[-1,18051,"chu"]],[18054,18054],[18051,18051]]],[1559390476711,["GJX@GJXAIOU",[[1,18051,"初始化D与P"]],[18051,18051],[18057,18057]]],[1559390502080,["GJX@GJXAIOU",[[-1,18199,"// 浼樼編鐨勫紬娲涗紛寰风畻娉?"]],[18199,18216],[18199,18199]]],[1559390586628,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[-1,17634,"![弗"],[1,17637,"\n\n"],[1,17741,"![弗"],[1,17818,"\n"],[-1,17829,"lang"],[-1,18057,"鍖朌鍜孭"],[1,18061,""],[-1,18199,"风畻娉?"],[1,18203,"\n\t\n\t"],[-1,18512,""],[1,18512,"\n```\n\n\n"]],[4388,4388],[18519,18519]]],[1559390586628,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[1,17635,"![弗"],[-1,17635,"\n\n"],[-1,17741,"![弗"],[-1,17821,"\n"],[1,17833,"lang"],[1,18057,"鍖朌鍜孭"],[-1,18057,""],[1,18195,"风畻娉?"],[-1,18195,"\n\t\n\t"],[1,18508,""],[-1,18508,"\n```\n\n\n"]],[18519,18519],[4388,4388]]],[1559390536331,["GJX@GJXAIOU",[[1,18169," 、、"]],[18169,18169],[18172,18172]]],[1559390537389,["GJX@GJXAIOU",[[-1,18170,"、、"]],[18172,18172],[18170,18170]]],[1559390545391,["GJX@GJXAIOU",[[1,18170,"//D[]"]],[18170,18170],[18175,18175]]],[1559390548309,["GJX@GJXAIOU",[[1,18174,"V"]],[18174,18174],[18175,18175]]],[1559390550157,["GJX@GJXAIOU",[[1,18176,"[]"]],[18176,18176],[18178,18178]]],[1559390551811,["GJX@GJXAIOU",[[1,18177,"W"]],[18177,18177],[18178,18178]]],[1559390554281,["GJX@GJXAIOU",[[1,18179,"z"]],[18179,18179],[18180,18180]]],[1559390554775,["GJX@GJXAIOU",[[-1,18179,"z"]],[18180,18180],[18179,18179]]],[1559390576318,["GJX@GJXAIOU",[[1,18179,"值即为对应点间的权值"]],[18179,18179],[18189,18189]]],[1559390584477,["GJX@GJXAIOU",[[1,18208," //初始化P"]],[18208,18208],[18215,18215]]],[1559390646615,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[-1,17634,"![弗"],[1,17637,"\n\n"],[1,17741,"![弗"],[1,17818,"\n"],[-1,17829,"lang"],[-1,18057,"鍖朌鍜孭"],[1,18061,""],[1,18169,"[w];"],[-1,18189,"[w];"],[1,18208,"= w;"],[-1,18215,"= w;"],[-1,18226,"风畻娉?"],[1,18230,"\n\t\n\t"],[-1,18539,""],[1,18539,"\n```\n\n\n"]],[4388,4388],[18546,18546]]],[1559390646615,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[1,17635,"![弗"],[-1,17635,"\n\n"],[-1,17741,"![弗"],[-1,17821,"\n"],[1,17833,"lang"],[1,18057,"鍖朌鍜孭"],[-1,18057,""],[-1,18165,"[w];"],[1,18189,"[w];"],[-1,18204,"= w;"],[1,18215,"= w;"],[1,18222,"风畻娉?"],[-1,18222,"\n\t\n\t"],[1,18535,""],[-1,18535,"\n```\n\n\n"]],[18546,18546],[4388,4388]]],[1559390609095,["GJX@GJXAIOU",[[-1,18477,"// 璇锋€濊€冿細杩欓噷鎹㈡垚(*P)[k][w]鍙互鍚楋紵涓轰粈涔堬紵"]],[18477,18515],[18477,18477]]],[1559390611932,["GJX@GJXAIOU",[[1,18407,"\n\t\t\t\t"]],[18402,18402],[18407,18407]]],[1559390643756,["GJX@GJXAIOU",[[1,18407,"//如果经过下标为K顶点路径比原两点"]],[18407,18407],[18425,18425]]],[1559390706642,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[-1,17634,"![弗"],[1,17637,"\n\n"],[1,17741,"![弗"],[1,17818,"\n"],[-1,17829,"lang"],[-1,18057,"鍖朌鍜孭"],[1,18061,""],[1,18169,"[w];"],[-1,18189,"[w];"],[1,18208,"= w;"],[-1,18215,"= w;"],[-1,18226,"风畻娉?"],[1,18230,"\n\t\n\t"],[1,18407,"\t\t\t\t"],[-1,18426,"\t\t\t\t"],[-1,18500,"粈涔堬紵"],[1,18504,"];\t\t"],[-1,18524,""],[1,18524,"\n```\n\n\n"]],[4388,4388],[18531,18531]]],[1559390706642,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[1,17635,"![弗"],[-1,17635,"\n\n"],[-1,17741,"![弗"],[-1,17821,"\n"],[1,17833,"lang"],[1,18057,"鍖朌鍜孭"],[-1,18057,""],[-1,18165,"[w];"],[1,18189,"[w];"],[-1,18204,"= w;"],[1,18215,"= w;"],[1,18222,"风畻娉?"],[-1,18222,"\n\t\n\t"],[-1,18403,"\t\t\t\t"],[1,18426,"\t\t\t\t"],[1,18496,"粈涔堬紵"],[-1,18496,"];\t\t"],[1,18520,""],[-1,18520,"\n```\n\n\n"]],[18531,18531],[4388,4388]]],[1559390655401,["GJX@GJXAIOU",[[1,18425,"间路径更短；"]],[18425,18425],[18431,18431]]],[1559390656309,["GJX@GJXAIOU",[[1,18436,"\n\t\t\t\t"]],[18431,18431],[18436,18436]]],[1559390658677,["GJX@GJXAIOU",[[1,18436,"// "]],[18436,18436],[18439,18439]]],[1559390659447,["GJX@GJXAIOU",[[-1,18438," "]],[18439,18439],[18438,18438]]],[1559390684793,["GJX@GJXAIOU",[[1,18438,"将当前两点间权值设为更小的一个；"]],[18438,18438],[18454,18454]]],[1559390705918,["GJX@GJXAIOU",[[1,18527," //路径设置经过下标为K的"]],[18527,18527],[18541,18541]]],[1559390766616,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[-1,17634,"![弗"],[1,17637,"\n\n"],[1,17741,"![弗"],[1,17818,"\n"],[-1,17829,"lang"],[-1,18057,"鍖朌鍜孭"],[1,18061,""],[1,18169,"[w];"],[-1,18189,"[w];"],[1,18208,"= w;"],[-1,18215,"= w;"],[-1,18226,"风畻娉?"],[1,18230,"\n\t\n\t"],[1,18407,"\t\t\t\t"],[-1,18455,"\t\t\t\t"],[1,18527,"[k];"],[-1,18541,"[k粈涔堬紵"],[1,18547,"\t\t"],[-1,18567,""],[1,18567,"\n```\n\n\n"]],[4388,4388],[18574,18574]]],[1559390766616,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[1,17635,"![弗"],[-1,17635,"\n\n"],[-1,17741,"![弗"],[-1,17821,"\n"],[1,17833,"lang"],[1,18057,"鍖朌鍜孭"],[-1,18057,""],[-1,18165,"[w];"],[1,18189,"[w];"],[-1,18204,"= w;"],[1,18215,"= w;"],[1,18222,"风畻娉?"],[-1,18222,"\n\t\n\t"],[-1,18403,"\t\t\t\t"],[1,18455,"\t\t\t\t"],[-1,18523,"[k];"],[1,18541,"[k粈涔堬紵"],[-1,18541,"\t\t"],[1,18563,""],[-1,18563,"\n```\n\n\n"]],[18574,18574],[4388,4388]]],[1559390708163,["GJX@GJXAIOU",[[1,18541,"顶点"]],[18541,18541],[18543,18543]]],[1559391186697,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[-1,17634,"![弗"],[1,17637,"\n\n"],[1,17741,"![弗"],[1,17818,"\n"],[-1,17829,"lang"],[-1,18057,"鍖朌鍜孭"],[1,18061,""],[1,18169,"[w];"],[-1,18189,"[w];"],[1,18208,"= w;"],[-1,18215,"= w;"],[-1,18226,"风畻娉?"],[1,18230,"\n\t\n\t"],[1,18407,"\t\t\t\t"],[-1,18455,"\t\t\t\t"],[1,18527,"[k];"],[-1,18543,"[k粈涔堬紵"],[1,18549,"\t\t"],[-1,18569,""],[1,18569,"\n```\n\n\n"]],[4388,4388],[18576,18576]]],[1559391186697,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[1,17635,"![弗"],[-1,17635,"\n\n"],[-1,17741,"![弗"],[-1,17821,"\n"],[1,17833,"lang"],[1,18057,"鍖朌鍜孭"],[-1,18057,""],[-1,18165,"[w];"],[1,18189,"[w];"],[-1,18204,"= w;"],[1,18215,"= w;"],[1,18222,"风畻娉?"],[-1,18222,"\n\t\n\t"],[-1,18403,"\t\t\t\t"],[1,18455,"\t\t\t\t"],[-1,18523,"[k];"],[1,18543,"[k粈涔堬紵"],[-1,18543,"\t\t"],[1,18565,""],[-1,18565,"\n```\n\n\n"]],[18576,18576],[4388,4388]]],[1559391157435,["GJX@GJXAIOU",[[1,18573,"\n"]],[18571,18571],[18572,18572]]],[1559391182171,["GJX@GJXAIOU",[[1,18572,"## 7.8 拓扑"]],[18572,18572],[18581,18581]]],[1559391246690,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[-1,17634,"![弗"],[1,17637,"\n\n"],[1,17741,"![弗"],[1,17818,"\n"],[-1,17829,"lang"],[-1,18057,"鍖朌鍜孭"],[1,18061,""],[1,18169,"[w];"],[-1,18189,"[w];"],[1,18208,"= w;"],[-1,18215,"= w;"],[-1,18226,"风畻娉?"],[1,18230,"\n\t\n\t"],[1,18407,"\t\t\t\t"],[-1,18455,"\t\t\t\t"],[1,18527,"[k];"],[-1,18543,"[k粈涔堬紵"],[1,18549,"\t\t"],[1,18570,"```\n\n"],[1,18580,"\n\n"]],[4388,4388],[18582,18582]]],[1559391246690,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[1,17635,"![弗"],[-1,17635,"\n\n"],[-1,17741,"![弗"],[-1,17821,"\n"],[1,17833,"lang"],[1,18057,"鍖朌鍜孭"],[-1,18057,""],[-1,18165,"[w];"],[1,18189,"[w];"],[-1,18204,"= w;"],[1,18215,"= w;"],[1,18222,"风畻娉?"],[-1,18222,"\n\t\n\t"],[-1,18403,"\t\t\t\t"],[1,18455,"\t\t\t\t"],[-1,18523,"[k];"],[1,18543,"[k粈涔堬紵"],[-1,18543,"\t\t"],[-1,18566,"```\n\n"],[-1,18581,"\n\n"]],[18582,18582],[4388,4388]]],[1559391192337,["GJX@GJXAIOU",[[1,18581,"排序"]],[18581,18581],[18583,18583]]],[1559391217782,["GJX@GJXAIOU",[[1,18585,"\n"]],[18584,18584],[18585,18585]]],[1559391221615,["GJX@GJXAIOU",[[-1,18585,"\n"],[1,18586,"前面"]],[18585,18585],[18587,18587]]],[1559391245056,["GJX@GJXAIOU",[[1,18587,"两个都是有环的图"]],[18587,18587],[18595,18595]]],[1559391306682,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[-1,17634,"![弗"],[1,17637,"\n\n"],[1,17741,"![弗"],[1,17818,"\n"],[-1,17829,"lang"],[-1,18057,"鍖朌鍜孭"],[1,18061,""],[1,18169,"[w];"],[-1,18189,"[w];"],[1,18208,"= w;"],[-1,18215,"= w;"],[-1,18226,"风畻娉?"],[1,18230,"\n\t\n\t"],[1,18407,"\t\t\t\t"],[-1,18455,"\t\t\t\t"],[1,18527,"[k];"],[-1,18543,"[k粈涔堬紵"],[1,18549,"\t\t"],[1,18570,"```\n\n"],[1,18582,"\n"]],[4388,4388],[18583,18583]]],[1559391306683,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[1,17635,"![弗"],[-1,17635,"\n\n"],[-1,17741,"![弗"],[-1,17821,"\n"],[1,17833,"lang"],[1,18057,"鍖朌鍜孭"],[-1,18057,""],[-1,18165,"[w];"],[1,18189,"[w];"],[-1,18204,"= w;"],[1,18215,"= w;"],[1,18222,"风畻娉?"],[-1,18222,"\n\t\n\t"],[-1,18403,"\t\t\t\t"],[1,18455,"\t\t\t\t"],[-1,18523,"[k];"],[1,18543,"[k粈涔堬紵"],[-1,18543,"\t\t"],[-1,18566,"```\n\n"],[-1,18583,"\n"]],[18583,18583],[4388,4388]]],[1559391271313,["GJX@GJXAIOU",[[1,18597,"，下面为无环的图应用，即没有"]],[18597,18597],[18611,18611]]],[1559391366690,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[-1,17634,"![弗"],[1,17637,"\n\n"],[1,17741,"![弗"],[1,17818,"\n"],[-1,17829,"lang"],[-1,18057,"鍖朌鍜孭"],[1,18061,""],[1,18169,"[w];"],[-1,18189,"[w];"],[1,18208,"= w;"],[-1,18215,"= w;"],[-1,18226,"风畻娉?"],[1,18230,"\n\t\n\t"],[1,18407,"\t\t\t\t"],[-1,18455,"\t\t\t\t"],[1,18527,"[k];"],[-1,18543,"[k粈涔堬紵"],[1,18549,"\t\t"],[1,18570,"```\n\n"],[1,18583,"\n"],[1,18593,"应用"]],[4388,4388],[18595,18595]]],[1559391366690,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[1,17635,"![弗"],[-1,17635,"\n\n"],[-1,17741,"![弗"],[-1,17821,"\n"],[1,17833,"lang"],[1,18057,"鍖朌鍜孭"],[-1,18057,""],[-1,18165,"[w];"],[1,18189,"[w];"],[-1,18204,"= w;"],[1,18215,"= w;"],[1,18222,"风畻娉?"],[-1,18222,"\n\t\n\t"],[-1,18403,"\t\t\t\t"],[1,18455,"\t\t\t\t"],[-1,18523,"[k];"],[1,18543,"[k粈涔堬紵"],[-1,18543,"\t\t"],[-1,18566,"```\n\n"],[-1,18584,"\n"],[-1,18595,"应用"]],[18595,18595],[4388,4388]]],[1559391324649,["GJX@GJXAIOU",[[1,18609,"图中"]],[18609,18609],[18611,18611]]],[1559391339368,["GJX@GJXAIOU",[[1,18613,"回路；"]],[18613,18613],[18616,18616]]],[1559391546746,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[-1,17634,"![弗"],[1,17637,"\n\n"],[1,17741,"![弗"],[1,17818,"\n"],[-1,17829,"lang"],[-1,18057,"鍖朌鍜孭"],[1,18061,""],[1,18169,"[w];"],[-1,18189,"[w];"],[1,18208,"= w;"],[-1,18215,"= w;"],[-1,18226,"风畻娉?"],[1,18230,"\n\t\n\t"],[1,18407,"\t\t\t\t"],[-1,18455,"\t\t\t\t"],[1,18527,"[k];"],[-1,18543,"[k粈涔堬紵"],[1,18549,"\t\t"],[1,18570,"```\n\n"],[1,18583,"\n"],[1,18593,"应用"],[1,18605,"图中"],[-1,18607,"图中"]],[4388,4388],[18607,18607]]],[1559391546746,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[1,17635,"![弗"],[-1,17635,"\n\n"],[-1,17741,"![弗"],[-1,17821,"\n"],[1,17833,"lang"],[1,18057,"鍖朌鍜孭"],[-1,18057,""],[-1,18165,"[w];"],[1,18189,"[w];"],[-1,18204,"= w;"],[1,18215,"= w;"],[1,18222,"风畻娉?"],[-1,18222,"\n\t\n\t"],[-1,18403,"\t\t\t\t"],[1,18455,"\t\t\t\t"],[-1,18523,"[k];"],[1,18543,"[k粈涔堬紵"],[-1,18543,"\t\t"],[-1,18566,"```\n\n"],[-1,18584,"\n"],[-1,18595,"应用"],[-1,18609,"图中"],[1,18613,"图中"]],[18607,18607],[4388,4388]]],[1559391497111,["GJX@GJXAIOU",[[1,18616,"\n\n"]],[18616,18616],[18617,18617]]],[1559391497712,["GJX@GJXAIOU",[[1,18617,"一个无环的有向图称为无环图（Directed Acyclic Graph），简称DAG图"]],[18617,18617],[18661,18661]]],[1559391501267,["GJX@GJXAIOU",[[1,18662,"\n"]],[18661,18661],[18662,18662]]],[1559391501475,["GJX@GJXAIOU",[[1,18663,"\n"]],[18662,18662],[18663,18663]]],[1559391501770,["GJX@GJXAIOU",[[1,18664,"\n"]],[18663,18663],[18664,18664]]],[1559391502061,["GJX@GJXAIOU",[[1,18665,"\n"]],[18664,18664],[18665,18665]]],[1559391502452,["GJX@GJXAIOU",[[1,18666,"\n"]],[18665,18665],[18666,18666]]],[1559391502699,["GJX@GJXAIOU",[[1,18667,"\n"]],[18666,18666],[18667,18667]]],[1559391510362,["GJX@GJXAIOU",[[1,18668,"\n"]],[18667,18667],[18668,18668]]],[1559391510564,["GJX@GJXAIOU",[[1,18669,"\n"]],[18668,18668],[18669,18669]]],[1559391511892,["GJX@GJXAIOU",[[1,18670,"\n"]],[18669,18669],[18670,18670]]],[1559391606710,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[-1,17634,"![弗"],[1,17637,"\n\n"],[1,17741,"![弗"],[1,17818,"\n"],[-1,17829,"lang"],[-1,18057,"鍖朌鍜孭"],[1,18061,""],[1,18169,"[w];"],[-1,18189,"[w];"],[1,18208,"= w;"],[-1,18215,"= w;"],[-1,18226,"风畻娉?"],[1,18230,"\n\t\n\t"],[1,18407,"\t\t\t\t"],[-1,18455,"\t\t\t\t"],[1,18527,"[k];"],[-1,18543,"[k粈涔堬紵"],[1,18549,"\t\t"],[1,18570,"```\n\n"],[1,18583,"\n"],[1,18593,"应用"],[-1,18605,"没有"],[1,18609,"没有"],[-1,18612,"\n"],[1,18658,"\n"]],[4388,4388],[18659,18659]]],[1559391606710,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[1,17635,"![弗"],[-1,17635,"\n\n"],[-1,17741,"![弗"],[-1,17821,"\n"],[1,17833,"lang"],[1,18057,"鍖朌鍜孭"],[-1,18057,""],[-1,18165,"[w];"],[1,18189,"[w];"],[-1,18204,"= w;"],[1,18215,"= w;"],[1,18222,"风畻娉?"],[-1,18222,"\n\t\n\t"],[-1,18403,"\t\t\t\t"],[1,18455,"\t\t\t\t"],[-1,18523,"[k];"],[1,18543,"[k粈涔堬紵"],[-1,18543,"\t\t"],[-1,18566,"```\n\n"],[-1,18584,"\n"],[-1,18595,"应用"],[1,18609,"没有"],[-1,18611,"没有"],[1,18616,"\n"],[-1,18661,"\n"]],[18659,18659],[4388,4388]]],[1559391554590,["GJX@GJXAIOU",[[1,18671,"\n"]],[18661,18661],[18662,18662]]],[1559391555120,["GJX@GJXAIOU",[[1,18662,"在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称之为AOV网"]],[18662,18662],[18722,18722]]],[1559391558813,["GJX@GJXAIOU",[[1,18617,"- "]],[18617,18617],[18619,18619]]],[1559391561000,["GJX@GJXAIOU",[[1,18664,"- "]],[18664,18664],[18666,18666]]],[1559391564432,["GJX@GJXAIOU",[[1,18726,"；"]],[18726,18726],[18727,18727]]],[1559391566521,["GJX@GJXAIOU",[[1,18663,"；"]],[18663,18663],[18664,18664]]],[1559391666716,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5635,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[-1,17634,"![弗"],[1,17637,"\n\n"],[1,17741,"![弗"],[1,17818,"\n"],[-1,17829,"lang"],[-1,18057,"鍖朌鍜孭"],[1,18061,""],[1,18169,"[w];"],[-1,18189,"[w];"],[1,18208,"= w;"],[-1,18215,"= w;"],[-1,18226,"风畻娉?"],[1,18230,"\n\t\n\t"],[1,18407,"\t\t\t\t"],[-1,18455,"\t\t\t\t"],[1,18527,"[k];"],[-1,18543,"[k粈涔堬紵"],[1,18549,"\t\t"],[1,18570,"```\n\n"],[1,18583,"\n"],[1,18593,"应用"],[-1,18605,"没有"],[1,18609,"没有"],[-1,18613,"\n"],[1,18614,"- "],[-1,18617,"- "],[-1,18660,"\n\n\n"],[1,18728,"\n\n\n\n"]],[4388,4388],[18732,18732]]],[1559391666716,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6144,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[1,17635,"![弗"],[-1,17635,"\n\n"],[-1,17741,"![弗"],[-1,17821,"\n"],[1,17833,"lang"],[1,18057,"鍖朌鍜孭"],[-1,18057,""],[-1,18165,"[w];"],[1,18189,"[w];"],[-1,18204,"= w;"],[1,18215,"= w;"],[1,18222,"风畻娉?"],[-1,18222,"\n\t\n\t"],[-1,18403,"\t\t\t\t"],[1,18455,"\t\t\t\t"],[-1,18523,"[k];"],[1,18543,"[k粈涔堬紵"],[-1,18543,"\t\t"],[-1,18566,"```\n\n"],[-1,18584,"\n"],[-1,18595,"应用"],[1,18609,"没有"],[-1,18611,"没有"],[1,18617,"\n"],[-1,18617,"- "],[1,18622,"- "],[1,18663,"\n\n\n"],[-1,18728,"\n\n\n\n"]],[18732,18732],[4388,4388]]],[1559391639781,["GJX@GJXAIOU",[[1,18730,"•拓扑序列：设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列V1,V2,……,Vn满足若从顶点Vi到Vj有一条路径，则在顶点序列中顶点Vi必在顶点Vj之前。则我们称这样的顶点序列为一个拓扑序列。\n\n•拓扑排序：所谓的拓扑排序，其实就是对一个有向图构造拓扑序列的过程。"]],[18730,18730],[18868,18868]]],[1559391642152,["GJX@GJXAIOU",[[-1,18730,"•"]],[18731,18731],[18730,18730]]],[1559391642950,["GJX@GJXAIOU",[[1,18730,"- "]],[18730,18730],[18732,18732]]],[1559391645826,["GJX@GJXAIOU",[[-1,18835,"•"]],[18836,18836],[18835,18835]]],[1559391647125,["GJX@GJXAIOU",[[1,18835,"- "]],[18835,18835],[18837,18837]]],[1559391651952,["GJX@GJXAIOU",[[1,18871,"- \n"]],[18870,18870],[18873,18873]]],[1559391652149,["GJX@GJXAIOU",[[-1,18871,"- "]],[18873,18873],[18872,18872]]],[1559391885703,[null,[[-1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[1,4425,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[1,4427,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[1,4432,"\n邻接表的创建：  \n```"],[-1,5366,"\ndui"],[1,5370,"```\n\n"],[-1,5373,"条边"],[-1,5378,","],[-1,5381,"表"],[-1,5385,"是件"],[-1,5392,"第复杂度"],[1,5398,"**"],[-1,5399,"（）"],[-1,5402,")"],[-1,5406,"**"],[1,5408,")"],[1,5410,"\n\n"],[1,5436,"\n\n"],[-1,5618,"\n"],[-1,5631,"\n"],[-1,5656,"- "],[1,5661,"- "],[-1,5682,"擦偶"],[-1,5686,"，"],[-1,5691,"对"],[-1,5709,"  - "],[1,5713,"\n"],[1,5734,"边表结点结构"],[-1,5797,"边表结点结构"],[1,5803,"\n"],[-1,5903,"\n- "],[1,5906,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[-1,5989,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[1,6022,""],[-1,6119,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[-1,6269,"结"],[1,6270,"顶"],[-1,6276,"界定啊"],[-1,6281,"顶"],[-1,6289,"，"],[1,6291,"\n### 7.5.1 深度优先遍历"],[-1,6308,"）"],[1,6312,"）\n"],[-1,6335,"时钟"],[-1,6343,"                "],[-1,6362,"顶底"],[-1,6373,"则从"],[-1,6389,"从"],[-1,6417,"知道"],[-1,6428,"军备"],[-1,6431,"背范文"],[-1,6451,"指导喊本"],[-1,6497,"\n"],[-1,6610,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[-1,6648,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[-1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[1,7621,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[-1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[1,7673,"\nBoolean visited[MAX];\t// "],[-1,7680,"es"],[1,7682,"\n\n"],[-1,7688,"\n;"],[1,7690,"深度"],[-1,7696," i++ )\n\t{"],[1,7705,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[1,7707,"\n"],[-1,7721,"FALS"],[1,7725,"TRU"],[-1,7727,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[-1,7760,"}\n\t\n\tfor( i=0; i <"],[1,7778,"printf(\"%c \""],[-1,7783,"numVertexes; i++ )\n\t"],[1,7803,"adjList[i].data);"],[1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[-1,7838,"i"],[1,7839,"p->adjvex"],[-1,7842,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[-1,7882,"i"],[1,7883,"p->adjvex"],[-1,7885,"\n\t\t}\n\t}\n}"],[-1,7895,"、、"],[1,7912,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[1,7922,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[1,7939,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[1,7963,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[-1,7981,"价比"],[-1,7989,"条边e个顶点的n"],[-1,8006,"连接"],[-1,8018,"："],[-1,8027,"）"],[-1,8030,")"],[1,8034,");"],[-1,8035,"shi"],[-1,8066,")"],[-1,8070,";"],[1,8071,")"],[-1,8074," \n"],[-1,8077,"=duiyu"],[-1,8087,"变少"],[-1,8110,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[1,8127,"### 7.5.2 广度优先遍历（"],[-1,8145,"（"],[-1,8150,"树"],[1,8151,"\n**图"],[-1,8161,"历****类似于"],[1,8169,"树的"],[-1,8173,"图树的"],[1,8176,"**\n\n"],[1,8285,"\n"],[1,8445,"\n"],[-1,8465,"language\n```\n"],[-1,8482," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[1,8500,"邻接矩阵的广度遍历算法"],[-1,8620,"i"],[1,8621,"I"],[1,8636," //初始化一辅助用的队列"],[1,8674," //对每一个顶点做循环"],[1,8697," //若是未访问过就处理"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8726," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[1,8744," //设置当前顶点访问过"],[1,8763," //将此顶点入队列"],[1,8794," //若当前队列不为空"],[1,8820," //将队中元素出队列，赋值给i"],[-1,8846,"I"],[1,8847,"r"],[-1,8862," //初始化一辅助用的队列"],[1,8883,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[-1,8992," //打印该结点，其他操作均可"],[-1,9021,"\n\t\t\t\t\t\tE"],[-1,9032,"设置当前"],[1,9036,"将找到的此"],[1,9038,"标记为已"],[-1,9040,"过n"],[1,9042,"\n\t\t\t"],[1,9045,"EnQue"],[-1,9055,"\n\t\t\t\t"],[1,9064,"找到的"],[1,9070,"\n\t\t\t\t"],[-1,9092,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[1,9190,"\n```\n\n\n"],[-1,9194,"矩阵"],[1,9196,"表"],[-1,9216,"矩阵"],[1,9218,"表"],[-1,9243,"M"],[1,9249,"AdjList"],[1,9251,"L"],[1,9267,"EdgeNode *p;\n\t"],[-1,9294,"."],[1,9295,"L->"],[-1,9345,"i"],[1,9346,"I"],[-1,9393,"."],[1,9394,"L->"],[-1,9422,"表"],[1,9423,"循环"],[-1,9443,"表"],[1,9444,"] "],[1,9464,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[1,9469,"t"],[-1,9474,"A"],[1,9475," \", GL->a"],[-1,9481," \"L, G.vex"],[1,9494,".data"],[-1,9500,"EdgeNode *p;\n\t"],[-1,9529,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[-1,9594,"I"],[1,9595,"\n"],[-1,9642,"L->"],[1,9645,"D"],[-1,9681,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[-1,9982,"\t"],[1,9983,"\n"],[1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[-1,10288,"官渡"],[-1,10307,"直视啊"],[-1,10318,"书序顺醋"],[-1,10326,"，"],[-1,10430,"）p"],[1,10432,"P"],[1,10435,"）"],[-1,10437,"P "],[-1,10440,"克鲁斯卡尔"],[1,13077,"克鲁斯卡尔（"],[1,13084,"）"],[-1,13086,"联通图"],[1,13089,"\n"],[-1,13103,"）"],[-1,13114,"\n[link基"],[1,13121,"）\n\n"],[1,13123,"基"],[-1,13126,"\n"],[1,13129,"\n"],[-1,13326,"克"],[1,13330,"克"],[-1,13369," "],[1,13372," "],[-1,13373,"而"],[1,13376,"而"],[-1,13402,"\n"],[-1,13406,"图"],[1,13407,"\n"],[1,13409,"图"],[-1,13410,"\n"],[1,13413,"\n"],[-1,13448,"2"],[1,13493,"2"],[-1,13554,"3"],[1,13556,"3"],[-1,13683,"4"],[1,13706,"4"],[-1,13965,"6"],[1,13988,"6"],[-1,14293,"8"],[1,14318,"8"],[-1,14671,"1"],[1,14696,"1"],[-1,14981,"\n"],[-1,15006,"时"],[1,15007,"\n"],[1,15009,"时"],[-1,15013,"\n"],[1,15016,"\n"],[-1,15045,"O"],[1,15046,"，"],[-1,15061,"e"],[1,15062," "],[-1,15089,"Oee"],[1,15092,"（e表"],[1,15099,"\n\n"],[-1,15106,"lanc`"],[1,15111,"c\n"],[1,15819,"```\n"],[-1,15833,"、"],[-1,15836,"•在网"],[1,15899,"在网图"],[-1,15918,"\n–网"],[1,15923,"网图是"],[-1,15942,"\n–非"],[1,15947,"非网图"],[-1,15964,"飞往图"],[-1,15987,"-"],[1,15988,"\n\n"],[-1,15990,"迪"],[1,15993,"迪"],[-1,15998,"）"],[1,16007,"）"],[-1,16009,"-"],[-1,16012," "],[1,16013,"\n"],[-1,16230,"`"],[1,16231,"\n"],[-1,17557,"\n"],[1,17558,"`"],[-1,17576,"-"],[1,17577,"\n"],[1,17616,"-"],[-1,17617,"洛"],[1,17620,"弗洛"],[-1,17623,"）"],[-1,17629,"s"],[1,17630,"）"],[-1,17634,"![弗"],[1,17637,"\n\n"],[1,17741,"![弗"],[1,17818,"\n"],[-1,17829,"lang"],[-1,18057,"鍖朌鍜孭"],[1,18061,""],[1,18169,"[w];"],[-1,18189,"[w];"],[1,18208,"= w;"],[-1,18215,"= w;"],[-1,18226,"风畻娉?"],[1,18230,"\n\t\n\t"],[1,18407,"\t\t\t\t"],[-1,18455,"\t\t\t\t"],[1,18527,"[k];"],[-1,18543,"[k粈涔堬紵"],[1,18549,"\t\t"],[1,18570,"```\n\n"],[1,18583,"\n"],[1,18593,"应用"],[-1,18605,"没有"],[1,18609,"没有"],[-1,18613,"\n"],[1,18614,"- "],[-1,18617,"- "],[-1,18660,"\n\n\n"],[-1,18870,""],[1,18870,"\n\n\n\n"]],[4388,4388],[18874,18874]]],[1559391885703,[null,[[1,4388,"\n```\n\n\n\n\nlingj邻接表的创建：\n    \n·```langua"],[-1,4388,"typedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEd"],[-1,4896,"s; /* 图中当前顶点数和边数 */\n}GraphAdjList;"],[-1,4935,"\n邻接表的创建：  \n```"],[1,5883,"\ndui"],[-1,5883,"```\n\n"],[1,5891,"条边"],[1,5894,","],[1,5896,"表"],[1,5899,"是件"],[1,5904,"第复杂度"],[-1,5906,"**"],[1,5909,"（）"],[1,5910,")"],[1,5913,"**"],[-1,5913,")"],[-1,5916,"\n\n"],[-1,5944,"\n\n"],[1,6128,"\n"],[1,6140,"\n"],[1,6164,"- "],[-1,6167,"- "],[1,6190,"擦偶"],[1,6192,"，"],[1,6196,"对"],[1,6213,"  - "],[-1,6213,"\n"],[-1,6235,"边表结点结构"],[1,6304,"边表结点结构"],[-1,6304,"\n"],[1,6405,"\n- "],[-1,6405,"关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；"],[1,6520,"关注的是边的集合，查找顶点需要扫描整个边数组，适合随对边进行操作；"],[-1,6520,""],[1,6617,"[图的深度优先遍历]($resource/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.swf)\n### 7.5.1 深度优先遍历\n\n\n\n### 7.5.2 广度优先遍历"],[1,6632,"结"],[-1,6632,"顶"],[1,6639,"界定啊"],[1,6641,"顶"],[1,6648,"，"],[-1,6649,"\n### 7.5.1 深度优先遍历"],[1,6683,"）"],[-1,6686,"）\n"],[1,6711,"时钟"],[1,6717,"                "],[1,6720,"顶底"],[1,6729,"则从"],[1,6743,"从"],[1,6770,"知道"],[1,6779,"军备"],[1,6780,"背范文"],[1,6797,"指导喊本"],[1,6839,"\n"],[1,6951,"使用邻接矩阵存储的图的深度搜索操作代码：\n\n```language\n```"],[1,6952,"c\ntypedef int Boolean;\t// 杩欓噷鎴戜滑瀹氫箟Boolean涓哄竷灏旂被鍨嬶紝鍏跺€间负TRUE鎴朏ALSE\nBoolean visited[MAX];\t// 璁块棶鏍囧織鐨勬暟缁?\n\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data);\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->"],[1,7571,"adjv表);\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 閭绘帴琛ㄧ殑娣卞害閬嶅巻鎿F"],[-1,7571,"使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// B"],[1,7647,"int i;\n\t\n\tfor( i=0; i < GL"],[-1,7647,"\nBoolean visited[MAX];\t// "],[1,7680,"es"],[-1,7680,"\n\n"],[1,7688,"\n;"],[-1,7688,"深度"],[1,7696," i++ )\n\t{"],[-1,7696,"\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;"],[-1,7747,"\n"],[1,7762,"FALS"],[-1,7762,"TRU"],[1,7767,"\t\t// 鍒濆鍖栨墍鏈夐《鐐圭姸鎬侀兘鏄湭璁块棶杩囩姸鎬?"],[1,7769,"}\n\t\n\tfor( i=0; i <"],[-1,7769,"printf(\"%c \""],[1,7786,"numVertexes; i++ )\n\t"],[-1,7786,"adjList[i].data);"],[-1,7821,"\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t"],[1,7883,"i"],[-1,7883,"p->adjvex"],[1,7895,"\t\t// 鑻ユ槸杩為€氬浘锛屽彧浼氭墽琛屼竴娆?"],[1,7911,"i"],[-1,7911,"p->adjvex"],[1,7922,"\n\t\t}\n\t}\n}"],[1,7923,"、、"],[-1,7938,"\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// "],[-1,7977,"\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// "],[-1,8108,"\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// "],[-1,8203,"\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n"],[1,8255,"价比"],[1,8261,"条边e个顶点的n"],[1,8270,"连接"],[1,8280,"："],[1,8288,"）"],[1,8290,")"],[-1,8293,");"],[1,8296,"shi"],[1,8324,")"],[1,8327,";"],[-1,8327,")"],[1,8331," \n"],[1,8332,"=duiyu"],[1,8336,"变少"],[1,8357,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],[-1,8357,"### 7.5.2 广度优先遍历（"],[1,8392,"（"],[1,8396,"树"],[-1,8396,"\n**图"],[1,8410,"历****类似于"],[-1,8410,"树的"],[1,8416,"图树的"],[-1,8416,"**\n\n"],[-1,8529,"\n"],[-1,8690,"\n"],[1,8711,"language\n```\n"],[1,8715," 閭绘帴鐭╅樀鐨勫箍搴﹂亶鍘嗙畻娉?"],[-1,8715,"邻接矩阵的广度遍历算法"],[1,8846,"i"],[-1,8846,"I"],[-1,8862," //初始化一辅助用的队列"],[-1,8913," //对每一个顶点做循环"],[-1,8948," //若是未访问过就处理"],[1,8978,"邻接矩阵的广度遍历算法"],[-1,8978," \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\t"],[-1,9029," //设置当前顶点访问过"],[-1,9060," //将此顶点入队列"],[-1,9101," //若当前队列不为空"],[-1,9138," //将队中元素出队列，赋值给i"],[1,9180,"I"],[-1,9180,"r"],[1,9196," //初始化一辅助用的队列"],[-1,9204,"  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t"],[1,9264," //对每一个顶点做循环"],[1,9287," //若是未访问过就处理"],[1,9319," //打印该结点，其他操作均可"],[1,9333,"\n\t\t\t\t\t\tE"],[1,9336,"设置当前"],[-1,9336,"将找到的此"],[-1,9343,"标记为已"],[1,9349,"过n"],[-1,9349,"\n\t\t\t"],[-1,9356,"EnQue"],[1,9371,"\n\t\t\t\t"],[-1,9375,"找到的"],[-1,9384,"\n\t\t\t\t"],[1,9411,"、 //若当前队列不为空 //jiang duij将队中元素出队列，赋值给id\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过 //将找到的此顶点标记为已访问 //将找到的此顶点入队列"],[-1,9411,"\n```\n\n\n"],[1,9422,"矩阵"],[-1,9422,"表"],[1,9443,"矩阵"],[-1,9443,"表"],[1,9469,"M"],[-1,9474,"AdjList"],[-1,9483,"L"],[-1,9500,"EdgeNode *p;\n\t"],[1,9541,"."],[-1,9541,"L->"],[1,9594,"i"],[-1,9594,"I"],[1,9642,"."],[-1,9642,"L->"],[1,9673,"表"],[-1,9673,"循环"],[1,9695,"表"],[-1,9695,"] "],[-1,9717,"    visited[i] = TRUE; //设置当前顶点访问过\n\t\t"],[-1,9759,"t"],[1,9765,"A"],[-1,9765," \", GL->a"],[1,9780," \"L, G.vex"],[-1,9783,".data"],[1,9794,"EdgeNode *p;\n\t"],[1,9809,"visited[i] =L->TRUE; //设置当前顶点访问过\n\t\t\t"],[1,9838,"I"],[-1,9838,"\n"],[1,9886,"L->"],[-1,9886,"D"],[1,9923,"for( j=0; j < G.numVertexes; j++ )\n\t\n\t  visited[i] = TRUE; //设置当前顶点访问过\t\t\t\t{\n\t\t\t\t  //判断其他顶L->adjList[i].data存在边且未被访问过\n\t\t\t\t\ti\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t"],[1,9982,"\t"],[-1,9982,"\n"],[-1,10278,"\t\t\t}\n\t\t}\n\t}\n}\n```"],[1,10305,"官渡"],[1,10322,"直视啊"],[1,10330,"书序顺醋"],[1,10334,"，"],[1,10437,"）p"],[-1,10437,"P"],[-1,10441,"）"],[1,10444,"P "],[1,10445,"克鲁斯卡尔"],[-1,13077,"克鲁斯卡尔（"],[-1,13090,"）"],[1,13093,"联通图"],[-1,13093,"\n"],[1,13108,"）"],[1,13118,"\n[link基"],[-1,13118,"）\n\n"],[-1,13123,"基"],[1,13127,"\n"],[-1,13129,"\n"],[1,13327,"克"],[-1,13330,"克"],[1,13370," "],[-1,13372," "],[1,13374,"而"],[-1,13376,"而"],[1,13403,"\n"],[1,13406,"图"],[-1,13406,"\n"],[-1,13409,"图"],[1,13411,"\n"],[-1,13413,"\n"],[1,13449,"2"],[-1,13493,"2"],[1,13555,"3"],[-1,13556,"3"],[1,13684,"4"],[-1,13706,"4"],[1,13966,"6"],[-1,13988,"6"],[1,14294,"8"],[-1,14318,"8"],[1,14672,"1"],[-1,14696,"1"],[1,14982,"\n"],[1,15006,"时"],[-1,15006,"\n"],[-1,15009,"时"],[1,15014,"\n"],[-1,15016,"\n"],[1,15046,"O"],[-1,15046,"，"],[1,15062,"e"],[-1,15062," "],[1,15090,"Oee"],[-1,15090,"（e表"],[-1,15100,"\n\n"],[1,15109,"lanc`"],[-1,15109,"c\n"],[-1,15819,"```\n"],[1,15837,"、"],[1,15839,"•在网"],[-1,15899,"在网图"],[1,15921,"\n–网"],[-1,15923,"网图是"],[1,15945,"\n–非"],[-1,15947,"非网图"],[1,15967,"飞往图"],[1,15987,"-"],[-1,15987,"\n\n"],[1,15991,"迪"],[-1,15993,"迪"],[1,15999,"）"],[-1,16007,"）"],[1,16010,"-"],[1,16012," "],[-1,16012,"\n"],[1,16230,"`"],[-1,16230,"\n"],[1,17557,"\n"],[-1,17557,"`"],[1,17576,"-"],[-1,17576,"\n"],[-1,17616,"-"],[1,17618,"洛"],[-1,17620,"弗洛"],[1,17625,"）"],[1,17630,"s"],[-1,17630,"）"],[1,17635,"![弗"],[-1,17635,"\n\n"],[-1,17741,"![弗"],[-1,17821,"\n"],[1,17833,"lang"],[1,18057,"鍖朌鍜孭"],[-1,18057,""],[-1,18165,"[w];"],[1,18189,"[w];"],[-1,18204,"= w;"],[1,18215,"= w;"],[1,18222,"风畻娉?"],[-1,18222,"\n\t\n\t"],[-1,18403,"\t\t\t\t"],[1,18455,"\t\t\t\t"],[-1,18523,"[k];"],[1,18543,"[k粈涔堬紵"],[-1,18543,"\t\t"],[-1,18566,"```\n\n"],[-1,18584,"\n"],[-1,18595,"应用"],[1,18609,"没有"],[-1,18611,"没有"],[1,18617,"\n"],[-1,18617,"- "],[1,18622,"- "],[1,18663,"\n\n\n"],[1,18870,""],[-1,18870,"\n\n\n\n"]],[18874,18874],[4388,4388]]],[1559391872706,["GJX@GJXAIOU",[[1,18879,"\n"]],[18872,18872],[18873,18873]]],[1559391875730,["GJX@GJXAIOU",[[1,18873,"P272"]],[18873,18873],[18877,18877]]],[1559391882480,["GJX@GJXAIOU",[[1,18873,"**"],[1,18877,"**"]],[18873,18877],[18873,18881]]]],null,"GJX@GJXAIOU"],["dafce3ac-6821-4a5e-b60c-b82a6568e15a",1559434732827,"---\nstyle: summer\n---\n# 图\n\n\n## 7.1 图的定义\n\n- 图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。\n- 顶点：图中的数据元素；    线性表中数据元素称为：元素； 树中数据元素称为：结点\n- 边：顶点之间的逻辑关系使用边来表示，边集可以是空的；\n- 无向边：若顶点Vi到Vj之间的边没有方向，则称这条边为无向边(Edge)，用无序偶(Vi,Vj)来表示；\n- 无向图：即图中任意两个顶点之间的边都是无向边，构成的图示无向图；\n- 有向边：若从顶点Vi到Vj的边有方向，则称这条边为有向边，也成为弧(Arc)，用有序偶<Vi,Vj>来表示，Vi称为弧尾，Vj称为弧头。表示方法不能颠倒；\n\n\n![有向图示例]($resource/%E6%97%A0%E5%90%91%E5%9B%BE%E7%A4%BA%E4%BE%8B.jpg)\n\n- 无向边使用小括号`()`表示，有向边使用尖括号`<>`表示。\n- 简单图：在图中不存在顶点到自身的边（就是没有自己到自己的边），且同一个边不重复出现（就是两个顶点之间不存在两条一样的路径）；\n- 无向完全图：无向图中如果任意两个顶点之间都有边；即含有n个顶点的无向完全图拥有`n*(n-1)/2`条边；\n- 有向完全图：有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧；则有向图最多拥有`n(n-1)`条边。\n- 网：带有权值的图\n- 子图：假设有两个图G1=(V1,E1)和G2=(V2,E2)，如果V2⊆V1，E2⊆E1，则称G2为G1的子图(Subgraph)。\n\n### 7.1.2 图的顶点和边间关系\n\n- 对于无向图G=(V,E)，如果边(V1,V2)∈E，则称顶点V1和V2互为邻接点(Adjacent)，即V1和V2相邻接。边(V1,V2)依附(incident)于顶点V1和V2，或者说边(V1,V2)与顶点V1和V2相关联。\n\n- 顶点V的度(Degree)：是和V相关联的边的数目，记为TD(V)；整个图的边数是各个顶点度数和的一半；\n\n- 对于有向图G=(V,E)，如果有<V1,V2>∈E，则称顶点V1邻接到顶点V2，顶点V2邻接自顶点V1。\n\n- 以**顶点V为头的弧**的数目称为V的**入度**(InDegree)，记为ID(V)，以V为尾的弧的数目称为V的**出度**(OutDegree)，记为OD(V)，因此顶点V的度为TD(V)=ID(V)+OD(V)。\n\n- 顶点到另一个顶点路径的长度是路径上的边或弧的数目；\n- 第一个顶点到最后一个顶点相同的路径称为回路或环；\n- 序列中顶点不重复出现的路径称为简单路径，除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。\n\n![简单环]($resource/%E7%AE%80%E5%8D%95%E7%8E%AF.jpg)\n\n### 7.1.3 连通图相关术语\n\n- 在无向图G中，如果从顶点V1到顶点V2有路径，则称V1和V2是连通的，如果对于图中任意两个顶点Vi和Vj都是连通的，则称G是连通图；\n- 无向图中的极大连通子图称为连通分量。\n  - 注意以下概念：\n  - 首先要是子图，并且子图是要连通的；\n  - 连通子图含有极大顶点数；\n  - 具有极大顶点数的连通子图包含依附于这些顶点的所有边。\n- 强连通图：在有向图G中，如果对于每一对Vi到Vj都存在路径（即任意两个结点之间可达），则称G是强连通图；\n- 强连通分量：有向图中的极大强连通子图称为有向图的强连通分量。\n- 一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。（如果一个图有n个顶点和小于n-1条边，则是非连通图，多余n-1条边则必定构成环）。\n- 如果一个有向图恰有一个顶点入度为0，其余顶点的入度均为1，则是一棵有向树。\n\n##  7.2 图的抽象数据类型\n```c\nADT 图(Graph) \n\nData \n\n 顶点的有穷非空集合和边的集合 \n\nOperation \n\n CreateGraph(*G,V,VR):按照顶点集合V和边弧集VR的定义构造图G。 \n\n DestroyGraph(*G):图G存在则销毁。 \n\n LocateVex(G,u):若图G中存在顶点u，则返回图中的位置。 \n\n GetVex(G,v):返回图G中顶点v的值。 \n\n PutVex(G,v,value):将图G中顶点v赋值value。 \n\n FirstAdjvex(G,*v):返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。 \n\n NextAdjVex(G,v,*w):返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个邻接点则返回“空”。 \n\n InsertVex(*G,v):在图G中增添新顶点v. \n\n DeleteVex(*G,v):删除图G中顶点v及其相关的弧。 \n\n InsertArc(*G,v,w):在图G中增添弧<v,w>,若G是无向图，还需要增添对称弧<w,v>。 \n\n DeleteArc(*G,v,w):在图G中删除弧<v,w>，若G是无向图，则还删除对称弧<w,v>。 \n\n DESTraverse(G):对图G中进行深度优先遍历，在遍历过程中对每个顶点调用。 \n\n HFSTraverse(G):对图G中进行广度优先遍历，在遍历过程中对每个顶点调用。 \n\nendADT\n```\n\n\n\n## 7.3 图的存储结构\n\n常见的存储方式：\n- 顺序存储：因为无法使用数据元素在内存中的物理位置来表示元素之间的关系，不行；\n- 多重链表：即以一个数据域和多个指针域组成的结点表示图中的一个顶点，但是如果顶点的度相差很大，按照度数最大的结点设计结点结构会造成浪费，如果每个顶点结点结构不同，会造成操作上的麻烦；\n\n\n图中的存储结构：\n- 邻接矩阵：使用两个数组来表示图，一个一维数组表示顶点信息，一个二维数组（邻接矩阵）表示图中的边或者弧的信息。\n  - 缺点:**对于边数相比顶点树很少的图，该结构较为浪费**；\n![邻接矩阵（无向图）]($resource/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%89.png)\n\n![邻接矩阵（有向图）]($resource/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%89.png)\n\n![邻接矩阵(网图)]($resource/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5(%E7%BD%91%E5%9B%BE).png)\n\n邻接矩阵的创建代码：\n```c\ntypedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码，如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义  */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\ntypedef struct\n{\n\tVertexType vexs[MAXVEX]; /* 顶点表 */\n\tEdgeType arc[MAXVEX][MAXVEX];/* 邻接矩阵，可看作边表 */\n\tint numNodes, numEdges; /* 图中当前的顶点数和边数  */\n}MGraph;\n\n```\n\n建立无向网图的邻接矩阵表示：\n```c\nvoid CreateMGraph(MGraph *G)\n{\n\tint i,j,k,w;\n\tprintf(\"输入顶点数和边数:\\n\");\n\tscanf(\"%d,%d\",&G->numNodes,&G->numEdges); /* 输入顶点数和边数 */\n\tfor(i = 0;i <G->numNodes;i++) /* 读入顶点信息,建立顶点表 */\n\t\tscanf(&G->vexs[i]);\n\tfor(i = 0;i <G->numNodes;i++)\n\t\tfor(j = 0;j <G->numNodes;j++)\n\t\t\tG->arc[i][j]=INFINITY;\t/* 邻接矩阵初始化 */\n\tfor(k = 0;k <G->numEdges;k++) /* 读入numEdges条边，建立邻接矩阵 */\n\t{\n\t\tprintf(\"输入边(vi,vj)上的下标i，下标j和权w:\\n\");\n\t\tscanf(\"%d,%d,%d\",&i,&j,&w); /* 输入边(vi,vj)上的权w */\n\t\tG->arc[i][j]=w; \n\t\tG->arc[j][i]= G->arc[i][j]; /* 因为是无向图，矩阵对称 */\n\t}\n}\n```\n\n对于n个结点e条边的无向网图创建的时间复杂度为：**O(n+n^2 +e)**\n\n- 邻接表：将数组和链表相结合\n  - 图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。\n  - 图中每个顶点Vi的所有邻接点构成一个线性表，由于邻接点的个数不确定，所以我们选择用单链表来存储。\n\n**针对于有向图：邻接表只关心出度，必须通过遍历整个图才能了解入度，逆邻接表反之**\n![邻接表(有向图入度)]($resource/%E9%82%BB%E6%8E%A5%E8%A1%A8(%E6%9C%89%E5%90%91%E5%9B%BE%E5%85%A5%E5%BA%A6).png)\n![邻接表（无向图）]($resource/%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%89.png)\n![邻接表（有向图出度）]($resource/%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E6%9C%89%E5%90%91%E5%9B%BE%E5%87%BA%E5%BA%A6%EF%BC%89.png)\n\n![邻接表（网）]($resource/%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E7%BD%91%EF%BC%89.png)\n\n邻接表结点的定义代码：\n```c\ntypedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEdges; /* 图中当前顶点数和边数 */\n}GraphAdjList;\n```\n\n邻接表的创建：  \n```c\n/* 建立图的邻接表结构 */\nvoid  CreateALGraph(GraphAdjList *G)\n{\n\tint i,j,k;\n\tEdgeNode *e;\n\tprintf(\"输入顶点数和边数:\\n\");\n\tscanf(\"%d,%d\",&G->numNodes,&G->numEdges); /* 输入顶点数和边数 */\n\tfor(i = 0;i < G->numNodes;i++) /* 读入顶点信息,建立顶点表 */\n\t{\n\t\tscanf(&G->adjList[i].data); \t/* 输入顶点信息 */\n\t\tG->adjList[i].firstedge=NULL; \t/* 将边表置为空表 */\n\t}\n\t\n\t\n\tfor(k = 0;k < G->numEdges;k++)/* 建立边表 */\n\t{\n\t\tprintf(\"输入边(vi,vj)上的顶点序号:\\n\");\n\t\tscanf(\"%d,%d\",&i,&j); /* 输入边(vi,vj)上的顶点序号 */\n\t\te=(EdgeNode *)malloc(sizeof(EdgeNode)); /* 向内存申请空间,生成边表结点 */\n\t\te->adjvex=j;\t\t\t\t\t/* 邻接序号为j */                         \n\t\te->next=G->adjList[i].firstedge;\t/* 将e的指针指向当前顶点上指向的结点 */\n\t\tG->adjList[i].firstedge=e;\t\t/* 将当前顶点的指针指向e */               \n\t\t\n\t\te=(EdgeNode *)malloc(sizeof(EdgeNode)); /* 向内存申请空间,生成边表结点 */\n\t\te->adjvex=i;\t\t\t\t\t/* 邻接序号为i */                         \n\t\te->next=G->adjList[j].firstedge;\t/* 将e的指针指向当前顶点上指向的结点 */\n\t\tG->adjList[j].firstedge=e;\t\t/* 将当前顶点的指针指向e */               \n\t}\n}\n```\n\n对于n个顶点e条边来说时间复杂度是：**O(n+e)**\n\n\n- 十字链表：针对于有向图，结合邻接表和逆邻接表；\n\n![十字链表结点结构]($resource/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84.jpg)\n\n![十字链表示例]($resource/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E7%A4%BA%E4%BE%8B.jpg)\n\n时间复杂度和邻接表相同；\n\n\n\n- 邻接多重表：针对无向图的邻接表的优化\n  - 邻接表主要关注顶点，邻接多重表主要关注边的操作，例如对已访问的边的标记，删除某一条边等；\n\n重新定义边表的结点结构：\n![邻接多重表边表结点结构]($resource/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8.jpg)\n\n![邻接多重表示例]($resource/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E7%A4%BA%E4%BE%8B.jpg)\n\n\n\n- 边集数组：关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；\n由两个一维数组构成，一个是存储顶点的信息，另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标(begin)、终点下标(end)和权(weight)组成\n\n![边集数组示例]($resource/%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84%E7%A4%BA%E4%BE%8B.png)\n\n\n\n## 7.5 图的遍历\n\n从图中某一顶点出发访遍图中其余顶点，且每一个顶点仅能被访问一次；\n### 7.5.1 深度优先遍历DepthFirstSearch（DFS）\n可以假定右手原则，在没有碰到重复顶点的情况下，始终走右手边，如果遍历又回到该顶点，并且图中任有顶点未被访问，则另选图中一个未被访问过的顶点作为起始点，重复上述过程，直到图中所有的顶点均被访问过；\n\n深度优先搜索的过程本质上是一个递归的过程，并且通过图转换之后，变成下图的有图之后，就是一棵树的前序遍历。\n\n![深度优先遍历转换图]($resource/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)\n\n下面以无向图为例：\n使用邻接矩阵存储的图的深度搜索操作代码：\n\n```c\ntypedef int Boolean;\t// Boolean代表布尔类型，true or false\nBoolean visited[MAX];\t// 访问标志的数组\n\nvoid DFS(MGraph G, int i)\n{\n\tint j;\n\t\n\tvisited[j] = TRUE;\t\t\t\n\tprintf(\"%c \", G.vexs[i]);\t// 打印顶点，这里的操作可以自定义\n\tfor( j=0; j < G.numVertexes; j++ )\n\t{\n\t\tif( G.arc[i][j]==1 && !visited[j] )\n\t\t{\n\t\t\tDFS(G, j);\t\t\t// 对未访问的邻接顶点递归调用\n\t\t}\n\t}\n}\n\n// 邻接矩阵的深度遍历操作\nvoid DFSTraverse(MGraph G)\n{\n\tint i;\n\t\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// 初始所有顶点状态都是未访问过状态\n\t}\n\t\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// 对未访问过的顶点调用DFS，若是连通图，只会执行一次\n\t\t{\n\t\t\tDFS(G, i);\n\t\t}\n\t}\n```\n\n\n\n\n\n使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// Boolean代表布尔类型，true or false\nBoolean visited[MAX];\t// 访问标志的数组\n\n//邻接表的深度优先递归算法\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data); //打印顶点，这里的操作可以自定义\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->adjvex); //对未访问的邻接顶点递归调用\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 邻接表的深度遍历操作\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// 初始化所有顶点状态都是未访问过状态\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// 对未访问的顶点调用DFS，若是连通图，只执行一次\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n使用两种存储结构的深度优先遍历算法比较：\n对于n个顶点e条边的图：邻接矩阵使用二维数组，时间复杂度为：O(n^2);\n邻接表所需的时间取决于顶点和边的数量，时间复杂度为：O(n+e);\n==对于点多边少的稀疏图：邻接表结构效率更高==\n\n\n### 7.5.2 广度优先遍历（BreadthFirstSearch）BFS\n**图的广度优先遍历类似于树的层次遍历**\n\n![广度优先遍历转换图]($resource/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)\n\n可以使用队列实现对图的广度优先遍历：\n![使用队列实现广度优先遍历]($resource/%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.jpg)\n\n使用邻接矩阵实现的广度遍历算法：\n```c\n//邻接矩阵的广度遍历算法\nvoid BFSTraverse(MGraph G)\n{\n\tint i, j;\n\tQueue Q;\n\t\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\n\t}\n\t\n\tInitQueue( &Q ); //初始化一辅助用的队列\n\t\n\tfor( i=0; i < G.numVertexes; i++ ) //对每一个顶点做循环\n\t{\n\t\tif( !visited[i] ) //若是未访问过就处理\n\t\t{\n\t\t\tprintf(\"%c \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\tvisited[i] = TRUE; //设置当前顶点访问过\n\t\t\tEnQueue(&Q, i); //将此顶点入队列\n\t\t\t\n\t\t\twhile( !QueueEmpty(Q) ) //若当前队列不为空\n\t\t\t{\n\t\t\t\tDeQueue(&Q, &i); //将队中元素出队列，赋值给i\n\t\t\t\tfor( j=0; j < G.numVertexes; j++ )\n\t\t\t\t{\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t\tif( G.art[i][j]==1 && !visited[j] )\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n使用邻接表实现的广度遍历算法：\n```c\n//邻接表的广度遍历算法\nvoid BFSTraverse(GraphAdjList GL)\n{\n\tint i, j;\n\tEdgeNode *p;\n\tQueue Q;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\n\t}\n\t\n\tInitQueue( &Q ); //初始化一辅助用的队列\n\t\n\tfor( i=0; i < GL->numVertexes; i++ ) //对每一个顶点做循环\n\t{\n\t\tif( !visited[i] ) //若是未访问过就处理\n\t\t{\n\t\t    visited[i] = TRUE; //设置当前顶点访问过\n\t\t\tprintf(\"%c \", GL->adjList[i].data); //打印该结点，其他操作均可\n\t\t\tEnQueue(&Q, i); //将此顶点入队列\n\t\t\t\n\t\t\twhile( !QueueEmpty(Q) ) //若当前队列不为空\n\t\t\t{\n\t\t\t\tDeQueue(&Q, &i); //将队中元素出队列，赋值给i\n\t\t\t\tp = GL->adjList[i].firstedge; //找到当前顶点边表链表头指针\n\t\t\t\twhile(p){\n                  if(!visited[p->adjvex]){ //若此顶点未被访问\n                     visited[p->adjvex] = TRUE;\n                     printf(\"%c\",GL->adjList[p->adjvex].data);\n                     EnQueue(&Q,p->adjvex); //将此顶点入队列\n                }\n                p = p->next; //指针指向下一个邻接点\n              }\n\t\t\t}\n\t\t}\n\t}\n}\n```\n图的深度优先遍历和广度优先遍历的时间复杂度是一样的，只是对顶点的访问顺序不同；\n深度优先适合目标比较明确，以找到目标为主要目的的情况；\n广度优先适合在不断扩大遍历返回时候找到相对最优解的情况；\n\n\n\n\n\n## 7.6 最小生成树\n\n概念：构造连通网的最小代价生成树；\n\n- 普里姆（Prim）算法\n\n首先构造图的邻接矩阵：\n![普里姆算法]($resource/%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95.png)\n\n示例理解：\n\n初始状态：\n\n![1]($resource/1.jpg)\n\n\n设置2个数据结构：\n\nlowcost[i]:表示以i为终点的边的最小权值,当lowcost[i]=0说明以i为终点的边的最小权值=0,也就是表示i点加入了MST\n\nmst[i]:表示对应lowcost[i]的起点，即说明边<mst[i],i>是MST的一条边，当mst[i]=0表示起点i加入MST\n\n\n\n我们假设V1是起始点，进行初始化（*代表无限大，即无通路）：\n\n\n\nlowcost[2]=6，lowcost[3]=1，lowcost[4]=5，lowcost[5]=*，lowcost[6]=*\n\nmst[2]=1，mst[3]=1，mst[4]=1，mst[5]=1，mst[6]=1，（所有点默认起点是V1）\n\n\n\n明显看出，以V3为终点的边的权值最小=1，所以边<mst[3],3>=1加入MST\n![2]($resource/2.jpg)\n\n\n此时，因为点V3的加入，需要更新lowcost数组和mst数组：\n\nlowcost[2]=5，lowcost[3]=0，lowcost[4]=5，lowcost[5]=6，lowcost[6]=4\n\nmst[2]=3，mst[3]=0，mst[4]=1，mst[5]=3，mst[6]=3\n\n\n明显看出，以V6为终点的边的权值最小=4，所以边<mst[6],6>=4加入MST\n\n![3]($resource/3.jpg)\n\n\n\n\n此时，因为点V6的加入，需要更新lowcost数组和mst数组：\n\nlowcost[2]=5，lowcost[3]=0，lowcost[4]=2，lowcost[5]=6，lowcost[6]=0\n\nmst[2]=3，mst[3]=0，mst[4]=6，mst[5]=3，mst[6]=0\n\n\n明显看出，以V4为终点的边的权值最小=2，所以边<mst[4],4>=4加入MST\n![4]($resource/4.jpg)\n\n\n\n\n此时，因为点V4的加入，需要更新lowcost数组和mst数组：\n\nlowcost[2]=5，lowcost[3]=0，lowcost[4]=0，lowcost[5]=6，lowcost[6]=0\n\nmst[2]=3，mst[3]=0，mst[4]=0，mst[5]=3，mst[6]=0\n\n\n明显看出，以V2为终点的边的权值最小=5，所以边<mst[2],2>=5加入MST\n\n![5]($resource/5.jpg)\n\n\n\n此时，因为点V2的加入，需要更新lowcost数组和mst数组：\n\nlowcost[2]=0，lowcost[3]=0，lowcost[4]=0，lowcost[5]=3，lowcost[6]=0\n\nmst[2]=0，mst[3]=0，mst[4]=0，mst[5]=2，mst[6]=0\n\n\n很明显，以V5为终点的边的权值最小=3，所以边<mst[5],5>=3加入MST\n\n\nlowcost[2]=0，lowcost[3]=0，lowcost[4]=0，lowcost[5]=0，lowcost[6]=0\n\nmst[2]=0，mst[3]=0，mst[4]=0，mst[5]=0，mst[6]=0\n\n\n至此，MST构建成功，如图所示：\n![6]($resource/6.jpg)\n\n\n\n\n算法程序代码如下：\n```c\n/* Prim算法生成最小生成树  */\nvoid MiniSpanTree_Prim(MGraph G)\n{\n\tint min, i, j, k;\n\tint adjvex[MAXVEX];\t\t/* 保存相关顶点下标 */\n\tint lowcost[MAXVEX];\t/* 保存相关顶点间边的权值 */\n\tlowcost[0] = 0;/* 初始化第一个权值为0，即v0加入生成树 */\n\t\t\t/* lowcost的值为0，在这里就是此下标的顶点已经加入生成树 */\n\tadjvex[0] = 0;\t\t\t/* 初始化第一个顶点下标为0 */\n\tfor(i = 1; i < G.numVertexes; i++)\t/* 循环除下标为0外的全部顶点 */\n\t{\n\t\tlowcost[i] = G.arc[0][i];\t/* 将v0顶点与之有边的权值存入数组 */\n\t\tadjvex[i] = 0;\t\t\t\t\t/* 初始化都为v0的下标 */\n\t}\n\tfor(i = 1; i < G.numVertexes; i++)\n\t{\n\t\tmin = INFINITY;\t/* 初始化最小权值为∞， */\n\t\t\t\t\t\t/* 通常设置为不可能的大数字如32767、65535等 */\n\t\tj = 1;k = 0;\n\t\twhile(j < G.numVertexes)\t/* 循环全部顶点 */\n\t\t{\n\t\t\tif(lowcost[j]!=0 && lowcost[j] < min)/* 如果权值不为0且权值小于min */\n\t\t\t{\t\n\t\t\t\tmin = lowcost[j];\t/* 则让当前权值成为最小值 */\n\t\t\t\tk = j;\t\t\t/* 将当前最小值的下标存入k */\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tprintf(\"(%d, %d)\\n\", adjvex[k], k);/* 打印当前顶点边中权值最小的边 */\n\t\tlowcost[k] = 0;/* 将当前顶点的权值设置为0,表示此顶点已经完成任务 */\n\t\tfor(j = 1; j < G.numVertexes; j++)\t/* 循环所有顶点 */\n\t\t{\n\t\t\tif(lowcost[j]!=0 && G.arc[k][j] < lowcost[j]) \n\t\t\t{/* 如果下标为k顶点各边权值小于此前这些顶点未被加入生成树权值 */\n\t\t\t\tlowcost[j] = G.arc[k][j];/* 将较小的权值存入lowcost相应位置 */\n\t\t\t\tadjvex[j] = k;\t\t\t\t/* 将下标为k的顶点存入adjvex */\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n- 克鲁斯卡尔（Kruskal）算法\n首先通过连通图构建边集数组（按照权值从小到大排序）\n\n**基本思想**\n假设 N=(V,{E})N=(V,{E}) 是连通网：\n\n令最小生成树的初始状态为只有 nn 个顶点并且没有边的非连通图 T={V,{}}T={V,{}} ，图中每个顶点自成一个连通分量。\n在 EE 中选择代价最小的边，若该边的两个顶点落在 TT 中不同的连通分量上，则将此边加入到 TT 中，否则就舍去此边而选择下一条代价最小的边。\n以此类推，直至 TT 中所有顶点都在同一连通分量上为止。\n\n**克鲁斯卡尔算法主要针对边来展开，边数少时效率会非常高，所以对稀疏图有很大的优势；** \n**而普里姆算法对于稠密图，即边数非常多的情况会更好一些。**\n\n**图解**\n1、将连通网中的边转化为边集数组，并对它们按权值从小到大排序。 \n \n![1]($resource/1.png)\n![2]($resource/2.png)\n2、去掉所有边，得到 T={A,B,C,D,E,F,G,H,I,{}}T={A,B,C,D,E,F,G,H,I,{}}。 \n\n3、对边集数组做循环遍历，开始时，i=0，找到第 1 条边，两顶点为 EE 与 HH，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H)}}T={A,B,C,D,E,F,G,H,I,{(E,H)}}。 \n \n![8]($resource/8.jpg)\n4、i=1，找到第 2 条边，两顶点为 CC 与 II，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I)}}。 \n5、i=2，找到第 3 条边，两顶点为 AA 与 BB，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B)}}。 \n \n![9]($resource/9.jpg)\n6、i=3，找到第 4 条边，两顶点为 AA 与 FF，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F)}} \n7、i=4，找到第 5 条边，两顶点为 BB 与 II，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I)}} \n \n![10]($resource/10.jpg)\n8、i=5，找到第 6 条边，两顶点为 DD 与 HH，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H)}} \n9、i=6，找到第 7 条边，两顶点为 BB 与 GG，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H),(B,G)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H),(B,G)}} \n \n![11]($resource/11.jpg)\n10、i=7，找到第 8 条边，两顶点为 GG 与 FF，它们属于同一棵树，舍去。再找 i=8，两顶点为 BB 与 CC，它们属于同一棵树，舍去。再找 i=9，两顶点为 GG 与 HH，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H),(B,G),(G,H)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H),(B,G),(G,H)}}。 \n11、此后的循环均造成环路，最终最小生成树如下。 \n![12]($resource/12.jpg)\n\n**时间复杂度**\n找边的两顶点是否属于同一棵树的时间复杂度为 O(loge)，而外面有一个 for 循环 e 次。所以克鲁斯卡尔算法的时间复杂度为 O(eloge)（e表示边的条数）。\n\n代码：\n```c\n/* 查找连线顶点的尾部下标 */\nint Find(int *parent, int f)\n{\n\twhile( parent[f] > 0 ) //表示有环路\n\t{\n\t\tf = parent[f];\n\t}\n\t\n\treturn f;\n}\n\n// Kruskal算法生成最小生成树\nvoid MiniSpanTree_Kruskal(MGraph G) //生成最小生成树\n{\n\tint i, n, m;\n\tEdge edges[MAGEDGE];\t// 定义边集数组\n\tint parent[MAXVEX];\t\t// 定义一数组用来判断边与边是否形成环路\n\t/* 此处省略将邻接矩阵G转换为边集数组edges并按照权值大小进行排序的代码 */\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tparent[i] = 0; //初始化数组值为0\n\t}\n\t\n\tfor( i=0; i < G.numEdges; i++ ) //循环每一条边\n\t{\n\t\tn = Find(parent, edges[i].begin);\t\n\t\tm = Find(parent, edges[i].end);\t\t\n\t\t\n\t\tif( n != m )\t\t// 加入n与m不等，说明此边没有与现有生成树形成环路\n\t\t{\n\t\t\tparent[n] = m;\t// 将此边的结尾结点放入下标为起点的parent中，说明此顶点已经在生成树的集合中；\n\t\t\tprintf(\"(%d, %d) %d \", edges[i].begin, edges[i].end, edges[i].weight);\n\t\t}\n\t}\n}\n```\n\n\n\n## 7.7 最短路径\n\n==迪杰斯克拉算法求的是一个顶点到所有顶点的最短路径；==\n==弗洛伊德算法求的是所有顶点到所有顶点的最短路径；==\n\n在网图和非网图中，最短路径的含义是不同的。\n- 网图是两顶点经过的边上权值之和最少的路径。\n- 非网图是两顶点之间经过的边数最少的路径。非网图可以理解称为所有边权值均为1的网；\n\n- **迪杰斯克拉（Dijkstra）算法**\n这里的迪杰斯克拉算法仅仅适用于无孤立点的图\n==解决了某个源点到其余各顶点的最短路径==\n原理见书本P259\n![迪杰斯克拉邻接矩阵]($resource/%E8%BF%AA%E6%9D%B0%E6%96%AF%E5%85%8B%E6%8B%89%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png)\n\n程序代码：\n```c\n#define MAXVEX 20\n#define INFINITY 65535\ntypedef int Patharc[MAXVEX];    /* 用于存储最短路径下标的数组 */\ntypedef int ShortPathTable[MAXVEX];/* 用于存储到各点最短路径的权值和 */\n\n/*  Dijkstra算法，求有向网G的v0顶点到其余顶点v的最短路径P[v]及带权长度D[v] */    \n/*  P[v]的值为前驱顶点下标,D[v]表示v0到v的最短路径长度和 */  \nvoid ShortestPath_Dijkstra(MGraph G, int v0, Patharc *P, ShortPathTable *D)\n{    \n\tint v,w,k,min;    \n\tint final[MAXVEX];/* final[w]=1表示求得顶点v0至vw的最短路径 */\n\tfor(v=0; v<G.numVertexes; v++)    /* 初始化数据 */\n\t{        \n\t\tfinal[v] = 0;\t\t\t/* 全部顶点初始化为未知最短路径状态 */\n\t\t(*D)[v] = G.arc[v0][v];/* 将与v0点有连线的顶点加上权值 */\n\t\t(*P)[v] = -1;\t\t\t\t/* 初始化路径数组P为-1  */       \n\t}\n\n\t(*D)[v0] = 0;  /* v0至v0路径为0 */  \n\tfinal[v0] = 1;    /* v0至v0不需要求路径 */        \n\t/* 开始主循环，每次求得v0到某个v顶点的最短路径 */   \n\tfor(v=1; v<G.numVertexes; v++)   \n\t{\n\t\tmin=INFINITY;    /* 当前所知离v0顶点的最近距离 */        \n\t\tfor(w=0; w<G.numVertexes; w++) /* 寻找离v0最近的顶点 */    \n\t\t{            \n\t\t\tif(!final[w] && (*D)[w]<min)             \n\t\t\t{                   \n\t\t\t\tk=w;                    \n\t\t\t\tmin = (*D)[w];    /* w顶点离v0顶点更近 */            \n\t\t\t}        \n\t\t}        \n\t\tfinal[k] = 1;    /* 将目前找到的最近的顶点置为1 */\n\t\tfor(w=0; w<G.numVertexes; w++) /* 修正当前最短路径及距离 */\n\t\t{\n\t\t\t/* 如果经过v顶点的路径比现在这条路径的长度短的话 */\n\t\t\tif(!final[w] && (min+G.arc[k][w]<(*D)[w]))   \n\t\t\t{ /*  说明找到了更短的路径，修改D[w]和P[w] */\n\t\t\t\t(*D)[w] = min + G.arc[k][w];  /* 修改当前路径长度 */               \n\t\t\t\t(*P)[w]=k;        \n\t\t\t}       \n\t\t}   \n\t}\n}\n```\n\n算法的时间复杂度：O(n^2);\n则求得所有顶点（任一顶点）到其他任意顶点的最短距离时间复杂度为O(n^3)\n\n- **弗洛伊德（Floyd）算法**\n\n![弗洛伊德算法]($resource/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95.jpg)\n\n![3]($resource/3.png)\n\n![弗洛伊德示例]($resource/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%A4%BA%E4%BE%8B.png)\n\n程序代码如下：\n```c\n#define MAXVEX\t9\n#define INFINITY\t65535\n\ntypedef int Pathmatirx[MAXVEX][MAXVEX];\ntypedef int ShortPathTable[MAXVEX][MAXVEX];\n\nvoid ShortestPath_Floyd(MGraph G, Pathmatirx *P, ShortPathTable *D)\n{\n\tint v, w, k;\n\t\n\t// 初始化D与P\n\tfor( v=0; v < G.numVertexes; v++ )\n\t{\n\t\tfor( w=0; w < G.numVertexes; w++ )\n\t\t{\n\t\t\t(*D)[v][w] = G.matirx[v][w]; //D[V][W]值即为对应点间的权值\n\t\t\t(*P)[v][w] = w; //初始化P\n\t\t}\n\t}\n\t\n\t\n\tfor( k=0; k < G.numVertexes; k++ )\n\t{\n\t\tfor( v=0; v < G.numVertexes; v++ )\n\t\t{\n\t\t\tfor( w=0; w < G.numVertexes; w++ )\n\t\t\t{\n\t\t\t\tif( (*D)[v][w] > (*D)[v][k] + (*D)[k][w] )\n\t\t\t\t{\n\t\t\t\t//如果经过下标为K顶点路径比原两点间路径更短；\n\t\t\t\t//将当前两点间权值设为更小的一个；\n\t\t\t\t\t(*D)[v][w] = (*D)[v][k] + (*D)[k][w];\n\t\t\t\t\t(*P)[v][w] = (*P)[v][k]; //路径设置经过下标为K的顶点\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n## 7.8 拓扑排序\n\n前面两个都是有环的图应用，下面为无环的图应用，即图中没有回路；\n- 一个无环的有向图称为无环图（Directed Acyclic Graph），简称DAG图；\n- 在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称之为AOV网；\n\n- 拓扑序列：设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列V1,V2,……,Vn满足若从顶点Vi到Vj有一条路径，则在顶点序列中顶点Vi必在顶点Vj之前。则我们称这样的顶点序列为一个拓扑序列。\n\n- 拓扑排序：所谓的拓扑排序，其实就是对一个有向图构造拓扑序列的过程。\n\n\n**P272**\n\n\n\n\n\n\n",[[1559434683849,["GJX@GJXAIOU",[[1,42,"**"],[1,44,"**"]],[42,44],[42,48]]],[1559434686143,["GJX@GJXAIOU",[[-1,44," "]],[45,45],[44,44]]],[1559434693420,["GJX@GJXAIOU",[[1,124,"**"],[1,126,"**"]],[124,126],[124,130]]],[1559434697904,["GJX@GJXAIOU",[[1,172,"**"],[1,173,"**"]],[172,173],[172,177]]],[1559434701405,["GJX@GJXAIOU",[[1,205,"**"],[1,208,"**"]],[205,208],[205,212]]],[1559434704069,["GJX@GJXAIOU",[[1,264,"**"],[1,267,"**"]],[264,267],[264,271]]],[1559434706847,["GJX@GJXAIOU",[[1,303,"**"],[1,306,"**"]],[303,306],[303,310]]],[1559434834862,["GJX@GJXAIOU",[[1,339,"**"],[1,340,"**"]],[339,340],[339,344]]],[1559434843807,["GJX@GJXAIOU",[[1,365,"**"],[1,378,"**"]],[365,378],[365,382]]]],null,"GJX@GJXAIOU"],["39d97e85-1ea2-443f-890f-36f562cab6eb",1559435072384,"---\nstyle: summer\n---\n# 图\n\n\n## 7.1 图的定义\n\n-**图**（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。\n- **顶点**：图中的数据元素；    线性表中数据元素称为：元素； 树中数据元素称为：结点\n- **边**：顶点之间的逻辑关系使用边来表示，边集可以是空的；\n- **无向边**：若顶点Vi到Vj之间的边没有方向，则称这条边为无向边(Edge)，用无序偶(Vi,Vj)来表示；\n- **无向图**：即图中任意两个顶点之间的边都是无向边，构成的图示无向图；\n- **有向边**：若从顶点Vi到Vj的边有方向，则称这条边为有向边，也成为**弧**(Arc)，用有序偶<Vi,Vj>来表示，**Vi称为弧尾，Vj称为弧头**。表示方法不能颠倒；\n\n\n![有向图示例]($resource/%E6%97%A0%E5%90%91%E5%9B%BE%E7%A4%BA%E4%BE%8B.jpg)\n\n- 无向边使用小括号`()`表示，有向边使用尖括号`<>`表示。\n- 简单图：在图中不存在顶点到自身的边（就是没有自己到自己的边），且同一个边不重复出现（就是两个顶点之间不存在两条一样的路径）；\n- 无向完全图：无向图中如果任意两个顶点之间都有边；即含有n个顶点的无向完全图拥有`n*(n-1)/2`条边；\n- 有向完全图：有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧；则有向图最多拥有`n(n-1)`条边。\n- 网：带有权值的图\n- 子图：假设有两个图G1=(V1,E1)和G2=(V2,E2)，如果V2⊆V1，E2⊆E1，则称G2为G1的子图(Subgraph)。\n\n### 7.1.2 图的顶点和边间关系\n\n- 对于无向图G=(V,E)，如果边(V1,V2)∈E，则称顶点V1和V2互为邻接点(Adjacent)，即V1和V2相邻接。边(V1,V2)依附(incident)于顶点V1和V2，或者说边(V1,V2)与顶点V1和V2相关联。\n\n- 顶点V的度(Degree)：是和V相关联的边的数目，记为TD(V)；整个图的边数是各个顶点度数和的一半；\n\n- 对于有向图G=(V,E)，如果有<V1,V2>∈E，则称顶点V1邻接到顶点V2，顶点V2邻接自顶点V1。\n\n- 以**顶点V为头的弧**的数目称为V的**入度**(InDegree)，记为ID(V)，以V为尾的弧的数目称为V的**出度**(OutDegree)，记为OD(V)，因此顶点V的度为TD(V)=ID(V)+OD(V)。\n\n- 顶点到另一个顶点路径的长度是路径上的边或弧的数目；\n- 第一个顶点到最后一个顶点相同的路径称为回路或环；\n- 序列中顶点不重复出现的路径称为简单路径，除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。\n\n![简单环]($resource/%E7%AE%80%E5%8D%95%E7%8E%AF.jpg)\n\n### 7.1.3 连通图相关术语\n\n- 在无向图G中，如果从顶点V1到顶点V2有路径，则称V1和V2是连通的，如果对于图中任意两个顶点Vi和Vj都是连通的，则称G是连通图；\n- 无向图中的极大连通子图称为连通分量。\n  - 注意以下概念：\n  - 首先要是子图，并且子图是要连通的；\n  - 连通子图含有极大顶点数；\n  - 具有极大顶点数的连通子图包含依附于这些顶点的所有边。\n- 强连通图：在有向图G中，如果对于每一对Vi到Vj都存在路径（即任意两个结点之间可达），则称G是强连通图；\n- 强连通分量：有向图中的极大强连通子图称为有向图的强连通分量。\n- 一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。（如果一个图有n个顶点和小于n-1条边，则是非连通图，多余n-1条边则必定构成环）。\n- 如果一个有向图恰有一个顶点入度为0，其余顶点的入度均为1，则是一棵有向树。\n\n##  7.2 图的抽象数据类型\n```c\nADT 图(Graph) \n\nData \n\n 顶点的有穷非空集合和边的集合 \n\nOperation \n\n CreateGraph(*G,V,VR):按照顶点集合V和边弧集VR的定义构造图G。 \n\n DestroyGraph(*G):图G存在则销毁。 \n\n LocateVex(G,u):若图G中存在顶点u，则返回图中的位置。 \n\n GetVex(G,v):返回图G中顶点v的值。 \n\n PutVex(G,v,value):将图G中顶点v赋值value。 \n\n FirstAdjvex(G,*v):返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。 \n\n NextAdjVex(G,v,*w):返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个邻接点则返回“空”。 \n\n InsertVex(*G,v):在图G中增添新顶点v. \n\n DeleteVex(*G,v):删除图G中顶点v及其相关的弧。 \n\n InsertArc(*G,v,w):在图G中增添弧<v,w>,若G是无向图，还需要增添对称弧<w,v>。 \n\n DeleteArc(*G,v,w):在图G中删除弧<v,w>，若G是无向图，则还删除对称弧<w,v>。 \n\n DESTraverse(G):对图G中进行深度优先遍历，在遍历过程中对每个顶点调用。 \n\n HFSTraverse(G):对图G中进行广度优先遍历，在遍历过程中对每个顶点调用。 \n\nendADT\n```\n\n\n\n## 7.3 图的存储结构\n\n常见的存储方式：\n- 顺序存储：因为无法使用数据元素在内存中的物理位置来表示元素之间的关系，不行；\n- 多重链表：即以一个数据域和多个指针域组成的结点表示图中的一个顶点，但是如果顶点的度相差很大，按照度数最大的结点设计结点结构会造成浪费，如果每个顶点结点结构不同，会造成操作上的麻烦；\n\n\n图中的存储结构：\n- 邻接矩阵：使用两个数组来表示图，一个一维数组表示顶点信息，一个二维数组（邻接矩阵）表示图中的边或者弧的信息。\n  - 缺点:**对于边数相比顶点树很少的图，该结构较为浪费**；\n![邻接矩阵（无向图）]($resource/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%89.png)\n\n![邻接矩阵（有向图）]($resource/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%89.png)\n\n![邻接矩阵(网图)]($resource/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5(%E7%BD%91%E5%9B%BE).png)\n\n邻接矩阵的创建代码：\n```c\ntypedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码，如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义  */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\ntypedef struct\n{\n\tVertexType vexs[MAXVEX]; /* 顶点表 */\n\tEdgeType arc[MAXVEX][MAXVEX];/* 邻接矩阵，可看作边表 */\n\tint numNodes, numEdges; /* 图中当前的顶点数和边数  */\n}MGraph;\n\n```\n\n建立无向网图的邻接矩阵表示：\n```c\nvoid CreateMGraph(MGraph *G)\n{\n\tint i,j,k,w;\n\tprintf(\"输入顶点数和边数:\\n\");\n\tscanf(\"%d,%d\",&G->numNodes,&G->numEdges); /* 输入顶点数和边数 */\n\tfor(i = 0;i <G->numNodes;i++) /* 读入顶点信息,建立顶点表 */\n\t\tscanf(&G->vexs[i]);\n\tfor(i = 0;i <G->numNodes;i++)\n\t\tfor(j = 0;j <G->numNodes;j++)\n\t\t\tG->arc[i][j]=INFINITY;\t/* 邻接矩阵初始化 */\n\tfor(k = 0;k <G->numEdges;k++) /* 读入numEdges条边，建立邻接矩阵 */\n\t{\n\t\tprintf(\"输入边(vi,vj)上的下标i，下标j和权w:\\n\");\n\t\tscanf(\"%d,%d,%d\",&i,&j,&w); /* 输入边(vi,vj)上的权w */\n\t\tG->arc[i][j]=w; \n\t\tG->arc[j][i]= G->arc[i][j]; /* 因为是无向图，矩阵对称 */\n\t}\n}\n```\n\n对于n个结点e条边的无向网图创建的时间复杂度为：**O(n+n^2 +e)**\n\n- 邻接表：将数组和链表相结合\n  - 图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。\n  - 图中每个顶点Vi的所有邻接点构成一个线性表，由于邻接点的个数不确定，所以我们选择用单链表来存储。\n\n**针对于有向图：邻接表只关心出度，必须通过遍历整个图才能了解入度，逆邻接表反之**\n![邻接表(有向图入度)]($resource/%E9%82%BB%E6%8E%A5%E8%A1%A8(%E6%9C%89%E5%90%91%E5%9B%BE%E5%85%A5%E5%BA%A6).png)\n![邻接表（无向图）]($resource/%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%89.png)\n![邻接表（有向图出度）]($resource/%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E6%9C%89%E5%90%91%E5%9B%BE%E5%87%BA%E5%BA%A6%EF%BC%89.png)\n\n![邻接表（网）]($resource/%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E7%BD%91%EF%BC%89.png)\n\n邻接表结点的定义代码：\n```c\ntypedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEdges; /* 图中当前顶点数和边数 */\n}GraphAdjList;\n```\n\n邻接表的创建：  \n```c\n/* 建立图的邻接表结构 */\nvoid  CreateALGraph(GraphAdjList *G)\n{\n\tint i,j,k;\n\tEdgeNode *e;\n\tprintf(\"输入顶点数和边数:\\n\");\n\tscanf(\"%d,%d\",&G->numNodes,&G->numEdges); /* 输入顶点数和边数 */\n\tfor(i = 0;i < G->numNodes;i++) /* 读入顶点信息,建立顶点表 */\n\t{\n\t\tscanf(&G->adjList[i].data); \t/* 输入顶点信息 */\n\t\tG->adjList[i].firstedge=NULL; \t/* 将边表置为空表 */\n\t}\n\t\n\t\n\tfor(k = 0;k < G->numEdges;k++)/* 建立边表 */\n\t{\n\t\tprintf(\"输入边(vi,vj)上的顶点序号:\\n\");\n\t\tscanf(\"%d,%d\",&i,&j); /* 输入边(vi,vj)上的顶点序号 */\n\t\te=(EdgeNode *)malloc(sizeof(EdgeNode)); /* 向内存申请空间,生成边表结点 */\n\t\te->adjvex=j;\t\t\t\t\t/* 邻接序号为j */                         \n\t\te->next=G->adjList[i].firstedge;\t/* 将e的指针指向当前顶点上指向的结点 */\n\t\tG->adjList[i].firstedge=e;\t\t/* 将当前顶点的指针指向e */               \n\t\t\n\t\te=(EdgeNode *)malloc(sizeof(EdgeNode)); /* 向内存申请空间,生成边表结点 */\n\t\te->adjvex=i;\t\t\t\t\t/* 邻接序号为i */                         \n\t\te->next=G->adjList[j].firstedge;\t/* 将e的指针指向当前顶点上指向的结点 */\n\t\tG->adjList[j].firstedge=e;\t\t/* 将当前顶点的指针指向e */               \n\t}\n}\n```\n\n对于n个顶点e条边来说时间复杂度是：**O(n+e)**\n\n\n- 十字链表：针对于有向图，结合邻接表和逆邻接表；\n\n![十字链表结点结构]($resource/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84.jpg)\n\n![十字链表示例]($resource/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E7%A4%BA%E4%BE%8B.jpg)\n\n时间复杂度和邻接表相同；\n\n\n\n- 邻接多重表：针对无向图的邻接表的优化\n  - 邻接表主要关注顶点，邻接多重表主要关注边的操作，例如对已访问的边的标记，删除某一条边等；\n\n重新定义边表的结点结构：\n![邻接多重表边表结点结构]($resource/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8.jpg)\n\n![邻接多重表示例]($resource/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E7%A4%BA%E4%BE%8B.jpg)\n\n\n\n- 边集数组：关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；\n由两个一维数组构成，一个是存储顶点的信息，另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标(begin)、终点下标(end)和权(weight)组成\n\n![边集数组示例]($resource/%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84%E7%A4%BA%E4%BE%8B.png)\n\n\n\n## 7.5 图的遍历\n\n从图中某一顶点出发访遍图中其余顶点，且每一个顶点仅能被访问一次；\n### 7.5.1 深度优先遍历DepthFirstSearch（DFS）\n可以假定右手原则，在没有碰到重复顶点的情况下，始终走右手边，如果遍历又回到该顶点，并且图中任有顶点未被访问，则另选图中一个未被访问过的顶点作为起始点，重复上述过程，直到图中所有的顶点均被访问过；\n\n深度优先搜索的过程本质上是一个递归的过程，并且通过图转换之后，变成下图的有图之后，就是一棵树的前序遍历。\n\n![深度优先遍历转换图]($resource/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)\n\n下面以无向图为例：\n使用邻接矩阵存储的图的深度搜索操作代码：\n\n```c\ntypedef int Boolean;\t// Boolean代表布尔类型，true or false\nBoolean visited[MAX];\t// 访问标志的数组\n\nvoid DFS(MGraph G, int i)\n{\n\tint j;\n\t\n\tvisited[j] = TRUE;\t\t\t\n\tprintf(\"%c \", G.vexs[i]);\t// 打印顶点，这里的操作可以自定义\n\tfor( j=0; j < G.numVertexes; j++ )\n\t{\n\t\tif( G.arc[i][j]==1 && !visited[j] )\n\t\t{\n\t\t\tDFS(G, j);\t\t\t// 对未访问的邻接顶点递归调用\n\t\t}\n\t}\n}\n\n// 邻接矩阵的深度遍历操作\nvoid DFSTraverse(MGraph G)\n{\n\tint i;\n\t\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// 初始所有顶点状态都是未访问过状态\n\t}\n\t\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// 对未访问过的顶点调用DFS，若是连通图，只会执行一次\n\t\t{\n\t\t\tDFS(G, i);\n\t\t}\n\t}\n```\n\n\n\n\n\n使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// Boolean代表布尔类型，true or false\nBoolean visited[MAX];\t// 访问标志的数组\n\n//邻接表的深度优先递归算法\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data); //打印顶点，这里的操作可以自定义\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->adjvex); //对未访问的邻接顶点递归调用\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 邻接表的深度遍历操作\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// 初始化所有顶点状态都是未访问过状态\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// 对未访问的顶点调用DFS，若是连通图，只执行一次\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n使用两种存储结构的深度优先遍历算法比较：\n对于n个顶点e条边的图：邻接矩阵使用二维数组，时间复杂度为：O(n^2);\n邻接表所需的时间取决于顶点和边的数量，时间复杂度为：O(n+e);\n==对于点多边少的稀疏图：邻接表结构效率更高==\n\n\n### 7.5.2 广度优先遍历（BreadthFirstSearch）BFS\n**图的广度优先遍历类似于树的层次遍历**\n\n![广度优先遍历转换图]($resource/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)\n\n可以使用队列实现对图的广度优先遍历：\n![使用队列实现广度优先遍历]($resource/%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.jpg)\n\n使用邻接矩阵实现的广度遍历算法：\n```c\n//邻接矩阵的广度遍历算法\nvoid BFSTraverse(MGraph G)\n{\n\tint i, j;\n\tQueue Q;\n\t\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\n\t}\n\t\n\tInitQueue( &Q ); //初始化一辅助用的队列\n\t\n\tfor( i=0; i < G.numVertexes; i++ ) //对每一个顶点做循环\n\t{\n\t\tif( !visited[i] ) //若是未访问过就处理\n\t\t{\n\t\t\tprintf(\"%c \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\tvisited[i] = TRUE; //设置当前顶点访问过\n\t\t\tEnQueue(&Q, i); //将此顶点入队列\n\t\t\t\n\t\t\twhile( !QueueEmpty(Q) ) //若当前队列不为空\n\t\t\t{\n\t\t\t\tDeQueue(&Q, &i); //将队中元素出队列，赋值给i\n\t\t\t\tfor( j=0; j < G.numVertexes; j++ )\n\t\t\t\t{\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t\tif( G.art[i][j]==1 && !visited[j] )\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n使用邻接表实现的广度遍历算法：\n```c\n//邻接表的广度遍历算法\nvoid BFSTraverse(GraphAdjList GL)\n{\n\tint i, j;\n\tEdgeNode *p;\n\tQueue Q;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\n\t}\n\t\n\tInitQueue( &Q ); //初始化一辅助用的队列\n\t\n\tfor( i=0; i < GL->numVertexes; i++ ) //对每一个顶点做循环\n\t{\n\t\tif( !visited[i] ) //若是未访问过就处理\n\t\t{\n\t\t    visited[i] = TRUE; //设置当前顶点访问过\n\t\t\tprintf(\"%c \", GL->adjList[i].data); //打印该结点，其他操作均可\n\t\t\tEnQueue(&Q, i); //将此顶点入队列\n\t\t\t\n\t\t\twhile( !QueueEmpty(Q) ) //若当前队列不为空\n\t\t\t{\n\t\t\t\tDeQueue(&Q, &i); //将队中元素出队列，赋值给i\n\t\t\t\tp = GL->adjList[i].firstedge; //找到当前顶点边表链表头指针\n\t\t\t\twhile(p){\n                  if(!visited[p->adjvex]){ //若此顶点未被访问\n                     visited[p->adjvex] = TRUE;\n                     printf(\"%c\",GL->adjList[p->adjvex].data);\n                     EnQueue(&Q,p->adjvex); //将此顶点入队列\n                }\n                p = p->next; //指针指向下一个邻接点\n              }\n\t\t\t}\n\t\t}\n\t}\n}\n```\n图的深度优先遍历和广度优先遍历的时间复杂度是一样的，只是对顶点的访问顺序不同；\n深度优先适合目标比较明确，以找到目标为主要目的的情况；\n广度优先适合在不断扩大遍历返回时候找到相对最优解的情况；\n\n\n\n\n\n## 7.6 最小生成树\n\n概念：构造连通网的最小代价生成树；\n\n- 普里姆（Prim）算法\n\n首先构造图的邻接矩阵：\n![普里姆算法]($resource/%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95.png)\n\n示例理解：\n\n初始状态：\n\n![1]($resource/1.jpg)\n\n\n设置2个数据结构：\n\nlowcost[i]:表示以i为终点的边的最小权值,当lowcost[i]=0说明以i为终点的边的最小权值=0,也就是表示i点加入了MST\n\nmst[i]:表示对应lowcost[i]的起点，即说明边<mst[i],i>是MST的一条边，当mst[i]=0表示起点i加入MST\n\n\n\n我们假设V1是起始点，进行初始化（*代表无限大，即无通路）：\n\n\n\nlowcost[2]=6，lowcost[3]=1，lowcost[4]=5，lowcost[5]=*，lowcost[6]=*\n\nmst[2]=1，mst[3]=1，mst[4]=1，mst[5]=1，mst[6]=1，（所有点默认起点是V1）\n\n\n\n明显看出，以V3为终点的边的权值最小=1，所以边<mst[3],3>=1加入MST\n![2]($resource/2.jpg)\n\n\n此时，因为点V3的加入，需要更新lowcost数组和mst数组：\n\nlowcost[2]=5，lowcost[3]=0，lowcost[4]=5，lowcost[5]=6，lowcost[6]=4\n\nmst[2]=3，mst[3]=0，mst[4]=1，mst[5]=3，mst[6]=3\n\n\n明显看出，以V6为终点的边的权值最小=4，所以边<mst[6],6>=4加入MST\n\n![3]($resource/3.jpg)\n\n\n\n\n此时，因为点V6的加入，需要更新lowcost数组和mst数组：\n\nlowcost[2]=5，lowcost[3]=0，lowcost[4]=2，lowcost[5]=6，lowcost[6]=0\n\nmst[2]=3，mst[3]=0，mst[4]=6，mst[5]=3，mst[6]=0\n\n\n明显看出，以V4为终点的边的权值最小=2，所以边<mst[4],4>=4加入MST\n![4]($resource/4.jpg)\n\n\n\n\n此时，因为点V4的加入，需要更新lowcost数组和mst数组：\n\nlowcost[2]=5，lowcost[3]=0，lowcost[4]=0，lowcost[5]=6，lowcost[6]=0\n\nmst[2]=3，mst[3]=0，mst[4]=0，mst[5]=3，mst[6]=0\n\n\n明显看出，以V2为终点的边的权值最小=5，所以边<mst[2],2>=5加入MST\n\n![5]($resource/5.jpg)\n\n\n\n此时，因为点V2的加入，需要更新lowcost数组和mst数组：\n\nlowcost[2]=0，lowcost[3]=0，lowcost[4]=0，lowcost[5]=3，lowcost[6]=0\n\nmst[2]=0，mst[3]=0，mst[4]=0，mst[5]=2，mst[6]=0\n\n\n很明显，以V5为终点的边的权值最小=3，所以边<mst[5],5>=3加入MST\n\n\nlowcost[2]=0，lowcost[3]=0，lowcost[4]=0，lowcost[5]=0，lowcost[6]=0\n\nmst[2]=0，mst[3]=0，mst[4]=0，mst[5]=0，mst[6]=0\n\n\n至此，MST构建成功，如图所示：\n![6]($resource/6.jpg)\n\n\n\n\n算法程序代码如下：\n```c\n/* Prim算法生成最小生成树  */\nvoid MiniSpanTree_Prim(MGraph G)\n{\n\tint min, i, j, k;\n\tint adjvex[MAXVEX];\t\t/* 保存相关顶点下标 */\n\tint lowcost[MAXVEX];\t/* 保存相关顶点间边的权值 */\n\tlowcost[0] = 0;/* 初始化第一个权值为0，即v0加入生成树 */\n\t\t\t/* lowcost的值为0，在这里就是此下标的顶点已经加入生成树 */\n\tadjvex[0] = 0;\t\t\t/* 初始化第一个顶点下标为0 */\n\tfor(i = 1; i < G.numVertexes; i++)\t/* 循环除下标为0外的全部顶点 */\n\t{\n\t\tlowcost[i] = G.arc[0][i];\t/* 将v0顶点与之有边的权值存入数组 */\n\t\tadjvex[i] = 0;\t\t\t\t\t/* 初始化都为v0的下标 */\n\t}\n\tfor(i = 1; i < G.numVertexes; i++)\n\t{\n\t\tmin = INFINITY;\t/* 初始化最小权值为∞， */\n\t\t\t\t\t\t/* 通常设置为不可能的大数字如32767、65535等 */\n\t\tj = 1;k = 0;\n\t\twhile(j < G.numVertexes)\t/* 循环全部顶点 */\n\t\t{\n\t\t\tif(lowcost[j]!=0 && lowcost[j] < min)/* 如果权值不为0且权值小于min */\n\t\t\t{\t\n\t\t\t\tmin = lowcost[j];\t/* 则让当前权值成为最小值 */\n\t\t\t\tk = j;\t\t\t/* 将当前最小值的下标存入k */\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tprintf(\"(%d, %d)\\n\", adjvex[k], k);/* 打印当前顶点边中权值最小的边 */\n\t\tlowcost[k] = 0;/* 将当前顶点的权值设置为0,表示此顶点已经完成任务 */\n\t\tfor(j = 1; j < G.numVertexes; j++)\t/* 循环所有顶点 */\n\t\t{\n\t\t\tif(lowcost[j]!=0 && G.arc[k][j] < lowcost[j]) \n\t\t\t{/* 如果下标为k顶点各边权值小于此前这些顶点未被加入生成树权值 */\n\t\t\t\tlowcost[j] = G.arc[k][j];/* 将较小的权值存入lowcost相应位置 */\n\t\t\t\tadjvex[j] = k;\t\t\t\t/* 将下标为k的顶点存入adjvex */\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n- 克鲁斯卡尔（Kruskal）算法\n首先通过连通图构建边集数组（按照权值从小到大排序）\n\n**基本思想**\n假设 N=(V,{E})N=(V,{E}) 是连通网：\n\n令最小生成树的初始状态为只有 nn 个顶点并且没有边的非连通图 T={V,{}}T={V,{}} ，图中每个顶点自成一个连通分量。\n在 EE 中选择代价最小的边，若该边的两个顶点落在 TT 中不同的连通分量上，则将此边加入到 TT 中，否则就舍去此边而选择下一条代价最小的边。\n以此类推，直至 TT 中所有顶点都在同一连通分量上为止。\n\n**克鲁斯卡尔算法主要针对边来展开，边数少时效率会非常高，所以对稀疏图有很大的优势；** \n**而普里姆算法对于稠密图，即边数非常多的情况会更好一些。**\n\n**图解**\n1、将连通网中的边转化为边集数组，并对它们按权值从小到大排序。 \n \n![1]($resource/1.png)\n![2]($resource/2.png)\n2、去掉所有边，得到 T={A,B,C,D,E,F,G,H,I,{}}T={A,B,C,D,E,F,G,H,I,{}}。 \n\n3、对边集数组做循环遍历，开始时，i=0，找到第 1 条边，两顶点为 EE 与 HH，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H)}}T={A,B,C,D,E,F,G,H,I,{(E,H)}}。 \n \n![8]($resource/8.jpg)\n4、i=1，找到第 2 条边，两顶点为 CC 与 II，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I)}}。 \n5、i=2，找到第 3 条边，两顶点为 AA 与 BB，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B)}}。 \n \n![9]($resource/9.jpg)\n6、i=3，找到第 4 条边，两顶点为 AA 与 FF，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F)}} \n7、i=4，找到第 5 条边，两顶点为 BB 与 II，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I)}} \n \n![10]($resource/10.jpg)\n8、i=5，找到第 6 条边，两顶点为 DD 与 HH，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H)}} \n9、i=6，找到第 7 条边，两顶点为 BB 与 GG，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H),(B,G)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H),(B,G)}} \n \n![11]($resource/11.jpg)\n10、i=7，找到第 8 条边，两顶点为 GG 与 FF，它们属于同一棵树，舍去。再找 i=8，两顶点为 BB 与 CC，它们属于同一棵树，舍去。再找 i=9，两顶点为 GG 与 HH，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H),(B,G),(G,H)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H),(B,G),(G,H)}}。 \n11、此后的循环均造成环路，最终最小生成树如下。 \n![12]($resource/12.jpg)\n\n**时间复杂度**\n找边的两顶点是否属于同一棵树的时间复杂度为 O(loge)，而外面有一个 for 循环 e 次。所以克鲁斯卡尔算法的时间复杂度为 O(eloge)（e表示边的条数）。\n\n代码：\n```c\n/* 查找连线顶点的尾部下标 */\nint Find(int *parent, int f)\n{\n\twhile( parent[f] > 0 ) //表示有环路\n\t{\n\t\tf = parent[f];\n\t}\n\t\n\treturn f;\n}\n\n// Kruskal算法生成最小生成树\nvoid MiniSpanTree_Kruskal(MGraph G) //生成最小生成树\n{\n\tint i, n, m;\n\tEdge edges[MAGEDGE];\t// 定义边集数组\n\tint parent[MAXVEX];\t\t// 定义一数组用来判断边与边是否形成环路\n\t/* 此处省略将邻接矩阵G转换为边集数组edges并按照权值大小进行排序的代码 */\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tparent[i] = 0; //初始化数组值为0\n\t}\n\t\n\tfor( i=0; i < G.numEdges; i++ ) //循环每一条边\n\t{\n\t\tn = Find(parent, edges[i].begin);\t\n\t\tm = Find(parent, edges[i].end);\t\t\n\t\t\n\t\tif( n != m )\t\t// 加入n与m不等，说明此边没有与现有生成树形成环路\n\t\t{\n\t\t\tparent[n] = m;\t// 将此边的结尾结点放入下标为起点的parent中，说明此顶点已经在生成树的集合中；\n\t\t\tprintf(\"(%d, %d) %d \", edges[i].begin, edges[i].end, edges[i].weight);\n\t\t}\n\t}\n}\n```\n\n\n\n## 7.7 最短路径\n\n==迪杰斯克拉算法求的是一个顶点到所有顶点的最短路径；==\n==弗洛伊德算法求的是所有顶点到所有顶点的最短路径；==\n\n在网图和非网图中，最短路径的含义是不同的。\n- 网图是两顶点经过的边上权值之和最少的路径。\n- 非网图是两顶点之间经过的边数最少的路径。非网图可以理解称为所有边权值均为1的网；\n\n- **迪杰斯克拉（Dijkstra）算法**\n这里的迪杰斯克拉算法仅仅适用于无孤立点的图\n==解决了某个源点到其余各顶点的最短路径==\n原理见书本P259\n![迪杰斯克拉邻接矩阵]($resource/%E8%BF%AA%E6%9D%B0%E6%96%AF%E5%85%8B%E6%8B%89%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png)\n\n程序代码：\n```c\n#define MAXVEX 20\n#define INFINITY 65535\ntypedef int Patharc[MAXVEX];    /* 用于存储最短路径下标的数组 */\ntypedef int ShortPathTable[MAXVEX];/* 用于存储到各点最短路径的权值和 */\n\n/*  Dijkstra算法，求有向网G的v0顶点到其余顶点v的最短路径P[v]及带权长度D[v] */    \n/*  P[v]的值为前驱顶点下标,D[v]表示v0到v的最短路径长度和 */  \nvoid ShortestPath_Dijkstra(MGraph G, int v0, Patharc *P, ShortPathTable *D)\n{    \n\tint v,w,k,min;    \n\tint final[MAXVEX];/* final[w]=1表示求得顶点v0至vw的最短路径 */\n\tfor(v=0; v<G.numVertexes; v++)    /* 初始化数据 */\n\t{        \n\t\tfinal[v] = 0;\t\t\t/* 全部顶点初始化为未知最短路径状态 */\n\t\t(*D)[v] = G.arc[v0][v];/* 将与v0点有连线的顶点加上权值 */\n\t\t(*P)[v] = -1;\t\t\t\t/* 初始化路径数组P为-1  */       \n\t}\n\n\t(*D)[v0] = 0;  /* v0至v0路径为0 */  \n\tfinal[v0] = 1;    /* v0至v0不需要求路径 */        \n\t/* 开始主循环，每次求得v0到某个v顶点的最短路径 */   \n\tfor(v=1; v<G.numVertexes; v++)   \n\t{\n\t\tmin=INFINITY;    /* 当前所知离v0顶点的最近距离 */        \n\t\tfor(w=0; w<G.numVertexes; w++) /* 寻找离v0最近的顶点 */    \n\t\t{            \n\t\t\tif(!final[w] && (*D)[w]<min)             \n\t\t\t{                   \n\t\t\t\tk=w;                    \n\t\t\t\tmin = (*D)[w];    /* w顶点离v0顶点更近 */            \n\t\t\t}        \n\t\t}        \n\t\tfinal[k] = 1;    /* 将目前找到的最近的顶点置为1 */\n\t\tfor(w=0; w<G.numVertexes; w++) /* 修正当前最短路径及距离 */\n\t\t{\n\t\t\t/* 如果经过v顶点的路径比现在这条路径的长度短的话 */\n\t\t\tif(!final[w] && (min+G.arc[k][w]<(*D)[w]))   \n\t\t\t{ /*  说明找到了更短的路径，修改D[w]和P[w] */\n\t\t\t\t(*D)[w] = min + G.arc[k][w];  /* 修改当前路径长度 */               \n\t\t\t\t(*P)[w]=k;        \n\t\t\t}       \n\t\t}   \n\t}\n}\n```\n\n算法的时间复杂度：O(n^2);\n则求得所有顶点（任一顶点）到其他任意顶点的最短距离时间复杂度为O(n^3)\n\n- **弗洛伊德（Floyd）算法**\n\n![弗洛伊德算法]($resource/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95.jpg)\n\n![3]($resource/3.png)\n\n![弗洛伊德示例]($resource/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%A4%BA%E4%BE%8B.png)\n\n程序代码如下：\n```c\n#define MAXVEX\t9\n#define INFINITY\t65535\n\ntypedef int Pathmatirx[MAXVEX][MAXVEX];\ntypedef int ShortPathTable[MAXVEX][MAXVEX];\n\nvoid ShortestPath_Floyd(MGraph G, Pathmatirx *P, ShortPathTable *D)\n{\n\tint v, w, k;\n\t\n\t// 初始化D与P\n\tfor( v=0; v < G.numVertexes; v++ )\n\t{\n\t\tfor( w=0; w < G.numVertexes; w++ )\n\t\t{\n\t\t\t(*D)[v][w] = G.matirx[v][w]; //D[V][W]值即为对应点间的权值\n\t\t\t(*P)[v][w] = w; //初始化P\n\t\t}\n\t}\n\t\n\t\n\tfor( k=0; k < G.numVertexes; k++ )\n\t{\n\t\tfor( v=0; v < G.numVertexes; v++ )\n\t\t{\n\t\t\tfor( w=0; w < G.numVertexes; w++ )\n\t\t\t{\n\t\t\t\tif( (*D)[v][w] > (*D)[v][k] + (*D)[k][w] )\n\t\t\t\t{\n\t\t\t\t//如果经过下标为K顶点路径比原两点间路径更短；\n\t\t\t\t//将当前两点间权值设为更小的一个；\n\t\t\t\t\t(*D)[v][w] = (*D)[v][k] + (*D)[k][w];\n\t\t\t\t\t(*P)[v][w] = (*P)[v][k]; //路径设置经过下标为K的顶点\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n## 7.8 拓扑排序\n\n前面两个都是有环的图应用，下面为无环的图应用，即图中没有回路；\n- 一个无环的有向图称为无环图（Directed Acyclic Graph），简称DAG图；\n- 在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称之为AOV网；\n\n- 拓扑序列：设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列V1,V2,……,Vn满足若从顶点Vi到Vj有一条路径，则在顶点序列中顶点Vi必在顶点Vj之前。则我们称这样的顶点序列为一个拓扑序列。\n\n- 拓扑排序：所谓的拓扑排序，其实就是对一个有向图构造拓扑序列的过程。\n\n\n**P272**\n\n\n\n\n\n\n",[[1559435055003,["GJX@GJXAIOU",[[-1,419,"7%A0"],[1,423,"C%89"],[1,459,"%202"]],[395,464],[468,468]]],[1559435099020,["GJX@GJXAIOU",[[1,505,"**"],[1,508,"**"]],[505,508],[505,512]]],[1559435103228,["GJX@GJXAIOU",[[1,574,"**"],[1,579,"**"]],[574,579],[574,583]]],[1559435125828,["GJX@GJXAIOU",[[1,590,"**"],[1,601,"**"]],[590,601],[590,605]]],[1559435153677,["GJX@GJXAIOU",[[1,695,"**"],[1,696,"**"]],[695,696],[695,700]]],[1559435156891,["GJX@GJXAIOU",[[1,710,"**"],[1,712,"**"]],[710,712],[710,716]]],[1559435236358,["GJX@GJXAIOU",[[1,842,"**"],[1,845,"**"]],[842,845],[842,849]]],[1559435241272,["GJX@GJXAIOU",[[1,926,"**"],[1,931,"**"]],[926,931],[926,935]]],[1559435461522,["GJX@GJXAIOU",[[1,1054,"（）"]],[1054,1054],[1056,1056]]],[1559435470476,["GJX@GJXAIOU",[[1,1055,"即指向V的弧"]],[1055,1055],[1061,1061]]],[1559435555140,["GJX@GJXAIOU",[[1,1286,"与非简单环"]],[1286,1286],[1291,1291]]]],null,"GJX@GJXAIOU"],["b1bd19e1-a20d-4499-b46f-92b945a00533",1559435627254,"---\nstyle: summer\n---\n# 图\n\n\n## 7.1 图的定义\n\n-**图**（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。\n- **顶点**：图中的数据元素；    线性表中数据元素称为：元素； 树中数据元素称为：结点\n- **边**：顶点之间的逻辑关系使用边来表示，边集可以是空的；\n- **无向边**：若顶点Vi到Vj之间的边没有方向，则称这条边为无向边(Edge)，用无序偶(Vi,Vj)来表示；\n- **无向图**：即图中任意两个顶点之间的边都是无向边，构成的图示无向图；\n- **有向边**：若从顶点Vi到Vj的边有方向，则称这条边为有向边，也成为**弧**(Arc)，用有序偶<Vi,Vj>来表示，**Vi称为弧尾，Vj称为弧头**。表示方法不能颠倒；\n\n\n![有向图示例]($resource/%E6%9C%89%E5%90%91%E5%9B%BE%E7%A4%BA%E4%BE%8B%202.jpg)\n\n- 无向边使用小括号`()`表示，有向边使用尖括号`<>`表示。\n- **简单图**：在图中不存在顶点到自身的边（就是没有自己到自己的边），且同一个边不重复出现（就是两个顶点之间不存在两条一样的路径）；\n- **无向完全图**：无向图中如果**任意两个顶点之间都有边**；即含有n个顶点的无向完全图拥有`n*(n-1)/2`条边；\n- 有向完全图：有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧；则有向图最多拥有`n(n-1)`条边。\n- **网**：带有权值的图\n- **子图**：假设有两个图G1=(V1,E1)和G2=(V2,E2)，如果V2⊆V1，E2⊆E1，则称G2为G1的子图(Subgraph)。\n\n### 7.1.2 图的顶点和边间关系\n\n- 对于无向图G=(V,E)，如果边(V1,V2)∈E，则称顶点V1和V2互为**邻接点**(Adjacent)，即V1和V2相邻接。边(V1,V2)依附(incident)于顶点V1和V2，或者说边(V1,V2)与顶点V1和V2相关联。\n\n- **顶点V的度**(Degree)：是和V相关联的边的数目，记为TD(V)；整个图的边数是各个顶点度数和的一半；\n\n- 对于有向图G=(V,E)，如果有<V1,V2>∈E，则称顶点V1邻接到顶点V2，顶点V2邻接自顶点V1。\n\n- 以**顶点V为头的弧**（即指向V的弧）的数目称为V的**入度**(InDegree)，记为ID(V)，以V为尾的弧的数目称为V的**出度**(OutDegree)，记为OD(V)，因此顶点V的度为TD(V)=ID(V)+OD(V)。\n\n- 顶点到另一个顶点路径的长度是路径上的边或弧的数目；\n- 第一个顶点到最后一个顶点相同的路径称为回路或环；\n- 序列中顶点不重复出现的路径称为简单路径，除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。\n\n![简单环与非简单环]($resource/%E7%AE%80%E5%8D%95%E7%8E%AF.jpg)\n\n### 7.1.3 连通图相关术语\n\n- 在无向图G中，如果从顶点V1到顶点V2有路径，则称V1和V2是连通的，如果对于图中任意两个顶点Vi和Vj都是连通的，则称G是连通图；\n- 无向图中的极大连通子图称为连通分量。\n  - 注意以下概念：\n  - 首先要是子图，并且子图是要连通的；\n  - 连通子图含有极大顶点数；\n  - 具有极大顶点数的连通子图包含依附于这些顶点的所有边。\n- 强连通图：在有向图G中，如果对于每一对Vi到Vj都存在路径（即任意两个结点之间可达），则称G是强连通图；\n- 强连通分量：有向图中的极大强连通子图称为有向图的强连通分量。\n- 一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。（如果一个图有n个顶点和小于n-1条边，则是非连通图，多余n-1条边则必定构成环）。\n- 如果一个有向图恰有一个顶点入度为0，其余顶点的入度均为1，则是一棵有向树。\n\n##  7.2 图的抽象数据类型\n```c\nADT 图(Graph) \n\nData \n\n 顶点的有穷非空集合和边的集合 \n\nOperation \n\n CreateGraph(*G,V,VR):按照顶点集合V和边弧集VR的定义构造图G。 \n\n DestroyGraph(*G):图G存在则销毁。 \n\n LocateVex(G,u):若图G中存在顶点u，则返回图中的位置。 \n\n GetVex(G,v):返回图G中顶点v的值。 \n\n PutVex(G,v,value):将图G中顶点v赋值value。 \n\n FirstAdjvex(G,*v):返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。 \n\n NextAdjVex(G,v,*w):返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个邻接点则返回“空”。 \n\n InsertVex(*G,v):在图G中增添新顶点v. \n\n DeleteVex(*G,v):删除图G中顶点v及其相关的弧。 \n\n InsertArc(*G,v,w):在图G中增添弧<v,w>,若G是无向图，还需要增添对称弧<w,v>。 \n\n DeleteArc(*G,v,w):在图G中删除弧<v,w>，若G是无向图，则还删除对称弧<w,v>。 \n\n DESTraverse(G):对图G中进行深度优先遍历，在遍历过程中对每个顶点调用。 \n\n HFSTraverse(G):对图G中进行广度优先遍历，在遍历过程中对每个顶点调用。 \n\nendADT\n```\n\n\n\n## 7.3 图的存储结构\n\n常见的存储方式：\n- 顺序存储：因为无法使用数据元素在内存中的物理位置来表示元素之间的关系，不行；\n- 多重链表：即以一个数据域和多个指针域组成的结点表示图中的一个顶点，但是如果顶点的度相差很大，按照度数最大的结点设计结点结构会造成浪费，如果每个顶点结点结构不同，会造成操作上的麻烦；\n\n\n图中的存储结构：\n- 邻接矩阵：使用两个数组来表示图，一个一维数组表示顶点信息，一个二维数组（邻接矩阵）表示图中的边或者弧的信息。\n  - 缺点:**对于边数相比顶点树很少的图，该结构较为浪费**；\n![邻接矩阵（无向图）]($resource/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%89.png)\n\n![邻接矩阵（有向图）]($resource/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%89.png)\n\n![邻接矩阵(网图)]($resource/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5(%E7%BD%91%E5%9B%BE).png)\n\n邻接矩阵的创建代码：\n```c\ntypedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码，如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义  */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\ntypedef struct\n{\n\tVertexType vexs[MAXVEX]; /* 顶点表 */\n\tEdgeType arc[MAXVEX][MAXVEX];/* 邻接矩阵，可看作边表 */\n\tint numNodes, numEdges; /* 图中当前的顶点数和边数  */\n}MGraph;\n\n```\n\n建立无向网图的邻接矩阵表示：\n```c\nvoid CreateMGraph(MGraph *G)\n{\n\tint i,j,k,w;\n\tprintf(\"输入顶点数和边数:\\n\");\n\tscanf(\"%d,%d\",&G->numNodes,&G->numEdges); /* 输入顶点数和边数 */\n\tfor(i = 0;i <G->numNodes;i++) /* 读入顶点信息,建立顶点表 */\n\t\tscanf(&G->vexs[i]);\n\tfor(i = 0;i <G->numNodes;i++)\n\t\tfor(j = 0;j <G->numNodes;j++)\n\t\t\tG->arc[i][j]=INFINITY;\t/* 邻接矩阵初始化 */\n\tfor(k = 0;k <G->numEdges;k++) /* 读入numEdges条边，建立邻接矩阵 */\n\t{\n\t\tprintf(\"输入边(vi,vj)上的下标i，下标j和权w:\\n\");\n\t\tscanf(\"%d,%d,%d\",&i,&j,&w); /* 输入边(vi,vj)上的权w */\n\t\tG->arc[i][j]=w; \n\t\tG->arc[j][i]= G->arc[i][j]; /* 因为是无向图，矩阵对称 */\n\t}\n}\n```\n\n对于n个结点e条边的无向网图创建的时间复杂度为：**O(n+n^2 +e)**\n\n- 邻接表：将数组和链表相结合\n  - 图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。\n  - 图中每个顶点Vi的所有邻接点构成一个线性表，由于邻接点的个数不确定，所以我们选择用单链表来存储。\n\n**针对于有向图：邻接表只关心出度，必须通过遍历整个图才能了解入度，逆邻接表反之**\n![邻接表(有向图入度)]($resource/%E9%82%BB%E6%8E%A5%E8%A1%A8(%E6%9C%89%E5%90%91%E5%9B%BE%E5%85%A5%E5%BA%A6).png)\n![邻接表（无向图）]($resource/%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%89.png)\n![邻接表（有向图出度）]($resource/%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E6%9C%89%E5%90%91%E5%9B%BE%E5%87%BA%E5%BA%A6%EF%BC%89.png)\n\n![邻接表（网）]($resource/%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E7%BD%91%EF%BC%89.png)\n\n邻接表结点的定义代码：\n```c\ntypedef int Status;\t/* Status是函数的类型,其值是函数结果状态代码,如OK等 */\ntypedef char VertexType; /* 顶点类型应由用户定义 */\ntypedef int EdgeType; /* 边上的权值类型应由用户定义 */\n\ntypedef struct EdgeNode /* 边表结点  */\n{\n\tint adjvex;    /* 邻接点域,存储该顶点对应的下标 */\n\tEdgeType info;\t\t/* 用于存储权值,对于非网图可以不需要 */\n\tstruct EdgeNode *next; /* 链域,指向下一个邻接点 */\n}EdgeNode;\n\ntypedef struct VertexNode /* 顶点表结点 */\n{\n\tVertexType data; /* 顶点域,存储顶点信息 */\n\tEdgeNode *firstedge;/* 边表头指针 */\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct\n{\n\tAdjList adjList; \n\tint numNodes,numEdges; /* 图中当前顶点数和边数 */\n}GraphAdjList;\n```\n\n邻接表的创建：  \n```c\n/* 建立图的邻接表结构 */\nvoid  CreateALGraph(GraphAdjList *G)\n{\n\tint i,j,k;\n\tEdgeNode *e;\n\tprintf(\"输入顶点数和边数:\\n\");\n\tscanf(\"%d,%d\",&G->numNodes,&G->numEdges); /* 输入顶点数和边数 */\n\tfor(i = 0;i < G->numNodes;i++) /* 读入顶点信息,建立顶点表 */\n\t{\n\t\tscanf(&G->adjList[i].data); \t/* 输入顶点信息 */\n\t\tG->adjList[i].firstedge=NULL; \t/* 将边表置为空表 */\n\t}\n\t\n\t\n\tfor(k = 0;k < G->numEdges;k++)/* 建立边表 */\n\t{\n\t\tprintf(\"输入边(vi,vj)上的顶点序号:\\n\");\n\t\tscanf(\"%d,%d\",&i,&j); /* 输入边(vi,vj)上的顶点序号 */\n\t\te=(EdgeNode *)malloc(sizeof(EdgeNode)); /* 向内存申请空间,生成边表结点 */\n\t\te->adjvex=j;\t\t\t\t\t/* 邻接序号为j */                         \n\t\te->next=G->adjList[i].firstedge;\t/* 将e的指针指向当前顶点上指向的结点 */\n\t\tG->adjList[i].firstedge=e;\t\t/* 将当前顶点的指针指向e */               \n\t\t\n\t\te=(EdgeNode *)malloc(sizeof(EdgeNode)); /* 向内存申请空间,生成边表结点 */\n\t\te->adjvex=i;\t\t\t\t\t/* 邻接序号为i */                         \n\t\te->next=G->adjList[j].firstedge;\t/* 将e的指针指向当前顶点上指向的结点 */\n\t\tG->adjList[j].firstedge=e;\t\t/* 将当前顶点的指针指向e */               \n\t}\n}\n```\n\n对于n个顶点e条边来说时间复杂度是：**O(n+e)**\n\n\n- 十字链表：针对于有向图，结合邻接表和逆邻接表；\n\n![十字链表结点结构]($resource/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84.jpg)\n\n![十字链表示例]($resource/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E7%A4%BA%E4%BE%8B.jpg)\n\n时间复杂度和邻接表相同；\n\n\n\n- 邻接多重表：针对无向图的邻接表的优化\n  - 邻接表主要关注顶点，邻接多重表主要关注边的操作，例如对已访问的边的标记，删除某一条边等；\n\n重新定义边表的结点结构：\n![邻接多重表边表结点结构]($resource/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8.jpg)\n\n![邻接多重表示例]($resource/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E7%A4%BA%E4%BE%8B.jpg)\n\n\n\n- 边集数组：关注的是边的集合，查找顶点需要扫描整个边数组，适合对边进行操作；\n由两个一维数组构成，一个是存储顶点的信息，另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标(begin)、终点下标(end)和权(weight)组成\n\n![边集数组示例]($resource/%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84%E7%A4%BA%E4%BE%8B.png)\n\n\n\n## 7.5 图的遍历\n\n从图中某一顶点出发访遍图中其余顶点，且每一个顶点仅能被访问一次；\n### 7.5.1 深度优先遍历DepthFirstSearch（DFS）\n可以假定右手原则，在没有碰到重复顶点的情况下，始终走右手边，如果遍历又回到该顶点，并且图中任有顶点未被访问，则另选图中一个未被访问过的顶点作为起始点，重复上述过程，直到图中所有的顶点均被访问过；\n\n深度优先搜索的过程本质上是一个递归的过程，并且通过图转换之后，变成下图的有图之后，就是一棵树的前序遍历。\n\n![深度优先遍历转换图]($resource/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)\n\n下面以无向图为例：\n使用邻接矩阵存储的图的深度搜索操作代码：\n\n```c\ntypedef int Boolean;\t// Boolean代表布尔类型，true or false\nBoolean visited[MAX];\t// 访问标志的数组\n\nvoid DFS(MGraph G, int i)\n{\n\tint j;\n\t\n\tvisited[j] = TRUE;\t\t\t\n\tprintf(\"%c \", G.vexs[i]);\t// 打印顶点，这里的操作可以自定义\n\tfor( j=0; j < G.numVertexes; j++ )\n\t{\n\t\tif( G.arc[i][j]==1 && !visited[j] )\n\t\t{\n\t\t\tDFS(G, j);\t\t\t// 对未访问的邻接顶点递归调用\n\t\t}\n\t}\n}\n\n// 邻接矩阵的深度遍历操作\nvoid DFSTraverse(MGraph G)\n{\n\tint i;\n\t\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// 初始所有顶点状态都是未访问过状态\n\t}\n\t\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// 对未访问过的顶点调用DFS，若是连通图，只会执行一次\n\t\t{\n\t\t\tDFS(G, i);\n\t\t}\n\t}\n```\n\n\n\n\n\n使用邻接表存储的图的深度搜索操作代码：\n```c\ntypedef int Boolean;\t// Boolean代表布尔类型，true or false\nBoolean visited[MAX];\t// 访问标志的数组\n\n//邻接表的深度优先递归算法\nvoid DFS(GraphAdjList GL, int i)\n{\n\tEdgeNode *p;\n\t\n\tvisited[i] = TRUE;\n\tprintf(\"%c \" GL->adjList[i].data); //打印顶点，这里的操作可以自定义\n\tp = GL->adjList[i].firstEdge;\n\t\n\twhile(p)\n\t{\n\t\tif( !visited[p->adjvex] )\n\t\t{\n\t\t\tDFS(GL, p->adjvex); //对未访问的邻接顶点递归调用\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n// 邻接表的深度遍历操作\nvoid DFSTraverse(GraphAdjList GL)\n{\n\tint i;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\t\t// 初始化所有顶点状态都是未访问过状态\n\t}\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tif( !visited[i] )\t\t// 对未访问的顶点调用DFS，若是连通图，只执行一次\n\t\t{\n\t\t\tDFS(GL, i);\n\t\t}\n\t}\n}\n```\n\n使用两种存储结构的深度优先遍历算法比较：\n对于n个顶点e条边的图：邻接矩阵使用二维数组，时间复杂度为：O(n^2);\n邻接表所需的时间取决于顶点和边的数量，时间复杂度为：O(n+e);\n==对于点多边少的稀疏图：邻接表结构效率更高==\n\n\n### 7.5.2 广度优先遍历（BreadthFirstSearch）BFS\n**图的广度优先遍历类似于树的层次遍历**\n\n![广度优先遍历转换图]($resource/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)\n\n可以使用队列实现对图的广度优先遍历：\n![使用队列实现广度优先遍历]($resource/%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.jpg)\n\n使用邻接矩阵实现的广度遍历算法：\n```c\n//邻接矩阵的广度遍历算法\nvoid BFSTraverse(MGraph G)\n{\n\tint i, j;\n\tQueue Q;\n\t\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\n\t}\n\t\n\tInitQueue( &Q ); //初始化一辅助用的队列\n\t\n\tfor( i=0; i < G.numVertexes; i++ ) //对每一个顶点做循环\n\t{\n\t\tif( !visited[i] ) //若是未访问过就处理\n\t\t{\n\t\t\tprintf(\"%c \", G.vex[i]); //打印该结点，其他操作均可\n\t\t\tvisited[i] = TRUE; //设置当前顶点访问过\n\t\t\tEnQueue(&Q, i); //将此顶点入队列\n\t\t\t\n\t\t\twhile( !QueueEmpty(Q) ) //若当前队列不为空\n\t\t\t{\n\t\t\t\tDeQueue(&Q, &i); //将队中元素出队列，赋值给i\n\t\t\t\tfor( j=0; j < G.numVertexes; j++ )\n\t\t\t\t{\n\t\t\t\t  //判断其他顶点若与当前顶点存在边且未被访问过\n\t\t\t\t\tif( G.art[i][j]==1 && !visited[j] )\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%c \", G.vex[j]);\n\t\t\t\t\t\tvisited[j] = TRUE; //将找到的此顶点标记为已访问\n\t\t\t\t\t\tEnQueue(&Q, j); //将找到的此顶点入队列\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n使用邻接表实现的广度遍历算法：\n```c\n//邻接表的广度遍历算法\nvoid BFSTraverse(GraphAdjList GL)\n{\n\tint i, j;\n\tEdgeNode *p;\n\tQueue Q;\n\t\n\tfor( i=0; i < GL->numVertexes; i++ )\n\t{\n\t\tvisited[i] = FALSE;\n\t}\n\t\n\tInitQueue( &Q ); //初始化一辅助用的队列\n\t\n\tfor( i=0; i < GL->numVertexes; i++ ) //对每一个顶点做循环\n\t{\n\t\tif( !visited[i] ) //若是未访问过就处理\n\t\t{\n\t\t    visited[i] = TRUE; //设置当前顶点访问过\n\t\t\tprintf(\"%c \", GL->adjList[i].data); //打印该结点，其他操作均可\n\t\t\tEnQueue(&Q, i); //将此顶点入队列\n\t\t\t\n\t\t\twhile( !QueueEmpty(Q) ) //若当前队列不为空\n\t\t\t{\n\t\t\t\tDeQueue(&Q, &i); //将队中元素出队列，赋值给i\n\t\t\t\tp = GL->adjList[i].firstedge; //找到当前顶点边表链表头指针\n\t\t\t\twhile(p){\n                  if(!visited[p->adjvex]){ //若此顶点未被访问\n                     visited[p->adjvex] = TRUE;\n                     printf(\"%c\",GL->adjList[p->adjvex].data);\n                     EnQueue(&Q,p->adjvex); //将此顶点入队列\n                }\n                p = p->next; //指针指向下一个邻接点\n              }\n\t\t\t}\n\t\t}\n\t}\n}\n```\n图的深度优先遍历和广度优先遍历的时间复杂度是一样的，只是对顶点的访问顺序不同；\n深度优先适合目标比较明确，以找到目标为主要目的的情况；\n广度优先适合在不断扩大遍历返回时候找到相对最优解的情况；\n\n\n\n\n\n## 7.6 最小生成树\n\n概念：构造连通网的最小代价生成树；\n\n- 普里姆（Prim）算法\n\n首先构造图的邻接矩阵：\n![普里姆算法]($resource/%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95.png)\n\n示例理解：\n\n初始状态：\n\n![1]($resource/1.jpg)\n\n\n设置2个数据结构：\n\nlowcost[i]:表示以i为终点的边的最小权值,当lowcost[i]=0说明以i为终点的边的最小权值=0,也就是表示i点加入了MST\n\nmst[i]:表示对应lowcost[i]的起点，即说明边<mst[i],i>是MST的一条边，当mst[i]=0表示起点i加入MST\n\n\n\n我们假设V1是起始点，进行初始化（*代表无限大，即无通路）：\n\n\n\nlowcost[2]=6，lowcost[3]=1，lowcost[4]=5，lowcost[5]=*，lowcost[6]=*\n\nmst[2]=1，mst[3]=1，mst[4]=1，mst[5]=1，mst[6]=1，（所有点默认起点是V1）\n\n\n\n明显看出，以V3为终点的边的权值最小=1，所以边<mst[3],3>=1加入MST\n![2]($resource/2.jpg)\n\n\n此时，因为点V3的加入，需要更新lowcost数组和mst数组：\n\nlowcost[2]=5，lowcost[3]=0，lowcost[4]=5，lowcost[5]=6，lowcost[6]=4\n\nmst[2]=3，mst[3]=0，mst[4]=1，mst[5]=3，mst[6]=3\n\n\n明显看出，以V6为终点的边的权值最小=4，所以边<mst[6],6>=4加入MST\n\n![3]($resource/3.jpg)\n\n\n\n\n此时，因为点V6的加入，需要更新lowcost数组和mst数组：\n\nlowcost[2]=5，lowcost[3]=0，lowcost[4]=2，lowcost[5]=6，lowcost[6]=0\n\nmst[2]=3，mst[3]=0，mst[4]=6，mst[5]=3，mst[6]=0\n\n\n明显看出，以V4为终点的边的权值最小=2，所以边<mst[4],4>=4加入MST\n![4]($resource/4.jpg)\n\n\n\n\n此时，因为点V4的加入，需要更新lowcost数组和mst数组：\n\nlowcost[2]=5，lowcost[3]=0，lowcost[4]=0，lowcost[5]=6，lowcost[6]=0\n\nmst[2]=3，mst[3]=0，mst[4]=0，mst[5]=3，mst[6]=0\n\n\n明显看出，以V2为终点的边的权值最小=5，所以边<mst[2],2>=5加入MST\n\n![5]($resource/5.jpg)\n\n\n\n此时，因为点V2的加入，需要更新lowcost数组和mst数组：\n\nlowcost[2]=0，lowcost[3]=0，lowcost[4]=0，lowcost[5]=3，lowcost[6]=0\n\nmst[2]=0，mst[3]=0，mst[4]=0，mst[5]=2，mst[6]=0\n\n\n很明显，以V5为终点的边的权值最小=3，所以边<mst[5],5>=3加入MST\n\n\nlowcost[2]=0，lowcost[3]=0，lowcost[4]=0，lowcost[5]=0，lowcost[6]=0\n\nmst[2]=0，mst[3]=0，mst[4]=0，mst[5]=0，mst[6]=0\n\n\n至此，MST构建成功，如图所示：\n![6]($resource/6.jpg)\n\n\n\n\n算法程序代码如下：\n```c\n/* Prim算法生成最小生成树  */\nvoid MiniSpanTree_Prim(MGraph G)\n{\n\tint min, i, j, k;\n\tint adjvex[MAXVEX];\t\t/* 保存相关顶点下标 */\n\tint lowcost[MAXVEX];\t/* 保存相关顶点间边的权值 */\n\tlowcost[0] = 0;/* 初始化第一个权值为0，即v0加入生成树 */\n\t\t\t/* lowcost的值为0，在这里就是此下标的顶点已经加入生成树 */\n\tadjvex[0] = 0;\t\t\t/* 初始化第一个顶点下标为0 */\n\tfor(i = 1; i < G.numVertexes; i++)\t/* 循环除下标为0外的全部顶点 */\n\t{\n\t\tlowcost[i] = G.arc[0][i];\t/* 将v0顶点与之有边的权值存入数组 */\n\t\tadjvex[i] = 0;\t\t\t\t\t/* 初始化都为v0的下标 */\n\t}\n\tfor(i = 1; i < G.numVertexes; i++)\n\t{\n\t\tmin = INFINITY;\t/* 初始化最小权值为∞， */\n\t\t\t\t\t\t/* 通常设置为不可能的大数字如32767、65535等 */\n\t\tj = 1;k = 0;\n\t\twhile(j < G.numVertexes)\t/* 循环全部顶点 */\n\t\t{\n\t\t\tif(lowcost[j]!=0 && lowcost[j] < min)/* 如果权值不为0且权值小于min */\n\t\t\t{\t\n\t\t\t\tmin = lowcost[j];\t/* 则让当前权值成为最小值 */\n\t\t\t\tk = j;\t\t\t/* 将当前最小值的下标存入k */\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tprintf(\"(%d, %d)\\n\", adjvex[k], k);/* 打印当前顶点边中权值最小的边 */\n\t\tlowcost[k] = 0;/* 将当前顶点的权值设置为0,表示此顶点已经完成任务 */\n\t\tfor(j = 1; j < G.numVertexes; j++)\t/* 循环所有顶点 */\n\t\t{\n\t\t\tif(lowcost[j]!=0 && G.arc[k][j] < lowcost[j]) \n\t\t\t{/* 如果下标为k顶点各边权值小于此前这些顶点未被加入生成树权值 */\n\t\t\t\tlowcost[j] = G.arc[k][j];/* 将较小的权值存入lowcost相应位置 */\n\t\t\t\tadjvex[j] = k;\t\t\t\t/* 将下标为k的顶点存入adjvex */\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n- 克鲁斯卡尔（Kruskal）算法\n首先通过连通图构建边集数组（按照权值从小到大排序）\n\n**基本思想**\n假设 N=(V,{E})N=(V,{E}) 是连通网：\n\n令最小生成树的初始状态为只有 nn 个顶点并且没有边的非连通图 T={V,{}}T={V,{}} ，图中每个顶点自成一个连通分量。\n在 EE 中选择代价最小的边，若该边的两个顶点落在 TT 中不同的连通分量上，则将此边加入到 TT 中，否则就舍去此边而选择下一条代价最小的边。\n以此类推，直至 TT 中所有顶点都在同一连通分量上为止。\n\n**克鲁斯卡尔算法主要针对边来展开，边数少时效率会非常高，所以对稀疏图有很大的优势；** \n**而普里姆算法对于稠密图，即边数非常多的情况会更好一些。**\n\n**图解**\n1、将连通网中的边转化为边集数组，并对它们按权值从小到大排序。 \n \n![1]($resource/1.png)\n![2]($resource/2.png)\n2、去掉所有边，得到 T={A,B,C,D,E,F,G,H,I,{}}T={A,B,C,D,E,F,G,H,I,{}}。 \n\n3、对边集数组做循环遍历，开始时，i=0，找到第 1 条边，两顶点为 EE 与 HH，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H)}}T={A,B,C,D,E,F,G,H,I,{(E,H)}}。 \n \n![8]($resource/8.jpg)\n4、i=1，找到第 2 条边，两顶点为 CC 与 II，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I)}}。 \n5、i=2，找到第 3 条边，两顶点为 AA 与 BB，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B)}}。 \n \n![9]($resource/9.jpg)\n6、i=3，找到第 4 条边，两顶点为 AA 与 FF，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F)}} \n7、i=4，找到第 5 条边，两顶点为 BB 与 II，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I)}} \n \n![10]($resource/10.jpg)\n8、i=5，找到第 6 条边，两顶点为 DD 与 HH，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H)}} \n9、i=6，找到第 7 条边，两顶点为 BB 与 GG，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H),(B,G)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H),(B,G)}} \n \n![11]($resource/11.jpg)\n10、i=7，找到第 8 条边，两顶点为 GG 与 FF，它们属于同一棵树，舍去。再找 i=8，两顶点为 BB 与 CC，它们属于同一棵树，舍去。再找 i=9，两顶点为 GG 与 HH，分别属于两棵树（两个连通分量），所以添加进 T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H),(B,G),(G,H)}}T={A,B,C,D,E,F,G,H,I,{(E,H),(C,I),(A,B),(A,F),(B,I),(D,H),(B,G),(G,H)}}。 \n11、此后的循环均造成环路，最终最小生成树如下。 \n![12]($resource/12.jpg)\n\n**时间复杂度**\n找边的两顶点是否属于同一棵树的时间复杂度为 O(loge)，而外面有一个 for 循环 e 次。所以克鲁斯卡尔算法的时间复杂度为 O(eloge)（e表示边的条数）。\n\n代码：\n```c\n/* 查找连线顶点的尾部下标 */\nint Find(int *parent, int f)\n{\n\twhile( parent[f] > 0 ) //表示有环路\n\t{\n\t\tf = parent[f];\n\t}\n\t\n\treturn f;\n}\n\n// Kruskal算法生成最小生成树\nvoid MiniSpanTree_Kruskal(MGraph G) //生成最小生成树\n{\n\tint i, n, m;\n\tEdge edges[MAGEDGE];\t// 定义边集数组\n\tint parent[MAXVEX];\t\t// 定义一数组用来判断边与边是否形成环路\n\t/* 此处省略将邻接矩阵G转换为边集数组edges并按照权值大小进行排序的代码 */\n\tfor( i=0; i < G.numVertexes; i++ )\n\t{\n\t\tparent[i] = 0; //初始化数组值为0\n\t}\n\t\n\tfor( i=0; i < G.numEdges; i++ ) //循环每一条边\n\t{\n\t\tn = Find(parent, edges[i].begin);\t\n\t\tm = Find(parent, edges[i].end);\t\t\n\t\t\n\t\tif( n != m )\t\t// 加入n与m不等，说明此边没有与现有生成树形成环路\n\t\t{\n\t\t\tparent[n] = m;\t// 将此边的结尾结点放入下标为起点的parent中，说明此顶点已经在生成树的集合中；\n\t\t\tprintf(\"(%d, %d) %d \", edges[i].begin, edges[i].end, edges[i].weight);\n\t\t}\n\t}\n}\n```\n\n\n\n## 7.7 最短路径\n\n==迪杰斯克拉算法求的是一个顶点到所有顶点的最短路径；==\n==弗洛伊德算法求的是所有顶点到所有顶点的最短路径；==\n\n在网图和非网图中，最短路径的含义是不同的。\n- 网图是两顶点经过的边上权值之和最少的路径。\n- 非网图是两顶点之间经过的边数最少的路径。非网图可以理解称为所有边权值均为1的网；\n\n- **迪杰斯克拉（Dijkstra）算法**\n这里的迪杰斯克拉算法仅仅适用于无孤立点的图\n==解决了某个源点到其余各顶点的最短路径==\n原理见书本P259\n![迪杰斯克拉邻接矩阵]($resource/%E8%BF%AA%E6%9D%B0%E6%96%AF%E5%85%8B%E6%8B%89%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png)\n\n程序代码：\n```c\n#define MAXVEX 20\n#define INFINITY 65535\ntypedef int Patharc[MAXVEX];    /* 用于存储最短路径下标的数组 */\ntypedef int ShortPathTable[MAXVEX];/* 用于存储到各点最短路径的权值和 */\n\n/*  Dijkstra算法，求有向网G的v0顶点到其余顶点v的最短路径P[v]及带权长度D[v] */    \n/*  P[v]的值为前驱顶点下标,D[v]表示v0到v的最短路径长度和 */  \nvoid ShortestPath_Dijkstra(MGraph G, int v0, Patharc *P, ShortPathTable *D)\n{    \n\tint v,w,k,min;    \n\tint final[MAXVEX];/* final[w]=1表示求得顶点v0至vw的最短路径 */\n\tfor(v=0; v<G.numVertexes; v++)    /* 初始化数据 */\n\t{        \n\t\tfinal[v] = 0;\t\t\t/* 全部顶点初始化为未知最短路径状态 */\n\t\t(*D)[v] = G.arc[v0][v];/* 将与v0点有连线的顶点加上权值 */\n\t\t(*P)[v] = -1;\t\t\t\t/* 初始化路径数组P为-1  */       \n\t}\n\n\t(*D)[v0] = 0;  /* v0至v0路径为0 */  \n\tfinal[v0] = 1;    /* v0至v0不需要求路径 */        \n\t/* 开始主循环，每次求得v0到某个v顶点的最短路径 */   \n\tfor(v=1; v<G.numVertexes; v++)   \n\t{\n\t\tmin=INFINITY;    /* 当前所知离v0顶点的最近距离 */        \n\t\tfor(w=0; w<G.numVertexes; w++) /* 寻找离v0最近的顶点 */    \n\t\t{            \n\t\t\tif(!final[w] && (*D)[w]<min)             \n\t\t\t{                   \n\t\t\t\tk=w;                    \n\t\t\t\tmin = (*D)[w];    /* w顶点离v0顶点更近 */            \n\t\t\t}        \n\t\t}        \n\t\tfinal[k] = 1;    /* 将目前找到的最近的顶点置为1 */\n\t\tfor(w=0; w<G.numVertexes; w++) /* 修正当前最短路径及距离 */\n\t\t{\n\t\t\t/* 如果经过v顶点的路径比现在这条路径的长度短的话 */\n\t\t\tif(!final[w] && (min+G.arc[k][w]<(*D)[w]))   \n\t\t\t{ /*  说明找到了更短的路径，修改D[w]和P[w] */\n\t\t\t\t(*D)[w] = min + G.arc[k][w];  /* 修改当前路径长度 */               \n\t\t\t\t(*P)[w]=k;        \n\t\t\t}       \n\t\t}   \n\t}\n}\n```\n\n算法的时间复杂度：O(n^2);\n则求得所有顶点（任一顶点）到其他任意顶点的最短距离时间复杂度为O(n^3)\n\n- **弗洛伊德（Floyd）算法**\n\n![弗洛伊德算法]($resource/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95.jpg)\n\n![3]($resource/3.png)\n\n![弗洛伊德示例]($resource/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%A4%BA%E4%BE%8B.png)\n\n程序代码如下：\n```c\n#define MAXVEX\t9\n#define INFINITY\t65535\n\ntypedef int Pathmatirx[MAXVEX][MAXVEX];\ntypedef int ShortPathTable[MAXVEX][MAXVEX];\n\nvoid ShortestPath_Floyd(MGraph G, Pathmatirx *P, ShortPathTable *D)\n{\n\tint v, w, k;\n\t\n\t// 初始化D与P\n\tfor( v=0; v < G.numVertexes; v++ )\n\t{\n\t\tfor( w=0; w < G.numVertexes; w++ )\n\t\t{\n\t\t\t(*D)[v][w] = G.matirx[v][w]; //D[V][W]值即为对应点间的权值\n\t\t\t(*P)[v][w] = w; //初始化P\n\t\t}\n\t}\n\t\n\t\n\tfor( k=0; k < G.numVertexes; k++ )\n\t{\n\t\tfor( v=0; v < G.numVertexes; v++ )\n\t\t{\n\t\t\tfor( w=0; w < G.numVertexes; w++ )\n\t\t\t{\n\t\t\t\tif( (*D)[v][w] > (*D)[v][k] + (*D)[k][w] )\n\t\t\t\t{\n\t\t\t\t//如果经过下标为K顶点路径比原两点间路径更短；\n\t\t\t\t//将当前两点间权值设为更小的一个；\n\t\t\t\t\t(*D)[v][w] = (*D)[v][k] + (*D)[k][w];\n\t\t\t\t\t(*P)[v][w] = (*P)[v][k]; //路径设置经过下标为K的顶点\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n## 7.8 拓扑排序\n\n前面两个都是有环的图应用，下面为无环的图应用，即图中没有回路；\n- 一个无环的有向图称为无环图（Directed Acyclic Graph），简称DAG图；\n- 在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称之为AOV网；\n\n- 拓扑序列：设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列V1,V2,……,Vn满足若从顶点Vi到Vj有一条路径，则在顶点序列中顶点Vi必在顶点Vj之前。则我们称这样的顶点序列为一个拓扑序列。\n\n- 拓扑排序：所谓的拓扑排序，其实就是对一个有向图构造拓扑序列的过程。\n\n\n**P272**\n\n\n\n\n\n\n",[[1559435605135,["GJX@GJXAIOU",[[1,1420,"**"],[1,1423,"**"]],[1420,1423],[1420,1427]]],[1559435620312,["GJX@GJXAIOU",[[1,1444,"**"],[1,1448,"**"]],[1444,1448],[1444,1452]]],[1559435632136,["GJX@GJXAIOU",[[-1,1454,"  - "]],[1458,1458],[1454,1454]]],[1559435632639,["GJX@GJXAIOU",[[-1,1453,"\n"]],[1454,1454],[1453,1453]]],[1559435634089,["GJX@GJXAIOU",[[-1,1452,"。"]],[1453,1453],[1452,1452]]],[1559435634804,["GJX@GJXAIOU",[[1,1452,"；"]],[1452,1452],[1453,1453]]],[1559435677532,["GJX@GJXAIOU",[[1,1533,"**"],[1,1537,"**"]],[1533,1537],[1533,1541]]],[1559435688508,["GJX@GJXAIOU",[[1,1592,"**"],[1,1597,"**"]],[1592,1597],[1592,1601]]],[1559435727939,["GJX@GJXAIOU",[[1,1629,"**"],[1,1648,"**"]],[1629,1648],[1629,1652]]],[1559435884087,["GJX@GJXAIOU",[[1,2444,"当"]],[2444,2444],[2445,2445]]],[1559435884720,["GJX@GJXAIOU",[[-1,2444,"当"]],[2445,2445],[2444,2444]]],[1559435888741,["GJX@GJXAIOU",[[1,2444,"但是zain"]],[2444,2444],[2450,2450]]],[1559435890524,["GJX@GJXAIOU",[[-1,2446,"zain"]],[2450,2450],[2446,2446]]],[1559435891899,["GJX@GJXAIOU",[[1,2446,"zia "]],[2446,2446],[2450,2450]]],[1559435893135,["GJX@GJXAIOU",[[-1,2446,"zia "]],[2450,2450],[2446,2446]]],[1559435896349,["GJX@GJXAIOU",[[1,2446,"在图中"]],[2446,2446],[2449,2449]]],[1559435900667,["GJX@GJXAIOU",[[-1,2445,"是"]],[2446,2446],[2445,2445]]],[1559435970387,["GJX@GJXAIOU",[[1,2577,"### "]],[2577,2577],[2589,2589]]],[1559435973822,["GJX@GJXAIOU",[[1,2590,"\n"]],[2589,2589],[2590,2590]]],[1559436476720,["GJX@GJXAIOU",[[1,4065,"\n"]],[4064,4064],[4065,4065]]],[1559436480916,["GJX@GJXAIOU",[[1,4170,"\n"]],[4169,4169],[4170,4170]]],[1559436483165,["GJX@GJXAIOU",[[1,4271,"\n"]],[4270,4270],[4271,4271]]],[1559436580647,["GJX@GJXAIOU",[[1,6038,"了"]],[6038,6038],[6039,6039]]]],null,"GJX@GJXAIOU"]]}