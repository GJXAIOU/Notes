# 串

## 5.1 字符串的定义
**串（string）**：有零个或者多个字符组成的有限序列（序列：即字符串的相邻字符之间具有前驱和后继的关系），一般记为：`s = “a1a2a3......an”`,可以直接使用双引号`""`表示空字符串。

**PS：**
-  空格串：只包含空格的串（可以不止一个空格），是有内容有长度的，不等于空字符串；
- 子串：串中任意个数的**连续字符**组成的子序列称为该串的子串；子串在主串中的位置就是子串的第一个字符在主串中的序号；
- 主串：包含子串的串称为主串；
- 前缀：指的是字符串的子串中从原串最前面开始的子串，如abcdef的前缀有：a,ab,abc,abcd,abcde
- 后缀：指的是字符串的子串中在原串结尾处结尾的子串，如abcdef的后缀有：f,ef,def,cdef,bcdef


## 5.2 串的比较

- 常见的编码：
  - ASCII：，每个字符由7个二进制位表示，共计可表示128个字符，后拓展使用8个二进制表示，可表示256个字符；
  - Unicode：每个字符由16位二进制表示，前256个字符与ASCII相同；

- 判定两个字符串大小标准：
  - 如果s1字符串从开头开始为S2字符串的子串，且长度小于s2,则 `s1<s2`;
  - 如果两个字符串中挨个字符比较，在最先不同的字符上s1较小，则 `s1<s2`;


## 5.3 串的抽象数据类型
当然不同的编程语言对于字符串操作方法名称有所不同，需要根据实际修改；
```c
	ADT 串(string)
	Data
	  串中元素仅有一个字符组成，相邻元素具有前驱和后继关系。
	Operation
	  StrAssign(T,*chars):生成一个其值等于字符串常量chars的串T。
	  StrCopy(T,S):串S存在，由串S复制得串T。
	  ClearString(S):串S存在，将串清空。
	  StringEmpty(S):若串S为空，返回true，否则返回false。
	  StrLength(S):返回串S的元素个数，即串的长度。
	  StrCompare(S,T):若S>T,返回值>0,若S=T,返回0，若S<T,返回值<0。
	  Concat(T,S1,S2):用T返回由S1和S2联接成的新串。
	  SubString(Sub,S,pos,len):串S存在，1<=pos<=StrLength(S),且0<=len<=StrLength(S)-pos+1,用Sub返回串S的第pos个字符起长度为len的子串。
	  Index(S,T,pos):串S和T存在，T是非空串，1<=pos<=StrLength(S),若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0.
	  Replace(S,T,V):串S、T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的子串。
	  StrInsert(S,pos,T):串S和T存在，1<=pos<=StrLength(S)+1,在串S的第pos个字符之前插入串T。
	  StrDelete(S,pos,len):串S存在，1<=pos<=STrLength(S)-len+1,从串S中删除第pos个字符起长度为len的子串。
	endADT
```

以index的实现为示例代码：
```c
//T为非空串，如果主串S中第pos个字符之后存在于T相等的子串，则返回第一个这样的子串在S中的位置，否则返回0；

int Index(String S, String T, int pos){
  int n,m,i;
  String sub;
  if(pos > 0){
     n = StrLength(S);
     m = StrLength(T);
     i = pos;
     while(i <= n-m+1){ //这里i是位置，实际数组中坐标要小1；
     		SubString(sub,S,i,m); //取主串第i个位置，长度与T相等的子串给sub
     		if (StrCompare(sub,T) != 0){  //如果两个字符串不相等
     			++i;
     		}else{
     			return i;
     		}
     }
  }
  return 0;   //若无子串与T相等，则返回0

}

```


## 5.4 串的存储结构

### 5.4.1 串的顺序存储结构
使用定长数组来存储字符串，可以在串值后面加一个不计入串长度的结束标记字符，比如“\0”来表示串值的终结；

实际使用过程中经常使用堆来动态分配； 即使用函数malloc 和free进行管理；

### 5.4.2 串的链式存储结构

与线性表类似，如果一个节点只放置一个字符浪费空间，因此一个结点一般放置多个字符；具体放置数目根据实际情况；

==串的链式存储结构除了方便于连接串和串操作的便利，总体不如顺序存储==




## 5.5 朴素的模式匹配算法

即是：子串的定位操作（也称为串的模式匹配）
朴素的模式匹配算法就是挨个移位进行匹配；
容易造成大量的重复遍历问题；


## 5.6 KMP模式匹配算法

**一般仅仅当模式与主串中间存在许多的“部分匹配”的情况下，优势较为明显，否则差距不大；**


**引入1：主串S= “abcdefgab”   ; 子串T=“abcdex”**
第一波匹配：发现到第6个才不相同，而且字符串子串T中首字母和后面所有字符都不相等，同时子串T的前五个字符和主串分别相等；所以子串首字符不可能和主串前5个字符相等；
则第二波匹配不再是使用子串T和主串S的第二项开始比较，而是直接和第6个字符相比较；

**引入2：主串 S= “abcababca” ,子串T=“abcabx”**
第一波匹配：发现到第6个才不相同，但是因为子串T的首字母和后面的第4个字符相等；
则第二波匹配直接和主串的第4个字符比较即可，同时T中首位的a和第四位的a相同，第二位的b和第5位的b相同，而第一波匹配中T中第四位和第五位已经和主串S中的对应位置比较过了，是相等的，因此这里的T的首字母和第二位字符就不必再次和主串比较了；


### 5.6.1 判断子串中首字母与后面字符的相似度
这里定义i值（主串当前位置的下标），KMP算法是实现i值不回溯，就是只能变大不能变小，又因为需要可变化的j值进行判断子串中首字母和后面字符的比较，因此j值的多少取决于当前字符之前的串的前后缀的相似度；
  
next[i]表示的是前i的字符组成的这个子串**最长的相同前缀后缀的长度！**(前缀和后缀相同的最大长度);例如字符串aababaaba的相同前缀后缀有a和aaba，那么其中最长的就是aaba。
将T串各个位置的j值变换定义为一个数组next,数组长度就是子串的长度，定义如下：

![数组next定义]($resource/%E6%95%B0%E7%BB%84next%E5%AE%9A%E4%B9%89.jpg)

示例：
![next数组值推导示例]($resource/next%E6%95%B0%E7%BB%84%E5%80%BC%E6%8E%A8%E5%AF%BC%E7%A4%BA%E4%BE%8B.jpg)



示例：nextval数组值推导

![nextval数组值推导1]($resource/nextval%E6%95%B0%E7%BB%84%E5%80%BC%E6%8E%A8%E5%AF%BC1.jpg)

![nextval数组值推导2]($resource/nextval%E6%95%B0%E7%BB%84%E5%80%BC%E6%8E%A8%E5%AF%BC2.jpg)



代码：
```c
/*
	求模式串T的next函数修正值并存入数组nextval
*/

void get_nextval(String T, int *nextval){
	int i ,j;
	i = 1;
	j = 0;
	nextval[1] = 0;
	while(i<T[0]){ //此处的T[0]表示串T的长度
		if (j==0 || T[i] == T[j]){ //T[i]表示后缀的单个字符，T[j]表示前缀的单个字符
			++i;
			++j;
			if (T[i] != T[j]){ //若当前字符与前缀字符不同
				nextval[i] = j; //则当前的j为nextval在i位置的值
			}else{
				nextval[i] = nextval[j]; //如果与前缀字符相同，则将前缀字符的nextval值赋值给nextval在i位置的值
			}
		}

	}else{
		j = nextval[j]; //若字符不同，则j值回溯
	}
}




/*
	本段为了计算当前要匹配的串T的next数组
	返回子串T在主串S中的第pos个字符之后的位置，若不存在，则函数返回值为0；
	T非空，1<=pos<=StrLength(S)
*/

int Index_KMP(String S, String T, int pos){
	int i = pos; //i用于主串S当前位置下标值，若pos不为1则从pos位置开始匹配
	int j = 1; //j用于子串T中当前位置的下标值
	int nextval[255];  //定义一个next数组
	get_nextval(T, nextval); //对T记性分析，得到next数组
	while(i <= s[0] && j <=T[0]){ //若i小于S的长度且j小于T的长度时，循环继续
		if (j == 0 || S[i] == T[j]){ //两个字母相等则继续，相对于朴素算法增加了j = 0 的判断
			++i;
			++j;	
		}else{ //指针后退重新开始匹配
			j = nextval[j]; //j退到合适的位置，i值不变
		}
	}
	if (j > T[0]){
		return i - T[0];
	}else{
		return 0;
	}
}

```



