{"compress":true,"commitItems":[["d3f9abd6-38dd-46eb-820c-f3e793663cb8",1566643398393,"## 章五：SQL、JDBC 和数据库编程\n\n\n\n### SQL 语句注意事项\n\n\n\n- 尽量别写 `select *`；一方面获得值当数据库变化时会改变，同时数据量过大造成性能问题；select 语句执行时间 = 数据库服务器执行该 SQL 的时间 + 结果返回时间；\n\n\n\n- 注意 `count(*)` 和 `count(字段名)`\n\n当正好该字段允许空值时候，返回记录条数的不一致；\n\n**但是当该字段正好为主键的时候，因为主键上有索引，因此效率比 count(*) 高；**\n\n\n\n- 在使用 insert 插入 使用应该使用字段列表；\n\n\n\n- MySQL 和 SQL  Server 支持一次性插入多条数据，Oracle 不支持；同时不能无限多的插入，否则会出错；将值使用 `,` 分开: `values (‘’，‘’), (‘’,‘’)`。\n\n\n\n- delete 中可以使用 in 语句同时删除多个记录；同样不能过多；用法：`delect from A where id in(1, 2, 3, xxx)`；\n\n\n\n- 使用 merge 语句实现：无则插入有则更新；但是 Oracle、SQLserver 不支持；\n\nDemo：根据图书进货表中的 ISBN，匹配图书表，没有记录就增加，有就用图书进货表中信息更新图书表中信息（只更新以 Java 开头的书籍）\n\n```sql\n\nmerge into图书表a\n\nusing图书进货表b\n\non(a.ISBN=b.ISBN)\n\nwhen matched then update set a. 图书名称=b. 图书名称\n\n    where b. 图书名称like 'java%' \n\nwhen not macthed then \n\n    insert into a(ISBN, 图书名称） values(b.ISBN,b. 图书名称）\n\n        where b. 图书名称like 'java%' \n\n```\n\n\n\n- 存储过程 \n\n  - 这是个争议点：存储过程只在创建时进行编译， 以后每次执行时都不需要重新编 译， 这样能提高数据库执行速度。\n\n但是，一般在存储过程中会有insert、delete或update的语句的集合，在创建存储过程时，这些语句确实会被编译。不过如果对比—下在存储过程里和在JDBC(或者 Hibernate)等场合里多次执行insert或delete、update语句，那么会发现两者的性能差异并不是很明显，更何况在JDBC等场合下还可以通过PreparedStatement 对象的批处理来优化执行性能。\n\n\n\n- 如果针对某个业务逻辑，要对多个表进行多次insert、delete、update或select 操作， 那么可以把这些操作汇集成一个存储过程 。 这样以后每次执行业务时， 只需要调用这个存储过程即可， 这样能提升代码的可重用性， 这也是存储过程的价值所在。\n\n- 存储过程的移植性很差，如针对MySOL数据库的存储过程不能在Oracle上使用，但是一般也不换数据库；\n\n- 存储过程中很难调试，如在—个存储过程中有5个insert语句 ， 分别向5张不同的表中插入数据，在某次通过JDBC执行该存储过程时， 向第三张表中插数据的insert语句发生—个 “主键冲突＂ 的错误，这时从Java语句抛出的异常来看， 只能知道 ”哪个执行存储过程出错＂ ，至千是存储过程中的哪句语句出的异常，这就只能靠自己去查了。\n\n- 用批处理方式的性能要比用存储过程的好 ， 所以在项目里并没有用存储过程来处理大批量的insert、 delete或update的操作。\n\n\n\n\n\n### 使用 JDBC 开发\n\n屏蔽了数据库中的实现细节，只要数据表名不变、表中字段不变，不同种类数据库之间只要修改很少的 jdbc 代码就可以实现迁移；\n\n\n\n- 使用 jdbc 开发，通过 getString(字段名)、getInt()、getfloat() 、getDate()等获取值；\n\n- 一定要在 finally 中关闭所有的链接；\n\n- 更换到 Oracle 时 JDBC 需要更改的地方；\n\n  - 导入的驱动文件不再是 mysql-connector-java.jar，改为：ojdbc.jar；\n\n  - 通过 Class.forName(“com.musql.jdbc.Driver”) 装载的驱动修改为 Oracle 的：“oracle.jdbc.driver.OracleDriver”;\n\n  - getConnection() 方法中的数据库连接的 URL 需要由 ”jdbc: mysql: / / localhost: 3306/数据库名“  改为 ”jdbc:oracle:thin:@localhost:1521:数据库名“\n\n\n\n\n\n### 优化数据库部分代码\n\n\n\n\n\n#### 将相对固定的连接信息写入配置文件\n\n- 减少多个代码同时用到数据库连接参数需要多次配置；\n\n- 对于测试和生产两种生产环境，可以使用两种不同的配置文件，使用命令行切换即可；\n\ndb.properties 写法：\n\n```properties\n\ndriver = com.mysql.cj.jdbc.Driver\n\nurl = jdbc:mysql://localhost:3306/数据库名?serverTimezone = GMT%2B8\n\nuser = 用户名\n\npassword = 密码\n\n```\n\n\n\n\n\n#### 用 PreparedStatement 以批处理的方式操作数据库\n\nPreparedStatement 是预处理，一般用于批处理和防止 SQL 注入；\n\n当需要在一个方法中执行多个插入（更新或者删除）操作时候，可以使用批处理；\n\n\n\n如果通过ps.executeUpdate的方式一条条 地执行语句 ， 那么每次执行语句都包括 “ 连 数据库＋执行语句＋释放数据库 连接\" 3个动作。相比之下 ，如果用批处理（executeBatch）的方式， 那么耗费的代价是 “—次连接＋多次执行＋一次释放 ” ，这样就能省去多次连接和释放数据库 资源从而提升操作性能；\n\n\n\n- PreparedStatement里 ， 占位符的编号是从1开始的， 而不 是从0开始的；\n\n- 批量操作能提升效率， 但一次性操作多少 ， 效率能提升多高？这 在不同的数据库\n\n中是不同的， 一般每批是操作500 - 1000条语句。不要太多不然缓存放不完；\n\n\n\n#### 用 PreparedStatement 对象防止 SQL 注入\n\n\n\n#### 使用 C3P0 连接池\n\n如果操作很频繁 ， 那么频繁的创建和关闭数据库连接动作会极大地减低系统的性能 ， 在这种情况下 ， 可以使用连接池；\n\n- 常见连接池有：C3P0 和 DBCP\n\n- C3P0 连接池的常用属性：\n\n![C3P0连接池常见属性]($resource/C3P0%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7.png)\n\n\n\n\n\n\n\n### 事务\n\n\n\n事务(Transaction)是—组针对数据库的操作， 这些操作要么都做， 要么都不做， 是 一个不可分割的 SQL 语句集合。\n\n\n\n#### 开启事务，合理的提交和回滚\n\n在JDBC中， 一般采用如下的方法使用事务。\n\n- (1)通过`connection.setAutoCommit(false)`, 设置不是自动提交。在JDBC中， 一般默认是自动提交，即有任何增删改的SOL语句都会立即执行。如果大家设置了非自动提交， 要在用好事务后设置回 “ 自动提交” 。\n\n- (2)在合适的地方用`connection.commit();` 来提交事务， 一般是在执行结束后提交事务， 这样就会同时执行事务中的所有操作。\n\n- 可以通过`connection.rollback()`来回滚事务， 回滚语句—般是放在catch从句中；一旦出现异常，就在 catch 中实现回滚；\n\n\n\n\n\n#### 事务中的常见问题：脏读、幻读和不可重复读\n\n在项目中， 如果**同时对一张表有两个（或多个） 事务进行读写操作时**， 很容易出现数据读写错误的问题，具体表现形式有脏读、 幻读和不可重复读。\n\n\n\n- (1)脏读(dirtyread)是指—个事务读取了另—个事务尚未提交的数据。\n\nA 值为 1，B 将其值设置为 2（但是尚未提交这个修改事务），A 读到值变为 2，结果 B 回滚了事务又将 A 值改为 1,则 A 读到的 2 就是一个脏数据，对应的操作为**脏读**；\n\n**避免方法：** 如果在第— 个事务提交前 ， 任何其他事务不可读取宾修改过的值，则可以追免出现该问题。\n\n\n\n- 幻读(phantom read)是指一个事务的操作会导致另一个事务前后两次查询 的结果不同。\n\nA 事务查询值为 1 的数据，读取到 10 条，然后事务 B 插入一条数据值为 1，A 再次以同样条件读取就会得到 11 条；\n\n**避免方法：** 如果在操作事务完成数据处理之前 ， 任何其他事务都不可以添加新数据， 则可避免该问题。\n\n\n\n- 不可重复读(non-repeatable read)是指—个事务的操作导致另—个事务前后两次读取到不同的数据。例如， 同—查询 在同一事务中多次进行， 由于其他事务提交了所做的修改（或和加或删除等操作） ， 这样每次查询会返回不同的结果集，这就是不可重复读。\n\nA 读到的值为 1，但是针对这个值的修改没有完成，事务 B 修改了值为 2，并提交了事务，则事务 A 再次读取值变为了 2；\n\n**避免方法：** 只有在修改事务完全提交之后才允许读取数据；\n\n\n\n\n\n#### 事务隔离级别\n\n\n\n用户可以通过事务隔离级别来解决上述在事务中读写不一致的问题。在JDBC中，有5个常量来描述事务隔离级别，级别从低到高依次如下。\n\n(1)读取未提交：`TRANSACTION_READ_UNCOMMITTED`, 允许脏读、不可重复读和幻读。\n\n(2)读取提交：`TRANSACTION_READ_COMMITTED`, 禁止脏读，但允许不可重复读和幻读。\n\n(3)可重读：`TRANSACTION_REPEATABLE_READ`,禁止脏读和不可重复读，但允许幻读。\n\n(4)可串化：`TRANSACTION_SER IALIZABLE`, 禁止脏读、不可重复读和幻读。\n\n(5)还有一个常量是`TRANSACTION_NONE`,如果读取这个值，那么将使用当前数据库说指定的事务隔离级别；\n\n\n\n综上所述，如果设置高级别的事务隔离级别，那么数据库系统就要采取额外的措施来保证这个设置。会造成后续的操作和功能等待。\n\n\n\n\n\n\n\n==P181==\n\n",[[1566643364300,["GJX@GJXAIOU",[[-1,2895,"![C3P0连接池常见属性]($resource/C3P0%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7.png)"]],[2895,2992],[2895,2895]]],[1566643388197,["GJX@GJXAIOU",[[1,2895,"![C3P0连接池常见属性]($resource/C3P0%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7.png)"]],[2895,2895],[2993,2993]]],[1566643391084,["GJX@GJXAIOU",[[-1,2999,"\n"]],[2998,2998],[2997,2997]]],[1566643391260,["GJX@GJXAIOU",[[-1,2998,"\n"]],[2997,2997],[2996,2996]]],[1566643391572,["GJX@GJXAIOU",[[-1,2997,"\n"]],[2996,2996],[2995,2995]]],[1566643420476,["GJX@GJXAIOU",[[-1,42,"\n"]],[42,42],[41,41]]],[1566643420798,["GJX@GJXAIOU",[[-1,41,"\n"]],[41,41],[40,40]]],[1566643421422,["GJX@GJXAIOU",[[-1,24,"\n"]],[23,23],[22,22]]],[1566643422588,["GJX@GJXAIOU",[[-1,23,"\n"]],[22,22],[21,21]]],[1566643424284,["GJX@GJXAIOU",[[-1,134,"\n"]],[134,134],[133,133]]],[1566643425375,["GJX@GJXAIOU",[[-1,240,"\n"]],[239,239],[238,238]]],[1566643425980,["GJX@GJXAIOU",[[-1,239,"\n"]],[238,238],[237,237]]],[1566643426740,["GJX@GJXAIOU",[[-1,269,"\n"]],[267,267],[266,266]]],[1566643427548,["GJX@GJXAIOU",[[-1,268,"\n"]],[268,268],[267,267]]],[1566643428395,["GJX@GJXAIOU",[[-1,372,"\n"]],[371,371],[370,370]]],[1566643429063,["GJX@GJXAIOU",[[-1,371,"\n"]],[371,371],[370,370]]],[1566643430588,["GJX@GJXAIOU",[[-1,133,"\n"]],[133,133],[132,132]]],[1566643431932,["GJX@GJXAIOU",[[-1,454,"\n"]],[453,453],[452,452]]],[1566643432612,["GJX@GJXAIOU",[[-1,453,"\n"]],[453,453],[452,452]]],[1566643435772,["GJX@GJXAIOU",[[-1,599,"\n"]],[599,599],[598,598]]],[1566643436275,["GJX@GJXAIOU",[[-1,583,"\n"]],[583,583],[582,582]]],[1566643437156,["GJX@GJXAIOU",[[-1,610,"\n"]],[610,610],[609,609]]],[1566643437852,["GJX@GJXAIOU",[[-1,628,"\n"]],[628,628],[627,627]]],[1566643438587,["GJX@GJXAIOU",[[-1,673,"\n"]],[673,673],[672,672]]],[1566643439348,["GJX@GJXAIOU",[[-1,704,"\n"]],[704,704],[703,703]]],[1566643439979,["GJX@GJXAIOU",[[-1,727,"\n"]],[727,727],[726,726]]],[1566643440660,["GJX@GJXAIOU",[[-1,780,"\n"]],[780,780],[779,779]]],[1566643442159,["GJX@GJXAIOU",[[-1,815,"\n"]],[815,815],[814,814]]],[1566643442884,["GJX@GJXAIOU",[[-1,821,"\n"]],[821,821],[820,820]]],[1566643443260,["GJX@GJXAIOU",[[-1,820,"\n"]],[820,820],[819,819]]],[1566643445277,["GJX@GJXAIOU",[[-1,828,"\n"]],[828,828],[827,827]]],[1566643447212,["GJX@GJXAIOU",[[-1,886,"\n"]],[886,886],[885,885]]],[1566643450622,["GJX@GJXAIOU",[[1,886," "]],[886,886],[887,887]]],[1566643452687,["GJX@GJXAIOU",[[-1,1083,"\n"]],[1082,1082],[1081,1081]]],[1566643453503,["GJX@GJXAIOU",[[-1,1082,"\n"]],[1081,1081],[1080,1080]]],[1566643456228,["GJX@GJXAIOU",[[-1,1514,"\n"]],[1513,1513],[1512,1512]]],[1566643456428,["GJX@GJXAIOU",[[-1,1513,"\n"]],[1512,1512],[1511,1511]]],[1566643458078,["GJX@GJXAIOU",[[-1,1593,"\n"]],[1593,1593],[1592,1592]]],[1566643459197,["GJX@GJXAIOU",[[-1,1660,"\n"]],[1660,1660],[1659,1659]]],[1566643460751,["GJX@GJXAIOU",[[-1,1685,"\n"]],[1685,1685],[1684,1684]]],[1566643461485,["GJX@GJXAIOU",[[-1,1714,"\n"]],[1714,1714],[1713,1713]]],[1566643462173,["GJX@GJXAIOU",[[-1,1768,"\n"]],[1768,1768],[1767,1767]]],[1566643463084,["GJX@GJXAIOU",[[-1,1867,"\n"]],[1867,1867],[1866,1866]]],[1566643464094,["GJX@GJXAIOU",[[-1,1994,"\n"]],[1993,1993],[1992,1992]]],[1566643464325,["GJX@GJXAIOU",[[-1,1993,"\n"]],[1992,1992],[1991,1991]]],[1566643464709,["GJX@GJXAIOU",[[-1,1992,"\n"]],[1991,1991],[1990,1990]]],[1566643466112,["GJX@GJXAIOU",[[-1,2010,"\n"]],[2009,2009],[2008,2008]]],[1566643466476,["GJX@GJXAIOU",[[-1,2009,"\n"]],[2008,2008],[2007,2007]]],[1566643467636,["GJX@GJXAIOU",[[-1,2008,"\n"]],[2007,2007],[2006,2006]]],[1566643468292,["GJX@GJXAIOU",[[-1,2007,"\n"]],[2007,2007],[2006,2006]]],[1566643470031,["GJX@GJXAIOU",[[-1,2057,"\n"]],[2057,2057],[2056,2056]]],[1566643473612,["GJX@GJXAIOU",[[-1,2132,"\n"]],[2132,2132],[2131,2131]]],[1566643474251,["GJX@GJXAIOU",[[-1,2117,"\n"]],[2117,2117],[2116,2116]]],[1566643475031,["GJX@GJXAIOU",[[-1,2165,"\n"]],[2165,2165],[2164,2164]]],[1566643475718,["GJX@GJXAIOU",[[-1,2229,"\n"]],[2229,2229],[2228,2228]]],[1566643476348,["GJX@GJXAIOU",[[-1,2240,"\n"]],[2240,2240],[2239,2239]]],[1566643477079,["GJX@GJXAIOU",[[-1,2254,"\n"]],[2254,2254],[2253,2253]]],[1566643478228,["GJX@GJXAIOU",[[-1,2262,"\n"]],[2261,2261],[2260,2260]]],[1566643478477,["GJX@GJXAIOU",[[-1,2261,"\n"]],[2260,2260],[2259,2259]]],[1566643478783,["GJX@GJXAIOU",[[-1,2260,"\n"]],[2259,2259],[2258,2258]]],[1566643479532,["GJX@GJXAIOU",[[-1,2259,"\n"]],[2259,2259],[2258,2258]]],[1566643483923,["GJX@GJXAIOU",[[-1,2340,"\n"]],[2340,2340],[2339,2339]]],[1566643484781,["GJX@GJXAIOU",[[-1,2379,"\n"]],[2379,2379],[2378,2378]]],[1566643485188,["GJX@GJXAIOU",[[-1,2378,"\n"]],[2378,2378],[2377,2377]]],[1566643486628,["GJX@GJXAIOU",[[-1,2543,"\n"]],[2543,2543],[2542,2542]]],[1566643487180,["GJX@GJXAIOU",[[-1,2542,"\n"]],[2542,2542],[2541,2541]]],[1566643488244,["GJX@GJXAIOU",[[-1,2590,"\n"]],[2590,2590],[2589,2589]]],[1566643491180,["GJX@GJXAIOU",[[-1,2632,"\n"]],[2633,2633],[2632,2632]]],[1566643491644,["GJX@GJXAIOU",[[-1,2631,"\n"]],[2632,2632],[2631,2631]]],[1566643492957,["GJX@GJXAIOU",[[-1,2674,"\n"]],[2673,2673],[2672,2672]]],[1566643493884,["GJX@GJXAIOU",[[-1,2713,"\n"]],[2711,2711],[2710,2710]]],[1566643494556,["GJX@GJXAIOU",[[-1,2712,"\n"]],[2712,2712],[2711,2711]]],[1566643497260,["GJX@GJXAIOU",[[-1,2729,"\n"]],[2729,2729],[2728,2728]]],[1566643499703,["GJX@GJXAIOU",[[-1,2788,"\n"]],[2788,2788],[2787,2787]]],[1566643501982,["GJX@GJXAIOU",[[-1,2939,"\n"]],[2939,2939],[2938,2938]]],[1566643502510,["GJX@GJXAIOU",[[-1,2929,"\n"]],[2928,2928],[2927,2927]]],[1566643503364,["GJX@GJXAIOU",[[-1,2928,"\n"]],[2928,2928],[2927,2927]]],[1566643504086,["GJX@GJXAIOU",[[-1,2936,"\n"]],[2936,2936],[2935,2935]]],[1566643504460,["GJX@GJXAIOU",[[-1,2935,"\n"]],[2935,2935],[2934,2934]]],[1566643505588,["GJX@GJXAIOU",[[-1,3002,"\n"]],[3002,3002],[3001,3001]]],[1566643505868,["GJX@GJXAIOU",[[-1,3001,"\n"]],[3001,3001],[3000,3000]]],[1566643509062,["GJX@GJXAIOU",[[-1,3327,"\n"]],[3326,3326],[3325,3325]]],[1566643509308,["GJX@GJXAIOU",[[-1,3326,"\n"]],[3325,3325],[3324,3324]]],[1566643509998,["GJX@GJXAIOU",[[-1,3325,"\n"]],[3324,3324],[3323,3323]]],[1566643510892,["GJX@GJXAIOU",[[-1,3324,"\n"]],[3324,3324],[3323,3323]]],[1566643511988,["GJX@GJXAIOU",[[-1,3427,"\n"]],[3427,3427],[3426,3426]]],[1566643512341,["GJX@GJXAIOU",[[-1,3426,"\n"]],[3426,3426],[3425,3425]]],[1566643514051,["GJX@GJXAIOU",[[-1,3350,"\n"]],[3350,3350],[3349,3349]]],[1566643515359,["GJX@GJXAIOU",[[-1,3619,"\n"]],[3619,3619],[3618,3618]]],[1566643515596,["GJX@GJXAIOU",[[-1,3618,"\n"]],[3618,3618],[3617,3617]]],[1566643517374,["GJX@GJXAIOU",[[-1,3789,"\n"]],[3788,3788],[3787,3787]]],[1566643518116,["GJX@GJXAIOU",[[-1,3788,"\n"]],[3788,3788],[3787,3787]]],[1566643520611,["GJX@GJXAIOU",[[-1,4021,"\n"]],[4021,4021],[4020,4020]]],[1566643520854,["GJX@GJXAIOU",[[-1,4020,"\n"]],[4020,4020],[4019,4019]]],[1566643521213,["GJX@GJXAIOU",[[-1,4019,"\n"]],[4019,4019],[4018,4018]]],[1566643521908,["GJX@GJXAIOU",[[-1,4033,"\n"]],[4033,4033],[4032,4032]]],[1566643522158,["GJX@GJXAIOU",[[-1,4032,"\n"]],[4032,4032],[4031,4031]]],[1566643522924,["GJX@GJXAIOU",[[-1,4031,"\n"]],[4031,4031],[4030,4030]]],[1566643524940,["GJX@GJXAIOU",[[-1,4152,"\n"]],[4152,4152],[4151,4151]]],[1566643525949,["GJX@GJXAIOU",[[-1,4208,"\n"]],[4208,4208],[4207,4207]]],[1566643526660,["GJX@GJXAIOU",[[-1,4263,"\n"]],[4263,4263],[4262,4262]]],[1566643527725,["GJX@GJXAIOU",[[-1,4314,"\n"]],[4314,4314],[4313,4313]]],[1566643528933,["GJX@GJXAIOU",[[-1,4375,"\n"]],[4374,4374],[4373,4373]]],[1566643529767,["GJX@GJXAIOU",[[-1,4374,"\n"]],[4374,4374],[4373,4373]]],[1566643539249,["GJX@GJXAIOU",[[1,27,"一 "]],[27,27],[28,28]]],[1566643539623,["GJX@GJXAIOU",[[1,28,"、"]],[28,28],[29,29]]],[1566643541375,["GJX@GJXAIOU",[[-1,29," "]],[30,30],[29,29]]],[1566643546985,["GJX@GJXAIOU",[[1,1519,"二、"]],[1519,1519],[1521,1521]]],[1566643551254,["GJX@GJXAIOU",[[1,2000,"三、"]],[2000,2000],[2002,2002]]],[1566643576909,["GJX@GJXAIOU",[[-1,1596,"\n"]],[1596,1596],[1595,1595]]],[1566643592218,["GJX@GJXAIOU",[[1,2017,"（）"]],[2017,2017],[2019,2019]]],[1566643593680,["GJX@GJXAIOU",[[1,2018,"一"]],[2018,2018],[2019,2019]]],[1566643597328,["GJX@GJXAIOU",[[1,2272,"（）"]],[2272,2272],[2274,2274]]],[1566643598657,["GJX@GJXAIOU",[[1,2273,"二"]],[2273,2273],[2274,2274]]],[1566643601832,["GJX@GJXAIOU",[[1,2690,"（）"]],[2690,2690],[2692,2692]]],[1566643604600,["GJX@GJXAIOU",[[1,2691,"三"]],[2691,2691],[2692,2692]]],[1566643625722,["GJX@GJXAIOU",[[1,2731,"（）"]],[2731,2731],[2733,2733]]],[1566643627674,["GJX@GJXAIOU",[[1,2732,"是"]],[2732,2732],[2733,2733]]],[1566643628900,["GJX@GJXAIOU",[[-1,2732,"是"]],[2733,2733],[2732,2732]]],[1566643633879,["GJX@GJXAIOU",[[1,2732,"四"]],[2732,2732],[2733,2733]]],[1566643693204,["GJX@GJXAIOU",[[-1,2844,"\n"]],[2844,2844],[2843,2843]]],[1566643889318,["GJX@GJXAIOU",[[1,2948,"四、"]],[2948,2948],[2950,2950]]],[1566643899472,["GJX@GJXAIOU",[[1,3023,"（）"]],[3023,3023],[3025,3025]]],[1566643901577,["GJX@GJXAIOU",[[1,3024,"一"]],[3024,3024],[3025,3025]]],[1566643902926,["GJX@GJXAIOU",[[1,3023," "]],[3023,3023],[3024,3024]]],[1566643905196,["GJX@GJXAIOU",[[-1,3027," "]],[3028,3028],[3027,3027]]],[1566643980761,["GJX@GJXAIOU",[[1,3350,"（）"]],[3350,3350],[3352,3352]]],[1566643982887,["GJX@GJXAIOU",[[1,3351,"二"]],[3351,3351],[3352,3352]]],[1566643987929,["GJX@GJXAIOU",[[1,4048,"（）"]],[4048,4048],[4050,4050]]],[1566643989527,["GJX@GJXAIOU",[[1,4049,"三"]],[4049,4049],[4050,4050]]],[1566644019862,["GJX@GJXAIOU",[[-1,166,"\n"]],[166,166],[165,165]]],[1566644023228,["GJX@GJXAIOU",[[-1,191,"\n"]],[191,191],[190,190]]],[1566644635661,["GJX@GJXAIOU",[[1,179,"两者"]],[179,179],[181,181]]],[1566644648771,["GJX@GJXAIOU",[[-1,255," "]],[256,256],[255,255]]],[1566644657868,["GJX@GJXAIOU",[[-1,282," "]],[283,283],[282,282]]],[1566644667563,["GJX@GJXAIOU",[[-1,312,"同时"]],[314,314],[312,312]]],[1566644668895,["GJX@GJXAIOU",[[1,312,"但是"]],[312,312],[314,314]]],[1566644681049,["GJX@GJXAIOU",[[1,329,"插入的多个值"]],[329,329],[335,335]]],[1566644682845,["GJX@GJXAIOU",[[-1,335,"将值"]],[337,337],[335,335]]],[1566644685603,["GJX@GJXAIOU",[[-1,355,"‘"]],[356,356],[355,355]]],[1566644686192,["GJX@GJXAIOU",[[1,355,"'"]],[355,355],[356,356]]],[1566644687220,["GJX@GJXAIOU",[[-1,356,"’"]],[357,357],[356,356]]],[1566644688013,["GJX@GJXAIOU",[[1,356,"'"]],[356,356],[357,357]]],[1566644691003,["GJX@GJXAIOU",[[-1,358,"‘’"]],[360,360],[358,358]]],[1566644691477,["GJX@GJXAIOU",[[1,358,"''"]],[358,358],[360,360]]],[1566644694094,["GJX@GJXAIOU",[[-1,364,"‘’"]],[366,366],[364,364]]],[1566644694685,["GJX@GJXAIOU",[[1,364,"''"]],[364,364],[366,366]]],[1566644696470,["GJX@GJXAIOU",[[-1,367,"‘’"]],[369,369],[367,367]]],[1566644696925,["GJX@GJXAIOU",[[1,367,"''"]],[367,367],[369,369]]],[1566644712799,["GJX@GJXAIOU",[[-1,361,", "]],[363,363],[361,361]]],[1566644714671,["GJX@GJXAIOU",[[1,361,", "]],[361,361],[363,363]]],[1566644716454,["GJX@GJXAIOU",[[-1,366,","]],[367,367],[366,366]]],[1566644716855,["GJX@GJXAIOU",[[1,366,","]],[366,366],[367,367]]],[1566644721118,["GJX@GJXAIOU",[[1,367,"d"]],[367,367],[368,368]]],[1566644722205,["GJX@GJXAIOU",[[-1,367,"d"]],[368,368],[367,367]]],[1566644726476,["GJX@GJXAIOU",[[-1,357,"，"]],[358,358],[357,357]]],[1566644727302,["GJX@GJXAIOU",[[1,357,","]],[357,357],[358,358]]],[1566644737541,["GJX@GJXAIOU",[[1,403,"d "]],[403,403],[404,404]]],[1566644737751,["GJX@GJXAIOU",[[1,404,"an"]],[404,404],[406,406]]],[1566644739860,["GJX@GJXAIOU",[[-1,403,"dan "]],[406,406],[403,403]]],[1566644742151,["GJX@GJXAIOU",[[1,403,"但是"]],[403,403],[405,405]]],[1566644757148,["GJX@GJXAIOU",[[-1,509,"\n"]],[509,509],[508,508]]],[1566644761739,["GJX@GJXAIOU",[[-1,580,"\n"]],[580,580],[579,579]]],[1566644841180,["GJX@GJXAIOU",[[-1,663," "]],[664,664],[663,663]]],[1566644843916,["GJX@GJXAIOU",[[-1,670," "]],[671,671],[670,670]]],[1566644845893,["GJX@GJXAIOU",[[1,668," "]],[668,668],[669,669]]],[1566644847149,["GJX@GJXAIOU",[[1,667," "]],[667,667],[668,668]]],[1566644855380,["GJX@GJXAIOU",[[-1,689," "]],[690,690],[689,689]]],[1566644864564,["GJX@GJXAIOU",[[-1,758,"）"]],[759,759],[758,758]]],[1566644869067,["GJX@GJXAIOU",[[-1,775," "]],[776,776],[775,775]]],[1566644874923,["GJX@GJXAIOU",[[-1,797," "]],[798,798],[797,797]]],[1566644878661,["GJX@GJXAIOU",[[1,801," "]],[801,801],[802,802]]],[1566644882197,["GJX@GJXAIOU",[[1,693," "]],[693,693],[694,694]]],[1566644893428,["GJX@GJXAIOU",[[-1,870," "]],[871,871],[870,870]]],[1566644898020,["GJX@GJXAIOU",[[1,841,"**"],[1,871,"**"]],[841,871],[841,875]]],[1566644956308,["GJX@GJXAIOU",[[1,1221,"**"],[1,1231,"**"]],[1221,1231],[1221,1235]]],[1566644959077,["GJX@GJXAIOU",[[1,1280,"**"],[1,1289,"**"]],[1280,1289],[1280,1293]]],[1566644966861,["GJX@GJXAIOU",[[1,1145,"**"],[1,1159,"**"]],[1145,1159],[1145,1163]]],[1566644975734,["GJX@GJXAIOU",[[-1,1320," "]],[1321,1321],[1320,1320]]],[1566644978292,["GJX@GJXAIOU",[[-1,1318," "]],[1319,1319],[1318,1318]]],[1566644984096,["GJX@GJXAIOU",[[1,1243," "]],[1243,1243],[1244,1244]]],[1566644984822,["GJX@GJXAIOU",[[1,1249," "]],[1249,1249],[1250,1250]]],[1566644985592,["GJX@GJXAIOU",[[1,1261," "]],[1261,1261],[1262,1262]]],[1566644986628,["GJX@GJXAIOU",[[1,1268," "]],[1268,1268],[1269,1269]]],[1566644987309,["GJX@GJXAIOU",[[1,1326," "]],[1326,1326],[1327,1327]]],[1566644987853,["GJX@GJXAIOU",[[1,1328," "]],[1328,1328],[1329,1329]]],[1566644989636,["GJX@GJXAIOU",[[1,1313,"  "]],[1313,1313],[1314,1314]]],[1566644990900,["GJX@GJXAIOU",[[-1,1314," "]],[1314,1314],[1313,1313]]],[1566644992048,["GJX@GJXAIOU",[[1,1312," "]],[1312,1312],[1313,1313]]],[1566644993391,["GJX@GJXAIOU",[[1,1316," "]],[1316,1316],[1317,1317]]],[1566644994629,["GJX@GJXAIOU",[[1,1323," "]],[1323,1323],[1324,1324]]],[1566644997013,["GJX@GJXAIOU",[[1,1109," "]],[1109,1109],[1110,1110]]],[1566644998685,["GJX@GJXAIOU",[[1,1130," "]],[1130,1130],[1131,1131]]],[1566644999494,["GJX@GJXAIOU",[[1,1132," "]],[1132,1132],[1133,1133]]],[1566645001964,["GJX@GJXAIOU",[[1,1053," "]],[1053,1053],[1054,1054]]],[1566645004031,["GJX@GJXAIOU",[[1,1001," "]],[1001,1001],[1002,1002]]],[1566645005260,["GJX@GJXAIOU",[[1,994," "]],[994,994],[995,995]]],[1566645006477,["GJX@GJXAIOU",[[1,1001," "]],[1001,1001],[1002,1002]]],[1566645007837,["GJX@GJXAIOU",[[1,1017," "]],[1017,1017],[1018,1018]]],[1566645009088,["GJX@GJXAIOU",[[1,968," "]],[968,968],[969,969]]],[1566645010325,["GJX@GJXAIOU",[[1,918," "]],[918,918],[919,919]]],[1566645011142,["GJX@GJXAIOU",[[1,920," "]],[920,920],[921,921]]],[1566645012181,["GJX@GJXAIOU",[[1,927," "]],[927,927],[928,928]]],[1566645013588,["GJX@GJXAIOU",[[1,905," "]],[905,905],[906,906]]],[1566645043854,["GJX@GJXAIOU",[[1,1312,"，很难找到具体错误"]],[1312,1312],[1321,1321]]],[1566645046788,["GJX@GJXAIOU",[[1,1422," "]],[1422,1422],[1423,1423]]],[1566645047413,["GJX@GJXAIOU",[[1,1427," "]],[1427,1427],[1428,1428]]],[1566645054907,["GJX@GJXAIOU",[[-1,1458,"至千"]],[1460,1460],[1458,1458]]],[1566645057662,["GJX@GJXAIOU",[[1,1458,"至于"]],[1458,1458],[1460,1460]]],[1566645070501,["GJX@GJXAIOU",[[1,1491,"**"],[1,1509,"**"]],[1491,1509],[1491,1513]]],[1566645076890,["GJX@GJXAIOU",[[-1,1565,"\n"]],[1565,1565],[1564,1564]]],[1566645096559,["GJX@GJXAIOU",[[1,1710,"字段"]],[1710,1710],[1712,1712]]],[1566645110943,["GJX@GJXAIOU",[[1,1742,"MySQL "]],[1742,1742],[1747,1747]]],[1566645121398,["GJX@GJXAIOU",[[1,1790,"·"]],[1790,1790],[1791,1791]]],[1566645122531,["GJX@GJXAIOU",[[-1,1790,"·"]],[1791,1791],[1790,1790]]],[1566645123013,["GJX@GJXAIOU",[[1,1790,"`"]],[1790,1790],[1791,1791]]],[1566645125540,["GJX@GJXAIOU",[[1,1815,"`"]],[1815,1815],[1816,1816]]],[1566645126892,["GJX@GJXAIOU",[[1,1820,"`"]],[1820,1820],[1821,1821]]],[1566645128061,["GJX@GJXAIOU",[[1,1830,"`"]],[1830,1830],[1831,1831]]],[1566645132408,["GJX@GJXAIOU",[[1,1722,"`"]],[1722,1722],[1723,1723]]],[1566645133909,["GJX@GJXAIOU",[[1,1730,"`"]],[1730,1730],[1731,1731]]],[1566645138661,["GJX@GJXAIOU",[[1,1662,"`"]],[1662,1662],[1663,1663]]],[1566645141720,["GJX@GJXAIOU",[[1,1708,"` "]],[1708,1708],[1710,1710]]],[1566645147604,["GJX@GJXAIOU",[[1,1845,"`"]],[1845,1845],[1846,1846]]],[1566645149117,["GJX@GJXAIOU",[[1,1885,"`"]],[1885,1885],[1886,1886]]],[1566645152363,["GJX@GJXAIOU",[[-1,1884," "]],[1884,1885],[1884,1884]]],[1566645153101,["GJX@GJXAIOU",[[1,1885," "]],[1885,1885],[1886,1886]]],[1566645156413,["GJX@GJXAIOU",[[1,1895,"`"]],[1895,1895],[1896,1896]]],[1566645159620,["GJX@GJXAIOU",[[-1,1895,"`"]],[1896,1896],[1895,1895]]],[1566645162605,["GJX@GJXAIOU",[[1,1905,"`"]],[1905,1905],[1906,1906]]],[1566645164109,["GJX@GJXAIOU",[[-1,1905,"`"]],[1906,1906],[1905,1905]]],[1566645164959,["GJX@GJXAIOU",[[1,1904,"`"]],[1904,1904],[1905,1905]]],[1566645166645,["GJX@GJXAIOU",[[1,1938,"`"]],[1938,1938],[1939,1939]]],[1566645176653,["GJX@GJXAIOU",[[1,1945,"`"]],[1945,1945],[1946,1946]]],[1566645178116,["GJX@GJXAIOU",[[1,1961,"`"]],[1961,1961],[1962,1962]]],[1566645180197,["GJX@GJXAIOU",[[1,1982,"`"]],[1982,1982],[1983,1983]]],[1566645186093,["GJX@GJXAIOU",[[-1,1996," / / "]],[2001,2001],[1996,1996]]],[1566645187862,["GJX@GJXAIOU",[[1,1996,"??"]],[1996,1996],[1998,1998]]],[1566645188532,["GJX@GJXAIOU",[[-1,1996,"??"]],[1998,1998],[1996,1996]]],[1566645189285,["GJX@GJXAIOU",[[1,1996,"、、"]],[1996,1996],[1998,1998]]],[1566645189915,["GJX@GJXAIOU",[[-1,1996,"、、"]],[1998,1998],[1996,1996]]],[1566645190751,["GJX@GJXAIOU",[[1,1996,"//"]],[1996,1996],[1998,1998]]],[1566645193734,["GJX@GJXAIOU",[[-1,2008," "]],[2009,2009],[2008,2008]]],[1566645203293,["GJX@GJXAIOU",[[1,2018,"`"]],[2018,2018],[2019,2019]]],[1566645208741,["GJX@GJXAIOU",[[1,2024,"`"]],[2024,2024],[2025,2025]]],[1566645212111,["GJX@GJXAIOU",[[1,2064,"`"]],[2064,2064],[2065,2065]]],[1566645242719,["GJX@GJXAIOU",[[-1,2179,"\n"]],[2179,2179],[2178,2178]]],[1566645248003,["GJX@GJXAIOU",[[1,2179,"\n"]],[2179,2179],[2180,2180]]],[1566645282395,["GJX@GJXAIOU",[[1,2382,"**"],[1,2422,"**"]],[2382,2422],[2382,2426]]],[1566645300109,["GJX@GJXAIOU",[[1,2470,"`"]],[2470,2470],[2471,2471]]],[1566645302111,["GJX@GJXAIOU",[[1,2487,"`"]],[2487,2487],[2488,2488]]],[1566645304438,["GJX@GJXAIOU",[[-1,2494," "]],[2495,2495],[2494,2494]]],[1566645308191,["GJX@GJXAIOU",[[-1,2499," "]],[2500,2500],[2499,2499]]],[1566645309947,["GJX@GJXAIOU",[[-1,2500," "]],[2501,2501],[2500,2500]]],[1566645315939,["GJX@GJXAIOU",[[-1,2514,"连 "]],[2516,2516],[2514,2514]]],[1566645316880,["GJX@GJXAIOU",[[1,2514,"l "]],[2514,2514],[2515,2515]]],[1566645318011,["GJX@GJXAIOU",[[-1,2514,"l"]],[2515,2515],[2514,2514]]],[1566645318804,["GJX@GJXAIOU",[[-1,2514," "]],[2515,2515],[2514,2514]]],[1566645322038,["GJX@GJXAIOU",[[1,2514,"连接"]],[2514,2514],[2516,2516]]],[1566645329235,["GJX@GJXAIOU",[[-1,2530," "]],[2531,2531],[2530,2530]]],[1566645335275,["GJX@GJXAIOU",[[-1,2543," "]],[2544,2544],[2543,2543]]],[1566645358603,["GJX@GJXAIOU",[[-1,2567,"，"]],[2568,2568],[2567,2567]]],[1566645361489,["GJX@GJXAIOU",[[1,2567,"。，"]],[2567,2567],[2569,2569]]],[1566645362875,["GJX@GJXAIOU",[[-1,2567,"。，"]],[2569,2569],[2567,2567]]],[1566645364214,["GJX@GJXAIOU",[[1,2567,"，"]],[2567,2567],[2568,2568]]],[1566645373035,["GJX@GJXAIOU",[[-1,2613," "]],[2614,2614],[2613,2613]]],[1566645379390,["GJX@GJXAIOU",[[-1,2648," "]],[2649,2649],[2648,2648]]],[1566645382003,["GJX@GJXAIOU",[[-1,2646," "]],[2647,2647],[2646,2646]]],[1566645385397,["GJX@GJXAIOU",[[1,2655," "]],[2655,2655],[2656,2656]]],[1566645386013,["GJX@GJXAIOU",[[1,2657," "]],[2657,2657],[2658,2658]]],[1566645389027,["GJX@GJXAIOU",[[-1,2665," "]],[2666,2666],[2665,2665]]],[1566645390096,["GJX@GJXAIOU",[[1,2667," "]],[2667,2667],[2668,2668]]],[1566645390838,["GJX@GJXAIOU",[[1,2669," "]],[2669,2669],[2670,2670]]],[1566645393564,["GJX@GJXAIOU",[[-1,2662," "]],[2663,2663],[2662,2662]]],[1566645399413,["GJX@GJXAIOU",[[1,2535," "]],[2535,2535],[2536,2536]]],[1566645401246,["GJX@GJXAIOU",[[1,2534," "]],[2534,2534],[2535,2535]]],[1566645403357,["GJX@GJXAIOU",[[1,2488," "]],[2488,2488],[2489,2489]]],[1566645406926,["GJX@GJXAIOU",[[1,2470," "]],[2470,2470],[2471,2471]]],[1566645420491,["GJX@GJXAIOU",[[-1,2701," "]],[2702,2702],[2701,2701]]],[1566645425485,["GJX@GJXAIOU",[[-1,2710," "]],[2711,2711],[2710,2710]]],[1566645436204,["GJX@GJXAIOU",[[-1,2723," "]],[2724,2724],[2723,2723]]],[1566645458195,["GJX@GJXAIOU",[[-1,2827," "]],[2828,2828],[2827,2827]]],[1566645459845,["GJX@GJXAIOU",[[-1,2828," "]],[2829,2829],[2828,2828]]],[1566645465437,["GJX@GJXAIOU",[[-1,2856," "]],[2857,2857],[2856,2856]]],[1566645466940,["GJX@GJXAIOU",[[-1,2857," "]],[2858,2858],[2857,2857]]],[1566645470965,["GJX@GJXAIOU",[[-1,2863," "]],[2864,2864],[2863,2863]]],[1566645472371,["GJX@GJXAIOU",[[-1,2864," "]],[2865,2865],[2864,2864]]],[1566645487422,["GJX@GJXAIOU",[[-1,3011,"\n"]],[3011,3011],[3010,3010]]],[1566645510851,["GJX@GJXAIOU",[[-1,3108,"\n"]],[3108,3108],[3107,3107]]],[1566645529837,["GJX@GJXAIOU",[[1,3172," "]],[3172,3172],[3173,3173]]],[1566645532612,["GJX@GJXAIOU",[[1,3139," "]],[3139,3139],[3140,3140]]],[1566645536181,["GJX@GJXAIOU",[[1,3190," "]],[3190,3190],[3191,3191]]],[1566645537455,["GJX@GJXAIOU",[[1,3186," "]],[3186,3186],[3187,3187]]],[1566645539798,["GJX@GJXAIOU",[[-1,3194," "]],[3195,3195],[3194,3194]]],[1566645544965,["GJX@GJXAIOU",[[1,3215," "]],[3215,3215],[3216,3216]]],[1566645546127,["GJX@GJXAIOU",[[1,3212," "]],[3212,3212],[3213,3213]]],[1566645547453,["GJX@GJXAIOU",[[-1,3214,"O"]],[3215,3215],[3214,3214]]],[1566645549034,["GJX@GJXAIOU",[[1,3214,"Q"]],[3214,3214],[3215,3215]]],[1566645559077,["GJX@GJXAIOU",[[-1,3228,"大家"]],[3230,3230],[3228,3228]]],[1566645562411,["GJX@GJXAIOU",[[-1,3237," "]],[3238,3238],[3237,3237]]],[1566645578341,["GJX@GJXAIOU",[[-1,3134,"(1)"]],[3137,3137],[3134,3134]]],[1566645581899,["GJX@GJXAIOU",[[-1,3258,"(2)"]],[3261,3261],[3258,3258]]],[1566645585325,["GJX@GJXAIOU",[[1,3265," "]],[3265,3265],[3266,3266]]],[1566645592604,["GJX@GJXAIOU",[[-1,3295," "]],[3296,3296],[3295,3295]]],[1566645602613,["GJX@GJXAIOU",[[1,3335," "]],[3335,3335],[3336,3336]]],[1566645606144,["GJX@GJXAIOU",[[1,3359," "]],[3359,3359],[3360,3360]]],[1566645618421,["GJX@GJXAIOU",[[-1,3366," "]],[3367,3367],[3366,3366]]],[1566645622316,["GJX@GJXAIOU",[[1,3375," "]],[3375,3375],[3376,3376]]],[1566645623885,["GJX@GJXAIOU",[[1,3381," "]],[3381,3381],[3382,3382]]],[1566645653931,["GJX@GJXAIOU",[[-1,3476," "]],[3477,3477],[3476,3476]]],[1566645659749,["GJX@GJXAIOU",[[-1,3501," "]],[3502,3502],[3501,3501]]],[1566645676067,["GJX@GJXAIOU",[[-1,3553,"\n"]],[3553,3553],[3552,3552]]],[1566645680932,["GJX@GJXAIOU",[[-1,3514,"(1)"]],[3517,3517],[3514,3514]]],[1566645685582,["GJX@GJXAIOU",[[1,3514,"**"],[1,3548,"**"]],[3514,3548],[3514,3552]]],[1566645686867,["GJX@GJXAIOU",[[-1,3552,"。"]],[3553,3553],[3552,3552]]],[1566645693196,["GJX@GJXAIOU",[[1,3518," "]],[3518,3518],[3519,3519]]],[1566645696133,["GJX@GJXAIOU",[[1,3530," "]],[3530,3530],[3531,3531]]],[1566645763470,["GJX@GJXAIOU",[[-1,3666," "]],[3667,3667],[3666,3666]]],[1566645767275,["GJX@GJXAIOU",[[-1,3672," "]],[3673,3673],[3672,3672]]],[1566645768878,["GJX@GJXAIOU",[[-1,3673," "]],[3674,3674],[3673,3673]]],[1566645770371,["GJX@GJXAIOU",[[-1,3650,"\n"]],[3650,3650],[3649,3649]]],[1566645845733,["GJX@GJXAIOU",[[-1,3682,"宾"]],[3683,3683],[3682,3682]]],[1566645846905,["GJX@GJXAIOU",[[1,3682,"其"]],[3682,3682],[3683,3683]]],[1566645851939,["GJX@GJXAIOU",[[-1,3692,"追"]],[3693,3693],[3692,3692]]],[1566645853246,["GJX@GJXAIOU",[[1,3692,"避免"]],[3692,3692],[3694,3694]]],[1566645853534,["GJX@GJXAIOU",[[-1,3694,"免"]],[3694,3694],[3693,3693]]],[1566645861638,["GJX@GJXAIOU",[[1,3706," "]],[3706,3706],[3707,3707]]],[1566645863069,["GJX@GJXAIOU",[[1,3721," "]],[3721,3721],[3722,3722]]],[1566645869410,["GJX@GJXAIOU",[[1,3704,"**"],[1,3751,"**"]],[3704,3751],[3704,3755]]],[1566645871523,["GJX@GJXAIOU",[[-1,3755,"。"]],[3756,3756],[3755,3755]]],[1566645874627,["GJX@GJXAIOU",[[-1,3747," "]],[3748,3748],[3747,3747]]],[1566645880803,["GJX@GJXAIOU",[[-1,3755,"\n"]],[3755,3755],[3754,3754]]],[1566645892689,["GJX@GJXAIOU",[[1,3773,"共"]],[3773,3773],[3774,3774]]],[1566645895644,["GJX@GJXAIOU",[[1,3779,"记录"]],[3779,3779],[3781,3781]]],[1566645905051,["GJX@GJXAIOU",[[-1,3822,"\n"]],[3822,3822],[3821,3821]]],[1566646128970,["GJX@GJXAIOU",[[1,3879,"**"],[1,3933,"**"]],[3879,3933],[3879,3937]]],[1566646169354,["GJX@GJXAIOU",[[1,4530,"√: 可能出现    ×: 不会出现\n\n|  | 脏读 | 不可重复读 | 幻读 |\n| Read uncommitted | √ | √ | √ |\n| Read committed | × | √ | √ |\n| Repeatable read | × | × | √ |\n| Serializable | × | × | × |"]],[4530,4530],[4697,4697]]],[1566646173539,["GJX@GJXAIOU",[[-1,4549,"\n"]],[4549,4549],[4548,4548]]],[1566646175851,["GJX@GJXAIOU",[[1,4572,"\n"]],[4571,4571],[4572,4572]]],[1566646181846,["GJX@GJXAIOU",[[-1,4537,"    "],[1,4541,"    "],[1,4572,"|---|----|---"]],[4572,4572],[4585,4585]]],[1566646186610,["GJX@GJXAIOU",[[-1,4552,"| "]],[4553,4553],[4551,4551]]],[1566646192518,["GJX@GJXAIOU",[[1,4551,"|"]],[4551,4551],[4552,4552]]],[1566646201589,["GJX@GJXAIOU",[[1,4584,"|---"]],[4584,4584],[4588,4588]]],[1566646357722,["GJX@GJXAIOU",[[-1,4013,"\n"]],[4013,4013],[4012,4012]]],[1566646360266,["GJX@GJXAIOU",[[-1,4076,"\n"]],[4076,4076],[4075,4075]]],[1566646370507,["GJX@GJXAIOU",[[1,4110,"\n"]],[4108,4108],[4109,4109]]],[1566646370651,["GJX@GJXAIOU",[[1,4111,"\n"]],[4109,4109],[4110,4110]]],[1566646370765,["GJX@GJXAIOU",[[1,4112,"\n"]],[4110,4110],[4111,4111]]],[1566646373157,["GJX@GJXAIOU",[[1,4109,"-当然,   从总的结果来看,   似乎两者都表现为两次读取的结果不一致.\n\n但如果你从控制的角度来看,   两者的区别就比较大\n对于前者,   只需要锁住满足条件的记录\n对于后者,   要锁住满足条件及其相近的记录\n\n-----------------------------------------------------------\n\n我这么理解是否可以？\n避免不可重复读需要锁行就行\n避免幻影读则需要锁表\n\n------------------------\n\n####不可重复读和幻读的区别####\n很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。\n\n如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复 读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会 发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。\n\n**所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。**\n\n上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。"]],[4109,4109],[4831,4831]]],[1566646375757,["GJX@GJXAIOU",[[1,4110," "],[-1,4113,"   "],[1,4116,"   "],[-1,4124,"   "],[1,4127,"   "],[-1,4161,"   "],[1,4164,"   "],[-1,4179,"   "],[1,4182,"   "],[-1,4200,"   "],[1,4203,"   "]],[4110,4110],[4111,4111]]],[1566646387275,["GJX@GJXAIOU",[[-1,4111,"当然,   从总的结果来看,   似乎"]],[4111,4130],[4111,4111]]],[1566646397511,["GJX@GJXAIOU",[[1,4111,"幻读和不可"]],[4111,4111],[4116,4116]]],[1566646399591,["GJX@GJXAIOU",[[1,4116,"重复读"]],[4116,4116],[4119,4119]]],[1566646403931,["GJX@GJXAIOU",[[-1,4137,"\n"]],[4137,4137],[4136,4136]]],[1566646407395,["GJX@GJXAIOU",[[-1,4165,"前者"]],[4167,4167],[4165,4165]]],[1566646408800,["GJX@GJXAIOU",[[1,4165,"幻读"]],[4165,4165],[4167,4167]]],[1566646412523,["GJX@GJXAIOU",[[-1,4186,"后者"]],[4188,4188],[4186,4186]]],[1566646422603,["GJX@GJXAIOU",[[-1,4184,"对于,   要锁住满足条件及其相近的记录"]],[4184,4204],[4184,4184]]],[1566646424143,["GJX@GJXAIOU",[[1,4163,"\n"]],[4162,4162],[4163,4163]]],[1566646424594,["GJX@GJXAIOU",[[1,4163,"对于,   要锁住满足条件及其相近的记录"]],[4163,4163],[4183,4183]]],[1566646428600,["GJX@GJXAIOU",[[1,4165,"幻读"]],[4165,4165],[4167,4167]]],[1566646432115,["GJX@GJXAIOU",[[-1,4188,"幻读"]],[4190,4190],[4188,4188]]],[1566646440333,["GJX@GJXAIOU",[[1,4188,"不可重复读"]],[4188,4188],[4193,4193]]],[1566646478821,["GJX@GJXAIOU",[[1,4137,"- "]],[4137,4137],[4139,4139]]],[1566646482859,["GJX@GJXAIOU",[[1,4165,"- "],[1,4188,"- "]],[4165,4211],[4167,4215]]],[1566646483284,["GJX@GJXAIOU",[[1,4165,"  "],[1,4190,"  "]],[4167,4215],[4169,4219]]],[1566646504879,["GJX@GJXAIOU",[[1,4219," ： jiu"]],[4219,4219],[4225,4225]]],[1566646505533,["GJX@GJXAIOU",[[-1,4222,"jiu"]],[4225,4225],[4222,4222]]],[1566646515738,["GJX@GJXAIOU",[[1,4222,"即需要锁住行"]],[4222,4222],[4228,4228]]],[1566646526693,["GJX@GJXAIOU",[[1,4191,"  ：即需要锁住表"]],[4191,4191],[4200,4200]]],[1566646530485,["GJX@GJXAIOU",[[-1,4240,"-----------------------------------------------------------\n\n我这么理解是否可以？\n避免不可重复读需要锁行就行\n避免幻影读则需要锁表\n\n------------------------"]],[4240,4362],[4240,4240]]],[1566646530834,["GJX@GJXAIOU",[[-1,4241,"\n"]],[4240,4240],[4239,4239]]],[1566646531066,["GJX@GJXAIOU",[[-1,4240,"\n"]],[4239,4239],[4238,4238]]],[1566646531243,["GJX@GJXAIOU",[[-1,4239,"\n"]],[4238,4238],[4237,4237]]],[1566646552376,["GJX@GJXAIOU",[[1,4238,"- 幻读的重点的"]],[4238,4238],[4246,4246]]],[1566646553378,["GJX@GJXAIOU",[[-1,4245,"的"]],[4246,4246],[4245,4245]]],[1566646556752,["GJX@GJXAIOU",[[1,4245,"在于insert"]],[4245,4245],[4253,4253]]],[1566646556787,["GJX@GJXAIOU",[[1,4247," "]],[4253,4253],[4254,4254]]],[1566646557214,["GJX@GJXAIOU",[[1,4254,"；"]],[4254,4254],[4255,4255]]],[1566646557739,["GJX@GJXAIOU",[[1,4256,"- \n"]],[4255,4255],[4258,4258]]],[1566646564231,["GJX@GJXAIOU",[[1,4258,"不可重复度"]],[4258,4258],[4263,4263]]],[1566646565034,["GJX@GJXAIOU",[[-1,4262,"度"]],[4263,4263],[4262,4262]]],[1566646575772,["GJX@GJXAIOU",[[1,4262,"读的重点在于：update 和 i"]],[4262,4262],[4279,4279]]],[1566646576291,["GJX@GJXAIOU",[[-1,4278,"i"]],[4279,4279],[4278,4278]]],[1566646577701,["GJX@GJXAIOU",[[1,4278,"delete"]],[4278,4278],[4284,4284]]],[1566646581715,["GJX@GJXAIOU",[[-1,4285,"####不可重复读和幻读的区别####\n很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。"]],[4285,4370],[4285,4285]]],[1566646612653,["GJX@GJXAIOU",[[1,4690,"####悲观锁和乐观锁####\n\n*   悲观锁\n\n正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处 于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机 制，也无法保证外部系统不会修改数据）。\n\n在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。\n\n*   乐观锁\n\n相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。\n\n而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如 果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。\n\n要说明的是，MVCC的实现没有固定的规范，每个数据库都会有不同的实现方式，这里讨论的是InnoDB的MVCC。"]],[4690,4690],[5350,5350]]],[1566646615781,["GJX@GJXAIOU",[[-1,4286,"\n"]],[4286,4286],[4285,4285]]],[1566646617659,["GJX@GJXAIOU",[[1,4256,"  "]],[4263,4263],[4265,4265]]],[1566646618443,["GJX@GJXAIOU",[[1,4238,"  "]],[4247,4247],[4249,4249]]],[1566646690589,["GJX@GJXAIOU",[[1,5601,"p["]],[5601,5601],[5603,5603]]],[1566646691322,["GJX@GJXAIOU",[[-1,5601,"p["]],[5603,5603],[5601,5601]]],[1566646692542,["GJX@GJXAIOU",[[1,5601,"【】"]],[5601,5601],[5603,5603]]],[1566646694622,["GJX@GJXAIOU",[[1,5602,"mysql"]],[5602,5602],[5607,5607]]],[1566646696722,["GJX@GJXAIOU",[[-1,5602,"mysql"]],[5607,5607],[5602,5602]]],[1566646700262,["GJX@GJXAIOU",[[1,5602,"MySQL默认"]],[5602,5602],[5609,5609]]],[1566646700297,["GJX@GJXAIOU",[[1,5607," "]],[5609,5609],[5610,5610]]],[1566646703851,["GJX@GJXAIOU",[[1,5610,"级别"]],[5610,5610],[5612,5612]]],[1566646716574,["GJX@GJXAIOU",[[1,5546,"【】"]],[5546,5546],[5548,5548]]],[1566646724232,["GJX@GJXAIOU",[[1,5547,"Oracle默认"]],[5547,5547],[5555,5555]]],[1566646724267,["GJX@GJXAIOU",[[1,5553," "]],[5555,5555],[5556,5556]]],[1566646728018,["GJX@GJXAIOU",[[1,5556,"级别"]],[5556,5556],[5558,5558]]],[1566646794082,["GJX@GJXAIOU",[[-1,4591,"\n"]],[4591,4591],[4590,4590]]],[1566646798204,["GJX@GJXAIOU",[[-1,4692,"####悲观锁和乐观锁####"]],[4692,4707],[4692,4692]]],[1566646798747,["GJX@GJXAIOU",[[-1,4693,"\n"]],[4692,4692],[4691,4691]]],[1566646800362,["GJX@GJXAIOU",[[-1,4692,"\n"]],[4692,4692],[4691,4691]]],[1566646803454,["GJX@GJXAIOU",[[-1,4700,"\n"]],[4700,4700],[4699,4699]]],[1566646815355,["GJX@GJXAIOU",[[-1,4950,"\n"]],[4950,4950],[4949,4949]]]],null,"GJX@GJXAIOU"],["dcfd7803-7c1f-49cd-822c-241bad37c0a8",1566782697974,"## 章五：SQL、JDBC 和数据库编程\n\n### 一、SQL 语句注意事项\n\n- 尽量别写 `select *`；一方面获得值当数据库变化时会改变，同时数据量过大造成性能问题；select 语句执行时间 = 数据库服务器执行该 SQL 的时间 + 结果返回时间；\n\n- 注意 `count(*)` 和 `count(字段名)`\n当正好该字段允许空值时候，两者返回记录条数的不一致；\n**但是当该字段正好为主键的时候，因为主键上有索引，因此效率比 count(*) 高；**\n\n- 在使用 insert 插入使用应该使用字段列表；\n\n- MySQL 和 SQL Server 支持一次性插入多条数据，Oracle 不支持；但是不能无限多的插入，否则会出错；插入的多个值使用 `,` 分开: `values ('',''), ('','')`。\n\n- delete 中可以使用 in 语句同时删除多个记录；但是同样不能过多；用法：`delect from A where id in(1, 2, 3, xxx)`；\n\n- 使用 merge 语句实现：无则插入有则更新；但是 Oracle、SQLserver 不支持；\nDemo：根据图书进货表中的 ISBN，匹配图书表，没有记录就增加，有就用图书进货表中信息更新图书表中信息（只更新以 Java 开头的书籍）\n```sql\nmerge into图书表a\nusing图书进货表b\non(a.ISBN=b.ISBN)\nwhen matched then update set a.图书名称 = b.图书名称\n    where b.图书名称 like 'java%' \nwhen not macthed then \n    insert into a(ISBN, 图书名称 values(b.ISBN,b.图书名称）\n        where b.图书名称 like 'java%' \n```\n\n- 存储过程 \n  - 这是个争议点：**存储过程只在创建时进行编译， 以后每次执行时都不需要重新编译**， 这样能提高数据库执行速度。\n 但是，一般在存储过程中会有 insert、delete 或 update 的语句的集合，在创建存储过程时，这些语句确实会被编译。不过如果对比—下在存储过程里和在 JDBC(或者 Hibernate)等场合里多次执行 insert 或 delete、update 语句，那么会发现两者的性能差异并不是很明显，更何况在JDBC等场合下还可以通过 PreparedStatement 对象的批处理来优化执行性能。\n\n- 如果针对某个业务逻辑，要对多个表进行多次 insert、delete、update 或 select 操作， 那么可以**把这些操作汇集成一个存储过程** 。 这样以后每次执行业务时， 只需要调用这个存储过程即可， 这样能提升代码的可重用性， 这也是存储过程的价值所在。\n\n- **存储过程的移植性很差**，如针对 MySOL 数据库的存储过程不能在 Oracle 上使用，但是一般也不换数据库；\n\n- **存储过程中很难调试，很难找到具体错误**，如在—个存储过程中有 5 个 insert 语句，分别向 5 张不同的表中插入数据，在某次通过JDBC执行该存储过程时， 向第三张表中插数据的insert语句发生—个 “主键冲突＂ 的错误，这时从 Java 语句抛出的异常来看， 只能知道 ”哪个执行存储过程出错＂ ，至于是存储过程中的哪句语句出的异常，这就只能靠自己去查了。\n\n- **用批处理方式的性能要比用存储过程的好** ， 所以在项目里并没有用存储过程来处理大批量的insert、 delete或update的操作。\n\n\n### 二、使用 JDBC 开发\n\n屏蔽了数据库中的实现细节，只要数据表名不变、表中字段不变，不同种类数据库之间只要修改很少的 jdbc 代码就可以实现迁移；\n\n- 使用 jdbc 开发，通过 `getString(字段名)、getInt()、getfloat() 、getDate()` 等获取字段值；\n- 一定要在 `finally` 中关闭所有的链接；\n- MySQL 更换到 Oracle 时 JDBC 需要更改的地方；\n  - 导入的驱动文件不再是 `mysql-connector-java.jar`，改为：`ojdbc.jar`；\n  - 通过 `Class.forName(“com.musql.jdbc.Driver”)` 装载的驱动修改为 Oracle 的：`“oracle.jdbc.driver.OracleDriver”`;\n  - `getConnection()` 方法中的数据库连接的 URL 需要由 `”jdbc: mysql://localhost:3306/数据库名“`  改为 `”jdbc:oracle:thin:@localhost:1521:数据库名“`\n\n\n### 三、优化数据库部分代码\n\n#### （一）将相对固定的连接信息写入配置文件\n\n- 减少多个代码同时用到数据库连接参数需要多次配置；\n- 对于测试和生产两种生产环境，可以使用两种不同的配置文件，使用命令行切换即可；\n\ndb.properties 写法：\n```properties\ndriver = com.mysql.cj.jdbc.Driver\nurl = jdbc:mysql://localhost:3306/数据库名?serverTimezone = GMT%2B8\nuser = 用户名\npassword = 密码\n```\n\n#### （二）用 PreparedStatement 以批处理的方式操作数据库\n\n**PreparedStatement 是预处理，一般用于批处理和防止 SQL 注入**；\n当需要在一个方法中执行多个插入（更新或者删除）操作时候，可以使用批处理；\n\n如果通过 `ps.executeUpdate` 的方式一条条地执行语句，那么每次执行语句都包括 “ 连接数据库＋执行语句＋释放数据库连接\"  3 个动作。相比之下，如果用批处理（executeBatch）的方式， 那么耗费的代价是 “—次连接＋多次执行＋一次释放 ” ，这样就能省去多次连接和释放数据库资源从而提升操作性能；\n\n- PreparedStatement里，占位符的编号是从 1 开始的，而不是从 0 开始的；\n- 批量操作能提升效率， 但一次性操作多少 ，效率能提升多高？这在不同的数据库中是不同的，一般每批是操作500 - 1000条语句。不要太多不然缓存放不完；\n\n\n#### （三）用 PreparedStatement 对象防止 SQL 注入\n\n#### （四）使用 C3P0 连接池\n如果操作很频繁，那么频繁的创建和关闭数据库连接动作会极大地减低系统的性能，在这种情况下，可以使用连接池；\n- 常见连接池有：C3P0 和 DBCP\n\n- C3P0 连接池的常用属性：\n![C3P0连接池常见属性]($resource/C3P0%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7.png)\n\n### 四、事务\n事务(Transaction)是—组针对数据库的操作， 这些操作要么都做， 要么都不做， 是 一个不可分割的 SQL 语句集合。\n\n#### （一）开启事务，合理的提交和回滚\n在JDBC中， 一般采用如下的方法使用事务。\n\n- 通过 `connection.setAutoCommit(false)` , 设置不是自动提交。在 JDBC 中，一般默认是自动提交，即有任何增删改的 SQL 语句都会立即执行。如果设置了非自动提交，要在用好事务后设置回 “ 自动提交” 。\n\n- 在合适的地方用 `connection.commit();` 来提交事务，一般是在执行结束后提交事务， 这样就会同时执行事务中的所有操作。\n\n- 可以通过 `connection.rollback()` 来回滚事务，回滚语句—般是放在 catch 从句中；一旦出现异常，就在 catch 中实现回滚；\n\n#### （二）事务中的常见问题：脏读、幻读和不可重复读\n在项目中， 如果**同时对一张表有两个（或多个） 事务进行读写操作时**，很容易出现数据读写错误的问题，具体表现形式有脏读、幻读和不可重复读。\n\n- **脏读 (dirtyread) 是指—个事务读取了另—个事务尚未提交的数据**\nA 值为 1，B 将其值设置为 2（但是尚未提交这个修改事务），A 读到值变为 2，结果 B 回滚了事务又将 A 值改为 1,则 A 读到的 2 就是一个脏数据，对应的操作为**脏读**；\n**避免方法：** 如果在第—个事务提交前，任何其他事务不可读取其修改过的值，则可以避免出现该问题。\n\n- **幻读 (phantom read) 是指一个事务的操作会导致另一个事务前后两次查询的结果不同**\nA 事务查询值为 1 的数据，读取到共 10 条记录，然后事务 B 插入一条数据值为 1，A 再次以同样条件读取就会得到 11 条；\n**避免方法：** 如果在操作事务完成数据处理之前 ， 任何其他事务都不可以添加新数据， 则可避免该问题。\n\n- **不可重复读(non-repeatable read)是指—个事务的操作导致另—个事务前后两次读取到不同的数据**。例如， 同—查询 在同一事务中多次进行， 由于其他事务提交了所做的修改（或和加或删除等操作） ， 这样每次查询会返回不同的结果集，这就是不可重复读。\nA 读到的值为 1，但是针对这个值的修改没有完成，事务 B 修改了值为 2，并提交了事务，则事务 A 再次读取值变为了 2；\n**避免方法：** 只有在修改事务完全提交之后才允许读取数据；\n\n- 幻读和不可重复读两者都表现为两次读取的结果不一致.\n- 但如果你从控制的角度来看,   两者的区别就比较大\n  - 对于幻读,   要锁住满足条件及其相近的记录  ：即需要锁住表\n  - 对于不可重复读,   只需要锁住满足条件的记录 ： 即需要锁住行\n  - 幻读的重点在于 insert；\n  - 不可重复读的重点在于：update 和 delete\n\n如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复 读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会 发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。\n\n**所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。**\n上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。\n\n*   悲观锁\n正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处 于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机 制，也无法保证外部系统不会修改数据）。\n\n在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。\n\n*   乐观锁\n相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。\n\n而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如 果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。\n\n要说明的是，MVCC的实现没有固定的规范，每个数据库都会有不同的实现方式，这里讨论的是InnoDB的MVCC。\n\n#### （三）事务隔离级别\n用户可以通过事务隔离级别来解决上述在事务中读写不一致的问题。在JDBC中，有5个常量来描述事务隔离级别，级别从低到高依次如下。\n\n(1)读取未提交：`TRANSACTION_READ_UNCOMMITTED`, 允许脏读、不可重复读和幻读。\n(2)读取提交：`TRANSACTION_READ_COMMITTED`, 禁止脏读，但允许不可重复读和幻读。【Oracle 默认级别】\n(3)可重读：`TRANSACTION_REPEATABLE_READ`,禁止脏读和不可重复读，但允许幻读。【MySQL 默认级别】\n(4)可串化：`TRANSACTION_SER IALIZABLE`, 禁止脏读、不可重复读和幻读。\n(5)还有一个常量是`TRANSACTION_NONE`,如果读取这个值，那么将使用当前数据库说指定的事务隔离级别；\n\n综上所述，如果设置高级别的事务隔离级别，那么数据库系统就要采取额外的措施来保证这个设置。会造成后续的操作和功能等待。\n\n√: 可能出现    ×: 不会出现\n| | 脏读 | 不可重复读 | 幻读 |\n|---|----|---|---\n| Read uncommitted | √ | √ | √ |\n| Read committed | × | √ | √ |\n| Repeatable read | × | × | √ |\n| Serializable | × | × | × |\n\n\n\n\n\n==P181==\n\n",[[1566782653899,["GJX@GJXAIOU",[[-1,5967,"==P181=="]],[5967,5975],[5967,5967]]],[1566782654032,["GJX@GJXAIOU",[[-1,5968,"\n"]],[5967,5967],[5966,5966]]],[1566782655377,["GJX@GJXAIOU",[[-1,5967,"\n"]],[5966,5966],[5965,5965]]],[1566782674395,["GJX@GJXAIOU",[[1,5965,"## 章六、反射机制和代理模式"]],[5965,5965],[5980,5980]]],[1566782674897,["GJX@GJXAIOU",[[1,5982,"\n"]],[5980,5980],[5981,5981]]],[1566782675056,["GJX@GJXAIOU",[[1,5983,"\n"]],[5981,5981],[5982,5982]]],[1566782684265,["GJX@GJXAIOU",[[1,5984,"\n"]],[5983,5983],[5984,5984]]],[1566782684367,["GJX@GJXAIOU",[[1,5985,"\n"]],[5984,5984],[5985,5985]]],[1566782684473,["GJX@GJXAIOU",[[1,5986,"\n"]],[5985,5985],[5986,5986]]],[1566782684593,["GJX@GJXAIOU",[[1,5987,"\n"]],[5986,5986],[5987,5987]]],[1566782684719,["GJX@GJXAIOU",[[1,5988,"\n"]],[5987,5987],[5988,5988]]],[1566782684847,["GJX@GJXAIOU",[[1,5989,"\n"]],[5988,5988],[5989,5989]]],[1566782684969,["GJX@GJXAIOU",[[1,5990,"\n"]],[5989,5989],[5990,5990]]],[1566782685095,["GJX@GJXAIOU",[[1,5991,"\n"]],[5990,5990],[5991,5991]]],[1566782685595,["GJX@GJXAIOU",[[1,5992,"\n"]],[5991,5991],[5992,5992]]],[1566782685628,["GJX@GJXAIOU",[[1,5993,"\n"]],[5992,5992],[5993,5993]]],[1566782685670,["GJX@GJXAIOU",[[1,5994,"\n"]],[5993,5993],[5994,5994]]],[1566782685703,["GJX@GJXAIOU",[[1,5995,"\n"]],[5994,5994],[5995,5995]]],[1566782685736,["GJX@GJXAIOU",[[1,5996,"\n"]],[5995,5995],[5996,5996]]],[1566782685773,["GJX@GJXAIOU",[[1,5997,"\n"]],[5996,5996],[5997,5997]]],[1566782685806,["GJX@GJXAIOU",[[1,5998,"\n"]],[5997,5997],[5998,5998]]],[1566782685840,["GJX@GJXAIOU",[[1,5999,"\n"]],[5998,5998],[5999,5999]]],[1566782685873,["GJX@GJXAIOU",[[1,6000,"\n"]],[5999,5999],[6000,6000]]],[1566782685916,["GJX@GJXAIOU",[[1,6001,"\n"]],[6000,6000],[6001,6001]]],[1566782685953,["GJX@GJXAIOU",[[1,6002,"\n"]],[6001,6001],[6002,6002]]],[1566782685986,["GJX@GJXAIOU",[[1,6003,"\n"]],[6002,6002],[6003,6003]]],[1566782686087,["GJX@GJXAIOU",[[1,6004,"\n"]],[6003,6003],[6004,6004]]],[1566782686234,["GJX@GJXAIOU",[[1,6005,"\n"]],[6004,6004],[6005,6005]]],[1566782686352,["GJX@GJXAIOU",[[1,6006,"\n"]],[6005,6005],[6006,6006]]],[1566782750599,["GJX@GJXAIOU",[[1,5983,"### 字节码和反射机制"]],[5983,5983],[5995,5995]]],[1566782751000,["GJX@GJXAIOU",[[1,6019,"\n"]],[5995,5995],[5996,5996]]],[1566782751139,["GJX@GJXAIOU",[[1,6020,"\n"]],[5996,5996],[5997,5997]]],[1566782791707,["GJX@GJXAIOU",[[1,5996,"字节码 (Byte Code) 是Java 语言跨平台特性的重要保障， 也是反射机制的重要基础。通过反射机制 ， 我们不仅能看到一个类的属性和方法， 还能在—个类中调用另一个类的方法，但前提是要有相关类的字节码文件（也就是 class 文件）。"]],[5996,5996],[6118,6118]]],[1566782854104,["GJX@GJXAIOU",[[1,6143,"\n"]],[6119,6119],[6120,6120]]],[1566782859077,["GJX@GJXAIOU",[[1,6120,"- Java文件"]],[6120,6120],[6128,6128]]],[1566782859112,["GJX@GJXAIOU",[[1,6126," "]],[6128,6128],[6129,6129]]],[1566782861946,["GJX@GJXAIOU",[[1,6122,"."]],[6122,6122],[6123,6123]]],[1566782869050,["GJX@GJXAIOU",[[1,6130,"编译审查恒"]],[6130,6130],[6135,6135]]],[1566782869654,["GJX@GJXAIOU",[[-1,6132,"审查恒"]],[6135,6135],[6132,6132]]],[1566782875284,["GJX@GJXAIOU",[[1,6132,"生成的"]],[6132,6132],[6135,6135]]],[1566782879301,["GJX@GJXAIOU",[[1,6135,"字节码问"]],[6135,6135],[6139,6139]]],[1566782881031,["GJX@GJXAIOU",[[-1,6135,"字节码问"]],[6139,6139],[6135,6135]]],[1566782881714,["GJX@GJXAIOU",[[1,6135,"."]],[6135,6135],[6136,6136]]],[1566782882546,["GJX@GJXAIOU",[[-1,6135,"."]],[6136,6136],[6135,6135]]],[1566782899721,["GJX@GJXAIOU",[[1,6135," .class 文件可以在各种平台中运行（）"]],[6135,6135],[6157,6157]]],[1566782905109,["GJX@GJXAIOU",[[1,6156,"只要其有Java"]],[6156,6156],[6164,6164]]],[1566782905143,["GJX@GJXAIOU",[[1,6160," "]],[6164,6164],[6165,6165]]],[1566782907319,["GJX@GJXAIOU",[[1,6165,"运行环境"]],[6165,6165],[6169,6169]]],[1566782907352,["GJX@GJXAIOU",[[1,6165," "]],[6169,6169],[6170,6170]]],[1566782909195,["GJX@GJXAIOU",[[1,6171,"；"]],[6171,6171],[6172,6172]]],[1566782909656,["GJX@GJXAIOU",[[1,6173,"- \n"]],[6172,6172],[6175,6175]]],[1566783017817,["GJX@GJXAIOU",[[1,6175,"Class 类的全称是」ava.lang.Class, 当一个类或接口（总之是」ava 文件被编译后的 class 文件）被装入Java 虚拟机 (JVM) 时便会产生一个与它相关联的 java.lang.Class 对象， 在反射部分的代码中， 我们一般通过 Class 来访问和使用目标类的属性和方法。"]],[6175,6175],[6328,6328]]],[1566783021160,["GJX@GJXAIOU",[[-1,6186,"」"]],[6187,6187],[6186,6186]]],[1566783023332,["GJX@GJXAIOU",[[1,6186,"J"]],[6186,6186],[6187,6187]]],[1566783023367,["GJX@GJXAIOU",[[1,6186," "]],[6187,6187],[6188,6188]]],[1566783033563,["GJX@GJXAIOU",[[-1,6215,"」"]],[6216,6216],[6215,6215]]],[1566783037566,["GJX@GJXAIOU",[[1,6215,"J"]],[6215,6215],[6216,6216]]],[1566783037603,["GJX@GJXAIOU",[[1,6215," "]],[6216,6216],[6217,6217]]],[1566783053451,["GJX@GJXAIOU",[[1,6334,"### "]],[6334,6334],[6338,6338]]],[1566783059938,["GJX@GJXAIOU",[[1,6338,"反射的常见用法"]],[6338,6338],[6345,6345]]],[1566783060252,["GJX@GJXAIOU",[[1,6365,"\n"]],[6345,6345],[6346,6346]]],[1566783069089,["GJX@GJXAIOU",[[1,6347,"一是 “查看＇ ， 如输入某个类的属性方法等信琶二是 ＂ 装载'' 如装载指定的类到内存中；三是 “调用” 如通过输入参数， 调用指定的方法。"]],[6347,6347],[6418,6418]]],[1566783073697,["GJX@GJXAIOU",[[-1,6369,"信琶"]],[6371,6371],[6369,6369]]],[1566783079253,["GJX@GJXAIOU",[[1,6369,"信息；"]],[6369,6369],[6372,6372]]],[1566783079753,["GJX@GJXAIOU",[[1,6372,"\n"]],[6372,6372],[6373,6373]]],[1566783089521,["GJX@GJXAIOU",[[1,6395,"\n"]],[6395,6395],[6396,6396]]],[1566783235675,["GJX@GJXAIOU",[[1,6423,"- 查看属性"]],[6423,6423],[6429,6429]]],[1566783238278,["GJX@GJXAIOU",[[1,6429,"Demo"]],[6429,6429],[6433,6433]]],[1566783238313,["GJX@GJXAIOU",[[1,6429," "]],[6433,6433],[6434,6434]]],[1566783239094,["GJX@GJXAIOU",[[1,6434,"："]],[6434,6434],[6435,6435]]],[1566783240161,["GJX@GJXAIOU",[[1,6436,"- \n"]],[6435,6435],[6438,6438]]],[1566783240640,["GJX@GJXAIOU",[[-1,6436,"- "]],[6438,6438],[6436,6436]]],[1566783242292,["GJX@GJXAIOU",[[1,6436,"```"]],[6436,6436],[6439,6439]]],[1566783242329,["GJX@GJXAIOU",[[1,6439,"language\n```\n"]],[6439,6439],[6439,6447]]],[1566783243189,["GJX@GJXAIOU",[[-1,6439,"language"],[1,6447,"j"]],[6439,6447],[6440,6440]]],[1566783243571,["GJX@GJXAIOU",[[1,6440,"ava"]],[6440,6440],[6443,6443]]],[1566783243657,["GJX@GJXAIOU",[[1,6444,"\n"]],[6443,6443],[6444,6444]]],[1566783558674,["GJX@GJXAIOU",[[1,6444,"class MyValClass {\n\tprivate int val1;\n\tpublic String val2;\n\tfinal protected String val3 = \"Java\";\n}\n\npublic class ReflectionReadVar{ \n\tpublic static void main(String[] args) {\n\t\tClass<MyValClass> clazz = MyValClass.class;\n\t\t//获取这个类的所有属性\n        Field[] fields = clazz.getDeclaredFields();\n\t    for(Field field : fields) {\n\t\t   //输出修饰符\n\t\t   System.out.print(Modifier.toString(field.getModifiers()) + \"\\t\");\n\t\t   //输出属性的类型\n\t\t   System.out.print(field.getGenericType().toString() + \"\\t\");\n\t\t   //输出属性的名字\n\t\t   System.out.println(field.getName());\n\t    }\n\t}\n}"]],[6444,6444],[6998,6998]]],[1566783590147,["GJX@GJXAIOU",[[1,6429,"d"]],[6429,6429],[6430,6430]]],[1566783590185,["GJX@GJXAIOU",[[1,6429," "]],[6430,6430],[6431,6431]]],[1566783590324,["GJX@GJXAIOU",[[1,6431,"e"]],[6431,6431],[6432,6432]]],[1566783590444,["GJX@GJXAIOU",[[1,6433," "]],[6432,6432],[6433,6433]]],[1566783591817,["GJX@GJXAIOU",[[-1,6430,"de  "]],[6433,6433],[6429,6429]]],[1566783596197,["GJX@GJXAIOU",[[1,6429,"的修饰符、"]],[6429,6429],[6434,6434]]],[1566783600342,["GJX@GJXAIOU",[[1,6434,"类型和名称"]],[6434,6434],[6439,6439]]],[1566783622720,["GJX@GJXAIOU",[[1,7014,"- 查看方法的返回值类型、参数和名称"]],[7014,7014],[7032,7032]]],[1566784037327,["GJX@GJXAIOU",[[1,7033,"·"]],[7033,7033],[7034,7034]]],[1566784038081,["GJX@GJXAIOU",[[-1,7033,"·"]],[7034,7034],[7033,7033]]],[1566784039300,["GJX@GJXAIOU",[[1,7033,"```"]],[7033,7033],[7036,7036]]],[1566784039336,["GJX@GJXAIOU",[[1,7036,"language\n```\n"]],[7036,7036],[7036,7044]]],[1566784039485,["GJX@GJXAIOU",[[1,7036,"`"],[1,7044,"`"]],[7036,7044],[7036,7046]]],[1566784040765,["GJX@GJXAIOU",[[-1,7035,"``language`"]],[7036,7046],[7035,7035]]],[1566784043300,["GJX@GJXAIOU",[[1,7035,"`java"]],[7035,7035],[7040,7040]]],[1566784043522,["GJX@GJXAIOU",[[1,7041,"\n"]],[7040,7040],[7041,7041]]],[1566784046144,["GJX@GJXAIOU",[[1,7041,"class MyFuncClass {\n\tpublic MyFuncClass(){}\n\tpublic MyFuncClass(int i){}\n\tprivate void f1(){}\n\tprotected int f2(int i){return 0;}\n\tpublic String f2(String s) {return \"Java\";}\n}\n\npublic class ReflectionReadFunc {\n\tpublic static void main(String[] args) {\n\t\tClass<MyFuncClass> clazz = MyFuncClass.class;\n\t\t// 返回所有的方法，但是不包括继承的方法和构造方法\n        Method[] methods = clazz.getDeclaredMethods();\n        for (Method method : methods) {\n            System.out.println(method);\n        }\n        System.out.println(\"***********\");\n       \n        //得到所有的构造函数\n        Constructor[] c1 = clazz.getDeclaredConstructors();\n        //输出所有的构造函数\n        for(Constructor ct : c1){\n            System.out.println(ct);\n        }\n\t}\n}"]],[7041,7041],[7752,7752]]],[1566784078115,["GJX@GJXAIOU",[[1,7753,"\n"]],[7752,7752],[7753,7753]]],[1566784078542,["GJX@GJXAIOU",[[1,7753,"/**\n * output: * protected int chapter6.MyFuncClass.f2(int) * public java.lang.String chapter6.MyFuncClass.f2(java.lang.String) * private void chapter6.MyFuncClass.f1() * *********** * public chapter6.MyFuncClass() * public chapter6.MyFuncClass(int) */"]],[7753,7753],[8005,8005]]],[1566784080283,["GJX@GJXAIOU",[[-1,7753,"/**\n * output: * protected int chapter6.MyFuncClass.f2(int) * public java.lang.String chapter6.MyFuncClass.f2(java.lang.String) * private void chapter6.MyFuncClass.f1() * *********** * public chapter6.MyFuncClass() * public chapter6.MyFuncClass(int) */"]],[8005,8005],[7753,7753]]],[1566784081979,["GJX@GJXAIOU",[[-1,7753,"\n"]],[7753,7753],[7752,7752]]],[1566784086452,["GJX@GJXAIOU",[[1,7753,"\n"]],[7752,7752],[7753,7753]]],[1566784089330,["GJX@GJXAIOU",[[1,7753,"/**\n * output:\n * protected int chapter6.MyFuncClass.f2(int)\n * public java.lang.String chapter6.MyFuncClass.f2(java.lang.String)\n * private void chapter6.MyFuncClass.f1()\n * ***********\n * public chapter6.MyFuncClass()\n * public chapter6.MyFuncClass(int)\n */"]],[7753,7753],[8012,8012]]],[1566784178098,["GJX@GJXAIOU",[[1,7009,"\n"]],[7008,7008],[7009,7009]]],[1566784181069,["GJX@GJXAIOU",[[1,7009,"/**output:\n * private\tint\tval1\n * public\tclass java.lang.String\tval2\n * protected final\tclass java.lang.String\tval3\n */"]],[7009,7009],[7128,7128]]],[1566784333095,["GJX@GJXAIOU",[[1,8138,"- tongguo"]],[8138,8138],[8147,8147]]],[1566784334635,["GJX@GJXAIOU",[[-1,8140,"tongguo"]],[8147,8147],[8140,8140]]],[1566784340887,["GJX@GJXAIOU",[[1,8140,"通过forName"]],[8140,8140],[8149,8149]]],[1566784340922,["GJX@GJXAIOU",[[1,8142," "]],[8149,8149],[8150,8150]]],[1566784341742,["GJX@GJXAIOU",[[1,8150,"和"]],[8150,8150],[8151,8151]]],[1566784341779,["GJX@GJXAIOU",[[1,8150," "]],[8151,8151],[8152,8152]]],[1566784342413,["GJX@GJXAIOU",[[1,8152,"n"]],[8152,8152],[8153,8153]]],[1566784342448,["GJX@GJXAIOU",[[1,8152," "]],[8153,8153],[8154,8154]]],[1566784350526,["GJX@GJXAIOU",[[1,8154,"ewInstance方法"]],[8154,8154],[8166,8166]]],[1566784350563,["GJX@GJXAIOU",[[1,8164," "]],[8166,8166],[8167,8167]]],[1566784352112,["GJX@GJXAIOU",[[1,8167,"加载类"]],[8167,8167],[8170,8170]]],[1566784367298,["GJX@GJXAIOU",[[1,6423,"\n"]],[6422,6422],[6423,6423]]],[1566784374130,["GJX@GJXAIOU",[[1,6423,"#### 查看"]],[6423,6423],[6430,6430]]],[1566784378818,["GJX@GJXAIOU",[[1,8146,"\n"]],[8145,8145],[8146,8146]]],[1566784382266,["GJX@GJXAIOU",[[1,8146,"#### 装在"]],[8146,8146],[8153,8153]]],[1566784382898,["GJX@GJXAIOU",[[-1,8151,"装在"]],[8153,8153],[8151,8151]]],[1566784385906,["GJX@GJXAIOU",[[1,8151,"装载"]],[8151,8151],[8153,8153]]],[1566784423754,["GJX@GJXAIOU",[[1,8187,"- \n"]],[8186,8186],[8189,8189]]],[1566784424765,["GJX@GJXAIOU",[[1,8187,"  "]],[8189,8189],[8191,8191]]],[1566784435287,["GJX@GJXAIOU",[[1,8191,"Class.forName方法"]],[8191,8191],[8206,8206]]],[1566784435322,["GJX@GJXAIOU",[[1,8204," "]],[8206,8206],[8207,8207]]],[1566784449426,["GJX@GJXAIOU",[[1,8207,"最常用的用法就是转载数据库的额驱动"]],[8207,8207],[8224,8224]]],[1566784451658,["GJX@GJXAIOU",[[-1,8221,"额"]],[8222,8222],[8221,8221]]],[1566784453546,["GJX@GJXAIOU",[[-1,8215,"转"]],[8216,8216],[8215,8215]]],[1566784455377,["GJX@GJXAIOU",[[1,8215,"装载"]],[8215,8215],[8217,8217]]],[1566784455626,["GJX@GJXAIOU",[[-1,8217,"载"]],[8217,8217],[8216,8216]]],[1566784458317,["GJX@GJXAIOU",[[1,8223,"；"]],[8223,8223],[8224,8224]]],[1566784467389,["GJX@GJXAIOU",[[1,8225,"  - \n"]],[8224,8224],[8229,8229]]],[1566784471622,["GJX@GJXAIOU",[[1,8229,"本质上f"]],[8229,8229],[8233,8233]]],[1566784471659,["GJX@GJXAIOU",[[1,8232," "]],[8233,8233],[8234,8234]]],[1566784471751,["GJX@GJXAIOU",[[1,8234,"o"]],[8234,8234],[8235,8235]]],[1566784472437,["GJX@GJXAIOU",[[-1,8234,"o"]],[8235,8235],[8234,8234]]],[1566784472590,["GJX@GJXAIOU",[[1,8234,"r"]],[8234,8234],[8235,8235]]],[1566784473410,["GJX@GJXAIOU",[[-1,8234,"r"]],[8235,8235],[8234,8234]]],[1566784476704,["GJX@GJXAIOU",[[1,8234,"orName的"]],[8234,8234],[8241,8241]]],[1566784476742,["GJX@GJXAIOU",[[1,8240," "]],[8241,8241],[8242,8242]]],[1566784477832,["GJX@GJXAIOU",[[1,8242,"最庸"]],[8242,8242],[8244,8244]]],[1566784478546,["GJX@GJXAIOU",[[-1,8242,"最庸"]],[8244,8244],[8242,8242]]],[1566784488256,["GJX@GJXAIOU",[[1,8242,"作用仅仅是返回一个Class"]],[8242,8242],[8256,8256]]],[1566784488293,["GJX@GJXAIOU",[[1,8251," "]],[8256,8256],[8257,8257]]],[1566784491527,["GJX@GJXAIOU",[[1,8257,"队形"]],[8257,8257],[8259,8259]]],[1566784491563,["GJX@GJXAIOU",[[1,8257," "]],[8259,8259],[8260,8260]]],[1566784491874,["GJX@GJXAIOU",[[1,8260,"的"]],[8260,8260],[8261,8261]]],[1566784492499,["GJX@GJXAIOU",[[-1,8258,"队形的"]],[8261,8261],[8258,8258]]],[1566784495973,["GJX@GJXAIOU",[[1,8258,"类型的对象，"]],[8258,8258],[8264,8264]]],[1566784501381,["GJX@GJXAIOU",[[1,8264,"newInd"]],[8264,8264],[8270,8270]]],[1566784502453,["GJX@GJXAIOU",[[-1,8269,"d"]],[8270,8270],[8269,8269]]],[1566784508593,["GJX@GJXAIOU",[[1,8269,"stance方法"]],[8269,8269],[8277,8277]]],[1566784508628,["GJX@GJXAIOU",[[1,8275," "]],[8277,8277],[8278,8278]]],[1566784512695,["GJX@GJXAIOU",[[1,8278,"作用是加载类；"]],[8278,8278],[8285,8285]]],[1566784515163,["GJX@GJXAIOU",[[1,8286,"  - \n"]],[8285,8285],[8290,8290]]],[1566784822660,["GJX@GJXAIOU",[[-1,8286,"  - "]],[8286,8290],[8286,8286]]],[1566784823831,["GJX@GJXAIOU",[[1,8286,"··"]],[8286,8286],[8288,8288]]],[1566784824516,["GJX@GJXAIOU",[[-1,8286,"··"]],[8288,8288],[8286,8286]]],[1566784825678,["GJX@GJXAIOU",[[1,8286,"```"]],[8286,8286],[8289,8289]]],[1566784825714,["GJX@GJXAIOU",[[1,8289,"language\n```\n"]],[8289,8289],[8289,8297]]],[1566784826966,["GJX@GJXAIOU",[[-1,8289,"language"],[1,8297,"j"]],[8289,8297],[8290,8290]]],[1566784827397,["GJX@GJXAIOU",[[1,8290,"ava"]],[8290,8290],[8293,8293]]],[1566784827627,["GJX@GJXAIOU",[[1,8294,"\n"]],[8293,8293],[8294,8294]]],[1566784831160,["GJX@GJXAIOU",[[1,8294,"class MyClass {\n\tpublic void print() {\n\t\tSystem.out.println(\"Java\");\n\t}\n}\n\npublic class ForClassDemo {\n\tpublic static void main(String[] args) {\n\t\tMyClass myClassObj = new MyClass();\n\t\tmyClassObj.print();//输出是Java\n\t\tSystem.out.println(\"*************\");\n\n\t\ttry {\n\t\t\tClass<?> clazz = Class.forName(\"chapter6.MyClass\");\n\t\t\tMyClass myClass = (MyClass)clazz.newInstance();\n\t\t\tmyClass.print();//输出是Java\n\t\t} catch (ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (InstantiationException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IllegalAccessException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}"]],[8294,8294],[8888,8888]]],[1566784835812,["GJX@GJXAIOU",[[1,8558,"\n\t\t"]],[8555,8555],[8558,8558]]],[1566784836590,["GJX@GJXAIOU",[[1,8558,"//"]],[8558,8558],[8560,8560]]],[1566784839132,["GJX@GJXAIOU",[[1,8558,"    "]],[8558,8558],[8562,8562]]],[1566784855760,["GJX@GJXAIOU",[[1,8564," forName() 中的类名应该是完整的"]],[8564,8564],[8585,8585]]],[1566784858145,["GJX@GJXAIOU",[[1,8585,"列名"]],[8585,8585],[8587,8587]]],[1566784859324,["GJX@GJXAIOU",[[-1,8585,"列名"]],[8587,8587],[8585,8585]]],[1566784861113,["GJX@GJXAIOU",[[1,8585,"类名"]],[8585,8585],[8587,8587]]],[1566784865148,["GJX@GJXAIOU",[[1,8921,"\n"]],[8920,8920],[8921,8921]]],[1566784889097,["GJX@GJXAIOU",[[1,8921,"/**\n * output:\n * Java\n * *************\n * Java\n */"]],[8921,8921],[8972,8972]]],[1566785192528,["GJX@GJXAIOU",[[1,8285,"即n"]],[8285,8285],[8287,8287]]],[1566785192567,["GJX@GJXAIOU",[[1,8286," "]],[8287,8287],[8288,8288]]],[1566785202926,["GJX@GJXAIOU",[[1,8288,"ewInstance 作用是通过Java"]],[8288,8288],[8308,8308]]],[1566785202964,["GJX@GJXAIOU",[[1,8304," "]],[8308,8308],[8309,8309]]],[1566785204745,["GJX@GJXAIOU",[[1,8309,"虚拟机"]],[8309,8309],[8312,8312]]],[1566785204784,["GJX@GJXAIOU",[[1,8309," "]],[8312,8312],[8313,8313]]],[1566785215859,["GJX@GJXAIOU",[[1,8313,"的类加载机制把指定的类架子啊"]],[8313,8313],[8327,8327]]],[1566785216764,["GJX@GJXAIOU",[[-1,8324,"架子啊"]],[8327,8327],[8324,8324]]],[1566785262393,["GJX@GJXAIOU",[[1,8324,"加载到内存中。但是newInstance"]],[8324,8324],[8344,8344]]],[1566785262430,["GJX@GJXAIOU",[[1,8333," "]],[8344,8344],[8345,8345]]],[1566785263482,["GJX@GJXAIOU",[[1,8345,"方法"]],[8345,8345],[8347,8347]]],[1566785263520,["GJX@GJXAIOU",[[1,8345," "]],[8347,8347],[8348,8348]]],[1566785270599,["GJX@GJXAIOU",[[1,8348,"只能调用无参"]],[8348,8348],[8354,8354]]],[1566785287530,["GJX@GJXAIOU",[[1,8354,"构造函数进行加载，如果有参数得是"]],[8354,8354],[8370,8370]]],[1566785288078,["GJX@GJXAIOU",[[-1,8369,"是"]],[8370,8370],[8369,8369]]],[1566785292863,["GJX@GJXAIOU",[[1,8369,"使用new"]],[8369,8369],[8374,8374]]],[1566785292900,["GJX@GJXAIOU",[[1,8371," "]],[8374,8374],[8375,8375]]],[1566785295081,["GJX@GJXAIOU",[[1,8375,"关键字"]],[8375,8375],[8378,8378]]],[1566785295119,["GJX@GJXAIOU",[[1,8375," "]],[8378,8378],[8379,8379]]],[1566785295695,["GJX@GJXAIOU",[[1,8379,"。"]],[8379,8379],[8380,8380]]],[1566785383387,["GJX@GJXAIOU",[[1,9075,"#### 通过反射机制调用类的 "]],[9075,9075],[9091,9091]]],[1566785384332,["GJX@GJXAIOU",[[-1,9090," "]],[9091,9091],[9090,9090]]],[1566785385204,["GJX@GJXAIOU",[[1,9090,"方法"]],[9090,9090],[9092,9092]]],[1566785385676,["GJX@GJXAIOU",[[1,9103,"\n"]],[9092,9092],[9093,9093]]],[1566785395951,["GJX@GJXAIOU",[[1,9093,"- "]],[9093,9093],[9095,9095]]],[1566785404953,["GJX@GJXAIOU",[[1,9095,"通过什么方式调研："]],[9095,9095],[9104,9104]]],[1566785406148,["GJX@GJXAIOU",[[-1,9101,"调研："]],[9104,9104],[9101,9101]]],[1566785410663,["GJX@GJXAIOU",[[1,9101,"调用："]],[9101,9101],[9104,9104]]],[1566785411063,["GJX@GJXAIOU",[[1,9105,"- \n"]],[9104,9104],[9107,9107]]],[1566785417753,["GJX@GJXAIOU",[[1,9107,"如何输入参数："]],[9107,9107],[9114,9114]]],[1566785418069,["GJX@GJXAIOU",[[1,9115,"- \n"]],[9114,9114],[9117,9117]]],[1566785426201,["GJX@GJXAIOU",[[1,9117,"如何得到返回结果："]],[9117,9117],[9126,9126]]],[1566786423466,["GJX@GJXAIOU",[[1,9127,"demo："]],[9127,9127],[9132,9132]]],[1566786423973,["GJX@GJXAIOU",[[1,9142,"\n"]],[9132,9132],[9133,9133]]],[1566786425658,["GJX@GJXAIOU",[[1,9133,"```"]],[9133,9133],[9136,9136]]],[1566786425696,["GJX@GJXAIOU",[[1,9136,"language\n```\n"]],[9136,9136],[9136,9144]]],[1566786426632,["GJX@GJXAIOU",[[-1,9136,"language"],[1,9144,"j"]],[9136,9144],[9137,9137]]],[1566786427082,["GJX@GJXAIOU",[[1,9137,"ava"]],[9137,9137],[9140,9140]]],[1566786427158,["GJX@GJXAIOU",[[1,9141,"\n"]],[9140,9140],[9141,9141]]],[1566786430112,["GJX@GJXAIOU",[[1,9141,"class Person {\n\tprivate String name;\n\n\tpublic Person(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic void saySkill(String skill) {\n\t\tSystem.out.println(\"Name is:\" + name + \", skill is:\" + skill);\n\t}\n\n\tpublic int addSalary(int current) {\n\t\treturn current + 100;\n\t}\n}\n\npublic class CallFuncDemo {\n\tpublic static void main(String[] args) {\n\t\tClass c1azz = null;\n\t\tConstructor c = null;\n\t\ttry {\n\t\t// 通过反射调用类的构造函数来创建对象\n\t\t\t// 得到 Class 类型的对象，其中包含了 Person 类的信息\n\t\t\tc1azz = Class.forName(\"chapter6.Person\");\n\t\t\t// 得到 Person 类带参数的构造函数；c 值为：public chapter6.Person(java.lang.String)\n\t\t\tc = c1azz.getDeclaredConstructor(String.class);\n\t\t\t// 通过带参数的构造函数创建一个Person类型对象\n\t\t\tPerson p = (Person)c.newInstance(\"Peter\");\n\t\t\t//output: Name is:Peter, skill is:java\n\t\t\tp.saySkill(\"Java\");\n\n\t\t\t// 调用方法，必须传递对象实例，同时传递参数值\n\t\t\tMethod method1 = c1azz.getMethod(\"saySkill\", String.class);\n\t\t\t// 因为没返回值，所以能直接调\n\t\t\t// 参数一指定该方法由哪个对象调用，参数二指定该方法的参数\n            method1.invoke(p, \"C#\");\n            \n            Method method2 = c1azz.getMethod(\"addSalary\", int.class);\n            Object invoke = method2.invoke(p, 100);\n            //输出200\n\t\t\tSystem.out.println(invoke);\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (NoSuchMethodException  e1) {\n\t\t\te1.printStackTrace();\n\t\t}\n\t\tcatch (InstantiationException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IllegalAccessException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (InvocationTargetException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n/**output:\n * Name is:Peter, skill is:Java\n * Name is:Peter, skill is:C#\n * 200\n */"]],[9141,9141],[10688,10688]]],[1566786433302,["GJX@GJXAIOU",[[1,10703,"\n"]],[10692,10692],[10693,10693]]],[1566786433430,["GJX@GJXAIOU",[[1,10704,"\n"]],[10693,10693],[10694,10694]]],[1566786476863,["GJX@GJXAIOU",[[1,10695,"### dai"]],[10695,10695],[10702,10702]]],[1566786477185,["GJX@GJXAIOU",[[1,10702,"li"]],[10702,10702],[10704,10704]]],[1566786478126,["GJX@GJXAIOU",[[-1,10699,"daili"]],[10704,10704],[10699,10699]]],[1566786487128,["GJX@GJXAIOU",[[1,10699,"代理模式和反射机制"]],[10699,10699],[10708,10708]]],[1566786487548,["GJX@GJXAIOU",[[1,10718,"\n"]],[10708,10708],[10709,10709]]],[1566786493402,["GJX@GJXAIOU",[[1,10709,"凡是的"]],[10709,10709],[10712,10712]]],[1566786494343,["GJX@GJXAIOU",[[-1,10709,"凡是的"]],[10712,10712],[10709,10709]]],[1566786499057,["GJX@GJXAIOU",[[1,10709,"反射的之用常见"]],[10709,10709],[10716,10716]]],[1566786500263,["GJX@GJXAIOU",[[-1,10712,"之用常见"]],[10716,10716],[10712,10712]]],[1566786512207,["GJX@GJXAIOU",[[1,10712,"使用场景之一就是在代理模式；"]],[10712,10712],[10726,10726]]],[1566786512510,["GJX@GJXAIOU",[[1,10736,"\n"]],[10726,10726],[10727,10727]]],[1566786516158,["GJX@GJXAIOU",[[-1,10736,"\n"]],[10727,10727],[10726,10726]]],[1566786527496,["GJX@GJXAIOU",[[1,10726,"通过反射机制实现动态代理功能；"]],[10726,10726],[10741,10741]]],[1566786527735,["GJX@GJXAIOU",[[1,10751,"\n"]],[10741,10741],[10742,10742]]],[1566786528236,["GJX@GJXAIOU",[[1,10752,"\n"]],[10742,10742],[10743,10743]]],[1566787098482,["GJX@GJXAIOU",[[1,10743,"~~~~"]],[10743,10743],[10745,10745]]],[1566787105284,["GJX@GJXAIOU",[[1,10745,"P190-197"]],[10745,10745],[10753,10753]]],[1566787107822,["GJX@GJXAIOU",[[1,10765,"\n"]],[10755,10755],[10756,10756]]],[1566787107959,["GJX@GJXAIOU",[[1,10766,"\n"]],[10756,10756],[10757,10757]]],[1566787169910,["GJX@GJXAIOU",[[1,10767,"\n"]],[10759,10759],[10760,10760]]],[1566787170016,["GJX@GJXAIOU",[[1,10768,"\n"]],[10760,10760],[10761,10761]]],[1566787187174,["GJX@GJXAIOU",[[1,10761,"## 章七：多线程和并发编程"]],[10761,10761],[10775,10775]]],[1566787187535,["GJX@GJXAIOU",[[1,10783,"\n"]],[10775,10775],[10776,10776]]],[1566787187646,["GJX@GJXAIOU",[[1,10784,"\n"]],[10776,10776],[10777,10777]]],[1566787189642,["GJX@GJXAIOU",[[1,10785,"\n"]],[10777,10777],[10778,10778]]],[1566787189759,["GJX@GJXAIOU",[[1,10786,"\n"]],[10778,10778],[10779,10779]]],[1566787189872,["GJX@GJXAIOU",[[1,10787,"\n"]],[10779,10779],[10780,10780]]],[1566787189985,["GJX@GJXAIOU",[[1,10788,"\n"]],[10780,10780],[10781,10781]]],[1566787190119,["GJX@GJXAIOU",[[1,10789,"\n"]],[10781,10781],[10782,10782]]],[1566787190239,["GJX@GJXAIOU",[[1,10790,"\n"]],[10782,10782],[10783,10783]]],[1566787190359,["GJX@GJXAIOU",[[1,10791,"\n"]],[10783,10783],[10784,10784]]],[1566787190512,["GJX@GJXAIOU",[[1,10792,"\n"]],[10784,10784],[10785,10785]]],[1566787190634,["GJX@GJXAIOU",[[1,10793,"\n"]],[10785,10785],[10786,10786]]],[1566787190760,["GJX@GJXAIOU",[[1,10794,"\n"]],[10786,10786],[10787,10787]]],[1566787190886,["GJX@GJXAIOU",[[1,10795,"\n"]],[10787,10787],[10788,10788]]],[1566787191023,["GJX@GJXAIOU",[[1,10796,"\n"]],[10788,10788],[10789,10789]]],[1566787191151,["GJX@GJXAIOU",[[1,10797,"\n"]],[10789,10789],[10790,10790]]],[1566787191287,["GJX@GJXAIOU",[[1,10798,"\n"]],[10790,10790],[10791,10791]]],[1566787191431,["GJX@GJXAIOU",[[1,10799,"\n"]],[10791,10791],[10792,10792]]],[1566787191577,["GJX@GJXAIOU",[[1,10800,"\n"]],[10792,10792],[10793,10793]]],[1566787191696,["GJX@GJXAIOU",[[1,10801,"\n"]],[10793,10793],[10794,10794]]],[1566787191863,["GJX@GJXAIOU",[[1,10802,"\n"]],[10794,10794],[10795,10795]]],[1566787192127,["GJX@GJXAIOU",[[1,10803,"\n"]],[10795,10795],[10796,10796]]],[1566787192687,["GJX@GJXAIOU",[[1,10804,"\n"]],[10796,10796],[10797,10797]]],[1566787252900,["GJX@GJXAIOU",[[1,10779,"### 线程的基本概念和实现多线程的基本方法"]],[10779,10779],[10801,10801]]],[1566787253271,["GJX@GJXAIOU",[[1,10827,"\n"]],[10801,10801],[10802,10802]]],[1566787253471,["GJX@GJXAIOU",[[1,10828,"\n"]],[10802,10802],[10803,10803]]],[1566787326910,["GJX@GJXAIOU",[[1,10803,"实现多线程的两种基本万j去，一种是通过extends Th 「ead 类的万式来实现，\n另一种是通过impleme 门ts Runnable 接口的方式来实现。\n通过这两种方法创建的线程都无法返回结果懂， 而在本节的后半部分1 将讲述通过\nCallable 让线程返回执行结果的万法。"]],[10803,10803],[10945,10945]]],[1566787333582,["GJX@GJXAIOU",[[-1,10813,"万j去"]],[10815,10815],[10813,10813]]],[1566787336942,["GJX@GJXAIOU",[[1,10813,"方法"]],[10813,10813],[10815,10815]]],[1566787340038,["GJX@GJXAIOU",[[-1,10831," 「"]],[10833,10833],[10831,10831]]],[1566787341338,["GJX@GJXAIOU",[[1,10831,"r"]],[10831,10831],[10832,10832]]],[1566787344233,["GJX@GJXAIOU",[[-1,10838,"万"]],[10839,10839],[10838,10838]]],[1566787347474,["GJX@GJXAIOU",[[1,10838,"放"]],[10838,10838],[10839,10839]]],[1566787349151,["GJX@GJXAIOU",[[-1,10838,"放"]],[10839,10839],[10838,10838]]],[1566787350484,["GJX@GJXAIOU",[[1,10838,"方式"]],[10838,10838],[10840,10840]]],[1566787350847,["GJX@GJXAIOU",[[-1,10840,"式"]],[10840,10840],[10839,10839]]],[1566787353958,["GJX@GJXAIOU",[[-1,10844,"\n"]],[10845,10845],[10844,10844]]],[1566787358319,["GJX@GJXAIOU",[[-1,10858,"门ts "]],[10862,10862],[10858,10858]]],[1566787367682,["GJX@GJXAIOU",[[1,10858,"nts "]],[10858,10858],[10862,10862]]],[1566787377943,["GJX@GJXAIOU",[[-1,10913," "]],[10914,10914],[10913,10913]]],[1566787378798,["GJX@GJXAIOU",[[1,10913,","]],[10913,10913],[10914,10914]]],[1566787379657,["GJX@GJXAIOU",[[-1,10912,"1,"]],[10914,10914],[10912,10912]]],[1566787382059,["GJX@GJXAIOU",[[1,10912,"，"]],[10912,10912],[10913,10913]]],[1566787385814,["GJX@GJXAIOU",[[-1,10918,"\n"]],[10919,10919],[10918,10918]]],[1566787389327,["GJX@GJXAIOU",[[-1,10900,"懂"]],[10901,10901],[10900,10900]]],[1566787390458,["GJX@GJXAIOU",[[1,10900,"值"]],[10900,10900],[10901,10901]]],[1566787393999,["GJX@GJXAIOU",[[-1,10937,"万法"]],[10939,10939],[10937,10937]]],[1566787395322,["GJX@GJXAIOU",[[1,10937,"方法"]],[10937,10937],[10939,10939]]],[1566787397135,["GJX@GJXAIOU",[[1,10966,"\n"]],[10940,10940],[10941,10941]]],[1566787397282,["GJX@GJXAIOU",[[1,10967,"\n"]],[10941,10941],[10942,10942]]],[1566787397422,["GJX@GJXAIOU",[[1,10968,"\n"]],[10942,10942],[10943,10943]]],[1566787421314,["GJX@GJXAIOU",[[1,10943,"#### 线程和紧张"]],[10943,10943],[10953,10953]]],[1566787421877,["GJX@GJXAIOU",[[-1,10951,"紧张"]],[10953,10953],[10951,10951]]],[1566787427813,["GJX@GJXAIOU",[[1,10951,"进程"]],[10951,10951],[10953,10953]]],[1566787428109,["GJX@GJXAIOU",[[1,10979,"\n"]],[10953,10953],[10954,10954]]],[1566787448920,["GJX@GJXAIOU",[[1,10955,"进程是实现某个独立功能的程序，它是操作系统（如windows系统）进行资涌分配和调度的一个独立单位，也是可以独立运行的一段程序。\n线程是—种轻量级的进程， 它是—个程序中实现单—功能的—个指令序列，是一个程序的—部分，不能单独运行， 必须在一个进程环境中运行。"]],[10955,10955],[11085,11085]]],[1566787454126,["GJX@GJXAIOU",[[-1,10990,"资涌"]],[10992,10992],[10990,10990]]],[1566787455611,["GJX@GJXAIOU",[[1,10990,"资源"]],[10990,10990],[10992,10992]]],[1566787492837,["GJX@GJXAIOU",[[1,11087,"****"]],[11087,11087],[11089,11089]]],[1566787496652,["GJX@GJXAIOU",[[1,11089,"两者"]],[11089,11089],[11091,11091]]],[1566787499867,["GJX@GJXAIOU",[[1,11091,"区别："]],[11091,11091],[11094,11094]]],[1566787501545,["GJX@GJXAIOU",[[1,11119,"\n"]],[11096,11096],[11097,11097]]],[1566787516351,["GJX@GJXAIOU",[[1,11097,"进程间相互独立， 但同—进程的各线程会共享该进程所拥有的资源，而进程则是用独占的方式来占有资洒，也就是说，进程间不能共享资源。\n(2)线程上下文切换（如—个从线程切换到另外—个线程）要比进程上下文切换速度快得多。\n(3)写个线程都有—个运行的入口 ， 顺序执行序列和出口，但是线程不能独立执行，必须依靠进程来调度和控制线程的执行。"]],[11097,11097],[11262,11262]]],[1566787546464,["GJX@GJXAIOU",[[-1,11209,"线"]],[11210,11210],[11209,11209]]],[1566787549141,["GJX@GJXAIOU",[[1,11209,"进"]],[11209,11209],[11210,11210]]],[1566787557071,["GJX@GJXAIOU",[[-1,11209,"进"]],[11210,11210],[11209,11209]]],[1566787560420,["GJX@GJXAIOU",[[1,11209,"线"]],[11209,11209],[11210,11210]]],[1566787578783,["GJX@GJXAIOU",[[1,11263,"4 般操作系统级别会偏重于 “进程” 的角度和管理，而应用项目（如某个在线购物平台）会偏重于 “线程” ， 如在某应用项目中的某些组件可以以多线程的方式同时执行。也就是说 ， 在编程时会更偏重千 “多线程” ，而不是 “多进程” 。"]],[11263,11263],[11379,11379]]],[1566787581710,["GJX@GJXAIOU",[[-1,11263,"4 "]],[11263,11265],[11263,11263]]],[1566787583027,["GJX@GJXAIOU",[[1,11263,"一"]],[11263,11263],[11264,11264]]],[1566787585742,["GJX@GJXAIOU",[[-1,11204,"(3)"]],[11207,11207],[11204,11204]]],[1566787588201,["GJX@GJXAIOU",[[-1,11161,"(2)"]],[11164,11164],[11161,11161]]],[1566787589697,["GJX@GJXAIOU",[[1,11161,"- "]],[11161,11161],[11163,11163]]],[1566787591832,["GJX@GJXAIOU",[[1,11097,"- "]],[11097,11097],[11099,11099]]],[1566787601057,["GJX@GJXAIOU",[[1,11261,"- "]],[11261,11261],[11263,11263]]],[1566787608154,["GJX@GJXAIOU",[[1,11205,"- "]],[11205,11205],[11207,11207]]],[1566787609296,["GJX@GJXAIOU",[[-1,11207,"写"]],[11208,11208],[11207,11207]]],[1566787613644,["GJX@GJXAIOU",[[1,11207,"每"]],[11207,11207],[11208,11208]]],[1566787626828,["GJX@GJXAIOU",[[1,11382,"#### 线程的声明"]],[11382,11382],[11392,11392]]],[1566787627446,["GJX@GJXAIOU",[[-1,11390,"声明"]],[11392,11392],[11390,11390]]],[1566787642276,["GJX@GJXAIOU",[[1,11390,"shenmingzhouq"]],[11390,11390],[11403,11403]]],[1566787642317,["GJX@GJXAIOU",[[1,11390," "]],[11403,11403],[11404,11404]]],[1566787645831,["GJX@GJXAIOU",[[-1,11390," shenmingzhouq"]],[11404,11404],[11390,11390]]],[1566787650877,["GJX@GJXAIOU",[[1,11390,"生命周期"]],[11390,11390],[11394,11394]]],[1566787651907,["GJX@GJXAIOU",[[1,11414,"\n"]],[11394,11394],[11395,11395]]],[1566787659959,["GJX@GJXAIOU",[[1,11395,"在Java 中，—个线程的生命周期中会有4种状态：初始化、可执行、阻塞和死亡状态"]],[11395,11395],[11435,11435]]],[1566787683120,["GJX@GJXAIOU",[[1,11436,"我们可以通过new语句创建一个线程对象，这时还没有调用它的start()方法，此时线程也没有分配到任何系统资漁，这时称为初始化状态。\n当我们调用了start()方法之后，它会自动调用线程对象的run()方法，此时线程如果分配到了CPU时间就可以开始运行，否则等待分配CPU时间，但无论是否分配到了CPU时间， 线程此刻都处千可执行状态。\n通过某些方法，如sleep()方法或wait()方法，我们可以把线程从可执行状态挂起。此时线程不会分配到CPU时间， 因此无法执行， 这时称为阻塞状态。"]],[11436,11436],[11681,11681]]],[1566787691874,["GJX@GJXAIOU",[[-1,11489,"资漁"]],[11491,11491],[11489,11489]]],[1566787693277,["GJX@GJXAIOU",[[1,11489,"资源"]],[11489,11489],[11491,11491]]],[1566787696467,["GJX@GJXAIOU",[[1,11436,"- "]],[11436,11436],[11438,11438]]],[1566787698994,["GJX@GJXAIOU",[[1,11505,"- "]],[11505,11505],[11507,11507]]],[1566787734416,["GJX@GJXAIOU",[[-1,11601,"千"]],[11602,11602],[11601,11601]]],[1566787735732,["GJX@GJXAIOU",[[1,11602,"可"]],[11601,11601],[11602,11602]]],[1566787736455,["GJX@GJXAIOU",[[-1,11602,"可"]],[11602,11602],[11601,11601]]],[1566787738766,["GJX@GJXAIOU",[[1,11601,"于"]],[11601,11601],[11602,11602]]],[1566787764665,["GJX@GJXAIOU",[[1,11686,"当线程睡眠了sleep参数所指定的时间后， 能自动地再次进入可执行状态，这时也可以通过notify()方法把因调用wait()方法而处于阻塞状态的线程变力可执行状态， 此刻该线程又有机会唱到CPU时间继续运行了。\n线程run()方法中的逻辑正常运行结束后就进入了 死亡状态。 调用stop()方，去或\ndestroy()方法时也会非正常地终止当前线程， 使宾进入死亡状态， 之后该线程就不存在了。"]],[11686,11686],[11884,11884]]],[1566787770347,["GJX@GJXAIOU",[[1,11609,"- "]],[11609,11609],[11611,11611]]],[1566787773221,["GJX@GJXAIOU",[[1,11688,"- "]],[11688,11688],[11690,11690]]],[1566787784873,["GJX@GJXAIOU",[[-1,11765,"变力"]],[11767,11767],[11765,11765]]],[1566787786740,["GJX@GJXAIOU",[[1,11765,"变为"]],[11765,11765],[11767,11767]]],[1566787792945,["GJX@GJXAIOU",[[-1,11783,"唱"]],[11784,11784],[11783,11783]]],[1566787795260,["GJX@GJXAIOU",[[1,11783,"得"]],[11783,11783],[11784,11784]]],[1566787802419,["GJX@GJXAIOU",[[1,11797,"- "]],[11797,11797],[11799,11799]]],[1566787816530,["GJX@GJXAIOU",[[-1,11838,"方，去"]],[11841,11841],[11838,11838]]],[1566787817884,["GJX@GJXAIOU",[[1,11838,"方法"]],[11838,11838],[11840,11840]]],[1566787822465,["GJX@GJXAIOU",[[-1,11841,"\n"]],[11842,11842],[11841,11841]]],[1566787825242,["GJX@GJXAIOU",[[1,11841," "]],[11841,11841],[11842,11842]]],[1566787828863,["GJX@GJXAIOU",[[-1,11869,"宾"]],[11870,11870],[11869,11869]]],[1566787829974,["GJX@GJXAIOU",[[1,11869,"其"]],[11869,11869],[11870,11870]]],[1566787873816,["GJX@GJXAIOU",[[1,11891,"![线程间的状态转换]($resource/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png)"]],[11891,11891],[11991,11991]]],[1566787875922,["GJX@GJXAIOU",[[1,12006,"\n"]],[11991,11991],[11992,11992]]],[1566787889676,["GJX@GJXAIOU",[[1,11992,"#### 通过extends"]],[11992,11992],[12006,12006]]],[1566787889719,["GJX@GJXAIOU",[[1,11999," "]],[12006,12006],[12007,12007]]],[1566787897677,["GJX@GJXAIOU",[[1,12007," Thread 实现多线程"]],[12007,12007],[12020,12020]]],[1566787898184,["GJX@GJXAIOU",[[1,12035,"\n"]],[12020,12020],[12021,12021]]],[1566787898309,["GJX@GJXAIOU",[[1,12036,"\n"]],[12021,12021],[12022,12022]]]],null,"GJX@GJXAIOU"],["69c65796-4b2d-4fe3-b328-ee2f06ff783d",1566868826183,"## 章五：SQL、JDBC 和数据库编程\n\n### 一、SQL 语句注意事项\n\n- 尽量别写 `select *`；一方面获得值当数据库变化时会改变，同时数据量过大造成性能问题；select 语句执行时间 = 数据库服务器执行该 SQL 的时间 + 结果返回时间；\n\n- 注意 `count(*)` 和 `count(字段名)`\n当正好该字段允许空值时候，两者返回记录条数的不一致；\n**但是当该字段正好为主键的时候，因为主键上有索引，因此效率比 count(*) 高；**\n\n- 在使用 insert 插入使用应该使用字段列表；\n\n- MySQL 和 SQL Server 支持一次性插入多条数据，Oracle 不支持；但是不能无限多的插入，否则会出错；插入的多个值使用 `,` 分开: `values ('',''), ('','')`。\n\n- delete 中可以使用 in 语句同时删除多个记录；但是同样不能过多；用法：`delect from A where id in(1, 2, 3, xxx)`；\n\n- 使用 merge 语句实现：无则插入有则更新；但是 Oracle、SQLserver 不支持；\nDemo：根据图书进货表中的 ISBN，匹配图书表，没有记录就增加，有就用图书进货表中信息更新图书表中信息（只更新以 Java 开头的书籍）\n```sql\nmerge into图书表a\nusing图书进货表b\non(a.ISBN=b.ISBN)\nwhen matched then update set a.图书名称 = b.图书名称\n    where b.图书名称 like 'java%' \nwhen not macthed then \n    insert into a(ISBN, 图书名称 values(b.ISBN,b.图书名称）\n        where b.图书名称 like 'java%' \n```\n\n- 存储过程 \n  - 这是个争议点：**存储过程只在创建时进行编译， 以后每次执行时都不需要重新编译**， 这样能提高数据库执行速度。\n 但是，一般在存储过程中会有 insert、delete 或 update 的语句的集合，在创建存储过程时，这些语句确实会被编译。不过如果对比—下在存储过程里和在 JDBC(或者 Hibernate)等场合里多次执行 insert 或 delete、update 语句，那么会发现两者的性能差异并不是很明显，更何况在JDBC等场合下还可以通过 PreparedStatement 对象的批处理来优化执行性能。\n\n- 如果针对某个业务逻辑，要对多个表进行多次 insert、delete、update 或 select 操作， 那么可以**把这些操作汇集成一个存储过程** 。 这样以后每次执行业务时， 只需要调用这个存储过程即可， 这样能提升代码的可重用性， 这也是存储过程的价值所在。\n\n- **存储过程的移植性很差**，如针对 MySOL 数据库的存储过程不能在 Oracle 上使用，但是一般也不换数据库；\n\n- **存储过程中很难调试，很难找到具体错误**，如在—个存储过程中有 5 个 insert 语句，分别向 5 张不同的表中插入数据，在某次通过JDBC执行该存储过程时， 向第三张表中插数据的insert语句发生—个 “主键冲突＂ 的错误，这时从 Java 语句抛出的异常来看， 只能知道 ”哪个执行存储过程出错＂ ，至于是存储过程中的哪句语句出的异常，这就只能靠自己去查了。\n\n- **用批处理方式的性能要比用存储过程的好** ， 所以在项目里并没有用存储过程来处理大批量的insert、 delete或update的操作。\n\n\n### 二、使用 JDBC 开发\n\n屏蔽了数据库中的实现细节，只要数据表名不变、表中字段不变，不同种类数据库之间只要修改很少的 jdbc 代码就可以实现迁移；\n\n- 使用 jdbc 开发，通过 `getString(字段名)、getInt()、getfloat() 、getDate()` 等获取字段值；\n- 一定要在 `finally` 中关闭所有的链接；\n- MySQL 更换到 Oracle 时 JDBC 需要更改的地方；\n  - 导入的驱动文件不再是 `mysql-connector-java.jar`，改为：`ojdbc.jar`；\n  - 通过 `Class.forName(“com.musql.jdbc.Driver”)` 装载的驱动修改为 Oracle 的：`“oracle.jdbc.driver.OracleDriver”`;\n  - `getConnection()` 方法中的数据库连接的 URL 需要由 `”jdbc: mysql://localhost:3306/数据库名“`  改为 `”jdbc:oracle:thin:@localhost:1521:数据库名“`\n\n\n### 三、优化数据库部分代码\n\n#### （一）将相对固定的连接信息写入配置文件\n\n- 减少多个代码同时用到数据库连接参数需要多次配置；\n- 对于测试和生产两种生产环境，可以使用两种不同的配置文件，使用命令行切换即可；\n\ndb.properties 写法：\n```properties\ndriver = com.mysql.cj.jdbc.Driver\nurl = jdbc:mysql://localhost:3306/数据库名?serverTimezone = GMT%2B8\nuser = 用户名\npassword = 密码\n```\n\n#### （二）用 PreparedStatement 以批处理的方式操作数据库\n\n**PreparedStatement 是预处理，一般用于批处理和防止 SQL 注入**；\n当需要在一个方法中执行多个插入（更新或者删除）操作时候，可以使用批处理；\n\n如果通过 `ps.executeUpdate` 的方式一条条地执行语句，那么每次执行语句都包括 “ 连接数据库＋执行语句＋释放数据库连接\"  3 个动作。相比之下，如果用批处理（executeBatch）的方式， 那么耗费的代价是 “—次连接＋多次执行＋一次释放 ” ，这样就能省去多次连接和释放数据库资源从而提升操作性能；\n\n- PreparedStatement里，占位符的编号是从 1 开始的，而不是从 0 开始的；\n- 批量操作能提升效率， 但一次性操作多少 ，效率能提升多高？这在不同的数据库中是不同的，一般每批是操作500 - 1000条语句。不要太多不然缓存放不完；\n\n\n#### （三）用 PreparedStatement 对象防止 SQL 注入\n\n#### （四）使用 C3P0 连接池\n如果操作很频繁，那么频繁的创建和关闭数据库连接动作会极大地减低系统的性能，在这种情况下，可以使用连接池；\n- 常见连接池有：C3P0 和 DBCP\n\n- C3P0 连接池的常用属性：\n![C3P0连接池常见属性]($resource/C3P0%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7.png)\n\n### 四、事务\n事务(Transaction)是—组针对数据库的操作， 这些操作要么都做， 要么都不做， 是 一个不可分割的 SQL 语句集合。\n\n#### （一）开启事务，合理的提交和回滚\n在JDBC中， 一般采用如下的方法使用事务。\n\n- 通过 `connection.setAutoCommit(false)` , 设置不是自动提交。在 JDBC 中，一般默认是自动提交，即有任何增删改的 SQL 语句都会立即执行。如果设置了非自动提交，要在用好事务后设置回 “ 自动提交” 。\n\n- 在合适的地方用 `connection.commit();` 来提交事务，一般是在执行结束后提交事务， 这样就会同时执行事务中的所有操作。\n\n- 可以通过 `connection.rollback()` 来回滚事务，回滚语句—般是放在 catch 从句中；一旦出现异常，就在 catch 中实现回滚；\n\n#### （二）事务中的常见问题：脏读、幻读和不可重复读\n在项目中， 如果**同时对一张表有两个（或多个） 事务进行读写操作时**，很容易出现数据读写错误的问题，具体表现形式有脏读、幻读和不可重复读。\n\n- **脏读 (dirtyread) 是指—个事务读取了另—个事务尚未提交的数据**\nA 值为 1，B 将其值设置为 2（但是尚未提交这个修改事务），A 读到值变为 2，结果 B 回滚了事务又将 A 值改为 1,则 A 读到的 2 就是一个脏数据，对应的操作为**脏读**；\n**避免方法：** 如果在第—个事务提交前，任何其他事务不可读取其修改过的值，则可以避免出现该问题。\n\n- **幻读 (phantom read) 是指一个事务的操作会导致另一个事务前后两次查询的结果不同**\nA 事务查询值为 1 的数据，读取到共 10 条记录，然后事务 B 插入一条数据值为 1，A 再次以同样条件读取就会得到 11 条；\n**避免方法：** 如果在操作事务完成数据处理之前 ， 任何其他事务都不可以添加新数据， 则可避免该问题。\n\n- **不可重复读(non-repeatable read)是指—个事务的操作导致另—个事务前后两次读取到不同的数据**。例如， 同—查询 在同一事务中多次进行， 由于其他事务提交了所做的修改（或和加或删除等操作） ， 这样每次查询会返回不同的结果集，这就是不可重复读。\nA 读到的值为 1，但是针对这个值的修改没有完成，事务 B 修改了值为 2，并提交了事务，则事务 A 再次读取值变为了 2；\n**避免方法：** 只有在修改事务完全提交之后才允许读取数据；\n\n- 幻读和不可重复读两者都表现为两次读取的结果不一致.\n- 但如果你从控制的角度来看,   两者的区别就比较大\n  - 对于幻读,   要锁住满足条件及其相近的记录  ：即需要锁住表\n  - 对于不可重复读,   只需要锁住满足条件的记录 ： 即需要锁住行\n  - 幻读的重点在于 insert；\n  - 不可重复读的重点在于：update 和 delete\n\n如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复 读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会 发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。\n\n**所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。**\n上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。\n\n*   悲观锁\n正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处 于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机 制，也无法保证外部系统不会修改数据）。\n\n在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。\n\n*   乐观锁\n相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。\n\n而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如 果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。\n\n要说明的是，MVCC的实现没有固定的规范，每个数据库都会有不同的实现方式，这里讨论的是InnoDB的MVCC。\n\n#### （三）事务隔离级别\n用户可以通过事务隔离级别来解决上述在事务中读写不一致的问题。在JDBC中，有5个常量来描述事务隔离级别，级别从低到高依次如下。\n\n(1)读取未提交：`TRANSACTION_READ_UNCOMMITTED`, 允许脏读、不可重复读和幻读。\n(2)读取提交：`TRANSACTION_READ_COMMITTED`, 禁止脏读，但允许不可重复读和幻读。【Oracle 默认级别】\n(3)可重读：`TRANSACTION_REPEATABLE_READ`,禁止脏读和不可重复读，但允许幻读。【MySQL 默认级别】\n(4)可串化：`TRANSACTION_SER IALIZABLE`, 禁止脏读、不可重复读和幻读。\n(5)还有一个常量是`TRANSACTION_NONE`,如果读取这个值，那么将使用当前数据库说指定的事务隔离级别；\n\n综上所述，如果设置高级别的事务隔离级别，那么数据库系统就要采取额外的措施来保证这个设置。会造成后续的操作和功能等待。\n\n√: 可能出现    ×: 不会出现\n| | 脏读 | 不可重复读 | 幻读 |\n|---|----|---|---\n| Read uncommitted | √ | √ | √ |\n| Read committed | × | √ | √ |\n| Repeatable read | × | × | √ |\n| Serializable | × | × | × |\n\n\n\n## 章六、反射机制和代理模式\n\n\n### 字节码和反射机制\n字节码 (Byte Code) 是Java 语言跨平台特性的重要保障， 也是反射机制的重要基础。通过反射机制 ， 我们不仅能看到一个类的属性和方法， 还能在—个类中调用另一个类的方法，但前提是要有相关类的字节码文件（也就是 class 文件）。\n\n- .Java 文件编译生成的 .class 文件可以在各种平台中运行（只要其有 Java 运行环境）；\n- Class 类的全称是 Java.lang.Class, 当一个类或接口（总之是 Java 文件被编译后的 class 文件）被装入Java 虚拟机 (JVM) 时便会产生一个与它相关联的 java.lang.Class 对象， 在反射部分的代码中， 我们一般通过 Class 来访问和使用目标类的属性和方法。\n\n\n\n### 反射的常见用法\n\n一是 “查看＇ ， 如输入某个类的属性方法等信息；\n二是 ＂ 装载'' 如装载指定的类到内存中；\n三是 “调用” 如通过输入参数， 调用指定的方法。\n\n#### 查看\n- 查看属性的修饰符、类型和名称 Demo：\n```java\nclass MyValClass {\n\tprivate int val1;\n\tpublic String val2;\n\tfinal protected String val3 = \"Java\";\n}\n\npublic class ReflectionReadVar{ \n\tpublic static void main(String[] args) {\n\t\tClass<MyValClass> clazz = MyValClass.class;\n\t\t//获取这个类的所有属性\n        Field[] fields = clazz.getDeclaredFields();\n\t    for(Field field : fields) {\n\t\t   //输出修饰符\n\t\t   System.out.print(Modifier.toString(field.getModifiers()) + \"\\t\");\n\t\t   //输出属性的类型\n\t\t   System.out.print(field.getGenericType().toString() + \"\\t\");\n\t\t   //输出属性的名字\n\t\t   System.out.println(field.getName());\n\t    }\n\t}\n}\n/**output:\n * private\tint\tval1\n * public\tclass java.lang.String\tval2\n * protected final\tclass java.lang.String\tval3\n */\n```\n\n- 查看方法的返回值类型、参数和名称\n```java\nclass MyFuncClass {\n\tpublic MyFuncClass(){}\n\tpublic MyFuncClass(int i){}\n\tprivate void f1(){}\n\tprotected int f2(int i){return 0;}\n\tpublic String f2(String s) {return \"Java\";}\n}\n\npublic class ReflectionReadFunc {\n\tpublic static void main(String[] args) {\n\t\tClass<MyFuncClass> clazz = MyFuncClass.class;\n\t\t// 返回所有的方法，但是不包括继承的方法和构造方法\n        Method[] methods = clazz.getDeclaredMethods();\n        for (Method method : methods) {\n            System.out.println(method);\n        }\n        System.out.println(\"***********\");\n       \n        //得到所有的构造函数\n        Constructor[] c1 = clazz.getDeclaredConstructors();\n        //输出所有的构造函数\n        for(Constructor ct : c1){\n            System.out.println(ct);\n        }\n\t}\n}\n/**\n * output:\n * protected int chapter6.MyFuncClass.f2(int)\n * public java.lang.String chapter6.MyFuncClass.f2(java.lang.String)\n * private void chapter6.MyFuncClass.f1()\n * ***********\n * public chapter6.MyFuncClass()\n * public chapter6.MyFuncClass(int)\n */\n```\n\n#### 装载\n- 通过 forName 和 newInstance 方法加载类\n  - Class.forName 方法最常用的用法就是装载数据库的驱动；\n  - 本质上 forName 的作用仅仅是返回一个 Class 类型的对象，newInstance 方法作用是加载类；即 newInstance 作用是通过 Java 虚拟机的类加载机制把指定的类加载到内存中。但是 newInstance 方法只能调用无参构造函数进行加载，如果有参数得使用 new 关键字。\n```java\nclass MyClass {\n\tpublic void print() {\n\t\tSystem.out.println(\"Java\");\n\t}\n}\n\npublic class ForClassDemo {\n\tpublic static void main(String[] args) {\n\t\tMyClass myClassObj = new MyClass();\n\t\tmyClassObj.print();//输出是Java\n\t\tSystem.out.println(\"*************\");\n\n\t\ttry {\n\t\t    // forName() 中的类名应该是完整的类名\n\t\t\tClass<?> clazz = Class.forName(\"chapter6.MyClass\");\n\t\t\tMyClass myClass = (MyClass)clazz.newInstance();\n\t\t\tmyClass.print();//输出是Java\n\t\t} catch (ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (InstantiationException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IllegalAccessException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n/**\n * output:\n * Java\n * *************\n * Java\n */\n```\n\n\n\n#### 通过反射机制调用类的方法\n- 通过什么方式调用：\n- 如何输入参数：\n- 如何得到返回结果：\ndemo：\n```java\nclass Person {\n\tprivate String name;\n\n\tpublic Person(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic void saySkill(String skill) {\n\t\tSystem.out.println(\"Name is:\" + name + \", skill is:\" + skill);\n\t}\n\n\tpublic int addSalary(int current) {\n\t\treturn current + 100;\n\t}\n}\n\npublic class CallFuncDemo {\n\tpublic static void main(String[] args) {\n\t\tClass c1azz = null;\n\t\tConstructor c = null;\n\t\ttry {\n\t\t// 通过反射调用类的构造函数来创建对象\n\t\t\t// 得到 Class 类型的对象，其中包含了 Person 类的信息\n\t\t\tc1azz = Class.forName(\"chapter6.Person\");\n\t\t\t// 得到 Person 类带参数的构造函数；c 值为：public chapter6.Person(java.lang.String)\n\t\t\tc = c1azz.getDeclaredConstructor(String.class);\n\t\t\t// 通过带参数的构造函数创建一个Person类型对象\n\t\t\tPerson p = (Person)c.newInstance(\"Peter\");\n\t\t\t//output: Name is:Peter, skill is:java\n\t\t\tp.saySkill(\"Java\");\n\n\t\t\t// 调用方法，必须传递对象实例，同时传递参数值\n\t\t\tMethod method1 = c1azz.getMethod(\"saySkill\", String.class);\n\t\t\t// 因为没返回值，所以能直接调\n\t\t\t// 参数一指定该方法由哪个对象调用，参数二指定该方法的参数\n            method1.invoke(p, \"C#\");\n            \n            Method method2 = c1azz.getMethod(\"addSalary\", int.class);\n            Object invoke = method2.invoke(p, 100);\n            //输出200\n\t\t\tSystem.out.println(invoke);\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (NoSuchMethodException  e1) {\n\t\t\te1.printStackTrace();\n\t\t}\n\t\tcatch (InstantiationException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IllegalAccessException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (InvocationTargetException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n/**output:\n * Name is:Peter, skill is:Java\n * Name is:Peter, skill is:C#\n * 200\n */\n```\n\n\n### 代理模式和反射机制\n反射的使用场景之一就是在代理模式；通过反射机制实现动态代理功能；\n\n~~P190-197~~\n\n\n\n\n\n## 章七：多线程和并发编程\n\n\n\n### 线程的基本概念和实现多线程的基本方法\n\n实现多线程的两种基本方法，一种是通过extends Thread 类的方式来实现，另一种是通过impleme nts Runnable 接口的方式来实现。\n通过这两种方法创建的线程都无法返回结果值， 而在本节的后半部分，将讲述通过Callable 让线程返回执行结果的方法。\n\n\n#### 线程和进程\n\n进程是实现某个独立功能的程序，它是操作系统（如windows系统）进行资源分配和调度的一个独立单位，也是可以独立运行的一段程序。\n线程是—种轻量级的进程， 它是—个程序中实现单—功能的—个指令序列，是一个程序的—部分，不能单独运行， 必须在一个进程环境中运行。\n\n**两者区别：**\n- 进程间相互独立， 但同—进程的各线程会共享该进程所拥有的资源，而进程则是用独占的方式来占有资洒，也就是说，进程间不能共享资源。\n- 线程上下文切换（如—个从线程切换到另外—个线程）要比进程上下文切换速度快得多。\n- 每个线程都有—个运行的入口 ， 顺序执行序列和出口，但是线程不能独立执行，必须依靠进程来调度和控制线程的执行。\n- 一般操作系统级别会偏重于 “进程” 的角度和管理，而应用项目（如某个在线购物平台）会偏重于 “线程” ， 如在某应用项目中的某些组件可以以多线程的方式同时执行。也就是说 ， 在编程时会更偏重千 “多线程” ，而不是 “多进程” 。\n\n#### 线程的生命周期\n在Java 中，—个线程的生命周期中会有4种状态：初始化、可执行、阻塞和死亡状态\n- 我们可以通过new语句创建一个线程对象，这时还没有调用它的start()方法，此时线程也没有分配到任何系统资源，这时称为初始化状态。\n- 当我们调用了start()方法之后，它会自动调用线程对象的run()方法，此时线程如果分配到了CPU时间就可以开始运行，否则等待分配CPU时间，但无论是否分配到了CPU时间， 线程此刻都处于可执行状态。\n- 通过某些方法，如sleep()方法或wait()方法，我们可以把线程从可执行状态挂起。此时线程不会分配到CPU时间， 因此无法执行， 这时称为阻塞状态。\n- 当线程睡眠了sleep参数所指定的时间后， 能自动地再次进入可执行状态，这时也可以通过notify()方法把因调用wait()方法而处于阻塞状态的线程变为可执行状态， 此刻该线程又有机会得到CPU时间继续运行了。\n- 线程run()方法中的逻辑正常运行结束后就进入了 死亡状态。 调用stop()方法或 destroy()方法时也会非正常地终止当前线程， 使其进入死亡状态， 之后该线程就不存在了。\n\n![线程间的状态转换]($resource/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png)\n\n#### 通过 extends Thread 实现多线程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",[[1566868793448,["GJX@GJXAIOU",[[1,12021,"会出现"]],[12021,12021],[12024,12024]]],[1566868797862,["GJX@GJXAIOU",[[-1,12021,"会出现"]],[12024,12024],[12021,12021]]],[1566868825426,["GJX@GJXAIOU",[[1,12021,"因为线程的调度工作由操作系统完成，"]],[12021,12021],[12038,12038]]],[1566868877242,["GJX@GJXAIOU",[[1,12038,"因此线程的执行次序是不可控的，导致多线程运行时会出现“数据不一致”"]],[12038,12038],[12071,12071]]],[1566868882525,["GJX@GJXAIOU",[[-1,12061,"会出现“数据不一致”"]],[12071,12071],[12061,12061]]],[1566868884698,["GJX@GJXAIOU",[[1,12061,"每次"]],[12061,12061],[12063,12063]]],[1566868893815,["GJX@GJXAIOU",[[1,12063,"过程都不一致；"]],[12063,12063],[12070,12070]]],[1566868895573,["GJX@GJXAIOU",[[1,12086,"\n"]],[12070,12070],[12071,12071]]],[1566868898805,["GJX@GJXAIOU",[[1,12087,"\n"]],[12071,12071],[12072,12072]]],[1566868900119,["GJX@GJXAIOU",[[1,12072,"```"]],[12072,12072],[12075,12075]]],[1566868900162,["GJX@GJXAIOU",[[1,12075,"language\n```\n"]],[12075,12075],[12075,12083]]],[1566868901432,["GJX@GJXAIOU",[[-1,12075,"language"],[1,12083,"j"]],[12075,12083],[12076,12076]]],[1566868901935,["GJX@GJXAIOU",[[1,12076,"ava"]],[12076,12076],[12079,12079]]],[1566868902133,["GJX@GJXAIOU",[[1,12080,"\n"]],[12079,12079],[12080,12080]]],[1566868905871,["GJX@GJXAIOU",[[1,12071,"Deml "]],[12071,12071],[12076,12076]]],[1566868907541,["GJX@GJXAIOU",[[-1,12074,"l "]],[12076,12076],[12074,12074]]],[1566868909352,["GJX@GJXAIOU",[[1,12074,"o:"]],[12074,12074],[12076,12076]]],[1566870086025,["GJX@GJXAIOU",[[1,12085,"package chapter7;\n\npublic class SimpleThread extends Thread {\n\t// 线程编号\n\tint index;\n\n\t// 通过构造函数指定该线程的编号\n\tpublic SimpleThread(int index) {\n\t\tthis.index = index;\n\t\tSystem.out.println(\"Create Thread[\" + index + \"]\");\n\t}\n\n\t// run方法，当调用线程的start方法时会自动调用该方法，此时线程进入可执行状态\n\t@Override\n\tpublic void run() {\n\t\tfor (int j = 0; j <= 3; j++) {\n\t\t\tSystem.out.println(\"Thread[\" + index + \"]:running time \" + j);\n\t\t}\n\t\t// 当前线程运行结束\n\t\tSystem.out.println(\"Thread[\" + index + \"] finish\");\n\t}\n\n\tpublic static void main(String args[]) {\n\t    int threadCount = 3;\n\t\tfor (int j = 0; j < threadCount; j++) {\n\t\t\t// 实例化该类型的对象，并直接调用start方法直接把线程拉起\n\t\t\t// 这个方法会自动调用run方法\n\t\t\tThread t = new SimpleThread(j + 1);\n\t\t\tt.start();\n\t\t}\n\t}\n}\n"]],[12085,12085],[12783,12783]]],[1566870138920,["GJX@GJXAIOU",[[1,12783,"/**\n * output: * Create Thread[1] * Create Thread[2] * Create Thread[3] * Thread[1]:running time 0 * Thread[2]:running time 0 * Thread[1]:running time 1 * Thread[1]:running time 2 * Thread[1]:running time 3 * Thread[3]:running time 0 * Thread[2]:running time 1 * Thread[2]:running time 2 * Thread[2]:running time 3 * Thread[2] finish * Thread[3]:running time 1 * Thread[1] finish * Thread[3]:running time 2 * Thread[3]:running time 3 * Thread[3] finish */"]],[12783,12783],[13238,13238]]],[1566870140927,["GJX@GJXAIOU",[[-1,12085,"package chapter7;\n\npublic class SimpleThread extends Thread {\n\t// 线程编号\n\tint index;\n\n\t// 通过构造函数指定该线程的编号\n\tpublic SimpleThread(int index) {\n\t\tthis.index = index;\n\t\tSystem.out.println(\"Create Thread[\" + index + \"]\");\n\t}\n\n\t// run方法，当调用线程的start方法时会自动调用该方法，此时线程进入可执行状态\n\t@Override\n\tpublic void run() {\n\t\tfor (int j = 0; j <= 3; j++) {\n\t\t\tSystem.out.println(\"Thread[\" + index + \"]:running time \" + j);\n\t\t}\n\t\t// 当前线程运行结束\n\t\tSystem.out.println(\"Thread[\" + index + \"] finish\");\n\t}\n\n\tpublic static void main(String args[]) {\n\t    int threadCount = 3;\n\t\tfor (int j = 0; j < threadCount; j++) {\n\t\t\t// 实例化该类型的对象，并直接调用start方法直接把线程拉起\n\t\t\t// 这个方法会自动调用run方法\n\t\t\tThread t = new SimpleThread(j + 1);\n\t\t\tt.start();\n\t\t}\n\t}\n}\n/**\n * output: * Create Thread[1] * Create Thread[2] * Create Thread[3] * Thread[1]:running time 0 * Thread[2]:running time 0 * Thread[1]:running time 1 * Thread[1]:running time 2 * Thread[1]:running time 3 * Thread[3]:running time 0 * Thread[2]:running time 1 * Thread[2]:running time 2 * Thread[2]:running time 3 * Thread[2] finish * Thread[3]:running time 1 * Thread[1] finish * Thread[3]:running time 2 * Thread[3]:running time 3 * Thread[3] finish */"]],[13238,13238],[12085,12085]]],[1566870148507,["GJX@GJXAIOU",[[1,12085,"package chapter7;\n\npublic class SimpleThread extends Thread {\n\t// 线程编号\n\tint index;\n\n\t// 通过构造函数指定该线程的编号\n\tpublic SimpleThread(int index) {\n\t\tthis.index = index;\n\t\tSystem.out.println(\"Create Thread[\" + index + \"]\");\n\t}\n\n\t// run方法，当调用线程的start方法时会自动调用该方法，此时线程进入可执行状态\n\t@Override\n\tpublic void run() {\n\t\tfor (int j = 0; j <= 3; j++) {\n\t\t\tSystem.out.println(\"Thread[\" + index + \"]:running time \" + j);\n\t\t}\n\t\t// 当前线程运行结束\n\t\tSystem.out.println(\"Thread[\" + index + \"] finish\");\n\t}\n\n\tpublic static void main(String args[]) {\n\t    int threadCount = 3;\n\t\tfor (int j = 0; j < threadCount; j++) {\n\t\t\t// 实例化该类型的对象，并直接调用start方法直接把线程拉起\n\t\t\t// 这个方法会自动调用run方法\n\t\t\tThread t = new SimpleThread(j + 1);\n\t\t\tt.start();\n\t\t}\n\t}\n}\n/**\n * output:\n * Create Thread[1]\n * Create Thread[2]\n * Create Thread[3]\n * Thread[1]:running time 0\n * Thread[2]:running time 0\n * Thread[1]:running time 1\n * Thread[1]:running time 2\n * Thread[1]:running time 3\n * Thread[3]:running time 0\n * Thread[2]:running time 1\n * Thread[2]:running time 2\n * Thread[2]:running time 3\n * Thread[2] finish\n * Thread[3]:running time 1\n * Thread[1] finish\n * Thread[3]:running time 2\n * Thread[3]:running time 3\n * Thread[3] finish\n */\n"]],[12085,12085],[13258,13258]]],[1566870151727,["GJX@GJXAIOU",[[1,13279,"\n"]],[13262,13262],[13263,13263]]],[1566870151862,["GJX@GJXAIOU",[[1,13280,"\n"]],[13263,13263],[13264,13264]]],[1566870171064,["GJX@GJXAIOU",[[1,13265,"#### tongguo"]],[13265,13265],[13277,13277]]],[1566870172318,["GJX@GJXAIOU",[[-1,13270,"tongguo"]],[13277,13277],[13270,13270]]],[1566870177803,["GJX@GJXAIOU",[[1,13270,"通过Implement"]],[13270,13270],[13281,13281]]],[1566870177849,["GJX@GJXAIOU",[[1,13272," "]],[13281,13281],[13282,13282]]],[1566870195192,["GJX@GJXAIOU",[[1,13282,"s Runnableshixian"]],[13282,13282],[13299,13299]]],[1566870196630,["GJX@GJXAIOU",[[-1,13292,"shixian"]],[13299,13299],[13292,13292]]],[1566870202882,["GJX@GJXAIOU",[[1,13292," 实现多线程（）"]],[13292,13292],[13300,13300]]],[1566870208444,["GJX@GJXAIOU",[[1,13299,"线程优先级"]],[13299,13299],[13304,13304]]],[1566870209894,["GJX@GJXAIOU",[[1,13321,"\n"]],[13305,13305],[13306,13306]]],[1566870237865,["GJX@GJXAIOU",[[1,13306,"一般用于该类已经通过 extent"]],[13306,13306],[13323,13323]]],[1566870238510,["GJX@GJXAIOU",[[-1,13322,"t"]],[13323,13323],[13322,13322]]],[1566870238881,["GJX@GJXAIOU",[[1,13322,"f"]],[13322,13322],[13323,13323]]],[1566870239560,["GJX@GJXAIOU",[[-1,13322,"f"]],[13323,13323],[13322,13322]]],[1566870252074,["GJX@GJXAIOU",[[1,13322,"ds 继承了一个类，则不能再使用功能"]],[13322,13322],[13340,13340]]],[1566870253190,["GJX@GJXAIOU",[[-1,13338,"功能"]],[13340,13340],[13338,13338]]],[1566870265429,["GJX@GJXAIOU",[[1,13338," extends 继承 Thread类"]],[13338,13338],[13357,13357]]],[1566870265474,["GJX@GJXAIOU",[[1,13356," "]],[13357,13357],[13358,13358]]],[1566870282876,["GJX@GJXAIOU",[[1,13358,"来实现多线程，可以采用 Implements Rn"]],[13358,13358],[13383,13383]]],[1566870284886,["GJX@GJXAIOU",[[-1,13382,"n"]],[13383,13383],[13382,13382]]],[1566870296284,["GJX@GJXAIOU",[[1,13382,"unnable 方式实现多线程。"]],[13382,13382],[13398,13398]]],[1566870299518,["GJX@GJXAIOU",[[-1,13370,"I"]],[13371,13371],[13370,13370]]],[1566870299977,["GJX@GJXAIOU",[[1,13370,"i"]],[13370,13370],[13371,13371]]],[1566870302705,["GJX@GJXAIOU",[[1,13414,"\n"]],[13398,13398],[13399,13399]]],[1566870330591,["GJX@GJXAIOU",[[1,13415,"\n"]],[13399,13399],[13400,13400]]],[1566870339865,["GJX@GJXAIOU",[[1,13400,"默认1"]],[13400,13400],[13403,13403]]],[1566870339912,["GJX@GJXAIOU",[[1,13402," "]],[13403,13403],[13404,13404]]],[1566870343778,["GJX@GJXAIOU",[[1,13404,"-10 yigong"]],[13404,13404],[13414,13414]]],[1566870345230,["GJX@GJXAIOU",[[-1,13408,"yigong"]],[13414,13414],[13408,13408]]],[1566870348443,["GJX@GJXAIOU",[[1,13408,"共1"]],[13408,13408],[13410,13410]]],[1566870348491,["GJX@GJXAIOU",[[1,13409," "]],[13410,13410],[13411,13411]]],[1566870349332,["GJX@GJXAIOU",[[1,13411,"0个"]],[13411,13411],[13413,13413]]],[1566870349376,["GJX@GJXAIOU",[[1,13412," "]],[13413,13413],[13414,13414]]],[1566870353910,["GJX@GJXAIOU",[[1,13414,"优先姐姐"]],[13414,13414],[13418,13418]]],[1566870354447,["GJX@GJXAIOU",[[-1,13416,"姐姐"]],[13418,13418],[13416,13416]]],[1566870376860,["GJX@GJXAIOU",[[1,13416,"级别，数字越小级别越高，****"]],[13416,13416],[13430,13430]]],[1566870385092,["GJX@GJXAIOU",[[1,13430,"但是高优先级的线程"]],[13430,13430],[13439,13439]]],[1566870392630,["GJX@GJXAIOU",[[1,13439,"仅仅是比第"]],[13439,13439],[13444,13444]]],[1566870393216,["GJX@GJXAIOU",[[-1,13443,"第"]],[13444,13444],[13443,13443]]],[1566870415732,["GJX@GJXAIOU",[[1,13443,"低优先级的先运行的概率大，不是绝对的能先执行。"]],[13443,13443],[13466,13466]]],[1566870423052,["GJX@GJXAIOU",[[1,13428,"默认级别为5"]],[13428,13428],[13434,13434]]],[1566870423096,["GJX@GJXAIOU",[[1,13433," "]],[13434,13434],[13435,13435]]],[1566870423604,["GJX@GJXAIOU",[[1,13435,"，"]],[13435,13435],[13436,13436]]],[1566870650681,["GJX@GJXAIOU",[[1,13477,"```"]],[13477,13477],[13480,13480]]],[1566870650728,["GJX@GJXAIOU",[[1,13480,"language\n```\n"]],[13480,13480],[13480,13488]]],[1566870652162,["GJX@GJXAIOU",[[-1,13480,"language"],[1,13488,"j"]],[13480,13488],[13481,13481]]],[1566870652595,["GJX@GJXAIOU",[[1,13481,"ava"]],[13481,13481],[13484,13484]]],[1566870652722,["GJX@GJXAIOU",[[1,13485,"\n"]],[13484,13484],[13485,13485]]],[1566870655687,["GJX@GJXAIOU",[[1,13485,"package chapter7;\n\n//实现Runnbale接口，此时这个类就可以extends其他的父类了\npublic class ThreadPriority implements Runnable {\n\t// 线程编号\n\tint number;\n\n\tpublic ThreadPriority(int num) {\n\t\tnumber = num;\n\t\tSystem.out.println(\"Create Thread[\" + number + \"]\");\n\t}\n\n\t// run方法，当调用线程的start方法时会调用该方法\n\t@Override\n\tpublic void run() {\n\t\tfor (int i = 0; i <= 3; i++) {\n\t\t\tSystem.out.println(\"Thread[\" + number + \"]:Count \" + i);\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\t// 定义线程t1，并设置其优先级为5\n\t\tThread t1 = new Thread(new ThreadPriority(1));\n\t\tt1.setPriority(1);\n\t\t// 定义线程t2，并设置其优先级为7\n\t\tThread t2 = new Thread(new ThreadPriority(2));\n\t\tt2.setPriority(7);\n\t\t// 启动这两个线程\n\t\tt1.start();\n\t\tt2.start();\n\t}\n}\n/**\n * output:\n * Create Thread[1]\n * Create Thread[2]\n * Thread[1]:Count 0\n * Thread[2]:Count 0\n * Thread[1]:Count 1\n * Thread[2]:Count 1\n * Thread[1]:Count 2\n * Thread[2]:Count 2\n * Thread[1]:Count 3\n * Thread[2]:Count 3\n */\n \n"]],[13485,13485],[14388,14388]]],[1566870690159,["GJX@GJXAIOU",[[-1,14388,"\n"]],[14388,14388],[14387,14387]]],[1566870690303,["GJX@GJXAIOU",[[-1,14386," "]],[14387,14387],[14386,14386]]],[1566870691593,["GJX@GJXAIOU",[[-1,14386,"\n"]],[14386,14386],[14385,14385]]],[1566870693506,["GJX@GJXAIOU",[[1,14405,"\n"]],[14390,14390],[14391,14391]]],[1566870693641,["GJX@GJXAIOU",[[1,14406,"\n"]],[14391,14391],[14392,14392]]],[1566870707614,["GJX@GJXAIOU",[[-1,10778,"\n"]],[10778,10778],[10777,10777]]],[1566870707767,["GJX@GJXAIOU",[[-1,10777,"\n"]],[10777,10777],[10776,10776]]],[1566870740147,["GJX@GJXAIOU",[[1,14391,"### 多线程的竞争与同步"]],[14391,14391],[14404,14404]]],[1566870740536,["GJX@GJXAIOU",[[1,14418,"\n"]],[14404,14404],[14405,14405]]],[1566870926184,["GJX@GJXAIOU",[[1,14419,"\n"]],[14405,14405],[14406,14406]]],[1566870928395,["GJX@GJXAIOU",[[1,14406,"4通过"]],[14406,14406],[14409,14409]]],[1566870928441,["GJX@GJXAIOU",[[1,14407," "]],[14409,14409],[14410,14410]]],[1566870930993,["GJX@GJXAIOU",[[-1,14406,"4 通过"]],[14410,14410],[14406,14406]]],[1566870938180,["GJX@GJXAIOU",[[1,14406,"#### 通过sleep"]],[14406,14406],[14418,14418]]],[1566870938225,["GJX@GJXAIOU",[[1,14413," "]],[14418,14418],[14419,14419]]],[1566870939739,["GJX@GJXAIOU",[[1,14419,"方法"]],[14419,14419],[14421,14421]]],[1566870939787,["GJX@GJXAIOU",[[1,14419," "]],[14421,14421],[14422,14422]]],[1566870954357,["GJX@GJXAIOU",[[1,14422,"让线程释放CPU"]],[14422,14422],[14430,14430]]],[1566870954402,["GJX@GJXAIOU",[[1,14427," "]],[14430,14430],[14431,14431]]],[1566870955555,["GJX@GJXAIOU",[[1,14431,"资源"]],[14431,14431],[14433,14433]]],[1566870955603,["GJX@GJXAIOU",[[1,14431," "]],[14433,14433],[14434,14434]]],[1566871017335,["GJX@GJXAIOU",[[1,14435,"是先"]],[14435,14435],[14437,14437]]],[1566871018831,["GJX@GJXAIOU",[[-1,14435,"是先"]],[14437,14437],[14435,14435]]],[1566871028810,["GJX@GJXAIOU",[[1,14435,"是线程类T"]],[14435,14435],[14440,14440]]],[1566871028857,["GJX@GJXAIOU",[[1,14439," "]],[14440,14440],[14441,14441]]],[1566871031565,["GJX@GJXAIOU",[[1,14441,"hrea"]],[14441,14441],[14445,14445]]],[1566871224629,["GJX@GJXAIOU",[[1,14445,"d "]],[14445,14445],[14447,14447]]],[1566871236408,["GJX@GJXAIOU",[[1,14447,"的一个sleep"]],[14447,14447],[14455,14455]]],[1566871236454,["GJX@GJXAIOU",[[1,14450," "]],[14455,14455],[14456,14456]]],[1566871241630,["GJX@GJXAIOU",[[1,14456,"() 静态方法"]],[14456,14456],[14463,14463]]],[1566871244186,["GJX@GJXAIOU",[[-1,14435,"是"]],[14436,14436],[14435,14435]]],[1566871245589,["GJX@GJXAIOU",[[1,14435,"通过"]],[14435,14435],[14437,14437]]],[1566871248636,["GJX@GJXAIOU",[[1,14464,"，"]],[14464,14464],[14465,14465]]],[1566871264420,["GJX@GJXAIOU",[[1,14458,"参数为毫秒数"]],[14458,14458],[14464,14464]]],[1566871283503,["GJX@GJXAIOU",[[1,14471,"让当前运行的线程"]],[14471,14471],[14479,14479]]],[1566871630408,["GJX@GJXAIOU",[[1,14479,"在这段时间内进入阻塞状态。 阻塞状态过去后， 该线程会重新进入可执行状态。"]],[14479,14479],[14516,14516]]],[1566871634362,["GJX@GJXAIOU",[[1,14529,"\n"]],[14516,14516],[14517,14517]]],[1566871645388,["GJX@GJXAIOU",[[1,14517,"示例："]],[14517,14517],[14520,14520]]],[1566871646394,["GJX@GJXAIOU",[[1,14520,"比如某个线程因数据库连接异常而无法连接到数据库， 这时我们可以通过sleep方法让该线程阻塞一段时间， 过后再重新连接。"]],[14520,14520],[14580,14580]]],[1566871650273,["GJX@GJXAIOU",[[1,14593,"\n"]],[14580,14580],[14581,14581]]],[1566871650418,["GJX@GJXAIOU",[[1,14594,"\n"]],[14581,14581],[14582,14582]]],[1566871652475,["GJX@GJXAIOU",[[1,14582,"Demo："]],[14582,14582],[14587,14587]]],[1566871652907,["GJX@GJXAIOU",[[1,14600,"\n"]],[14587,14587],[14588,14588]]],[1566871654491,["GJX@GJXAIOU",[[1,14588,"```"]],[14588,14588],[14591,14591]]],[1566871654538,["GJX@GJXAIOU",[[1,14591,"language\n```\n"]],[14591,14591],[14591,14599]]],[1566871655307,["GJX@GJXAIOU",[[-1,14591,"language"],[1,14599,"j"]],[14591,14599],[14592,14592]]],[1566871655735,["GJX@GJXAIOU",[[1,14592,"ava"]],[14592,14592],[14595,14595]]],[1566871655892,["GJX@GJXAIOU",[[1,14596,"\n"]],[14595,14595],[14596,14596]]],[1566872707635,["GJX@GJXAIOU",[[1,14596,"package chapter7;\n\npublic class ThreadSleep extends Thread {\n\t@Override\n\tpublic void run() {\n\t\tLong curTime = System.currentTimeMillis();\n\t\t// sleep方法会抛出InterruptedException异常\n\t\t// 需要用try-catch语句进行捕捉\n\t\ttry {\n\t\t\tsleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t}\n\t\tSystem.out.println(\"ts线程阻塞的时间\" + (System.currentTimeMillis() - curTime) + \"毫秒\");\n\t}\n\n\tpublic static void main(String arg[]) {\n\t\tThreadSleep ts = new ThreadSleep();\n\t\tts.start();\n\t\tLong curTime = System.currentTimeMillis();\n        try {  \n            Thread.sleep(1000);  \n        } catch (InterruptedException e) {\n            e.printStackTrace();  \n        }  \n        System.out.println(\"主线程阻塞的时间\" + (System.currentTimeMillis() - curTime) + \"毫秒\");\n\t}\n}\n/**\n * output:\n * 主线程阻塞的时间1000毫秒\n * ts线程阻塞的时间2001毫秒\n */\n"]],[14596,14596],[15375,15375]]],[1566873206821,["GJX@GJXAIOU",[[1,15393,"\n"]],[15379,15379],[15380,15380]]],[1566873206954,["GJX@GJXAIOU",[[1,15394,"\n"]],[15380,15380],[15381,15381]]],[1566873208606,["GJX@GJXAIOU",[[1,15380,"#### "]],[15380,15380],[15385,15385]]],[1566873214253,["GJX@GJXAIOU",[[1,15380,"\n"]],[15379,15379],[15380,15380]]],[1566873229481,["GJX@GJXAIOU",[[1,15386," Synchronized 作用在方法上"]],[15386,15386],[15406,15406]]],[1566873229980,["GJX@GJXAIOU",[[1,15421,"\n"]],[15406,15406],[15407,15407]]],[1566873261711,["GJX@GJXAIOU",[[1,15407,"解决多想成"]],[15407,15407],[15412,15412]]],[1566873262596,["GJX@GJXAIOU",[[-1,15409,"多想成"]],[15412,15412],[15409,15409]]],[1566873265352,["GJX@GJXAIOU",[[1,15409,"多线程"]],[15409,15409],[15412,15412]]],[1566873266681,["GJX@GJXAIOU",[[1,15412,"编发"]],[15412,15412],[15414,15414]]],[1566873267232,["GJX@GJXAIOU",[[-1,15412,"编发"]],[15414,15414],[15412,15412]]],[1566873276971,["GJX@GJXAIOU",[[1,15412,"并发执行牟特"]],[15412,15412],[15418,15418]]],[1566873278877,["GJX@GJXAIOU",[[-1,15416,"牟特"]],[15418,15418],[15416,15416]]],[1566873311410,["GJX@GJXAIOU",[[1,15416,"某个方法或者代码引发不同线程同时修改同块存储空间。"]],[15416,15416],[15441,15441]]]],null,"GJX@GJXAIOU"],["87ca4dfc-1ba9-40ca-bb11-39edab591944",1567038007084,"## 章五：SQL、JDBC 和数据库编程\n\n### 一、SQL 语句注意事项\n\n- 尽量别写 `select *`；一方面获得值当数据库变化时会改变，同时数据量过大造成性能问题；select 语句执行时间 = 数据库服务器执行该 SQL 的时间 + 结果返回时间；\n\n- 注意 `count(*)` 和 `count(字段名)`\n当正好该字段允许空值时候，两者返回记录条数的不一致；\n**但是当该字段正好为主键的时候，因为主键上有索引，因此效率比 count(*) 高；**\n\n- 在使用 insert 插入使用应该使用字段列表；\n\n- MySQL 和 SQL Server 支持一次性插入多条数据，Oracle 不支持；但是不能无限多的插入，否则会出错；插入的多个值使用 `,` 分开: `values ('',''), ('','')`。\n\n- delete 中可以使用 in 语句同时删除多个记录；但是同样不能过多；用法：`delect from A where id in(1, 2, 3, xxx)`；\n\n- 使用 merge 语句实现：无则插入有则更新；但是 Oracle、SQLserver 不支持；\nDemo：根据图书进货表中的 ISBN，匹配图书表，没有记录就增加，有就用图书进货表中信息更新图书表中信息（只更新以 Java 开头的书籍）\n```sql\nmerge into图书表a\nusing图书进货表b\non(a.ISBN=b.ISBN)\nwhen matched then update set a.图书名称 = b.图书名称\n    where b.图书名称 like 'java%' \nwhen not macthed then \n    insert into a(ISBN, 图书名称 values(b.ISBN,b.图书名称）\n        where b.图书名称 like 'java%' \n```\n\n- 存储过程 \n  - 这是个争议点：**存储过程只在创建时进行编译， 以后每次执行时都不需要重新编译**， 这样能提高数据库执行速度。\n 但是，一般在存储过程中会有 insert、delete 或 update 的语句的集合，在创建存储过程时，这些语句确实会被编译。不过如果对比—下在存储过程里和在 JDBC(或者 Hibernate)等场合里多次执行 insert 或 delete、update 语句，那么会发现两者的性能差异并不是很明显，更何况在JDBC等场合下还可以通过 PreparedStatement 对象的批处理来优化执行性能。\n\n- 如果针对某个业务逻辑，要对多个表进行多次 insert、delete、update 或 select 操作， 那么可以**把这些操作汇集成一个存储过程** 。 这样以后每次执行业务时， 只需要调用这个存储过程即可， 这样能提升代码的可重用性， 这也是存储过程的价值所在。\n\n- **存储过程的移植性很差**，如针对 MySOL 数据库的存储过程不能在 Oracle 上使用，但是一般也不换数据库；\n\n- **存储过程中很难调试，很难找到具体错误**，如在—个存储过程中有 5 个 insert 语句，分别向 5 张不同的表中插入数据，在某次通过JDBC执行该存储过程时， 向第三张表中插数据的insert语句发生—个 “主键冲突＂ 的错误，这时从 Java 语句抛出的异常来看， 只能知道 ”哪个执行存储过程出错＂ ，至于是存储过程中的哪句语句出的异常，这就只能靠自己去查了。\n\n- **用批处理方式的性能要比用存储过程的好** ， 所以在项目里并没有用存储过程来处理大批量的insert、 delete或update的操作。\n\n\n### 二、使用 JDBC 开发\n\n屏蔽了数据库中的实现细节，只要数据表名不变、表中字段不变，不同种类数据库之间只要修改很少的 jdbc 代码就可以实现迁移；\n\n- 使用 jdbc 开发，通过 `getString(字段名)、getInt()、getfloat() 、getDate()` 等获取字段值；\n- 一定要在 `finally` 中关闭所有的链接；\n- MySQL 更换到 Oracle 时 JDBC 需要更改的地方；\n  - 导入的驱动文件不再是 `mysql-connector-java.jar`，改为：`ojdbc.jar`；\n  - 通过 `Class.forName(“com.musql.jdbc.Driver”)` 装载的驱动修改为 Oracle 的：`“oracle.jdbc.driver.OracleDriver”`;\n  - `getConnection()` 方法中的数据库连接的 URL 需要由 `”jdbc: mysql://localhost:3306/数据库名“`  改为 `”jdbc:oracle:thin:@localhost:1521:数据库名“`\n\n\n### 三、优化数据库部分代码\n\n#### （一）将相对固定的连接信息写入配置文件\n\n- 减少多个代码同时用到数据库连接参数需要多次配置；\n- 对于测试和生产两种生产环境，可以使用两种不同的配置文件，使用命令行切换即可；\n\ndb.properties 写法：\n```properties\ndriver = com.mysql.cj.jdbc.Driver\nurl = jdbc:mysql://localhost:3306/数据库名?serverTimezone = GMT%2B8\nuser = 用户名\npassword = 密码\n```\n\n#### （二）用 PreparedStatement 以批处理的方式操作数据库\n\n**PreparedStatement 是预处理，一般用于批处理和防止 SQL 注入**；\n当需要在一个方法中执行多个插入（更新或者删除）操作时候，可以使用批处理；\n\n如果通过 `ps.executeUpdate` 的方式一条条地执行语句，那么每次执行语句都包括 “ 连接数据库＋执行语句＋释放数据库连接\"  3 个动作。相比之下，如果用批处理（executeBatch）的方式， 那么耗费的代价是 “—次连接＋多次执行＋一次释放 ” ，这样就能省去多次连接和释放数据库资源从而提升操作性能；\n\n- PreparedStatement里，占位符的编号是从 1 开始的，而不是从 0 开始的；\n- 批量操作能提升效率， 但一次性操作多少 ，效率能提升多高？这在不同的数据库中是不同的，一般每批是操作500 - 1000条语句。不要太多不然缓存放不完；\n\n\n#### （三）用 PreparedStatement 对象防止 SQL 注入\n\n#### （四）使用 C3P0 连接池\n如果操作很频繁，那么频繁的创建和关闭数据库连接动作会极大地减低系统的性能，在这种情况下，可以使用连接池；\n- 常见连接池有：C3P0 和 DBCP\n\n- C3P0 连接池的常用属性：\n![C3P0连接池常见属性]($resource/C3P0%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7.png)\n\n### 四、事务\n事务(Transaction)是—组针对数据库的操作， 这些操作要么都做， 要么都不做， 是 一个不可分割的 SQL 语句集合。\n\n#### （一）开启事务，合理的提交和回滚\n在JDBC中， 一般采用如下的方法使用事务。\n\n- 通过 `connection.setAutoCommit(false)` , 设置不是自动提交。在 JDBC 中，一般默认是自动提交，即有任何增删改的 SQL 语句都会立即执行。如果设置了非自动提交，要在用好事务后设置回 “ 自动提交” 。\n\n- 在合适的地方用 `connection.commit();` 来提交事务，一般是在执行结束后提交事务， 这样就会同时执行事务中的所有操作。\n\n- 可以通过 `connection.rollback()` 来回滚事务，回滚语句—般是放在 catch 从句中；一旦出现异常，就在 catch 中实现回滚；\n\n#### （二）事务中的常见问题：脏读、幻读和不可重复读\n在项目中， 如果**同时对一张表有两个（或多个） 事务进行读写操作时**，很容易出现数据读写错误的问题，具体表现形式有脏读、幻读和不可重复读。\n\n- **脏读 (dirtyread) 是指—个事务读取了另—个事务尚未提交的数据**\nA 值为 1，B 将其值设置为 2（但是尚未提交这个修改事务），A 读到值变为 2，结果 B 回滚了事务又将 A 值改为 1,则 A 读到的 2 就是一个脏数据，对应的操作为**脏读**；\n**避免方法：** 如果在第—个事务提交前，任何其他事务不可读取其修改过的值，则可以避免出现该问题。\n\n- **幻读 (phantom read) 是指一个事务的操作会导致另一个事务前后两次查询的结果不同**\nA 事务查询值为 1 的数据，读取到共 10 条记录，然后事务 B 插入一条数据值为 1，A 再次以同样条件读取就会得到 11 条；\n**避免方法：** 如果在操作事务完成数据处理之前 ， 任何其他事务都不可以添加新数据， 则可避免该问题。\n\n- **不可重复读(non-repeatable read)是指—个事务的操作导致另—个事务前后两次读取到不同的数据**。例如， 同—查询 在同一事务中多次进行， 由于其他事务提交了所做的修改（或和加或删除等操作） ， 这样每次查询会返回不同的结果集，这就是不可重复读。\nA 读到的值为 1，但是针对这个值的修改没有完成，事务 B 修改了值为 2，并提交了事务，则事务 A 再次读取值变为了 2；\n**避免方法：** 只有在修改事务完全提交之后才允许读取数据；\n\n- 幻读和不可重复读两者都表现为两次读取的结果不一致.\n- 但如果你从控制的角度来看,   两者的区别就比较大\n  - 对于幻读,   要锁住满足条件及其相近的记录  ：即需要锁住表\n  - 对于不可重复读,   只需要锁住满足条件的记录 ： 即需要锁住行\n  - 幻读的重点在于 insert；\n  - 不可重复读的重点在于：update 和 delete\n\n如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复 读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会 发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。\n\n**所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。**\n上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。\n\n*   悲观锁\n正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处 于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机 制，也无法保证外部系统不会修改数据）。\n\n在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。\n\n*   乐观锁\n相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。\n\n而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如 果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。\n\n要说明的是，MVCC的实现没有固定的规范，每个数据库都会有不同的实现方式，这里讨论的是InnoDB的MVCC。\n\n#### （三）事务隔离级别\n用户可以通过事务隔离级别来解决上述在事务中读写不一致的问题。在JDBC中，有5个常量来描述事务隔离级别，级别从低到高依次如下。\n\n(1)读取未提交：`TRANSACTION_READ_UNCOMMITTED`, 允许脏读、不可重复读和幻读。\n(2)读取提交：`TRANSACTION_READ_COMMITTED`, 禁止脏读，但允许不可重复读和幻读。【Oracle 默认级别】\n(3)可重读：`TRANSACTION_REPEATABLE_READ`,禁止脏读和不可重复读，但允许幻读。【MySQL 默认级别】\n(4)可串化：`TRANSACTION_SER IALIZABLE`, 禁止脏读、不可重复读和幻读。\n(5)还有一个常量是`TRANSACTION_NONE`,如果读取这个值，那么将使用当前数据库说指定的事务隔离级别；\n\n综上所述，如果设置高级别的事务隔离级别，那么数据库系统就要采取额外的措施来保证这个设置。会造成后续的操作和功能等待。\n\n√: 可能出现    ×: 不会出现\n| | 脏读 | 不可重复读 | 幻读 |\n|---|----|---|---\n| Read uncommitted | √ | √ | √ |\n| Read committed | × | √ | √ |\n| Repeatable read | × | × | √ |\n| Serializable | × | × | × |\n\n\n\n## 章六、反射机制和代理模式\n\n\n### 字节码和反射机制\n字节码 (Byte Code) 是Java 语言跨平台特性的重要保障， 也是反射机制的重要基础。通过反射机制 ， 我们不仅能看到一个类的属性和方法， 还能在—个类中调用另一个类的方法，但前提是要有相关类的字节码文件（也就是 class 文件）。\n\n- .Java 文件编译生成的 .class 文件可以在各种平台中运行（只要其有 Java 运行环境）；\n- Class 类的全称是 Java.lang.Class, 当一个类或接口（总之是 Java 文件被编译后的 class 文件）被装入Java 虚拟机 (JVM) 时便会产生一个与它相关联的 java.lang.Class 对象， 在反射部分的代码中， 我们一般通过 Class 来访问和使用目标类的属性和方法。\n\n\n\n### 反射的常见用法\n\n一是 “查看＇ ， 如输入某个类的属性方法等信息；\n二是 ＂ 装载'' 如装载指定的类到内存中；\n三是 “调用” 如通过输入参数， 调用指定的方法。\n\n#### 查看\n- 查看属性的修饰符、类型和名称 Demo：\n```java\nclass MyValClass {\n\tprivate int val1;\n\tpublic String val2;\n\tfinal protected String val3 = \"Java\";\n}\n\npublic class ReflectionReadVar{ \n\tpublic static void main(String[] args) {\n\t\tClass<MyValClass> clazz = MyValClass.class;\n\t\t//获取这个类的所有属性\n        Field[] fields = clazz.getDeclaredFields();\n\t    for(Field field : fields) {\n\t\t   //输出修饰符\n\t\t   System.out.print(Modifier.toString(field.getModifiers()) + \"\\t\");\n\t\t   //输出属性的类型\n\t\t   System.out.print(field.getGenericType().toString() + \"\\t\");\n\t\t   //输出属性的名字\n\t\t   System.out.println(field.getName());\n\t    }\n\t}\n}\n/**output:\n * private\tint\tval1\n * public\tclass java.lang.String\tval2\n * protected final\tclass java.lang.String\tval3\n */\n```\n\n- 查看方法的返回值类型、参数和名称\n```java\nclass MyFuncClass {\n\tpublic MyFuncClass(){}\n\tpublic MyFuncClass(int i){}\n\tprivate void f1(){}\n\tprotected int f2(int i){return 0;}\n\tpublic String f2(String s) {return \"Java\";}\n}\n\npublic class ReflectionReadFunc {\n\tpublic static void main(String[] args) {\n\t\tClass<MyFuncClass> clazz = MyFuncClass.class;\n\t\t// 返回所有的方法，但是不包括继承的方法和构造方法\n        Method[] methods = clazz.getDeclaredMethods();\n        for (Method method : methods) {\n            System.out.println(method);\n        }\n        System.out.println(\"***********\");\n       \n        //得到所有的构造函数\n        Constructor[] c1 = clazz.getDeclaredConstructors();\n        //输出所有的构造函数\n        for(Constructor ct : c1){\n            System.out.println(ct);\n        }\n\t}\n}\n/**\n * output:\n * protected int chapter6.MyFuncClass.f2(int)\n * public java.lang.String chapter6.MyFuncClass.f2(java.lang.String)\n * private void chapter6.MyFuncClass.f1()\n * ***********\n * public chapter6.MyFuncClass()\n * public chapter6.MyFuncClass(int)\n */\n```\n\n#### 装载\n- 通过 forName 和 newInstance 方法加载类\n  - Class.forName 方法最常用的用法就是装载数据库的驱动；\n  - 本质上 forName 的作用仅仅是返回一个 Class 类型的对象，newInstance 方法作用是加载类；即 newInstance 作用是通过 Java 虚拟机的类加载机制把指定的类加载到内存中。但是 newInstance 方法只能调用无参构造函数进行加载，如果有参数得使用 new 关键字。\n```java\nclass MyClass {\n\tpublic void print() {\n\t\tSystem.out.println(\"Java\");\n\t}\n}\n\npublic class ForClassDemo {\n\tpublic static void main(String[] args) {\n\t\tMyClass myClassObj = new MyClass();\n\t\tmyClassObj.print();//输出是Java\n\t\tSystem.out.println(\"*************\");\n\n\t\ttry {\n\t\t    // forName() 中的类名应该是完整的类名\n\t\t\tClass<?> clazz = Class.forName(\"chapter6.MyClass\");\n\t\t\tMyClass myClass = (MyClass)clazz.newInstance();\n\t\t\tmyClass.print();//输出是Java\n\t\t} catch (ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (InstantiationException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IllegalAccessException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n/**\n * output:\n * Java\n * *************\n * Java\n */\n```\n\n\n\n#### 通过反射机制调用类的方法\n- 通过什么方式调用：\n- 如何输入参数：\n- 如何得到返回结果：\ndemo：\n```java\nclass Person {\n\tprivate String name;\n\n\tpublic Person(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic void saySkill(String skill) {\n\t\tSystem.out.println(\"Name is:\" + name + \", skill is:\" + skill);\n\t}\n\n\tpublic int addSalary(int current) {\n\t\treturn current + 100;\n\t}\n}\n\npublic class CallFuncDemo {\n\tpublic static void main(String[] args) {\n\t\tClass c1azz = null;\n\t\tConstructor c = null;\n\t\ttry {\n\t\t// 通过反射调用类的构造函数来创建对象\n\t\t\t// 得到 Class 类型的对象，其中包含了 Person 类的信息\n\t\t\tc1azz = Class.forName(\"chapter6.Person\");\n\t\t\t// 得到 Person 类带参数的构造函数；c 值为：public chapter6.Person(java.lang.String)\n\t\t\tc = c1azz.getDeclaredConstructor(String.class);\n\t\t\t// 通过带参数的构造函数创建一个Person类型对象\n\t\t\tPerson p = (Person)c.newInstance(\"Peter\");\n\t\t\t//output: Name is:Peter, skill is:java\n\t\t\tp.saySkill(\"Java\");\n\n\t\t\t// 调用方法，必须传递对象实例，同时传递参数值\n\t\t\tMethod method1 = c1azz.getMethod(\"saySkill\", String.class);\n\t\t\t// 因为没返回值，所以能直接调\n\t\t\t// 参数一指定该方法由哪个对象调用，参数二指定该方法的参数\n            method1.invoke(p, \"C#\");\n            \n            Method method2 = c1azz.getMethod(\"addSalary\", int.class);\n            Object invoke = method2.invoke(p, 100);\n            //输出200\n\t\t\tSystem.out.println(invoke);\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (NoSuchMethodException  e1) {\n\t\t\te1.printStackTrace();\n\t\t}\n\t\tcatch (InstantiationException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IllegalAccessException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (InvocationTargetException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n/**output:\n * Name is:Peter, skill is:Java\n * Name is:Peter, skill is:C#\n * 200\n */\n```\n\n\n### 代理模式和反射机制\n反射的使用场景之一就是在代理模式；通过反射机制实现动态代理功能；\n\n~~P190-197~~\n\n\n\n\n\n## 章七：多线程和并发编程\n\n### 线程的基本概念和实现多线程的基本方法\n\n实现多线程的两种基本方法，一种是通过extends Thread 类的方式来实现，另一种是通过impleme nts Runnable 接口的方式来实现。\n通过这两种方法创建的线程都无法返回结果值， 而在本节的后半部分，将讲述通过Callable 让线程返回执行结果的方法。\n\n\n#### 线程和进程\n\n进程是实现某个独立功能的程序，它是操作系统（如windows系统）进行资源分配和调度的一个独立单位，也是可以独立运行的一段程序。\n线程是—种轻量级的进程， 它是—个程序中实现单—功能的—个指令序列，是一个程序的—部分，不能单独运行， 必须在一个进程环境中运行。\n\n**两者区别：**\n- 进程间相互独立， 但同—进程的各线程会共享该进程所拥有的资源，而进程则是用独占的方式来占有资洒，也就是说，进程间不能共享资源。\n- 线程上下文切换（如—个从线程切换到另外—个线程）要比进程上下文切换速度快得多。\n- 每个线程都有—个运行的入口 ， 顺序执行序列和出口，但是线程不能独立执行，必须依靠进程来调度和控制线程的执行。\n- 一般操作系统级别会偏重于 “进程” 的角度和管理，而应用项目（如某个在线购物平台）会偏重于 “线程” ， 如在某应用项目中的某些组件可以以多线程的方式同时执行。也就是说 ， 在编程时会更偏重千 “多线程” ，而不是 “多进程” 。\n\n#### 线程的生命周期\n在Java 中，—个线程的生命周期中会有4种状态：初始化、可执行、阻塞和死亡状态\n- 我们可以通过new语句创建一个线程对象，这时还没有调用它的start()方法，此时线程也没有分配到任何系统资源，这时称为初始化状态。\n- 当我们调用了start()方法之后，它会自动调用线程对象的run()方法，此时线程如果分配到了CPU时间就可以开始运行，否则等待分配CPU时间，但无论是否分配到了CPU时间， 线程此刻都处于可执行状态。\n- 通过某些方法，如sleep()方法或wait()方法，我们可以把线程从可执行状态挂起。此时线程不会分配到CPU时间， 因此无法执行， 这时称为阻塞状态。\n- 当线程睡眠了sleep参数所指定的时间后， 能自动地再次进入可执行状态，这时也可以通过notify()方法把因调用wait()方法而处于阻塞状态的线程变为可执行状态， 此刻该线程又有机会得到CPU时间继续运行了。\n- 线程run()方法中的逻辑正常运行结束后就进入了 死亡状态。 调用stop()方法或 destroy()方法时也会非正常地终止当前线程， 使其进入死亡状态， 之后该线程就不存在了。\n\n![线程间的状态转换]($resource/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png)\n\n#### 通过 extends Thread 实现多线程\n因为线程的调度工作由操作系统完成，因此线程的执行次序是不可控的，导致多线程运行时每次过程都不一致；\nDemo:\n```java\npackage chapter7;\n\npublic class SimpleThread extends Thread {\n\t// 线程编号\n\tint index;\n\n\t// 通过构造函数指定该线程的编号\n\tpublic SimpleThread(int index) {\n\t\tthis.index = index;\n\t\tSystem.out.println(\"Create Thread[\" + index + \"]\");\n\t}\n\n\t// run方法，当调用线程的start方法时会自动调用该方法，此时线程进入可执行状态\n\t@Override\n\tpublic void run() {\n\t\tfor (int j = 0; j <= 3; j++) {\n\t\t\tSystem.out.println(\"Thread[\" + index + \"]:running time \" + j);\n\t\t}\n\t\t// 当前线程运行结束\n\t\tSystem.out.println(\"Thread[\" + index + \"] finish\");\n\t}\n\n\tpublic static void main(String args[]) {\n\t    int threadCount = 3;\n\t\tfor (int j = 0; j < threadCount; j++) {\n\t\t\t// 实例化该类型的对象，并直接调用start方法直接把线程拉起\n\t\t\t// 这个方法会自动调用run方法\n\t\t\tThread t = new SimpleThread(j + 1);\n\t\t\tt.start();\n\t\t}\n\t}\n}\n/**\n * output:\n * Create Thread[1]\n * Create Thread[2]\n * Create Thread[3]\n * Thread[1]:running time 0\n * Thread[2]:running time 0\n * Thread[1]:running time 1\n * Thread[1]:running time 2\n * Thread[1]:running time 3\n * Thread[3]:running time 0\n * Thread[2]:running time 1\n * Thread[2]:running time 2\n * Thread[2]:running time 3\n * Thread[2] finish\n * Thread[3]:running time 1\n * Thread[1] finish\n * Thread[3]:running time 2\n * Thread[3]:running time 3\n * Thread[3] finish\n */\n\n```\n\n\n#### 通过 Implements Runnable 实现多线程（线程优先级）\n一般用于该类已经通过 extends 继承了一个类，则不能再使用 extends 继承 Thread 类来实现多线程，可以采用 implements Runnable 方式实现多线程。\n\n默认 1-10 共 10 个优先级别，数字越小级别越高，默认级别为 5，**但是高优先级的线程仅仅是比低优先级的先运行的概率大，不是绝对的能先执行。**\n```java\npackage chapter7;\n\n//实现Runnbale接口，此时这个类就可以extends其他的父类了\npublic class ThreadPriority implements Runnable {\n\t// 线程编号\n\tint number;\n\n\tpublic ThreadPriority(int num) {\n\t\tnumber = num;\n\t\tSystem.out.println(\"Create Thread[\" + number + \"]\");\n\t}\n\n\t// run方法，当调用线程的start方法时会调用该方法\n\t@Override\n\tpublic void run() {\n\t\tfor (int i = 0; i <= 3; i++) {\n\t\t\tSystem.out.println(\"Thread[\" + number + \"]:Count \" + i);\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\t// 定义线程t1，并设置其优先级为5\n\t\tThread t1 = new Thread(new ThreadPriority(1));\n\t\tt1.setPriority(1);\n\t\t// 定义线程t2，并设置其优先级为7\n\t\tThread t2 = new Thread(new ThreadPriority(2));\n\t\tt2.setPriority(7);\n\t\t// 启动这两个线程\n\t\tt1.start();\n\t\tt2.start();\n\t}\n}\n/**\n * output:\n * Create Thread[1]\n * Create Thread[2]\n * Thread[1]:Count 0\n * Thread[2]:Count 0\n * Thread[1]:Count 1\n * Thread[2]:Count 1\n * Thread[1]:Count 2\n * Thread[2]:Count 2\n * Thread[1]:Count 3\n * Thread[2]:Count 3\n */\n```\n\n\n\n### 多线程的竞争与同步\n\n#### 通过 sleep 方法让线程释放 CPU 资源\n通过线程类 Thread 的一个 sleep(参数为毫秒数) 静态方法，让当前运行的线程在这段时间内进入阻塞状态。 阻塞状态过去后， 该线程会重新进入可执行状态。\n示例：比如某个线程因数据库连接异常而无法连接到数据库， 这时我们可以通过sleep方法让该线程阻塞一段时间， 过后再重新连接。\n\nDemo：\n```java\npackage chapter7;\n\npublic class ThreadSleep extends Thread {\n\t@Override\n\tpublic void run() {\n\t\tLong curTime = System.currentTimeMillis();\n\t\t// sleep方法会抛出InterruptedException异常\n\t\t// 需要用try-catch语句进行捕捉\n\t\ttry {\n\t\t\tsleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t}\n\t\tSystem.out.println(\"ts线程阻塞的时间\" + (System.currentTimeMillis() - curTime) + \"毫秒\");\n\t}\n\n\tpublic static void main(String arg[]) {\n\t\tThreadSleep ts = new ThreadSleep();\n\t\tts.start();\n\t\tLong curTime = System.currentTimeMillis();\n        try {  \n            Thread.sleep(1000);  \n        } catch (InterruptedException e) {\n            e.printStackTrace();  \n        }  \n        System.out.println(\"主线程阻塞的时间\" + (System.currentTimeMillis() - curTime) + \"毫秒\");\n\t}\n}\n/**\n * output:\n * 主线程阻塞的时间1000毫秒\n * ts线程阻塞的时间2001毫秒\n */\n\n```\n\n####  Synchronized 作用在方法上\n解决多线程并发执行某个方法或者代码引发不同线程同时修改同块存储空间。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",[[1567037965165,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1567037966163,["GJX@GJXAIOU",[[1,0,"---\nstyle: summer\n---"]],[0,0],[21,21]]]],null,"GJX@GJXAIOU"]]}