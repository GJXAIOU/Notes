---
tags: 
- Java
- Java编程思想
flag: green
style: summer
date: '2019-7-6'
---

# 第一章：对象导论


## 1.1 抽象过程
非 OOP（Object-oriented Programming）编程语言的抽象都是要求在解决问题的时候基于计算机的机构，而不是基于要解决的问题的结构进行思考。

在 OOP 中，将问题空间中的元素及其在解空间中的表示称为“对象”；程序可以通过添加新类型的对象使得自身适用于某个特定的问题；

- Java 作为 OOP 的五种特性：
  - 万物皆对象；
  - 程序是对象的集合，他们可以通过发送消息来告知彼此所要做的；
  - 每个对象都有自己的由其他对象所构成的存储；
  - 每个对象都拥有其类型：即每个对象都是某个类的一个实例，每个类最重要的区别于其他类的特性就是“可以发送什么样的消息给它”；
  - 某一特定类型的所有对象都可以接收同样的消息；

## 1.2 每个对象都有一个接口

- 创建抽象数据类型（类）是面向对象程序设计的基本概念之一；
- 类描述了具有相同特性（数据元素）和行为（功能）的对象的集合，因此实际上是一个数据类型；
- 每个对象只能满足某些请求，这些请求是由对象的接口所定义的，决定接口的是类型；

## 1.3 每个对象都提供服务
内聚：每个对象都可以完成某一项任务，但是不要试图做更多的事情；

## 1.4 被隐藏的具体实现

Java 使用三个关键字在类的内部设定边界：
- public :其紧随其后的元素对任何人都是可以使用的；
- private : 除了类型的创建者和类型的内部方法之外任何人不能访问；
- protected ：几乎同上，只是继承的类是可以访问 protected 成员；

Java 默认的访问权限是：包访问权限，即类可以访问同一个包（库构件）中的其他类成员，但是在包之外不能访问；


## 1.5 复用具体体现

**组合：** 使用现有类合成新的类；
**聚合：** 如果组合是动态发生的，称之为聚合

==在构建新类时候，优先考虑组合，然后才是继承==

## 1.6 继承
继承针对：基类（超类、父类） 和 继承类，体现了相似性和差异性；

- 继承现有类型的时候，也就创造了新的类型，新的类型不仅仅包括现有类型的所有成员，重要的是：**它复制了基类的接口**，即**所有可以发送给基类对象的消息同时发送给导出类对象**；
- 使基类和导出类产生差异的两种方式：
  - 继承类中增加新的方法；
  - 继承类中改变现有基类的方法，相当于重写父类的方法，称之为：覆盖

### 1.6.1 “是一个”和“像是一个”关系
**替代原则（纯粹替代）**：继承类只是覆盖了基类的方法，不添加基类中没有的新方法；
像是一个：继承类中增加了基类中没有的新方法；


## 1.7 伴随多态的可互换对象（没怎么看懂）
见 Java -> Blog ->Java 中的绑定、前期绑定、后期绑定

**前期绑定**：编译器将产生对一个具体函数名字的调用，而运行时将这个调用解析到将要被执行的代码的绝对地址；
**后期绑定**：程序直到运行时候才能确定代码的位置；
Java 中动态绑定是默认行为，同时，只有除了final，static，private和构造方法是前期绑定外，其他的方法全部为动态绑定；

==**向上转型**==：将导出类看成是它的基类的过程



## 1.8 单根继承结构

Java 所有的类最终都继承自单一的基类：Object；
优势：
- 单根继承结构找那个所有的对象都具有一个共用接口，因此它们归根到底都是相同的基本类型；
- 单根继承结构保证所有的对象都具有某些功能；
- 单根继承结构使垃圾回收器的实现变得容易；

## 1.9 容器

解决目标：当不知道在解决某个特定的问题需要多少的对象，或者它们将存活多久的时候，需要知道需要多少空间来创建这些对象；

解决方法：创建另一种对象类型，这种新的对象类型持有对其它对象的引用；称之为：容器；例如：list、map、set 都是一种容器；

### 1.9.1 参数化类型（泛型）
**向下转型**：将一个泛化的类型转换为一个更加具体的类型；
使用泛型可以减少向下转型带来的强制类型转换


## 1.10 对象的创建和生命期

- 对象放置在 堆栈区（自动变量、限域变量或静态存储区域），优先考虑存储空间的分配以及释放，但是牺牲灵活性，要求编程时需要知道对象的确切数量、生命周期与类型；
- 对象放置在 堆（heap）的内存池中动态的创建对象；
  - 1.直到运行时候才知道需要多少对象、他们的生命周期以及具体类型；
  - 因为存储空间是在运行的时候进行动态分配的，所以需要大量的时间在堆中分配存储空间，这可能要远远大于在堆栈中创建存储空间的时间。在堆栈 中存储空间和释放存储空间通常各需要一条汇编指令即可，分别对应将栈顶指针向下移动和栈顶指针向上移动。创建堆存储空间的时间依赖于存储机制的设计；

**比较：** 
Java 完全采用动态内存分配方式；
- 在堆栈上创建对象，编译器可以确定对象的存活时间，并可以自动销毁；
- 在堆上创建对象，编译器对对象的生命周期一无所知，只能使用 Java 的垃圾回收器；


