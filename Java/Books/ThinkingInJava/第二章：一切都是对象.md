---
tags: 
- Java
- Java编程思想
flag: green
style: summer
date: '2019-7-6'
---
# 第二章：一切都是对象


## 2.1 用引用操纵对象

**操纵的标识符实际上是对象的一个“引用”；**
示例：
`String s; `创建的仅仅是一个引用，并不是对象，如果向 s 发送一条消息，就会返回运行时错误，因为此时 s 没有和任何对象相关联；
`String s = "hello";` **创建一个引用的同时便进行初始化**
这里的初始化可以理解为：将引用与某个对象相关联；

## 2.2 必须由你创建所有的对象

### 2.2.1 对象存储区域

- 寄存器： 在处理器的内部，是最快的存储区，数量有限，不能直接控制；
- 堆栈：位于通用 RAM（随机访问存储器）中，但是通过**堆栈指针**可以从处理器直接获得支持。堆栈指针向下移动，则分配新的内存；若向上移动，则释放内存；分配存储的方法的快速和有效性仅次于寄存器；因为 java 系统的知道存储在堆栈中对象具体的声明周期，因此灵活性不好；**对象引用存放在堆栈中。**
- 堆：一种位于 RAM 的通用内存池，**用于存放所有的 Java 对象**，编译器不需要知道存储的数据在堆中存活多长时间，因此灵活性较大，但是堆进行存储分配和清理可能比堆栈进行存储分配需要更多的时间。存储new出来的类的**对象（包括其成员变量）和数组**;堆中分配的内存由JVM的自动垃圾回收器来管理
- 常量存储：常量值直接存储在程序代码内部；
- 非 RAM 存储：数据完全存活与程序之外，不受程序的约束，与程序有没有运行没有关系，存放在编译期被确定，并被保存在已编译的.class文件中的一些数据；存放字符串常量，其他基本数据类型的常量，类和接口的全限定名，字段名称和描述符，方法名称和描述符,例如：**流对象和持久化对象**

### 2.2.2 特例：基本类型
基本数据类型的变量是直接将“值”存储在堆栈中；
Java 基本数据类型占的存储空间大小是不变的，和系统无关，**不随机器硬件架构的变化而变化**；

| 基本类型    | 大小      | 最小值       | 最大值            | 包装器类      |
|---------|---------|-----------|----------------|-----------|
| boolean | \-      | \-        | \-             | Boolean   |
| byte    | 8 bits  | \-128     | \+127          | Byte      |
| char    | 16 bits | Unicode 0 | Unicode 2^16\-1 | Character |
| short   | 16 bits | \-2^15     | \+2^15\-1       | Short     |
| int     | 32 bits | \-2^32     | \+2^32\-1       | Integer   |
| float   | 32 bits | IEEE754   | IEEE754        | Float     |
| long    | 64 bits | \-2^63     | \+2^63\-1       | Long      |
| double  | 64 bits | IEEE754   | IEEE754        | Double    |
| void    | \-      | \-        | \-             | Void      |

所有数值类型都有正负号 
   boolean类型所占存储空间的大小没有明确指定（要看具体虚拟机的实现），仅定义为能够取字面值true或false。

**基本类型具有包装器类，使得可以在堆中创建一个非基本对象，用来表示对应的基本类型：相当于变成了对象**

**自动装箱**：自动地将一个原始数据类型转换为一个封装类型
**自动拆箱**：自动地将一个封装类型数据转换为原始数据类型

**补：高精度计算类：** 这两个包装器没有对应的数据类型 
- BigInteger：支持任意精度的整数，可以准确表示任何大小的**整数值**；
- BigDecimal： 支持任意精度的定点数；

### 2.2.3 Java中的数组
  Java确保数组会被初始化。而且不能在它的范围之外被访问。这种**范围检查，是以每个数组上少量的内存开销及运行时的下标检查为代价的**。
```Java
《深入理解Java虚拟机》：
Java 语言中对数组的访问比C/C++相对安全是因为：
如有一维数组，其元素类型为 mypackage.MyClass，
则虚拟机会自动生成一个直接继承于java.lang.Object的子类
[Lmypackage.MyClass，创建动作由字节码指令newarray触发。
这个类代表了一个元素类型为mypackage.MyClass的一维数组，
数组中应有的属性和方法（用户可直接使用的只有被修饰为
public的length属性和clone()方法）都实现在这个类里。
Java语言中对数组的访问比C/C++相对安全就是因为这个类
封装了数组元素的访问方法（准确地说，越界检查不是封装
在数组元素访问的类中，而是封装在数组访问的xaload、
xastore字节码中），而C/C++直接翻译为对数组指针的移动。
```

```java

// NotInit.java
package mypackage;
class MyClass{
    static{
        System.out.println("MyClass Init...");
    }
}
public class NotInit{
    public static void main(String[] args){
        MyClass[] a = new MyClass[3];
    }   
}
/*
* 没有输出，说明数组元素没有初始化（虚拟机自动生成了别的类）。
*/

```

- 创建一个数组对象，实际就是创建一个引用数组，每个引用元素会被初始化为null。java 看到 null，认为该引用没有指向对象；
- 基本数据类型的数组，编译器会将这种数组所占的内存全部置为零。
- 在Java语言中，当检查到发生数组越界时会抛出java.lang.ArrayIndexOutOfBoundsException异常。
- **使用任何引用之前，必须为其指定一个对象**

## 2.3 作用域（scope）
  1. **Java 与 C/C++ 关于作用域的区别**：如下，对于Java，非法，而对于 C/C++ 合法。（在 C/C++ 里将一个作用域的变量“隐藏”起来的做法，在Java里是不允许的。因为Java设计者认为这样做会导致程序混乱。）
```language
{
    int x = 12;
    {
        int x = 96;     // Illegal for Java, but legal for C/C++
    }
}
```
  2. **Java对象不具备和基本类型一样的生命周期**。当用new创建一个Java对象时，它可以存活于作用域之外。如：
```language
{
    String s = new String("a string");
}   // End of scope
```
引用 s 在作用域终点就消失了。然而，s 指向的 **String 对象仍继续占据内存空间**。

Java 中的**垃圾回收器**：用来监视用 new 创建的所有对象，并辨别那些不会再被引用的对象，随后释放这些对象的空间，便于其他新的对象使用；

## 2.4 创建新的数据类型：类
**基本成员默认值：**
==只有当变量作为类的成员时候，Java 才确保给定其默认值==
对于其他局部变量：例如：`int c;` 获得的是一个随机值；

## 2.5 方法、参数、返回值

- 方法和参数列表唯一的标识出某个方法；
- Java 中的方法只能作为类的一部分来创建，方法（除了使用 static 修饰）只能使用对象调用；
- 调用方法的行为称为：发送消息给对象；

### 2.5.1 参数列表
参数中传递的实际上也是对象的引用；
字符串中每个字符的尺寸都是 16 位或者 2 个字节；

**返回值**
- return 作用：
  - 结束该方法的执行；
  -  返回该函数要返回的值到调用该方法处；

## 2.6 创建一个 Java 程序
### 2.6.1 import 关键字
  import关键字指示编译器导入一个包，也就是一个类库（在其他语言中，一个库不仅包含类，还可能包括方法和数据，**但是Java中所有的代码都必须写在类里**）。 
  特定类 java.lang 会被**自动导入**到每一个Java文件中。

### 2.6.3 static 关键字
**只有执行 new 来创建对象的时候，数据存储空间才被分配**

- **通过 static 关键字可以满足以下两方面情形的需要**：
只想为某一**特定域分配单一存储空间**，而不去考虑空间要创建多少对象，甚至根本就不创建任何对象。
希望某个方法不与包含它的类的任何对象关联在一起。也就是说，即使**没有创建对象，也能够调用这个方法**。
  有些面向对象语言采用类数据和类方法两个术语，代表那些数据和方法只是作为整个类，而不是类的某个特定对象而存在的。例：

- **static 字段**
```java
class StaticTest{
    static int i = 47;
}
```
  如下创建两个对象，st1.i 和 st2.i 指向同一存储空间，共享同一个 i ，因此它们具有相同的值47。
```language
StaticTest st1 = new StaticTest();
StaticTest st2 = new StaticTest();
```
- **static 方法**
  - static作用于字段时，会改变数据的创建方式，但作用于方法时，差别却没有那么大。static方法的一个重要用法就是在不创建任何对象的前提下就可以调用它。这一点对定义main()方法很重要（所以main()方法是一个 satic 方法），这个方法是运行一个应用时的入口点。
  - 和其它任何方法一样，static方法可以创建或使用与其类型相同的被命名对象，因此，static方法常常拿来做“牧羊人”的角色，负责看护与其隶属同一类型的实例群。
  - static方法的含义：static方法就是没有this的方法。关于static方法内部是否能调用非静态方法：因为没有this，就没有对象，所以不能直接调用非静态方法，但可以传递一个对象引用到静态方法里，然后通过这个引用（和this效果相同）来调用非静态方法和访问非静态数据成员。
有些人认为static方法不是“面向对象”的，因为它们的确具有全局函数的语义；使用static方法时，由于不存在this，所以不是通过“向对象发送消息”的方式来完成的。


## 2.7 零碎知识点

- java.lang 是默认导入到每个 Java 文件中的
- println();作用：将数据打印到控制台然后换行；
- main 方法中的 args 参数是用于存储命令行参数；


## 2.8 注释和嵌入式文档

P32-36

