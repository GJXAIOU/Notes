---
tags: 
- Java
- Java编程思想
flag: yellow
style: summer
date: '2019-7-8'
---
# 第五章：初始化与清理

## 5.1 用构造器确保初始化

- 通过提供构造器，类的设计者可以确保每个对象都会得到初始化；因为构造器会自动调用的；
- Java 中“初始化”和“创建”捆绑在一起，不可分离；
- 构造器没有返回值，不是返回值为空 (void),new 表达式确实返回了对新建对象的引用，但是构造器本身没有返回任何值；



## 5.2 方法重载（method overloading）
  重载方法，方法名相同，形式参数列表不同（参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同）。重载是面向对象的一个基本特性。但是一般不使用参数的顺序不同来区分；

* 声明为final的方法不能被重载
* 声明为static的方法不能重载，但是能够被再次声明。
* 重载方法的返回类型可以相同也可以不同，但仅返回类型不同不足以成为方法的重载。
* 编译器根据调用方法的签名逐个匹配，以选择对应方法的过程叫做重载分辨（Overload Resolution，或叫重载决议）。 
```java
1. 《深入理解Java虚拟机》：虚拟机（准确地说是编译器）在重载时是通过参数的静态类型（Static Type ）或叫外观类型（Apparent Type）而不是实际类型（Actual Type）作为判定依据的。 
2. 《深入理解Java虚拟机》：编译期间选择静态分派目标的过程是Java语言实现方法重载的本质。
```

### 5.2.2 涉及基本类型的重载
基本数据类型会从一个较小的类型，自动的提升到较大的类型；
原则：
- 同一类型的优先匹配，没有同一类型，按照**一级一级**顺序向上提升；char、int、float、double；逐级上升；
- 如果传入的实际参数过大，必须先进行类型转换来窄化转换；


## 5.4 this 关键字
  `this` 关键字只能在方法内部使用，表示对“**调用方法的那个对象**”的引用。在方法内部调用同一个类的另一个方法，不必使用 this；

示例：
```java
public class Leaf{
    int i = 0 ;
    Leaf increment(){
        i++;
        return this;  //返回当前对象的引用
    }

    void print(){
        System.out.println( " i " + i);
    }

    public static void main(String[] args) {
        Leaf leaf = new Leaf();
        x.increment().increment().increment().print();
    }
}
//Output :  i = 3
```

### 5.4.1 在构造器中调用构造器

this是指“这个对象”或者“当前对象”，而且它本身表示对当前对象的引用；在构造器中，如果为this添加了参数列表，那么就有了不同的含义，这将产生**对符合此参数列表的某个构造器的调用**

```java
public class Flower {
    int petalCount = 0;
    String s = "initial value";
    Flower(int petals) {
        petalCount = petals;
        System.out.println("Constructor with int arg only");
    }
    Flower(String s, int petals) {
        this(petals);//call constructor <Flower(int petals)>
        //! this(s);//can't call two
        this.s = s;
        System.out.println("Constructor with int & String args");
    }
    Flower() {
        this("hi", 47);
        System.out.println("Default constructor with no arg");
    }
}
```

可以用this调用一个构造器，但是不能同时调用两个，而且必须**将构造器调用放在最开始位置**
**除了构造器之外，编译器禁止其他任何方法中调用构造器；**





## 5.5 清理：终结处理和垃圾回收

垃圾回收器只知道释放经由 new 分配的内存；


### 5.5.1 finalize()
* Java中的finalize()不等于C++中的析构函数
* 当发生“垃圾回收”时，finalize()才得到调用
* Java里的对象并非总是被垃圾回收（因为Java的“垃圾回收”并不能保证一定会发生） 
  * 对象可能不被垃圾回收
  * 垃圾回收并不等于“析构”
  * 垃圾回收只与内存有关；使用垃圾回收器的唯一原因是为了回收程序不在使用的内存；
* Java并未提供“析构函数”或相似的概念，Java的“垃圾回收”不保证一定会发生，所以要做类似的清理工作，必须自己动手创建一个执行清理工作的普通方法。
* 只要程序没有濒临存储空间用完的那一刻，垃圾回收可能就会一直没有发生。这个策略是恰当的，因为垃圾回收本身也有开销，要是不使用它，那就不用支付这部分开销了。
*
### 5.5.2 finalize()用途何在
* 由于垃圾回收器会负责释放对象占据的所有内存，这就将finalize()的需求限制到一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间。由于Java中一切皆为对象，所以那种特殊情况主要发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方式。 
* JVM 未面临内存耗尽的情况下，不会浪费时间去执行垃圾回收以恢复内存的；
* 不要过多地使用finalize()，它不是进行普通的清理工作的合适场所。  
```java
Joshua Bloch在题为“避免使用终结函数”一节中走得更远，他提到：“终结无法预料，常常是危险的，总之是多余的。”《Effective Java》，第20页，（Addison-Wesley 2001）
```


### 5.5.4 垃圾回收器如何工作
- Java 从堆中分配空间的速度可以和其他语言从堆栈上分配空间的速度相媲美；

**垃圾回收技术：**
- **计数**：简单但是速度很慢；每个对象都含有一个引用计数器，当有引用连接至对象的时候，计数+1。当引用离开作用域或者被置为 null 时，引用计数-1.对于对象之间的循环引用开销较大；
- **自适应**：
  - 停止- 复制：首先暂停程序的运行（因此它不属于后台回收模式），然后将所有存活的对象从当前堆度复制到另一个堆，没有复制的全是垃圾。因为复制之后的对象是一个挨着一个，所以新堆保持紧凑排列；
  - 标记- 清扫：从堆栈和静态存储区出发，遍历所有的引用，进而找出所有的存活对象，每找到一个对象就对对象设一个标记，这时候不会回收任何对象，只有全部标记工作完成的时候，清理工作才开始；清理过程是释放没有标记的对象，剩下的空间是不连续的，如果想得到连续的，需要重新整理剩下的对象；

**JVM 中提升速度方式：**
- 使用 JIT（Just in time 即时编译器）：先把程序全部或者部分翻译成本地机器码，当需要装载某个类的时候（通常是在为该类创建第一个对象的时候），编译器先找到.class 文件，然后将该类的字节码文件装入内存；接下来有两种方案：
  - 让即时编译器编译所有代码；
  - 惰性评估：即时编译器只有在必要的时候才编译代码；

## 5.6 成员初始化
Java尽力保证：所有变量在使用前都能得到恰当的初始化。

- 对于方法的局部变量，如果使用前没有初始化，Java以编译时错误（注意，如果方法内的局部变量未被使用，将不会编译错误）的形式来贯彻这种保证。

- 对于类的成员变量：
  - 成员变量是基本类型，Java会自动初始化初值0；
  - 成员变量是引用类型，Java会自动初始化初值null;
```java
// InitialValues.java
public class InitialValues{
    int j;
    char c;
    MyClass mc;
    public static void main(String[] args){
        int i;
        //i++; // Error -- i not initialized
        InitialValues obj = new InitialValues();
        System.out.println(obj.c);
        System.out.println(obj.j);
        System.out.println(obj.mc);
    }
}
class MyClass{}
```

- 无法阻止自动初始化的进行，它将在构造器被调用之前发生,如下，i首先会被置0，然后变成7。

```java
// Counter.java
public class Counter{
    int i;
    Counter(){
        i = 7;
    }
}
```

------
下面没核对，书本上从 P93 页开始做笔记
## 5.7 对象的创建过程

假设有个名为Dog的类：

* 静态方法或域。当首次创建类对象时（构造器可以看成静态方法，但不是）或类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件；
* 载入Dog.class，执行静态初始化的所有动作，且只执行这一次；
* 当调用`new Dog()`时，首先将在堆上分配存储空间；
* 存储空间清零。所以成员变量会置成0或null；
* 执行所有出现于字段**定义处的初始化**动作。
* 执行构造器。

## 5.8 数组初始化

可以将Java中的数组作为一种数组类型来理解。
* 如 int[] a; 可以认为是 a 是一个数组引用，初始值为null
* 初始化： 
  * int[] a = new int[3]; 初始化各元素值为0，对于boolean，初始值为false;
  * int[] a = {1, 2, 3}; 初始化元素分别为1, 2, 3;
