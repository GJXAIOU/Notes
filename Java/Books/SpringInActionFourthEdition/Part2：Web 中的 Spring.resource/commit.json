{"compress":true,"commitItems":[["114a5d6b-f49e-407f-864f-a5606b6562d8",1573095896828,"",[[1573095856212,["GJX@GJXAIOU",[[1,0,"# Part2：Web 中的 Spring\n\n\n\n"]],[0,0],[24,24]]]],null,"GJX@GJXAIOU"],["7be62f8e-94f1-4966-9fd6-e0162fd3fae3",1573132465471,"# Part2：Web 中的 Spring\n\n\n\n",[[1573132464110,["GJX@GJXAIOU",[[1,23,"## 一、构建 "]],[23,23],[31,31]]],[1573132473456,["GJX@GJXAIOU",[[1,31,"Spring Web 应用程序"]],[31,31],[46,46]]],[1573132474723,["GJX@GJXAIOU",[[1,48,"\n"]],[46,46],[47,47]]],[1573132475981,["GJX@GJXAIOU",[[1,49,"\n"]],[47,47],[48,48]]],[1573132476601,["GJX@GJXAIOU",[[1,48,"本章中，将会接触到Spring MVC基础，以及如何编写控制器来处理web请求，如何通明地绑定请求参数到业务对象上，同时还可以提供数据校验和错误处理的功能。\n\n# Spring MVC初探\n\n## 跟踪Spring MVC请求\n\n![请求会由DispatcherServlet分配给控制器（根据处理器映射来确定），在控制器完成处理后，接着请求会被发送给一个视图来呈现结果](http://hoxis-github-io.qiniudn.com/160118-spring-in-action-5.1.png)\n\n在请求离开浏览器时，会带有用户所请求内容的信息，例如请求的URL、用户提交的表单信息。\n\n请求旅程的第一站是Spring的DispatcherServlet。Spring MVC所有的请求都会通过一个前端控制器Servlet。前端控制器是常用的Web应用程序模式，在这里一个单实例的Servlet将请求委托给应用程序的其他组件来执行实际的处理。在Spring MVC中，DispatcherServlet 就是前端控制器。\n\nDispatcherServlet的任务是将请求发送给Spring MVC**控制器**。控制器是一个用于处理请求的Spring组件。在典型的应用程序中可能会有多个控制器， Dispatcher Servlet需要知道应该将请求发送给哪个控制器。所以DispatcherServlet会查询一个或多个处理器映射来确定请求的下一站在哪里。**处理器映射**会根据请求所携带的URL信息来进行决策。\n\n一旦选择了合适的控制器，DispatcherServlet会将请求发送给选中的控制器。到达了控制器，请求会卸下其负载（用户提交的信息）并等待控制器处理这些信息（实际上，设计良好的控制器本身只处理很少甚至不处理工作，而是将业务逻辑委托给个或多个服务对象）。\n\n控制器在完成逻辑处理后通常会产生一些信息，这些信息需要返回给用户并在浏览器上显示。这些信息被称为**模型**（Model）。不过仅仅给用户返回原始的信息是不够的–这些信息需要以用户友好的方式进行格式化，一般是HTML。所以，信息需要发送给—个**视图**（View），通常会是JSP。\n\n控制器所做的最后一件事是**将模型数据打包**，并且标示出用于渲染输出的视图名称。它接下来会将请求连同模型和视图名称发送回DispatcherServlet。\n\n这样，控制器就不会与特定的视图相耦合，传递给DispatcherServlet的视图名称并不直接表示某个特定的JSP。它仅仅传递了一个逻辑名，这个名字将会用来查找用来产生结果的真正视图。DispatcherServlet将会使用**视图解析器**来将逻辑视图名匹配为一个特定的视图实现。\n\n既然DispatcherServlet已经知道由哪个视图渲染结果，那么请求的任务基本上也就完成了。它的最后一站是视图的实现（可能是JSP），在这里它交付模型数据。请求的任务就完成了。视图将使用模型数据渲染输出，并通过这个输出将响应对象传递给客户端。\n\n## 搭建Spring MVC\n\n### 配置DispatcherServlet\n\nDispatcherServlet是Spring MVC的核心，它负责将请求分发到其他各个组件。\n\n在旧版本中，DispatcherServlet之类的servlet一般在`web.xml`文件中配置，该文件一般会打包进最后的war包种；但是Spring3引入了注解，我们在这一章将展示如何基于注解配置Spring MVC。\n\n**注意：**\n在使用maven构建web工程时，由于缺少web.xml文件，可能会出现`web.xml is missing and <failOnMissingWebXml> is set to true`这样的错误，那么可以通过在pom.xml文件中添加如下配置来避免这种错误：\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-war-plugin</artifactId>\n            <version>2.6</version>\n            <configuration>\n                <failOnMissingWebXml>false</failOnMissingWebXml>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n既然不适用`web.xml`文件，你需要在servlet容器中使用Java配置DispatcherServlet，具体的代码列举如下：\n\n```java\npackage spittr.config;\n\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\npublic class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { \"/\" };\n    }\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class<?>[] { RootConfig.class };\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class<?>[] { WebConfig.class };\n    }\n\n}\n```\n\n任意继承自`AbstractAnnotationConfigDispatcherServletInitializer`的类都会被自动用来配置DispatcherServlet，这个类负责**配置DispatcherServlet**、**初始化Spring MVC容器和Spring容器**。\n\nSpittrWebAppInitializer重写了三个方法，`getRootConfigClasses()`方法用于获取Spring应用容器的配置文件，这里我们给定预先定义的RootConfig.class；`getServletConfigClasses()`负责获取SpringMVC应用容器，这里传入预先定义好的WebConfig.class；`getServletMappings()`方法负责指定需要由DispatcherServlet映射的路径，这里给定的是”/”，意思是由DispatcherServlet处理所有向该应用发起的请求。\n\n### 两种应用上下文\n\n当DispatcherServlet启动时，会创建一个Spring应用上下文并且会加载配置文件中声明的bean，通过`getServletConfigClasses()`方法，DispatcherServlet会加载`WebConfig`配置类中所配置的bean。\n\n在Spring web应用中，通常还有另外一种应用上下文：`ContextLoaderListener`。\n\nDispatcherServlet用来加载web组件bean，如控制器（controllers）、视图解析器（view resolvers）以及处理器映射（handler mappings）等。而ContextLoaderListener则用来加载应用中的其他bean，如运行在应用后台的中间层和数据层组件。\n\nAbstractAnnotationConfigDispatcherServletInitializer会同时创建DispatcherServlet和ContextLoaderListener。`getServletConfigClasses()`方法返回的`@Configuration`类会定义DispatcherServlet应用上下文的bean。同时，`getRootConfigClasses()`返回的`@Configuration`类用来配置ContextLoaderListener上下文创建的bean。\n\n相对于传统的`web.xml`文件配置的方式，通过AbstractAnnotationConfigDispatcherServletInitializer来配置DispatcherServlet是一种替代方案。需要注意的是，这种配置只适用于**Servlet 3.0**，例如Apache Tomcat 7或者更高。\n\n### 激活Spring MVC\n\n正如有多种方式可以配置DispatcherServlet，激活Spring MVC组件也有不止一种方法。一般的，都会通过XML配置文件的方式来配置Spring，例如可以通过`<mvc:annotation-driven>`来激活基于注解的Spring MVC。\n\n最简单的配置Spring MVC的一种方式是通过`@EnableWebMvc`注解：\n\n```java\npackage spittr.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\n\n@Configuration\n@EnableWebMvc\npublic class WebConfig {\n\n}\n```\n\n`@Configuration`表示这是Java配置类；`@EnableWebMvc`注解用于启动Spring MVC特性。\n\n这样就可以激活Spring MVC了，但是还有其他一些问题：\n- 没有配置视图解析器（view resolvers），这种情况下，Spring会默认使用`BeanNameViewResolver`，它会通过寻找那些与视图id匹配的bean以及实现了View接口的类进行视图解析；\n- 没有激活组件扫描：这样Spring会寻找配置中明确声明的任意控制器；\n- DispatcherServlet会处理所有的请求，包括静态资源请求，如图片和样式（这些往往不是我们想要的）。\n\n因此，需要为WebConfig增加一些配置：\n\n```java\npackage spittr.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.ViewResolver;\nimport org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\nimport org.springframework.web.servlet.view.InternalResourceViewResolver;\n\n@Configuration\n@EnableWebMvc\n@ComponentScan(\"spitter.web\") // 激活Spring MVC\npublic class WebConfig extends WebMvcConfigurerAdapter {\n\n    // 配置一个JSP视图解析器\n    @Bean\n    public ViewResolver viewResolver() {\n        InternalResourceViewResolver resolver = new InternalResourceViewResolver();\n        resolver.setPrefix(\"/WEB_INF/views/\");\n        resolver.setSuffix(\".jsp\");\n        resolver.setExposeContextBeansAsAttributes(true);\n        return resolver;\n    }\n\n    @Override\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n        configurer.enable();\n    }\n}\n```\n\n首先需要注意的是，`WebConfig`使用了`@ComponentScan`注解，因此会在`spitter.web`包下扫描寻找组件，这些组件包括使用`@Controller`进行注解的控制器。这样就不再需要在配置类中显式地声明其他控制器。\n\n接下来，添加了一个`ViewResolver`bean，即`InternalResourceViewResolver`。它通过匹配符合设置的前缀和后缀的视图来用来寻找对应的JSP文件，比如视图home会被解析为/WEB-INF/views/home.jsp。这里的三个函数的含义依次是：`setPrefix()`方法用于设置视图路径的前缀；`setSuffix()`用于设置视图路径的后缀，即如果给定一个逻辑视图名称——”home”，则会被解析成”/WEB-INF/views/home.jsp”； `setExposeContextBeansAsAttributes(true)`使得可以在JSP页面中通过${}访问容器中的bean。\n\n然后，`WebConfig`继承自`WebMvcConfigurerAdapter`，并且重写了`configureDefaultServletHandling()`方法，通过调用`enable()`方法从而可以让DispatcherServlet将静态资源的请求转发给默认的servlet。\n\n```java\npackage spittr.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.ComponentScan.Filter;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.FilterType;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\n\n@Configuration\n@ComponentScan(basePackages = { \"spitter\" }, excludeFilters = {\n        @Filter(type = FilterType.ANNOTATION, value = EnableWebMvc.class) })\npublic class RootConfig {\n\n}\n```\n\n需要注意的一点是，RootConfig 使用了`@ComponentScan`注解。\n\n## Spittr应用介绍\n\n这一章要用的例子应用，从Twitter获取了一些灵感，因此最开始叫Spitter；然后又借鉴了最近比较流行的网站Flickr，因此我们也把e去掉，最终形成Spittr这个名字。这也有利于区分领域名称（类似于twitter，这里用spring实现，因此叫spitter）和应用名称。\n\nSpittr类似于Twitter，用户可以通过它添加一些推文。Spittr有两个重要的概念：_spitter_（应用的用户）和_spittle_（用户发布简单状态）。本章将会构建该应用的web层、创建用于展示spittle的控制器以及用户注册流程。\n\n# 编写简单的控制器\n\nSpring MVC中，控制器仅仅是拥有`@RequestMapping`注解方法的类，从而可以声明它们可以处理何种请求。\n\n在开始之前，我们先假设一个控制器，它可以处理匹配`/`的请求并会跳转到主页面。\n\n```java\npackage spittr.web;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\n@Controller // 声明一个控制器\npublic class HomeController {\n\n    @RequestMapping(value = \"/\", method = RequestMethod.GET) // 处理GET请求\n    public String home() {\n        return \"home\";\n    }\n\n}\n```\n\n`@Controller`是一个构造型注解，它基于`@Component`，组件扫描器会自动地将HomeController声明为Spring上下文的一个bean。\n\nhome()方法采用了`@RequestMapping`注解，属性`value`指定了该方法处理的请求路径，`method`方法指定了可以处理的HTTP方法。这种情况下，当一个来自`/`的GET方法请求时，就会调用home()方法。\n\nhome()方法仅仅返回了一个”home”的String值，Spring MVC会对这个String值进行解析并跳转到指定的视图上。`DispatcherServlet`则会请求视图解析器将这个逻辑视图解析到真实视图上。\n\n我们已经配置了InternalResourceViewResolver，“home”视图会被解析到`/WEB-INF/views/home.jsp`。\n\n```html\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\"%>\n<%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\"%>\n\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>Spittr</title>\n<link rel=\"stylesheet\" type=\"text/css\"\n    href=\"<c:url value=\"/resources/style.css\" />\">\n</head>\n<body>\n    <h1>Welcome to Spittr</h1>\n    <a href=\"<c:url value=\"/spittles\" />\">Spittles</a> |\n    <a href=\"<c:url value=\"/spitter/register\" />\">Register</a>\n</body>\n</html>\n```\n\n下面对HomeController进行测试。\n\n## 测试控制器\n\n一般的web测试需要将工程发布到一个web容器中，启动后才能观察运行结果。\n如：\n![主页](http://hoxis-github-io.qiniudn.com/160118-spring-in-action-homepage.png)\n\n从另外的角度来看，HomeController其实是一个简单的POJO对象，那么可以使用下面的方法对其进行测试：\n\n```java\npackage spittr.web;\n\nimport org.junit.Test;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.result.MockMvcResultMatchers;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\npublic class HomeControllerTest {\n\n    @Test\n    public void testHomePage() throws Exception {\n        HomeController controller = new HomeController();\n        // 设置MockMvc\n        MockMvc mockMvc = MockMvcBuilders.standaloneSetup(controller).build();\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/\")).andExpect(MockMvcResultMatchers.view().name(\"home\"));\n    }\n\n}\n```\n\n相对于直接调用home()方法测试它的返回值，上面的测试中发起了一个来自`/`的 GET 请求，并且对其结果视图进行断言。将HomeController的实例传送给`MockMvcBuilders.standaloneSetup`，并且调用`build()`方法来创建一个`MockMvc`实例。然后，使用`MockMvc`实例产生了一个GET请求，并且设置了视图的期望。\n\n## 定义类层级的请求处理\n\n```java\npackage spittr.web;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\n@Controller // 声明一个控制器\n@RequestMapping(\"/\") // 控制器匹配路径\npublic class HomeController {\n\n    @RequestMapping(method = RequestMethod.GET) // 处理GET请求\n    public String home() {\n        return \"home\";// 视图名称\n    }\n\n}\n```\n\n在这个新版的HomeController中，将请求匹配路径移到了类层级，HTTP方法的匹配仍处在方法层级。当有控制类中有一个类层级的`@RequestMapping`，该类中所有的用`@RequestMapping`注解的处理方法共同组成了类层级的`@RequestMapping`。\n\n`@RequestMapping`的value属性接受String数组，那么就可以使用如下配置：\n\n```java\n@Controller // 声明一个控制器\n@RequestMapping(\"/\", \"/homepage\") // 控制器匹配路径\npublic class HomeController {\n...\n}\n```\n\n这种情况下，home()方法就可以处理来自`/`和`/homepage`的GET请求。\n\n## 将model数据传送给视图\n\n在Spittr应用中，需要一个页面，用来显示最近提交的spittle清单。首先需要定义一个数据访问的仓库，用来抓取spittle：\n\n```java\npackage spittr.data;\n\nimport java.util.List;\nimport spittr.Spittle;\n\npublic interface SpittleRepository {\n    /**\n     * @param max\n     *            待返回的最大的Spittle ID\n     * @param count\n     *            返回Spittle对象的个数\n     * @return\n     */\n    List<Spittle> findSpittles(long max, int count);\n}\n```\n\n如果要获取最近的20个Spittle对象，那么只需调用这样调用：\n`List<Spittle> recent = spittleRepository.findSpittles(Long.MAX_VALUE, 20);`\n\n下面对Spittle进行定义：\n\n```java\npackage spittr;\n\nimport java.util.Date;\n\nimport org.apache.commons.lang3.builder.EqualsBuilder;\nimport org.apache.commons.lang3.builder.HashCodeBuilder;\n\npublic class Spittle {\n    private final Long id;\n    private final String message;// 消息\n    private final Date time;// 时间戳\n    private Double latitude;\n    private Double longitude;\n\n    public Spittle(String message, Date time) {\n        this(message, time, null, null);\n    }\n\n    public Spittle(String message, Date time, Double latitude, Double longitude) {\n        this.id = null;\n        this.message = message;\n        this.time = time;\n        this.latitude = latitude;\n        this.longitude = longitude;\n    }\n\n    @Override\n    public boolean equals(Object that) {\n        return EqualsBuilder.reflectionEquals(this, that, \"id\", \"time\");\n    }\n\n    @Override\n    public int hashCode() {\n        return HashCodeBuilder.reflectionHashCode(this, \"id\", \"time\");\n    }\n\n    //getters and setters\n\n}\n```\n\nSpittle对象中现在包含信息、时间戳、位置这几个属性。\n\n下面利用Spring的`MockMvc`来断言新的控制器的行为是否正确：\n\n上面的测试通过创建一个SpittleRepository接口的mock实现，该实现会通过findSpittles()方法返回一个包含20个Spittle对象的集合。然后将这个bean注入到SpittleController实例中，并设置MockMvc使用该实例。\n\n不同于HomeControllerTest，该测试使用了`setSingleView()`，发起一个`/spittles`的GET请求，并断言视图是否为spittles以及model是否含有一个spittleList的属性值。\n\n当然，现在运行这个测试代码肯定是会出错的，因为还没有SpittleController。\n\n```java\npackage spittr.web;\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\nimport org.hamcrest.core.IsCollectionContaining;\nimport org.junit.Test;\nimport org.mockito.Mockito;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.result.MockMvcResultMatchers;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\nimport org.springframework.web.servlet.view.InternalResourceView;\n\nimport spittr.Spittle;\nimport spittr.data.SpittleRepository;\n\npublic class SpittleControllerTest {\n\n    @Test\n    public void shouldShowRecentSpittles() throws Exception {\n        List<Spittle> expectedSpittles = createSpittleList(20);\n        SpittleRepository mockRepository = Mockito.mock(SpittleRepository.class);\n        Mockito.when(mockRepository.findSpittles(Long.MAX_VALUE, 20)).thenReturn(expectedSpittles);\n\n        SpittleController controller = new SpittleController(mockRepository);\n        MockMvc mockMvc = MockMvcBuilders.standaloneSetup(controller)\n                .setSingleView(new InternalResourceView(\"/WEB_INF/views/spittles.jsp\")).build();\n\n        // 调用MockMvc.perform(RequestBuilder requestBuilder)发起一个http请求，然后将得到ResultActions\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/spittles\"))// 添加验证断言来判断执行请求后的结果是否是预期的；\n                .andExpect(MockMvcResultMatchers.view().name(\"spittles\"))// view()：得到视图验证器；\n                // 得到相应的***ResultMatchers后，接着再调用其相应的API得到ResultMatcher，\n                // 如ModelResultMatchers.attributeExists(final String... names)判断Model属性是否存在。\n                .andExpect(MockMvcResultMatchers.model().attributeExists(\"spittleList\"))// model()：得到模型验证器；\n                .andExpect(MockMvcResultMatchers.model().attribute(\"spittleList\", IsCollectionContaining.hasItems(expectedSpittles.toArray())));\n    }\n\n    private List<Spittle> createSpittleList(int count) {\n        List<Spittle> spittles = new ArrayList<Spittle>();\n        for (int i = 0; i < count; i++) {\n            spittles.add(new Spittle(\"Spittle \", new Date()));\n        }\n        return spittles;\n    }\n\n}\n```\n\nSpittleController中，使用@Autowired注解注入了spittleRepository属性。\n\n需要注意的是`spittles()`方法使用了Model（_控制器和视图之间传递的数据_）作为入参，Model本质上是一个map，它会被传送至view，因此数据可以提供给客户端。如果在调用`addAttribute()`方法时没有指定key，那么就会从传入的对象中获取，比如代码中传入的参数属性是List，那么key就是spittleList。最后，该方法返回spittles作为传动给model的视图名称。\n\n也可以显示的指定key：\n\n```java\nmodel.addAttribute(spittleRepository.findSpittles(Long.MAX_VALUE, 20));\n```\n\n也可以直接采用map的方式：\n\n```java\n@RequestMapping(method = RequestMethod.GET)\npublic String spittles(Map model) {\n    // 将spittles添加到model中\n    model.put(\"spittles\", spittleRepository.findSpittles(Long.MAX_VALUE, 20));\n\n    // 返回视图名称\n    return \"spittles\";\n}\n```\n\n不管采用何种方式实现spittles()方法，结果都是一样的。一个Spittle对象集合会存储在model中，并分配到名为spittles的view中，根据测试方法中的配置，该视图就是/WEB-INF/views/spittles.jsp。\n\n现在model已经有数据了，那么JSP页面中如何获取数据呢？当视图是一个JSP页面时，model数据会作为请求属性被拷贝到请求中，因此可以通过JSTL（JavaServer Pages Standard Tag Library）`<c:forEach>`来获取：\n\n```html\n<c:forEach items=\"${spittleList}\" var=\"spittle\">\n    <li id=\"spittle_<c:out value=\"spittle.id\"/>\">\n        <div class=\"spittleMessage\">\n            <c:out value=\"${spittle.message}\" />\n        </div>\n        <div>\n            <span class=\"spittleTime\"><c:out value=\"${spittle.time}\" /></span>\n            <span class=\"spittleLocation\"> (<c:out\n                    value=\"${spittle.latitude}\" />, <c:out\n                    value=\"${spittle.longitude}\" />)\n            </span>\n        </div>\n    </li>\n</c:forEach>\n```\n\n下面对SpittleController进行扩展，让它可以处理一些输入。\n\n# 接受输入请求\n\nSpring MVC提供了如下方式供客户端传递数据到控制器处理方法：\n- Query parameters\n- Form parameters\n- Path variables\n\n## 处理查询参数：@RequestParam\n\nSpittr应用的一个需求就是要对spittle列表分页展示，但是SpittleController仅仅展示最近的spittle。如果要让用户可以每次得到一页的spittle记录，那么就需要让用户可以通过某种方式将他们想看的spittle记录的参数传递到后台。\n\n在浏览spittle时，如果想要查看下一页的spittle，那么就需要传递比当前页的最后一个spittle的id小一位的id，也可以传递想要展示的spittle的数量。\n\n为了实现分页，需要编写一个控制器满足：\n- `before`参数，结果中的spittle的id都要在这个参数之前；\n- `count`参数，结果中要包含的spittle的个数\n\n下面我们对上面的`spittles()`方法进行小小的改动，让它可以使用before和count参数。首先对测试方法进行改动：\n\n```java\n    @Test\n    public void shouldShowRecentSpittles() throws Exception {\n        List<Spittle> expectedSpittles = createSpittleList(20);\n        SpittleRepository mockRepository = Mockito.mock(SpittleRepository.class);\n        Mockito.when(mockRepository.findSpittles(238900, 50)).thenReturn(expectedSpittles);\n\n        SpittleController controller = new SpittleController(mockRepository);\n        MockMvc mockMvc = MockMvcBuilders.standaloneSetup(controller)\n                .setSingleView(new InternalResourceView(\"/WEB_INF/views/spittles.jsp\")).build();\n\n        // 调用MockMvc.perform(RequestBuilder requestBuilder)发起一个http请求，然后将得到ResultActions\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/spittles?max=238900&count=50\"))// 添加验证断言来判断执行请求后的结果是否是预期的；\n                .andExpect(MockMvcResultMatchers.view().name(\"spittles\"))// view()：得到视图验证器；\n                // 得到相应的***ResultMatchers后，接着再调用其相应的API得到ResultMatcher，\n                // 如ModelResultMatchers.attributeExists(final String... names)判断Model属性是否存在。\n                .andExpect(MockMvcResultMatchers.model().attributeExists(\"spittleList\"))// model()：得到模型验证器；\n                .andExpect(MockMvcResultMatchers.model().attribute(\"spittleList\", IsCollectionContaining.hasItems(expectedSpittles.toArray())));\n    }\n```\n\n这个测试方法的主要改动就是它发起的GET请求传递了两个参数：max和count。对`spittles()`进行修改：\n\n```java\n@RequestMapping(method=RequestMethod.GET)\npublic List<Spittle> spittles(\n        @RequestParam(value=\"max\", defaultValue=MAX_LONG_AS_STRING) long max, \n        @RequestParam(value=\"count\", defaultValue=\"20\") int count) {\n    return spittleRepository.findSpittles(max, count);\n}\n```\n\n这种情况下，如果没有max参数没有指定，那么就会使用默认的设置。由于查询参数是String类型的，因此`defaultValue`属性值也需要设置为String类型，需要对Long.MAX_VALUE进行设置：\n`private static final String MAX_LONG_AS_STRING = \"9223372036854775807\";`\n\n虽然，这里defaultValue的属性为String类型，当运行到函数时，将会根据函数的参数类型进行转换。\n\n查询参数是请求中传送信息给控制器的最常用方式，另外一种流行的方式就是将参数作为请求路径的一部分。\n\n## 通过路径参数传递数据：@PathVariable\n\n假设现在应用需要展示单独的一篇Spittle，那么就需要一个id作为查询参数，对应的处理方法可以是：\n\n```java\n@RequestMapping(value=\"show\", method=RequestMethod.GET)\npublic String showSpittle(\n        @RequestParam(\"spittle_id\") long spittleId,\n        Model model\n        ) {\n    model.addAttribute(spittleRepository.findOne(spittleId));\n    return \"spittle\";\n}\n```\n\n这个handler方法将会处理形如`/spittles/show?spittle_id=12345`的请求，但是这并不符合资源导向的观点。理想情况下，应该使用URL路径对资源进行区分，而不是查询参数，即应该使用`/spittles/12345`这种形式。\n\n为了实现资源导向的控制器，我们先在测试中获得这个需求（使用了静态引入）：\n\n```java\n@Test\npublic void testSpittle() throws Exception {\n    Spittle expectedSpittle = new Spittle(\"Hello\", new Date());\n    SpittleRepository mockRepository = Mockito.mock(SpittleRepository.class);\n    when(mockRepository.findOne(12345)).thenReturn(expectedSpittle);\n\n    SpittleController controller = new SpittleController(mockRepository);\n    MockMvc mockMvc = standaloneSetup(controller).build();\n\n    mockMvc.perform(get(\"/spittles/12345\"))\n    .andExpect(view().name(\"spittle\"))\n    .andExpect(model().attributeExists(\"spittle\"))\n    .andExpect(model().attribute(\"spittle\", expectedSpittle));\n}\n```\n\n该测试中发起了一个`/spittles/12345`的GET请求，并且对其返回结果视图进行断言。\n\n为了满足路径参数，Spring MVC允许在`@RequestMapping`路径中使用占位符（需要用大括号包围），下面是使用占位符来接受一个id作为路径的一部分：\n\n```java\n@RequestMapping(value=\"/{spittleId}\", method=RequestMethod.GET)\npublic String spittle(\n        @PathVariable(\"spittleId\") long spittleId,\n        Model model\n        ) {\n    model.addAttribute(spittleRepository.findOne(spittleId));\n    return \"spittle\";\n}\n```\n\nspittle()方法的spittleId入参使用了`@PathVariable(\"spittleId\")`注解，表明请求中占位符位置的值都会被传送到handler的spittleId参数。_@RequestMapping中value属性的占位符必须和@PathVariable包裹的参数一致_。如果@PathVariable中没有给定参数，那么将默认使用入参的册数参数名。即可以使用下面的方法：\n\n```java\n@RequestMapping(value=\"/{spittleId}\", method=RequestMethod.GET)\npublic String spittle(\n        @PathVariable long spittleId,\n        Model model\n        ) {\n    model.addAttribute(spittleRepository.findOne(spittleId));\n    return \"spittle\";\n}\n```\n\nspittle()方法会将接收的参数值传递给spittleRepository的findOne()方法并查找到一个Spittle，并将其放置到model中，model的key值会是spittle，接下来就可以在视图中引用这个Spittle：\n\n```html\n<div class=\"spittleView\">\n    <div class=\"spittleMessage\">\n        <c:out value=\"${spittle.message}\" />\n    </div>\n    <div>\n        <span class=\"spittleTime\"><c:out value=\"${spittle.time}\" /></span>\n    </div>\n</div>\n```\n\n查询参数和路径参数可以处理一些少量的请求数据，但是当请求数据过大时，它们就不再适用，下面就来讲解一下如何处理表单数据。\n\n# 处理表单\n\nWeb应用不仅仅是将内容推送给用户，它同时也会让用户填写表单并将数据提交给应用。\n\n对于表单有两种处理方式：展示表单以及处理用户提交的表单数据。在Spittr中，需要提供一个供新用户进行注册的表单。\n\n`SpitterController`：展示用户注册表单\n\n```java\npackage spittr.web;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\n@Controller\n@RequestMapping(\"/spitter\")\npublic class SpitterController {\n\n    // 处理来自/spitter/register的get请求\n    @RequestMapping(value = \"/register\", method = RequestMethod.GET)\n    public String showRegistrationForm() {\n        return \"registerForm\";\n    }\n\n}\n```\n\n`showRegistrationForm`方法的`@RequestMapping`注解，以及类级别的注解`@RequestMapping`，表明了这个方法会处理来自/spitter/register的get请求，该方法仅仅返回了一个名为registerForm的逻辑视图。根据之前在`InternalResourceViewResolver`中的配置，这个逻辑视图会导向到`/WEB-INF/views/registerForm.jsp`该界面。\n\n对应的测试方法：\n\n```java\npackage spittr.web;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;\nimport static org.springframework.test.web.servlet.setup.MockMvcBuilders.*;\n\nimport org.junit.Test;\nimport org.springframework.test.web.servlet.MockMvc;\n\npublic class SpitterControllerTest {\n\n    @Test\n    public void shouldShowRegistration() throws Exception {\n        SpitterController controller = new SpitterController();\n        MockMvc mockMvc = standaloneSetup(controller).build();\n        mockMvc.perform(get(\"/spitter/register\")).andExpect(view().name(\"registerForm\"));\n    }\n}\n```\n\n也可以通过启动项目访问界面的方式验证：\n\n```html\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\n<%@ page session=\"false\" %>\n<html>\n  <head>\n    <title>Spitter</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"<c:url value=\"/resources/style.css\" />\" >\n  </head>\n  <body>\n    <h1>Register</h1>\n\n    <form method=\"POST\">\n      First Name: <input type=\"text\" name=\"firstName\" /><br/>\n      Last Name: <input type=\"text\" name=\"lastName\" /><br/>\n      Username: <input type=\"text\" name=\"username\" /><br/>\n      Password: <input type=\"password\" name=\"password\" /><br/>\n      <input type=\"submit\" value=\"Register\" />\n    </form>\n  </body>\n</html>\n```\n\n![该界面提供了用户注册的功能](http://hoxis-github-io.qiniudn.com/160215-spring-in-action-rigister.png)\n\n接下来需要对提交的表单进行处理。\n\n## 编写表单处理控制器\n\n在处理POST请求时，控制器需要接受表单数据并且将这些数据存储为一个Spitter对象。为了避免重复提交，应该重定向到一个新的界面：用户信息页。在处理post请求时，一个聪明的做法就是在处理完成后发送一个重定向的请求，从而可以避免重复提交。\n\n下面来实现控制器方法，从而可以处理注册请求。\n\n```java\n    private SpitterRepository spitterRepository;\n\n    public SpitterController() {\n    }\n\n    // 注入SpitterRepository\n    @Autowired\n    public SpitterController(SpitterRepository spitterRepository) {\n        this.spitterRepository = spitterRepository;\n    }\n\n    public String processRegistration(Spitter spitter) {\n        // 保存Spitter\n        spitterRepository.save(spitter);\n        // 重定向到新的页面\n        return \"redirect:/spitter/\" + spitter.getUsername();\n    }\n````\nprocessRegistration方法使用Spitter对象作为入参，该对象的属性会从请求中填充。该方法中调用了spitterRepository的save方法对Spitter对象进行存储。最后返回了一个带有`redirect:`的字符串。\n\n当InternalResourceViewResolver遇到`redirect:`时，它会自动地将其当做一个重定向请求，从而可以重定向到用户详情页面，如/spitter/xiaoming。\n\n同时，InternalResourceViewResolver也可以识别前缀`forward:`，这种情况下，请求会被转向到给定的URL地址。\n\n下面需要编写处理处理用户详情页面的方法：\n\n<div class=\"se-preview-section-delimiter\"></div>\n\n```java\n    @RequestMapping(value = \"/{username}\", method = RequestMethod.GET)\n    public String showSpitterProfile(@PathVariable(\"username\") String username, Model model) {\n        Spitter spitter = spitterRepository.findByUsername(username);\n        model.addAttribute(spitter);\n        return \"profile\";\n    }\n```\n\n## 参数校验\n\n从Spring3.0开始，Spring支持Java校验api，从而可以从而可以不需要添加其他配置，仅仅需要有一个Java API 的实现，如Hibernate Validator。\n\nJava Validation API定义了许多注解，可以使用这些注解来约束参数的值，所有的注解都在包`javax.validation.constraints`中。\n\n| 注解 | 描述 |\n| --- | --- |\n| @AssertFalse（@AssertTrue） | 对象必须是布尔类型，并且必须为false（true） |\n| @DecimalMax(value)、@DecimalMin(value) | 限制对象必须是一个数字，其值不大于（不小于）指定的BigDecimalString值 |\n| @Digits(integer,fraction) | 对象必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction |\n| @Future | 必须是一个将来的日期 |\n| @Max(value)、@Min(value) | 必须为一个不大于（不小于）指定值的数字 |\n| @NotNull | 限制对象不能为空 |\n| @Null | 限制对象必须为空 |\n| @Past | 必须是一个过去的日期 |\n| @Pattern(value) | 必须符合指定的正则表达式 |\n| @Size(min,max) | 限制字符长度必须在min到max之间 |\n\n使用示例：\n\n```java\npublic class Spitter {\n\n    private Long id;\n\n    @NotNull\n    @Size(min = 5, max = 16)\n    private String username;\n\n    @NotNull\n    @Size(min = 5, max = 25)\n    private String password;\n\n    @NotNull\n    @Size(min = 2, max = 30)\n    private String firstName;\n\n    ...\n```\n\n既然已经对Spitter的参数添加了约束，那么就需要改动processRegistration方法来应用校验：\n\n```java\n    @RequestMapping(value = \"/register\", method = RequestMethod.POST)\n    public String processRegistration(@Valid Spitter spitter, Errors errors) {\n        // 若校验中出现错误，那么就返回到注册界面\n        if (errors.hasErrors()) {\n            return \"registerForm\";\n        }\n        // 保存Spitter\n        spitterRepository.save(spitter);\n        // 重定向到新的页面\n        return \"redirect:/spitter/\" + spitter.getUsername();\n    }\n```\n\n# 总结\n\n这一章比较适合Spring MVC的入门学习资料。主要涵盖了Spring MVC处理web请求的处理过程、如何写简单的控制器和控制器方法来处理Http请求、如何使用mockito框架测试控制器方法。\n\n基于Spring MVC的应用有三种方式读取数据：查询参数、路径参数和表单输入。本章用两节介绍了这些内容，并给出了类似错误处理和参数验证等关键知识点。\n\n由于缺少真正的入库操作，因此本章节的一些方法不能真正的运作。\n\n在接下来的章节中，我们会对Spring视图进行深入了解，对如何在JSP页面中使用Spring标签库进行展开。"]],[48,48],[26283,26283]]],[1573132583097,["GJX@GJXAIOU",[[1,129,"##"]],[130,130],[144,144]]],[1573132586083,["GJX@GJXAIOU",[[1,132,"（"],[-1,6226," "],[1,6227," "],[-1,16518," "],[1,16519," "],[-1,16556," "],[1,16557," "]],[132,132],[133,133]]],[1573132586226,["GJX@GJXAIOU",[[1,133,"）"]],[133,133],[134,134]]],[1573132588286,["GJX@GJXAIOU",[[1,133,"一"]],[133,133],[134,134]]],[1573132596112,["GJX@GJXAIOU",[[1,151,"##"]],[150,150],[168,168]]],[1573132602307,["GJX@GJXAIOU",[[-1,26,"一、"]],[28,28],[26,26]]],[1573132605051,["GJX@GJXAIOU",[[1,26,"章为："]],[26,26],[29,29]]],[1573132605853,["GJX@GJXAIOU",[[-1,27,"为："]],[29,29],[27,27]]],[1573132608780,["GJX@GJXAIOU",[[1,27,"五："]],[27,27],[29,29]]],[1573132612977,["GJX@GJXAIOU",[[-1,133,"（一）"]],[133,136],[133,133]]],[1573132614215,["GJX@GJXAIOU",[[1,133,"=一 "]],[133,133],[135,135]]],[1573132615653,["GJX@GJXAIOU",[[-1,131,"#=一 "]],[135,135],[131,131]]],[1573132617563,["GJX@GJXAIOU",[[1,131,"#"]],[131,131],[145,145]]],[1573132622970,["GJX@GJXAIOU",[[1,133,"一 "]],[133,133],[134,134]]],[1573132623349,["GJX@GJXAIOU",[[1,134,"、"]],[134,134],[135,135]]],[1573132626646,["GJX@GJXAIOU",[[1,155,"（）"]],[155,155],[157,157]]],[1573132628423,["GJX@GJXAIOU",[[1,156,"一"]],[156,156],[157,157]]],[1573132643391,["GJX@GJXAIOU",[[1,149,"基于模型- 事务"]],[149,149],[157,157]]],[1573132644548,["GJX@GJXAIOU",[[-1,155,"事务"]],[157,157],[155,155]]],[1573132654016,["GJX@GJXAIOU",[[1,155,"视图-控制（）"]],[155,155],[162,162]]],[1573132656997,["GJX@GJXAIOU",[[1,161,"MVC"]],[161,161],[164,164]]],[1573132676427,["GJX@GJXAIOU",[[1,166,"\n"]],[166,166],[167,167]]],[1573132843653,["GJX@GJXAIOU",[[1,166,"审批唐"]],[166,166],[169,169]]],[1573132847914,["GJX@GJXAIOU",[[-1,166,"审批唐"]],[169,169],[166,166]]],[1573132848681,["GJX@GJXAIOU",[[-1,166,"\n"]],[166,166],[165,165]]],[1573132849403,["GJX@GJXAIOU",[[1,166,"\n"]],[165,165],[166,166]]],[1573132872437,["GJX@GJXAIOU",[[1,166,"spring 将请求在调度 Servlet、处理器映射（）"]],[166,166],[195,195]]],[1573132878719,["GJX@GJXAIOU",[[1,194,"handler Mapping"]],[194,194],[209,209]]],[1573132881878,["GJX@GJXAIOU",[[1,210,"。"]],[210,210],[211,211]]],[1573132882828,["GJX@GJXAIOU",[[-1,210,"。"]],[211,211],[210,210]]],[1573132884551,["GJX@GJXAIOU",[[1,210,"。"]],[210,210],[211,211]]],[1573132885218,["GJX@GJXAIOU",[[-1,210,"。"]],[211,211],[210,210]]],[1573132900726,["GJX@GJXAIOU",[[1,210,"、控制器以及视图解析器（）"]],[210,210],[223,223]]],[1573132921783,["GJX@GJXAIOU",[[1,222,"view resolver "]],[222,222],[236,236]]],[1573132929175,["GJX@GJXAIOU",[[1,237,"之间移动。"]],[237,237],[242,242]]],[1573132998377,["GJX@GJXAIOU",[[1,243,"\n"]],[243,243],[244,244]]],[1573132999714,["GJX@GJXAIOU",[[1,268,"\n"]],[267,267],[268,268]]],[1573133011519,["GJX@GJXAIOU",[[1,268,"![spring 处理请求过程]($resource/spring%20%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.png)"]],[268,268],[364,364]]],[1573133015144,["GJX@GJXAIOU",[[-1,364,"!["]],[364,366],[364,364]]],[1573133015620,["GJX@GJXAIOU",[[1,364,"\n"]],[364,364],[365,365]]],[1573133054297,["GJX@GJXAIOU",[[-1,365,"请求会由DispatcherServlet分配给控制器（根据处理器映射来确定），在控制器完成处理后，接着请求会被发送给一个视图来呈现结果](http://hoxis-github-io.qiniudn.com/160118-spring-in-action-5.1.png)"]],[433,502],[365,365]]],[1573133056129,["GJX@GJXAIOU",[[1,267,"请求会由DispatcherServlet分配给控制器（根据处理器映射来确定），在控制器完成处理后，接着请求会被发送给一个视图来呈现结果"]],[267,267],[335,335]]],[1573133060564,["GJX@GJXAIOU",[[-1,434,"\n"]],[434,434],[433,433]]],[1573133061120,["GJX@GJXAIOU",[[-1,433,"\n"]],[433,433],[432,432]]],[1573133083943,["GJX@GJXAIOU",[[1,433,"- "]],[433,433],[435,435]]],[1573133088872,["GJX@GJXAIOU",[[1,480,"- "]],[480,480],[482,482]]],[1573133130093,["GJX@GJXAIOU",[[1,572,"**"],[1,608,"**"]],[572,608],[572,612]]],[1573133135291,["GJX@GJXAIOU",[[1,654,"- "]],[654,654],[656,656]]],[1573133224642,["GJX@GJXAIOU",[[1,939,"**"],[1,980,"**"]],[939,980],[939,984]]],[1573133233925,["GJX@GJXAIOU",[[1,855,"- "]],[855,855],[857,857]]],[1573133237169,["GJX@GJXAIOU",[[1,990,"- "]],[990,990],[992,992]]],[1573133838108,["GJX@GJXAIOU",[[1,1073,"---"]],[1073,1073],[1076,1076]]],[1573133858688,["GJX@GJXAIOU",[[1,1139,"- "]],[1139,1139],[1141,1141]]],[1573133897386,["GJX@GJXAIOU",[[1,1182,"**"],[1,1219,"**"]],[1182,1219],[1182,1223]]],[1573133902669,["GJX@GJXAIOU",[[1,1226,"- "]],[1226,1226],[1228,1228]]],[1573133927197,["GJX@GJXAIOU",[[1,1373,"- "]],[1373,1373],[1375,1375]]],[1573133969210,["GJX@GJXAIOU",[[1,1503,"##"]],[1504,1504],[1518,1518]]],[1573133971781,["GJX@GJXAIOU",[[1,1506,"（）"]],[1506,1506],[1508,1508]]],[1573133973160,["GJX@GJXAIOU",[[1,1507,"二"]],[1507,1507],[1508,1508]]],[1573133990450,["GJX@GJXAIOU",[[-1,1523,"### "]],[1523,1527],[1523,1523]]],[1573133991163,["GJX@GJXAIOU",[[1,1523,"- "]],[1523,1523],[1525,1525]]],[1573134163634,["GJX@GJXAIOU",[[1,1578,"**"],[1,1593,"**"]],[1578,1593],[1578,1597]]],[1573134242456,["GJX@GJXAIOU",[[-1,1667,"种"]],[1668,1668],[1667,1667]]],[1573134243540,["GJX@GJXAIOU",[[1,1667,"中"]],[1667,1667],[1668,1668]]],[1573134260914,["GJX@GJXAIOU",[[1,2236,"**"],[1,2274,"**"]],[2236,2274],[2236,2278]]],[1573134271289,["GJX@GJXAIOU",[[-1,2221,"适"]],[2222,2222],[2221,2221]]],[1573134274412,["GJX@GJXAIOU",[[1,2221,"使"]],[2221,2221],[2222,2222]]],[1573134277641,["GJX@GJXAIOU",[[1,2218,"****"]],[2218,2218],[2220,2220]]],[1573134280199,["GJX@GJXAIOU",[[1,2220,"这里不是"]],[2220,2220],[2224,2224]]],[1573134281629,["GJX@GJXAIOU",[[-1,2222,"不是"]],[2224,2224],[2222,2222]]],[1573134288847,["GJX@GJXAIOU",[[1,2222,"不使用 web.xml  配置"]],[2222,2222],[2237,2237]]],[1573134292668,["GJX@GJXAIOU",[[1,2239,"："]],[2239,2239],[2240,2240]]],[1573134321370,["GJX@GJXAIOU",[[1,2612,"\n    "]],[2607,2607],[2612,2612]]],[1573134322212,["GJX@GJXAIOU",[[1,2612,"、、"]],[2612,2612],[2614,2614]]],[1573134323319,["GJX@GJXAIOU",[[-1,2612,"、、"]],[2614,2614],[2612,2612]]],[1573134324533,["GJX@GJXAIOU",[[1,2612,"//"]],[2612,2612],[2614,2614]]],[1573134325365,["GJX@GJXAIOU",[[-1,2612,"//"]],[2614,2614],[2612,2612]]],[1573134345723,["GJX@GJXAIOU",[[1,2612,"    // 将 DispatcherServlet 映射到： "]],[2612,2612],[2644,2644]]],[1573134346794,["GJX@GJXAIOU",[[-1,2643," "]],[2644,2644],[2643,2643]]],[1573134348540,["GJX@GJXAIOU",[[1,2643,"··"]],[2643,2643],[2645,2645]]],[1573134349550,["GJX@GJXAIOU",[[-1,2643,"··"]],[2645,2645],[2643,2643]]],[1573134350250,["GJX@GJXAIOU",[[1,2643,"、"]],[2643,2643],[2644,2644]]],[1573134351466,["GJX@GJXAIOU",[[-1,2643,"、"]],[2644,2644],[2643,2643]]],[1573134352333,["GJX@GJXAIOU",[[1,2643,"/"]],[2643,2643],[2644,2644]]],[1573134443466,["GJX@GJXAIOU",[[1,2943,"****"]],[2943,2943],[2945,2945]]],[1573134444999,["GJX@GJXAIOU",[[1,2945,"从 "]],[2945,2945],[2947,2947]]],[1573134452009,["GJX@GJXAIOU",[[1,2947,"类名： SpittrWebAppInitializer"]],[2947,2947],[2974,2974]]],[1573134456223,["GJX@GJXAIOU",[[1,2976,"，的值"]],[2976,2976],[2979,2979]]],[1573134456962,["GJX@GJXAIOU",[[-1,2977,"的值"]],[2979,2979],[2977,2977]]],[1573134475131,["GJX@GJXAIOU",[[1,2977,"得知要创建的应用名为：Spitter；"]],[2977,2977],[2996,2996]]],[1573134488106,["GJX@GJXAIOU",[[1,2997,"\n"]],[2997,2997],[2998,2998]]],[1573134512768,["GJX@GJXAIOU",[[-1,3064,"用来"]],[3066,3066],[3064,3064]]],[1573134522341,["GJX@GJXAIOU",[[1,3083,"和"]],[3083,3083],[3084,3084]]],[1573134522570,["GJX@GJXAIOU",[[1,3083," "]],[3084,3084],[3085,3085]]],[1573134530614,["GJX@GJXAIOU",[[1,3085," Spring 引用"]],[3085,3085],[3095,3095]]],[1573134532226,["GJX@GJXAIOU",[[-1,3093,"引用"]],[3095,3095],[3093,3093]]],[1573134550301,["GJX@GJXAIOU",[[1,3093,"应用上下文（）"]],[3093,3093],[3100,3100]]],[1573134559413,["GJX@GJXAIOU",[[1,3099,"Spring 的引用"]],[3099,3099],[3109,3109]]],[1573134561025,["GJX@GJXAIOU",[[-1,3107,"引用"]],[3109,3109],[3107,3107]]],[1573134563848,["GJX@GJXAIOU",[[1,3107,"应用"]],[3107,3107],[3109,3109]]],[1573134579605,["GJX@GJXAIOU",[[1,3109,"上下文会位于引用"]],[3109,3109],[3117,3117]]],[1573134581013,["GJX@GJXAIOU",[[-1,3115,"引用"]],[3117,3117],[3115,3115]]],[1573134605847,["GJX@GJXAIOU",[[1,3115,"应用程序的 Servlet 上下文中"]],[3115,3115],[3133,3133]]],[1573134658268,["GJX@GJXAIOU",[[1,3195,"\n"]],[3194,3194],[3195,3195]]],[1573134661211,["GJX@GJXAIOU",[[1,3194,"因为 "]],[3194,3194],[3197,3197]]],[1573134663954,["GJX@GJXAIOU",[[-1,3196," "]],[3197,3197],[3196,3196]]],[1573134685837,["GJX@GJXAIOU",[[1,3196,"容器会在类路径中查找实现 javax.servle"]],[3196,3196],[3221,3221]]],[1573134690143,["GJX@GJXAIOU",[[1,3221,"t.SEr"]],[3221,3221],[3226,3226]]],[1573134691554,["GJX@GJXAIOU",[[-1,3224,"Er"]],[3226,3226],[3224,3224]]],[1573134715787,["GJX@GJXAIOU",[[1,3224,"ervletContainerInitializer Jiek"]],[3224,3224],[3255,3255]]],[1573134718076,["GJX@GJXAIOU",[[-1,3251,"Jiek"]],[3255,3255],[3251,3251]]],[1573134742029,["GJX@GJXAIOU",[[1,3251,"接口的类，如果发现就用它配置 Servlet 容器，而"]],[3251,3251],[3278,3278]]],[1573134755557,["GJX@GJXAIOU",[[1,3194,"上面那段的原理："]],[3194,3194],[3202,3202]]],[1573134783911,["GJX@GJXAIOU",[[1,3286," Spring 中提供了该井口"]],[3286,3286],[3301,3301]]],[1573134784756,["GJX@GJXAIOU",[[-1,3299,"井口"]],[3301,3301],[3299,3299]]],[1573134806293,["GJX@GJXAIOU",[[1,3299,"接口的实现，名为：SpringServlet"]],[3299,3299],[3321,3321]]],[1573134846287,["GJX@GJXAIOU",[[1,3321,"ContainerInitializer，该类优惠"]],[3321,3321],[3346,3346]]],[1573134847046,["GJX@GJXAIOU",[[-1,3344,"优惠"]],[3346,3346],[3344,3344]]],[1573134863196,["GJX@GJXAIOU",[[1,3344,"又会查找实现 WebApplication"]],[3344,3344],[3365,3365]]],[1573134891422,["GJX@GJXAIOU",[[1,3365,"Initializer 的类，并将配置的任务交给他们是"]],[3365,3365],[3392,3392]]],[1573134893104,["GJX@GJXAIOU",[[-1,3391,"是"]],[3392,3392],[3391,3391]]],[1573134906288,["GJX@GJXAIOU",[[1,3391,"实现，Spring 32."]],[3391,3391],[3404,3404]]],[1573134908037,["GJX@GJXAIOU",[[-1,3402,"2."]],[3404,3404],[3402,3402]]],[1573134909287,["GJX@GJXAIOU",[[1,3402,"。2 "]],[3402,3402],[3405,3405]]],[1573134910972,["GJX@GJXAIOU",[[-1,3401,"3。2 "]],[3405,3405],[3401,3401]]],[1573134912563,["GJX@GJXAIOU",[[1,3401,"3."]],[3401,3401],[3403,3403]]],[1573134913133,["GJX@GJXAIOU",[[-1,3402,"."]],[3403,3403],[3402,3402]]],[1573134914296,["GJX@GJXAIOU",[[1,3402,"。2"]],[3402,3402],[3404,3404]]],[1573134915035,["GJX@GJXAIOU",[[-1,3402,"。2"]],[3404,3404],[3402,3402]]],[1573134916173,["GJX@GJXAIOU",[[1,3402,"。"]],[3402,3402],[3403,3403]]],[1573134917299,["GJX@GJXAIOU",[[-1,3401,"3。"]],[3403,3403],[3401,3401]]],[1573134921439,["GJX@GJXAIOU",[[1,3401,"3.2 zhong "]],[3401,3401],[3411,3411]]],[1573134925415,["GJX@GJXAIOU",[[-1,3405,"zhong "]],[3411,3411],[3405,3405]]]],null,"GJX@GJXAIOU"]]}