{"compress":true,"commitItems":[["e2a171c8-0e36-4741-853b-a617df1898b4",1564120043219,"",[[1564119997305,["GJX@GJXAIOU",[[1,0,"# Java中final关键字使用\n\n\n\n"]],[0,0],[20,20]]],[1564120001702,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1564120003048,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1564120003186,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1564120004751,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1564120004773,["GJX@GJXAIOU",[[1,4,"\n---\n\n"]],[3,3],[4,4]]],[1564120005135,["GJX@GJXAIOU",[[1,5,"\n"]],[4,4],[5,5]]],[1564120012159,["GJX@GJXAIOU",[[1,5,"flag: red"]],[5,5],[14,14]]],[1564120013807,["GJX@GJXAIOU",[[-1,4,"\n"]],[4,4],[3,3]]],[1564120050953,["GJX@GJXAIOU",[[1,14,"\n"]],[13,13],[14,14]]],[1564120057658,["GJX@GJXAIOU",[[1,14,"tags: "]],[14,14],[20,20]]],[1564120058314,["GJX@GJXAIOU",[[1,21,"\n"]],[20,20],[21,21]]],[1564120085921,["GJX@GJXAIOU",[[1,21,"- finalguan"]],[21,21],[32,32]]],[1564120086782,["GJX@GJXAIOU",[[-1,28,"guan"]],[32,32],[28,28]]],[1564120091284,["GJX@GJXAIOU",[[1,28,"关键字"]],[28,28],[31,31]]],[1564120112313,["GJX@GJXAIOU",[[1,57,"final在平时开发过程中是常常看见的，但是感觉对它是熟悉又陌生。今天来看看final究竟是什么。final，顾名思义，即最终、不可变。在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。final方法在编译阶段绑定，称为静态绑定(static binding)。\n\n**一、修饰类** \n\n当一个类的整体定义为final时候，表明这个类不能被继承，比如java中的String类。但是注意的是final类中的所有成员方法都会被隐式地指定为final方法。这个很容易。\n\n**二、方法**\n\n当一个方法修饰为final的时候，意味着把该方法锁定，以防任何继承类修改它的含义。因此，如果只有明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。还有就是，类的private方法会隐式地被指定为final方法。代码如下：\n\n```\nclass WithFinals {    private final void f() {        System.out.println(\"WithFinals.f()\");    }    private void g() {        System.out.println(\"WithFinals.g()\");    }    public final void h() {        System.out.println(\"WithFinals.h()\");    }}public class OverridingPrivate extends WithFinals {//    public void h() {//        System.out.println(\"OverridingPrivate.h()\");//    }//    @Override    public void g() {        System.out.println(\"OverridingPrivate.g()\");    }//    @Override    public void f() {        System.out.println(\"OverridingPrivate.f()\");    }}\n```\n\n如果把上面三处注释地方去掉，代码编译不通过，下面分析一下编译不通过的原因。第一个地方方法h()编译不通过，因为父类h() 方法修饰符为final不能通过编译。\n\n第二个地方是g()上面的注解编译不通过，是因为父类发g()方法是修饰为private，这正如上面讲的类的private方法会隐式地被指定为final方法，但是跟final又不同，去掉@Override却编译通过，这是因为“覆盖”只有在某个方法是基类的一部分才会出现。即，必须能将一个对象向上转型为它的基本类型并调用相同的方法。如果方法为private，它就不是基类的一部分，它是隐藏于类中的程序代码，只不过有相同的名称。如果方法为public、protected或包访问权限方法的话，就不会产生在基类中出现的\"仅具有相同的名称\"。所以子类的g（）是一个新的方法，这其实与final关系不大；\n\n第三个地方是f()上面的注解不能编译通过,去掉@Override也是正常编译通过的，所以这也能间接证明private 方法其实是否是final没有多大联系。\n\n**三、变量**\n\n对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。引用变量被final修饰之后，虽然不能再指向其他对象，但是它指向的对象的内容是可变的。撸个代码：\n\n```\nclass Value {    int i;    public Value(int i) {        this.i = i;    }}public class FinalData {    private static Random rand = new Random(47);    private String id;    public FinalData(String id) {        this.id = id;    }    private final int valueOne = 9;    private static final int VALUE_TWO = 99;    private final int i4 = rand.nextInt(20);    static final int INT_5 = rand.nextInt(20);    private Value v1 = new Value(11);    private final Value v2 = new Value(22);    private static final Value VAL_3 = new Value(33);    @Override    public String toString() {        return id + \": \" + \"i4 = \" + i4 + \", INT_5 = \" + INT_5;    }    public static void main(String[] args) {        FinalData fd1 = new FinalData(\"fd1\");        // fd1.valueOne++; // Error        fd1.v2.i++;        fd1.v1 = new Value(9);        // fd1.v2 = new Value(0); // Error        // fd1.VAL_3 = new Value(1); // Error        System.out.println(fd1);        System.out.println(\"Creating new FinalData\");        FinalData fd2 = new FinalData(\"fd2\");        System.out.println(fd1);        System.out.println(fd2);    }}\n```\n\n一个个分析， 我们知道static强调唯一，而final强调常量，valueOne和VALUE_TWO 都是编译常量，区别就是VALUE_TWO在存储空间是唯一的，以及赋值阶段不同。\n\n对于i4 和INT_5展示了将final数值定义为静态和非静态的区别。看一下上面代码编译后的情况，如下面的图：\n\n![](https://mmbiz.qpic.cn/mmbiz_png/IibUVnJ665Wq9501E22D8RBpFicNPacxSO76xYruFLL03l6WKjLXkiclEnjPj6eKCTHsOX9KcFOZs4V5xweGmAxmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n图一\n\n编译之后i4到构造器中，而INT_5在static代码块中，可以看出i4在创建实列变量的时候被赋值，而INT_5在类加载过程准备阶段就赋值了(注意static且非final是在初始化阶段被赋值的)，还有一点valueOne并不在构造器中，这是因为valueOne是基本类型。另外在fd1和fd2中发现i4的值是唯一的（相对于对象而言），INT_5也是一样的（相对于类而言）。\n\nv1到VAl_3中，不能因为v2是final的，就 认为v2的值不可以改变。从代码的第37行可以看出，v2的值是可以改变的，这是因为这是一个引用，但是无法将v2再次指向新的引用。这对数组具有同样的意义，数组不过是另一种引用。\n\n**四、进阶**\n\n**1.空白final**\n\n空白final是指声明为final但又未给初值的变量。编译器确保空白的final在使用前必须初始化。代码如下\n\n```\nclass Poppet {    private int i;    Poppet(int ii) {        i = ii;    }}public class BlankFinal {    private final int i = 0;    private final int j;    private final Poppet p;    public BlankFinal() {        j = 1;        p = new Poppet(1);    }}\n```\n\ni和p均没有值 ，这跟static不一样，static非final会在类加载阶段的准备阶段会被赋予类型初始值，即 static修饰的 j在准备阶段为0，static修饰的 p为null，而空白final不会。如果BlankFinal构造函数里的两行的代码注释掉会编译不通过。\n\n**2.final局部变量**\n\n废话不多说，撸一把代码\n\n```\npublic class FinalTest {    private int g1 = 127;    private int g2 = 128;    private int g3 = 32767;    private int g4 = 32768;    public static void main(String[] args) {        int n1 = 2019;        final int n2 = 2019;        String s = \"20190718\";        String s1 = n1 + \"0718\";        String s2 = n2 + \"0718\";        System.out.println(s == s1); //false        System.out.println(s == s2); //true    }}\n```\n\n上面的类变量g1-g4先不要管，下面会解释其中的用意。运行结果发现第一个打印的是false，第二个是true，下面分析原因，先看一下编译之后的结果：\n\n![](https://mmbiz.qpic.cn/mmbiz_png/IibUVnJ665Wq9501E22D8RBpFicNPacxSO57icEI8ian6ianbtdaW4IaEShjp5EFcoHWutEDS7tcibwqlmSNw2MCibr5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n         图二\n\n图二中，发现很有意思的事情，n1编译之后为short类型了,n2编译之后为boolean类型了，这个其实算是编译器优化了，为每个常量选择合适的类型，这样可以减少虚拟机的内存空间，对于final局部常量来说对运行期是没有影响的（局部变量和字段（实类变量、类变量）是有区别，它在常量池是没有Fieldref符号引用，自然没有访问标志信息，因此将局部声明为final对运行期是没有影响的），非0的时候编译之后为true，0的时候为false；\n\n接下来发现s与s2的是一样的，即在常量池中的位置是同一个位置，字符索引是同一个，说白了就是内存中同一个值，所以就很好的解释为什么s==s2是true。对于s1来说，其实是通过StringBuilder类把n1和“0718”相加的，直接来证明一下，如下图反编译之后的结果来看：\n\n![](https://mmbiz.qpic.cn/mmbiz_png/IibUVnJ665Wq9501E22D8RBpFicNPacxSO47kbH5Q6al8GicGA7cu1AiakhQbjn2lynLyAHkgIfedicv1IdQDEKodzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n图三\n\n图三中，24行中看出是通过StringBuilder的append进行相加的，然后通过StringBuilder的toString方法获取值，这就解释了s==s1为false的原因。\n\n下面是扩展内容，接下来解释g1-g4的用途,先看一下g1-g4常量池的情况\n\n![](https://mmbiz.qpic.cn/mmbiz_png/IibUVnJ665Wq9501E22D8RBpFicNPacxSOV6cR8iaJWcUjDkgMIymbWhKvbSK1vmkjbKQqvWZNwVRqzGRwUFLPmPQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n图四\n\n上面是编译后的部分截图，了解常量池的朋友从图中#5知道32768是在常量池的，但是127、128、32767不再常量池，那再哪里呢，再看反编译片段。\n\n![](https://mmbiz.qpic.cn/mmbiz_png/IibUVnJ665Wq9501E22D8RBpFicNPacxSOjmpEQWVI7FicMTCxD1FsVFj6K91BPvSJrCKeGaEzib0ffoURAlAI88Xw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n图五\n\n发现127是由bipush送至栈顶，而128和32767送至栈顶的sipush送至栈顶，\n\n这两个命令是是什么意思？\n\nbipush:将单字节常量（-128~127）推送至栈顶\n\nsipush:将一个短整型常量值（-32768~32767）推送至栈顶\n\n相当于虚拟机缓存了-32768~32767的数值，不需要在常量池定义了，类比于Integer类，Integer会缓存-128~127，超过了这个范围则从新生成Integer对象 。"]],[57,57],[5886,5886]]],[1564120129447,["GJX@GJXAIOU",[[1,207,"## "]],[207,207],[220,220]]],[1564120131153,["GJX@GJXAIOU",[[1,220,"****"]],[220,220],[222,222]]],[1564120133562,["GJX@GJXAIOU",[[-1,210,"**"],[-1,217,"**"]],[211,211],[210,215]]],[1564120135953,["GJX@GJXAIOU",[[1,220,"****"]],[220,220],[222,222]]],[1564120138576,["GJX@GJXAIOU",[[-1,216,"********"]],[216,224],[216,216]]],[1564120141039,["GJX@GJXAIOU",[[-1,308,"**"],[-1,314,"**"]],[312,312],[308,312]]],[1564120142567,["GJX@GJXAIOU",[[1,308,"## "]],[308,312],[315,315]]],[1564120162980,["GJX@GJXAIOU",[[1,440,"<p style=\"margin-bottom: 10px;\">"],[-1,445," "],[1,446,"&nbsp;"],[-1,456," {    "],[1,462,"&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"],[-1,469," "],[1,470,"&nbsp;"],[-1,475," "],[1,476,"&nbsp;"],[-1,480," f() {        "],[1,494,"&nbsp;f()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"],[-1,531,"    }    "],[1,540,"&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;"],[-1,547," "],[1,548,"&nbsp;"],[-1,552," g() {        "],[1,566,"&nbsp;g()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"],[-1,603,"    }    "],[1,612,"&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;"],[-1,618," "],[1,619,"&nbsp;"],[-1,624," "],[1,625,"&nbsp;"],[-1,629," h() {        "],[1,643,"&nbsp;h()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"],[-1,680,"    "],[1,684,"&nbsp;&nbsp;&nbsp;&nbsp;"],[-1,692," "],[1,693,"&nbsp;"],[-1,698," "],[1,699,"&nbsp;"],[-1,716," "],[1,717,"&nbsp;"],[-1,724," "],[1,725,"&nbsp;"],[-1,735," {//    "],[1,743,"&nbsp;{//&nbsp;&nbsp;&nbsp;&nbsp;"],[-1,749," "],[1,750,"&nbsp;"],[-1,754," h() {//        "],[1,770,"&nbsp;h()&nbsp;{//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"],[-1,816,"    }//    "],[1,827,"&nbsp;&nbsp;&nbsp;&nbsp;}//&nbsp;&nbsp;&nbsp;&nbsp;"],[-1,836,"    "],[1,840,"&nbsp;&nbsp;&nbsp;&nbsp;"],[-1,846," "],[1,847,"&nbsp;"],[-1,851," g() {        "],[1,865,"&nbsp;g()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"],[-1,909,"    }//    "],[1,920,"&nbsp;&nbsp;&nbsp;&nbsp;}//&nbsp;&nbsp;&nbsp;&nbsp;"],[-1,929,"    "],[1,933,"&nbsp;&nbsp;&nbsp;&nbsp;"],[-1,939," "],[1,940,"&nbsp;"],[-1,944," f() {        "],[1,958,"&nbsp;f()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"],[-1,1002,"    "],[1,1006,"&nbsp;&nbsp;&nbsp;&nbsp;"],[1,1008,"</p>\n"]],[440,1008],[1700,1700]]],[1564120168207,["GJX@GJXAIOU",[[-1,440,"<p style=\"margin-bottom: 10px;\">class&nbsp;WithFinals&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;void&nbsp;f()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"WithFinals.f()\");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;g()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"WithFinals.g()\");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;final&nbsp;void&nbsp;h()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"WithFinals.h()\");&nbsp;&nbsp;&nbsp;&nbsp;}}public&nbsp;class&nbsp;OverridingPrivate&nbsp;extends&nbsp;WithFinals&nbsp;{//&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;h()&nbsp;{//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"OverridingPrivate.h()\");//&nbsp;&nbsp;&nbsp;&nbsp;}//&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;g()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"OverridingPrivate.g()\");&nbsp;&nbsp;&nbsp;&nbsp;}//&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;f()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"OverridingPrivate.f()\");&nbsp;&nbsp;&nbsp;&nbsp;}}</p>\n"]],[440,1700],[440,440]]],[1564120175904,["GJX@GJXAIOU",[[1,440,"class WithFinals {\n    private final void f() {\n        System.out.println(\"WithFinals.f()\");\n    }\n\n    private void g() {\n        System.out.println(\"WithFinals.g()\");\n    }\n\n    public final void h() {\n        System.out.println(\"WithFinals.h()\");\n    }\n}\n\n\npublic class OverridingPrivate extends WithFinals {\n//    public void h() {\n//        System.out.println(\"OverridingPrivate.h()\");\n//    }\n\n//    @Override\n    public void g() {\n        System.out.println(\"OverridingPrivate.g()\");\n    }\n\n//    @Override\n    public void f() {\n        System.out.println(\"OverridingPrivate.f()\");\n    }\n\n}"]],[440,440],[1038,1038]]],[1564120181142,["GJX@GJXAIOU",[[-1,215," "],[1,216," "],[-1,439,""],[1,439,"java"],[-1,1648," "],[1,1649," "],[-1,1654," {    int i;    "],[1,1670," {    int i;    "],[-1,1676," "],[1,1677," "],[-1,1686," i) {        "],[1,1699," i) {        "],[-1,1705," = i;    "],[1,1714," = i;    "],[-1,1722," "],[1,1723," "],[-1,1728," "],[1,1729," "],[-1,1738," {    "],[1,1744," {    "],[-1,1751," "],[1,1752," "],[-1,1758," "],[1,1759," "],[-1,1765," "],[1,1766," "],[-1,1770," = new "],[1,1777," = new "],[-1,1788,"    "],[1,1792,"    "],[-1,1799," "],[1,1800," "],[-1,1806," id;    "],[1,1814," id;    "],[-1,1820," "],[1,1821," "],[-1,1837," id) {        "],[1,1851," id) {        "],[-1,1858," = id;    }    "],[1,1873," = id;    }    "],[-1,1880," "],[1,1881," "],[-1,1886," int "],[1,1891," int "],[-1,1899," = 9;    "],[1,1908," = 9;    "],[-1,1915," "],[1,1916," "],[-1,1922," "],[1,1923," "],[-1,1928," int "],[1,1933," int "],[-1,1942," = 99;    "],[1,1952," = 99;    "],[-1,1959," "],[1,1960," "],[-1,1965," int i4 = "],[1,1975," int i4 = "],[-1,1992,"    "],[1,1996,"    "],[-1,2002," "],[1,2003," "],[-1,2008," int "],[1,2013," int "],[-1,2018," = "],[1,2021," = "],[-1,2038,"    "],[1,2042,"    "],[-1,2049," "],[1,2050," "],[-1,2055," v1 = new "],[1,2065," v1 = new "],[-1,2075,"    "],[1,2079,"    "],[-1,2086," "],[1,2087," "],[-1,2092," "],[1,2093," "],[-1,2098," v2 = new "],[1,2108," v2 = new "],[-1,2118,"    "],[1,2122,"    "],[-1,2129," "],[1,2130," "],[-1,2136," "],[1,2137," "],[-1,2142," "],[1,2143," "],[-1,2148," "],[1,2149," "],[-1,2154," = new "],[1,2161," = new "],[-1,2171,"    "],[1,2175,"    "],[-1,2184,"    "],[1,2188,"    "],[-1,2194," "],[1,2195," "],[-1,2201," "],[1,2202," "],[-1,2212," {        "],[1,2222," {        "],[-1,2228," id + \": \" + \"i4 = \" + i4 + \", "],[1,2259," id + \": \" + \"i4 = \" + i4 + \", "],[-1,2264," = \" + "],[1,2271," = \" + "],[-1,2277,"    }    "],[1,2286,"    }    "],[-1,2292," "],[1,2293," "],[-1,2299," "],[1,2300," "],[-1,2304," "],[1,2305," "],[-1,2318," "],[1,2319," "],[-1,2324," {        "],[1,2334," {        "],[-1,2343," fd1 = new "],[1,2354," fd1 = new "],[-1,2371,"        // "],[1,2382,"        // "],[-1,2397," // "],[1,2401," // "],[-1,2406,"        "],[1,2414,"        "],[-1,2425,"        "],[1,2433,"        "],[-1,2439," = new "],[1,2446," = new "],[-1,2455,"        // "],[1,2466,"        // "],[-1,2472," = new "],[1,2479," = new "],[-1,2488," // "],[1,2492," // "],[-1,2497,"        // "],[1,2508,"        // "],[-1,2517," = new "],[1,2524," = new "],[-1,2533," // "],[1,2537," // "],[-1,2542,"        "],[1,2550,"        "],[-1,2574,"        "],[1,2582,"        "],[-1,2610," new "],[1,2615," new "],[-1,2627,"        "],[1,2635,"        "],[-1,2644," fd2 = new "],[1,2655," fd2 = new "],[-1,2672,"        "],[1,2680,"        "],[-1,2704,"        "],[1,2712,"        "],[-1,2736,"    "],[1,2740,"    "],[-1,3473," "],[1,3474," "],[-1,3480," {    "],[1,3486," {    "],[-1,3493," int i;    "],[1,3504," int i;    "],[-1,3514," ii) {        i = ii;    "],[1,3539," ii) {        i = ii;    "],[-1,3547," "],[1,3548," "],[-1,3553," "],[1,3554," "],[-1,3564," {    "],[1,3570," {    "],[-1,3577," "],[1,3578," "],[-1,3583," int i = 0;    "],[1,3598," int i = 0;    "],[-1,3605," "],[1,3606," "],[-1,3611," int j;    "],[1,3622," int j;    "],[-1,3629," "],[1,3630," "],[-1,3635," "],[1,3636," "],[-1,3642," p;    "],[1,3649," p;    "],[-1,3655," "],[1,3656," "],[-1,3668," {        j = 1;        p = new "],[1,3700," {        j = 1;        p = new "],[-1,3710,"    "],[1,3714,"    "],[-1,3901," "],[1,3902," "],[-1,3907," "],[1,3908," "],[-1,3917," {    "],[1,3923," {    "],[-1,3930," int g1 = "],[1,3940," int g1 = "],[-1,3944,"    "],[1,3948,"    "],[-1,3955," int g2 = "],[1,3965," int g2 = "],[-1,3969,"    "],[1,3973,"    "],[-1,3980," int g3 = "],[1,3990," int g3 = "],[-1,3996,"    "],[1,4000,"    "],[-1,4007," int g4 = "],[1,4017," int g4 = "],[-1,4023,"    "],[1,4027,"    "],[-1,4033," "],[1,4034," "],[-1,4040," "],[1,4041," "],[-1,4045," "],[1,4046," "],[-1,4059," "],[1,4060," "],[-1,4065," {        int n1 = "],[1,4084," {        int n1 = "],[-1,4089,"        "],[1,4097,"        "],[-1,4102," int n2 = "],[1,4112," int n2 = "],[-1,4117,"        "],[1,4125,"        "],[-1,4131," s = "],[1,4136," s = "],[-1,4147,"        "],[1,4155,"        "],[-1,4161," s1 = n1 + "],[1,4172," s1 = n1 + "],[-1,4179,"        "],[1,4187,"        "],[-1,4193," s2 = n2 + "],[1,4204," s2 = n2 + "],[-1,4211,"        "],[1,4219,"        "],[-1,4239," == "],[1,4243," == "],[-1,4247," "],[1,4248," "],[-1,4255,"        "],[1,4263,"        "],[-1,4283," == "],[1,4287," == "],[-1,4291," "],[1,4292," "],[-1,4298,"    "],[1,4302,"    "],[-1,4568,"         "],[1,4577,"         "]],[439,439],[443,443]]],[1564120190503,["GJX@GJXAIOU",[[1,1235,"**"],[1,1291,"**"]],[1235,1291],[1235,1295]]],[1564120194235,["GJX@GJXAIOU",[[-1,1510,"**"],[-1,1516,"**"]],[1512,1512],[1510,1514]]],[1564120196081,["GJX@GJXAIOU",[[1,1510,"## "]],[1510,1514],[1517,1517]]],[1564120210027,["GJX@GJXAIOU",[[1,1663,"\n"],[1,1673,"\n"],[1,1698,"\n"],[1,1717,"\n"],[1,1722,"\n"],[1,1723,"\n\n\n"],[1,1747,"\n"],[1,1795,"\n"],[1,1817,"\n\n\n"],[1,1850,"\n"],[1,1871,"\n"],[1,1876,"\n\n"],[1,1911,"\n"],[1,1955,"\n\n"],[1,1999,"\n"],[1,2045,"\n\n"],[1,2082,"\n"],[1,2125,"\n"],[1,2178,"\n\n\n"],[1,2191,"\n"],[1,2221,"\n"],[1,2284,"\n"],[1,2289,"\n\n"],[1,2333,"\n"],[1,2378,"\n"],[1,2413,"\n"],[1,2432,"\n"],[1,2462,"\n\n"],[1,2504,"\n"],[1,2549,"\n"],[1,2581,"\n"],[1,2634,"\n"],[1,2679,"\n"],[1,2711,"\n"],[1,2743,"\n"],[1,2748,"\n"]],[1650,2749],[2796,2796]]],[1564120242751,["GJX@GJXAIOU",[[-1,2952,"![](https://mmbiz.qpic.cn/mmbiz_png/IibUVnJ665Wq9501E22D8RBpFicNPacxSO76xYruFLL03l6WKjLXkiclEnjPj6eKCTHsOX9KcFOZs4V5xweGmAxmw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)"]],[2952,3128],[2952,2952]]],[1564120252906,["GJX@GJXAIOU",[[1,2952,"![代码编译结果]($resource/%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C.jpg)"]],[2952,2952],[3032,3032]]],[1564120262990,["GJX@GJXAIOU",[[-1,3340,"**"],[-1,3346,"**"]],[3345,3345],[3340,3344]]],[1564120265392,["GJX@GJXAIOU",[[1,3340,"## "]],[3340,3340],[3347,3347]]],[1564120268006,["GJX@GJXAIOU",[[-1,3349,"**"],[-1,3360,"**"]],[3350,3350],[3349,3358]]],[1564120269375,["GJX@GJXAIOU",[[1,3349,"### "]],[3349,3358],[3362,3362]]],[1564120283861,["GJX@GJXAIOU",[[1,3438,"\n"],[1,3456,"\n\n"],[1,3476,"\n"],[1,3491,"\n"],[1,3496,"\n"],[1,3497,"\n\n"],[1,3522,"\n"],[1,3550,"\n"],[1,3574,"\n"],[1,3601,"\n\n"],[1,3626,"\n"],[1,3640,"\n"],[1,3666,"\n"],[1,3671,"\n\n"],[1,3672,"\n"]],[3424,3672],[3691,3691]]],[1564120291655,["GJX@GJXAIOU",[[1,3718,"**"],[1,3800,"**"]],[3718,3800],[3718,3804]]],[1564120295335,["GJX@GJXAIOU",[[-1,3840,"**"],[-1,3853,"**"]],[3843,3843],[3840,3851]]],[1564120296609,["GJX@GJXAIOU",[[1,3840,"### "]],[3840,3851],[3855,3855]]],[1564120307860,["GJX@GJXAIOU",[[1,3898,"\n"],[1,3923,"\n"],[1,3948,"\n"],[1,3975,"\n"],[1,4002,"\n\n\n"],[1,4046,"\n\n"],[1,4068,"\n"],[1,4096,"\n\n"],[1,4126,"\n"],[1,4158,"\n"],[1,4190,"\n\n"],[1,4234,"\n"],[1,4277,"\n\n"],[1,4282,"\n"],[1,4283,"\n"]],[3874,4283],[4304,4304]]],[1564120337270,["GJX@GJXAIOU",[[-1,4386,"![](https://mmbiz.qpic.cn/mmbiz_png/IibUVnJ665Wq9501E22D8RBpFicNPacxSO57icEI8ian6ianbtdaW4IaEShjp5EFcoHWutEDS7tcibwqlmSNw2MCibr5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n"]],[4385,4566],[4385,4385]]],[1564120345855,["GJX@GJXAIOU",[[1,4385,"![程序编译结果]($resource/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C.jpg)"]],[4385,4385],[4465,4465]]],[1564120348447,["GJX@GJXAIOU",[[-1,4467,"        "]],[4467,4475],[4467,4467]]],[1564120370343,["GJX@GJXAIOU",[[1,32,"\n"]],[31,31],[32,32]]],[1564120372328,["GJX@GJXAIOU",[[1,32,"- weika"]],[32,32],[39,39]]],[1564120373174,["GJX@GJXAIOU",[[-1,34,"weika"]],[39,39],[34,34]]],[1564120376801,["GJX@GJXAIOU",[[1,34,"未看"]],[34,34],[36,36]]]],null,"GJX@GJXAIOU"],["f601964e-7f9e-4de2-aa5f-19dbb48a8cac",1564820936212,"---\nflag: red\ntags: \n- final关键字\n- 未看\n---\n\n# Java中final关键字使用\n\n\nfinal在平时开发过程中是常常看见的，但是感觉对它是熟悉又陌生。今天来看看final究竟是什么。final，顾名思义，即最终、不可变。在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。final方法在编译阶段绑定，称为静态绑定(static binding)。\n\n## 一、修饰类 \n\n当一个类的整体定义为final时候，表明这个类不能被继承，比如java中的String类。但是注意的是final类中的所有成员方法都会被隐式地指定为final方法。这个很容易。\n\n## 二、方法\n\n当一个方法修饰为final的时候，意味着把该方法锁定，以防任何继承类修改它的含义。因此，如果只有明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。还有就是，类的private方法会隐式地被指定为final方法。代码如下：\n\n```java\nclass WithFinals {\n    private final void f() {\n        System.out.println(\"WithFinals.f()\");\n    }\n\n    private void g() {\n        System.out.println(\"WithFinals.g()\");\n    }\n\n    public final void h() {\n        System.out.println(\"WithFinals.h()\");\n    }\n}\n\n\npublic class OverridingPrivate extends WithFinals {\n//    public void h() {\n//        System.out.println(\"OverridingPrivate.h()\");\n//    }\n\n//    @Override\n    public void g() {\n        System.out.println(\"OverridingPrivate.g()\");\n    }\n\n//    @Override\n    public void f() {\n        System.out.println(\"OverridingPrivate.f()\");\n    }\n\n}\n```\n\n如果把上面三处注释地方去掉，代码编译不通过，下面分析一下编译不通过的原因。第一个地方方法h()编译不通过，因为父类h() 方法修饰符为final不能通过编译。\n\n第二个地方是g()上面的注解编译不通过，是因为父类发g()方法是修饰为private，这正如上面讲的类的private方法会隐式地被指定为final方法，但是跟final又不同，去掉@Override却编译通过，**这是因为“覆盖”只有在某个方法是基类的一部分才会出现。即，必须能将一个对象向上转型为它的基本类型并调用相同的方法**。如果方法为private，它就不是基类的一部分，它是隐藏于类中的程序代码，只不过有相同的名称。如果方法为public、protected或包访问权限方法的话，就不会产生在基类中出现的\"仅具有相同的名称\"。所以子类的g（）是一个新的方法，这其实与final关系不大；\n\n第三个地方是f()上面的注解不能编译通过,去掉@Override也是正常编译通过的，所以这也能间接证明private 方法其实是否是final没有多大联系。\n\n## 三、变量\n\n对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。引用变量被final修饰之后，虽然不能再指向其他对象，但是它指向的对象的内容是可变的。撸个代码：\n\n```\nclass Value {\n    int i;\n    public Value(int i) {\n        this.i = i;\n    }\n}\n\n\npublic class FinalData {\n    private static Random rand = new Random(47);\n    private String id;\n\n\n    public FinalData(String id) {\n        this.id = id;\n    }\n\n    private final int valueOne = 9;\n    private static final int VALUE_TWO = 99;\n\n    private final int i4 = rand.nextInt(20);\n    static final int INT_5 = rand.nextInt(20);\n\n    private Value v1 = new Value(11);\n    private final Value v2 = new Value(22);\n    private static final Value VAL_3 = new Value(33);\n\n\n    @Override\n    public String toString() {\n        return id + \": \" + \"i4 = \" + i4 + \", INT_5 = \" + INT_5;\n    }\n\n    public static void main(String[] args) {\n        FinalData fd1 = new FinalData(\"fd1\");\n        // fd1.valueOne++; // Error\n        fd1.v2.i++;\n        fd1.v1 = new Value(9);\n\n        // fd1.v2 = new Value(0); // Error\n        // fd1.VAL_3 = new Value(1); // Error\n        System.out.println(fd1);\n        System.out.println(\"Creating new FinalData\");\n        FinalData fd2 = new FinalData(\"fd2\");\n        System.out.println(fd1);\n        System.out.println(fd2);\n    }\n}\n```\n\n一个个分析， 我们知道static强调唯一，而final强调常量，valueOne和VALUE_TWO 都是编译常量，区别就是VALUE_TWO在存储空间是唯一的，以及赋值阶段不同。\n\n对于i4 和INT_5展示了将final数值定义为静态和非静态的区别。看一下上面代码编译后的情况，如下面的图：\n\n![代码编译结果]($resource/%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C.jpg)\n\n图一\n\n编译之后i4到构造器中，而INT_5在static代码块中，可以看出i4在创建实列变量的时候被赋值，而INT_5在类加载过程准备阶段就赋值了(注意static且非final是在初始化阶段被赋值的)，还有一点valueOne并不在构造器中，这是因为valueOne是基本类型。另外在fd1和fd2中发现i4的值是唯一的（相对于对象而言），INT_5也是一样的（相对于类而言）。\n\nv1到VAl_3中，不能因为v2是final的，就 认为v2的值不可以改变。从代码的第37行可以看出，v2的值是可以改变的，这是因为这是一个引用，但是无法将v2再次指向新的引用。这对数组具有同样的意义，数组不过是另一种引用。\n\n## 四、进阶\n\n### 1.空白final\n\n空白final是指声明为final但又未给初值的变量。编译器确保空白的final在使用前必须初始化。代码如下\n\n```\nclass Poppet {\n    private int i;\n\n    Poppet(int ii) {\n        i = ii;\n    }\n}\n\npublic class BlankFinal {\n    private final int i = 0;\n    private final int j;\n    private final Poppet p;\n\n    public BlankFinal() {\n        j = 1;\n        p = new Poppet(1);\n    }\n\n}\n\n```\n\ni和p均没有值 ，这跟static不一样，**static非final会在类加载阶段的准备阶段会被赋予类型初始值，即 static修饰的 j在准备阶段为0，static修饰的 p为null，而空白final不会**。如果BlankFinal构造函数里的两行的代码注释掉会编译不通过。\n\n### 2.final局部变量\n\n废话不多说，撸一把代码\n\n```\npublic class FinalTest {\n    private int g1 = 127;\n    private int g2 = 128;\n    private int g3 = 32767;\n    private int g4 = 32768;\n\n\n    public static void main(String[] args) {\n\n        int n1 = 2019;\n        final int n2 = 2019;\n\n        String s = \"20190718\";\n        String s1 = n1 + \"0718\";\n        String s2 = n2 + \"0718\";\n\n        System.out.println(s == s1); //false\n        System.out.println(s == s2); //true\n\n    }\n}\n\n```\n\n上面的类变量g1-g4先不要管，下面会解释其中的用意。运行结果发现第一个打印的是false，第二个是true，下面分析原因，先看一下编译之后的结果：\n![程序编译结果]($resource/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C.jpg)\n\n 图二\n\n图二中，发现很有意思的事情，n1编译之后为short类型了,n2编译之后为boolean类型了，这个其实算是编译器优化了，为每个常量选择合适的类型，这样可以减少虚拟机的内存空间，对于final局部常量来说对运行期是没有影响的（局部变量和字段（实类变量、类变量）是有区别，它在常量池是没有Fieldref符号引用，自然没有访问标志信息，因此将局部声明为final对运行期是没有影响的），非0的时候编译之后为true，0的时候为false；\n\n接下来发现s与s2的是一样的，即在常量池中的位置是同一个位置，字符索引是同一个，说白了就是内存中同一个值，所以就很好的解释为什么s==s2是true。对于s1来说，其实是通过StringBuilder类把n1和“0718”相加的，直接来证明一下，如下图反编译之后的结果来看：\n\n![](https://mmbiz.qpic.cn/mmbiz_png/IibUVnJ665Wq9501E22D8RBpFicNPacxSO47kbH5Q6al8GicGA7cu1AiakhQbjn2lynLyAHkgIfedicv1IdQDEKodzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n图三\n\n图三中，24行中看出是通过StringBuilder的append进行相加的，然后通过StringBuilder的toString方法获取值，这就解释了s==s1为false的原因。\n\n下面是扩展内容，接下来解释g1-g4的用途,先看一下g1-g4常量池的情况\n\n![](https://mmbiz.qpic.cn/mmbiz_png/IibUVnJ665Wq9501E22D8RBpFicNPacxSOV6cR8iaJWcUjDkgMIymbWhKvbSK1vmkjbKQqvWZNwVRqzGRwUFLPmPQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n图四\n\n上面是编译后的部分截图，了解常量池的朋友从图中#5知道32768是在常量池的，但是127、128、32767不再常量池，那再哪里呢，再看反编译片段。\n\n![](https://mmbiz.qpic.cn/mmbiz_png/IibUVnJ665Wq9501E22D8RBpFicNPacxSOjmpEQWVI7FicMTCxD1FsVFj6K91BPvSJrCKeGaEzib0ffoURAlAI88Xw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n图五\n\n发现127是由bipush送至栈顶，而128和32767送至栈顶的sipush送至栈顶，\n\n这两个命令是是什么意思？\n\nbipush:将单字节常量（-128~127）推送至栈顶\n\nsipush:将一个短整型常量值（-32768~32767）推送至栈顶\n\n相当于虚拟机缓存了-32768~32767的数值，不需要在常量池定义了，类比于Integer类，Integer会缓存-128~127，超过了这个范围则从新生成Integer对象 。\n",[[1564820901743,["GJX@GJXAIOU",[[-1,61,"\n"]],[61,61],[60,60]]],[1564820913372,["GJX@GJXAIOU",[[-1,60,"\nfinal在平时开发过程中是常常看见的，但是感觉对它是熟悉又陌生。今天来看看final究竟是什么。final，顾名思义，即最终、不可变。"]],[60,129],[60,60]]]],null,"GJX@GJXAIOU"]]}