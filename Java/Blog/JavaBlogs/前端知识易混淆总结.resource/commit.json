{"compress":true,"commitItems":[["9e57d611-4ea2-49d5-afb6-d89c0eecb2b0",1566610360955,"",[[1566610321702,["GJX@GJXAIOU",[[1,0,"# 前端知识易混淆总结\n\n\n\n"]],[0,0],[14,14]]],[1566610336621,["GJX@GJXAIOU",[[1,14,"xml和html可以认为是超集和子集的关系。html是xml的一个子集，因此html比xml简洁。html够用的地方就用html，不够用的地方就用xml。（什么？哪里够用哪里不够用？这个就要学习了xml的基本原理后才能理解了。现在说了也很抽象。）\n\n关于jsp、servlet和javascript：首先你要分清一个概念，什么叫“动态网站”。动态不是说页面上的东西能动，而是说你这个网站有一些诸如留言板、论坛之类的无法仅仅通过客户端浏览器实现的功能。\njava script是一种客户端脚本语言，它一般是用来提供一些简单的客户端功能（注意，我说“一般是”，没说“只能是”），用来补充html的不足。比如，快速验证你填写的email地址是否合法，javascript在浏览器里面执行，这和html是一样的。\njsp/servlet是服务器端的程序，它们由服务器执行。servlet可以完全替代jsp，一般来说，对普通网站而言，jsp也可以替代servlet的作用。之所以会有jsp和servlet这两个功能上差不多的东西，是因为一些设计模式/软件工程上的考虑，简单一点理解的话，也可以这么说：jsp比servlet要简单，而servlet要比jsp强大、有效，因此针对网站的不同功能模块，需要合理选择使用servlet还是jsp来编写。\n因此，根据之前对“动态网站”的定义，javascript不是用来做动态网站的，而jsp/servlet是。比如说新浪这个爱问程序，当你回答一个问题的时候，输入框右下角会显示你还能输入几个汉字，这个就是用javascript实现的，而当你点了提交按钮以后，服务器会收到你的回答，并把回答存入数据库，这个存入数据库的功能就可以通过jsp或servlet实现"]],[14,14],[758,758]]],[1566610339308,["GJX@GJXAIOU",[[1,759,"\n"]],[758,758],[759,759]]],[1566610339411,["GJX@GJXAIOU",[[1,760,"\n"]],[759,759],[760,760]]],[1566610339524,["GJX@GJXAIOU",[[1,761,"\n"]],[760,760],[761,761]]],[1566610339635,["GJX@GJXAIOU",[[1,762,"\n"]],[761,761],[762,762]]],[1566610339766,["GJX@GJXAIOU",[[1,763,"\n"]],[762,762],[763,763]]],[1566610339899,["GJX@GJXAIOU",[[1,764,"\n"]],[763,763],[764,764]]],[1566610340019,["GJX@GJXAIOU",[[1,765,"\n"]],[764,764],[765,765]]],[1566610340141,["GJX@GJXAIOU",[[1,766,"\n"]],[765,765],[766,766]]],[1566610340260,["GJX@GJXAIOU",[[1,767,"\n"]],[766,766],[767,767]]],[1566610340390,["GJX@GJXAIOU",[[1,768,"\n"]],[767,767],[768,768]]],[1566610372684,["GJX@GJXAIOU",[[-1,14,"xml和html可以认为是超集和子集的关系。"]],[14,36],[14,14]]],[1566610377078,["GJX@GJXAIOU",[[-1,69,"（什么？哪里够用哪里不够用？这个就要学习了xml的基本原理后才能理解了。现在说了也很抽象。）"]],[69,115],[69,69]]],[1566610387246,["GJX@GJXAIOU",[[1,13,"## HTML"]],[13,13],[20,20]]],[1566610390195,["GJX@GJXAIOU",[[1,78,"\n"]],[77,77],[78,78]]],[1566610390342,["GJX@GJXAIOU",[[1,79,"\n"]],[78,78],[79,79]]],[1566610410145,["GJX@GJXAIOU",[[1,79,"## JavaScript = JS"]],[79,79],[97,97]]],[1566610418623,["GJX@GJXAIOU",[[1,719,"## Servlet"]],[719,719],[729,729]]],[1566610419517,["GJX@GJXAIOU",[[1,738,"\n"]],[729,729],[730,730]]],[1566610419853,["GJX@GJXAIOU",[[1,739,"\n"]],[730,730],[731,731]]],[1566610420148,["GJX@GJXAIOU",[[1,740,"\n"]],[731,731],[732,732]]],[1566610425951,["GJX@GJXAIOU",[[1,732,"## CSS"]],[732,732],[738,738]]],[1566610426395,["GJX@GJXAIOU",[[1,747,"\n"]],[738,738],[739,739]]],[1566610428250,["GJX@GJXAIOU",[[1,748,"\n"]],[739,739],[740,740]]],[1566610452260,["GJX@GJXAIOU",[[1,740,"## Java Servl"]],[740,740],[753,753]]],[1566610453347,["GJX@GJXAIOU",[[-1,751,"vl"]],[753,753],[751,751]]],[1566610461436,["GJX@GJXAIOU",[[1,751,"ver Page = JSA"]],[751,751],[765,765]]],[1566610461996,["GJX@GJXAIOU",[[-1,764,"A"]],[765,765],[764,764]]],[1566610462348,["GJX@GJXAIOU",[[1,764,"P"]],[764,764],[765,765]]],[1566610469379,["GJX@GJXAIOU",[[1,13,"\n"]],[12,12],[13,13]]],[1566610469515,["GJX@GJXAIOU",[[1,14,"\n"]],[13,13],[14,14]]],[1566610471126,["GJX@GJXAIOU",[[1,15,"\n"]],[13,13],[14,14]]],[1566610471940,["GJX@GJXAIOU",[[1,14,"- "]],[14,14],[16,16]]],[1566610473723,["GJX@GJXAIOU",[[-1,14,"- "]],[16,16],[14,14]]],[1566610475459,["GJX@GJXAIOU",[[1,14,"### "]],[14,14],[18,18]]],[1566610476245,["GJX@GJXAIOU",[[-1,17," "]],[18,18],[17,17]]],[1566610476699,["GJX@GJXAIOU",[[1,17," "]],[17,17],[18,18]]],[1566610477299,["GJX@GJXAIOU",[[-1,16,"# "]],[18,18],[16,16]]],[1566610479111,["GJX@GJXAIOU",[[1,16," hui"]],[16,16],[20,20]]],[1566610479700,["GJX@GJXAIOU",[[-1,17,"hui"]],[20,20],[17,17]]],[1566610481424,["GJX@GJXAIOU",[[1,17,"汇总"]],[17,17],[19,19]]],[1566610483966,["GJX@GJXAIOU",[[1,33," "]],[33,33],[34,34]]],[1566610484949,["GJX@GJXAIOU",[[1,38," "]],[38,38],[39,39]]],[1566610485627,["GJX@GJXAIOU",[[1,35," "]],[35,35],[36,36]]],[1566610487340,["GJX@GJXAIOU",[[1,48," "]],[48,48],[49,49]]],[1566610488486,["GJX@GJXAIOU",[[1,53," "]],[53,53],[54,54]]],[1566610489374,["GJX@GJXAIOU",[[1,55," "]],[55,55],[56,56]]],[1566610490133,["GJX@GJXAIOU",[[1,59," "]],[59,59],[60,60]]],[1566610491612,["GJX@GJXAIOU",[[1,67," "]],[67,67],[68,68]]],[1566610492596,["GJX@GJXAIOU",[[1,75," "]],[75,75],[76,76]]],[1566610495348,["GJX@GJXAIOU",[[1,89," "]],[89,89],[90,90]]],[1566610499195,["GJX@GJXAIOU",[[1,21,"\n"]],[20,20],[21,21]]],[1566610499340,["GJX@GJXAIOU",[[1,22,"\n"]],[21,21],[22,22]]],[1566610499470,["GJX@GJXAIOU",[[1,23,"\n"]],[22,22],[23,23]]],[1566610499587,["GJX@GJXAIOU",[[1,24,"\n"]],[23,23],[24,24]]],[1566610532095,["GJX@GJXAIOU",[[1,21,"- Java"]],[21,21],[27,27]]],[1566610537691,["GJX@GJXAIOU",[[-1,23,"Java"]],[27,27],[23,23]]],[1566610540742,["GJX@GJXAIOU",[[1,23,"JavaScript是"]],[23,23],[34,34]]],[1566610540765,["GJX@GJXAIOU",[[1,33," "]],[34,34],[35,35]]],[1566610548573,["GJX@GJXAIOU",[[1,35,"客户端脚本语言；"]],[35,35],[43,43]]],[1566610549594,["GJX@GJXAIOU",[[1,44,"- \n"]],[43,43],[46,46]]],[1566610554375,["GJX@GJXAIOU",[[1,46,"jsp和"]],[46,46],[50,50]]],[1566610554398,["GJX@GJXAIOU",[[1,49," "]],[50,50],[51,51]]],[1566610556831,["GJX@GJXAIOU",[[1,51,"Servlet"]],[51,51],[58,58]]],[1566610556855,["GJX@GJXAIOU",[[1,51," "]],[58,58],[59,59]]],[1566610559462,["GJX@GJXAIOU",[[1,59,"是"]],[59,59],[60,60]]],[1566610559485,["GJX@GJXAIOU",[[1,59," "]],[60,60],[61,61]]],[1566610564791,["GJX@GJXAIOU",[[1,61,"服务器的晨曦"]],[61,61],[67,67]]],[1566610565716,["GJX@GJXAIOU",[[-1,65,"晨曦"]],[67,67],[65,65]]],[1566610567423,["GJX@GJXAIOU",[[1,65,"程序；"]],[65,65],[68,68]]],[1566610600555,["GJX@GJXAIOU",[[1,837,"## "]],[837,837],[840,840]]],[1566610602123,["GJX@GJXAIOU",[[1,840,"工台"]],[840,840],[842,842]]],[1566610602859,["GJX@GJXAIOU",[[-1,840,"工台"]],[842,842],[840,840]]],[1566610606102,["GJX@GJXAIOU",[[1,840,"动态网站"]],[840,840],[844,844]]],[1566610606405,["GJX@GJXAIOU",[[1,850,"\n"]],[844,844],[845,845]]],[1566610612595,["GJX@GJXAIOU",[[-1,213,"动态不是说页面上的东西能动，而是说你这个网站有一些诸如留言板、论坛之类的无法仅仅通过客户端浏览器实现的功能。"]],[213,267],[213,213]]],[1566610614874,["GJX@GJXAIOU",[[1,792,"动态不是说页面上的东西能动，而是说你这个网站有一些诸如留言板、论坛之类的无法仅仅通过客户端浏览器实现的功能。"]],[792,792],[846,846]]],[1566610620668,["GJX@GJXAIOU",[[-1,167,"关于jsp、servlet和javascript：首先你要分清一个概念，什么叫“动态网站”。"]],[167,213],[167,167]]],[1566610622892,["GJX@GJXAIOU",[[-1,167,"\n"]],[167,167],[166,166]]],[1566610627676,["GJX@GJXAIOU",[[-1,207,"（注意，我说“一般是”，没说“只能是”）"]],[207,227],[207,207]]],[1566610637324,["GJX@GJXAIOU",[[1,69,"- \n"]],[68,68],[71,71]]],[1566610641408,["GJX@GJXAIOU",[[1,71,"JavaScript和"]],[71,71],[82,82]]],[1566610641433,["GJX@GJXAIOU",[[1,81," "]],[82,82],[83,83]]],[1566610643430,["GJX@GJXAIOU",[[1,83,"HTML"]],[83,83],[87,87]]],[1566610643453,["GJX@GJXAIOU",[[1,83," "]],[87,87],[88,88]]],[1566610644918,["GJX@GJXAIOU",[[1,88,"都是"]],[88,88],[90,90]]],[1566610644942,["GJX@GJXAIOU",[[1,88," "]],[90,90],[91,91]]],[1566610649328,["GJX@GJXAIOU",[[1,91,"在浏览器中运行；"]],[91,91],[99,99]]],[1566610654131,["GJX@GJXAIOU",[[-1,273,"，javascript在浏览器里面执行，这和html是一样的。"]],[273,304],[273,273]]],[1566610654661,["GJX@GJXAIOU",[[1,273,"；"]],[273,273],[274,274]]],[1566610660251,["GJX@GJXAIOU",[[-1,202," "]],[203,203],[202,202]]],[1566610661379,["GJX@GJXAIOU",[[-1,202,"s"]],[203,203],[202,202]]],[1566610662313,["GJX@GJXAIOU",[[1,202,"S"]],[202,202],[203,203]]],[1566610665485,["GJX@GJXAIOU",[[-1,198,"j"]],[199,199],[198,198]]],[1566610666599,["GJX@GJXAIOU",[[1,198,"J"]],[198,198],[199,199]]],[1566610668580,["GJX@GJXAIOU",[[1,274,"\n"]],[274,274],[275,275]]],[1566610674422,["GJX@GJXAIOU",[[-1,689,"## Java Server Page = JSP"]],[689,714],[689,689]]],[1566610675987,["GJX@GJXAIOU",[[1,668,"\n"]],[667,667],[668,668]]],[1566610676125,["GJX@GJXAIOU",[[1,669,"\n"]],[668,668],[669,669]]],[1566610677029,["GJX@GJXAIOU",[[1,668,"## Java Server Page = JSP"]],[668,668],[693,693]]],[1566610682683,["GJX@GJXAIOU",[[-1,275,"jsp/servlet是服务器端的程序，它们由服务器执行。servlet可以完全替代jsp，一般来说，对普通网站而言，jsp也可以替代servlet的作用。之所以会有jsp和servlet这两个功能上差不多的东西，是因为一些设计模式/软件工程上的考虑，简单一点理解的话，也可以这么说：jsp比servlet要简单，而servlet要比jsp强大、有效，因此针对网站的不同功能模块，需要合理选择使用servlet还是jsp来编写。"]],[275,489],[275,275]]],[1566610684315,["GJX@GJXAIOU",[[1,480,"jsp/servlet是服务器端的程序，它们由服务器执行。servlet可以完全替代jsp，一般来说，对普通网站而言，jsp也可以替代servlet的作用。之所以会有jsp和servlet这两个功能上差不多的东西，是因为一些设计模式/软件工程上的考虑，简单一点理解的话，也可以这么说：jsp比servlet要简单，而servlet要比jsp强大、有效，因此针对网站的不同功能模块，需要合理选择使用servlet还是jsp来编写。"]],[480,480],[694,694]]],[1566610701517,["GJX@GJXAIOU",[[1,491," "]],[491,491],[492,492]]],[1566610703220,["GJX@GJXAIOU",[[1,517," "]],[517,517],[518,518]]],[1566610704293,["GJX@GJXAIOU",[[1,527," "]],[527,527],[528,528]]],[1566610704900,["GJX@GJXAIOU",[[1,524," "]],[524,524],[525,525]]],[1566610706524,["GJX@GJXAIOU",[[1,551," "]],[551,551],[552,552]]],[1566610707347,["GJX@GJXAIOU",[[1,546," "]],[546,546],[547,547]]],[1566610708908,["GJX@GJXAIOU",[[1,560," "]],[560,560],[561,561]]],[1566610710277,["GJX@GJXAIOU",[[1,570," "]],[570,570],[571,571]]],[1566610710964,["GJX@GJXAIOU",[[1,574," "]],[574,574],[575,575]]],[1566610712364,["GJX@GJXAIOU",[[1,576," "]],[576,576],[577,577]]],[1566610713325,["GJX@GJXAIOU",[[1,584," "]],[584,584],[585,585]]],[1566610715885,["GJX@GJXAIOU",[[1,636," "]],[636,636],[637,637]]],[1566610716923,["GJX@GJXAIOU",[[1,638," "]],[638,638],[639,639]]],[1566610718292,["GJX@GJXAIOU",[[1,646," "]],[646,646],[647,647]]],[1566610719229,["GJX@GJXAIOU",[[1,652," "]],[652,652],[653,653]]],[1566610720142,["GJX@GJXAIOU",[[1,660," "]],[660,660],[661,661]]],[1566610721093,["GJX@GJXAIOU",[[1,663," "]],[663,663],[664,664]]],[1566610721750,["GJX@GJXAIOU",[[1,667," "]],[667,667],[668,668]]],[1566610723948,["GJX@GJXAIOU",[[1,703," "]],[703,703],[704,704]]],[1566610724852,["GJX@GJXAIOU",[[1,696," "]],[696,696],[697,697]]],[1566610725828,["GJX@GJXAIOU",[[1,710," "]],[710,710],[711,711]]],[1566610727020,["GJX@GJXAIOU",[[1,707," "]],[707,707],[708,708]]],[1566610809860,["GJX@GJXAIOU",[[-1,730,"## CSS"]],[730,736],[730,730]]],[1566610813916,["GJX@GJXAIOU",[[1,179,"\n"]],[177,177],[178,178]]],[1566610814516,["GJX@GJXAIOU",[[1,178,"## CSS"]],[178,178],[184,184]]],[1566610827316,["GJX@GJXAIOU",[[1,100,"- 一个基本的网站包含很多个网页，一个网页由html, css和javascript组成。"]],[100,100],[145,145]]],[1566610830620,["GJX@GJXAIOU",[[-1,144,"。"]],[145,145],[144,144]]],[1566610831166,["GJX@GJXAIOU",[[1,144,"；"]],[144,144],[145,145]]],[1566610843035,["GJX@GJXAIOU",[[1,145,"html是主体，装载各种dom元素；css用来装饰dom元素；javascript控制dom元素。"]],[145,145],[194,194]]],[1566610845964,["GJX@GJXAIOU",[[1,122," "]],[122,122],[123,123]]],[1566610846902,["GJX@GJXAIOU",[[1,132," "]],[132,132],[133,133]]],[1566610851492,["GJX@GJXAIOU",[[1,134," "]],[134,134],[135,135]]],[1566610852766,["GJX@GJXAIOU",[[1,145," "]],[145,145],[146,146]]],[1566610853918,["GJX@GJXAIOU",[[1,153," "]],[153,153],[154,154]]],[1566610855980,["GJX@GJXAIOU",[[1,162," "]],[162,162],[163,163]]],[1566610856846,["GJX@GJXAIOU",[[1,166," "]],[166,166],[167,167]]],[1566610858014,["GJX@GJXAIOU",[[1,173," "]],[173,173],[174,174]]],[1566610859292,["GJX@GJXAIOU",[[1,181," "]],[181,181],[182,182]]],[1566610860309,["GJX@GJXAIOU",[[1,178," "]],[178,178],[179,179]]],[1566610861438,["GJX@GJXAIOU",[[1,196," "]],[196,196],[197,197]]],[1566610862221,["GJX@GJXAIOU",[[1,202," "]],[202,202],[203,203]]],[1566610863100,["GJX@GJXAIOU",[[1,199," "]],[199,199],[200,200]]],[1566610917276,["GJX@GJXAIOU",[[-1,389,"\n"]],[389,389],[388,388]]],[1566610951126,["GJX@GJXAIOU",[[1,285,"\n"]],[283,283],[284,284]]],[1566610951950,["GJX@GJXAIOU",[[1,284,"html是用来描述网页的一种语言，它不是一种编程语言，而是一种标记语言（标记标签），总的来说，html使用标记标签来描述网页，本文就用标签来代替标记标签进行说明。"]],[284,284],[365,365]]],[1566610960244,["GJX@GJXAIOU",[[1,312,"**"],[1,325,"**"]],[312,325],[312,329]]],[1566610963342,["GJX@GJXAIOU",[[1,288," "]],[288,288],[289,289]]],[1566610965285,["GJX@GJXAIOU",[[1,340," "]],[340,340],[341,341]]],[1566610976020,["GJX@GJXAIOU",[[-1,352,"，本文就用标签来代替标记标签进行说明"]],[352,370],[352,352]]],[1566610993573,["GJX@GJXAIOU",[[1,353,"标签里可带有各类属性，最基本的就是class和id。class属性的作用是引用css样式；id的作用是配合javascript使用，具有唯一性。"]],[353,353],[425,425]]],[1566611007227,["GJX@GJXAIOU",[[1,972,"\n"]],[972,972],[973,973]]],[1566611007339,["GJX@GJXAIOU",[[1,973,"\n"]],[973,973],[974,974]]],[1566611012705,["GJX@GJXAIOU",[[1,987,"## DOM"]],[987,987],[993,993]]],[1566611030020,["GJX@GJXAIOU",[[1,434,"css的官方名字叫层叠样式表，它的出现是为了解决内容和表现分离的问题，一般存放在.css文件里。\n\n使用css。\n\n可在html的头元素<head>里书写，或者书写在CSS文件并在html里引用该文件。\n\ncss优先权。\n\n多个css样式可集中在单个html标签里，出现这种情况时，一般按优先权划分\n\n浏览器默认设置 （最低）\n外部样式表\n内部样式表（写在html的<head>标签内部）\n内联样式（写在html的标签里，即style属性）（最高）\ncss的语法。\n\ncss由两个主要部分组成，选择器，一条或多条声明。\n\n选择器是指css样式的名字“.seletor”，名字前面要带上一点“.”。声明是由属性和值组成，给个例子“margin: 0 auto”，冒号前面是属性，后面是值，该例子是定义元素居中显示。"]],[434,434],[790,790]]],[1566611033722,["GJX@GJXAIOU",[[-1,483,"\n"]],[483,483],[482,482]]],[1566611040486,["GJX@GJXAIOU",[[1,454,"**"],[1,468,"**"]],[454,468],[454,472]]],[1566611042277,["GJX@GJXAIOU",[[1,478," "]],[478,478],[479,479]]],[1566611043125,["GJX@GJXAIOU",[[1,483," "]],[483,483],[484,484]]],[1566611044412,["GJX@GJXAIOU",[[1,437," "]],[437,437],[438,438]]],[1566611046819,["GJX@GJXAIOU",[[-1,495,"。"]],[496,496],[495,495]]],[1566611049427,["GJX@GJXAIOU",[[1,490,"**"],[1,495,"**"]],[490,495],[490,499]]],[1566611052163,["GJX@GJXAIOU",[[-1,500,"\n"]],[500,500],[499,499]]],[1566611054046,["GJX@GJXAIOU",[[1,502," "]],[502,502],[503,503]]],[1566611054876,["GJX@GJXAIOU",[[1,507," "]],[507,507],[508,508]]],[1566611056013,["GJX@GJXAIOU",[[-1,512,"<"],[1,513," "]],[512,513],[513,513]]],[1566611058331,["GJX@GJXAIOU",[[1,512,"<"],[-1,512," "]],[513,513],[512,513]]],[1566611060127,["GJX@GJXAIOU",[[1,512," "]],[512,512],[513,513]]],[1566611061058,["GJX@GJXAIOU",[[1,519," "]],[519,519],[520,520]]],[1566611062342,["GJX@GJXAIOU",[[1,529," "]],[529,529],[530,530]]],[1566611063211,["GJX@GJXAIOU",[[1,533," "]],[533,533],[534,534]]],[1566611064749,["GJX@GJXAIOU",[[1,538," "]],[538,538],[539,539]]],[1566611065852,["GJX@GJXAIOU",[[1,543," "]],[543,543],[544,544]]],[1566611068443,["GJX@GJXAIOU",[[-1,559,"。"]],[560,560],[559,559]]],[1566611077359,["GJX@GJXAIOU",[[1,536,"中"]],[536,536],[537,537]]],[1566611082189,["GJX@GJXAIOU",[[1,554,"**"],[1,560,"**"]],[554,560],[554,564]]],[1566611085157,["GJX@GJXAIOU",[[-1,565,"\n"]],[565,565],[564,564]]],[1566611090018,["GJX@GJXAIOU",[[-1,603,"\n"]],[603,603],[602,602]]],[1566611094563,["GJX@GJXAIOU",[[-1,712,"\n"]],[712,712],[711,711]]],[1566611097474,["GJX@GJXAIOU",[[1,808,"\n"]],[807,807],[808,808]]],[1566611097627,["GJX@GJXAIOU",[[1,809,"\n"]],[808,808],[809,809]]],[1566611102932,["GJX@GJXAIOU",[[-1,686,"css由两个主要部分组成，选择器，一条或多条声明。\n选择器是指css样式的名字“.seletor”，名字前面要带上一点“.”。声明是由属性和值组成，给个例子“margin: 0 auto”，冒号前面是属性，后面是值，该例子是定义元素居中显示。"]],[686,807],[686,686]]],[1566611104690,["GJX@GJXAIOU",[[1,490,"\n"]],[489,489],[490,490]]],[1566611105099,["GJX@GJXAIOU",[[1,490,"css由两个主要部分组成，选择器，一条或多条声明。\n选择器是指css样式的名字“.seletor”，名字前面要带上一点“.”。声明是由属性和值组成，给个例子“margin: 0 auto”，冒号前面是属性，后面是值，该例子是定义元素居中显示。"]],[490,490],[611,611]]],[1566611110548,["GJX@GJXAIOU",[[1,493," 组成："]],[493,493],[497,497]]],[1566611115884,["GJX@GJXAIOU",[[-1,497,"由两个主要部分组成，"]],[497,507],[497,497]]],[1566611119372,["GJX@GJXAIOU",[[1,490,"**"],[1,496,"**"]],[490,496],[490,500]]],[1566611126655,["GJX@GJXAIOU",[[1,722,"："]],[722,722],[723,723]]],[1566611130325,["GJX@GJXAIOU",[[1,751," "]],[751,751],[752,752]]],[1566611131622,["GJX@GJXAIOU",[[1,756," "]],[756,756],[757,757]]],[1566611132494,["GJX@GJXAIOU",[[1,758," "]],[758,758],[759,759]]],[1566611133397,["GJX@GJXAIOU",[[1,765," "]],[765,765],[766,766]]],[1566611134206,["GJX@GJXAIOU",[[1,794," "]],[794,794],[795,795]]],[1566611135117,["GJX@GJXAIOU",[[1,789," "]],[789,789],[790,790]]],[1566611136342,["GJX@GJXAIOU",[[1,783," "]],[783,783],[784,784]]],[1566611137478,["GJX@GJXAIOU",[[1,779," "]],[779,779],[780,780]]],[1566611139741,["GJX@GJXAIOU",[[1,814," "]],[814,814],[815,815]]],[1566611145758,["GJX@GJXAIOU",[[1,806," "]],[806,806],[807,807]]],[1566611146485,["GJX@GJXAIOU",[[1,810," "]],[810,810],[811,811]]],[1566611148110,["GJX@GJXAIOU",[[-1,806," "]],[807,807],[806,806]]],[1566611156196,["GJX@GJXAIOU",[[-1,819,"\n"]],[818,818],[817,817]]],[1566611156380,["GJX@GJXAIOU",[[-1,818,"\n"]],[817,817],[816,816]]],[1566611170892,["GJX@GJXAIOU",[[-1,914,"因此，根据之前对“动态网站”的定义，"]],[914,931],[914,914]]],[1566611174342,["GJX@GJXAIOU",[[1,924," "]],[924,924],[925,925]]],[1566611183525,["GJX@GJXAIOU",[[1,937," "]],[937,937],[938,938]]],[1566611184277,["GJX@GJXAIOU",[[1,949," "]],[949,949],[950,950]]],[1566611190230,["GJX@GJXAIOU",[[1,1075,"。"]],[1075,1075],[1076,1076]]],[1566611193037,["GJX@GJXAIOU",[[1,1000," "]],[1000,1000],[1001,1001]]],[1566611194557,["GJX@GJXAIOU",[[1,1011," "]],[1011,1011],[1012,1012]]],[1566611196427,["GJX@GJXAIOU",[[1,1075," "]],[1075,1075],[1076,1076]]],[1566611197283,["GJX@GJXAIOU",[[1,1068," "]],[1068,1068],[1069,1069]]],[1566611198158,["GJX@GJXAIOU",[[1,1067," "]],[1067,1067],[1068,1068]]],[1566611199261,["GJX@GJXAIOU",[[1,1064," "]],[1064,1064],[1065,1065]]],[1566611202933,["GJX@GJXAIOU",[[1,900," "]],[900,900],[901,901]]],[1566611203684,["GJX@GJXAIOU",[[1,906," "]],[906,906],[907,907]]],[1566611222453,["GJX@GJXAIOU",[[1,916,"**"],[1,953,"**"]],[916,953],[916,957]]],[1566611256051,["GJX@GJXAIOU",[[1,1090,"\n"]],[1089,1089],[1090,1090]]],[1566611256179,["GJX@GJXAIOU",[[1,1091,"\n"]],[1090,1090],[1091,1091]]],[1566611256331,["GJX@GJXAIOU",[[1,1092,"\n"]],[1091,1091],[1092,1092]]],[1566611256627,["GJX@GJXAIOU",[[1,1093,"\n"]],[1092,1092],[1093,1093]]],[1566611268949,["GJX@GJXAIOU",[[1,1090,"原生js，js库，js框架，js插件"]],[1090,1090],[1108,1108]]],[1566611271469,["GJX@GJXAIOU",[[1,1090,"**"],[1,1108,"**"]],[1090,1108],[1090,1112]]],[1566611273174,["GJX@GJXAIOU",[[1,1094," "]],[1094,1094],[1095,1095]]],[1566611273948,["GJX@GJXAIOU",[[1,1100," "]],[1100,1100],[1101,1101]]],[1566611274981,["GJX@GJXAIOU",[[1,1105," "]],[1105,1105],[1106,1106]]],[1566611275813,["GJX@GJXAIOU",[[1,1111," "]],[1111,1111],[1112,1112]]],[1566611283267,["GJX@GJXAIOU",[[1,1117," 原生js，是指最基础的js，没有封装过，但因为各浏览器对js的支持不同，就导致用基础的js编程需要为不同的浏览器写兼容代码。\n\nl  Js库，js框架，是指集成一系列dom操作，API封装，界面UI封装的的库类，常见的有jQuery，extjs等等，这方面的定义比较难区分，暂不误导大家\n\nl  Js插件，就是集成了帮助程序员轻松完成功能的程序。Js插件用得比较多，网页制作上随处可见。如图片轮换功能，导航制作，上传图片等等。"]],[1117,1117],[1331,1331]]],[1566611285739,["GJX@GJXAIOU",[[1,1117,"\n"]],[1117,1118],[1119,1119]]],[1566611286134,["GJX@GJXAIOU",[[-1,1118," "],[1,1119," -"],[-1,1185," "],[1,1186," "],[-1,1266," "],[1,1267," "]],[1119,1119],[1120,1120]]],[1566611286348,["GJX@GJXAIOU",[[1,1120," "]],[1120,1120],[1121,1121]]],[1566611289299,["GJX@GJXAIOU",[[-1,1185,"l  "]],[1185,1188],[1185,1185]]],[1566611289892,["GJX@GJXAIOU",[[1,1185,"- "]],[1185,1185],[1187,1187]]],[1566611293523,["GJX@GJXAIOU",[[-1,1265,"l  "]],[1265,1268],[1265,1265]]],[1566611294397,["GJX@GJXAIOU",[[1,1265,"- "]],[1265,1265],[1267,1267]]],[1566611469027,["GJX@GJXAIOU",[[-1,1244,"，这方面的定义比较难区分，暂不误导大家"]],[1244,1263],[1244,1244]]],[1566611471269,["GJX@GJXAIOU",[[1,1244,"；"]],[1244,1244],[1245,1245]]],[1566611487804,["GJX@GJXAIOU",[[-1,1118," "]],[1118,1119],[1118,1118]]],[1566611529214,["GJX@GJXAIOU",[[1,431,"ascadingC"]],[430,430],[439,439]]],[1566611546579,["GJX@GJXAIOU",[[1,439," Style Sheets = "]],[439,439],[455,455]]],[1566611559524,["GJX@GJXAIOU",[[1,213,"**Hyper Text Markup Languag** = "]],[213,213],[245,245]]],[1566611561875,["GJX@GJXAIOU",[[-1,240,"**"]],[242,242],[240,240]]],[1566611564890,["GJX@GJXAIOU",[[-1,213,"**"]],[215,215],[213,213]]],[1566611652995,["GJX@GJXAIOU",[[1,208,"- html是网页的结构，CSS是网页的样式，javascript是网页的行为。html就是网页的框架，\n如网页要分成几块就是用html代码实现的；css是用来美化网页框架的，如网页中的导航就是用css控制的；\njs是使网页框架具有动态效果的，如网页中的幻灯片效果就是用js来实现的。"]],[208,208],[350,350]]],[1566611662251,["GJX@GJXAIOU",[[1,248,"\n"]],[248,248],[249,249]]],[1566611662900,["GJX@GJXAIOU",[[1,249,"- "]],[249,249],[251,251]]],[1566611666234,["GJX@GJXAIOU",[[-1,263,"\n"]],[264,264],[263,263]]],[1566611669980,["GJX@GJXAIOU",[[1,284,"\n"]],[284,284],[285,285]]],[1566611670516,["GJX@GJXAIOU",[[1,285,"- "]],[285,285],[287,287]]],[1566611674268,["GJX@GJXAIOU",[[1,319,"- "]],[319,319],[321,321]]],[1566611675390,["GJX@GJXAIOU",[[1,319,"  "]],[321,321],[323,323]]],[1566611676564,["GJX@GJXAIOU",[[1,285,"  "]],[287,287],[289,289]]],[1566611677147,["GJX@GJXAIOU",[[1,249,"  "]],[251,251],[253,253]]],[1566611679908,["GJX@GJXAIOU",[[1,241," "]],[241,241],[242,242]]],[1566611680804,["GJX@GJXAIOU",[[1,277," "]],[277,277],[278,278]]],[1566611681612,["GJX@GJXAIOU",[[1,282," "]],[282,282],[283,283]]],[1566611682908,["GJX@GJXAIOU",[[1,224," "]],[224,224],[225,225]]],[1566611684691,["GJX@GJXAIOU",[[1,214," "]],[214,214],[215,215]]],[1566611686126,["GJX@GJXAIOU",[[1,260," "]],[260,260],[261,261]]],[1566611686901,["GJX@GJXAIOU",[[1,300," "]],[300,300],[301,301]]],[1566611687660,["GJX@GJXAIOU",[[1,336," "]],[336,336],[337,337]]],[1566611689908,["GJX@GJXAIOU",[[1,322," "]],[322,322],[323,323]]],[1566611690749,["GJX@GJXAIOU",[[1,326," "]],[326,326],[327,327]]],[1566611691612,["GJX@GJXAIOU",[[1,366," "]],[366,366],[367,367]]],[1566611692307,["GJX@GJXAIOU",[[1,369," "]],[369,369],[370,370]]],[1566611936611,["GJX@GJXAIOU",[[1,292,"HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。"]],[292,292],[344,344]]],[1566611937932,["GJX@GJXAIOU",[[1,296," "]],[296,296],[297,297]]],[1566611950973,["GJX@GJXAIOU",[[1,384," CSS样式是表现(外观控制)。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。\n所有这些用来改变内容外观的东西称之为表现"]],[384,384],[457,457]]],[1566611953986,["GJX@GJXAIOU",[[-1,436,"\n"]],[437,437],[436,436]]],[1566611957324,["GJX@GJXAIOU",[[-1,384," "],[1,385," "],[1,456,"."]],[456,456],[457,457]]],[1566611958531,["GJX@GJXAIOU",[[-1,456,"."]],[457,457],[456,456]]],[1566611959612,["GJX@GJXAIOU",[[1,456,"."]],[456,456],[457,457]]],[1566611960275,["GJX@GJXAIOU",[[-1,456,"."]],[457,457],[456,456]]],[1566611961174,["GJX@GJXAIOU",[[1,456,"。"]],[456,456],[457,457]]],[1566611964061,["GJX@GJXAIOU",[[1,388," "]],[388,388],[389,389]]],[1566611973172,["GJX@GJXAIOU",[[1,502,"JavaScript是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。\n还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。"]],[502,502],[607,607]]],[1566611976395,["GJX@GJXAIOU",[[-1,554,"\n"]],[555,555],[554,554]]],[1566611980724,["GJX@GJXAIOU",[[1,512," "]],[512,512],[513,513]]],[1566611981868,["GJX@GJXAIOU",[[1,602," "]],[602,602],[603,603]]],[1566611982907,["GJX@GJXAIOU",[[1,592," "]],[592,592],[593,593]]],[1566612229973,["GJX@GJXAIOU",[[1,1796,"\n"]],[1795,1795],[1796,1796]]],[1566612230115,["GJX@GJXAIOU",[[1,1797,"\n"]],[1796,1796],[1797,1797]]],[1566612230276,["GJX@GJXAIOU",[[1,1798,"\n"]],[1797,1797],[1798,1798]]],[1566612232454,["GJX@GJXAIOU",[[1,1797,"jsp其实可以看做一种脚本语言，需要用servlet来编译实现，然而作为一种脚本语言它有相当强大，在其中可以嵌入java代码，jsp中几乎可以使用全部的java类 。其实就是可以把jsp当做html来作为网页显示出来，而且其上还可以嵌套java语言，也可以嵌套其他的语言类似，当然都序言用servlet来编译实现。jsp作为字节码文件执行后可以直接运行，不必每次都要编译，速度快。可能我表述还是有点问题，但是jsp和js大多都应用于web网页的编写上，jsp可以看做html和java的结合体，当然js就可以在jsp上实现一些动作，特效，验证功能，与在html中所实现的效果一样。因为jsp是在服务器端解释执行的，服务器执行转化后的.class程序，客户端接收到的只是服务器发来的html代码，看不到jsp代码。而js可以在客户端通过查看源代码显示出来。"]],[1797,1797],[2174,2174]]],[1566612242668,["GJX@GJXAIOU",[[1,1849,"**"],[1,1859,"**"]],[1849,1859],[1849,1863]]],[1566612298298,["GJX@GJXAIOU",[[1,2180,"\n"]],[2178,2178],[2179,2179]]],[1566612301003,["GJX@GJXAIOU",[[1,2179,"jsp只是相当于java里面的servlet部分"]],[2179,2179],[2203,2203]]],[1566612302747,["GJX@GJXAIOU",[[1,2179,"\n"]],[2179,2179],[2180,2180]]],[1566612556243,["GJX@GJXAIOU",[[1,2537,"\n"]],[2534,2534],[2535,2535]]],[1566612556355,["GJX@GJXAIOU",[[1,2538,"\n"]],[2535,2535],[2536,2536]]],[1566612557234,["GJX@GJXAIOU",[[1,2536,"**1\\. JavaScript**\n\nJavaScript（简称js）是一种主要运行于浏览器中的弱类型的动态脚本语言，可以用来实现网页上的一些高级功能，如数据验证处理、页面动态效果、定时任务、与用户交互、发送/接收服务器端数据等等。\n\n动态语言指的是程序运行时可以改变结构，主要体现在：\n① js中的变量在声明的时候不需要指定类型，其实际类型由程序运行中的赋值决定，在运行过程中变量的类型也可以改变。**注：这一点是动态语言的特征，并不是弱类型语言的特征，之前的回答有误。**\n② 函数可变。js允许在运行过程中使用eval动态执行字符串里的命令，也可以通过new Function等方式由字符串动态构造函数，函数可以被创建、修改、删除，可以从已有函数构造出新函数，等等。\n③ 对象的成员可变，可以动态添加、删除成员属性或成员方法。\n\n弱类型指的是js中的变量在参与运算的时候可以根据实际需要动态转换类型。与之相对应的是强类型语言——变量一般不允许自动转换类型（某些强类型语言的字符串连接操作除外），如果参与运算、调用时不符合要求的类型，则会在编译阶段报错。\n\njs是1995年由Netscape公司的Brendan Eich为自家的浏览器Netscape Navigator开发的，当时意图是用于网页上的表单验证，即验证表单的各个输入项是否符合预定规则，在验证通过后才向服务器提交表单内容，减少页面与服务器端不必要的频繁交互。\n\njs的最初版本只用了10天就开发完成，当然不是完全从无到有，而是借鉴了其他一些语言的特性来开发。如此仓促开发，js自然有一些先天不足，但同时也具备了基于弱类型动态语言的方便灵活、对象原型继承、函数是一种特殊的对象等优秀特性，于是越来越得到广泛应用，而语言自身也在标准化组织的推动下不断发展进步。\n\n在浏览器发展的早期，Microsoft仿造JavaScript推出了相似的脚本语言JScript，在IE浏览器中使用，Microsoft同时推出的还有VBScript。后来为了解决不同浏览器中脚本语言不兼容的问题，在ECMA（欧洲计算机制造商协会）成立了标准化小组，由各厂商参与，共同制定JavaScript的语言规范，规范化的这门语言被命名为ECMAScript。\n\njs也可以在浏览器之外的其他场合使用，如服务器端的Node.js、java的Rhino、无界面浏览器PhantomJS等。\n\n**2\\. jQuery**\n\njQuery是js的一个工具库，由John Resig在2006年发布。\nj代表JavaScript，query是“查询”的意思。也就是说，这个库的意图是基于JavaScript的查询。\n查询的目标是什么？答案是DOM（文档对象模型）结构中的Node（节点）。一个网页就是一个html文档，而网页上的所有内容都是节点，包括文档节点、元素节点、文本节点、注释节点、属性节点等等。而jQuery的查询最主要针对的是元素节点，如段落（p）、锚点（a）、表格（table）等，只有少数方法可以处理文本节点与注释节点。同时jQuery还可以用attr方法方便地对元素节点的属性进行读取/设置。\n\n在jQuery出现之前，在js程序中获取元素节点比较麻烦，例如获取id为elem1的节点：\n\n```js\ndocument.getElementById('elem1')\n\n```\n\n或者是获取页面上的所有checkbox元素，首先需要获取input类型的元素：\n\n```js\ndocument.getElementsByTagName('input')\n\n```\n\n然后对获得的元素列表进行for循环处理，逐个判断其类型是否为checkbox。\n如果有更多元化的查询要求，则对应的js代码也会相当复杂。虽然有一些库可以解决这方面的需求，但强大程度、易用性等方面都不太理想。\n\nJohn Resig发现了一个盲点——css样式应用到页面上的元素时，是有一套规则的，即css选择器，浏览器可以通过css选择器找到匹配的元素并将指定的样式应用到这些元素上。也就是说，通过css选择器可以有效地进行元素查找定位，但它最初只被用于样式领域。于是，John Resig根据css选择器编写了jQuery选择器，并对选择器的规则进行了扩充，从而让元素查找变得非常方便。例如，上面2个例子用jQuery可以写为：\n\n```js\n$('#elem1')\n\n```\n\n与\n\n```js\n$(\":checkbox\")\n\n```\n\n同时，jQuery还有一个核心思想——链式操作，例如：\n\n```js\n$('div.con')\n    .height(100)\n    .show();\n\n```\n\n这样的连续调用可以让代码书写更加简洁，也就是jQuery自己的口号：write less, do more。\n\n此外，jQuery还提供了浏览器兼容、样式读写、事件绑定与执行、动画等特性，后来又加入了ajax、promise等，再加上方便的插件编写机制，对整个js的生态圈产生了重大的影响，可以说是js历史上影响力最大的一个库。其中选择器引擎后来被单独剥离出来成为sizzle，供其他的js库调用。这部分的工作还影响了官方，在jQuery成功之后，浏览器才有了querySelector与querySelectorAll方法。时至今日，虽然有了querySelector与querySelectorAll，但jQuery的选择器仍然有少部分特性是前2者所无法替代的。\n\n**3\\. ajax**\n\najax全称Asynchronous JavaScript and XML（异步的JavaScript与XML），是网页无需刷新页面、使用js与服务器进行交互的一种技术。\n\n有时候会有这样一种需求：只希望更改页面上的一个区域。然而在从前的技术框架内只能刷新整个页面，带来的后果是：①需要重新传输整个页面，服务器端与客户端的流量消耗都会比较大；②如果是动态页，服务器端需要重新生成整个页面，即使是那些客户原本不想要刷新的区域，增大了服务器的负担。\n\nGoogle的Jesse James Garrett在2005年初发表了一篇文章，提供了解决这种需求的技术方案，也就是ajax。实际上这是一种实践先行的技术，该方案的技术依赖之一XMLHTTP在1998年就已经被Microsoft开发出来了，而Google在若干年后使用这项技术开发Google Maps等产品之后，才发表了相应的文章并对其进行了命名。\n\najax的基本流程可以概括为：页面上js脚本实例化一个XMLHttpRequest对象，设置好服务器端的url、必要的查询参数、回调函数之后，向服务器发出请求，服务器在处理请求之后将处理结果返回给页面，触发事先绑定的回调函数。这样，页面脚本如果想要改变一个区域的内容，只需要通过ajax向服务器获取与该区域有关的少量数据，在回调函数中将该区域的内容替换掉即可，不需要刷新整个页面。\n\nXMLHttpRequest在发送请求的时候，有两种方式：同步与异步。同步方式是请求发出后，一直到收到服务器返回的数据为止，浏览器进程被阻塞，页面上什么事也做不了。而异步方式则不会阻塞浏览器进程，在服务端返回数据并触发回调函数之前，用户依然可以在该页面上进行其他操作。ajax的核心是异步方式，而同步方式只有在极其特殊的情况下才会被用到。\n\nXMLHttpRequest在早期IE浏览器里是使用ActiveX来实现的，并不是浏览器自身的对象。后来其他各家浏览器也都实现了XMLHttpRequest对象，而高版本IE也把XMLHttpRequest改为了浏览器的内建对象。\n\n**4\\. JSON**\n\nJSON全称JavaScript Object Notation（js对象标记法），由Douglas Crockford在2002年发现并制定了标准。从名称上就可以看出来，JSON是基于JavaScript的，是JavaScript的一个子集。JSON是用JavaScript语法来表示数据的一种轻量级语言。\n\n虽然Douglas在2002年就注册了[http://json.org](https://link.zhihu.com/?target=http%3A//json.org)，并且为各种语言编写了解析与构造JSON数据的库，但在最开始的几年JSON一直没有得到足够的重视。情况一直延续到ajax的出现。\n\n从ajax的命名中我们就可以看到，数据交换是通过XML格式进行的。在ajax刚出现的时候，绝大多数应用都是采用XML格式，也有少数使用纯文本的。但是XML格式有一个缺点，就是文档构造复杂，需要传输比较多的字节数。在这种情况下，JSON的轻便性逐渐得到重视，后来替代XML成为ajax最主要的数据传输格式。可以举个简单的例子感受一下二者的区别：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<root>\n  <article>\n    <title>Article Title1</title>\n    <content>content1</content>\n  </article>\n  <article>\n    <title>Article Title2</title>\n    <content>content2</content>\n  </article>\n</root>\n```\n\n```json\n{\n  \"article\" : [\n    {\n      \"title\": \"Article Title1\",\n      \"content\": \"content1\"\n    },\n    {\n      \"title\": \"Article Title2\",\n      \"content\": \"content2\"\n    }\n  ]\n}\n```\n\nXML规范实际上是比较复杂的，单纯作为数据传输来说它太重了。在ajax领域中JSON取代XML的过程，是一个很好的“用脚投票”的范例。\n\n而JSON的影响力在此后还继续扩大，有些软件将其作为配置文件的格式，有些编程语言也吸纳了JSON的优点。例如c#，在高版本里可以这样写：\n\n```csharp\nDictionary<int, string> dict = new Dictionary<int, string>{\n    {1, \"a\"},\n    {2, \"b\"}\n};\n\n```\n\n但是如果c# 2.0这样写，可是会报错的。在2.0里只能写成下面这种形式：\n\n```csharp\nDictionary<int, string> dict = new Dictionary<int, string>();\ndict.Add(1, \"a\");\ndict.Add(2, \"b\");\n\n```\n\n等价于\n\n```csharp\nDictionary<int, string> dict = new Dictionary<int, string>();\ndict[1] = \"a\";\ndict[2] = \"b\";\n\n```\n\n比较一下两种写法的区别，不仅有便捷性的差距，而且前一种写法可以在声明变量的同时为变量赋值，后一种写法则不行，这会影响到类属性的初始化操作：在c# 2.0中，只能把针对Dictionary之类复杂对象的初始化代码写在函数里，而不能直接写在类属性的声明处。\n\n感觉上是c#受了JSON（或者说js）的影响。但此处是我个人的感觉，如有错误请指出。\n\n回到js自身，对于对象构造有两种方法：基于对象的完整写法，字面量表示法。前者如：\n\n```js\nvar obj = new Object();\nobj.title = \"title1\";\nobj.content = \"content1\";\n\n```\n\n而与之对应的字面量表示法则写为：\n\n```js\nvar obj = {\n    title: \"title1\",\n    content: \"content1\"\n};\n\n```\n\n可以明显看出字面量表示法要简洁得多。而JSON基本就是字面量表示法的一个子集，除了强制要求键与字符串类型的值必须用双引号包起之外，它剔除了undefined、function等类型，也不包括浏览器内置对象类型（如Date、RegExp等），是基于文本的、比较纯粹的数据表示方法。所以说，Douglas是“发现”了JSON，而不是“发明”。标准的JSON不包含注释，但后来因为实际需求而出现了能够处理注释的JSON库。\n\n**5\\. Node.js**\n\nNode.js是Ryan Dahl在2009年发布的、主要用于服务器端的Javascript运行环境，也可以用于个人电脑。\nRyan Dahl此前一直在寻找一种事件驱动型的、异步的服务器端框架，实际上，js并不是他的首选。他是在尝试了几种语言之后，才发现js的函数回调与单线程特性正好契合他的要求，于是Node.js应运而生。\njs的异步回调在ajax的部分已经提过：在调用异步方法的时候，可以将后续的处理函数作为参数传入，在调用相应的异步接口之后，程序会将线程的控制权让出，允许其他代码执行；在接口返回处理结果后，再执行后续处理函数（即回调函数）。实际上，因为js是单线程语言，回调函数并不是立刻被执行的，而是会被送入任务队列，在线程空闲、并且队列前方没有其他任务的情况下，才会被执行。\n\n用户在向服务器提交请求的时候，如果处理比较费时，传统的服务器端框架会导致处理线程被阻塞。而js的特性使得异步任务在执行的时候让出线程的控制权，在处理完成后再进行正确的回调，从而能够获得比较好的高并发处理能力。\njs本身是一门严格的单线程语言，而Node.js为了充分发挥服务器的处理能力，在运行环境级别上增加了对于多线程的支持（child process）。但Node.js的多线程与常规的多线程有很大区别——常规语言的多线程允许多个线程共享数据，或者调用其他线程暴露出来的公开方法，而Node.js的多线程只能用消息机制进行通讯。这样，Node.js就规避了常规多线程的数据同步、线程锁（线程同步/互斥）等复杂问题，规避了一些潜在风险。\n\nNode.js使用的V8引擎实际上就是Google的Chrome浏览器使用的Javascript引擎（因为V8引擎是开源的），并进行了模块扩展。例如遵循CommonJS标准的模块定义，适合服务器需求的多线程、集群、HTTP/HTTPS，文件系统，等等。Node.js中的很多方法都同时提供了异步版本与同步版本，从函数的命名上可以简单区分。\n得益于其模块特性，Node.js的模块扩展变得相当方便，用于Node.js包管理的npm得到了广泛的使用，但也曾经引起“是否过度使用依赖包”的争论。\n\nNode.js不仅可用于服务器端，因为其安装完成之后可以用命令行方式方便地调用，因此在个人电脑中也逐渐得到广泛应用。例如为代码编辑器提供插件、用于桌面的Node.js App等。另外还有一个重要的应用领域就是前端自动化，包括代码的预编译/转换（如使用Babel将ECMAScript 6的代码转换为低版本的es代码，将sass/less的样式表文件编译为传统的css文件）、语法检查、代码文件或图像文件的合并、代码的混淆/压缩、自动分发、自动测试等，还可以监视开发文件夹，在内容改变时自动执行上述操作，并自动刷新浏览器页面。这样使得前端领域的开发方式得到了大大进化。\n\njs虽然因为有着一些先天不足而被人诟病，但这些年来却越发展越壮大。这不仅仅是因为依托于浏览器这个宿主环境，更是因为其自身具备的一些优秀特性，Node.js的出现与发展就是一个很好的例证。\n\n**总结**\n\najax与Node.js都使用了js的异步回调特性。\njQuery的出现解决了那个各方面标准尚未统一的混乱时代的许多问题，让js的应用更加广泛，并为未来某些标准的制定指明了方向。\nJSON从js中脱胎而出，作为一种简洁、扩展性好的轻量级数据表示方法，在很多领域得到了广泛使用。\nNode.js在服务器端与开发流程中都越来越得到重视。\n由于Node.js不包含BOM与DOM，因此jQuery不能直接在Node.js上使用，但可以借助jsdom、cheerio之类的库，在构造出虚拟的dom结构后再使用。查看github上的jQuery开发包，可以看到它使用了Node.js上的grunt来进行自动化构建、测试的工作。\n以上几项技术的共同进步，配合浏览器的进步，此外还有硬件条件的发展，让复杂的页面应用越来越多，许多以前在服务器端进行的工作可以转到客户的浏览器中进行，顺应了分布式处理的潮流。\n\n[于江水](https://www.zhihu.com/people/69ed13f3ddc662d6ecd8261512117e85)\n\n**的答案存在一些错误或者不严谨之处：**\n\n1\\. js设计之初并不是用来弹窗或者改变页面上内容，这些功能是随着浏览器的发展才出现的。实际上js语言自身并不能实现这样的需求。\n\n完整的JavaScript包括ECMAScript、BOM（浏览器对象模型，如window、location等对象）、DOM。其中BOM和DOM虽然是js的组成部分，但js只规定了这两者的接口规范，即浏览器返回这两类对象时，可以用js的方式来处理（点号或者方括号来操作对象成员，可以读取或修改属性等）。也就是说，js脚本通过浏览器提供的接口去操作BOM和DOM，js在其中主要进行流程控制。没有这些接口的支持，js自身是无法完成一些功能的。而早期各家浏览器对于接口实现的不同，也带来了比较严重的兼容性问题。\n\n从js的标准化工作也能看出之间的不同。ECMAScript是由ECMA来进行标准化工作，而BOM和DOM则是由W3C（World Wide Web Consortium）来进行标准化的。\n\n2\\. jQuery设计的第一要素是对于节点的查询。解决兼容性问题也是jQuery设计的重点，但不是第一位的。当时在尝试解决兼容性问题的js库有好几个，jQuery在这方面并不唯一。而jQuery选择器才是jQuery划时代的特性，从早已存在的事物（css选择器）中发现了价值，并将其修改扩充、发扬光大。\n\n不可否认，jQuery的流行很大程度上要归功于解决兼容性问题，但作为名称中包含的“query”连提都不提，这答案有点偏了。\n\n3\\. ajax创建之初是用于处理Gmail、Google Maps这样的复杂页面应用，表单提交方式的改变只是ajax技术发展的一个副产品而已。\n\n并且表单提交的问题并不仅仅在于填错项目，实际面临的问题要复杂得多，包括用户的网络掉线、服务器端因为请求过多而暂时无法响应等不可抗因素。在传统模式下，提交表单是前往一个新的动态页，如果出现了错误，运气好的时候点浏览器的“后退”按钮还可以返回表单填写界面，刚才写的东西都还在；运气不好的时候，只会看见一个空白的表单。当时在一些论坛里，总能看到“辛辛苦苦码的字一提交就全没了”的哭诉。\n\n4\\. 对于JSON的用途描述有错。原答案中提到提交内容简单的时候，用字符串发送，后来改为XML与JSON。实际上，JSON用于客户端（包括浏览器）与服务端通讯的时候，主要指的是服务器端返回处理结果时送回给客户端的数据格式是JSON。而客户端提交给服务器端的数据大多数并不是XML或JSON格式的。\n\n客户端向服务器端提交数据的时候，使用GET或POST方法，其数据一般是简单的“键/值对”表示，例如常见的GET方法在url中构造的参数：\n\n```text\n?page=1&pagesize=20\n\n```\n\nPOST方法在提交一般类型的表单时，与GET方法在数据组织形式上基本相近（除非是用multipart类型的表单发送文件数据），但http数据包格式、浏览器历史记录、以及服务器端接收处理有所区别，这属于http协议的内容，此处不展开。\n因此，客户端向服务器端提交数据的时候，主要是采用字符串拼接的方式按上述例子构造，一般不会使用XML或者JSON格式，特别是在ajax出现的早期。（近年来随着页面应用越来越复杂，用JSON格式向服务器端传递数据的情况也逐渐增加）\n而服务器端返回给客户端的数据格式，一开始的主流就是XML，不存在以字符串为主然后过渡到XML的过程。\n另外，XMLHTTP还可以用来进行服务器间通讯，早期发送与接收数据的主流格式都是XML，但是这与ajax不是一回事。"]],[2536,2536],[11067,11067]]],[1566612569683,["GJX@GJXAIOU",[[-1,2556,"JavaScript（简称js）是一种主要运行于浏览器中的弱类型的动态脚本语言，可以用来实现网页上的一些高级功能，如数据验证处理、页面动态效果、定时任务、与用户交互、发送/接收服务器端数据等等。\n\n动态语言指的是程序运行时可以改变结构，主要体现在：\n① js中的变量在声明的时候不需要指定类型，其实际类型由程序运行中的赋值决定，在运行过程中变量的类型也可以改变。**注：这一点是动态语言的特征，并不是弱类型语言的特征，之前的回答有误。**\n② 函数可变。js允许在运行过程中使用eval动态执行字符串里的命令，也可以通过new Function等方式由字符串动态构造函数，函数可以被创建、修改、删除，可以从已有函数构造出新函数，等等。\n③ 对象的成员可变，可以动态添加、删除成员属性或成员方法。\n\n弱类型指的是js中的变量在参与运算的时候可以根据实际需要动态转换类型。与之相对应的是强类型语言——变量一般不允许自动转换类型（某些强类型语言的字符串连接操作除外），如果参与运算、调用时不符合要求的类型，则会在编译阶段报错。\n\njs是1995年由Netscape公司的Brendan Eich为自家的浏览器Netscape Navigator开发的，当时意图是用于网页上的表单验证，即验证表单的各个输入项是否符合预定规则，在验证通过后才向服务器提交表单内容，减少页面与服务器端不必要的频繁交互。\n\njs的最初版本只用了10天就开发完成，当然不是完全从无到有，而是借鉴了其他一些语言的特性来开发。如此仓促开发，js自然有一些先天不足，但同时也具备了基于弱类型动态语言的方便灵活、对象原型继承、函数是一种特殊的对象等优秀特性，于是越来越得到广泛应用，而语言自身也在标准化组织的推动下不断发展进步。\n\n在浏览器发展的早期，Microsoft仿造JavaScript推出了相似的脚本语言JScript，在IE浏览器中使用，Microsoft同时推出的还有VBScript。后来为了解决不同浏览器中脚本语言不兼容的问题，在ECMA（欧洲计算机制造商协会）成立了标准化小组，由各厂商参与，共同制定JavaScript的语言规范，规范化的这门语言被命名为ECMAScript。\n\njs也可以在浏览器之外的其他场合使用，如服务器端的Node.js、java的Rhino、无界面浏览器PhantomJS等。"]],[2556,3548],[2556,2556]]],[1566612576227,["GJX@GJXAIOU",[[1,1770,"\n"]],[1768,1768],[1769,1769]]],[1566612576355,["GJX@GJXAIOU",[[1,1771,"\n"]],[1769,1769],[1770,1770]]],[1566612576491,["GJX@GJXAIOU",[[1,1772,"\n"]],[1770,1770],[1771,1771]]],[1566612576685,["GJX@GJXAIOU",[[1,1773,"\n"]],[1771,1771],[1772,1772]]],[1566612576798,["GJX@GJXAIOU",[[1,1774,"\n"]],[1772,1772],[1773,1773]]],[1566612576876,["GJX@GJXAIOU",[[1,1775,"\n"]],[1773,1773],[1774,1774]]],[1566612576995,["GJX@GJXAIOU",[[1,1776,"\n"]],[1774,1774],[1775,1775]]],[1566612577125,["GJX@GJXAIOU",[[1,1777,"\n"]],[1775,1775],[1776,1776]]],[1566612577243,["GJX@GJXAIOU",[[1,1778,"\n"]],[1776,1776],[1777,1777]]],[1566612577362,["GJX@GJXAIOU",[[1,1779,"\n"]],[1777,1777],[1778,1778]]],[1566612579861,["GJX@GJXAIOU",[[1,1770,"JavaScript（简称js）是一种主要运行于浏览器中的弱类型的动态脚本语言，可以用来实现网页上的一些高级功能，如数据验证处理、页面动态效果、定时任务、与用户交互、发送/接收服务器端数据等等。\n\n动态语言指的是程序运行时可以改变结构，主要体现在：\n① js中的变量在声明的时候不需要指定类型，其实际类型由程序运行中的赋值决定，在运行过程中变量的类型也可以改变。**注：这一点是动态语言的特征，并不是弱类型语言的特征，之前的回答有误。**\n② 函数可变。js允许在运行过程中使用eval动态执行字符串里的命令，也可以通过new Function等方式由字符串动态构造函数，函数可以被创建、修改、删除，可以从已有函数构造出新函数，等等。\n③ 对象的成员可变，可以动态添加、删除成员属性或成员方法。\n\n弱类型指的是js中的变量在参与运算的时候可以根据实际需要动态转换类型。与之相对应的是强类型语言——变量一般不允许自动转换类型（某些强类型语言的字符串连接操作除外），如果参与运算、调用时不符合要求的类型，则会在编译阶段报错。\n\njs是1995年由Netscape公司的Brendan Eich为自家的浏览器Netscape Navigator开发的，当时意图是用于网页上的表单验证，即验证表单的各个输入项是否符合预定规则，在验证通过后才向服务器提交表单内容，减少页面与服务器端不必要的频繁交互。\n\njs的最初版本只用了10天就开发完成，当然不是完全从无到有，而是借鉴了其他一些语言的特性来开发。如此仓促开发，js自然有一些先天不足，但同时也具备了基于弱类型动态语言的方便灵活、对象原型继承、函数是一种特殊的对象等优秀特性，于是越来越得到广泛应用，而语言自身也在标准化组织的推动下不断发展进步。\n\n在浏览器发展的早期，Microsoft仿造JavaScript推出了相似的脚本语言JScript，在IE浏览器中使用，Microsoft同时推出的还有VBScript。后来为了解决不同浏览器中脚本语言不兼容的问题，在ECMA（欧洲计算机制造商协会）成立了标准化小组，由各厂商参与，共同制定JavaScript的语言规范，规范化的这门语言被命名为ECMAScript。\n\njs也可以在浏览器之外的其他场合使用，如服务器端的Node.js、java的Rhino、无界面浏览器PhantomJS等。"]],[1770,1770],[2762,2762]]],[1566612601876,["GJX@GJXAIOU",[[-1,1827,"如数据验证处理、页面动态效果、定时任务、与用户交互、发送/接收服务器端数据等等。"]],[1827,1867],[1827,1827]]],[1566612603963,["GJX@GJXAIOU",[[1,1368,"如数据验证处理、页面动态效果、定时任务、与用户交互、发送/接收服务器端数据等等。"]],[1368,1368],[1408,1408]]],[1566612611412,["GJX@GJXAIOU",[[1,1307,"r"]],[1307,1307],[1308,1308]]],[1566612612117,["GJX@GJXAIOU",[[1,1307," "],[1,1308," uole"]],[1308,1308],[1313,1313]]],[1566612613947,["GJX@GJXAIOU",[[-1,1308,"ruole "]],[1313,1313],[1307,1307]]],[1566612615339,["GJX@GJXAIOU",[[-1,1307," "]],[1308,1308],[1307,1307]]],[1566612627477,["GJX@GJXAIOU",[[1,1307,"弱类型的动态"]],[1307,1307],[1313,1313]]],[1566612634458,["GJX@GJXAIOU",[[-1,1816,"JavaScript（简称js）是一种主要运行于浏览器中的弱类型的动态脚本语言，可以用来实现网页上的一些高级功能，"]],[1816,1873],[1816,1816]]],[1566612638786,["GJX@GJXAIOU",[[-1,1817,"\n"]],[1817,1817],[1816,1816]]],[1566612638994,["GJX@GJXAIOU",[[-1,1816,"\n"]],[1816,1816],[1815,1815]]],[1566612642469,["GJX@GJXAIOU",[[1,1816,"**"],[1,1820,"**"]],[1816,1820],[1816,1824]]],[1566612645765,["GJX@GJXAIOU",[[-1,1846,"① "]],[1846,1848],[1846,1846]]],[1566612646244,["GJX@GJXAIOU",[[1,1846,"- "]],[1846,1846],[1848,1848]]],[1566612662362,["GJX@GJXAIOU",[[-1,1929,"，之前的回答有误"]],[1929,1937],[1929,1929]]],[1566612751755,["GJX@GJXAIOU",[[-1,1933,"② "]],[1933,1935],[1933,1933]]],[1566612752221,["GJX@GJXAIOU",[[1,1933,"- "]],[1933,1933],[1935,1935]]],[1566612755666,["GJX@GJXAIOU",[[-1,2031,"③ "]],[2031,2033],[2031,2031]]],[1566612756175,["GJX@GJXAIOU",[[1,2031,"- "]],[2031,2031],[2033,2033]]],[1566612761146,["GJX@GJXAIOU",[[1,2062,"**"],[1,2065,"**"]],[2062,2065],[2062,2069]]],[1566612827612,["GJX@GJXAIOU",[[-1,2179,"js是1995年由Netscape公司的Brendan Eich为自家的浏览器Netscape Navigator开发的，当时意图是用于网页上的表单验证，即验证表单的各个输入项是否符合预定规则，在验证通过后才向服务器提交表单内容，减少页面与服务器端不必要的频繁交互。\n\njs的最初版本只用了10天就开发完成，当然不是完全从无到有，而是借鉴了其他一些语言的特性来开发。如此仓促开发，js自然有一些先天不足，但同时也具备了基于弱类型动态语言的方便灵活、对象原型继承、函数是一种特殊的对象等优秀特性，于是越来越得到广泛应用，而语言自身也在标准化组织的推动下不断发展进步。\n\n在浏览器发展的早期，Microsoft仿造JavaScript推出了相似的脚本语言JScript，在IE浏览器中使用，Microsoft同时推出的还有VBScript。后来为了解决不同浏览器中脚本语言不兼容的问题，在ECMA（欧洲计算机制造商协会）成立了标准化小组，由各厂商参与，共同制定JavaScript的语言规范，规范化的这门语言被命名为ECMAScript。"]],[2180,2646],[2179,2179]]],[1566612830395,["GJX@GJXAIOU",[[-1,2180,"\n"]],[2180,2180],[2179,2179]]],[1566612830771,["GJX@GJXAIOU",[[-1,2179,"\n"]],[2179,2179],[2178,2178]]],[1566612845707,["GJX@GJXAIOU",[[-1,3038,"**2\\. jQuery**\n\njQuery是js的一个工具库，由John Resig在2006年发布。\nj代表JavaScript，query是“查询”的意思。也就是说，这个库的意图是基于JavaScript的查询。\n查询的目标是什么？答案是DOM（文档对象模型）结构中的Node（节点）。一个网页就是一个html文档，而网页上的所有内容都是节点，包括文档节点、元素节点、文本节点、注释节点、属性节点等等。而jQuery的查询最主要针对的是元素节点，如段落（p）、锚点（a）、表格（table）等，只有少数方法可以处理文本节点与注释节点。同时jQuery还可以用attr方法方便地对元素节点的属性进行读取/设置。\n\n在jQuery出现之前，在js程序中获取元素节点比较麻烦，例如获取id为elem1的节点：\n\n```js\ndocument.getElementById('elem1')\n\n```\n\n或者是获取页面上的所有checkbox元素，首先需要获取input类型的元素：\n\n```js\ndocument.getElementsByTagName('input')\n\n```\n\n然后对获得的元素列表进行for循环处理，逐个判断其类型是否为checkbox。\n如果有更多元化的查询要求，则对应的js代码也会相当复杂。虽然有一些库可以解决这方面的需求，但强大程度、易用性等方面都不太理想。\n\nJohn Resig发现了一个盲点——css样式应用到页面上的元素时，是有一套规则的，即css选择器，浏览器可以通过css选择器找到匹配的元素并将指定的样式应用到这些元素上。也就是说，通过css选择器可以有效地进行元素查找定位，但它最初只被用于样式领域。于是，John Resig根据css选择器编写了jQuery选择器，并对选择器的规则进行了扩充，从而让元素查找变得非常方便。例如，上面2个例子用jQuery可以写为：\n\n```js\n$('#elem1')\n\n```\n\n与\n\n```js\n$(\":checkbox\")\n\n```\n\n同时，jQuery还有一个核心思想——链式操作，例如：\n\n```js\n$('div.con')\n    .height(100)\n    .show();\n\n```\n\n这样的连续调用可以让代码书写更加简洁，也就是jQuery自己的口号：write less, do more。\n\n此外，jQuery还提供了浏览器兼容、样式读写、事件绑定与执行、动画等特性，后来又加入了ajax、promise等，再加上方便的插件编写机制，对整个js的生态圈产生了重大的影响，可以说是js历史上影响力最大的一个库。其中选择器引擎后来被单独剥离出来成为sizzle，供其他的js库调用。这部分的工作还影响了官方，在jQuery成功之后，浏览器才有了querySelector与querySelectorAll方法。时至今日，虽然有了querySelector与querySelectorAll，但jQuery的选择器仍然有少部分特性是前2者所无法替代的。"]],[3038,4319],[3038,3038]]],[1566612854539,["GJX@GJXAIOU",[[1,2242,"**2\\. jQuery**\n\njQuery是js的一个工具库，由John Resig在2006年发布。\nj代表JavaScript，query是“查询”的意思。也就是说，这个库的意图是基于JavaScript的查询。\n查询的目标是什么？答案是DOM（文档对象模型）结构中的Node（节点）。一个网页就是一个html文档，而网页上的所有内容都是节点，包括文档节点、元素节点、文本节点、注释节点、属性节点等等。而jQuery的查询最主要针对的是元素节点，如段落（p）、锚点（a）、表格（table）等，只有少数方法可以处理文本节点与注释节点。同时jQuery还可以用attr方法方便地对元素节点的属性进行读取/设置。\n\n在jQuery出现之前，在js程序中获取元素节点比较麻烦，例如获取id为elem1的节点：\n\n```js\ndocument.getElementById('elem1')\n\n```\n\n或者是获取页面上的所有checkbox元素，首先需要获取input类型的元素：\n\n```js\ndocument.getElementsByTagName('input')\n\n```\n\n然后对获得的元素列表进行for循环处理，逐个判断其类型是否为checkbox。\n如果有更多元化的查询要求，则对应的js代码也会相当复杂。虽然有一些库可以解决这方面的需求，但强大程度、易用性等方面都不太理想。\n\nJohn Resig发现了一个盲点——css样式应用到页面上的元素时，是有一套规则的，即css选择器，浏览器可以通过css选择器找到匹配的元素并将指定的样式应用到这些元素上。也就是说，通过css选择器可以有效地进行元素查找定位，但它最初只被用于样式领域。于是，John Resig根据css选择器编写了jQuery选择器，并对选择器的规则进行了扩充，从而让元素查找变得非常方便。例如，上面2个例子用jQuery可以写为：\n\n```js\n$('#elem1')\n\n```\n\n与\n\n```js\n$(\":checkbox\")\n\n```\n\n同时，jQuery还有一个核心思想——链式操作，例如：\n\n```js\n$('div.con')\n    .height(100)\n    .show();\n\n```\n\n这样的连续调用可以让代码书写更加简洁，也就是jQuery自己的口号：write less, do more。\n\n此外，jQuery还提供了浏览器兼容、样式读写、事件绑定与执行、动画等特性，后来又加入了ajax、promise等，再加上方便的插件编写机制，对整个js的生态圈产生了重大的影响，可以说是js历史上影响力最大的一个库。其中选择器引擎后来被单独剥离出来成为sizzle，供其他的js库调用。这部分的工作还影响了官方，在jQuery成功之后，浏览器才有了querySelector与querySelectorAll方法。时至今日，虽然有了querySelector与querySelectorAll，但jQuery的选择器仍然有少部分特性是前2者所无法替代的。"]],[2242,2242],[3523,3523]]],[1566612856732,["GJX@GJXAIOU",[[-1,2254,"**"]],[2256,2256],[2254,2254]]],[1566612860244,["GJX@GJXAIOU",[[-1,2242,"**2\\. "]],[2248,2248],[2242,2242]]],[1566612861723,["GJX@GJXAIOU",[[1,2242,"### "]],[2242,2242],[2252,2252]]],[1566612900555,["GJX@GJXAIOU",[[-1,2633,"\n"]],[2633,2633],[2632,2632]]],[1566612904803,["GJX@GJXAIOU",[[-1,2593,"\n"]],[2593,2593],[2592,2592]]],[1566612909265,["GJX@GJXAIOU",[[-1,2632,"```"]],[2632,2635],[2632,2632]]],[1566612910882,["GJX@GJXAIOU",[[-1,2593,"```js"]],[2593,2598],[2593,2593]]],[1566612913212,["GJX@GJXAIOU",[[-1,2593,"\n"]],[2594,2594],[2593,2593]]],[1566612913676,["GJX@GJXAIOU",[[-1,2592,"\n"]],[2593,2593],[2592,2592]]],[1566612914650,["GJX@GJXAIOU",[[-1,2591,"："]],[2592,2592],[2591,2591]]],[1566612920822,["GJX@GJXAIOU",[[1,2591,"：·"]],[2591,2591],[2593,2593]]],[1566612921813,["GJX@GJXAIOU",[[-1,2592,"·"]],[2593,2593],[2592,2592]]],[1566612922644,["GJX@GJXAIOU",[[1,2592,"`"]],[2592,2592],[2593,2593]]],[1566612927654,["GJX@GJXAIOU",[[1,2625,"`"]],[2625,2625],[2626,2626]]],[1566612932676,["GJX@GJXAIOU",[[1,2560," "]],[2560,2560],[2561,2561]]],[1566612933318,["GJX@GJXAIOU",[[1,2563," "]],[2563,2563],[2564,2564]]],[1566612934334,["GJX@GJXAIOU",[[1,2554," "]],[2554,2554],[2555,2555]]],[1566612935502,["GJX@GJXAIOU",[[1,2548," "]],[2548,2548],[2549,2549]]],[1566612936540,["GJX@GJXAIOU",[[1,2260," "]],[2260,2260],[2261,2261]]],[1566612937356,["GJX@GJXAIOU",[[1,2263," "]],[2263,2263],[2264,2264]]],[1566612938515,["GJX@GJXAIOU",[[-1,2263," "]],[2264,2264],[2263,2263]]],[1566612939347,["GJX@GJXAIOU",[[1,2262," "]],[2262,2262],[2263,2263]]],[1566612940084,["GJX@GJXAIOU",[[1,2265," "]],[2265,2265],[2266,2266]]],[1566612942173,["GJX@GJXAIOU",[[1,2274," "]],[2274,2274],[2275,2275]]],[1566612943110,["GJX@GJXAIOU",[[1,2285," "]],[2285,2285],[2286,2286]]],[1566612944493,["GJX@GJXAIOU",[[1,2299," "]],[2299,2299],[2300,2300]]],[1566612945228,["GJX@GJXAIOU",[[1,2297," "]],[2297,2297],[2298,2298]]],[1566612946603,["GJX@GJXAIOU",[[1,2317," "]],[2317,2317],[2318,2318]]],[1566612948493,["GJX@GJXAIOU",[[1,2341," "]],[2341,2341],[2342,2342]]],[1566612949660,["GJX@GJXAIOU",[[1,2352," "]],[2352,2352],[2353,2353]]],[1566612951260,["GJX@GJXAIOU",[[1,2385," "]],[2385,2385],[2386,2386]]],[1566612952628,["GJX@GJXAIOU",[[1,2370," "]],[2370,2370],[2371,2371]]],[1566612955444,["GJX@GJXAIOU",[[1,2408," "]],[2408,2408],[2409,2409]]],[1566612956476,["GJX@GJXAIOU",[[1,2404," "]],[2404,2404],[2405,2405]]],[1566612959132,["GJX@GJXAIOU",[[1,2457," "]],[2457,2457],[2458,2458]]],[1566612959975,["GJX@GJXAIOU",[[1,2464," "]],[2464,2464],[2465,2465]]],[1566612961814,["GJX@GJXAIOU",[[1,2526," "]],[2526,2526],[2527,2527]]],[1566612962621,["GJX@GJXAIOU",[[1,2533," "]],[2533,2533],[2534,2534]]],[1566612963679,["GJX@GJXAIOU",[[-1,2538,"a"],[1,2539," "]],[2538,2539],[2539,2539]]],[1566612965488,["GJX@GJXAIOU",[[1,2538,"a"],[-1,2538," "]],[2539,2539],[2538,2539]]],[1566612966861,["GJX@GJXAIOU",[[1,2538," "]],[2538,2538],[2539,2539]]],[1566612968117,["GJX@GJXAIOU",[[1,2543," "]],[2543,2543],[2544,2544]]],[1566612972797,["GJX@GJXAIOU",[[-1,2652,"\n"]],[2652,2652],[2651,2651]]],[1566612978100,["GJX@GJXAIOU",[[1,2699,"`"]],[2699,2699],[2700,2700]]],[1566612978878,["GJX@GJXAIOU",[[1,2738,"`"]],[2738,2738],[2739,2739]]],[1566612980578,["GJX@GJXAIOU",[[-1,2741,"```"]],[2741,2744],[2741,2741]]],[1566612983147,["GJX@GJXAIOU",[[-1,2693,"```js"]],[2698,2698],[2693,2693]]],[1566612983596,["GJX@GJXAIOU",[[-1,2693,"\n"]],[2693,2693],[2692,2692]]],[1566612984146,["GJX@GJXAIOU",[[-1,2692,"\n"]],[2692,2692],[2691,2691]]],[1566612987393,["GJX@GJXAIOU",[[-1,2735,"\n"]],[2735,2735],[2734,2734]]],[1566612987797,["GJX@GJXAIOU",[[-1,2734,"\n"]],[2734,2734],[2733,2733]]],[1566612993556,["GJX@GJXAIOU",[[1,2746," "]],[2746,2746],[2747,2747]]],[1566612994315,["GJX@GJXAIOU",[[1,2750," "]],[2750,2750],[2751,2751]]],[1566612995396,["GJX@GJXAIOU",[[1,2766," "]],[2766,2766],[2767,2767]]],[1566612997594,["GJX@GJXAIOU",[[-1,2733,"\n"]],[2733,2733],[2732,2732]]],[1566613000362,["GJX@GJXAIOU",[[-1,2732,"\n"]],[2733,2733],[2732,2732]]],[1566613003171,["GJX@GJXAIOU",[[-1,2691,"\n"]],[2692,2692],[2691,2691]]],[1566613027297,["GJX@GJXAIOU",[[-1,3051,"```js"]],[3051,3056],[3051,3051]]],[1566613027770,["GJX@GJXAIOU",[[-1,3051,"\n"]],[3051,3051],[3050,3050]]],[1566613028236,["GJX@GJXAIOU",[[-1,3050,"\n"]],[3050,3050],[3049,3049]]],[1566613030660,["GJX@GJXAIOU",[[1,3050,"`"]],[3050,3050],[3051,3051]]],[1566613031277,["GJX@GJXAIOU",[[1,3062,"`"]],[3062,3062],[3063,3063]]],[1566613034334,["GJX@GJXAIOU",[[1,3079,"`"]],[3079,3079],[3080,3080]]],[1566613035142,["GJX@GJXAIOU",[[1,3094,"`"]],[3094,3094],[3095,3095]]],[1566613037157,["GJX@GJXAIOU",[[-1,3097,"```"]],[3097,3100],[3097,3097]]],[1566613037609,["GJX@GJXAIOU",[[-1,3098,"\n"]],[3097,3097],[3096,3096]]],[1566613040940,["GJX@GJXAIOU",[[-1,3065,"```\n\n与\n\n```js"]],[3065,3078],[3065,3065]]],[1566613041425,["GJX@GJXAIOU",[[-1,3065,"\n"]],[3065,3065],[3064,3064]]],[1566613041925,["GJX@GJXAIOU",[[-1,3064,"\n"]],[3064,3064],[3063,3063]]],[1566613044818,["GJX@GJXAIOU",[[-1,3049,"\n"]],[3050,3050],[3049,3049]]],[1566613045805,["GJX@GJXAIOU",[[1,3049," "]],[3049,3049],[3050,3050]]],[1566613047641,["GJX@GJXAIOU",[[-1,3063,"\n"]],[3064,3064],[3063,3063]]],[1566613049716,["GJX@GJXAIOU",[[1,3063," he"]],[3063,3063],[3066,3066]]],[1566613051405,["GJX@GJXAIOU",[[-1,3063," he"]],[3066,3066],[3063,3063]]],[1566613053052,["GJX@GJXAIOU",[[1,3063," he"]],[3063,3063],[3066,3066]]],[1566613054114,["GJX@GJXAIOU",[[-1,3063," he"]],[3066,3066],[3063,3063]]],[1566613054772,["GJX@GJXAIOU",[[1,3063," "]],[3063,3063],[3064,3064]]],[1566613056763,["GJX@GJXAIOU",[[-1,3063," "]],[3064,3064],[3063,3063]]],[1566613058893,["GJX@GJXAIOU",[[1,3063," 和 "]],[3063,3063],[3066,3066]]],[1566613065001,["GJX@GJXAIOU",[[-1,3084,"\n"]],[3084,3084],[3083,3083]]],[1566613067252,["GJX@GJXAIOU",[[-1,3112,"\n"]],[3112,3112],[3111,3111]]],[1566613069578,["GJX@GJXAIOU",[[-1,3166,"\n"]],[3166,3166],[3165,3165]]],[1566613070673,["GJX@GJXAIOU",[[-1,3161,"\n"]],[3161,3161],[3160,3160]]],[1566613101642,["GJX@GJXAIOU",[[-1,4272,"**1\\. JavaScript**"]],[4272,4290],[4272,4272]]],[1566613119835,["GJX@GJXAIOU",[[-1,4278,"**3\\. ajax**\n\najax全称Asynchronous JavaScript and XML（异步的JavaScript与XML），是网页无需刷新页面、使用js与服务器进行交互的一种技术。\n\n有时候会有这样一种需求：只希望更改页面上的一个区域。然而在从前的技术框架内只能刷新整个页面，带来的后果是：①需要重新传输整个页面，服务器端与客户端的流量消耗都会比较大；②如果是动态页，服务器端需要重新生成整个页面，即使是那些客户原本不想要刷新的区域，增大了服务器的负担。\n\nGoogle的Jesse James Garrett在2005年初发表了一篇文章，提供了解决这种需求的技术方案，也就是ajax。实际上这是一种实践先行的技术，该方案的技术依赖之一XMLHTTP在1998年就已经被Microsoft开发出来了，而Google在若干年后使用这项技术开发Google Maps等产品之后，才发表了相应的文章并对其进行了命名。\n\najax的基本流程可以概括为：页面上js脚本实例化一个XMLHttpRequest对象，设置好服务器端的url、必要的查询参数、回调函数之后，向服务器发出请求，服务器在处理请求之后将处理结果返回给页面，触发事先绑定的回调函数。这样，页面脚本如果想要改变一个区域的内容，只需要通过ajax向服务器获取与该区域有关的少量数据，在回调函数中将该区域的内容替换掉即可，不需要刷新整个页面。\n\nXMLHttpRequest在发送请求的时候，有两种方式：同步与异步。同步方式是请求发出后，一直到收到服务器返回的数据为止，浏览器进程被阻塞，页面上什么事也做不了。而异步方式则不会阻塞浏览器进程，在服务端返回数据并触发回调函数之前，用户依然可以在该页面上进行其他操作。ajax的核心是异步方式，而同步方式只有在极其特殊的情况下才会被用到。\n\nXMLHttpRequest在早期IE浏览器里是使用ActiveX来实现的，并不是浏览器自身的对象。后来其他各家浏览器也都实现了XMLHttpRequest对象，而高版本IE也把XMLHttpRequest改为了浏览器的内建对象。"]],[4278,5172],[4278,4278]]],[1566613127829,["GJX@GJXAIOU",[[1,3500,"**3\\. ajax**\n\najax全称Asynchronous JavaScript and XML（异步的JavaScript与XML），是网页无需刷新页面、使用js与服务器进行交互的一种技术。\n\n有时候会有这样一种需求：只希望更改页面上的一个区域。然而在从前的技术框架内只能刷新整个页面，带来的后果是：①需要重新传输整个页面，服务器端与客户端的流量消耗都会比较大；②如果是动态页，服务器端需要重新生成整个页面，即使是那些客户原本不想要刷新的区域，增大了服务器的负担。\n\nGoogle的Jesse James Garrett在2005年初发表了一篇文章，提供了解决这种需求的技术方案，也就是ajax。实际上这是一种实践先行的技术，该方案的技术依赖之一XMLHTTP在1998年就已经被Microsoft开发出来了，而Google在若干年后使用这项技术开发Google Maps等产品之后，才发表了相应的文章并对其进行了命名。\n\najax的基本流程可以概括为：页面上js脚本实例化一个XMLHttpRequest对象，设置好服务器端的url、必要的查询参数、回调函数之后，向服务器发出请求，服务器在处理请求之后将处理结果返回给页面，触发事先绑定的回调函数。这样，页面脚本如果想要改变一个区域的内容，只需要通过ajax向服务器获取与该区域有关的少量数据，在回调函数中将该区域的内容替换掉即可，不需要刷新整个页面。\n\nXMLHttpRequest在发送请求的时候，有两种方式：同步与异步。同步方式是请求发出后，一直到收到服务器返回的数据为止，浏览器进程被阻塞，页面上什么事也做不了。而异步方式则不会阻塞浏览器进程，在服务端返回数据并触发回调函数之前，用户依然可以在该页面上进行其他操作。ajax的核心是异步方式，而同步方式只有在极其特殊的情况下才会被用到。\n\nXMLHttpRequest在早期IE浏览器里是使用ActiveX来实现的，并不是浏览器自身的对象。后来其他各家浏览器也都实现了XMLHttpRequest对象，而高版本IE也把XMLHttpRequest改为了浏览器的内建对象。"]],[3500,3500],[4394,4394]]],[1566613129938,["GJX@GJXAIOU",[[-1,3510,"**"]],[3512,3512],[3510,3510]]],[1566613132828,["GJX@GJXAIOU",[[-1,3500,"**3\\. "]],[3506,3506],[3500,3500]]],[1566613134378,["GJX@GJXAIOU",[[1,3500,"### "]],[3500,3500],[3508,3508]]],[1566613179178,["GJX@GJXAIOU",[[-1,3734,"Google的Jesse James Garrett在2005年初发表了一篇文章，提供了解决这种需求的技术方案，也就是ajax。实际上这是一种实践先行的技术，该方案的技术依赖之一XMLHTTP在1998年就已经被Microsoft开发出来了，而Google在若干年后使用这项技术开发Google Maps等产品之后，才发表了相应的文章并对其进行了命名。\n"]],[3733,3910],[3733,3733]]],[1566613179609,["GJX@GJXAIOU",[[-1,3734,"\n"]],[3733,3733],[3732,3732]]],[1566613242796,["GJX@GJXAIOU",[[-1,4992,"**4\\. JSON**\n\nJSON全称JavaScript Object Notation（js对象标记法），由Douglas Crockford在2002年发现并制定了标准。从名称上就可以看出来，JSON是基于JavaScript的，是JavaScript的一个子集。JSON是用JavaScript语法来表示数据的一种轻量级语言。\n\n虽然Douglas在2002年就注册了[http://json.org](https://link.zhihu.com/?target=http%3A//json.org)，并且为各种语言编写了解析与构造JSON数据的库，但在最开始的几年JSON一直没有得到足够的重视。情况一直延续到ajax的出现。\n\n从ajax的命名中我们就可以看到，数据交换是通过XML格式进行的。在ajax刚出现的时候，绝大多数应用都是采用XML格式，也有少数使用纯文本的。但是XML格式有一个缺点，就是文档构造复杂，需要传输比较多的字节数。在这种情况下，JSON的轻便性逐渐得到重视，后来替代XML成为ajax最主要的数据传输格式。可以举个简单的例子感受一下二者的区别：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<root>\n  <article>\n    <title>Article Title1</title>\n    <content>content1</content>\n  </article>\n  <article>\n    <title>Article Title2</title>\n    <content>content2</content>\n  </article>\n</root>\n```\n\n```json\n{\n  \"article\" : [\n    {\n      \"title\": \"Article Title1\",\n      \"content\": \"content1\"\n    },\n    {\n      \"title\": \"Article Title2\",\n      \"content\": \"content2\"\n    }\n  ]\n}\n```\n\nXML规范实际上是比较复杂的，单纯作为数据传输来说它太重了。在ajax领域中JSON取代XML的过程，是一个很好的“用脚投票”的范例。\n\n而JSON的影响力在此后还继续扩大，有些软件将其作为配置文件的格式，有些编程语言也吸纳了JSON的优点。例如c#，在高版本里可以这样写：\n\n```csharp\nDictionary<int, string> dict = new Dictionary<int, string>{\n    {1, \"a\"},\n    {2, \"b\"}\n};\n\n```\n\n但是如果c# 2.0这样写，可是会报错的。在2.0里只能写成下面这种形式：\n\n```csharp\nDictionary<int, string> dict = new Dictionary<int, string>();\ndict.Add(1, \"a\");\ndict.Add(2, \"b\");\n\n```\n\n等价于\n\n```csharp\nDictionary<int, string> dict = new Dictionary<int, string>();\ndict[1] = \"a\";\ndict[2] = \"b\";\n\n```\n\n比较一下两种写法的区别，不仅有便捷性的差距，而且前一种写法可以在声明变量的同时为变量赋值，后一种写法则不行，这会影响到类属性的初始化操作：在c# 2.0中，只能把针对Dictionary之类复杂对象的初始化代码写在函数里，而不能直接写在类属性的声明处。\n\n感觉上是c#受了JSON（或者说js）的影响。但此处是我个人的感觉，如有错误请指出。\n\n回到js自身，对于对象构造有两种方法：基于对象的完整写法，字面量表示法。前者如：\n\n```js\nvar obj = new Object();\nobj.title = \"title1\";\nobj.content = \"content1\";\n\n```\n\n而与之对应的字面量表示法则写为：\n\n```js\nvar obj = {\n    title: \"title1\",\n    content: \"content1\"\n};\n\n```\n\n可以明显看出字面量表示法要简洁得多。而JSON基本就是字面量表示法的一个子集，除了强制要求键与字符串类型的值必须用双引号包起之外，它剔除了undefined、function等类型，也不包括浏览器内置对象类型（如Date、RegExp等），是基于文本的、比较纯粹的数据表示方法。所以说，Douglas是“发现”了JSON，而不是“发明”。标准的JSON不包含注释，但后来因为实际需求而出现了能够处理注释的JSON库。"]],[4992,7026],[4992,4992]]],[1566613247227,["GJX@GJXAIOU",[[1,4218,"\n"]],[4214,4214],[4215,4215]]],[1566613247860,["GJX@GJXAIOU",[[1,4215,"**4\\. JSON**\n\nJSON全称JavaScript Object Notation（js对象标记法），由Douglas Crockford在2002年发现并制定了标准。从名称上就可以看出来，JSON是基于JavaScript的，是JavaScript的一个子集。JSON是用JavaScript语法来表示数据的一种轻量级语言。\n\n虽然Douglas在2002年就注册了[http://json.org](https://link.zhihu.com/?target=http%3A//json.org)，并且为各种语言编写了解析与构造JSON数据的库，但在最开始的几年JSON一直没有得到足够的重视。情况一直延续到ajax的出现。\n\n从ajax的命名中我们就可以看到，数据交换是通过XML格式进行的。在ajax刚出现的时候，绝大多数应用都是采用XML格式，也有少数使用纯文本的。但是XML格式有一个缺点，就是文档构造复杂，需要传输比较多的字节数。在这种情况下，JSON的轻便性逐渐得到重视，后来替代XML成为ajax最主要的数据传输格式。可以举个简单的例子感受一下二者的区别：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<root>\n  <article>\n    <title>Article Title1</title>\n    <content>content1</content>\n  </article>\n  <article>\n    <title>Article Title2</title>\n    <content>content2</content>\n  </article>\n</root>\n```\n\n```json\n{\n  \"article\" : [\n    {\n      \"title\": \"Article Title1\",\n      \"content\": \"content1\"\n    },\n    {\n      \"title\": \"Article Title2\",\n      \"content\": \"content2\"\n    }\n  ]\n}\n```\n\nXML规范实际上是比较复杂的，单纯作为数据传输来说它太重了。在ajax领域中JSON取代XML的过程，是一个很好的“用脚投票”的范例。\n\n而JSON的影响力在此后还继续扩大，有些软件将其作为配置文件的格式，有些编程语言也吸纳了JSON的优点。例如c#，在高版本里可以这样写：\n\n```csharp\nDictionary<int, string> dict = new Dictionary<int, string>{\n    {1, \"a\"},\n    {2, \"b\"}\n};\n\n```\n\n但是如果c# 2.0这样写，可是会报错的。在2.0里只能写成下面这种形式：\n\n```csharp\nDictionary<int, string> dict = new Dictionary<int, string>();\ndict.Add(1, \"a\");\ndict.Add(2, \"b\");\n\n```\n\n等价于\n\n```csharp\nDictionary<int, string> dict = new Dictionary<int, string>();\ndict[1] = \"a\";\ndict[2] = \"b\";\n\n```\n\n比较一下两种写法的区别，不仅有便捷性的差距，而且前一种写法可以在声明变量的同时为变量赋值，后一种写法则不行，这会影响到类属性的初始化操作：在c# 2.0中，只能把针对Dictionary之类复杂对象的初始化代码写在函数里，而不能直接写在类属性的声明处。\n\n感觉上是c#受了JSON（或者说js）的影响。但此处是我个人的感觉，如有错误请指出。\n\n回到js自身，对于对象构造有两种方法：基于对象的完整写法，字面量表示法。前者如：\n\n```js\nvar obj = new Object();\nobj.title = \"title1\";\nobj.content = \"content1\";\n\n```\n\n而与之对应的字面量表示法则写为：\n\n```js\nvar obj = {\n    title: \"title1\",\n    content: \"content1\"\n};\n\n```\n\n可以明显看出字面量表示法要简洁得多。而JSON基本就是字面量表示法的一个子集，除了强制要求键与字符串类型的值必须用双引号包起之外，它剔除了undefined、function等类型，也不包括浏览器内置对象类型（如Date、RegExp等），是基于文本的、比较纯粹的数据表示方法。所以说，Douglas是“发现”了JSON，而不是“发明”。标准的JSON不包含注释，但后来因为实际需求而出现了能够处理注释的JSON库。"]],[4215,4215],[6249,6249]]],[1566613250018,["GJX@GJXAIOU",[[-1,4225,"**"]],[4227,4227],[4225,4225]]],[1566613253234,["GJX@GJXAIOU",[[-1,4215,"**4\\. "]],[4221,4221],[4215,4215]]],[1566613254426,["GJX@GJXAIOU",[[1,4215,"### "]],[4215,4215],[4223,4223]]],[1566613268042,["GJX@GJXAIOU",[[-1,4267,"由Douglas Crockford在2002年发现并制定了标准。从名称上就可以看出来，"]],[4267,4311],[4267,4267]]],[1566613282602,["GJX@GJXAIOU",[[1,4303,"**"],[1,4334,"**"]],[4303,4334],[4303,4338]]],[1566613388147,["GJX@GJXAIOU",[[-1,4341,"虽然Douglas在2002年就注册了[http://json.org](https://link.zhihu.com/?target=http%3A//json.org)，并且为各种语言编写了解析与构造JSON数据的库，但在最开始的几年JSON一直没有得到足够的重视。情况一直延续到ajax的出现。"]],[4341,4491],[4341,4341]]],[1566613388618,["GJX@GJXAIOU",[[-1,4342,"\n"]],[4341,4341],[4340,4340]]],[1566613389970,["GJX@GJXAIOU",[[-1,4341,"\n"]],[4341,4341],[4340,4340]]],[1566613411258,["GJX@GJXAIOU",[[1,4454,"**"],[1,4492,"**"]],[4454,4492],[4454,4496]]],[1566613434500,["GJX@GJXAIOU",[[-1,4949,"\n"]],[4949,4949],[4948,4948]]],[1566614194602,["GJX@GJXAIOU",[[-1,5018,"而JSON的影响力在此后还继续扩大，有些软件将其作为配置文件的格式，有些编程语言也吸纳了JSON的优点。例如c#，在高版本里可以这样写：\n\n```csharp\nDictionary<int, string> dict = new Dictionary<int, string>{\n    {1, \"a\"},\n    {2, \"b\"}\n};\n\n```\n\n但是如果c# 2.0这样写，可是会报错的。在2.0里只能写成下面这种形式：\n\n```csharp\nDictionary<int, string> dict = new Dictionary<int, string>();\ndict.Add(1, \"a\");\ndict.Add(2, \"b\");\n\n```\n\n等价于\n\n```csharp\nDictionary<int, string> dict = new Dictionary<int, string>();\ndict[1] = \"a\";\ndict[2] = \"b\";\n\n```\n\n比较一下两种写法的区别，不仅有便捷性的差距，而且前一种写法可以在声明变量的同时为变量赋值，后一种写法则不行，这会影响到类属性的初始化操作：在c# 2.0中，只能把针对Dictionary之类复杂对象的初始化代码写在函数里，而不能直接写在类属性的声明处。\n\n感觉上是c#受了JSON（或者说js）的影响。但此处是我个人的感觉，如有错误请指出。"]],[5018,5630],[5018,5018]]],[1566614196978,["GJX@GJXAIOU",[[-1,5019,"\n"]],[5018,5018],[5017,5017]]],[1566614197458,["GJX@GJXAIOU",[[-1,5018,"\n"]],[5017,5017],[5016,5016]]],[1566614205081,["GJX@GJXAIOU",[[-1,6222,"**5\\. Node.js**\n\nNode.js是Ryan Dahl在2009年发布的、主要用于服务器端的Javascript运行环境，也可以用于个人电脑。\nRyan Dahl此前一直在寻找一种事件驱动型的、异步的服务器端框架，实际上，js并不是他的首选。他是在尝试了几种语言之后，才发现js的函数回调与单线程特性正好契合他的要求，于是Node.js应运而生。\njs的异步回调在ajax的部分已经提过：在调用异步方法的时候，可以将后续的处理函数作为参数传入，在调用相应的异步接口之后，程序会将线程的控制权让出，允许其他代码执行；在接口返回处理结果后，再执行后续处理函数（即回调函数）。实际上，因为js是单线程语言，回调函数并不是立刻被执行的，而是会被送入任务队列，在线程空闲、并且队列前方没有其他任务的情况下，才会被执行。\n\n用户在向服务器提交请求的时候，如果处理比较费时，传统的服务器端框架会导致处理线程被阻塞。而js的特性使得异步任务在执行的时候让出线程的控制权，在处理完成后再进行正确的回调，从而能够获得比较好的高并发处理能力。\njs本身是一门严格的单线程语言，而Node.js为了充分发挥服务器的处理能力，在运行环境级别上增加了对于多线程的支持（child process）。但Node.js的多线程与常规的多线程有很大区别——常规语言的多线程允许多个线程共享数据，或者调用其他线程暴露出来的公开方法，而Node.js的多线程只能用消息机制进行通讯。这样，Node.js就规避了常规多线程的数据同步、线程锁（线程同步/互斥）等复杂问题，规避了一些潜在风险。\n\nNode.js使用的V8引擎实际上就是Google的Chrome浏览器使用的Javascript引擎（因为V8引擎是开源的），并进行了模块扩展。例如遵循CommonJS标准的模块定义，适合服务器需求的多线程、集群、HTTP/HTTPS，文件系统，等等。Node.js中的很多方法都同时提供了异步版本与同步版本，从函数的命名上可以简单区分。\n得益于其模块特性，Node.js的模块扩展变得相当方便，用于Node.js包管理的npm得到了广泛的使用，但也曾经引起“是否过度使用依赖包”的争论。\n\nNode.js不仅可用于服务器端，因为其安装完成之后可以用命令行方式方便地调用，因此在个人电脑中也逐渐得到广泛应用。例如为代码编辑器提供插件、用于桌面的Node.js App等。另外还有一个重要的应用领域就是前端自动化，包括代码的预编译/转换（如使用Babel将ECMAScript 6的代码转换为低版本的es代码，将sass/less的样式表文件编译为传统的css文件）、语法检查、代码文件或图像文件的合并、代码的混淆/压缩、自动分发、自动测试等，还可以监视开发文件夹，在内容改变时自动执行上述操作，并自动刷新浏览器页面。这样使得前端领域的开发方式得到了大大进化。\n\njs虽然因为有着一些先天不足而被人诟病，但这些年来却越发展越壮大。这不仅仅是因为依托于浏览器这个宿主环境，更是因为其自身具备的一些优秀特性，Node.js的出现与发展就是一个很好的例证。"]],[6222,7530],[6222,6222]]],[1566614209715,["GJX@GJXAIOU",[[1,5446,"\n"]],[5443,5443],[5444,5444]]],[1566614209849,["GJX@GJXAIOU",[[1,5447,"\n"]],[5444,5444],[5445,5445]]],[1566614210267,["GJX@GJXAIOU",[[1,5445,"**5\\. Node.js**\n\nNode.js是Ryan Dahl在2009年发布的、主要用于服务器端的Javascript运行环境，也可以用于个人电脑。\nRyan Dahl此前一直在寻找一种事件驱动型的、异步的服务器端框架，实际上，js并不是他的首选。他是在尝试了几种语言之后，才发现js的函数回调与单线程特性正好契合他的要求，于是Node.js应运而生。\njs的异步回调在ajax的部分已经提过：在调用异步方法的时候，可以将后续的处理函数作为参数传入，在调用相应的异步接口之后，程序会将线程的控制权让出，允许其他代码执行；在接口返回处理结果后，再执行后续处理函数（即回调函数）。实际上，因为js是单线程语言，回调函数并不是立刻被执行的，而是会被送入任务队列，在线程空闲、并且队列前方没有其他任务的情况下，才会被执行。\n\n用户在向服务器提交请求的时候，如果处理比较费时，传统的服务器端框架会导致处理线程被阻塞。而js的特性使得异步任务在执行的时候让出线程的控制权，在处理完成后再进行正确的回调，从而能够获得比较好的高并发处理能力。\njs本身是一门严格的单线程语言，而Node.js为了充分发挥服务器的处理能力，在运行环境级别上增加了对于多线程的支持（child process）。但Node.js的多线程与常规的多线程有很大区别——常规语言的多线程允许多个线程共享数据，或者调用其他线程暴露出来的公开方法，而Node.js的多线程只能用消息机制进行通讯。这样，Node.js就规避了常规多线程的数据同步、线程锁（线程同步/互斥）等复杂问题，规避了一些潜在风险。\n\nNode.js使用的V8引擎实际上就是Google的Chrome浏览器使用的Javascript引擎（因为V8引擎是开源的），并进行了模块扩展。例如遵循CommonJS标准的模块定义，适合服务器需求的多线程、集群、HTTP/HTTPS，文件系统，等等。Node.js中的很多方法都同时提供了异步版本与同步版本，从函数的命名上可以简单区分。\n得益于其模块特性，Node.js的模块扩展变得相当方便，用于Node.js包管理的npm得到了广泛的使用，但也曾经引起“是否过度使用依赖包”的争论。\n\nNode.js不仅可用于服务器端，因为其安装完成之后可以用命令行方式方便地调用，因此在个人电脑中也逐渐得到广泛应用。例如为代码编辑器提供插件、用于桌面的Node.js App等。另外还有一个重要的应用领域就是前端自动化，包括代码的预编译/转换（如使用Babel将ECMAScript 6的代码转换为低版本的es代码，将sass/less的样式表文件编译为传统的css文件）、语法检查、代码文件或图像文件的合并、代码的混淆/压缩、自动分发、自动测试等，还可以监视开发文件夹，在内容改变时自动执行上述操作，并自动刷新浏览器页面。这样使得前端领域的开发方式得到了大大进化。\n\njs虽然因为有着一些先天不足而被人诟病，但这些年来却越发展越壮大。这不仅仅是因为依托于浏览器这个宿主环境，更是因为其自身具备的一些优秀特性，Node.js的出现与发展就是一个很好的例证。"]],[5445,5445],[6753,6753]]],[1566614213610,["GJX@GJXAIOU",[[-1,5445,"**5\\. "]],[5445,5451],[5445,5445]]],[1566614214290,["GJX@GJXAIOU",[[1,5445,"### "]],[5445,5445],[5458,5458]]],[1566614216641,["GJX@GJXAIOU",[[-1,5456,"**"]],[5458,5458],[5456,5456]]],[1566614263628,["GJX@GJXAIOU",[[1,5737,"**"],[1,5802,"**"]],[5737,5802],[5737,5806]]],[1566614343484,["GJX@GJXAIOU",[[-1,7533,"\n"]],[7531,7531],[7530,7530]]],[1566614343610,["GJX@GJXAIOU",[[-1,7532,"\n"]],[7530,7530],[7529,7529]]],[1566614343714,["GJX@GJXAIOU",[[-1,7531,"\n"]],[7529,7529],[7528,7528]]],[1566614343849,["GJX@GJXAIOU",[[-1,7530,"\n"]],[7528,7528],[7527,7527]]],[1566614343977,["GJX@GJXAIOU",[[-1,7529,"\n"]],[7527,7527],[7526,7526]]],[1566614344114,["GJX@GJXAIOU",[[-1,7528,"\n"]],[7526,7526],[7525,7525]]],[1566614344370,["GJX@GJXAIOU",[[-1,7527,"\n"]],[7525,7525],[7524,7524]]],[1566614344499,["GJX@GJXAIOU",[[-1,7526,"\n"]],[7524,7524],[7523,7523]]],[1566614344626,["GJX@GJXAIOU",[[-1,7525,"\n"]],[7523,7523],[7522,7522]]],[1566614344769,["GJX@GJXAIOU",[[-1,7524,"\n"]],[7522,7522],[7521,7521]]],[1566614344907,["GJX@GJXAIOU",[[-1,7523,"\n"]],[7521,7521],[7520,7520]]],[1566614345029,["GJX@GJXAIOU",[[-1,7522,"\n"]],[7520,7520],[7519,7519]]],[1566614347900,["GJX@GJXAIOU",[[1,7522,"## "]],[7522,7522],[7531,7531]]],[1566614350817,["GJX@GJXAIOU",[[-1,7529,"**"]],[7531,7531],[7529,7529]]],[1566614352953,["GJX@GJXAIOU",[[-1,7525,"**"]],[7527,7527],[7525,7525]]],[1566614364947,["GJX@GJXAIOU",[[1,7619,"**"],[1,7653,"**"]],[7619,7653],[7619,7657]]],[1566614403618,["GJX@GJXAIOU",[[-1,7930,"[于江水](https://www.zhihu.com/people/69ed13f3ddc662d6ecd8261512117e85)\n\n**的答案存在一些错误或者不严谨之处：**"]],[7930,8021],[7930,7930]]],[1566614406671,["GJX@GJXAIOU",[[1,7930,"****"]],[7930,7930],[7932,7932]]],[1566614408096,["GJX@GJXAIOU",[[1,7932,"补充"]],[7932,7932],[7934,7934]]],[1566614411194,["GJX@GJXAIOU",[[-1,7937,"\n"]],[7937,7937],[7936,7936]]],[1566614417054,["GJX@GJXAIOU",[[1,9084,"·"]],[9084,9084],[9085,9085]]],[1566614418242,["GJX@GJXAIOU",[[-1,9084,"·"]],[9085,9085],[9084,9084]]],[1566614418692,["GJX@GJXAIOU",[[1,9084,"`"]],[9084,9084],[9085,9085]]],[1566614420519,["GJX@GJXAIOU",[[1,9065,"`"]],[9065,9065],[9066,9066]]],[1566614422093,["GJX@GJXAIOU",[[-1,9058,"``text\n`"]],[9056,9064],[9056,9056]]],[1566614422408,["GJX@GJXAIOU",[[-1,9056,"\n"]],[9056,9056],[9055,9055]]],[1566614423409,["GJX@GJXAIOU",[[-1,9079,"```"]],[9079,9082],[9079,9079]]],[1566614424649,["GJX@GJXAIOU",[[-1,9055,"\n"]],[9056,9056],[9055,9055]]],[1566614425450,["GJX@GJXAIOU",[[-1,9079,"\n"]],[9079,9079],[9078,9078]]],[1566614425898,["GJX@GJXAIOU",[[-1,9078,"\n"]],[9078,9078],[9077,9077]]],[1566614482179,["GJX@GJXAIOU",[[1,3577,"**"],[1,3594,"**"]],[3577,3594],[3577,3598]]],[1566614493859,["GJX@GJXAIOU",[[1,2254,"**"],[1,2272,"**"]],[2254,2272],[2254,2276]]]],null,"GJX@GJXAIOU"]]}