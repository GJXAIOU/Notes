{"compress":true,"commitItems":[["75e97dab-235e-43da-9c5d-388150af0cff",1562295700443,"# java进阶--深入理解Java自动装箱拆箱机制（Autoboxing and unboxing）\n\n2017年04月18日 20:37:40 [HankingHu](https://me.csdn.net/u013309870) 阅读数 3353\n\n 版权声明：本文为博主原创文章，转载请标明出处。 https://blog.csdn.net/u013309870/article/details/70229983\n\n## **1.自动装箱与拆箱的定义**\n\n装箱就是自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。\n\nJava中的数据类型分为两类：一类是基本数据类型，另一类是引用数据类型。如下图：\n\n![这里写图片描述](https://img-blog.csdn.net/20170418171248279?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzMwOTg3MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n由上可知Java中的基本数据类型有八种分别是：int（4字节） byte（1字节） short（2字节） long（8字节） float （4字节） double（8字节） char（2字节） boolean（1byte）基本数据类型不是对象，不能使用对象的方法。将基本数据类型转换为对象就是自动装箱的过程。下面是基本数据类型与封装器类之间对应的关系。\n\n| 简单类型 | 二进制位数 | 封装器类 |\n| --- | --- | --- |\n| int | 32 | Integer |\n| byte | 8 | Byte |\n| long | 64 | Long |\n| float | 32 | float |\n| double | 64 | Double |\n| char | 16 | Character |\n| boolean | 1 | Boolean |\n\n## **自动装箱**\n\n先看下面这段代码：\n\n```\npublic static void main(String[] args) {\n        // TODO Auto-generated method stub\n        int a=3;\n        //定义一个基本数据类型的变量a赋值3\n        Integer b=a;\n        //b是Integer 类定义的对象，直接用int 类型的a赋值    \n        System.out.println(b);\n        //打印结果为3\n    }\n```\n\n上面的代码中 `Integer b=a;` 非常的奇怪，一个对象怎么赋值成了基本数据类型的变量，其实这就是自动装箱的过程，上面程序在执行`Integer b=a;`的时候调用了Integer.valueOf ( int i ) 方法，`Integer b=a; 这段代码等同于：Integer b=Integer.valueOf ( a ) 。下面是对 Integer.valueOf ( int i ) 方法简化后的源码：\n\n```\npublic static Integer valueOf(int i) {       \n        if (i >= -128 && i <= 127)\n            return IntegerCache.cache[i + 127];\n            //如果i的值大于-128小于127则返回一个缓冲区中的一个Integer对象\n        return new Integer(i);\n        //否则返回 new 一个Integer 对象\n    }\n```\n\n可以看到Integer.valueOf ( a )其实是返回了一个Integer的对象。因此由于自动装箱的存在Integer b=a 这段代码是没有毛病的。其实更简化的来写可以这样：Integer b=3，同样这段代码等价于：Integer b=Integer.valueOf (3 ) 。\n\n## **自动拆箱**\n\n先看下面的这段代码：\n\n```\npublic static void main(String[] args) {\n        // TODO Auto-generated method stub\n\n        Integer b=new Integer(3);\n        //b为Integer的对象\n        int a=b;\n        //a为一个int的基本数据类型\n        System.out.println(a);\n        //打印输出3。\n    }\n```\n\n上面的代码：int a=b,很奇怪，怎么把一个对象赋给了一个基本类型呢？其实 int a=b,这段代码等价于：int a=b.intValue(),来看看inValue()方法到底是什么，下面是源码：\n\n```\npublic int intValue() {\n        return value;\n    }\n```\n\n这个方法很简单嘛，就是返回了value值，然而value又是什么，继续找到了一个代码：\n\n```\npublic Integer(int value) {\n        this.value = value;\n    }\n\n```\n\n原来value，就是定义 Integer b=new Integer(3) ; 赋的值。所以上面的代码其实是这样的：\n\n```\npublic static void main(String[] args) {\n        // TODO Auto-generated method stub\n\n        Integer b=new Integer(3);\n        //b为Integer的对象\n        int a=b.intValue();\n        //其中b.intValue()返回实例化b时构造函数new Integer(3);赋的值3。\n        System.out.println(a);\n        //打印输出3。\n    }\n```\n\n## **相关题目**\n\n自动装箱和拆箱已经解决了，看看下面的代码输出什么：\n\n```\npublic static void main(String[] args) {        \n        //1\n        Integer a=new Integer(123);\n        Integer b=new Integer(123);\n        System.out.println(a==b);//输出 false\n\n        //2 \n        Integer c=123;\n        Integer d=123;  \n        System.out.println(c==d);//输出 true\n\n        //3\n        Integer e=129;\n        Integer f=129;\n        System.out.println(e==f);//输出 false\n        //4\n        int g=59;\n        Integer h=new Integer(59);\n        System.out.println(g==h);//输出 true\n    }\n```\n\n上面的三段代码：代码1 输出为 true 还是比较好理解的：如下图：\n\n![这里写图片描述](https://img-blog.csdn.net/20170419095258057?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzMwOTg3MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\na，b是栈中对象的引用分别指向堆中两个不同的对象，而 a==b 这条语句就是判断 a , b在堆中指向的对象是不是同一个，因此 代码1输出false。\n\n然而代码2中的输出为什么会是true呢？由上面的自动装箱知道\n\n```\n    Integer c=123;\n    Integer d=123;  \n\n```\n\n不也是生成了两个对象 c 和 d 吗？ 为什么输出结果却为true。这个其实跟自动装箱有关，再来看一下自动装箱的源代码：\n\n```\npublic static Integer valueOf(int i) {       \n        if (i >= -128 && i <= 127)\n            return IntegerCache.cache[i + 127];\n            //如果i的值大于-128小于127则返回一个缓冲区中的一个Integer对象\n        return new Integer(i);\n        //否则返回 new 一个Integer 对象\n    }\n```\n\n上面的这段代码中：IntegerCache.cache[i + 127]; 又是什么？下面是简化后的源码：\n\n```\n private static class IntegerCache {\n\n        static final Integer cache[];\n        //定义一个Integer类型的数组且数组不可变\n        static {  \n        //利用静态代码块对数组进行初始化。                     \n            cache = new Integer[256];\n            int j = -128;\n            for(int k = 0; k < cache.length; k++)\n                cache[k] = new Integer(j++);\n        }\n\n  //cache[]原来是一个Integer 类型的数组（也可以称为常量池），value 从-128到127，\n    public static Integer valueOf(int i) {   \n        if (i >=-128 && i <= 127)        \n            return IntegerCache.cache[i + (-IntegerCache.low)];\n            //如果装箱时值在-128到127之间，之间返回常量池中的已经初始化后的Integer对象。\n        return new Integer(i);\n        //否则返回一个新的对象。\n    }\n}\n```\n\n由上面的代码很好理解，原来IntegerCache 类在初始化的时候，生成了一个大小为 256 的integer 类型的常量池，并且integer.val 的值从-128-127，当我们运行 Integer c=a ;时，如果 -128<=a<=127时，不会再生成新的integer对象，直接从常量池中找到对应的已经初始化后的对象。当 a<-128||a>127时会生成一个新的对象。因此不难理解代码2为什么会输出true了。因为 c 和 d指向的是同一个对象，并不是生成了两个不同对象。同样不难理解代码3为什么会输出 false 。但是代码4中明明g指向的是栈中的变量，而h指向的是堆中的对象，为什么 g==h 是true，这就是自动拆箱，g==h 这代码执行时其实是：g==h.IntValue(），而h.IntValue()=59,所以两边其实是两个 int 在比较。\n\n## 总结\n\n上面讲解了int基本类型的自动装箱和拆箱，其实**int byte short long float double char boolean** 这些基本类型的自动装箱和拆箱过程都是差不多的。\n\n简单一句话：**装箱就是自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。**",[[1562295651189,["GJX@GJXAIOU",[[-1,52,"\n2017年04月18日 20:37:40 [HankingHu](https://me.csdn.net/u013309870) 阅读数 3353\n\n 版权声明：本文为博主原创文章，转载请标明出处。"]],[52,152],[52,52]]],[1562295685600,["GJX@GJXAIOU",[[-1,1091," "],[1,1092," "],[-1,1106," "],[1,1107," "],[1,4906,"`"],[-1,5072," "],[1,5073," "]],[4906,4906],[4907,4907]]],[1562295687526,["GJX@GJXAIOU",[[1,4911,"`"]],[4911,4911],[4912,4912]]],[1562295690158,["GJX@GJXAIOU",[[1,4927,"`"]],[4927,4927],[4928,4928]]],[1562295691437,["GJX@GJXAIOU",[[1,4932,"`"]],[4932,4932],[4933,4933]]],[1562295695765,["GJX@GJXAIOU",[[1,4944,"`"]],[4944,4944],[4945,4945]]],[1562295698943,["GJX@GJXAIOU",[[1,4960,"`"]],[4960,4960],[4961,4961]]],[1562295733319,["GJX@GJXAIOU",[[1,2826,",wei"]],[2826,2826],[2830,2830]]],[1562295734174,["GJX@GJXAIOU",[[-1,2827,"wei"]],[2830,2830],[2827,2827]]],[1562295739182,["GJX@GJXAIOU",[[1,2827,"因为是两个对象"]],[2827,2827],[2834,2834]]],[1562295775963,["GJX@GJXAIOU",[[-1,3545,"\n"]],[3545,3545],[3544,3544]]],[1562295780836,["GJX@GJXAIOU",[[-1,3507,"  "],[-1,3524,"  "]],[3508,3544],[3506,3540]]],[1562295782085,["GJX@GJXAIOU",[[-1,3505,"  "],[-1,3522,"  "]],[3506,3540],[3505,3536]]],[1562295852803,["GJX@GJXAIOU",[[-1,4687,"-"]],[4688,4688],[4687,4687]]],[1562295856182,["GJX@GJXAIOU",[[1,4687,"~"]],[4687,4687],[4688,4688]]],[1562296194364,["GJX@GJXAIOU",[[1,112,"\n"]],[111,111],[112,112]]],[1562296194491,["GJX@GJXAIOU",[[1,113,"\n"]],[112,112],[113,113]]],[1562296194652,["GJX@GJXAIOU",[[1,114,"\n"]],[113,113],[114,114]]],[1562296194795,["GJX@GJXAIOU",[[1,115,"\n"]],[114,114],[115,115]]],[1562296194883,["GJX@GJXAIOU",[[1,116,"\n"]],[115,115],[116,116]]],[1562296195038,["GJX@GJXAIOU",[[1,117,"\n"]],[116,116],[117,117]]],[1562296198318,["GJX@GJXAIOU",[[1,112,"基础类型与对象类型的区别\n在Java中一切皆为对象，可唯独基础类型很奇怪，对于从C语言过渡过来的同学可能很容易就接受了，但是却并不一定能搞懂这两者之间的关系。 \n对于对象类型，是在程序运行时，通过new动态在堆上创建的对象，而基础类型，是在编译的时候就将值分配到数据栈中。通过基础类型，变量地址所存储的值恰好为存储的值；而对象类型，你持有的仅仅是引用而并不是真实数据存储的地址。 \n基础类型，是将数据分配到了数据栈中，而对象类型，则将对象分配到了对象堆中。据说这也是java保留基础类型的原因，因为性能！保存在数据栈中避免了运行时动态分配内存的操作。\n\n另外一点，还需要注意的是，java中有8种基础类型： \nbyte\\short\\int\\long\\double\\float\\boolean\\char \n这里面并没有String!!!"]],[112,112],[479,479]]],[1562296202445,["GJX@GJXAIOU",[[1,112,"**"],[1,124,"**"]],[112,124],[112,128]]],[1562296208318,["GJX@GJXAIOU",[[1,112,"## "]],[112,112],[131,131]]],[1562296433404,["GJX@GJXAIOU",[[1,1183,"\n"]],[1182,1182],[1183,1183]]],[1562296433539,["GJX@GJXAIOU",[[1,1184,"\n"]],[1183,1183],[1184,1184]]],[1562296433699,["GJX@GJXAIOU",[[1,1185,"\n"]],[1184,1184],[1185,1185]]],[1562296436339,["GJX@GJXAIOU",[[1,1184,"1.  //自动装箱，底层其实执行了Integer a=Integer.valueOf(1);\n\n2.  Integer a = 1;\n\n3.  //自动拆箱，底层其实执行了int b=a.intValue();"]],[1184,1184],[1290,1290]]],[1562296438435,["GJX@GJXAIOU",[[-1,1233,"2.  Integer a = 1;"]],[1233,1251],[1233,1233]]],[1562296438875,["GJX@GJXAIOU",[[-1,1234,"\n"]],[1233,1233],[1232,1232]]],[1562296439387,["GJX@GJXAIOU",[[-1,1233,"\n"]],[1232,1232],[1231,1231]]],[1562296440468,["GJX@GJXAIOU",[[-1,1232,"\n"]],[1232,1232],[1231,1231]]],[1562296441683,["GJX@GJXAIOU",[[-1,1184,"1.  //"]],[1184,1190],[1184,1184]]],[1562296443541,["GJX@GJXAIOU",[[1,1184,"- "]],[1184,1184],[1186,1186]]],[1562296445635,["GJX@GJXAIOU",[[-1,1228,"3.  //"],[1,1234,"-"]],[1228,1228],[1229,1229]]],[1562296446092,["GJX@GJXAIOU",[[1,1229," "]],[1229,1229],[1230,1230]]]],null,"GJX@GJXAIOU"],["6ca9ba45-c68e-439f-a1ff-cf1e3d7017a4",1562374589998,"# java进阶--深入理解Java自动装箱拆箱机制（Autoboxing and unboxing）\n https://blog.csdn.net/u013309870/article/details/70229983\n\n## **基础类型与对象类型的区别**\n在Java中一切皆为对象，可唯独基础类型很奇怪，对于从C语言过渡过来的同学可能很容易就接受了，但是却并不一定能搞懂这两者之间的关系。 \n对于对象类型，是在程序运行时，通过new动态在堆上创建的对象，而基础类型，是在编译的时候就将值分配到数据栈中。通过基础类型，变量地址所存储的值恰好为存储的值；而对象类型，你持有的仅仅是引用而并不是真实数据存储的地址。 \n基础类型，是将数据分配到了数据栈中，而对象类型，则将对象分配到了对象堆中。据说这也是java保留基础类型的原因，因为性能！保存在数据栈中避免了运行时动态分配内存的操作。\n\n另外一点，还需要注意的是，java中有8种基础类型： \nbyte\\short\\int\\long\\double\\float\\boolean\\char \n这里面并没有String!!!\n\n\n\n\n\n## **1.自动装箱与拆箱的定义**\n\n装箱就是自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。\n\nJava中的数据类型分为两类：一类是基本数据类型，另一类是引用数据类型。如下图：\n\n![这里写图片描述](https://img-blog.csdn.net/20170418171248279?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzMwOTg3MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n由上可知Java中的基本数据类型有八种分别是：int（4字节） byte（1字节） short（2字节） long（8字节） float （4字节） double（8字节） char（2字节） boolean（1byte）基本数据类型不是对象，不能使用对象的方法。将基本数据类型转换为对象就是自动装箱的过程。下面是基本数据类型与封装器类之间对应的关系。\n\n| 简单类型 | 二进制位数 | 封装器类 |\n| --- | --- | --- |\n| int | 32 | Integer |\n| byte | 8 | Byte |\n| long | 64 | Long |\n| float | 32 | float |\n| double | 64 | Double |\n| char | 16 | Character |\n| boolean | 1 | Boolean |\n\n\n- 自动装箱，底层其实执行了Integer a=Integer.valueOf(1);\n- 自动拆箱，底层其实执行了int b=a.intValue();\n\n## **自动装箱**\n\n先看下面这段代码：\n\n```\npublic static void main(String[] args) {\n        // TODO Auto-generated method stub\n        int a=3;\n        //定义一个基本数据类型的变量a赋值3\n        Integer b=a;\n        //b是Integer 类定义的对象，直接用int 类型的a赋值    \n        System.out.println(b);\n        //打印结果为3\n    }\n```\n\n上面的代码中 `Integer b=a;` 非常的奇怪，一个对象怎么赋值成了基本数据类型的变量，其实这就是自动装箱的过程，上面程序在执行`Integer b=a;`的时候调用了Integer.valueOf ( int i ) 方法，`Integer b=a; 这段代码等同于：Integer b=Integer.valueOf ( a ) 。下面是对 Integer.valueOf ( int i ) 方法简化后的源码：\n\n```\npublic static Integer valueOf(int i) {       \n        if (i >= -128 && i <= 127)\n            return IntegerCache.cache[i + 127];\n            //如果i的值大于-128小于127则返回一个缓冲区中的一个Integer对象\n        return new Integer(i);\n        //否则返回 new 一个Integer 对象\n    }\n```\n\n可以看到Integer.valueOf ( a )其实是返回了一个Integer的对象。因此由于自动装箱的存在Integer b=a 这段代码是没有毛病的。其实更简化的来写可以这样：Integer b=3，同样这段代码等价于：Integer b=Integer.valueOf (3 ) 。\n\n## **自动拆箱**\n\n先看下面的这段代码：\n\n```\npublic static void main(String[] args) {\n        // TODO Auto-generated method stub\n\n        Integer b=new Integer(3);\n        //b为Integer的对象\n        int a=b;\n        //a为一个int的基本数据类型\n        System.out.println(a);\n        //打印输出3。\n    }\n```\n\n上面的代码：int a=b,很奇怪，怎么把一个对象赋给了一个基本类型呢？其实 int a=b,这段代码等价于：int a=b.intValue(),来看看inValue()方法到底是什么，下面是源码：\n\n```\npublic int intValue() {\n        return value;\n    }\n```\n\n这个方法很简单嘛，就是返回了value值，然而value又是什么，继续找到了一个代码：\n\n```\npublic Integer(int value) {\n        this.value = value;\n    }\n\n```\n\n原来value，就是定义 Integer b=new Integer(3) ; 赋的值。所以上面的代码其实是这样的：\n\n```\npublic static void main(String[] args) {\n        // TODO Auto-generated method stub\n\n        Integer b=new Integer(3);\n        //b为Integer的对象\n        int a=b.intValue();\n        //其中b.intValue()返回实例化b时构造函数new Integer(3);赋的值3。\n        System.out.println(a);\n        //打印输出3。\n    }\n```\n\n## **相关题目**\n\n自动装箱和拆箱已经解决了，看看下面的代码输出什么：\n\n```\npublic static void main(String[] args) {        \n        //1\n        Integer a=new Integer(123);\n        Integer b=new Integer(123);\n        System.out.println(a==b);//输出 false,因为是两个对象\n\n        //2 \n        Integer c=123;\n        Integer d=123;  \n        System.out.println(c==d);//输出 true\n\n        //3\n        Integer e=129;\n        Integer f=129;\n        System.out.println(e==f);//输出 false\n        //4\n        int g=59;\n        Integer h=new Integer(59);\n        System.out.println(g==h);//输出 true\n    }\n```\n\n上面的三段代码：代码1 输出为 true 还是比较好理解的：如下图：\n\n![这里写图片描述](https://img-blog.csdn.net/20170419095258057?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzMwOTg3MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\na，b是栈中对象的引用分别指向堆中两个不同的对象，而 a==b 这条语句就是判断 a , b在堆中指向的对象是不是同一个，因此 代码1输出false。\n\n然而代码2中的输出为什么会是true呢？由上面的自动装箱知道\n\n```\nInteger c=123;\nInteger d=123;  \n```\n\n不也是生成了两个对象 c 和 d 吗？ 为什么输出结果却为true。这个其实跟自动装箱有关，再来看一下自动装箱的源代码：\n\n```\npublic static Integer valueOf(int i) {       \n        if (i >= -128 && i <= 127)\n            return IntegerCache.cache[i + 127];\n            //如果i的值大于-128小于127则返回一个缓冲区中的一个Integer对象\n        return new Integer(i);\n        //否则返回 new 一个Integer 对象\n    }\n```\n\n上面的这段代码中：IntegerCache.cache[i + 127]; 又是什么？下面是简化后的源码：\n\n```\n private static class IntegerCache {\n\n        static final Integer cache[];\n        //定义一个Integer类型的数组且数组不可变\n        static {  \n        //利用静态代码块对数组进行初始化。                     \n            cache = new Integer[256];\n            int j = -128;\n            for(int k = 0; k < cache.length; k++)\n                cache[k] = new Integer(j++);\n        }\n\n  //cache[]原来是一个Integer 类型的数组（也可以称为常量池），value 从-128到127，\n    public static Integer valueOf(int i) {   \n        if (i >=-128 && i <= 127)        \n            return IntegerCache.cache[i + (-IntegerCache.low)];\n            //如果装箱时值在-128到127之间，之间返回常量池中的已经初始化后的Integer对象。\n        return new Integer(i);\n        //否则返回一个新的对象。\n    }\n}\n```\n\n由上面的代码很好理解，原来IntegerCache 类在初始化的时候，生成了一个大小为 256 的integer 类型的常量池，并且integer.val 的值从-128~127，当我们运行 Integer c=a ;时，如果 -128<=a<=127时，不会再生成新的integer对象，直接从常量池中找到对应的已经初始化后的对象。当 a<-128||a>127时会生成一个新的对象。因此不难理解代码2为什么会输出true了。因为 c 和 d指向的是同一个对象，并不是生成了两个不同对象。同样不难理解代码3为什么会输出 false 。但是代码4中明明g指向的是栈中的变量，而h指向的是堆中的对象，为什么 `g==h` 是true，这就是自动拆箱，`g==h` 这代码执行时其实是：`g==h.IntValue(）`，而h.IntValue()=59,所以两边其实是两个 int 在比较。\n\n## 总结\n\n上面讲解了int基本类型的自动装箱和拆箱，其实**int byte short long float double char boolean** 这些基本类型的自动装箱和拆箱过程都是差不多的。\n\n简单一句话：**装箱就是自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。**",[[1562374563718,["GJX@GJXAIOU",[[1,1228,"  "]],[1247,1247],[1249,1249]]]],null,"GJX@GJXAIOU"]]}