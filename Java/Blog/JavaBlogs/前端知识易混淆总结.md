# 前端知识易混淆总结


## 汇总

- JavaScript 是客户端脚本语言；
- jsp 和 Servlet 是服务器的程序；
- JavaScript 和 HTML 都是在浏览器中运行；
- 一个基本的网站包含很多个网页，一个网页由 html, css 和 javascript 组成；html 是主体，装载各种 dom 元素；css 用来装饰 dom 元素；javascript 控制 dom 元素。
- html 是网页的结构，CSS 是网页的样式，javascript 是网页的行为。
  - html 就是网页的框架，如网页要分成几块就是用 html 代码实现的；HTML 是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。
  - css 是用来美化网页框架的，如网页中的导航就是用 css 控制的； CSS 样式是表现(外观控制)。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。
  - js 是使网页框架具有动态效果的，如网页中的幻灯片效果就是用 js 来实现的。JavaScript 是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用 JavaScript 来实现的。

## Hyper Text Markup Languag = HTML
html 是 xml 的一个子集，因此 html 比 xml 简洁。html 够用的地方就用 html，不够用的地方就用 xml。
html 是用来描述网页的一种语言，它不是一种编程语言，而**是一种标记语言（标记标签）**，总的来说，html 使用标记标签来描述网页。标签里可带有各类属性，最基本的就是class和id。class属性的作用是引用css样式；id的作用是配合javascript使用，具有唯一性。

## Cascading Style Sheets = CSS
css 的官方名字叫层叠样式表，它的出现是**为了解决内容和表现分离的问题**，一般存放在 .css 文件里。
**css 组成**：选择器，一条或多条声明。
选择器是指css样式的名字“.seletor”，名字前面要带上一点“.”。声明是由属性和值组成，给个例子“margin: 0 auto”，冒号前面是属性，后面是值，该例子是定义元素居中显示。
**使用css**
可在 html 的头元素 <head> 里书写，或者书写在 CSS 文件中并在 html 里引用该文件。

**css优先权**
多个css样式可集中在单个html标签里，出现这种情况时，一般按优先权划分：
浏览器默认设置 （最低）
外部样式表
内部样式表（写在 html 的 <head> 标签内部）
内联样式（写在 html 的标签里，即 style 属性）（最高）
css 的语法。
 

## JavaScript = JS
JavaScript是一种客户端弱类型的动态脚本语言，它一般是用来提供一些简单的客户端功能，用来补充html的不足。比如，快速验证你填写的 email 地址是否合法；如数据验证处理、页面动态效果、定时任务、与用户交互、发送/接收服务器端数据等等。

**javascript 不是用来做动态网站的，而 jsp/servlet 是**。比如说新浪这个爱问程序，当你回答一个问题的时候，输入框右下角会显示你还能输入几个汉字，这个就是用 javascript 实现的，而当你点了提交按钮以后，服务器会收到你的回答，并把回答存入数据库，这个存入数据库的功能就可以通过 jsp 或 servlet 实现。

**原生 js，js 库，js 框架，js 插件**

- 原生js，是指最基础的js，没有封装过，但因为各浏览器对js的支持不同，就导致用基础的js编程需要为不同的浏览器写兼容代码。

- Js库，js框架，是指集成一系列dom操作，API封装，界面UI封装的的库类，常见的有jQuery，extjs等等；

- Js插件，就是集成了帮助程序员轻松完成功能的程序。Js插件用得比较多，网页制作上随处可见。如图片轮换功能，导航制作，上传图片等等。


**动态语言**指的是程序运行时可以改变结构，主要体现在：
- js中的变量在声明的时候不需要指定类型，其实际类型由程序运行中的赋值决定，在运行过程中变量的类型也可以改变。**注：这一点是动态语言的特征，并不是弱类型语言的特征。**
- 函数可变。js允许在运行过程中使用eval动态执行字符串里的命令，也可以通过new Function等方式由字符串动态构造函数，函数可以被创建、修改、删除，可以从已有函数构造出新函数，等等。
- 对象的成员可变，可以动态添加、删除成员属性或成员方法。

**弱类型**指的是js中的变量在参与运算的时候可以根据实际需要动态转换类型。与之相对应的是强类型语言——变量一般不允许自动转换类型（某些强类型语言的字符串连接操作除外），如果参与运算、调用时不符合要求的类型，则会在编译阶段报错。

js也可以在浏览器之外的其他场合使用，如服务器端的Node.js、java的Rhino、无界面浏览器PhantomJS等。

### jQuery

**jQuery 是 js 的一个工具库**，由 John Resig 在2006年发布。
j 代表 JavaScript，query 是“查询”的意思。也就是说，这个库的意图是基于 JavaScript 的查询。
查询的目标是什么？答案是 DOM（文档对象模型）结构中的 Node（节点）。一个网页就是一个 html 文档，而网页上的所有内容都是节点，包括文档节点、元素节点、文本节点、注释节点、属性节点等等。而 jQuery 的查询最主要针对的是元素节点，如段落（p）、锚点（a）、表格（table）等，只有少数方法可以处理文本节点与注释节点。同时 jQuery 还可以用 attr 方法方便地对元素节点的属性进行读取/设置。

在 jQuery 出现之前，在 js 程序中获取元素节点比较麻烦，例如获取id为elem1的节点：`document.getElementById('elem1')`

或者是获取页面上的所有checkbox元素，首先需要获取input类型的元素：`document.getElementsByTagName('input')`然后对获得的元素列表进行 for 循环处理，逐个判断其类型是否为 checkbox。
如果有更多元化的查询要求，则对应的js代码也会相当复杂。虽然有一些库可以解决这方面的需求，但强大程度、易用性等方面都不太理想。

John Resig发现了一个盲点——css样式应用到页面上的元素时，是有一套规则的，即css选择器，浏览器可以通过css选择器找到匹配的元素并将指定的样式应用到这些元素上。也就是说，通过css选择器可以有效地进行元素查找定位，但它最初只被用于样式领域。于是，John Resig根据css选择器编写了jQuery选择器，并对选择器的规则进行了扩充，从而让元素查找变得非常方便。例如，上面2个例子用jQuery可以写为： `$('#elem1')` 和 `$(":checkbox")`

同时，jQuery还有一个核心思想——链式操作，例如：
```js
$('div.con')
    .height(100)
    .show();
```
这样的连续调用可以让代码书写更加简洁，也就是jQuery自己的口号：write less, do more。

此外，jQuery还提供了浏览器兼容、样式读写、事件绑定与执行、动画等特性，后来又加入了ajax、promise等，再加上方便的插件编写机制，对整个js的生态圈产生了重大的影响，可以说是js历史上影响力最大的一个库。其中选择器引擎后来被单独剥离出来成为sizzle，供其他的js库调用。这部分的工作还影响了官方，在jQuery成功之后，浏览器才有了querySelector与querySelectorAll方法。时至今日，虽然有了querySelector与querySelectorAll，但jQuery的选择器仍然有少部分特性是前2者所无法替代的。

### ajax

ajax全称Asynchronous JavaScript and XML（异步的JavaScript与XML），是网页无需刷新页面、**使用js与服务器进行交互的一种技术**。

有时候会有这样一种需求：只希望更改页面上的一个区域。然而在从前的技术框架内只能刷新整个页面，带来的后果是：①需要重新传输整个页面，服务器端与客户端的流量消耗都会比较大；②如果是动态页，服务器端需要重新生成整个页面，即使是那些客户原本不想要刷新的区域，增大了服务器的负担。

ajax的基本流程可以概括为：页面上js脚本实例化一个XMLHttpRequest对象，设置好服务器端的url、必要的查询参数、回调函数之后，向服务器发出请求，服务器在处理请求之后将处理结果返回给页面，触发事先绑定的回调函数。这样，页面脚本如果想要改变一个区域的内容，只需要通过ajax向服务器获取与该区域有关的少量数据，在回调函数中将该区域的内容替换掉即可，不需要刷新整个页面。

XMLHttpRequest在发送请求的时候，有两种方式：同步与异步。同步方式是请求发出后，一直到收到服务器返回的数据为止，浏览器进程被阻塞，页面上什么事也做不了。而异步方式则不会阻塞浏览器进程，在服务端返回数据并触发回调函数之前，用户依然可以在该页面上进行其他操作。ajax的核心是异步方式，而同步方式只有在极其特殊的情况下才会被用到。

XMLHttpRequest在早期IE浏览器里是使用ActiveX来实现的，并不是浏览器自身的对象。后来其他各家浏览器也都实现了XMLHttpRequest对象，而高版本IE也把XMLHttpRequest改为了浏览器的内建对象。


### JSON

JSON全称JavaScript Object Notation（js对象标记法），JSON是基于JavaScript的，是JavaScript的一个子集。**JSON是用JavaScript语法来表示数据的一种轻量级语言**。

从ajax的命名中我们就可以看到，数据交换是通过XML格式进行的。在ajax刚出现的时候，绝大多数应用都是采用XML格式，也有少数使用纯文本的。但是XML格式有一个缺点，就是文档构造复杂，需要传输比较多的字节数。在这种情况下，**JSON的轻便性逐渐得到重视，后来替代XML成为ajax最主要的数据传输格式**。可以举个简单的例子感受一下二者的区别：

```xml
<?xml version="1.0" encoding="utf-8"?>
<root>
  <article>
    <title>Article Title1</title>
    <content>content1</content>
  </article>
  <article>
    <title>Article Title2</title>
    <content>content2</content>
  </article>
</root>
```

```json
{
  "article" : [
    {
      "title": "Article Title1",
      "content": "content1"
    },
    {
      "title": "Article Title2",
      "content": "content2"
    }
  ]
}
```
XML规范实际上是比较复杂的，单纯作为数据传输来说它太重了。在ajax领域中JSON取代XML的过程，是一个很好的“用脚投票”的范例。

回到js自身，对于对象构造有两种方法：基于对象的完整写法，字面量表示法。前者如：

```js
var obj = new Object();
obj.title = "title1";
obj.content = "content1";

```

而与之对应的字面量表示法则写为：

```js
var obj = {
    title: "title1",
    content: "content1"
};

```

可以明显看出字面量表示法要简洁得多。而JSON基本就是字面量表示法的一个子集，除了强制要求键与字符串类型的值必须用双引号包起之外，它剔除了undefined、function等类型，也不包括浏览器内置对象类型（如Date、RegExp等），是基于文本的、比较纯粹的数据表示方法。所以说，Douglas是“发现”了JSON，而不是“发明”。标准的JSON不包含注释，但后来因为实际需求而出现了能够处理注释的JSON库。


### Node.js

Node.js是Ryan Dahl在2009年发布的、主要用于服务器端的Javascript运行环境，也可以用于个人电脑。
Ryan Dahl此前一直在寻找一种事件驱动型的、异步的服务器端框架，实际上，js并不是他的首选。他是在尝试了几种语言之后，才发现js的函数回调与单线程特性正好契合他的要求，于是Node.js应运而生。
js的异步回调在ajax的部分已经提过：在调用异步方法的时候，可以将后续的处理函数作为参数传入，在调用相应的异步接口之后，程序会将线程的控制权让出，允许其他代码执行；在接口返回处理结果后，再执行后续处理函数（即回调函数）。实际上，**因为js是单线程语言，回调函数并不是立刻被执行的，而是会被送入任务队列，在线程空闲、并且队列前方没有其他任务的情况下，才会被执行。**

用户在向服务器提交请求的时候，如果处理比较费时，传统的服务器端框架会导致处理线程被阻塞。而js的特性使得异步任务在执行的时候让出线程的控制权，在处理完成后再进行正确的回调，从而能够获得比较好的高并发处理能力。
js本身是一门严格的单线程语言，而Node.js为了充分发挥服务器的处理能力，在运行环境级别上增加了对于多线程的支持（child process）。但Node.js的多线程与常规的多线程有很大区别——常规语言的多线程允许多个线程共享数据，或者调用其他线程暴露出来的公开方法，而Node.js的多线程只能用消息机制进行通讯。这样，Node.js就规避了常规多线程的数据同步、线程锁（线程同步/互斥）等复杂问题，规避了一些潜在风险。

Node.js使用的V8引擎实际上就是Google的Chrome浏览器使用的Javascript引擎（因为V8引擎是开源的），并进行了模块扩展。例如遵循CommonJS标准的模块定义，适合服务器需求的多线程、集群、HTTP/HTTPS，文件系统，等等。Node.js中的很多方法都同时提供了异步版本与同步版本，从函数的命名上可以简单区分。
得益于其模块特性，Node.js的模块扩展变得相当方便，用于Node.js包管理的npm得到了广泛的使用，但也曾经引起“是否过度使用依赖包”的争论。

Node.js不仅可用于服务器端，因为其安装完成之后可以用命令行方式方便地调用，因此在个人电脑中也逐渐得到广泛应用。例如为代码编辑器提供插件、用于桌面的Node.js App等。另外还有一个重要的应用领域就是前端自动化，包括代码的预编译/转换（如使用Babel将ECMAScript 6的代码转换为低版本的es代码，将sass/less的样式表文件编译为传统的css文件）、语法检查、代码文件或图像文件的合并、代码的混淆/压缩、自动分发、自动测试等，还可以监视开发文件夹，在内容改变时自动执行上述操作，并自动刷新浏览器页面。这样使得前端领域的开发方式得到了大大进化。

js虽然因为有着一些先天不足而被人诟病，但这些年来却越发展越壮大。这不仅仅是因为依托于浏览器这个宿主环境，更是因为其自身具备的一些优秀特性，Node.js的出现与发展就是一个很好的例证。


## Java Server Page = JSP

jsp其实可以看做一种脚本语言，需要用servlet来编译实现，然而作为一种脚本语言它有相当强大，在其中**可以嵌入java代码**，jsp中几乎可以使用全部的java类 。其实就是可以把jsp当做html来作为网页显示出来，而且其上还可以嵌套java语言，也可以嵌套其他的语言类似，当然都序言用servlet来编译实现。jsp作为字节码文件执行后可以直接运行，不必每次都要编译，速度快。可能我表述还是有点问题，但是jsp和js大多都应用于web网页的编写上，jsp可以看做html和java的结合体，当然js就可以在jsp上实现一些动作，特效，验证功能，与在html中所实现的效果一样。因为jsp是在服务器端解释执行的，服务器执行转化后的.class程序，客户端接收到的只是服务器发来的html代码，看不到jsp代码。而js可以在客户端通过查看源代码显示出来。

jsp只是相当于java里面的servlet部分

jsp/servlet 是服务器端的程序，它们由服务器执行。servlet 可以完全替代 jsp ，一般来说，对普通网站而言，jsp 也可以替代 servlet 的作用。之所以会有 jsp 和 servlet 这两个功能上差不多的东西，是因为一些设计模式/软件工程上的考虑，简单一点理解的话，也可以这么说：jsp 比 servlet 要简单，而 servlet 要比 jsp 强大、有效，因此针对网站的不同功能模块，需要合理选择使用 servlet 还是 jsp 来编写。


## Servlet


## DOM




## 动态网站

动态不是说页面上的东西能动，而是说你这个网站有一些诸如留言板、论坛之类的无法仅仅通过客户端浏览器实现的功能。



## 总结

ajax与Node.js都使用了js的异步回调特性。
jQuery的出现解决了那个各方面标准尚未统一的混乱时代的许多问题，让js的应用更加广泛，并为未来某些标准的制定指明了方向。
**JSON从js中脱胎而出，作为一种简洁、扩展性好的轻量级数据表示方法**，在很多领域得到了广泛使用。
Node.js在服务器端与开发流程中都越来越得到重视。
由于Node.js不包含BOM与DOM，因此jQuery不能直接在Node.js上使用，但可以借助jsdom、cheerio之类的库，在构造出虚拟的dom结构后再使用。查看github上的jQuery开发包，可以看到它使用了Node.js上的grunt来进行自动化构建、测试的工作。
以上几项技术的共同进步，配合浏览器的进步，此外还有硬件条件的发展，让复杂的页面应用越来越多，许多以前在服务器端进行的工作可以转到客户的浏览器中进行，顺应了分布式处理的潮流。

**补充**
1\. js设计之初并不是用来弹窗或者改变页面上内容，这些功能是随着浏览器的发展才出现的。实际上js语言自身并不能实现这样的需求。

完整的JavaScript包括ECMAScript、BOM（浏览器对象模型，如window、location等对象）、DOM。其中BOM和DOM虽然是js的组成部分，但js只规定了这两者的接口规范，即浏览器返回这两类对象时，可以用js的方式来处理（点号或者方括号来操作对象成员，可以读取或修改属性等）。也就是说，js脚本通过浏览器提供的接口去操作BOM和DOM，js在其中主要进行流程控制。没有这些接口的支持，js自身是无法完成一些功能的。而早期各家浏览器对于接口实现的不同，也带来了比较严重的兼容性问题。

从js的标准化工作也能看出之间的不同。ECMAScript是由ECMA来进行标准化工作，而BOM和DOM则是由W3C（World Wide Web Consortium）来进行标准化的。

2\. jQuery设计的第一要素是对于节点的查询。解决兼容性问题也是jQuery设计的重点，但不是第一位的。当时在尝试解决兼容性问题的js库有好几个，jQuery在这方面并不唯一。而jQuery选择器才是jQuery划时代的特性，从早已存在的事物（css选择器）中发现了价值，并将其修改扩充、发扬光大。

不可否认，jQuery的流行很大程度上要归功于解决兼容性问题，但作为名称中包含的“query”连提都不提，这答案有点偏了。

3\. ajax创建之初是用于处理Gmail、Google Maps这样的复杂页面应用，表单提交方式的改变只是ajax技术发展的一个副产品而已。

并且表单提交的问题并不仅仅在于填错项目，实际面临的问题要复杂得多，包括用户的网络掉线、服务器端因为请求过多而暂时无法响应等不可抗因素。在传统模式下，提交表单是前往一个新的动态页，如果出现了错误，运气好的时候点浏览器的“后退”按钮还可以返回表单填写界面，刚才写的东西都还在；运气不好的时候，只会看见一个空白的表单。当时在一些论坛里，总能看到“辛辛苦苦码的字一提交就全没了”的哭诉。

4\. 对于JSON的用途描述有错。原答案中提到提交内容简单的时候，用字符串发送，后来改为XML与JSON。实际上，JSON用于客户端（包括浏览器）与服务端通讯的时候，主要指的是服务器端返回处理结果时送回给客户端的数据格式是JSON。而客户端提交给服务器端的数据大多数并不是XML或JSON格式的。

客户端向服务器端提交数据的时候，使用GET或POST方法，其数据一般是简单的“键/值对”表示，例如常见的GET方法在url中构造的参数：`?page=1&pagesize=20`

POST方法在提交一般类型的表单时，与GET方法在数据组织形式上基本相近（除非是用multipart类型的表单发送文件数据），但http数据包格式、浏览器历史记录、以及服务器端接收处理有所区别，这属于http协议的内容，此处不展开。
因此，客户端向服务器端提交数据的时候，主要是采用字符串拼接的方式按上述例子构造，一般不会使用XML或者JSON格式，特别是在ajax出现的早期。（近年来随着页面应用越来越复杂，用JSON格式向服务器端传递数据的情况也逐渐增加）
而服务器端返回给客户端的数据格式，一开始的主流就是XML，不存在以字符串为主然后过渡到XML的过程。
另外，XMLHTTP还可以用来进行服务器间通讯，早期发送与接收数据的主流格式都是XML，但是这与ajax不是一回事。


