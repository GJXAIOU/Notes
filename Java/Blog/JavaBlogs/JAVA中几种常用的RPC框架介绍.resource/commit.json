{"compress":true,"commitItems":[["7c46b77f-5499-4a13-9784-39b3ec009c5d",1564537220952,"# JAVA中几种常用的RPC框架介绍\n\n [![java架构师](https://pic1.zhimg.com/v2-17298a78e5365d26d85d451e23a4853c_xs.jpg)](https://www.zhihu.com/people/javajia-gou-shi-98) \n\n [java架构师](https://www.zhihu.com/people/javajia-gou-shi-98) \n\n架构师\n\n1 人赞同了该文章\n\nRPC是远程过程调用的简称，广泛应用在大规模分布式应用中，作用是有助于系统的垂直拆分，使系统更易拓展。Java中的RPC框架比较多，各有特色，广泛使用的有RMI、Hessian、Dubbo等。RPC还有一个特点就是能够跨语言，本文只以JAVA语言里的RPC为例。\n\n对于RPC有一个逻辑关系图，以RMI为例：\n\n![](https://pic3.zhimg.com/80/v2-f771e70d45bc8b69435363da62adc72a_hd.jpg)\n\n其他的框架结构也类似，区别在于对象的序列化方法，传输对象的通讯协议，以及注册中心的管理与failover设计（利用zookeeper）。\n\n客户端和服务端可以运行在不同的JVM中，Client只需要引入接口，接口的实现以及运行时需要的数据都在Server端，RPC的主要依赖技术是序列化、反序列化和传输协议，JAVA里对应的就是对象的序列化、反序列化以及序列化后数据的传输。RMI的序列化和反序列化是JAVA自带的，Hessian里的序列化和反序列化是私有的，传输协议则是HTTP，Dubbo的序列化可以多种选择，一般使用Hessian的序列化协议，传输则是TCP协议，使用了高性能的NIO框架Netty。对于序列化，我还了解一些，像Google的ProBuffer、JBoss Marshalling和Apache Thrift等，之前有写一篇介绍ProBuffer的博文\n\n1、RMI（远程方法调用）\n\nJAVA自带的远程方法调用工具，不过有一定的局限性，毕竟是JAVA语言最开始时的设计，后来很多框架的原理都基于RMI，RMI的使用如下：\n\n对外接口\n\n```text\n<span style=\"font-size:12px;\">public interface IService extends Remote {\n\n    public String queryName(String no) throws RemoteException;\n\n}</span>\n```\n\n**服务实现**\n\n```text\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\n\n// 服务实现\npublic class ServiceImpl extends UnicastRemoteObject implements IService {\n\n    /**\n     */\n    private static final long serialVersionUID = 682805210518738166L;\n\n    /**\n     * @throws RemoteException\n     */\n    protected ServiceImpl() throws RemoteException {\n        super();\n    }\n\n    /* (non-Javadoc)\n     *\n     */\n    @Override\n    public String queryName(String no) throws RemoteException {\n        // 方法的具体实现\n        System.out.println(\"hello\" + no);\n        return String.valueOf(System.currentTimeMillis());\n    }\n\n}\n\n```\n\n**RMI客户端**\n\n```text\nimport java.rmi.AccessException;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\n\n// RMI客户端\npublic class Client {\n\n    public static void main(String[] args) {\n        // 注册管理器\n        Registry registry = null;\n        try {\n            // 获取服务注册管理器\n            registry = LocateRegistry.getRegistry(\"127.0.0.1\",8088);\n            // 列出所有注册的服务\n            String[] list = registry.list();\n            for(String s : list){\n                System.out.println(s);\n            }\n        } catch (RemoteException e) {\n\n        }\n        try {\n            // 根据命名获取服务\n            IService server = (IService) registry.lookup(\"vince\");\n            // 调用远程方法\n            String result = server.queryName(\"ha ha ha ha\");\n            // 输出调用结果\n            System.out.println(\"result from remote : \" + result);\n        } catch (AccessException e) {\n\n        } catch (RemoteException e) {\n\n        } catch (NotBoundException e) {\n\n        }\n    }\n}\n\n```\n\n**RMI服务端**\n\n```text\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\n\n// RMI服务端\npublic class Server {\n\n    public static void main(String[] args) {\n        // 注册管理器\n        Registry registry = null;\n        try {\n            // 创建一个服务注册管理器\n            registry = LocateRegistry.createRegistry(8088);\n\n        } catch (RemoteException e) {\n\n        }\n        try {\n            // 创建一个服务\n            ServiceImpl server = new ServiceImpl();\n            // 将服务绑定命名\n            registry.rebind(\"vince\", server);\n\n            System.out.println(\"bind server\");\n        } catch (RemoteException e) {\n\n        }\n    }\n}\n\n```\n\n服务注册管理器写在了Server里，当然也可以抽出来单独作为一个服务，在其他一些框架中，往往用Zookeeper充当注册管理角色。\n\n2、Hessian（基于HTTP的远程方法调用）\n\n基于HTTP协议传输，在性能方面还不够完美，负载均衡和失效转移依赖于应用的负载均衡器，Hessian的使用则与RMI类似，区别在于淡化了Registry的角色，通过显示的地址调用，利用HessianProxyFactory根据配置的地址create一个代理对象，另外还要引入Hessian的Jar包。\n\n![](https://pic1.zhimg.com/80/v2-f20d91abb298359dc64b7c4bc76b578c_hd.jpg)\n\n**3、Dubbo（淘宝开源的基于TCP的RPC框架）**\n\n基于Netty的高性能RPC框架，是阿里巴巴开源的，总体原理如下：\n\n![](https://pic4.zhimg.com/80/v2-58b20e319f8bd0ce40e472315b9d3377_hd.jpg)\n\n在了解Dubbo之前，要先对Zookeeper有深入的理解，当理解了zookeeper后，Dubbo也就了无秘密了。\n\nDubbo的详细说明在淘宝开源里说的非常详细，在工作中很多生产项目都用了Dubbo，过程中也发现了很多需要注意的地方，尤其是那繁多的配置，设置不当都会让人烦脑，最好能再基于现有开源的Dubbo再定制优化一下。\n\n欢迎工作一到五年的Java工程师朋友们加入Java架构开发：855801563\n\n群内提供免费的Java架构学习资料（里面有高可用、高并发、高性能及分布式、Jvm性能调优、Spring源码，MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx等多个知识点的架构资料）合理利用自己每一分每一秒的时间来学习提升自己，不要再用\"没有时间“来掩饰自己思想上的懒惰！趁年轻，使劲拼，给未来的自己一个交代",[[1564537216305,["GJX@GJXAIOU",[[-1,21," [![java架构师](https://pic1.zhimg.com/v2-17298a78e5365d26d85d451e23a4853c_xs.jpg)](https://www.zhihu.com/people/javajia-gou-shi-98) \n\n [java架构师](https://www.zhihu.com/people/javajia-gou-shi-98) "]],[21,213],[21,21]]],[1564537228634,["GJX@GJXAIOU",[[1,21,"[原文链接地址](https://zhuanlan.zhihu.com/p/46818259)"]],[21,21],[68,68]]],[1564537232721,["GJX@GJXAIOU",[[-1,70,"架构师\n\n1 人赞同了该文章"]],[70,84],[70,70]]],[1564537246441,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1564537248141,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1564537248291,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1564537248459,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1564537248486,["GJX@GJXAIOU",[[1,4,"\n---\n\n"]],[3,3],[4,4]]],[1564537251243,["GJX@GJXAIOU",[[1,4,"tags:"]],[4,4],[9,9]]],[1564537252347,["GJX@GJXAIOU",[[1,10,"\n"]],[9,9],[10,10]]],[1564537254010,["GJX@GJXAIOU",[[1,10,"- wi"]],[10,10],[14,14]]],[1564537254612,["GJX@GJXAIOU",[[-1,12,"wi"]],[14,14],[12,12]]],[1564537257262,["GJX@GJXAIOU",[[1,12,"未看"]],[12,12],[14,14]]]],null,"GJX@GJXAIOU"]]}