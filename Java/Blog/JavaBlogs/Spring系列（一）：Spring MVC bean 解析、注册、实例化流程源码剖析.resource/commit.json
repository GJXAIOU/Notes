{"compress":true,"commitItems":[["5129261d-5791-446b-9006-1c369879d9dd",1573954068280," [七分熟pizza](https://juejin.im/user/5895420861ff4b006b040369)[![lv-2](https://b-gold-cdn.xitu.io/v3/static/img/lv-2.f597b88.svg)](https://juejin.im/book/5c90640c5188252d7941f5bb/section/5c9065385188252da6320022)\n\n2019年04月19日阅读 404\n\n关注\n\n# Spring系列（一）：Spring MVC bean 解析、注册、实例化流程源码剖析\n\n## 1．背景\n\n最近在使用Spring MVC过程中遇到了一些问题，网上搜索不少帖子后虽然找到了答案和解决方法，但这些答案大部分都只是给了结论，并没有说明具体原因，感觉总是有点不太满意。\n\n更重要的是这些所谓的结论大多是抄来抄去，基本源自一家，真实性也有待考证。\n\n> 要成为一名优秀的码农，不仅能熟练的复制粘贴，更要有打破砂锅问到底的精神，达到知其然也知其所以然的境界。\n\n那作为程序员怎么能知其所以然呢？\n\n> 答案就是阅读源代码！\n\n此处请大家内心默读三遍。\n\n用过Spring 的人都知道其核心就是IOC和AOP，因此要想了解Spring机制就得先从这两点入手，本文主要通过对IOC部分的机制进行介绍。\n\n## 2\\. 实验环境\n\n在开始阅读之前，先准备好以下实验材料。\n\n*   Spring 5.0源码([github.com/spring-proj…](https://github.com/spring-projects/spring-framework.git))\n\n*   IDE：Intellij IDEA\n\nIDEA 是一个优秀的开发工具，如果还在用Eclipse的建议切换到此工具进行。\n\nIDEA有很多的快捷键，在分析过程中建议大家多用Ctrl+Alt+B快捷键，可以快速定位到实现函数。\n\n## 3\\. Spring Bean 解析注册\n\nSpring bean的加载主要分为以下6步：\n\n*   （1）读取XML配置文件\n*   （2）XML文件解析为document文档\n*   （3）解析bean\n*   （4）注册bean\n*   （5）实例化bean\n*   （6）获取bean\n\n### 3.1 读取XML配置文件\n\n查看源码第一步是找到程序入口，再以入口为突破口，一步步进行源码跟踪。\n\nJava Web应用中的入口就是web.xml。\n\n在web.xml找到ContextLoaderListener ，此Listener负责初始化Spring IOC。\n\ncontextConfigLocation参数设置了bean定义文件地址。\n\n```\n<listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n</listener>\n<context-param>\n    <param-name>contextConfigLocation</param-name>\n    <param-value>classpath*:spring.xml</param-value>\n</context-param>\n复制代码\n```\n\n下面是ContextLoaderListener的官方定义：\n\n> public class ContextLoaderListener extends ContextLoader implements ServletContextListener\n\n> Bootstrap listener to start up and shut down Spring's root WebApplicationContext. Simply delegates to ContextLoader as well as to ContextCleanupListener.\n\n> [docs.spring.io/spring-fram…](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/context/ContextLoaderListener.html)\n\n翻译过来ContextLoaderListener作用就是负责启动和关闭Spring root WebApplicationContext。\n\n具体WebApplicationContext是什么？开始看源码。\n\n```\npackage org.springframework.web.context;\npublic class ContextLoaderListener extends ContextLoader implements ServletContextListener {\n    public ContextLoaderListener() {\n    }\n    public ContextLoaderListener(WebApplicationContext context) {\n        super(context);\n    }\n    //servletContext初始化时候调用\n    public void contextInitialized(ServletContextEvent event) {\n        this.initWebApplicationContext(event.getServletContext();\n    }\n    //servletContext销毁时候调用\n    public void contextDestroyed(ServletContextEvent event) {\n        this.closeWebApplicationContext(event.getServletContext());\n    }\n}\n复制代码\n```\n\n从源码看出此Listener主要有两个函数，一个负责初始化WebApplicationContext，一个负责销毁。\n\n继续看initWebApplicationContext函数。\n\n```\npublic WebApplicationContext initWebApplicationContext(ServletContext servletContext) {\n//初始化Spring容器时如果发现servlet 容器中已存在根Spring容根器则抛出异常，证明rootWebApplicationContext只能有一个。\n   if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {\n      throw new IllegalStateException(\n            \"Cannot initialize context because there is already a root application context present - \" +\n            \"check whether you have multiple ContextLoader* definitions in your web.xml!\");\n   }\n   if (this.context == null) {\n\t//1.创建webApplicationContext实例\n        this.context = createWebApplicationContext(servletContext);\n   }\n   if (this.context instanceof ConfigurableWebApplicationContext) {\n        ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;\n\t //2.配置WebApplicationContext\n        configureAndRefreshWebApplicationContext(cwac, servletContext);\n    }\n    //3.把生成的webApplicationContext 设置为root webApplicationContext。\n    servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);\n    return this.context; \n\n}\n复制代码\n```\n\n在上面的代码中主要有两个功能：\n\n*   （1）创建WebApplicationContext实例。\n*   （2）配置生成WebApplicationContext实例。\n*   （3）把生成的webApplicationContext 设置为root webApplicationContext。\n\n#### 3.1.1 创建WebApplicationContext实例\n\n进入CreateWebAPPlicationContext函数\n\n```\nprotected WebApplicationContext createWebApplicationContext(ServletContext sc) {\n   //得到ContextClass类,默认实例化的是XmlWebApplicationContext类\n   Class<?> contextClass = determineContextClass(sc);\n   //实例化Context类\n   return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n}\n复制代码\n```\n\n进入determineContextClass函数。\n\n```\nprotected Class<?> determineContextClass(ServletContext servletContext) {\n   // 此处CONTEXT_CLASS_PARAM = \"contextClass\"String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);\n   if (contextClassName != null) {\n         //若设置了contextClass则使用定义好的ContextClass。\n         return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());\n      }\n   else {\n      //此处获取的是在Spring源码中ContextLoader.properties中配置的org.springframework.web.context.support.XmlWebApplicationContext类。\n      contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());\n      return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());\n}\n复制代码\n```\n\n#### 3.1.2 配置Web ApplicationContext\n\n进入configureAndReFreshWebApplicaitonContext函数。\n\n```\nprotected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {\n  //webapplicationContext设置servletContext.\n   wac.setServletContext(sc);\n   // 此处CONFIG_LOCATION_PARAM = \"contextConfigLocation\"，即读即取web.xm中配设置的contextConfigLocation参数值，获得spring bean的配置文件.\n   String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);\n   if (configLocationParam != null) {\n      //webApplicationContext设置配置文件路径设。\n      wac.setConfigLocation(configLocationParam);\n   }\n   //开始处理bean\n   wac.refresh();\n}\n复制代码\n```\n\n### 3.2 解析XML文件\n\n上面wac变量声明为ConfigurableWebApplicationContext类型，ConfigurableWebApplicationContext又继承了WebApplicationContext。\n\nWebApplication Context有很多实现类。 但从上面determineContextClass得知此处wac实际上是XmlWebApplicationContext类，因此进入XmlWebApplication类查看其继承的refresh()方法。\n\n沿方法调用栈一层层看下去。\n\n```\npublic void refresh() throws BeansException, IllegalStateException {\n   synchronized (this.startupShutdownMonitor) {\n      //获取beanFactory\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n     // 实例化所有声明为非懒加载的单例bean \n      finishBeanFactoryInitialization(beanFactory);\n    }\n}\n复制代码\n```\n\n获取beanFactory。\n\n```\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n     //初始化beanFactory\n     refreshBeanFactory();\n     return beanFactory;\n}\n复制代码\n```\n\nbeanFactory初始化。\n\n```\n@Override\nprotected final void refreshBeanFactory() throws BeansException {\n      DefaultListableBeanFactory beanFactory = createBeanFactory();\n      //加载bean定义\n      loadBeanDefinitions(beanFactory);\n      synchronized (this.beanFactoryMonitor) {\n      this.beanFactory = beanFactory;\n      }\n}\n复制代码\n```\n\n加载bean。\n\n```\nprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n   //创建XmlBeanDefinitionReader实例来解析XML配置文件\n   XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n   initBeanDefinitionReader(beanDefinitionReader);\n   //解析XML配置文件中的bean。\n   loadBeanDefinitions(beanDefinitionReader);\n}\n复制代码\n```\n\n读取XML配置文件。\n\n```\nprotected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws IOException {\n//此处读取的就是之前设置好的web.xml中配置文件地址\n   String[] configLocations = getConfigLocations();\n   if (configLocations != null) {\n      for (String configLocation : configLocations) {\n         //调用XmlBeanDefinitionReader读取XML配置文件\n         reader.loadBeanDefinitions(configLocation);\n      }\n   }\n}\n复制代码\n```\n\nXmlBeanDefinitionReader读取XML文件中的bean定义。\n\n```\npublic int loadBeanDefinitions(String location, Set<Resource> actualResources) throws BeanDefinitionStoreException {\n   ResourceLoader resourceLoader = getResourceLoader();\n      Resource resource = resourceLoader.getResource(location);\n      //加载bean\n      int loadCount = loadBeanDefinitions(resource);\n      return loadCount;\n   }\n}\n复制代码\n```\n\n继续查看loadBeanDefinitons函数调用栈，进入到XmlBeanDefinitioReader类的loadBeanDefinitions方法。\n\n```\npublic int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {\n      //获取文件流\n      InputStream inputStream = encodedResource.getResource().getInputStream();\n      InputSource inputSource = new InputSource(inputStream);\n     //从文件流中加载定义好的bean。\n      return doLoadBeanDefinitions(inputSource, encodedResource.getResource());\n   }\n}\n复制代码\n```\n\n最终将XML文件解析成Document文档对象。\n\n```\nprotected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n      //XML配置文件解析到Document实例中\n      Document doc = doLoadDocument(inputSource, resource);\n      //注册bean\n      return registerBeanDefinitions(doc, resource);\n   }\n复制代码\n```\n\n### 3.3 解析bean\n\n上一步完成了XML文件的解析工作，接下来将XML中定义的bean注册到webApplicationContext，继续跟踪函数。\n\n```\npublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {\n   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();\n   //使用documentRedder实例读取bean定义\n   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n   }\n复制代码\n```\n\n用BeanDefinitionDocumentReader对象来注册bean。\n\n```\npublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n   this.readerContext = readerContext;\n   //读取document元素\n   Element root = doc.getDocumentElement();\n   //真正开始注册bean\n   doRegisterBeanDefinitions(root);\n}\n复制代码\n```\n\n解析XML文档。\n\n```\nprotected void doRegisterBeanDefinitions(Element root) {\n    //预处理XML \n   preProcessXml(root);\n   //解析注册bean\n   parseBeanDefinitions(root, this.delegate);\n   postProcessXml(root);\n}\n复制代码\n```\n\n循环解析XML文档中的每个元素。\n\n```\nprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {\n   //如果该元素属于默认命名空间走此逻辑。Spring的默认namespace为：http://www.springframework.org/schema/beans“\n   if (delegate.isDefaultNamespace(root)) {\n      NodeList nl = root.getChildNodes();\n      for (int i = 0; i < nl.getLength(); i++) {\n         Node node = nl.item(i);\n         if (node instanceof Element) {\n            Element ele = (Element) node;\n            //对document中的每个元素都判断其所属命名空间，然后走相应的解析逻辑\n            if (delegate.isDefaultNamespace(ele)) {\n               parseDefaultElement(ele, delegate);\n            }\n            else {\n               delegate.parseCustomElement(ele);\n            }\n         }\n      }\n   }\n   else {\n      //如果该元素属于自定义namespace走此逻辑 ，比如AOP，MVC等。\n      delegate.parseCustomElement(root);\n   }\n}\n复制代码\n```\n\n下面是默认命名空间的解析逻辑。\n\n不明白Spring的命名空间的可以网上查一下，其实类似于package，用来区分变量来源，防止变量重名。\n\n```\nprivate void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {\n   //解析import元素\n   if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n      importBeanDefinitionResource(ele);\n   }\n   //解析alias元素\n   else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n      processAliasRegistration(ele);\n   }\n   //解析bean元素\n   else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n      processBeanDefinition(ele, delegate);\n   }\n   //解析beans元素\n   else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n      // recurse\n      doRegisterBeanDefinitions(ele);\n   }\n}\n复制代码\n```\n\n这里我们就不一一跟踪，以解析bean元素为例继续展开。\n\n```\nprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n   //解析bean\n   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n   if (bdHolder != null) {\n         // 注册bean\n         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n   }\n}\n复制代码\n```\n\n解析bean元素，最后把每个bean解析为一个包含bean所有信息的BeanDefinitionHolder对象。\n\n```\npublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {\n   String id = ele.getAttribute(ID_ATTRIBUTE);\n   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);\n   return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n}\n复制代码\n```\n\n### 3.4 注册bean\n\n接下来将解析到的bean注册到webApplicationContext中。接下继续跟踪registerBeanDefinition函数。\n\n```\npublic static void registerBeanDefinition(\n      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)\n      throws BeanDefinitionStoreException {\n      // 获取beanname\n      String beanName = definitionHolder.getBeanName();\n      //注册bean\n      registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());\n      // 注册bean的别名\n      String[] aliases = definitionHolder.getAliases();\n      if (aliases != null) {\n          for (String alias : aliases) {\n             registry.registerAlias(beanName, alias);\n     }\n   }\n}\n复制代码\n```\n\n跟踪registerBeanDefinition函数，此函数将bean信息保存到到webApplicationContext的beanDefinitionMap变量中，该变量为map类型，保存Spring 容器中所有的bean定义。\n\n```\npublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n      throws BeanDefinitionStoreException {\n\t//把bean信息保存到beanDefinitionMap中\n        this.beanDefinitionMap.put(beanName, beanDefinition);\n\t//把beanName 保存到List 类型的beanDefinitionNames属性中\n    this.beanDefinitionNames.add(beanName);\n   }\n复制代码\n```\n\n### 3.5 实例化bean\n\nSpring 实例化bean的时机有两个。\n\n一个是容器启动时候，另一个是真正调用的时候。\n\n如果bean声明为scope=singleton且lazy-init=false，则容器启动时候就实例化该bean（Spring 默认就是此行为）。否则在调用时候再进行实例化。\n\n相信用过Spring的同学们都知道以上概念，但是为什么呢？\n\n继续从源码角度进行分析，回到之前XmlWebApplication的refresh（）方法。\n\n```\npublic void refresh() throws BeansException, IllegalStateException {\n   synchronized (this.startupShutdownMonitor) {\n      //生成beanFactory,\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n      // 实例化所有声明为非懒加载的单例bean \n      finishBeanFactoryInitialization(beanFactory);\n }\n复制代码\n```\n\n可以看到获得beanFactory后调用了 finishBeanFactoryInitialization()方法，继续跟踪此方法。\n\n```\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\n  // 初始化非懒加载的单例bean   \n  beanFactory.preInstantiateSingletons();\n}\n复制代码\n```\n\n预先实例化单例类逻辑。\n\n```\npublic void preInstantiateSingletons() throws BeansException {\n   // 获取所有注册的bean\n   List<String> beanNames = new ArrayList<String>(this.beanDefinitionNames);\n   // 遍历bean \n   for (String beanName : beanNames) {\n      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\n      //如果bean是单例且非懒加载，则获取实例\n      if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\n            getBean(beanName);\n      }\n   }\n}\n复制代码\n```\n\n获取bean。\n\n```\npublic Object getBean(String name) throws BeansException {\n   return doGetBean(name, null, null, false);\n}\n复制代码\n```\n\ndoGetBean中处理的逻辑很多，为了减少干扰，下面只显示了创建bean的函数调用栈。\n\n```\nprotected <T> T doGetBean(\n      final String name, final Class<T> requiredType, final Object[] args, boolean typeCheckOnly)\n      throws BeansException {\n\t//创建bean\n       createBean(beanName, mbd, args);\n}\n复制代码\n```\n\n创建bean。\n\n```\nprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {\n    Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n    return beanInstance;\n}\n复制代码\n```\n\n```\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)\n      throws BeanCreationException {\n      // 实例化bean   \n      instanceWrapper = createBeanInstance(beanName, mbd, args);\n}\n复制代码\n```\n\n```\nprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {\n   //实例化bean\n   return instantiateBean(beanName, mbd);\n}\n复制代码\n```\n\n```\nprotected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {\n      //调用实例化策略进行实例化\n      beanInstance = getInstantiationStrategy().instantiate(mbd, beanName,\n}\n复制代码\n```\n\n判断哪种动态代理方式实例化bean。\n\n```\npublic Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) {\n   //使用JDK动态代理\n   if (bd.getMethodOverrides().isEmpty()) {\n      return BeanUtils.instantiateClass(constructorToUse);\n   }\n   else {\n     //使用CGLIB动态代理\n     return instantiateWithMethodInjection(bd, beanName, owner);\n   }\n}\n复制代码\n```\n\n不管哪种方式最终都是通过反射的形式完成了bean的实例化。\n\n```\npublic static <T> T instantiateClass(Constructor<T> ctor, Object... args) \n      ReflectionUtils.makeAccessible(ctor);\n      return ctor.newInstance(args);\n}\n复制代码\n```\n\n### 3.6 获取bean\n\n我们继续回到doGetBean函数，分析获取bean的逻辑。\n\n```\nprotected <T> T doGetBean(\n      final String name, final Class<T> requiredType, final Object[] args, boolean typeCheckOnly)\n      throws BeansException {\n    //获取beanName\n     final String beanName = transformedBeanName(name);\n     Object bean\n    // 先检查该bean是否为单例且容器中是否已经存在例化的单例类\n    Object sharedInstance = getSingleton(beanName);\n    //如果已存在该bean的单例类\n    if (sharedInstance != null && args == null) {\n       bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n    }\n    else{\n          // 获取父BeanFactory\n          BeanFactory parentBeanFactory = getParentBeanFactory();\n          //先判断该容器中是否注册了此bean，如果有则在该容器实例化bean，否则再到父容器实例化bean\n          if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n               String nameToLookup = originalBeanName(name);\n               // 如果父容器有该bean，则调用父beanFactory的方法获得该bean\n               return (T) parentBeanFactory.getBean(nameToLookup, args);\n           }\n            //如果该bean有依赖bean，先实递归例化依赖bean。    \n            String[] dependsOn = mbd.getDependsOn();\n            if (dependsOn != null) {\n                for (String dep : dependsOn) {\n                   registerDependentBean(dep, beanName);\n                   getBean(dep);\n                }\n            }\n    \t    //如果scope为Singleton执行此逻辑\n            if (mbd.isSingleton()) {\n                sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {\n                   @Override\n                   public Object getObject() throws BeansException {\n    \t\t//调用创建bean方法\n                         return createBean(beanName, mbd, args);\n                      }\n\n                   }\n                });\n             }\n             //如果scope为Prototype执行此逻辑，每次获取时候都实例化一个bean\n             else if (mbd.isPrototype()) {\n                Object prototypeInstance = null;\n                   prototypeInstance = createBean(beanName, mbd, args);\n             }\n             //如果scope为Request,Session,GolbalSession执行此逻辑\n             else {\n                String scopeName = mbd.getScope();\n                final Scope scope = this.scopes.get(scopeName);\n                   Object scopedInstance = scope.get(beanName, new ObjectFactory<Object>() {\n                      @Override\n                      public Object getObject() throws BeansException {\n                            return createBean(beanName, mbd, args);\n                      }\n                   });\n             }\n          }\n}\n      return (T) bean;\n}\n复制代码\n```\n\n上面方法中首先调用getSingleton(beanName)方法来获取单例bean，如果获取到则直接返回该bean。方法调用栈如下：\n\n```\npublic Object getSingleton(String beanName) {\n   return getSingleton(beanName, true);\n}\n复制代码\n```\n\n```\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n//从singletonObjects中获取bean。\n   Object singletonObject = this.singletonObjects.get(beanName);\n   return (singletonObject != NULL_OBJECT ? singletonObject : null);\n}\n复制代码\n```\n\ngetSingleton方法先从singletonObjects属性中获取bean 对象,如果不为空则返回该对象，否则返回null。\n\n那 singletonObjects保存的是什么？什么时候保存的呢？\n\n回到doGetBean（）函数继续分析。如果singletonObjects没有该bean的对象，进入到创建bean的逻辑。处理逻辑如下：\n\n```\n//获取父beanFactory\nBeanFactory parentBeanFactory = getParentBeanFactory();\n//如果该容器中没有注册该bean，且父容器不为空，则去父容器中获取bean后返回\nif (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n      return parentBeanFactory.getBean(nameToLookup, requiredType);\n}\n\n复制代码\n```\n\n下面是判断容器中有没有注册bean的逻辑，此处beanDefinitionMap相信大家都不陌生，在注册bean的流程里已经说过所有的bean信息都会保存到该变量中。\n\n```\npublic boolean containsBeanDefinition(String beanName) {\n   Assert.notNull(beanName, \"Bean name must not be null\");\n   return this.beanDefinitionMap.containsKey(beanName);\n}\n复制代码\n```\n\n如果该容器中已经注册过bean，继续往下走。先获取该bean的依赖bean，如果镩子依赖bean，则先递归获取相应的依赖bean。\n\n```\nString[] dependsOn = mbd.getDependsOn();\nif (dependsOn != null) {\n    for (String dep : dependsOn) {\n         registerDependentBean(dep, beanName);\n         getBean(dep);\n    }\n}   \n复制代码\n```\n\n依赖bean创建完成后，接下来就是创建自身bean实例了。\n\n获取bean实例的处理逻辑有三种，即Singleton、Prototype、其它(request、session、global session)，下面一一说明。\n\n#### 3.6.1 Singleton\n\n如果bean是单例模式，执行此逻辑。\n\n```\nif (mbd.isSingleton()) {\n       sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {\n          @Override\n          public Object getObject() throws BeansException {\n    \t    //创建bean回调\n            return createBean(beanName, mbd, args); \n       });\n      bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n}\n复制代码\n```\n\n获取单例bean，如果已经有该bean的对象直接返回。如果没有则创建单例bean对象，并添加到容器的singletonObjects Map中，以后直接从singletonObjects直接获取bean。\n\n```\npublic Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {\n   synchronized (this.singletonObjects) {\n      Object singletonObject = this.singletonObjects.get(beanName);\n\t  //如果singletonObjects中没有该bean\n      if (singletonObject == null) {\n    \t//回调参数传进来的ObjectFactory的getObject方法，即调用createBean方法创建bean实例\n            singletonObject = singletonFactory.getObject();\n        //置新创建单例bean标志位为true。\n           newSingleton = true;\n         if (newSingleton) {\n        //如果是新创建bean，注册新生成bean对象\n            addSingleton(beanName, singletonObject);\n         }\n      }\n      //返回获取的单例bean\n      return (singletonObject != NULL_OBJECT ? singletonObject : null);\n   }\n}\n复制代码\n```\n\n把新生成的单例bean加入到类型为MAP 的singletonObjects属性中，这也就是前面singletonObjects（）方法中获取单例bean时从此Map中获取的原因。\n\n```\nprotected void addSingleton(String beanName, Object singletonObject) {\n   synchronized (this.singletonObjects) {\n    //把新生成bean对象加入到singletonObjects属性中。\n      this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));\n\n      this.registeredSingletons.add(beanName);\n   }\n}\n复制代码\n```\n\n#### 3.6.2 Prototype\n\nPrototype是每次获取该bean时候都新建一个bean，因此逻辑比较简单，直接创建一个bean后返回。\n\n```\nelse if (mbd.isPrototype()) {\n    Object prototypeInstance = null;\n    //创建bean\n    prototypeInstance = createBean(beanName, mbd, args);\n    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n}\n复制代码\n```\n\n#### 3.6.3 request、session、global session\n\n```\nelse {\n    //获取该bean的scope   \n    String scopeName = mbd.getScope();\n    //获取相应scope\n    final Scope scope = this.scopes.get(scopeName);\n    //获取相应scope的实例化对象\n    Object scopedInstance = scope.get(beanName, new ObjectFactory<Object>() {\n             @Override\n             public Object getObject() throws BeansException {\n                   return createBean(beanName, mbd, args);\n             }\n    });\n    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n   }\n复制代码\n```\n\n从相应scope获取对象实例。\n\n```\npublic Object get(String name, ObjectFactory<?> objectFactory) {\n   RequestAttributes attributes = RequestContextHolder.currentRequestAttributes();\n   //先从指定scope中获取bean实例，如果没有则新建，如果已经有直接返回\n   Object scopedObject = attributes.getAttribute(name, getScope());\n   if (scopedObject == null) {\n      //回调函数调用createBean创建实例\n      scopedObject = objectFactory.getObject();\n      //创建实例后保存到相应scope中\n      attributes.setAttribute(name, scopedObject, getScope());\n      }\n   }\n   return scopedObject;\n}\n复制代码\n```\n\n判断scope，获取实例函数逻辑。\n\n```\npublic Object getAttribute(String name, int scope) {\n   //scope是request时\n   if (scope == SCOPE_REQUEST) {\n      //从request中获取实例\n      return this.request.getAttribute(name);\n   }\n   else {\n      PortletSession session = getSession(false);\n      if (session != null) {\n         //scope是globalSession时，从application中获取实例\n         if (scope == SCOPE_GLOBAL_SESSION) {\n            //从globalSession中获取实例\n            Object value = session.getAttribute(name, PortletSession.APPLICATION_SCOPE);\n            return value;\n         }\n         else {\n            //从session中获取实例\n            Object value = session.getAttribute(name);\n            return value;\n         }\n      }\n      return null;\n   }\n}\n复制代码\n```\n\n在相应scope中设置实例函数逻辑。\n\n```\npublic void setAttribute(String name, Object value, int scope) {\n   if (scope == SCOPE_REQUEST) {\n      this.request.setAttribute(name, value);\n   }\n   else {\n      PortletSession session = getSession(true);\n      if (scope == SCOPE_GLOBAL_SESSION) {\n         session.setAttribute(name, value, PortletSession.APPLICATION_SCOPE);\n      }\n      else {\n         session.setAttribute(name, value);\n      }\n   }\n}\n复制代码\n```\n\n以上就是Spring bean从无到有的整个逻辑。\n\n## 4\\. 小结\n\n从源码角度分析 bean的实例化流程到此基本接近尾声了。\n\n回到开头的问题，ContextLoaderListener中初始化的WebApplicationContext到底是什么呢？\n\n通过源码的分析我们知道WebApplicationContext负责了bean的创建、保存、获取。其实也就是我们平时所说的IOC容器，只不过名字表述不同而已。\n\n## 5\\. 尾声\n\n本文主要是讲解了XML配置文件中bean的解析、注册、实例化。对于其它命名空间的解析还没有讲到，后续的文章中会一一介绍。\n\n希望通过本文让大家在以后使用Spring的过程中有“一切尽在掌控之中”的感觉，而不仅仅是稀里糊涂的使用。",[[1573954063424,["GJX@GJXAIOUPC",[[-1,0," [七分熟pizza](https://juejin.im/user/5895420861ff4b006b040369)[![lv-2](https://b-gold-cdn.xitu.io/v3/static/img/lv-2.f597b88.svg)](https://juejin.im/book/5c90640c5188252d7941f5bb/section/5c9065385188252da6320022)\n\n2019年04月19日阅读 404\n\n关注"]],[0,233],[0,0]]],[1573954065275,["GJX@GJXAIOUPC",[[1,0,"-"]],[0,0],[1,1]]],[1573954065454,["GJX@GJXAIOUPC",[[1,0,"-"]],[1,1],[2,2]]],[1573954065642,["GJX@GJXAIOUPC",[[1,2,"-"]],[2,2],[3,3]]],[1573954065926,["GJX@GJXAIOUPC",[[1,5,"---\n\n\n"]],[3,3],[4,4]]],[1573954066474,["GJX@GJXAIOUPC",[[1,5,"\n"]],[4,4],[5,5]]],[1573954067632,["GJX@GJXAIOUPC",[[-1,5,"\n"]],[5,5],[4,4]]],[1573954077060,["GJX@GJXAIOUPC",[[1,4,"flag: blue"]],[4,4],[14,14]]]],null,"GJX@GJXAIOUPC"]]}