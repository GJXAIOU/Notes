{"compress":true,"commitItems":[["3d0dec5e-0a39-44eb-b3a1-179d6715e3ff",1565399119421,"# JAVA String方法中public int indexOf(int ch)问题\n\n2018年01月15日 19:37:58 [来自流星](https://me.csdn.net/qq_34579060) 阅读数 430\n\n在JAVA中返回一个字符在字符串的位置首次出现的位置时候,String 给我们提供几个有效的API。\n\n**[java]** [view plain](http://blog.csdn.net/qq_16558621/article/details/51882809# \"view plain\") [copy](http://blog.csdn.net/qq_16558621/article/details/51882809# \"copy\")\n\n1.  <span style=\"font-family:SimSun;font-size:18px;\"> int indexOf(int ch)   \n2.  //返回指定字符在此字符串中第一次出现处的索引。  \n3.  int indexOf(int ch, int fromIndex)   \n4.  //返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。  \n5.  int indexOf(String str)   \n6.  //返回指定子字符串在此字符串中第一次出现处的索引。  \n7.  int indexOf(String str, int fromIndex)   \n8.  //返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</span>  \n\n举个例子：\n\n**[java]** [view plain](http://blog.csdn.net/qq_16558621/article/details/51882809# \"view plain\") [copy](http://blog.csdn.net/qq_16558621/article/details/51882809# \"copy\")\n\n1.  <span style=\"font-family:SimSun;font-size:18px;\">class Demo1  \n2.  {  \n3.  public static void main(String[] args){  \n4.  System.out.println(\"hello world\".indexOf('l'));  \n5.  //返回值为2  \n6.  System.out.println(\"hello world\".indexOf('o',5));  \n7.  //返回值为7  \n8.  }  \n9.  }</span><span style=\"font-family:SimSun;font-size:24px;\">   </span>  \n\n我们总是很习以为常的取用这个函数，传入一个字符去寻找这个字符首次出现的位置，但是我们仔细的看下JDK的函数声明public int indexOf(int ch)，请注意这里的函数的局部参数是数据类型是int，而不是我们认为是char，在JAVA中int类型定义为4个字节，而char类型定义为2个字节，虽然我们可以将char 自动转换为int，但是JDK为什么不直接声明为public int indexOf(char ch)，这就是我们今天要讨论的问题。\n\n  首先JAVA使用的Unicode编码长度是是4个字节，也就是说一个int大小为是可以容纳一个Unicode的编码的长度的。Unicode的编码中第一字节称为组，第二字节称为面，第三字节称为行，第四字节称为点。第0组第0面里的字符可以只用2个字节表示，且涵盖了绝大部分的常用字。为了方便称呼，Unicode给它了一个名称——**基本多文种平面**（BMP  Basic Multilingual Plane）。基本多文种平面值域和上域都是0到FFFF，共计65535个码点。并且ASCII中有的字符Unicode中都有，并且对应相同的编码数字，并不是我们简单的认为Unicode编码一个char就可以存下数据。\n\n我们看下String的indexOf(int ch)的源代码:\n\n**[java]** [view plain](http://blog.csdn.net/qq_16558621/article/details/51882809# \"view plain\") [copy](http://blog.csdn.net/qq_16558621/article/details/51882809# \"copy\")\n\n1.  <span style=\"font-family:SimSun;font-size:18px;\">   public int indexOf(int ch, int fromIndex) {  \n2.  final int max = value.length;  \n3.  if (fromIndex < 0) {  \n4.  fromIndex = 0;  \n5.  } else if (fromIndex >= max) {  \n6.  // Note: fromIndex might be near -1>>>1.  \n7.  return -1;  \n8.  }  \n\n10.  if (ch < Character.MIN_SUPPLEMENTARY_CODE_POINT) {  \n11.  // handle most cases here (ch is a BMP code point or a  \n12.  // negative value (invalid code point))  \n13.  final char[] value = this.value;  \n14.  for (int i = fromIndex; i < max; i++) {  \n15.  if (value[i] == ch) {  \n16.  return i;  \n17.  }  \n18.  }  \n19.  return -1;  \n20.  } else {  \n21.  return indexOfSupplementary(ch, fromIndex);  \n22.  }  \n23.  }</span>  \n\n@param   ch character (Unicode code point)  参数ch 是一个Unicode的代码点\n\n什么是代码点？代码点 Code Point：与一个Unicode编码表中的某个字符对应的代码值。Java中用char来表示Unicode字符，由于刚开始Unicode最多使用16bit表示。因此char能够表示全部的Unicode字符。后来由于Unicode4.0规定Unicode支持的字符远远超过65536个字符。因此char现在不能表示所有的unicode字符。仅仅能表示0x000000到0x00FFFF(00 代表的就是拉丁文及其符号)之间的字符。也就是说，char不能表示增补字符。\n\nJava中用int表示所有Unicode代码点。int的21个低位（最低有效位）用于表示Unicode代码点，并且11个高位（最高有效位）必须为零。也就是说，int能表示出char不能表示的增补字符。我们还可以看到,indexOf()有一个if{}else{}语句当超过Unicode的代码补充范围时候,就会调用indexOfSupplementartary()方法。他是处理超过范围的问题的。这里其实我们就可以记住indexOf(int ch)其实是传入的Unicode的代码点，不是传入的真正的字符，而且Java中的代码点是用32为数据表示的,因次是用int而不是char",[[1565399065289,["GJX@GJXAIOU",[[-1,46,"2018年01月15日 19:37:58 [来自流星](https://me.csdn.net/qq_34579060) 阅读数 430"]],[46,114],[46,46]]],[1565399085393,["GJX@GJXAIOU",[[-1,100,"**[java]** [view plain](http://blog.csdn.net/qq_16558621/article/details/51882809# \"view plain\") [copy](http://blog.csdn.net/qq_16558621/article/details/51882809# \"copy\")"]],[100,270],[100,100]]],[1565399090458,["GJX@GJXAIOU",[[1,101,"·"],[-1,111," "],[1,112," "],[-1,155," int "],[1,160," int "],[-1,171," ch)   "],[1,178," ch)   "],[-1,207,"  "],[1,209,"  "],[-1,217," "],[1,218," "],[-1,229," ch, int "],[1,238," ch, int "],[-1,248,"   "],[1,251,"   "],[-1,291,"  "],[1,293,"  "],[-1,301," "],[1,302," "],[-1,316," "],[1,317," "],[-1,321,"   "],[1,324,"   "],[-1,355,"  "],[1,357,"  "],[-1,365," "],[1,366," "],[-1,380," "],[1,381," "],[-1,385," int "],[1,390," int "],[-1,400,"   "],[1,403,"   "],[-1,450,"  "],[1,452,"  "],[-1,471," "],[1,472," "],[-1,557," "],[1,558," "],[-1,642," "],[1,643," "],[-1,691," "],[1,692," "],[-1,697,"  "],[1,699,"  "],[-1,705,"  "],[1,707,"  "],[-1,718," "],[1,719," "],[-1,725," "],[1,726," "],[-1,730," "],[1,731," "],[-1,744," "],[1,745," "],[-1,751,"  "],[1,753,"  "],[-1,783," "],[1,784," "],[-1,805,"  "],[1,807,"  "],[-1,819,"  "],[1,821,"  "],[-1,851," "],[1,852," "],[-1,875,"  "],[1,877,"  "],[-1,889,"  "],[1,891,"  "],[-1,897,"  "],[1,899,"  "],[-1,917," "],[1,918," "],[-1,961,"   "],[1,964,"   "],[-1,971,"  "],[1,973,"  "],[-1,1206," "],[1,1207," "],[-1,1385," "],[1,1386," "],[-1,1557," "],[1,1558," "],[-1,1643," "],[1,1644," "],[-1,1728," "],[1,1729," "],[-1,1772,"   "],[1,1775,"   "],[-1,1781," int "],[1,1786," int "],[-1,1797," ch, int "],[1,1806," ch, int "],[-1,1816," {  "],[1,1820," {  "],[-1,1830," int max = "],[1,1841," int max = "],[-1,1854,"  "],[1,1856,"  "],[-1,1863," "],[1,1864," "],[-1,1874," < 0) {  "],[1,1883," < 0) {  "],[-1,1897," = 0;  "],[1,1904," = 0;  "],[-1,1910," "],[1,1911," "],[-1,1915," if "],[1,1919," if "],[-1,1929," >= "],[1,1933," >= "],[-1,1937," {  "],[1,1941," {  "],[-1,1948," "],[1,1949," "],[-1,1954," "],[1,1955," "],[-1,1964," "],[1,1965," "],[-1,1970," be "],[1,1974," be "],[-1,1978," "],[1,1979," "],[-1,1986,"  "],[1,1988,"  "],[-1,1999," -1;  "],[1,2005," -1;  "],[-1,2011,"  "],[1,2013,"  "],[-1,2022," (ch < "],[1,2029," (ch < "],[-1,2068," {  "],[1,2072," {  "],[-1,2080," "],[1,2081," "],[-1,2087," "],[1,2088," "],[-1,2092," "],[1,2093," "],[-1,2098," "],[1,2099," "],[-1,2103," (ch is a BMP "],[1,2117," (ch is a BMP "],[-1,2121," "],[1,2122," "],[-1,2127," or a  "],[1,2134," or a  "],[-1,2142," "],[1,2143," "],[-1,2151," "],[1,2152," "],[-1,2157," "],[1,2158," "],[-1,2166," "],[1,2167," "],[-1,2171," "],[1,2172," "],[-1,2179,"  "],[1,2181,"  "],[-1,2192," "],[1,2193," "],[-1,2199," "],[1,2200," "],[-1,2205," = "],[1,2208," = "],[-1,2219,"  "],[1,2221,"  "],[-1,2230," "],[1,2231," "],[-1,2235," i = "],[1,2240," i = "],[-1,2250," i < "],[1,2255," i < "],[-1,2259," "],[1,2260," "],[-1,2264," {  "],[1,2268," {  "],[-1,2276," "],[1,2277," "],[-1,2286," == ch) {  "],[1,2297," == ch) {  "],[-1,2309," i;  "],[1,2314," i;  "],[-1,2321,"  "],[1,2323,"  "],[-1,2330,"  "],[1,2332,"  "],[-1,2344," -1;  "],[1,2350," -1;  "],[-1,2357," "],[1,2358," "],[-1,2362," {  "],[1,2366," {  "],[-1,2378," "],[1,2379," "],[-1,2403," "],[1,2404," "],[-1,2415,"  "],[1,2417,"  "],[-1,2424,"  "],[1,2426,"  "],[-1,2440,"  "],[1,2442,"  "],[-1,2451," "],[1,2452," "],[-1,2487," "],[1,2488," "]],[101,101],[102,102]]],[1565399091817,["GJX@GJXAIOU",[[-1,101,"·"]],[102,102],[101,101]]],[1565399092700,["GJX@GJXAIOU",[[1,101,"```"]],[101,101],[104,104]]],[1565399092728,["GJX@GJXAIOU",[[1,104,"language\n```\n"]],[104,104],[104,112]]],[1565399094090,["GJX@GJXAIOU",[[-1,104,"language"],[1,112,"j"]],[104,112],[105,105]]],[1565399094442,["GJX@GJXAIOU",[[1,105,"ava"]],[105,105],[108,108]]],[1565399094650,["GJX@GJXAIOU",[[1,109,"\n"]],[108,108],[109,109]]],[1565399108660,["GJX@GJXAIOU",[[1,109,"<span style=\"font-family:SimSun;font-size:18px;\"> int indexOf(int ch) \n      //返回指定字符在此字符串中第一次出现处的索引。\n int indexOf(int ch, int fromIndex) \n      //返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。\n int indexOf(String str) \n      //返回指定子字符串在此字符串中第一次出现处的索引。\n int indexOf(String str, int fromIndex) \n      //返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</span>"]],[109,109],[438,438]]],[1565399113866,["GJX@GJXAIOU",[[-1,109,"<span style=\"font-family:SimSun;font-size:18px;\"> "]],[109,159],[109,109]]],[1565399115482,["GJX@GJXAIOU",[[1,109,"  "]],[109,109],[111,111]]],[1565399116954,["GJX@GJXAIOU",[[-1,110," "]],[111,111],[110,110]]],[1565399122177,["GJX@GJXAIOU",[[-1,395,"1.  <span style=\"font-family:SimSun;font-size:18px;\"> int indexOf(int ch)   \n2.  //返回指定字符在此字符串中第一次出现处的索引。  \n3.  int indexOf(int ch, int fromIndex)   \n4.  //返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。  \n5.  int indexOf(String str)   \n6.  //返回指定子字符串在此字符串中第一次出现处的索引。  \n7.  int indexOf(String str, int fromIndex)   \n8.  //返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</span>  \n\n"]],[394,746],[394,394]]],[1565399136457,["GJX@GJXAIOU",[[-1,402,"**[java]** [view plain](http://blog.csdn.net/qq_16558621/article/details/51882809# \"view plain\") [copy](http://blog.csdn.net/qq_16558621/article/details/51882809# \"copy\")\n\n1.  <span style=\"font-family:SimSun;font-size:18px;\">class Demo1  \n2.  {  \n3.  public static void main(String[] args){  \n4.  System.out.println(\"hello world\".indexOf('l'));  \n5.  //返回值为2  \n6.  System.out.println(\"hello world\".indexOf('o',5));  \n7.  //返回值为7  \n8.  }  \n9.  }</span><span style=\"font-family:SimSun;font-size:24px;\">   </span>  \n"]],[401,914],[401,401]]],[1565399137717,["GJX@GJXAIOU",[[1,401,"```"]],[401,401],[404,404]]],[1565399137743,["GJX@GJXAIOU",[[1,404,"language\n```\n"]],[404,404],[404,412]]],[1565399138578,["GJX@GJXAIOU",[[-1,404,"language"],[1,412,"j"]],[404,412],[405,405]]],[1565399139002,["GJX@GJXAIOU",[[1,405,"ava"]],[405,405],[408,408]]],[1565399139172,["GJX@GJXAIOU",[[1,409,"\n"]],[408,408],[409,409]]],[1565399145054,["GJX@GJXAIOU",[[1,409,"<span style=\"font-family:SimSun;font-size:18px;\">class Demo1\n{\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"hello world\".indexOf('l'));\n\t\t//返回值为2\n\t\tSystem.out.println(\"hello world\".indexOf('o',5));\n\t\t//返回值为7\n\t}\n}</span><span style=\"font-family:SimSun;font-size:24px;\">\t</span>"]],[409,409],[703,703]]],[1565399149812,["GJX@GJXAIOU",[[-1,409,"<span style=\"font-family:SimSun;font-size:18px;\">"]],[409,458],[409,409]]],[1565399156649,["GJX@GJXAIOU",[[-1,590,"</span><span style=\"font-family:SimSun;font-size:24px;\">\t</span>"]],[590,654],[590,590]]],[1565399159081,["GJX@GJXAIOU",[[-1,420,"\n"]],[421,421],[420,420]]],[1565399185888,["GJX@GJXAIOU",[[-1,1168,"**[java]** [view plain](http://blog.csdn.net/qq_16558621/article/details/51882809# \"view plain\") [copy](http://blog.csdn.net/qq_16558621/article/details/51882809# \"copy\")\n\n1.  <span style=\"font-family:SimSun;font-size:18px;\">   public int indexOf(int ch, int fromIndex) {  \n2.  final int max = value.length;  \n3.  if (fromIndex < 0) {  \n4.  fromIndex = 0;  \n5.  } else if (fromIndex >= max) {  \n6.  // Note: fromIndex might be near -1>>>1.  \n7.  return -1;  \n8.  }  \n\n10.  if (ch < Character.MIN_SUPPLEMENTARY_CODE_POINT) {  \n11.  // handle most cases here (ch is a BMP code point or a  \n12.  // negative value (invalid code point))  \n13.  final char[] value = this.value;  \n14.  for (int i = fromIndex; i < max; i++) {  \n15.  if (value[i] == ch) {  \n16.  return i;  \n17.  }  \n18.  }  \n19.  return -1;  \n20.  } else {  \n21.  return indexOfSupplementary(ch, fromIndex);  \n22.  }  \n23.  }</span>  \n"]],[1168,2064],[1168,1168]]],[1565399187001,["GJX@GJXAIOU",[[1,1168,"```"]],[1168,1168],[1171,1171]]],[1565399187025,["GJX@GJXAIOU",[[1,1171,"language\n```\n"]],[1171,1171],[1171,1179]]],[1565399188194,["GJX@GJXAIOU",[[-1,1171,"language"],[1,1179,"j"]],[1171,1179],[1172,1172]]],[1565399188570,["GJX@GJXAIOU",[[1,1172,"ava"]],[1172,1172],[1175,1175]]],[1565399188666,["GJX@GJXAIOU",[[1,1176,"\n"]],[1175,1175],[1176,1176]]],[1565399194309,["GJX@GJXAIOU",[[1,1176,"<span style=\"font-family:SimSun;font-size:18px;\">   public int indexOf(int ch, int fromIndex) {\n        final int max = value.length;\n        if (fromIndex < 0) {\n            fromIndex = 0;\n        } else if (fromIndex >= max) {\n            // Note: fromIndex might be near -1>>>1.\n            return -1;\n        }\n \n        if (ch < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            // handle most cases here (ch is a BMP code point or a\n            // negative value (invalid code point))\n            final char[] value = this.value;\n            for (int i = fromIndex; i < max; i++) {\n                if (value[i] == ch) {\n                    return i;\n                }\n            }\n            return -1;\n        } else {\n            return indexOfSupplementary(ch, fromIndex);\n        }\n    }</span>"]],[1176,1176],[1986,1986]]],[1565399198273,["GJX@GJXAIOU",[[-1,1176,"<span style=\"font-family:SimSun;font-size:18px;\">   "]],[1176,1228],[1176,1176]]],[1565399202354,["GJX@GJXAIOU",[[-1,1927,"</span>"]],[1927,1934],[1927,1927]]],[1565399258225,["GJX@GJXAIOU",[[1,2116,"**"],[1,2244,"**"]],[2116,2244],[2116,2248]]],[1565399284161,["GJX@GJXAIOU",[[1,2005,"**"],[1,2045,"**"]],[2005,2045],[2005,2049]]],[1565399307810,["GJX@GJXAIOU",[[1,2463,"**"],[1,2543,"**"]],[2463,2543],[2463,2547]]]],null,"GJX@GJXAIOU"],["fe41ebfd-a3dd-4d63-b7d3-0c913d8fc928",1565441046454,"# JAVA String方法中public int indexOf(int ch)问题\n\n\n\n在JAVA中返回一个字符在字符串的位置首次出现的位置时候,String 给我们提供几个有效的API。\n\n\n```java\n int indexOf(int ch) \n      //返回指定字符在此字符串中第一次出现处的索引。\n int indexOf(int ch, int fromIndex) \n      //返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。\n int indexOf(String str) \n      //返回指定子字符串在此字符串中第一次出现处的索引。\n int indexOf(String str, int fromIndex) \n      //返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</span>\n```\n\n举个例子：\n```java\nclass Demo1{\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"hello world\".indexOf('l'));\n\t\t//返回值为2\n\t\tSystem.out.println(\"hello world\".indexOf('o',5));\n\t\t//返回值为7\n\t}\n}\n```\n\n\n我们总是很习以为常的取用这个函数，传入一个字符去寻找这个字符首次出现的位置，但是我们仔细的看下JDK的函数声明public int indexOf(int ch)，请注意这里的函数的局部参数是数据类型是int，而不是我们认为是char，在JAVA中int类型定义为4个字节，而char类型定义为2个字节，虽然我们可以将char 自动转换为int，但是JDK为什么不直接声明为public int indexOf(char ch)，这就是我们今天要讨论的问题。\n\n  首先JAVA使用的Unicode编码长度是是4个字节，也就是说一个int大小为是可以容纳一个Unicode的编码的长度的。Unicode的编码中第一字节称为组，第二字节称为面，第三字节称为行，第四字节称为点。第0组第0面里的字符可以只用2个字节表示，且涵盖了绝大部分的常用字。为了方便称呼，Unicode给它了一个名称——**基本多文种平面**（BMP  Basic Multilingual Plane）。基本多文种平面值域和上域都是0到FFFF，共计65535个码点。并且ASCII中有的字符Unicode中都有，并且对应相同的编码数字，并不是我们简单的认为Unicode编码一个char就可以存下数据。\n\n我们看下String的indexOf(int ch)的源代码:\n\n```java\npublic int indexOf(int ch, int fromIndex) {\n        final int max = value.length;\n        if (fromIndex < 0) {\n            fromIndex = 0;\n        } else if (fromIndex >= max) {\n            // Note: fromIndex might be near -1>>>1.\n            return -1;\n        }\n \n        if (ch < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            // handle most cases here (ch is a BMP code point or a\n            // negative value (invalid code point))\n            final char[] value = this.value;\n            for (int i = fromIndex; i < max; i++) {\n                if (value[i] == ch) {\n                    return i;\n                }\n            }\n            return -1;\n        } else {\n            return indexOfSupplementary(ch, fromIndex);\n        }\n    }\n```\n\n@param   ch character (Unicode code point)  参数ch 是一个Unicode的代码点\n\n什么是代码点？**代码点 Code Point：与一个Unicode编码表中的某个字符对应的代码值**。Java中用char来表示Unicode字符，由于刚开始Unicode最多使用16bit表示。因此char能够表示全部的Unicode字符。**后来由于Unicode4.0规定Unicode支持的字符远远超过65536个字符。因此char现在不能表示所有的unicode字符。仅仅能表示0x000000到0x00FFFF(00 代表的就是拉丁文及其符号)之间的字符。也就是说，char不能表示增补字符**。\n\nJava中用int表示所有Unicode代码点。int的21个低位（最低有效位）用于表示Unicode代码点，并且11个高位（最高有效位）必须为零。也就是说，int能表示出char不能表示的增补字符。我们还可以看到,indexOf()有一个if{}else{}语句当超过Unicode的代码补充范围时候,就会调用indexOfSupplementartary()方法。他是处理超过范围的问题的。这里其实我们就可以记住**indexOf(int ch)其实是传入的Unicode的代码点，不是传入的真正的字符，而且Java中的代码点是用32为数据表示的,因次是用int而不是char**",[[1565441009883,["GJX@GJXAIOU",[[-1,47,"\n"]],[47,47],[46,46]]],[1565441010050,["GJX@GJXAIOU",[[-1,46,"\n"]],[46,46],[45,45]]],[1565441020779,["GJX@GJXAIOU",[[-1,380,"</span>"]],[380,387],[380,380]]],[1565441137772,["GJX@GJXAIOU",[[-1,135,"//返回指定字符在此字符串中第一次出现处的索引。"]],[135,159],[135,135]]],[1565441139459,["GJX@GJXAIOU",[[1,107,"\n"]],[106,106],[107,107]]],[1565441139981,["GJX@GJXAIOU",[[1,107,"//返回指定字符在此字符串中第一次出现处的索引。"]],[107,107],[131,131]]],[1565441143035,["GJX@GJXAIOU",[[-1,204,"//返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。"]],[204,239],[204,204]]],[1565441145571,["GJX@GJXAIOU",[[1,155,"//返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。"]],[155,155],[190,190]]],[1565441148277,["GJX@GJXAIOU",[[-1,154," "]],[155,155],[154,154]]],[1565441155163,["GJX@GJXAIOU",[[1,154,"\n"]],[154,154],[155,155]]],[1565441160003,["GJX@GJXAIOU",[[-1,272,"//返回指定子字符串在此字符串中第一次出现处的索引"]],[272,297],[272,272]]],[1565441163451,["GJX@GJXAIOU",[[1,234,"//返回指定子字符串在此字符串中第一次出现处的索引"]],[234,234],[259,259]]],[1565441165131,["GJX@GJXAIOU",[[1,234,"\n "]],[234,234],[236,236]]],[1565441168628,["GJX@GJXAIOU",[[1,261,"."]],[261,261],[262,262]]],[1565441169874,["GJX@GJXAIOU",[[-1,261,"."]],[262,262],[261,261]]],[1565441170499,["GJX@GJXAIOU",[[1,261,"。"]],[261,261],[262,262]]],[1565441173316,["GJX@GJXAIOU",[[-1,298,"  。"]],[298,301],[298,298]]],[1565441178453,["GJX@GJXAIOU",[[-1,346,"//返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。"]],[346,381],[346,346]]],[1565441182172,["GJX@GJXAIOU",[[1,295,"//返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。"]],[295,295],[330,330]]],[1565441183750,["GJX@GJXAIOU",[[1,295,"\n "]],[295,295],[297,297]]]],null,"GJX@GJXAIOU"]]}