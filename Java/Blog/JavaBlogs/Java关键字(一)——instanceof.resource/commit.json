{"compress":true,"commitItems":[["fe872f7d-ef3d-453f-b943-58124ed28565",1568729673579,"**目录**\n\n*   [1、obj 必须为引用类型，不能是基本类型](https://www.cnblogs.com/ysocean/p/8486500.html#_label0)\n*   [2、obj 为 null](https://www.cnblogs.com/ysocean/p/8486500.html#_label1)\n*   [3、obj 为 class 类的实例对象](https://www.cnblogs.com/ysocean/p/8486500.html#_label2)\n*   [4、obj 为 class 接口的实现类](https://www.cnblogs.com/ysocean/p/8486500.html#_label3)\n*   [5、obj 为 class 类的直接或间接子类](https://www.cnblogs.com/ysocean/p/8486500.html#_label4)\n*   [6、问题](https://www.cnblogs.com/ysocean/p/8486500.html#_label5)\n*   [7、深究原理](https://www.cnblogs.com/ysocean/p/8486500.html#_label6)\n*   [8、instanceof 的实现策略](https://www.cnblogs.com/ysocean/p/8486500.html#_label7)\n\n* * *\n\n　　instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：\n\n| \n\n1\n\n | \n\n`boolean` `result = obj ``instanceof` `Class`\n\n |\n\n　　其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。\n\n　　注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。\n\n[回到顶部](https://www.cnblogs.com/ysocean/p/8486500.html#_labelTop)\n\n### 1、obj 必须为引用类型，不能是基本类型\n\n| \n\n1\n\n2\n\n3\n\n | \n\n`int` `i = ``0``;`\n\n`System.out.println(i ``instanceof` `Integer);``//编译不通过`\n\n`System.out.println(i ``instanceof` `Object);``//编译不通过`\n\n |\n\n　　instanceof 运算符只能用作对象的判断。\n\n[回到顶部](https://www.cnblogs.com/ysocean/p/8486500.html#_labelTop)\n\n### 2、obj 为 null\n\n| \n\n1\n\n | \n\n`System.out.println(``null` `instanceof` `Object);``//false`\n\n |\n\n　　关于 null 类型的描述在官方文档：[https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1](https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1) 有一些介绍。一般我们知道Java分为两种数据类型，一种是基本数据类型，有八个分别是 byte  short  int  long  float  double  char boolean,一种是引用类型，包括类，接口，数组等等。而Java中还有一种特殊的 null 类型，该类型没有名字，所以不可能声明为 null 类型的变量或者转换为 null 类型，null 引用是 null 类型表达式唯一可能的值，null 引用也可以转换为任意引用类型。我们不需要对 null 类型有多深刻的了解，我们只需要知道 null 是可以成为任意引用类型的**特殊符号**。\n\n　　在 [JavaSE规范](https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.20.2) 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回 false。\n\n[回到顶部](https://www.cnblogs.com/ysocean/p/8486500.html#_labelTop)\n\n### 3、obj 为 class 类的实例对象\n\n| \n\n1\n\n2\n\n | \n\n`Integer integer = ``new` `Integer(``1``);`\n\n`System.out.println(integer ``instanceof`  `Integer);``//true`\n\n |\n\n　　这没什么好说的，最普遍的一种用法。\n\n[回到顶部](https://www.cnblogs.com/ysocean/p/8486500.html#_labelTop)\n\n### 4、obj 为 class 接口的实现类\n\n　　了解Java 集合的，我们知道集合中有个上层接口 List，其有个典型实现类 ArrayList\n\n| \n\n1\n\n2\n\n | \n\n`public` `class` `ArrayList<E> ``extends` `AbstractList<E>`\n\n`implements` `List<E>, RandomAccess, Cloneable, java.io.Serializable`\n\n |\n\n　　所以我们可以用 instanceof 运算符判断 某个对象是否是 List 接口的实现类，如果是返回 true，否则返回 false\n\n| \n\n1\n\n2\n\n | \n\n`ArrayList arrayList = ``new` `ArrayList();`\n\n`System.out.println(arrayList ``instanceof` `List);``//true`\n\n |\n\n　　或者反过来也是返回 true\n\n| \n\n1\n\n2\n\n | \n\n`List list = ``new` `ArrayList();`\n\n`System.out.println(list ``instanceof` `ArrayList);``//true`\n\n |\n\n[回到顶部](https://www.cnblogs.com/ysocean/p/8486500.html#_labelTop)\n\n### 5、obj 为 class 类的直接或间接子类\n\n　　我们新建一个父类 Person.class，然后在创建它的一个子类 Man.class\n\n| \n\n1\n\n2\n\n3\n\n | \n\n`public` `class` `Person {`\n\n`}`\n\n |\n\n　　Man.class\n\n| \n\n1\n\n2\n\n3\n\n | \n\n`public` `class` `Man ``extends` `Person{`\n\n`}`\n\n |\n\n　　测试：\n\n| \n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n | \n\n`Person p1 = ``new` `Person();`\n\n`Person p2 = ``new` `Man();`\n\n`Man m1 = ``new` `Man();`\n\n`System.out.println(p1 ``instanceof` `Man);``//false`\n\n`System.out.println(p2 ``instanceof` `Man);``//true`\n\n`System.out.println(m1 ``instanceof` `Man);``//true`\n\n |\n\n　　注意第一种情况， p1 instanceof Man ，Man 是 Person 的子类，Person 不是 Man 的子类，所以返回结果为 false。\n\n[回到顶部](https://www.cnblogs.com/ysocean/p/8486500.html#_labelTop)\n\n### 6、问题\n\n　　前面我们说过**编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。**\n\n看如下几个例子：\n\n| \n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n | \n\n`Person p1 = ``new` `Person();`\n\n`System.out.println(p1 ``instanceof` `String);``//编译报错`\n\n`System.out.println(p1 ``instanceof` `List);``//false`\n\n`System.out.println(p1 ``instanceof` `List<?>);``//false`\n\n`System.out.println(p1 ``instanceof` `List<Person>);``//编译报错`\n\n |\n\n　　按照我们上面的说法，这里就存在问题了，Person 的对象 p1 很明显不能转换为 String 对象，那么自然 Person 的对象 p1 instanceof String 不能通过编译，但为什么 p1 instanceof List 却能通过编译呢？而 instanceof List<Person> 又不能通过编译了？\n\n[回到顶部](https://www.cnblogs.com/ysocean/p/8486500.html#_labelTop)\n\n### 7、深究原理\n\n　　我们可以看Java语言规范Java SE 8 版：[https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.20.2](https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.20.2)\n\n![](https://images2018.cnblogs.com/blog/1120165/201803/1120165-20180302000448613-26394231.png)\n\n 　　如果用伪代码描述：\n\n| \n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n | \n\n`boolean` `result;`\n\n`if` `(obj == ``null``) {`\n\n`result = ``false``;`\n\n`} ``else` `{`\n\n`try` `{`\n\n`T temp = (T) obj; ``// checkcast`\n\n`result = ``true``;`\n\n`} ``catch` `(ClassCastException e) {`\n\n`result = ``false``;`\n\n`}`\n\n`}`\n\n |\n\n　　也就是说有表达式 obj instanceof T，instanceof 运算符的 obj 操作数的类型必须是引用类型或空类型; 否则，会发生编译时错误。 \n\n　　如果 obj 强制转换为 T 时发生编译错误，则关系表达式的 instanceof 同样会产生编译时错误。 在这种情况下，表达式实例的结果永远为false。\n\n　　在运行时，如果 T 的值不为null，并且 obj 可以转换为 T 而不引发ClassCastException，则instanceof运算符的结果为true。 否则结果是错误的\n\n　　简单来说就是：**如果 obj 不为 null 并且 (T) obj 不抛 ClassCastException 异常则该表达式值为 true ，否则值为 false 。**\n\n所以对于上面提出的问题就很好理解了，为什么 p1 instanceof String 编译报错，因为(String)p1 是不能通过编译的，而 (List)p1 可以通过编译。\n\n[回到顶部](https://www.cnblogs.com/ysocean/p/8486500.html#_labelTop)\n\n### 8、instanceof 的实现策略\n\n　　JavaSE 8 instanceof 的实现算法：[https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.instanceof](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.instanceof)\n\n　　![](https://images2018.cnblogs.com/blog/1120165/201803/1120165-20180302002919162-2045599504.png)\n\n　　1、obj如果为null，则返回false；否则设S为obj的类型对象，剩下的问题就是检查S是否为T的子类型；\n\n　　2、如果S == T，则返回true；\n\n　　3、接下来分为3种情况，之所以要分情况是因为instanceof要做的是“子类型检查”，而Java语言的类型系统里数组类型、接口类型与普通类类型三者的子类型规定都不一样，必须分开来讨论。\n\n　　①、S是数组类型：如果 T 是一个类类型，那么T必须是Object；如果 T 是接口类型，那么 T 必须是由数组实现的接口之一；\n\n　　②、接口类型：对接口类型的 instanceof 就直接遍历S里记录的它所实现的接口，看有没有跟T一致的；\n\n　　③、类类型：对类类型的 instanceof 则是遍历S的super链（继承链）一直到Object，看有没有跟T一致的。遍历类的super链意味着这个算法的性能会受类的继承深度的影响。\n\n参考链接：https://www.zhihu.com/question/21574535",[[1568729664315,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1568729665358,["GJX@GJXAIOU",[[1,0,"# [Java关键字(一)——instanceof](https://www.cnblogs.com/ysocean/p/8486500.html)"]],[0,0],[74,74]]],[1568729669068,["GJX@GJXAIOU",[[-1,27,"https://www.cnblogs.com/ysocean/p/8486500.html"]],[27,73],[27,27]]],[1568729671375,["GJX@GJXAIOU",[[1,29,"\n"]],[28,28],[29,29]]],[1568729671638,["GJX@GJXAIOU",[[1,30,"\n"]],[29,29],[30,30]]],[1568729683152,["GJX@GJXAIOU",[[1,30,"[原文链接](https://www.cnblogs.com/ysocean/p/8486500.html)"]],[30,30],[84,84]]],[1568729686373,["GJX@GJXAIOU",[[-1,25,"]()"]],[25,28],[25,25]]],[1568729687606,["GJX@GJXAIOU",[[-1,2,"["]],[3,3],[2,2]]],[1568729689301,["GJX@GJXAIOU",[[-1,80,"\n"]],[81,81],[80,80]]],[1568729690639,["GJX@GJXAIOU",[[1,80,"\n"]],[80,80],[81,81]]],[1568729691140,["GJX@GJXAIOU",[[1,81,"\n"]],[81,81],[82,82]]],[1568729695563,["GJX@GJXAIOU",[[-1,82,"**目录**\n\n*   [1、obj 必须为引用类型，不能是基本类型](https://www.cnblogs.com/ysocean/p/8486500.html#_label0)\n*   [2、obj 为 null](https://www.cnblogs.com/ysocean/p/8486500.html#_label1)\n*   [3、obj 为 class 类的实例对象](https://www.cnblogs.com/ysocean/p/8486500.html#_label2)\n*   [4、obj 为 class 接口的实现类](https://www.cnblogs.com/ysocean/p/8486500.html#_label3)\n*   [5、obj 为 class 类的直接或间接子类](https://www.cnblogs.com/ysocean/p/8486500.html#_label4)\n*   [6、问题](https://www.cnblogs.com/ysocean/p/8486500.html#_label5)\n*   [7、深究原理](https://www.cnblogs.com/ysocean/p/8486500.html#_label6)\n*   [8、instanceof 的实现策略](https://www.cnblogs.com/ysocean/p/8486500.html#_label7)\n\n* * *"]],[82,724],[82,82]]],[1568729697972,["GJX@GJXAIOU",[[-1,140,"| \n\n1\n\n | "]],[140,150],[140,140]]]],null,"GJX@GJXAIOU"]]}