# Java并发编程 - 有状态 & 无状态的对象区别

### **一、基本概念**

1、有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非[线程安全](https://so.csdn.net/so/search?q=线程安全&spm=1001.2101.3001.7020)的。在不同方法调用间不保留任何状态。

2、无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象.不能保存数据，是不变类，是线程安全的。

### 二、看代码加深印象

```java
/** 
 * 有状态bean,有state,user等属性，并且user有存偖功能，是可变的。 
 *  简单来说, 普通的java类, 带有属性, 并且属性是可以被修改的, 那么这个类的实例就是有状态对象. 也就是如果你拿到的这个实例, 可能就被别人修改过, 那么你当前的操作就会受到别人之前操作的影响.
 * @author Peter Wei 
 *  
 */ 
public class StatefulBean {  
   
    public int state;  
    // 由于多线程环境下，user是引用对象，是非线程安全的  
    public User user;  
   
    public int getState() {  
        return state;  
    }  
   
    public void setState(int state) {  
        this.state = state;  
    }  
   
    public User getUser() {  
        return user;  
    }  
   
    public void setUser(User user) {  
        this.user = user;  
    }  
}  
   
/** 
 * 无状态bean,不能存偖数据。因为没有任何属性，所以是不可变的。只有一系统的方法操作。 
 *  
 * @author Peter Wei 
 *  
 */ 
public class StatelessBeanService {  
   
    // 虽然有billDao属性，但billDao是没有状态信息的，是Stateless Bean.  
    BillDao billDao;  
   
    public BillDao getBillDao() {  
        return billDao;  
    }  
   
    public void setBillDao(BillDao billDao) {  
        this.billDao = billDao;  
    }  
   
    public List<User> findUser(String Id) {  
         return null;  
    }  
}
```

### 三、Spring中的有状态(Stateful)和无状态(Stateless)

1、通过上面的分析，相信大家已经对有状态和无状态有了一定的理解。无状态的 Bean适合用不变模式，技术就是单例模式，这样可以共享实例，提高性能。有状态的Bean，多线程环境下不安全，那么适合用 Prototype 原型模式。Prototype: 每次对 bean 的请求都会创建一个新的 bean 实例。

2、默认情况下，从 Spring bean 工厂所取得的实例为 singleton（scope 属性为singleton）,容器只存在一个共享的bean实例。

3、理解了两者的关系，那么scope选择的原则就很容易了：有状态的bean都使用prototype作用域，而对无状态的bean则应该使用singleton作用域。

4、如 Service 层、Dao 层用默认 singleton 就行，虽然 Service 类也有 dao 这样的属性，但 dao 这些类都是没有状态信息的，也就是相当于不变(immutable)类，所以不影响。Struts2 中的 Action 因为会有 User、BizEntity 这样的实例对象，是有状态信息的，在多线程环境下是不安全的，所以Struts2 默认的实现是 Prototype 模式。在 Spring 中，Struts2 的 Action中，scope 要配成 prototype 作用域。  



### 四、Servlet是单例模式

1、Servlet体系结构是建立在Java多线程机制之上的，它的生命周期是由Web 容器负责的。一个Servlet类在Application中只有一个实例存在，也就是有多个线程在使用这个实例。这是单例模式的应用。无状态的单例是线程安全的，但我们如果在Servlet里用了实例变量，那么就变成有状态了，是非线程安全的。如下面的用法就是不安全的,因为user,out都是有状态信息的。

```
/** 
 * 非线程安全的Servlet。 
 * @author Peter Wei 
 * 
 */  
public class UnSafeServlet HttpServlet{  
      
    User user;  
    PrintWriter out;  
      
    public void doGet (HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException{  
        //do something...  
    }  
}  
```

Out、Request、Response、Session、Config、Page、PageContext 是线程安全的，Application 在整个系统内被使用,所以不是线程安全的。

 

###  五、SpringMvc默认是单例默认，Struts2默认的实现是Prototype模式。



# 架构设计之“无状态”和“有状态”浅析

> 原文：：https://juejin.cn/post/6995012622386987038

「数据一致性」和「高可用」其实本质是一个通过提升复杂度让整体更完善的方式。本文主要讲一些让系统更简单，更容易维护的东西——「易伸缩」，首当其冲的主题就是「stateless」，也叫「无状态」。

## 一、服务的有状态和无状态

### （一）无状态服务

客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份。服务端不保存任何客户端请求者信息。

无状态的好处

- 客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务
- 服务端的集群和状态对客户端透明 = 服务端可以任意的迁移和伸缩 = 减小服务端存储压力

### （二）有状态服务

有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如 tomcat 中的 session。

**例如** 登录：用户登录后，我们把登录者的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session。然后下次请求，用户携带 cookie 值来，我们就能识别到对应 session，从而找到用户的信息。

有状态的缺点

- 服务端保存大量数据，增加服务端压力
- 服务端保存用户状态，无法进行水平扩展
- 客户端请求依赖服务端，多次请求必须访问同一台服务器

状态化的判断是指两个来自相同发起者的请求在服务器端是否具备上下文关系。

- 如果是状态化请求，那么服务器端一般都要保存请求的相关信息，每个请求可以默认地使用以前的请求信息。
- 而无状态的请求，服务器端的处理信息必须全部来自于请求所携带的信息以及可以被所有请求所使用的公共信息。

**有状态和去状态对比**

无状态的服务器程序，最著名的就是WEB服务器。

状态化的服务器有更广阔的应用范围，比如MSN、网络游戏等服务器。他在服务端维护每个连接的状态信息，服务端在接收到每个连接的发送的请求时，可以从本地存储的信息来重现上下文关系。

纯函数式编程，就是无状态的。有状态，也叫有副作用。

无状态的服务易伸缩： 很容易的通过给后端添加服务器和前端的负载均衡实现横向的扩展。当系统中存在着大量「有状态」的业务处理过程时，伸缩扩展就会变得复杂起来。

## 2. 对象的有状态和无状态

### 2.1 什么是有状态和无状态

- **有状态** 就是有数据存储功能。**有状态对象(Stateful Bean)**，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。
- **无状态** 就是一次操作，不能保存数据。**无状态对象(Stateless Bean)**，就是没有实例变量的对象.不能保存数据，是不变类，是线程安全的。

通过代码加深理解

### 2.2 有状态对象(Stateful Bean)

```less
/**
 * @desc: 有状态bean,有state,user等属性，并且user有存偖功能，是可变的。
 * @link:
 */
@Getter
@Setter
public class StatefulBean {
    public int state;
    // 由于多线程环境下，user是引用对象，是非线程安全的
    public TestParam param;
}
```

### 2.3 无状态对象(Stateless Bean)

```typescript
/**
 * @desc: 无状态bean,不能存偖数据。因为没有任何属性，所以是不可变的。只有一系统的方法操作
 * @link:
 */
public class StatelessBeanService {

    // 虽然有 orderService 属性，但borderService 是没有状态信息的，是Stateless Bean.
    OrderService orderService;

    public List<TestParam> findUser(String Id) {
        return null;
    }
}
复制代码
```

## 3. Spring 中有状态和无状态

通过上面的分析，相信大家已经对有状态和无状态有了一定的理解。

- **无状态的Bean** 适合用不变模式，技术就是单例模式，这样可以共享实例，提高性能。
- **有状态的Bean** 多线程环境下不安全，那么适合用Prototype原型模式。Prototype: 每次对bean的请求都会创建一个新的bean实例。

默认情况下，从Spring bean工厂所取得的实例为singleton（scope属性为singleton）,容器只存在一个共享的bean实例。

理解了两者的关系，那么scope选择的原则就很容易了：有状态的bean都使用prototype作用域，而对无状态的bean则应该使用singleton作用域。

如Service层、Dao层用默认singleton就行，虽然Service类也有dao这样的属性，但dao这些类都是没有状态信息的，也就是相当于不变(immutable)类，所以不影响。

Struts2 中的Action因为会有User、BizEntity这样的实例对象，是有状态信息的，在多线程环境下是不安全的，所以Struts2默认的实现是Prototype模式。在Spring中，Struts2的Action中，scope要配成prototype作用域。

## 4. 有状态协议和无状态协议

无状态协议：在下一次链接不记住这一次链接的信息。

- HTTP,UDP都是无状态协议
- TCP,FTP是有状态协议

### 4.1 Http 无状态

标准的http协议是无状态的，无连接的

1. 标准的http协议指的是不包括cookies, session，application的http协议，他们都不属于标准协议，虽然各种网络应用提供商，实现语言、web容器等，都默认支持它
2. 无连接指的是什么
    - 每一个访问都是无连接，服务器挨个处理访问队列里的访问，处理完一个就关闭连接，这事儿就完了，然后处理下一个新的
    - 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接

对于【无状态】，我看到很多隔着一层磨砂玻璃一样的模糊说法（官方或者教程里的说法）

1. 协议对于事务处理没有记忆能力【事物处理】【记忆能力】
2. 对同一个url请求没有上下文关系【上下文关系】
3. 每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况【无直接联系】【受直接影响】
4. 服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器【状态】



# [http协议无状态中的 "状态" 到底指的是什么？！](https://www.cnblogs.com/bellkosmos/p/5237146.html)

**引子：**

最近在好好了解http，发现对介绍http的第一句话【http协议是无状态的，无连接的】就无法理解了：无状态的【状态】到底指的是什么？！

找了很多资料不仅没有发现有一针见血正面回答这个问题的，而且有些解释还充斥了各种错误，看着看着就觉得心里憋着一股浊气吐不出来

于是在看了很多资料之后，我一口吐出浊气，大声正面提出这个问题：http协议无状态中的【状态】到底指的是什么？！

然后开始不断探索解决这个问题。。。

最终很高兴的是我找到了让人满意的答案，先卖个关子，各位如果着急可以直接拉到最下查看

 

**正文：http协议无状态中的【状态】到底指的是什么？！**

 

先来看这句话的另外两个概念：（标准的http协议是无状态的，无连接的）

1. 标准的http协议指的是不包括cookies, session，application的http协议，他们都不属于标准协议，虽然各种网络应用提供商，实现语言、web容器等，都默认支持它
2. 无连接指的是什么
    1. 每一个访问都是无连接，服务器挨个处理访问队列里的访问，处理完一个就关闭连接，这事儿就完了，然后处理下一个新的
    2. 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接

 

对于【无状态】，我看到很多隔着一层磨砂玻璃一样的模糊说法（官方或者教程里的说法），看着非常难受（但其实算是对的）（后来我发现我为什么觉得它看着难受了，因为他们引入了很多新的，而且明显是一个可能用在很多地方的广义名词，这些词最大的作用就是，混淆概念，下面我标注了）

1. 协议对于事务处理没有记忆能力【事物处理】【记忆能力】
2. 对同一个url请求没有上下文关系【上下文关系】
3. 每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况【无直接联系】【受直接影响】
4. 服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器【状态】

 

我必须得到确切而具体的解释！

 

这几点给了我下一步思考的方向：

1. 【服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器 】这里的客户端的状态是不是确切地指服务器没有保存客户的信息呢？但显然不是啊
2. 【HTTP无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品】我对此质疑为什么无状态就不能实现购物车呢？服务器就不能存储东西了么？
3. 【 每次的请求都是独立的，<它的执行情况和结果>与<前面的请求>和<之后的请求>是无直接关系的】我觉得这个说法比较靠谱，但是所谓的不同请求间的没有关系，是指的请求内容没有关系，还是只是指请求本身没有关系？
    1. 请求内容没有关系只可能是服务器上不存有用户数据才可能啊，但是显然是存有的啊
    2. 请求本身没有关系，这又有什么意义呢，每一次的请求有什么价值？

 

根据这个方向我做了一个模拟访问实验：假如没有cookie没有session，只有http的时候，那当一个注册用户访问这个购物网站的时候，会发生这些事情：

1. 前提情况：
    1. 服务器肯定为每个注册用户建立了数据表，记录用户的数据
    2. http是无连接的
2. 第一步需要登录
    1. 用户通过http把用户的用户名和密码发送给服务器，服务器把他们跟自己存有的用户资料对比，如果一致，则返回信息登录成功
3. 然后用户点击某一商品页
    1. 这个动作相当于输入一个商品页的网址
    2. 假如商品页比较机密不对外公开，需要是用户才能访问
    3. 而虽然http能传送用户名和密码，而且刚才也输入了，还验证成功了，但是因为服务器既不会记得你登录的状态，你的客户端也不会存储你刚才输入的用户名和密码
    4. 所以因为这一次访问因为无法确定你的身份，只能访问失败
        1. 这时候如果要解决这个问题，而且没有cookie没有session，那就只能你在访问网址的同时继续带上你的用户名和密码（继续输入咯）其实就像我现在的APP一样
4. 假设上一步的问题解决了，就是每次访问的时候都会手动输入用户名和密码，然后现在的情况是：你已经选了几件商品在你的购物车中，你想再添加一件商品，于是你点击某个商品旁边的加号
    1. 这个动作也相当于输入一个网址，网址的内容是发送一个请求，往你的购物车中加入这个商品
    2. 系统首先用你传来的用户名和密码验证你的身份，然后访问你的数据库，在其中的购物车属性下加一条数据，就是这个商品的数据
    3. 操作结束后，返回操作成功，并结束访问
5. OK，实验结束，看似没有cookie没有session也能凑合解决问题，其实两个操作都有很大的问题
    1. 你每访问一次需要权限的内容都需要在客户端输入用户名和密码，这一项的繁琐就不必赘述了
    2. 你的每一次操作都要与系统底层的数据库进行交互
        1. 多次少量的访问存在非常大的性能浪费。非常容易就能想到肯定是一次大量的操作更加有效率，于是就想到了缓存区
    3. 你的非重要琐碎数据也被写进数据库中，跟你的主要数据放在一起
        1. 一次次添加和删除购物车其实只是跟你这次浏览，或者叫这次会话有关，是临时的数据，跟用户的主要信息无关，它们没什么价值，纯粹的冗余数据（不排除现在有的公司觉得这种数据也有非常大的价值可以让它们巧妙的利用），用什么存放这些临时的数据，我们也很容易想到缓存区

 

经过这个模拟访问实验，结合前面的思考方向，我们知道了三点：

1. 服务器上肯定存有用户的数据，你提交的增删改查它也能够处理，所以这句话中【服务器中没有保存客户端的状态】的状态并不是指用户的数据，我们的猜测不对
2. 我们的质疑对了，无状态能实现购物车，可以通过服务器上存有的用户数据来实现
3. 但是，使用上面这种方式实现购物车，存在三个比较大的问题。由此，我们不禁会想，这三个问题的解决是不是跟我们不确切了解的【状态】一词有关？于是，接下来我们来通过解决这三个问题来把【状态】的意义探寻下去

 

由上所述，我们可以在http的基础上增加一些机制来解决上面出现的三个问题

1. 在用户端增加一个记录本是非常有必要的，正好官方加入的cookie机制跟这个一样，它的用处也确实是上面讨论的那样，一般就是用来标识访问者的身份
2. 在服务器增加一个缓存区能同时解决后两个问题
    1. 有了这个缓存区作为一个数据缓冲，就不用一次次地访问数据库，浪费大量计算机资源，而是在最后统一归入数据库
    2. 有了这个缓存区，你就不用把临时的数据放到数据库中了，只需要在你们交流告一段落之后，再把数据整理，把有用的数据归入数据库
3. 这里就自然引申出了一个重要的概念：会话，它作为一个缓冲存储区被从数据库中分离出来，理由并不生硬，它有其独特的重要且不可替代的作用。这个东西恰好跟官方加入的session机制一样
    1. 另外说一个非常具有迷惑性的容易让人对session的主要作用产生偏离的理解：认为session存在的价值就是给访问者分配一个sessionID代替用户名和密码，
    2. 为什么非常具有迷惑性，因为session确实做了这件事，而且也起到了很大的作用，所以它是对的，但是只对一半，而且没有涉及问题的本质，这种情况是最危险的（看似很有说服力，把你说服了，所以你很难有动力继续找下去，但是真实情况跟它有偏差，但是偏差不大，所以又很难把你说服回来，只有隐隐的不对劲，这个时候你离真实最近，也离真实最远）
    3. 那就顺便说说它为什么是对的，也就是用session做的另一件有用的事：
        1. 给每个session一个ID，一方面用来方便自己查询，另一方面把这个ID给用户，用户下一次访问的时候就可以不用用户名和密码，而是直接使用这个ID来表明自己的身份
        2. 首先，这个ID安全吗？这个ID比直接传用户名和密码安全吗？
            1. 你很容易会想到，本来用户名和密码的组合还特地设置地比较复杂，你这换一组数字就代替了，是不是太不安全了？
            2. 我们知道http协议本身是完全不加密的，如果使用用户名和密码，第一次访问是放在http头中，后边自动保存了密码就会放在cookie中，这些都完全没有加密，它的安全性基本为0，就是裸奔了，只要被窃取，那就丢失了
            3. 所以，就这个意义来讲，sessionID的安全性跟使用用户名和密码没什么区别
            4. 但是其实，虽然http本身不能加密，但是有些软件什么的，能在应用层面手动给你加密，比如QQ就会使用户名密码加临时验证码联合哈希，sessionID加一个时间戳简单加密也是非常常用的方法
            5. 而且因为sessionID本身有有效期，即使丢了，也可能很快失效，造成的损失可能没那么大，而用户名跟密码丢了，那就大了
            6. 所以总结就是：
                1. 不严格加密的sessionID和用户名和密码一样，都不太安全
                2. 但是相比较来说，sessionID要安全一些
                3. 而使用https是完全安全的
        3. 然后，使用sessionID有哪些好处
            1. 方便直接根据ID查询用户对应的session
            2. 加密的时候计算量小
            3. 安全性不会降低，甚至还更高一些

 

OK，通过独立地解决纯http机制会产生的问题，我们探讨了cookie和session机制的本质。而且想到：【使用http协议，服务器中不会保存客户端的状态】所产生的问题通过增加cookie和session机制解决了，是不是就意味着这个【状态】跟cookie和session的关系非常紧密？所以这个无状态指的是【没有对 本次会话 设置一个缓存区，记录这次会话的状态，缓存区包括服务器端和用户端】但好像还是没有点破关键（主要是觉得跟前面那些官方对状态的说法不太吻合，甚至没有对应关系）

 

忽然我想到一个问题：一个有状态的http是什么样的？

1. 很难直接想象有状态的http是什么样，因为http这种机制是天然无状态的

2. 那就类比一下吧，另一个天然有状态的机制叫TCP

    1. 如果有状态的意思是它的每次请求是有联系的，那么有状态的TCP的样子是：假如一份数据分了三份TCP包发送，那这个包上面会标明这是第几个包，会标明这个包跟那几个包是有联系的，有什么联系

3. 但好像这个有状态的TCP跟我们想要的有状态的HTTP没有关系，因为即使每次http请求之间互相有联系，它也不能解决上面提到的http无状态的问题

4. 诶，等等，好像能类比：

    1. 假如每个http连接都有一个签名，于是第一次登陆成功之后，服务器就知道了这个签名是允许登陆的，于是之后所有同样签名的http连接都能登陆，这里利用了同一个用户发出的http连接之间的同主人关系，这里解决了一个保持登录状态的问题

    2. 同样，来尝试利用这个【每次http请求之间互相有联系】来解决上面碰到的那个问题【每一次操作都要与系统底层的数据库进行交互】，但想了半天确实无法进行下去

    3. 不过我灵机一动，从另一个角度来想，好像解决了这个问题：

        1. 只有【每次http请求之间互相有联系】这个条件，无法解决【每一次操作都要与系统底层的数据库进行交互】

        2. 因为很明显，要解决【每一次操作都要与系统底层的数据库进行交互】就必须在服务器端开辟一块缓存区

        3. 不过如果你思考一下如何实现【每次http请求之间互相有联系】，你就会发现，它也需要在服务器端开辟一块缓存区

        4. 所以【在服务器端开辟一块缓存区】才是真正的条件，也就是说，它确实等价于【有状态】

        5. 而且我也找到了这个【在服务器端开辟一块缓存区】的条件跟前面那些官方对状态的说法对应的点，那就是：

            1. 通过在服务器端开辟一块缓存区，存储、记忆、共享一些临时数据，你就可以：
                1. 协议对于事务处理有记忆能力【事物处理】【记忆能力】
                2. 对同一个url请求有上下文关系【上下文关系】
                3. 每次的请求都是不独立的，它的执行情况和结果与前面的请求和之后的请求是直接关系的【不独立】【直接关系】
                4. 服务器中保存客户端的状态【状态】

        6. 所以，这个状态，加上前面说的客户端也有cookie，就是指，

            客户端和服务器在临时会话中产生的数据

            ！而前面也说道了，使用缓存区保存临时会话中的数据是多么重要

            1. 所以状态不仅包括不同URL访问之间的关系，还有对其他URL访问的数据记录，还有一些其他的东西，所以更确切地说，状态应该是【实现了这些东西所凭借的后面的缓存空间】中的客户的临时数据
            2. cookie和session应该是完全实现了有状态这个功能

 

**一种常见的对状态的误解：**

1. 有人在解释HTTP的无状态时，把它跟有连接对立，说是两种方式，也就是如果想不无状态，就必须有连接，但其实不然
2. 有连接和无连接以及之后的Keep-Alive都是指TCP连接
3. 有状态和无状态可以指TCP也可以指HTTP
4. TCP一直有状态，HTTP一直无状态，但是应用为了有状态，就给HTTP加了cookie和session机制，让使用http的应用也能有状态，但http还是无状态
5. 开始TCP是有连接，后来TCP无连接，再后来也就是现在TCP是Keep-Alive，有点像有连接