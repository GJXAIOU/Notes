{"compress":true,"commitItems":[["d082524e-c513-42f6-8188-937147435f03",1563930044813,"",[[1563930001479,["GJX@GJXAIOU",[[1,0,"# Day25多线程与多进程\n\n\n\n"]],[0,0],[17,17]]],[1563930014393,["GJX@GJXAIOU",[[1,2,"Java"]],[2,2],[6,6]]],[1563930389884,["GJX@GJXAIOU",[[1,20,"代码示例："]],[20,20],[25,25]]],[1563930390151,["GJX@GJXAIOU",[[1,27,"\n"]],[25,25],[26,26]]],[1563930392257,["GJX@GJXAIOU",[[1,26,"```"]],[26,26],[29,29]]],[1563930392279,["GJX@GJXAIOU",[[1,29,"language\n```\n"]],[29,29],[29,37]]],[1563930393290,["GJX@GJXAIOU",[[-1,29,"language"],[1,37,"j"]],[29,37],[30,30]]],[1563930393704,["GJX@GJXAIOU",[[1,30,"ava"]],[30,30],[33,33]]],[1563930393839,["GJX@GJXAIOU",[[1,34,"\n"]],[33,33],[34,34]]],[1563930394903,["GJX@GJXAIOU",[[1,34,"package com.qfedu.a_thread;\n\nimport org.junit.Test;\n\n/*\n  用线程同时\n  小芳视频和小红聊天 \n */\nclass VideoThread extends Thread {\n\t@Override\n\tpublic void run() {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tSystem.out.println(\"和小芳视频中………………\");\n\t\t}\n\t}\n}\n\nclass ChatThread extends Thread {\n\t@Override\n\tpublic void run() {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tSystem.out.println(\"和小红聊天中~~~~~\");\n\t\t}\n\t}\n}\t\n\npublic class Demo1 {\n\t@Test //注解\n\tpublic void test1() {\n\t\tVideoThread vt = new VideoThread();\n\t\tChatThread ct = new ChatThread();\n\t\t\n\t\tvt.start();\n\t\tct.start();\n\t}\n}\n\n\n\n"]],[34,34],[583,583]]],[1563930400655,["GJX@GJXAIOU",[[-1,62,"\n"]],[62,62],[61,61]]],[1563930526471,["GJX@GJXAIOU",[[1,434,"\n"]],[433,433],[434,434]]],[1563930529449,["GJX@GJXAIOU",[[1,434,"    、、"]],[434,434],[440,440]]],[1563930530087,["GJX@GJXAIOU",[[-1,438,"、、"]],[440,440],[438,438]]],[1563930532083,["GJX@GJXAIOU",[[1,438,"/、"]],[438,438],[440,440]]],[1563930532665,["GJX@GJXAIOU",[[-1,439,"、"]],[440,440],[439,439]]],[1563930534887,["GJX@GJXAIOU",[[1,439,"/zhiji"]],[439,439],[445,445]]],[1563930535823,["GJX@GJXAIOU",[[-1,440,"zhiji"]],[445,445],[440,440]]],[1563930561216,["GJX@GJXAIOU",[[1,440,"直接测试就行，在test1方法名上右击，run as J"]],[440,440],[468,468]]],[1563930563511,["GJX@GJXAIOU",[[-1,467,"J"]],[468,468],[467,467]]],[1563930565479,["GJX@GJXAIOU",[[1,467,"jUnit"]],[467,467],[472,472]]],[1563930573392,["GJX@GJXAIOU",[[-1,621,"\n"]],[621,621],[620,620]]],[1563930573719,["GJX@GJXAIOU",[[-1,620,"\n"]],[620,620],[619,619]]],[1563930573982,["GJX@GJXAIOU",[[-1,619,"\n"]],[619,619],[618,618]]],[1563930574423,["GJX@GJXAIOU",[[-1,618,"\n"]],[618,618],[617,617]]],[1563930600253,["GJX@GJXAIOU",[[1,623,"## xianch"]],[623,623],[632,632]]],[1563930601353,["GJX@GJXAIOU",[[-1,626,"xianch"]],[632,632],[626,626]]],[1563930606077,["GJX@GJXAIOU",[[1,626,"线程中的常用方法"]],[626,626],[634,634]]],[1563930606911,["GJX@GJXAIOU",[[1,635,"\n"]],[634,634],[635,635]]],[1563930621215,["GJX@GJXAIOU",[[1,635,"Thread(String name); 初始化线程的名字，属于线程的一个有参数的构造方法\n  setName(String name); 修改线程的名字\n  getName();  获取线程的名字\n  \n  static sleep(); static静态方法，通过Thread类名调用，这里需要处理一些异常，要求当前线程睡觉多少毫秒\n  \t\t\t【哪一个线程执行了sleep方法，哪一个线程就睡觉】\n  static currentThead(); static静态方法，返回当前的线程对象\n  \t\t\t【哪一个线程执行了currentThread方法，就返回哪一个线程对象】\n  \t\t\t\n  getPriority(); 返回当前线程的优先级 CPU执行的优先级，不是绝对的\n  setPriority(int newPriority); 设置线程的优先级\n  \t【注意】\n  \t\t线程的优先级范围是从1 ~ 10， 10最高，1最低\n  \t\t这里的优先级只是提高了当前线程拥有CPU执行权概率，并不能完全保证当前线程能够一定会占用更多的CPU时间\n  \t\t片\n  \t\t线程的默认优先级为5\n  \n  Thread[main,5,main]\n  Thread[Thread-0,5,main]\n  \n  Thread[线程名， 优先级， 线程组名]"]],[635,635],[1210,1210]]],[1563930624880,["GJX@GJXAIOU",[[1,1211,"  \n"]],[1210,1210],[1213,1213]]],[1563930625015,["GJX@GJXAIOU",[[-1,1211,"  "],[1,1213,"\n"]],[1213,1213],[1212,1212]]],[1563930632179,["GJX@GJXAIOU",[[-1,1212,"\n"],[1,1213,"·"]],[1212,1212],[1213,1213]]],[1563930632570,["GJX@GJXAIOU",[[1,1213,"··"]],[1213,1213],[1215,1215]]],[1563930633206,["GJX@GJXAIOU",[[-1,1213,"··"]],[1215,1215],[1213,1213]]],[1563930633423,["GJX@GJXAIOU",[[-1,1212,"·"],[1,1213,"\n"]],[1213,1213],[1212,1212]]],[1563930633934,["GJX@GJXAIOU",[[-1,1212,"\n"]],[1212,1212],[1211,1211]]],[1563930634946,["GJX@GJXAIOU",[[1,1212,"\n"]],[1211,1211],[1212,1212]]],[1563930635788,["GJX@GJXAIOU",[[-1,1212,"\n"],[1,1213,"·"]],[1212,1212],[1213,1213]]],[1563930636775,["GJX@GJXAIOU",[[-1,1212,"·"],[1,1213,"\n"]],[1213,1213],[1212,1212]]],[1563930637226,["GJX@GJXAIOU",[[-1,1212,"\n"],[1,1213,"·"]],[1212,1212],[1213,1213]]],[1563930637885,["GJX@GJXAIOU",[[1,1213,"··"]],[1213,1213],[1215,1215]]],[1563930638518,["GJX@GJXAIOU",[[-1,1213,"··"]],[1215,1215],[1213,1213]]],[1563930638791,["GJX@GJXAIOU",[[-1,1212,"·"],[1,1213,"\n"]],[1213,1213],[1212,1212]]],[1563930639603,["GJX@GJXAIOU",[[-1,1212,"\n"],[1,1213,"`"]],[1212,1212],[1213,1213]]],[1563930639983,["GJX@GJXAIOU",[[1,1213,"``"]],[1213,1213],[1215,1215]]],[1563930640007,["GJX@GJXAIOU",[[1,1215,"language\n```\n"]],[1215,1215],[1215,1223]]],[1563930640793,["GJX@GJXAIOU",[[-1,1215,"language"],[1,1223,"j"]],[1215,1223],[1216,1216]]],[1563930641223,["GJX@GJXAIOU",[[1,1216,"ava"]],[1216,1216],[1219,1219]]],[1563930641367,["GJX@GJXAIOU",[[1,1220,"\n"]],[1219,1219],[1220,1220]]],[1563930642432,["GJX@GJXAIOU",[[1,1220,"package com.qfedu.a_thread;\n\n/*\n 线程中的常用方法：\n  Thread(String name); 初始化线程的名字，属于线程的一个有参数的构造方法\n  setName(String name); 修改线程的名字\n  getName();  获取线程的名字\n  \n  static sleep(); static静态方法，通过Thread类名调用，这里需要处理一些异常，要求当前线程睡觉多少毫秒\n  \t\t\t【哪一个线程执行了sleep方法，哪一个线程就睡觉】\n  static currentThead(); static静态方法，返回当前的线程对象\n  \t\t\t【哪一个线程执行了currentThread方法，就返回哪一个线程对象】\n  \t\t\t\n  getPriority(); 返回当前线程的优先级 CPU执行的优先级，不是绝对的\n  setPriority(int newPriority); 设置线程的优先级\n  \t【注意】\n  \t\t线程的优先级范围是从1 ~ 10， 10最高，1最低\n  \t\t这里的优先级只是提高了当前线程拥有CPU执行权概率，并不能完全保证当前线程能够一定会占用更多的CPU时间\n  \t\t片\n  \t\t线程的默认优先级为5\n  \n  Thread[main,5,main]\n  Thread[Thread-0,5,main]\n  \n  Thread[线程名， 优先级， 线程组名]\n */\ninterface A {\n\tpublic void testA();\n}\n\npublic class Demo2 extends Thread implements A{\n\t\n\tpublic Demo2(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t@Override\n\tpublic void testA() {\n\t\t//这里也无法抛出异常，两种处理方法，第一种，捕获异常，第二种，在接口中声明方法部分，声明该异常\n\t\ttry {\n\t\t\tThread.sleep(100);\n\t\t} catch (InterruptedException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\t\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\t//这里是Demo2线程对象的线程代码\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"28:\" + Thread.currentThread());\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tSystem.out.println(\"自定义线程\");\n\t\t\t/*\n\t\t\t 在其他方法中， 使用sleep方法，可以抛出，可以捕获，但是在run方法为什么只有捕获没有抛出？？？\n\t\t\t \n\t\t\t 这是一个语法规则：在Java中，重写父类的方法，要求和父类的方法声明一模一样，在Thread类中\n\t\t\t run方法没有抛出异常，所以在子类中，你也不能抛出异常，要和父类一致\n\t\t\t */\n\t\t\ttry {\n\t\t\t\tsleep(100);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\t//这里是main线程\n\t\t\n\t\tDemo2 d = new Demo2(\"狗蛋\");\n\t\td.setName(\"狗娃\");\n\t\td.setPriority(10);\n\t\t//d.setName(\"狗子\");\n\t\t//System.out.println(d.getName());\n\t\td.start(); //开启自定义线程，执行自定义线程中的run方法里面的功能\n\t\tSystem.out.println(\"39:\" + Thread.currentThread());\n\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tSystem.out.println(\"这里是main线程\");\n\t\t\tsleep(100);\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[1220,1220],[3143,3143]]],[1563930647422,["GJX@GJXAIOU",[[-1,1249,"/*\n 线程中的常用方法：\n  Thread(String name); 初始化线程的名字，属于线程的一个有参数的构造方法\n  setName(String name); 修改线程的名字\n  getName();  获取线程的名字\n  \n  static sleep(); static静态方法，通过Thread类名调用，这里需要处理一些异常，要求当前线程睡觉多少毫秒\n  \t\t\t【哪一个线程执行了sleep方法，哪一个线程就睡觉】\n  static currentThead(); static静态方法，返回当前的线程对象\n  \t\t\t【哪一个线程执行了currentThread方法，就返回哪一个线程对象】\n  \t\t\t\n  getPriority(); 返回当前线程的优先级 CPU执行的优先级，不是绝对的\n  setPriority(int newPriority); 设置线程的优先级\n  \t【注意】\n  \t\t线程的优先级范围是从1 ~ 10， 10最高，1最低\n  \t\t这里的优先级只是提高了当前线程拥有CPU执行权概率，并不能完全保证当前线程能够一定会占用更多的CPU时间\n  \t\t片\n  \t\t线程的默认优先级为5\n  \n  Thread[main,5,main]\n  Thread[Thread-0,5,main]\n  \n  Thread[线程名， 优先级， 线程组名]\n */"]],[1249,1844],[1249,1249]]],[1563930650839,["GJX@GJXAIOU",[[-1,1249,"\n"]],[1249,1249],[1248,1248]]],[1563930665288,["GJX@GJXAIOU",[[-1,681,"  "]],[683,683],[681,681]]],[1563930668535,["GJX@GJXAIOU",[[-1,711,"  "]],[713,713],[711,711]]],[1563930748614,["GJX@GJXAIOU",[[-1,734,"  "]],[734,736],[734,734]]],[1563930764574,["GJX@GJXAIOU",[[-1,799," \t\t\t"]],[799,803],[799,799]]],[1563930766118,["GJX@GJXAIOU",[[-1,798," "]],[799,799],[798,798]]],[1563930766525,["GJX@GJXAIOU",[[-1,797,"\n"]],[798,798],[797,797]]],[1563930768247,["GJX@GJXAIOU",[[1,797,";"]],[797,797],[798,798]]],[1563930772751,["GJX@GJXAIOU",[[-1,871,"  \t\t\t"]],[871,876],[871,871]]],[1563930773127,["GJX@GJXAIOU",[[-1,870,"\n"]],[871,871],[870,870]]],[1563930776558,["GJX@GJXAIOU",[[-1,825,"  "]],[827,827],[825,825]]],[1563930779634,["GJX@GJXAIOU",[[1,635,"- "]],[635,635],[637,637]]],[1563930781864,["GJX@GJXAIOU",[[1,683,"- "]],[683,683],[685,685]]],[1563930783951,["GJX@GJXAIOU",[[1,715,"- "]],[715,715],[717,717]]],[1563930786699,["GJX@GJXAIOU",[[1,740,"- "]],[740,740],[742,742]]],[1563930789569,["GJX@GJXAIOU",[[1,833,"- "]],[833,833],[835,835]]],[1563930793816,["GJX@GJXAIOU",[[1,923,"- "]],[923,923],[925,925]]],[1563930796264,["GJX@GJXAIOU",[[1,969,"- "]],[969,969],[971,971]]],[1563930799143,["GJX@GJXAIOU",[[-1,921,"  "]],[923,923],[921,921]]],[1563930800671,["GJX@GJXAIOU",[[-1,965,"  "]],[965,965],[965,965]]],[1563930808256,["GJX@GJXAIOU",[[1,878,";"]],[878,878],[879,879]]],[1563930814164,["GJX@GJXAIOU",[[-1,1007,"  \t"],[1,1010,"-"]],[1007,1010],[1008,1008]]],[1563930814336,["GJX@GJXAIOU",[[1,1008," "]],[1008,1008],[1009,1009]]],[1563930821910,["GJX@GJXAIOU",[[-1,1101,"\n  \t\t"]],[1101,1106],[1101,1101]]],[1563930824103,["GJX@GJXAIOU",[[1,1102,"."]],[1102,1102],[1103,1103]]],[1563930825213,["GJX@GJXAIOU",[[-1,1102,"."]],[1103,1103],[1102,1102]]],[1563930825688,["GJX@GJXAIOU",[[1,1102,"。"]],[1102,1102],[1103,1103]]],[1563930846128,["GJX@GJXAIOU",[[1,950,"；"]],[950,950],[951,951]]],[1563930859120,["GJX@GJXAIOU",[[1,966,"，仅仅是提升概率；"]],[966,966],[975,975]]],[1563930859663,["GJX@GJXAIOU",[[-1,974,"；"]],[975,975],[974,974]]],[1563930860191,["GJX@GJXAIOU",[[1,974,"。"]],[974,974],[975,975]]],[1563930863840,["GJX@GJXAIOU",[[1,1016,"。"]],[1016,1016],[1017,1017]]],[1563930866849,["GJX@GJXAIOU",[[1,915,"。"]],[915,915],[916,916]]],[1563930868745,["GJX@GJXAIOU",[[1,832,"。"]],[832,832],[833,833]]],[1563930879373,["GJX@GJXAIOU",[[1,1022,"\n- "]],[1019,1019],[1022,1022]]],[1563930880950,["GJX@GJXAIOU",[[-1,1020,"- "]],[1022,1022],[1020,1020]]],[1563930918641,["GJX@GJXAIOU",[[1,1086,"的"]],[1086,1086],[1087,1087]]],[1563930926605,["GJX@GJXAIOU",[[-1,1119,"  \t\t"]],[1119,1123],[1119,1119]]],[1563930927023,["GJX@GJXAIOU",[[-1,1118,"\n"]],[1119,1119],[1118,1118]]],[1563930931280,["GJX@GJXAIOU",[[1,1128,"。"]],[1128,1128],[1129,1129]]],[1563931003775,["GJX@GJXAIOU",[[1,1607,"、、"]],[1607,1607],[1609,1609]]],[1563931004469,["GJX@GJXAIOU",[[-1,1607,"、、"]],[1609,1609],[1607,1607]]],[1563931008379,["GJX@GJXAIOU",[[1,1607,"//--------------------------------------------------"]],[1607,1607],[1659,1659]]],[1563931016415,["GJX@GJXAIOU",[[-1,1715,"\t\t// TODO Auto-generated method stub"]],[1717,1751],[1715,1715]]],[1563931016773,["GJX@GJXAIOU",[[-1,1715,"\n"]],[1715,1715],[1714,1714]]],[1563931135845,["GJX@GJXAIOU",[[-1,1185," "]],[1185,1185],[1184,1184]]],[1563931136222,["GJX@GJXAIOU",[[-1,1183,"\n"]],[1184,1184],[1183,1183]]],[1563931162447,["GJX@GJXAIOU",[[1,1377,"//dao"]],[1377,1377],[1382,1382]]],[1563931163008,["GJX@GJXAIOU",[[-1,1379,"dao"]],[1382,1382],[1379,1379]]],[1563931165866,["GJX@GJXAIOU",[[1,1379,"调用父类的"]],[1379,1379],[1384,1384]]],[1563931168796,["GJX@GJXAIOU",[[-1,1383,"的"]],[1384,1384],[1383,1383]]],[1563931179591,["GJX@GJXAIOU",[[1,1383,"Thread的有参构造方法"]],[1383,1383],[1396,1396]]],[1563931224405,["GJX@GJXAIOU",[[-1,2313,"\t\t//d.setName(\"狗子\");\n\t\t//System.out.println(d.getName());"]],[2315,2370],[2313,2313]]],[1563931224781,["GJX@GJXAIOU",[[-1,2313,"\n"]],[2313,2313],[2312,2312]]],[1563931281055,["GJX@GJXAIOU",[[-1,2519,"\n"]],[2519,2519],[2518,2518]]],[1563931281182,["GJX@GJXAIOU",[[-1,2518,"\n"]],[2518,2518],[2517,2517]]],[1563931281317,["GJX@GJXAIOU",[[-1,2517,"\n"]],[2517,2517],[2516,2516]]],[1563931281446,["GJX@GJXAIOU",[[-1,2516,"\n"]],[2516,2516],[2515,2515]]],[1563931281582,["GJX@GJXAIOU",[[-1,2515,"\n"]],[2515,2515],[2514,2514]]],[1563931281711,["GJX@GJXAIOU",[[-1,2514,"\n"]],[2514,2514],[2513,2513]]],[1563931281829,["GJX@GJXAIOU",[[-1,2513,"\n"]],[2513,2513],[2512,2512]]],[1563931281957,["GJX@GJXAIOU",[[-1,2512,"\n"]],[2512,2512],[2511,2511]]],[1563931282076,["GJX@GJXAIOU",[[-1,2511,"\n"]],[2511,2511],[2510,2510]]],[1563931282205,["GJX@GJXAIOU",[[-1,2510,"\n"]],[2510,2510],[2509,2509]]],[1563931282335,["GJX@GJXAIOU",[[-1,2509,"\n"]],[2509,2509],[2508,2508]]],[1563931282464,["GJX@GJXAIOU",[[-1,2508,"\n"]],[2508,2508],[2507,2507]]],[1563931282597,["GJX@GJXAIOU",[[-1,2507,"\n"]],[2507,2507],[2506,2506]]],[1563931282749,["GJX@GJXAIOU",[[-1,2506,"\n"]],[2506,2506],[2505,2505]]],[1563931283023,["GJX@GJXAIOU",[[-1,2505,"\n"]],[2505,2505],[2504,2504]]],[1563931366269,["GJX@GJXAIOU",[[-1,1970,"\t\t\t "]],[1970,1974],[1970,1970]]],[1563931366662,["GJX@GJXAIOU",[[-1,1969,"\n"]],[1970,1970],[1969,1969]]],[1563931367847,["GJX@GJXAIOU",[[1,1969,"，"]],[1969,1969],[1970,1970]]],[1563931374390,["GJX@GJXAIOU",[[-1,1917,"\t\t\t "]],[1917,1921],[1917,1917]]],[1563931374533,["GJX@GJXAIOU",[[-1,1916,"\n"]],[1917,1917],[1916,1916]]],[1563931375941,["GJX@GJXAIOU",[[-1,1912,"\t\t\t "]],[1916,1916],[1912,1912]]],[1563931376135,["GJX@GJXAIOU",[[-1,1911,"\n"]],[1912,1912],[1911,1911]]],[1563931376437,["GJX@GJXAIOU",[[-1,1910,"？"]],[1911,1911],[1910,1910]]],[1563931379945,["GJX@GJXAIOU",[[1,1910,"图标为=="]],[1910,1910],[1915,1915]]],[1563931381071,["GJX@GJXAIOU",[[-1,1909,"？图标为=="]],[1915,1915],[1909,1909]]],[1563931383259,["GJX@GJXAIOU",[[1,1909,"因为"]],[1909,1909],[1911,1911]]],[1563931391308,["GJX@GJXAIOU",[[-1,2065,"\t\t\t\t// TODO Auto-generated catch block"]],[2069,2103],[2065,2065]]],[1563931391773,["GJX@GJXAIOU",[[-1,2065,"\n"]],[2065,2065],[2064,2064]]],[1563931500356,["GJX@GJXAIOU",[[-1,1554,"\t\t\t// TODO Auto-generated catch block"]],[1557,1591],[1554,1554]]],[1563931500797,["GJX@GJXAIOU",[[-1,1554,"\n"]],[1554,1554],[1553,1553]]],[1563931520159,["GJX@GJXAIOU",[[1,1207,"下面的Interface"]],[1207,1207],[1219,1219]]],[1563931520184,["GJX@GJXAIOU",[[1,1210," "]],[1219,1219],[1220,1220]]],[1563931522153,["GJX@GJXAIOU",[[1,1220,"A和"]],[1220,1220],[1222,1222]]],[1563931522178,["GJX@GJXAIOU",[[1,1221," "]],[1222,1222],[1223,1223]]],[1563931529391,["GJX@GJXAIOU",[[1,1223,"test"]],[1223,1223],[1227,1227]]],[1563931529417,["GJX@GJXAIOU",[[1,1223," "]],[1227,1227],[1228,1228]]],[1563931531585,["GJX@GJXAIOU",[[1,1228,"A是"]],[1228,1228],[1230,1230]]],[1563931531611,["GJX@GJXAIOU",[[1,1229," "]],[1230,1230],[1231,1231]]],[1563931543745,["GJX@GJXAIOU",[[1,1231,"为了测试什么时候不能"]],[1231,1231],[1241,1241]]],[1563931549416,["GJX@GJXAIOU",[[1,1241,"抛出一餐"]],[1241,1241],[1245,1245]]],[1563931550087,["GJX@GJXAIOU",[[-1,1243,"一餐"]],[1245,1245],[1243,1243]]],[1563931555687,["GJX@GJXAIOU",[[1,1243,"异常；"]],[1243,1243],[1246,1246]]],[1563931561856,["GJX@GJXAIOU",[[1,2457,"\n"]],[2456,2456],[2457,2457]]],[1563931561990,["GJX@GJXAIOU",[[1,2458,"\n"]],[2457,2457],[2458,2458]]],[1563931562134,["GJX@GJXAIOU",[[1,2459,"\n"]],[2458,2458],[2459,2459]]],[1563931562262,["GJX@GJXAIOU",[[1,2460,"\n"]],[2459,2459],[2460,2460]]],[1563931563713,["GJX@GJXAIOU",[[1,2460,"## "]],[2460,2460],[2463,2463]]],[1563931572104,["GJX@GJXAIOU",[[1,2464,"\n"]],[2463,2463],[2464,2464]]],[1563931572415,["GJX@GJXAIOU",[[1,2465,"\n"]],[2464,2464],[2465,2465]]],[1563931587443,["GJX@GJXAIOU",[[1,2463,"线程的什么"]],[2463,2463],[2468,2468]]],[1563931588718,["GJX@GJXAIOU",[[-1,2466,"什么"]],[2468,2468],[2466,2466]]],[1563931590673,["GJX@GJXAIOU",[[1,2466,"什么"]],[2466,2466],[2468,2468]]],[1563931591277,["GJX@GJXAIOU",[[-1,2466,"什么"]],[2468,2468],[2466,2466]]],[1563931594634,["GJX@GJXAIOU",[[1,2466,"生命周期"]],[2466,2466],[2470,2470]]],[1563931595165,["GJX@GJXAIOU",[[1,2473,"\n"]],[2470,2470],[2471,2471]]],[1563931595277,["GJX@GJXAIOU",[[1,2474,"\n"]],[2471,2471],[2472,2472]]],[1563931962758,["GJX@GJXAIOU",[[1,2472,"![线程的生命周期]($resource/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)"]],[2472,2472],[2562,2562]]],[1563932023285,["GJX@GJXAIOU",[[1,2564,"\n"]],[2563,2563],[2564,2564]]],[1563932024389,["GJX@GJXAIOU",[[1,2564,"## "]],[2564,2564],[2567,2567]]],[1563932033487,["GJX@GJXAIOU",[[1,2567,"线程的共享资源问题"]],[2567,2567],[2576,2576]]],[1563932033932,["GJX@GJXAIOU",[[1,2577,"\n"]],[2576,2576],[2577,2577]]],[1563932035291,["GJX@GJXAIOU",[[1,2578,"\n"]],[2577,2577],[2578,2578]]],[1563932037653,["GJX@GJXAIOU",[[1,2578,"      "]],[2578,2578],[2584,2584]]],[1563932039733,["GJX@GJXAIOU",[[-1,2578,"      "]],[2584,2584],[2578,2578]]],[1563932040885,["GJX@GJXAIOU",[[-1,2578,"\n"],[1,2579,"`"]],[2578,2578],[2579,2579]]],[1563932041277,["GJX@GJXAIOU",[[1,2579,"``"]],[2579,2579],[2581,2581]]],[1563932041303,["GJX@GJXAIOU",[[1,2581,"language\n```\n"]],[2581,2581],[2581,2589]]],[1563932041948,["GJX@GJXAIOU",[[-1,2581,"language"],[1,2589,"j"]],[2581,2589],[2582,2582]]],[1563932042384,["GJX@GJXAIOU",[[1,2582,"ava"]],[2582,2582],[2585,2585]]],[1563932042572,["GJX@GJXAIOU",[[1,2586,"\n"]],[2585,2585],[2586,2586]]],[1563932043710,["GJX@GJXAIOU",[[1,2586,"package com.qfedu.a_thread;\n\n/*\n \t线程的共享资源问题 \n\n \t动物园：\n \t\t卖票 50张票 3个窗口售卖\n\n \t这里隐含多线程，这里可以把3个窗口看做是3个线程\n\n \t问题:\n \t\t发现票每一张都被买了三次\n \t原因：\n \t\t因为Ticket是在每一个线程中run方法里面的一个局部变量，这个局部变量是每一个线程对象都拥有的\n \t\t这里Ticket就是不在是一个共享资源\n \t处理方式：\n \t\t把Ticket变成成员变量\n\n \t问题：\n \t\t发现貌似每一张票还都是卖了50次，而且这里还优化了售卖的算法\n \t原因：\n \t\t这里Ticket变成了一个成员变量，在每一个线程对象中，都拥有这个Ticket成员变量，每一个成员变量\n \t\t是一个独立的个体，不是共享资源\n \t处理方式:\n \t\t用static修饰ticket成员变量，变成一个存放在数据共享区的一个静态成员变量\n\n \t问题：\n \t\t发现会出现几张票是买了多次的\n \t原因：\n \t\t因为窗口1在卖票的时候，还没有运行到ticket--这条语句的时候，下一个窗口2开始执行卖票算法\n \t\t这里窗口2卖的票是窗口1还没有ticket--的票\n \t处理方式：\n \t\t上锁，锁门\n\n \tJava中的线程同步机制：\n \t\t方式1：\n \t\t\t同步代码块：\n \t\t\t格式：\n \t\t\t\tsynchronized (锁对象) {\n \t\t\t\t\t需要同步的代码;\n \t\t\t\t}\n \t\t同步代码块的注意事项：\n \t\t\t1. 锁对象，可以是任意的一个对象， 但是必须是同一个对象！！！不能在这里使用new 来创建匿名对象\n \t\t\t2. sleep() 不会释放锁对象，不会开锁。例如： 厕所有人关门睡着了\n \t\t\t3. 使用synchronized 同步代码块的时候，必须是真正意义上存在共享资源的线程问题，才会使用\n \t\t\t而且通常情况下，用synchronized锁住的代码越少越好，提高代码执行效率\n */\n\nclass SaleTicket extends Thread {\n\n\tprivate static int ticket = 50;\n\n\tpublic SaleTicket(String name) {\n\t\tsuper(name);\n\t}\n\n\t@Override\n\tpublic void run() {\n\n\t\twhile (true) {\n\t\t\tsynchronized (\"你好\") { //\"你好 \" new Demo3() \n\t\t\t\tif (ticket > 0) {\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName()+\":卖出来第\" + ticket\n\t\t\t\t\t\t\t+ \"张票\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsleep(500);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"卖完了\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tticket--;\n\t\t\t}\n\t\t}\n\t}\n}\n\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n\t\tSaleTicket s1 = new SaleTicket(\"窗口1\");\n\t\tSaleTicket s2 = new SaleTicket(\"窗口2\");\n\t\tSaleTicket s3 = new SaleTicket(\"窗口3\");\n\n\t\ts2.start();\n\t\ts1.start();\n\t\ts3.start();\n\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n"]],[2586,2586],[4239,4239]]],[1563932050612,["GJX@GJXAIOU",[[-1,2615,"/*\n \t线程的共享资源问题 \n\n \t动物园：\n \t\t卖票 50张票 3个窗口售卖\n\n \t这里隐含多线程，这里可以把3个窗口看做是3个线程\n\n \t问题:\n \t\t发现票每一张都被买了三次\n \t原因：\n \t\t因为Ticket是在每一个线程中run方法里面的一个局部变量，这个局部变量是每一个线程对象都拥有的\n \t\t这里Ticket就是不在是一个共享资源\n \t处理方式：\n \t\t把Ticket变成成员变量\n\n \t问题：\n \t\t发现貌似每一张票还都是卖了50次，而且这里还优化了售卖的算法\n \t原因：\n \t\t这里Ticket变成了一个成员变量，在每一个线程对象中，都拥有这个Ticket成员变量，每一个成员变量\n \t\t是一个独立的个体，不是共享资源\n \t处理方式:\n \t\t用static修饰ticket成员变量，变成一个存放在数据共享区的一个静态成员变量\n\n \t问题：\n \t\t发现会出现几张票是买了多次的\n \t原因：\n \t\t因为窗口1在卖票的时候，还没有运行到ticket--这条语句的时候，下一个窗口2开始执行卖票算法\n \t\t这里窗口2卖的票是窗口1还没有ticket--的票\n \t处理方式：\n \t\t上锁，锁门\n\n \tJava中的线程同步机制：\n \t\t方式1：\n \t\t\t同步代码块：\n \t\t\t格式：\n \t\t\t\tsynchronized (锁对象) {\n \t\t\t\t\t需要同步的代码;\n \t\t\t\t}\n \t\t同步代码块的注意事项：\n \t\t\t1. 锁对象，可以是任意的一个对象， 但是必须是同一个对象！！！不能在这里使用new 来创建匿名对象\n \t\t\t2. sleep() 不会释放锁对象，不会开锁。例如： 厕所有人关门睡着了\n \t\t\t3. 使用synchronized 同步代码块的时候，必须是真正意义上存在共享资源的线程问题，才会使用\n \t\t\t而且通常情况下，用synchronized锁住的代码越少越好，提高代码执行效率\n */\n"]],[2615,3426],[2615,2615]]],[1563932053086,["GJX@GJXAIOU",[[1,2578,"\n"]],[2577,2577],[2578,2578]]],[1563932053516,["GJX@GJXAIOU",[[1,2578,"/*\n \t线程的共享资源问题 \n\n \t动物园：\n \t\t卖票 50张票 3个窗口售卖\n\n \t这里隐含多线程，这里可以把3个窗口看做是3个线程\n\n \t问题:\n \t\t发现票每一张都被买了三次\n \t原因：\n \t\t因为Ticket是在每一个线程中run方法里面的一个局部变量，这个局部变量是每一个线程对象都拥有的\n \t\t这里Ticket就是不在是一个共享资源\n \t处理方式：\n \t\t把Ticket变成成员变量\n\n \t问题：\n \t\t发现貌似每一张票还都是卖了50次，而且这里还优化了售卖的算法\n \t原因：\n \t\t这里Ticket变成了一个成员变量，在每一个线程对象中，都拥有这个Ticket成员变量，每一个成员变量\n \t\t是一个独立的个体，不是共享资源\n \t处理方式:\n \t\t用static修饰ticket成员变量，变成一个存放在数据共享区的一个静态成员变量\n\n \t问题：\n \t\t发现会出现几张票是买了多次的\n \t原因：\n \t\t因为窗口1在卖票的时候，还没有运行到ticket--这条语句的时候，下一个窗口2开始执行卖票算法\n \t\t这里窗口2卖的票是窗口1还没有ticket--的票\n \t处理方式：\n \t\t上锁，锁门\n\n \tJava中的线程同步机制：\n \t\t方式1：\n \t\t\t同步代码块：\n \t\t\t格式：\n \t\t\t\tsynchronized (锁对象) {\n \t\t\t\t\t需要同步的代码;\n \t\t\t\t}\n \t\t同步代码块的注意事项：\n \t\t\t1. 锁对象，可以是任意的一个对象， 但是必须是同一个对象！！！不能在这里使用new 来创建匿名对象\n \t\t\t2. sleep() 不会释放锁对象，不会开锁。例如： 厕所有人关门睡着了\n \t\t\t3. 使用synchronized 同步代码块的时候，必须是真正意义上存在共享资源的线程问题，才会使用\n \t\t\t而且通常情况下，用synchronized锁住的代码越少越好，提高代码执行效率\n */\n"]],[2578,2578],[3389,3389]]],[1563932055635,["GJX@GJXAIOU",[[-1,2578,"/*"]],[2578,2580],[2578,2578]]],[1563932056070,["GJX@GJXAIOU",[[-1,2578,"\n"]],[2578,2578],[2577,2577]]],[1563932059854,["GJX@GJXAIOU",[[-1,3383,"*/"]],[3383,3385],[3383,3383]]],[1563932065581,["GJX@GJXAIOU",[[-1,2578," \t线程的共享资源问题 "]],[2579,2590],[2578,2578]]],[1563932066660,["GJX@GJXAIOU",[[-1,2579,"\n"]],[2579,2579],[2578,2578]]],[1563932067053,["GJX@GJXAIOU",[[-1,2578,"\n"]],[2578,2578],[2577,2577]]],[1563932071961,["GJX@GJXAIOU",[[-1,2578," \t"],[-1,2585," \t\t"],[-1,2604," \t"],[-1,2632," \t"],[-1,2638," \t\t"],[-1,2654," \t"],[-1,2660," \t\t"],[-1,2713," \t\t"],[-1,2736," \t"],[-1,2744," \t\t"],[-1,2762," \t"],[-1,2768," \t\t"],[-1,2802," \t"],[-1,2808," \t\t"],[-1,2863," \t\t"],[-1,2882," \t"],[-1,2890," \t\t"],[-1,2936," \t"],[-1,2942," \t\t"],[-1,2960," \t"],[-1,2966," \t\t"],[-1,3018," \t\t"],[-1,3047," \t"],[-1,3055," \t\t"],[-1,3065," \t"],[-1,3081," \t\t"],[-1,3089," \t\t\t"],[-1,3100," \t\t\t"],[-1,3108," \t\t\t\t"],[-1,3134," \t\t\t\t\t"],[-1,3149," \t\t\t\t"],[-1,3156," \t\t"],[-1,3171," \t\t\t"],[-1,3226," \t\t\t"],[-1,3268," \t\t\t"],[-1,3324," \t\t\t"]],[2580,3367],[2580,3367]]],[1563932072243,["GJX@GJXAIOU",[[-1,3259," "],[-1,3335,"\t"]],[2580,3367],[2580,3366]]],[1563932075851,["GJX@GJXAIOU",[[1,3334,"  "]],[3334,3334],[3336,3336]]],[1563932077852,["GJX@GJXAIOU",[[-1,3333,"\n"]],[3333,3333],[3332,3332]]],[1563932084604,["GJX@GJXAIOU",[[-1,2598,"\n"]],[2598,2598],[2597,2597]]],[1563932085092,["GJX@GJXAIOU",[[-1,2596,"卖"]],[2597,2597],[2596,2596]]],[1563932087327,["GJX@GJXAIOU",[[1,2596,"卖"]],[2596,2596],[2597,2597]]],[1563932287399,["GJX@GJXAIOU",[[-1,2826,"\n"]],[2827,2827],[2826,2826]]],[1563932307011,["GJX@GJXAIOU",[[-1,2694,"\n"]],[2695,2695],[2694,2694]]],[1563932307630,["GJX@GJXAIOU",[[1,2694,","]],[2694,2694],[2695,2695]]],[1563932791933,["GJX@GJXAIOU",[[1,2989,"\n"]],[2988,2988],[2989,2989]]],[1563932801004,["GJX@GJXAIOU",[[1,2989,"![线程安全问题]($resource/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.png)"]],[2989,2989],[3069,3069]]],[1563932814478,["GJX@GJXAIOU",[[1,3082,"- "]],[3082,3082],[3084,3084]]],[1563932833714,["GJX@GJXAIOU",[[1,3114,"\n"]],[3113,3113],[3114,3114]]],[1563932837231,["GJX@GJXAIOU",[[1,3114,"```java"]],[3114,3114],[3121,3121]]],[1563932839483,["GJX@GJXAIOU",[[1,3154,"\n"]],[3153,3153],[3154,3154]]],[1563932840247,["GJX@GJXAIOU",[[1,3154,"```"]],[3154,3154],[3157,3157]]],[1563932849565,["GJX@GJXAIOU",[[1,3143,"  //"]],[3143,3143],[3147,3147]]],[1563932992875,["GJX@GJXAIOU",[[-1,3708,"\n\t\t\t\t\t\t\t"]],[3708,3716],[3708,3708]]],[1563933001419,["GJX@GJXAIOU",[[-1,4199,"\n"]],[4199,4199],[4198,4198]]],[1563933001676,["GJX@GJXAIOU",[[-1,4198,"\n"]],[4198,4198],[4197,4197]]],[1563933001908,["GJX@GJXAIOU",[[-1,4197,"\n"]],[4197,4197],[4196,4196]]],[1563933002150,["GJX@GJXAIOU",[[-1,4196,"\n"]],[4196,4196],[4195,4195]]],[1563933002355,["GJX@GJXAIOU",[[-1,4195,"\n"]],[4195,4195],[4194,4194]]],[1563933002547,["GJX@GJXAIOU",[[-1,4194,"\n"]],[4194,4194],[4193,4193]]],[1563933002757,["GJX@GJXAIOU",[[-1,4193,"\n"]],[4193,4193],[4192,4192]]],[1563933002939,["GJX@GJXAIOU",[[-1,4192,"\n"]],[4192,4192],[4191,4191]]],[1563933003155,["GJX@GJXAIOU",[[-1,4191,"\n"]],[4191,4191],[4190,4190]]],[1563933003387,["GJX@GJXAIOU",[[-1,4190,"\n"]],[4190,4190],[4189,4189]]],[1563933003844,["GJX@GJXAIOU",[[-1,4189,"\n"]],[4189,4189],[4188,4188]]],[1563933011763,["GJX@GJXAIOU",[[1,3611,"chuang"]],[3611,3611],[3617,3617]]],[1563933013043,["GJX@GJXAIOU",[[-1,3611,"chuang"]],[3617,3617],[3611,3611]]],[1563933027353,["GJX@GJXAIOU",[[1,3611,"创建不同对象，即对应不同的锁"]],[3611,3611],[3625,3625]]],[1563933102317,["GJX@GJXAIOU",[[1,3759," 、、"]],[3759,3759],[3762,3762]]],[1563933103203,["GJX@GJXAIOU",[[-1,3760,"、、"]],[3762,3762],[3760,3760]]],[1563933104012,["GJX@GJXAIOU",[[1,3760,"//"]],[3760,3760],[3762,3762]]],[1563933172464,["GJX@GJXAIOU",[[1,3762,"睡眠也不会释放锁对象"]],[3762,3762],[3772,3772]]],[1563933181412,["GJX@GJXAIOU",[[-1,3813,"\t\t\t\t\t\t// TODO Auto-generated catch block"]],[3813,3853],[3813,3813]]],[1563933181836,["GJX@GJXAIOU",[[-1,3813,"\n"]],[3813,3813],[3812,3812]]],[1563933339885,["GJX@GJXAIOU",[[1,4179,"\n"]],[4178,4178],[4179,4179]]],[1563933340043,["GJX@GJXAIOU",[[1,4180,"\n"]],[4179,4179],[4180,4180]]],[1563933341214,["GJX@GJXAIOU",[[1,4180,"### "]],[4180,4180],[4184,4184]]],[1563933346248,["GJX@GJXAIOU",[[1,4184,"死锁"]],[4184,4184],[4186,4186]]],[1563933346515,["GJX@GJXAIOU",[[1,4187,"\n"]],[4186,4186],[4187,4187]]],[1563933420133,["GJX@GJXAIOU",[[1,4188,"\n"]],[4187,4187],[4188,4188]]],[1563933420541,["GJX@GJXAIOU",[[1,4188,"package com.qfedu.a_thread;\n\n/*\n 开发中的死锁现象\n  为什么会出现死锁： 【必须会】\n  \t1. 存在两个或两个以上的共享资源\n  \t2. 存在两个或者两个以上的线程使用这些共享资源\n 绝对不能用死锁！！！\n */\n\nclass DeadLock extends Thread {\n\tpublic DeadLock(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tif (Thread.currentThread().getName().equals(\"小胖\")) {\n\t\t\tsynchronized (\"电池\") {\n\t\t\t\tSystem.out.println(\"小胖有电池，想要遥控器\");\n\t\t\t\t\n\t\t\t\tsynchronized (\"遥控器\") {\n\t\t\t\t\tSystem.out.println(\"小胖拿到了遥控器，打开了投影仪\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Thread.currentThread().getName().equals(\"逗比\")) {\n\t\t\tsynchronized (\"遥控器\") {\n\t\t\t\tSystem.out.println(\"逗比有遥控器，想要电池\");\n\t\t\t\t\n\t\t\t\tsynchronized (\"电池\") {\n\t\t\t\t\tSystem.out.println(\"逗比拿到了电池，打开了投影仪\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\npublic class Demo4 {\n\tpublic static void main(String[] args) {\n\t\tDeadLock d1 = new DeadLock(\"小胖\");\n\t\tDeadLock d2 = new DeadLock(\"逗比\");\n\t\t\n\t\td1.start();\n\t\td2.start();\n\t\t\n\t}\n}\n"]],[4188,4188],[5035,5035]]],[1563933423218,["GJX@GJXAIOU",[[-1,4188,"package com.qfedu.a_thread;\n\n/*\n 开发中的死锁现象\n  为什么会出现死锁： 【必须会】\n  \t1. 存在两个或两个以上的共享资源\n  \t2. 存在两个或者两个以上的线程使用这些共享资源\n 绝对不能用死锁！！！\n */\n\nclass DeadLock extends Thread {\n\tpublic DeadLock(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tif (Thread.currentThread().getName().equals(\"小胖\")) {\n\t\t\tsynchronized (\"电池\") {\n\t\t\t\tSystem.out.println(\"小胖有电池，想要遥控器\");\n\t\t\t\t\n\t\t\t\tsynchronized (\"遥控器\") {\n\t\t\t\t\tSystem.out.println(\"小胖拿到了遥控器，打开了投影仪\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Thread.currentThread().getName().equals(\"逗比\")) {\n\t\t\tsynchronized (\"遥控器\") {\n\t\t\t\tSystem.out.println(\"逗比有遥控器，想要电池\");\n\t\t\t\t\n\t\t\t\tsynchronized (\"电池\") {\n\t\t\t\t\tSystem.out.println(\"逗比拿到了电池，打开了投影仪\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\npublic class Demo4 {\n\tpublic static void main(String[] args) {\n\t\tDeadLock d1 = new DeadLock(\"小胖\");\n\t\tDeadLock d2 = new DeadLock(\"逗比\");\n\t\t\n\t\td1.start();\n\t\td2.start();\n\t\t\n\t}\n}\n"]],[5035,5035],[4188,4188]]],[1563933424828,["GJX@GJXAIOU",[[-1,4188,"\n"],[1,4189,"·"]],[4188,4188],[4189,4189]]],[1563933425038,["GJX@GJXAIOU",[[1,4189,"·"]],[4189,4189],[4190,4190]]],[1563933425946,["GJX@GJXAIOU",[[-1,4189,"·"]],[4190,4190],[4189,4189]]],[1563933426106,["GJX@GJXAIOU",[[-1,4188,"·"],[1,4189,"\n"]],[4189,4189],[4188,4188]]],[1563933426822,["GJX@GJXAIOU",[[-1,4188,"\n"],[1,4189,"`"]],[4188,4188],[4189,4189]]],[1563933427188,["GJX@GJXAIOU",[[1,4189,"``"]],[4189,4189],[4191,4191]]],[1563933427225,["GJX@GJXAIOU",[[1,4191,"language\n```\n"]],[4191,4191],[4191,4199]]],[1563933428060,["GJX@GJXAIOU",[[-1,4191,"language"],[1,4199,"j"]],[4191,4199],[4192,4192]]],[1563933428493,["GJX@GJXAIOU",[[1,4192,"ava"]],[4192,4192],[4195,4195]]],[1563933428587,["GJX@GJXAIOU",[[1,4196,"\n"]],[4195,4195],[4196,4196]]],[1563933429481,["GJX@GJXAIOU",[[1,4196,"package com.qfedu.a_thread;\n\n/*\n 开发中的死锁现象\n  为什么会出现死锁： 【必须会】\n  \t1. 存在两个或两个以上的共享资源\n  \t2. 存在两个或者两个以上的线程使用这些共享资源\n 绝对不能用死锁！！！\n */\n\nclass DeadLock extends Thread {\n\tpublic DeadLock(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tif (Thread.currentThread().getName().equals(\"小胖\")) {\n\t\t\tsynchronized (\"电池\") {\n\t\t\t\tSystem.out.println(\"小胖有电池，想要遥控器\");\n\t\t\t\t\n\t\t\t\tsynchronized (\"遥控器\") {\n\t\t\t\t\tSystem.out.println(\"小胖拿到了遥控器，打开了投影仪\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Thread.currentThread().getName().equals(\"逗比\")) {\n\t\t\tsynchronized (\"遥控器\") {\n\t\t\t\tSystem.out.println(\"逗比有遥控器，想要电池\");\n\t\t\t\t\n\t\t\t\tsynchronized (\"电池\") {\n\t\t\t\t\tSystem.out.println(\"逗比拿到了电池，打开了投影仪\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\npublic class Demo4 {\n\tpublic static void main(String[] args) {\n\t\tDeadLock d1 = new DeadLock(\"小胖\");\n\t\tDeadLock d2 = new DeadLock(\"逗比\");\n\t\t\n\t\td1.start();\n\t\td2.start();\n\t\t\n\t}\n}\n"]],[4196,4196],[5043,5043]]],[1563933433536,["GJX@GJXAIOU",[[-1,4225,"/*\n 开发中的死锁现象\n  为什么会出现死锁： 【必须会】\n  \t1. 存在两个或两个以上的共享资源\n  \t2. 存在两个或者两个以上的线程使用这些共享资源\n 绝对不能用死锁！！！\n */\n"],[1,4321,"x"]],[4225,4321],[4226,4226]]],[1563933435218,["GJX@GJXAIOU",[[-1,4225,"x"]],[4226,4226],[4225,4225]]],[1563933435385,["GJX@GJXAIOU",[[-1,4225,"\n"]],[4225,4225],[4224,4224]]],[1563933435674,["GJX@GJXAIOU",[[-1,4224,"\n"]],[4224,4224],[4223,4223]]],[1563933437412,["GJX@GJXAIOU",[[1,4187,"/*\n 开发中的死锁现象\n  为什么会出现死锁： 【必须会】\n  \t1. 存在两个或两个以上的共享资源\n  \t2. 存在两个或者两个以上的线程使用这些共享资源\n 绝对不能用死锁！！！\n */\n"]],[4187,4187],[4283,4283]]],[1563933572107,["GJX@GJXAIOU",[[1,5046,"\n"]],[5045,5045],[5046,5046]]],[1563933590173,["GJX@GJXAIOU",[[-1,5046,"\n"],[1,5047,"c"]],[5046,5046],[5047,5047]]],[1563933590981,["GJX@GJXAIOU",[[1,5047,"unz"]],[5047,5047],[5050,5050]]],[1563933591666,["GJX@GJXAIOU",[[-1,5047,"unz"]],[5050,5050],[5047,5047]]],[1563933591804,["GJX@GJXAIOU",[[-1,5046,"c"],[1,5047,"\n"]],[5047,5047],[5046,5046]]],[1563933594496,["GJX@GJXAIOU",[[-1,5046,"\n"],[1,5047,"存在"]],[5046,5046],[5048,5048]]],[1563933608109,["GJX@GJXAIOU",[[1,5048,"死锁行为，会出现无法执行的情况；"]],[5048,5048],[5064,5064]]],[1563933634964,["GJX@GJXAIOU",[[1,5064,"\n\n"]],[5064,5064],[5065,5065]]],[1563933635123,["GJX@GJXAIOU",[[1,5066,"\n"]],[5065,5065],[5066,5066]]],[1563933635322,["GJX@GJXAIOU",[[1,5067,"\n"]],[5066,5066],[5067,5067]]],[1563933653308,["GJX@GJXAIOU",[[-1,5032,"\n"]],[5033,5033],[5032,5032]]],[1563933655933,["GJX@GJXAIOU",[[-1,5040,"\n"]],[5040,5040],[5039,5039]]],[1563933663314,["GJX@GJXAIOU",[[-1,4857,"\n"]],[4858,4858],[4857,4857]]],[1563933715347,["GJX@GJXAIOU",[[1,5065,"\n"]],[5062,5062],[5063,5063]]],[1563933720299,["GJX@GJXAIOU",[[1,5063,"### "]],[5063,5063],[5067,5067]]],[1563933734955,["GJX@GJXAIOU",[[1,5068,"package com.qfedu.a_thread;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n/*\n\tJava语言是一种单继承，多实现【遵从】面向对象的语言\n\t\n\t自定义线程的方式：\n\t\t方式1：\n\t\t\t1. 自定义一个类，继承Thread类\n\t\t\t2. 重写Thread里面的run方法，把线程的功能代码放入到run方法中\n\t\t\t3. 创建自定义线程类对象\n\t\t\t4. 开启线程，使用start方法\n\t\t\n\t\t弊端：\n\t\t\t因为Java是一个单继承的语言，一旦某一个类继承了Thread类，就无法再继承其他类，或者说\n\t\t\t一个类继承了其他类，也就没有办法继承Thread类\n\t\t\n\t\t方式2: 【墙裂推荐】\n\t\t\t【遵从】Runnable接口实现自定线程类\n\t\t\t1. 自定义一个类，【遵从】Runnable接口\n\t\t\t2. 实现Runnable接口中唯一要求的方法 Run方法，把线程的功能代码写入到run方法中\n\t\t\t3. 创建Thread类对象，并且把【遵从】Runnable接口的自定义类对象，作为参数传入到\n\t\t\tThread构造方法中\n\t\t\t4. 调用Thread类对象的start方法，开启线程\n */\n\nclass TestRunnable implements Runnable {\n\n\t//实现自定义线程类，遵从Runnable接口要求实现的Run方法，把线程代码写入到Runnable里面\n\t@Override\n\tpublic void run() {\n\t\tfor (int i = 0 ; i < 10; i++) {\n\t\t\tSystem.out.println(\"当前线程为:\" + Thread.currentThread());\n\t\t}\n\t}\t\n}\n\npublic class Demo5 {\n\tpublic static <T> void main(String[] args) {\n\t\t//创建Thread类对象，调用Thread构造方法中，需要传入Runnable接口实现类对象的方法~\n\t\tThread t1 = new Thread(new TestRunnable());\n\t\t\n//\t\tArrays.sort(a, new Comparator<String>() {\n//\n//\t\t\t@Override\n//\t\t\tpublic int compare(String o1, String o2) {\n//\t\t\t\t// TODO Auto-generated method stub\n//\t\t\t\treturn 0;\n//\t\t\t}\n//\t\t});\n\t\t\n\t\tThread t2 = new Thread(new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tSystem.out.println(\"匿名内部类的匿名对象，作为方法的参数，这里是作为线程对象的参数\" + \n\t\t\t\t\t\t\tThread.currentThread());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tt1.start();\n\t\tt2.start();\n\t\t\n\t\t/*\n\t\ttarget是在创建Thread类对象时候，传入的【遵从】Runnable接口的实现类，这个实现类中\n\t\t实现类【遵从】Runnable接口要求实现的run方法，在run方法中，就是定义的线程代码\n\t\t在Thread类中有一个成员变量\n\t\t//What will be run\n\t\tprivate Runnable target; \n\t\t\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif (target != null) {\n\t\t\t\ttarget.run();\n\t\t\t}\n\t\t}\n\t\t*/\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n"]],[5068,5068],[6750,6750]]],[1563933736389,["GJX@GJXAIOU",[[-1,5068,"package com.qfedu.a_thread;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n/*\n\tJava语言是一种单继承，多实现【遵从】面向对象的语言\n\t\n\t自定义线程的方式：\n\t\t方式1：\n\t\t\t1. 自定义一个类，继承Thread类\n\t\t\t2. 重写Thread里面的run方法，把线程的功能代码放入到run方法中\n\t\t\t3. 创建自定义线程类对象\n\t\t\t4. 开启线程，使用start方法\n\t\t\n\t\t弊端：\n\t\t\t因为Java是一个单继承的语言，一旦某一个类继承了Thread类，就无法再继承其他类，或者说\n\t\t\t一个类继承了其他类，也就没有办法继承Thread类\n\t\t\n\t\t方式2: 【墙裂推荐】\n\t\t\t【遵从】Runnable接口实现自定线程类\n\t\t\t1. 自定义一个类，【遵从】Runnable接口\n\t\t\t2. 实现Runnable接口中唯一要求的方法 Run方法，把线程的功能代码写入到run方法中\n\t\t\t3. 创建Thread类对象，并且把【遵从】Runnable接口的自定义类对象，作为参数传入到\n\t\t\tThread构造方法中\n\t\t\t4. 调用Thread类对象的start方法，开启线程\n */\n\nclass TestRunnable implements Runnable {\n\n\t//实现自定义线程类，遵从Runnable接口要求实现的Run方法，把线程代码写入到Runnable里面\n\t@Override\n\tpublic void run() {\n\t\tfor (int i = 0 ; i < 10; i++) {\n\t\t\tSystem.out.println(\"当前线程为:\" + Thread.currentThread());\n\t\t}\n\t}\t\n}\n\npublic class Demo5 {\n\tpublic static <T> void main(String[] args) {\n\t\t//创建Thread类对象，调用Thread构造方法中，需要传入Runnable接口实现类对象的方法~\n\t\tThread t1 = new Thread(new TestRunnable());\n\t\t\n//\t\tArrays.sort(a, new Comparator<String>() {\n//\n//\t\t\t@Override\n//\t\t\tpublic int compare(String o1, String o2) {\n//\t\t\t\t// TODO Auto-generated method stub\n//\t\t\t\treturn 0;\n//\t\t\t}\n//\t\t});\n\t\t\n\t\tThread t2 = new Thread(new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tSystem.out.println(\"匿名内部类的匿名对象，作为方法的参数，这里是作为线程对象的参数\" + \n\t\t\t\t\t\t\tThread.currentThread());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tt1.start();\n\t\tt2.start();\n\t\t\n\t\t/*\n\t\ttarget是在创建Thread类对象时候，传入的【遵从】Runnable接口的实现类，这个实现类中\n\t\t实现类【遵从】Runnable接口要求实现的run方法，在run方法中，就是定义的线程代码\n\t\t在Thread类中有一个成员变量\n\t\t//What will be run\n\t\tprivate Runnable target; \n\t\t\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif (target != null) {\n\t\t\t\ttarget.run();\n\t\t\t}\n\t\t}\n\t\t*/\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n"]],[6750,6750],[5068,5068]]],[1563933738388,["GJX@GJXAIOU",[[1,5068,"```"]],[5068,5068],[5071,5071]]],[1563933738419,["GJX@GJXAIOU",[[1,5071,"language\n```\n"]],[5071,5071],[5071,5079]]],[1563933739245,["GJX@GJXAIOU",[[-1,5071,"language"],[1,5079,"j"]],[5071,5079],[5072,5072]]],[1563933740108,["GJX@GJXAIOU",[[1,5072,"ava"]],[5072,5072],[5075,5075]]],[1563933740427,["GJX@GJXAIOU",[[1,5076,"\n"]],[5075,5075],[5076,5076]]],[1563933741540,["GJX@GJXAIOU",[[1,5076,"package com.qfedu.a_thread;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n/*\n\tJava语言是一种单继承，多实现【遵从】面向对象的语言\n\t\n\t自定义线程的方式：\n\t\t方式1：\n\t\t\t1. 自定义一个类，继承Thread类\n\t\t\t2. 重写Thread里面的run方法，把线程的功能代码放入到run方法中\n\t\t\t3. 创建自定义线程类对象\n\t\t\t4. 开启线程，使用start方法\n\t\t\n\t\t弊端：\n\t\t\t因为Java是一个单继承的语言，一旦某一个类继承了Thread类，就无法再继承其他类，或者说\n\t\t\t一个类继承了其他类，也就没有办法继承Thread类\n\t\t\n\t\t方式2: 【墙裂推荐】\n\t\t\t【遵从】Runnable接口实现自定线程类\n\t\t\t1. 自定义一个类，【遵从】Runnable接口\n\t\t\t2. 实现Runnable接口中唯一要求的方法 Run方法，把线程的功能代码写入到run方法中\n\t\t\t3. 创建Thread类对象，并且把【遵从】Runnable接口的自定义类对象，作为参数传入到\n\t\t\tThread构造方法中\n\t\t\t4. 调用Thread类对象的start方法，开启线程\n */\n\nclass TestRunnable implements Runnable {\n\n\t//实现自定义线程类，遵从Runnable接口要求实现的Run方法，把线程代码写入到Runnable里面\n\t@Override\n\tpublic void run() {\n\t\tfor (int i = 0 ; i < 10; i++) {\n\t\t\tSystem.out.println(\"当前线程为:\" + Thread.currentThread());\n\t\t}\n\t}\t\n}\n\npublic class Demo5 {\n\tpublic static <T> void main(String[] args) {\n\t\t//创建Thread类对象，调用Thread构造方法中，需要传入Runnable接口实现类对象的方法~\n\t\tThread t1 = new Thread(new TestRunnable());\n\t\t\n//\t\tArrays.sort(a, new Comparator<String>() {\n//\n//\t\t\t@Override\n//\t\t\tpublic int compare(String o1, String o2) {\n//\t\t\t\t// TODO Auto-generated method stub\n//\t\t\t\treturn 0;\n//\t\t\t}\n//\t\t});\n\t\t\n\t\tThread t2 = new Thread(new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tSystem.out.println(\"匿名内部类的匿名对象，作为方法的参数，这里是作为线程对象的参数\" + \n\t\t\t\t\t\t\tThread.currentThread());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tt1.start();\n\t\tt2.start();\n\t\t\n\t\t/*\n\t\ttarget是在创建Thread类对象时候，传入的【遵从】Runnable接口的实现类，这个实现类中\n\t\t实现类【遵从】Runnable接口要求实现的run方法，在run方法中，就是定义的线程代码\n\t\t在Thread类中有一个成员变量\n\t\t//What will be run\n\t\tprivate Runnable target; \n\t\t\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif (target != null) {\n\t\t\t\ttarget.run();\n\t\t\t}\n\t\t}\n\t\t*/\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n"]],[5076,5076],[6758,6758]]],[1563933747573,["GJX@GJXAIOU",[[-1,5160,"/*\n\tJava语言是一种单继承，多实现【遵从】面向对象的语言\n\t\n\t自定义线程的方式：\n\t\t方式1：\n\t\t\t1. 自定义一个类，继承Thread类\n\t\t\t2. 重写Thread里面的run方法，把线程的功能代码放入到run方法中\n\t\t\t3. 创建自定义线程类对象\n\t\t\t4. 开启线程，使用start方法\n\t\t\n\t\t弊端：\n\t\t\t因为Java是一个单继承的语言，一旦某一个类继承了Thread类，就无法再继承其他类，或者说\n\t\t\t一个类继承了其他类，也就没有办法继承Thread类\n\t\t\n\t\t方式2: 【墙裂推荐】\n\t\t\t【遵从】Runnable接口实现自定线程类\n\t\t\t1. 自定义一个类，【遵从】Runnable接口\n\t\t\t2. 实现Runnable接口中唯一要求的方法 Run方法，把线程的功能代码写入到run方法中\n\t\t\t3. 创建Thread类对象，并且把【遵从】Runnable接口的自定义类对象，作为参数传入到\n\t\t\tThread构造方法中\n\t\t\t4. 调用Thread类对象的start方法，开启线程\n */"]],[5160,5623],[5160,5160]]],[1563933751251,["GJX@GJXAIOU",[[1,5068,"\n"]],[5067,5067],[5068,5068]]],[1563933751363,["GJX@GJXAIOU",[[1,5069,"\n"]],[5068,5068],[5069,5069]]],[1563933751789,["GJX@GJXAIOU",[[1,5069,"/*\n\tJava语言是一种单继承，多实现【遵从】面向对象的语言\n\t\n\t自定义线程的方式：\n\t\t方式1：\n\t\t\t1. 自定义一个类，继承Thread类\n\t\t\t2. 重写Thread里面的run方法，把线程的功能代码放入到run方法中\n\t\t\t3. 创建自定义线程类对象\n\t\t\t4. 开启线程，使用start方法\n\t\t\n\t\t弊端：\n\t\t\t因为Java是一个单继承的语言，一旦某一个类继承了Thread类，就无法再继承其他类，或者说\n\t\t\t一个类继承了其他类，也就没有办法继承Thread类\n\t\t\n\t\t方式2: 【墙裂推荐】\n\t\t\t【遵从】Runnable接口实现自定线程类\n\t\t\t1. 自定义一个类，【遵从】Runnable接口\n\t\t\t2. 实现Runnable接口中唯一要求的方法 Run方法，把线程的功能代码写入到run方法中\n\t\t\t3. 创建Thread类对象，并且把【遵从】Runnable接口的自定义类对象，作为参数传入到\n\t\t\tThread构造方法中\n\t\t\t4. 调用Thread类对象的start方法，开启线程\n */"]],[5069,5069],[5532,5532]]],[1563933753964,["GJX@GJXAIOU",[[-1,5069,"/*"]],[5069,5071],[5069,5069]]],[1563933757870,["GJX@GJXAIOU",[[-1,5070,"\t"],[-1,5099,"\t"],[-1,5101,"\t"],[-1,5113,"\t"],[-1,5119,"\t"],[-1,5144,"\t"],[-1,5185,"\t"],[-1,5200,"\t"],[-1,5222,"\t"],[-1,5224,"\t"],[-1,5232,"\t"],[-1,5282,"\t"],[-1,5310,"\t"],[-1,5312,"\t"],[-1,5326,"\t"],[-1,5353,"\t"],[-1,5379,"\t"],[-1,5430,"\t"],[-1,5483,"\t"],[-1,5496,"\t"]],[5071,5526],[5070,5506]]],[1563933758541,["GJX@GJXAIOU",[[-1,5109,"\t"],[-1,5115,"\t"],[-1,5137,"\t"],[-1,5178,"\t"],[-1,5193,"\t"],[-1,5213,"\t"],[-1,5215,"\t"],[-1,5220,"\t"],[-1,5269,"\t"],[-1,5297,"\t"],[-1,5299,"\t"],[-1,5312,"\t"],[-1,5336,"\t"],[-1,5364,"\t"],[-1,5413,"\t"],[-1,5464,"\t"],[-1,5477,"\t"]],[5070,5506],[5070,5489]]],[1563933761902,["GJX@GJXAIOU",[[-1,5490," */"]],[5490,5493],[5490,5490]]],[1563933767002,["GJX@GJXAIOU",[[1,5063,"\n"]],[5062,5062],[5063,5063]]],[1563933769010,["GJX@GJXAIOU",[[-1,5070,"\n"]],[5070,5070],[5069,5069]]],[1563933769154,["GJX@GJXAIOU",[[-1,5069,"\n"]],[5069,5069],[5068,5068]]],[1563933821573,["GJX@GJXAIOU",[[-1,5447,"\t"]],[5448,5448],[5447,5447]]],[1563933821841,["GJX@GJXAIOU",[[-1,5446,"\n"]],[5447,5447],[5446,5446]]],[1563934090790,["GJX@GJXAIOU",[[1,5979,"//匿名对象"]],[5979,5979],[5985,5985]]],[1563934094134,["GJX@GJXAIOU",[[1,6217," 、、"]],[6217,6217],[6220,6220]]],[1563934094714,["GJX@GJXAIOU",[[-1,6218,"、、"]],[6220,6220],[6218,6218]]],[1563934107542,["GJX@GJXAIOU",[[1,6218,"//匿名内部类的匿名对象，不在需要上面的 "]],[6218,6218],[6239,6239]]],[1563934121822,["GJX@GJXAIOU",[[1,6238,"Test"]],[6238,6238],[6242,6242]]],[1563934130157,["GJX@GJXAIOU",[[1,6242,"Runnable方法"]],[6242,6242],[6252,6252]]],[1563934133330,["GJX@GJXAIOU",[[-1,6232,"在"]],[6233,6233],[6232,6232]]],[1563934135141,["GJX@GJXAIOU",[[1,6232,"再"]],[6232,6232],[6233,6233]]],[1563934141546,["GJX@GJXAIOU",[[-1,6250,"方法"]],[6252,6252],[6250,6250]]],[1563934144823,["GJX@GJXAIOU",[[1,6250,"类"]],[6250,6250],[6251,6251]]],[1563934149931,["GJX@GJXAIOU",[[1,6235,"定义"]],[6235,6235],[6237,6237]]],[1563934185530,["GJX@GJXAIOU",[[-1,5986,"\t\t"],[1,5988,"\n"]],[5988,5988],[5987,5987]]],[1563934186448,["GJX@GJXAIOU",[[1,5987,"、、"]],[5987,5987],[5989,5989]]],[1563934187211,["GJX@GJXAIOU",[[-1,5987,"、、"]],[5989,5989],[5987,5987]]],[1563934200822,["GJX@GJXAIOU",[[1,5987,"        //其他常见的匿名内部类的匿名对象"]],[5987,5987],[6012,6012]]],[1563936062432,["GJX@GJXAIOU",[[-1,6782,"\n"]],[6782,6782],[6781,6781]]],[1563936062586,["GJX@GJXAIOU",[[-1,6781,"\n"]],[6781,6781],[6780,6780]]],[1563936062729,["GJX@GJXAIOU",[[-1,6780,"\n"]],[6780,6780],[6779,6779]]],[1563936062963,["GJX@GJXAIOU",[[-1,6779,"\n"]],[6779,6779],[6778,6778]]],[1563936063105,["GJX@GJXAIOU",[[-1,6778,"\n"]],[6778,6778],[6777,6777]]],[1563936063215,["GJX@GJXAIOU",[[-1,6777,"\n"]],[6777,6777],[6776,6776]]],[1563936063344,["GJX@GJXAIOU",[[-1,6776,"\n"]],[6776,6776],[6775,6775]]],[1563936063471,["GJX@GJXAIOU",[[-1,6775,"\n"]],[6775,6775],[6774,6774]]],[1563936063607,["GJX@GJXAIOU",[[-1,6774,"\n"]],[6774,6774],[6773,6773]]],[1563936063776,["GJX@GJXAIOU",[[-1,6773,"\n"]],[6773,6773],[6772,6772]]],[1563936063977,["GJX@GJXAIOU",[[-1,6772,"\n"]],[6772,6772],[6771,6771]]],[1563936064368,["GJX@GJXAIOU",[[-1,6771,"\n"]],[6771,6771],[6770,6770]]],[1563936300713,["GJX@GJXAIOU",[[1,6777,"\n"]],[6775,6775],[6776,6776]]],[1563936316374,["GJX@GJXAIOU",[[1,6776,"package com.qfedu.a_thread;\n\n/*\n 守护线程(后台线程) \n \t例如：\n \t\t软件的Log日志文件，软件的自动更新，软件的自动下载\n \t\t\n \t特征：\n \t\t如果整个程序再运行过程中，只剩下一个守护线程，那么这个守护线程也就没有意义了，会自动停止\n \t\n \tJVM的垃圾回收机制是守护线程还是普通线程？？？\n \t\n \t\t守护线程！！！\n */\n\npublic class Demo6 extends Thread {\n\t\n\tpublic Demo6(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t//模拟后台下载更新的线程\n\t@Override\n\tpublic void run() {\n\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\tSystem.out.println(\"软件更新下载中………………\" + i + \"%\");\n\t\t\t\n\t\t\tif (i == 100) {\n\t\t\t\tSystem.out.println(\"软件更新下载完成，是否安装~~\");\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tThread.sleep(10);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tDemo6 d = new Demo6(\"后台线程\");\n\t\t\n\t\t//设置当前线程为守护线程或者是后台线程\n\t\td.setDaemon(true);\n\t\t\n\t\t//System.out.println(d.isDaemon());\n\t\td.start();\n\t\tfor (int i = 0; i <= 50; i++) {\n\t\t\tThread.sleep(10);\n\t\t\tSystem.out.println(\"主线程:\" + i);\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[6776,6776],[7722,7722]]],[1563936317558,["GJX@GJXAIOU",[[-1,6776,"package com.qfedu.a_thread;\n\n/*\n 守护线程(后台线程) \n \t例如：\n \t\t软件的Log日志文件，软件的自动更新，软件的自动下载\n \t\t\n \t特征：\n \t\t如果整个程序再运行过程中，只剩下一个守护线程，那么这个守护线程也就没有意义了，会自动停止\n \t\n \tJVM的垃圾回收机制是守护线程还是普通线程？？？\n \t\n \t\t守护线程！！！\n */\n\npublic class Demo6 extends Thread {\n\t\n\tpublic Demo6(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t//模拟后台下载更新的线程\n\t@Override\n\tpublic void run() {\n\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\tSystem.out.println(\"软件更新下载中………………\" + i + \"%\");\n\t\t\t\n\t\t\tif (i == 100) {\n\t\t\t\tSystem.out.println(\"软件更新下载完成，是否安装~~\");\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tThread.sleep(10);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tDemo6 d = new Demo6(\"后台线程\");\n\t\t\n\t\t//设置当前线程为守护线程或者是后台线程\n\t\td.setDaemon(true);\n\t\t\n\t\t//System.out.println(d.isDaemon());\n\t\td.start();\n\t\tfor (int i = 0; i <= 50; i++) {\n\t\t\tThread.sleep(10);\n\t\t\tSystem.out.println(\"主线程:\" + i);\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[7722,7722],[6776,6776]]],[1563936319211,["GJX@GJXAIOU",[[1,6776,"··"]],[6776,6776],[6778,6778]]],[1563936320336,["GJX@GJXAIOU",[[-1,6776,"··"]],[6778,6778],[6776,6776]]],[1563936321655,["GJX@GJXAIOU",[[1,6776,"```"]],[6776,6776],[6779,6779]]],[1563936321689,["GJX@GJXAIOU",[[1,6779,"language\n```\n"]],[6779,6779],[6779,6787]]],[1563936322769,["GJX@GJXAIOU",[[-1,6779,"language"],[1,6787,"j"]],[6779,6787],[6780,6780]]],[1563936323209,["GJX@GJXAIOU",[[1,6780,"ava"]],[6780,6780],[6783,6783]]],[1563936323338,["GJX@GJXAIOU",[[1,6784,"\n"]],[6783,6783],[6784,6784]]],[1563936325767,["GJX@GJXAIOU",[[1,6784,"package com.qfedu.a_thread;\n\n/*\n 守护线程(后台线程) \n \t例如：\n \t\t软件的Log日志文件，软件的自动更新，软件的自动下载\n \t\t\n \t特征：\n \t\t如果整个程序再运行过程中，只剩下一个守护线程，那么这个守护线程也就没有意义了，会自动停止\n \t\n \tJVM的垃圾回收机制是守护线程还是普通线程？？？\n \t\n \t\t守护线程！！！\n */\n\npublic class Demo6 extends Thread {\n\t\n\tpublic Demo6(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t//模拟后台下载更新的线程\n\t@Override\n\tpublic void run() {\n\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\tSystem.out.println(\"软件更新下载中………………\" + i + \"%\");\n\t\t\t\n\t\t\tif (i == 100) {\n\t\t\t\tSystem.out.println(\"软件更新下载完成，是否安装~~\");\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tThread.sleep(10);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tDemo6 d = new Demo6(\"后台线程\");\n\t\t\n\t\t//设置当前线程为守护线程或者是后台线程\n\t\td.setDaemon(true);\n\t\t\n\t\t//System.out.println(d.isDaemon());\n\t\td.start();\n\t\tfor (int i = 0; i <= 50; i++) {\n\t\t\tThread.sleep(10);\n\t\t\tSystem.out.println(\"主线程:\" + i);\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[6784,6784],[7730,7730]]],[1563936329798,["GJX@GJXAIOU",[[-1,6816," 守护线程(后台线程) "]],[6816,6828],[6816,6816]]],[1563936331462,["GJX@GJXAIOU",[[1,6776,"\n"]],[6775,6775],[6776,6776]]],[1563936334912,["GJX@GJXAIOU",[[1,6776,"##  守护线程(后台线程) "]],[6776,6776],[6791,6791]]],[1563936342215,["GJX@GJXAIOU",[[-1,6829,"/*\n\n \t例如：\n \t\t软件的Log日志文件，软件的自动更新，软件的自动下载\n \t\t\n \t特征：\n \t\t如果整个程序再运行过程中，只剩下一个守护线程，那么这个守护线程也就没有意义了，会自动停止\n \t\n \tJVM的垃圾回收机制是守护线程还是普通线程？？？\n \t\n \t\t守护线程！！！\n */\n"]],[6832,6974],[6828,6828]]],[1563936343993,["GJX@GJXAIOU",[[1,6792,"\n"]],[6791,6791],[6792,6792]]],[1563936344374,["GJX@GJXAIOU",[[1,6793," \t例如：\n \t\t软件的Log日志文件，软件的自动更新，软件的自动下载\n \t\t\n \t特征：\n \t\t如果整个程序再运行过程中，只剩下一个守护线程，那么这个守护线程也就没有意义了，会自动停止\n \t\n \tJVM的垃圾回收机制是守护线程还是普通线程？？？\n \t\n \t\t守护线程！！！\n */\n"]],[6792,6792],[6934,6934]]],[1563936348014,["GJX@GJXAIOU",[[-1,6793," \t"],[-1,6799," \t\t"],[-1,6829," \t\t"],[-1,6833," \t"],[-1,6839," \t\t"],[-1,6887," \t"],[-1,6890," \t"],[-1,6917," \t"],[-1,6920," \t\t"]],[6794,6930],[6794,6930]]],[1563936350766,["GJX@GJXAIOU",[[-1,6910,"*/"]],[6912,6912],[6910,6910]]],[1563936366208,["GJX@GJXAIOU",[[1,5068,"zi"]],[5068,5068],[5070,5070]]],[1563936367461,["GJX@GJXAIOU",[[-1,5068,"zi"]],[5070,5070],[5068,5068]]],[1563936371901,["GJX@GJXAIOU",[[1,5068,"自定义线程"]],[5068,5068],[5073,5073]]],[1563936474863,["GJX@GJXAIOU",[[-1,6895,"还是普通线程？？？"]],[6895,6904],[6895,6895]]],[1563936477502,["GJX@GJXAIOU",[[-1,6897,"守护线程！！！"]],[6897,6904],[6897,6897]]],[1563936477830,["GJX@GJXAIOU",[[-1,6897,"\n"]],[6897,6897],[6896,6896]]],[1563936478271,["GJX@GJXAIOU",[[-1,6896,"\n"]],[6896,6896],[6895,6895]]],[1563936481114,["GJX@GJXAIOU",[[1,6895,"。"]],[6895,6895],[6896,6896]]],[1563936524321,["GJX@GJXAIOU",[[-1,6936,"\n"]],[6936,6936],[6935,6935]]],[1563937090216,["GJX@GJXAIOU",[[1,7524,"、、"]],[7524,7524],[7526,7526]]],[1563937090840,["GJX@GJXAIOU",[[-1,7524,"、、"]],[7526,7526],[7524,7524]]],[1563937099592,["GJX@GJXAIOU",[[1,7524,"//true为守护线程"]],[7524,7524],[7535,7535]]],[1563937188166,["GJX@GJXAIOU",[[-1,6897," "],[1,6898,"\n"]],[6898,6898],[6898,6898]]],[1563937208420,["GJX@GJXAIOU",[[1,6898,"这里当主线程停止，则下载也会"]],[6898,6898],[6912,6912]]],[1563937212545,["GJX@GJXAIOU",[[1,6912,"自动停止；"]],[6912,6912],[6917,6917]]],[1563937217551,["GJX@GJXAIOU",[[-1,7724,"\n"]],[7724,7724],[7723,7723]]],[1563937217669,["GJX@GJXAIOU",[[-1,7723,"\n"]],[7723,7723],[7722,7722]]],[1563937217837,["GJX@GJXAIOU",[[-1,7722,"\n"]],[7722,7722],[7721,7721]]],[1563937218013,["GJX@GJXAIOU",[[-1,7721,"\n"]],[7721,7721],[7720,7720]]],[1563937218165,["GJX@GJXAIOU",[[-1,7720,"\n"]],[7720,7720],[7719,7719]]],[1563937218389,["GJX@GJXAIOU",[[-1,7719,"\n"]],[7719,7719],[7718,7718]]],[1563937218542,["GJX@GJXAIOU",[[-1,7718,"\n"]],[7718,7718],[7717,7717]]],[1563937218680,["GJX@GJXAIOU",[[-1,7717,"\n"]],[7717,7717],[7716,7716]]],[1563937218949,["GJX@GJXAIOU",[[-1,7716,"\n"]],[7716,7716],[7715,7715]]],[1563937219126,["GJX@GJXAIOU",[[-1,7715,"\n"]],[7715,7715],[7714,7714]]],[1563937219293,["GJX@GJXAIOU",[[-1,7714,"\n"]],[7714,7714],[7713,7713]]],[1563937219480,["GJX@GJXAIOU",[[-1,7713,"\n"]],[7713,7713],[7712,7712]]],[1563937219670,["GJX@GJXAIOU",[[-1,7712,"\n"]],[7712,7712],[7711,7711]]],[1563937220071,["GJX@GJXAIOU",[[-1,7711,"\n"]],[7711,7711],[7710,7710]]],[1563937220471,["GJX@GJXAIOU",[[-1,7710,"\n"]],[7710,7710],[7709,7709]]],[1563937220680,["GJX@GJXAIOU",[[-1,7709,"\n"]],[7709,7709],[7708,7708]]],[1563937221078,["GJX@GJXAIOU",[[-1,7708,"\n"]],[7708,7708],[7707,7707]]],[1563937253570,["GJX@GJXAIOU",[[1,7713,"### 线程通讯"]],[7713,7713],[7721,7721]]],[1563937254478,["GJX@GJXAIOU",[[1,7722,"\n"]],[7721,7721],[7722,7722]]],[1563937269149,["GJX@GJXAIOU",[[1,7722,"线程通讯:\n  \t一个线程完成任务之后，通知另一个线程来完成该线程应该执行的任务\n  \t\n 生产者和消费者问题\t\n \t这里商品是两个线程直接的共享资源\n \n wait(); 等待，如果一个线程执行了wait方法，那么这个线程就会进入临时阻塞状态，等待唤醒，这个唤醒必须\n \t\t其他线程调用notify() 方法唤醒\n notify(); 唤醒，唤醒线程池中进入【临时阻塞状态】的一个线程\n \n \t注意事项：\n \t\t1. wait()和notify()这两个方法都是Object类的方法"]],[7722,7722],[7964,7964]]],[1563937270141,["GJX@GJXAIOU",[[1,7965," \t\t2. \n"]],[7964,7964],[7971,7971]]],[1563937272373,["GJX@GJXAIOU",[[-1,7965," \t\t2. \n"]],[7971,7971],[7964,7964]]],[1563937274292,["GJX@GJXAIOU",[[1,7965," \t\t2. \n"]],[7964,7964],[7971,7971]]],[1563937274446,["GJX@GJXAIOU",[[-1,7965," \t\t2. "]],[7971,7971],[7966,7966]]],[1563937274614,["GJX@GJXAIOU",[[1,7966,"\n"]],[7966,7966],[7967,7967]]],[1563937276112,["GJX@GJXAIOU",[[-1,7966,"\n"],[1,7967,"`"]],[7967,7967],[7967,7967]]],[1563937276918,["GJX@GJXAIOU",[[1,7967,"``"]],[7967,7967],[7969,7969]]],[1563937276952,["GJX@GJXAIOU",[[1,7969,"language\n```\n"]],[7969,7969],[7969,7977]]],[1563937277374,["GJX@GJXAIOU",[[-1,7969,"language"],[1,7977,"j"]],[7969,7977],[7970,7970]]],[1563937278369,["GJX@GJXAIOU",[[1,7970,"ava"]],[7970,7970],[7973,7973]]],[1563937278559,["GJX@GJXAIOU",[[1,7974,"\n"]],[7973,7973],[7974,7974]]],[1563937285335,["GJX@GJXAIOU",[[1,7974,"package com.qfedu.a_thread;\n\n/*\n 线程通讯:\n  \t一个线程完成任务之后，通知另一个线程来完成该线程应该执行的任务\n  \t\n 生产者和消费者问题\t\n \t这里商品是两个线程直接的共享资源\n \n wait(); 等待，如果一个线程执行了wait方法，那么这个线程就会进入临时阻塞状态，等待唤醒，这个唤醒必须\n \t\t其他线程调用notify() 方法唤醒\n notify(); 唤醒，唤醒线程池中进入【临时阻塞状态】的一个线程\n \n \t注意事项：\n \t\t1. wait()和notify()这两个方法都是Object类的方法\n */\n\nclass Product {\n\tString name; //商品的名字\n\tint price; //价格\n\t\n\tboolean flag = false; //产品是否生产成功，如果成功flag设置为true，消费者购买之后，设置为false\n}\n\nclass Producer extends Thread {\n\tProduct p;  //商品的类对象，是和消费者之间的共享资源\n\t\n\tpublic Producer(Product p) {\n\t\tthis.p = p;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tint count = 0;\n\t\twhile (true) {\n\t\t\tsynchronized (p) {\n\t\t\t\ttry {\n\t\t\t\t\tsleep(100);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (!p.flag) { //p.flag == false\n\t\t\t\t\t\n\t\t\t\t\t//商品不存在，生产过程\n\t\t\t\t\tif (count % 2 == 0) {\n\t\t\t\t\t\tp.name = \"红辣椒擀面皮\";\n\t\t\t\t\t\tp.price = 5;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp.name = \"唐风阁肉夹馍\";\n\t\t\t\t\t\tp.price = 10;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcount++;\n\t\t\t\t\tSystem.out.println(\"生产者生产了:\" + p.name + \":\" + p.price);\n\t\t\t\t\tp.flag = true;\n\t\t\t\t\t//生产结束，唤醒消费者\n\t\t\t\t\tp.notify();\n\t\t\t\t} else {\n\t\t\t\t\t//商品存在，要求消费者来购买，生产者进入临时阻塞\n\t\t\t\t\ttry {\n\t\t\t\t\t\tp.wait();\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t} // try - catch\n\t\t\t\t}// if - else\n\t\t\t} // 同步代码块\n\t\t}// while (true)\n\t} //run()\n}\n\nclass Customer extends Thread {\n\tProduct p; //商品类对象，是和生产者之间的共享资源\n\t\n\tpublic Customer(Product p) {\n\t\tthis.p = p;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tsynchronized (p) {\n\t\t\t\ttry {\n\t\t\t\t\tsleep(100);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (p.flag) { //p.flag == true \n\t\t\t\t\t//这里表示商品存在\n\t\t\t\t\tSystem.out.println(\"消费者购买了:\" + p.name + \":\" + p.price);\n\t\t\t\t\t\n\t\t\t\t\tp.flag = false; //表示消费者购买完毕，要求生产者生产\n\t\t\t\t\t//需要唤醒生产者\n\t\t\t\t\tp.notify();\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//商品不存在，消费者进入临时阻塞\n\t\t\t\t\t\tp.wait();\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t} // try - catch\n\t\t\t\t}// if - else \n\t\t\t} //同步代码块\n\t\t} // while (true)\n\t} //run()\n}\n\npublic class Demo7 {\n\tpublic static void main(String[] args) {\n\t\tProduct product = new Product();\n\t\t\n\t\tProducer p = new Producer(product);\n\t\tCustomer c = new Customer(product);\n\t\t\n\t\tp.start();\n\t\tc.start();\n\t}\n}\n"]],[7974,7974],[10314,10314]]],[1563937289574,["GJX@GJXAIOU",[[-1,8003,"/*\n 线程通讯:\n  \t一个线程完成任务之后，通知另一个线程来完成该线程应该执行的任务\n  \t\n 生产者和消费者问题\t\n \t这里商品是两个线程直接的共享资源\n \n wait(); 等待，如果一个线程执行了wait方法，那么这个线程就会进入临时阻塞状态，等待唤醒，这个唤醒必须\n \t\t其他线程调用notify() 方法唤醒\n notify(); 唤醒，唤醒线程池中进入【临时阻塞状态】的一个线程\n \n \t注意事项：\n \t\t1. wait()和notify()这两个方法都是Object类的方法\n */"]],[8003,8253],[8003,8003]]],[1563937290172,["GJX@GJXAIOU",[[-1,8004,"\n"]],[8003,8003],[8002,8002]]],[1563937290637,["GJX@GJXAIOU",[[-1,8003,"\n"]],[8002,8002],[8001,8001]]],[1563937320702,["GJX@GJXAIOU",[[-1,7728,"  "],[-1,7763,"  "],[-1,7767," "],[-1,7779," \t"],[-1,7798," "],[-1,7800," "],[-1,7857," \t\t"],[-1,7880," "],[-1,7916," "],[-1,7918," \t"],[-1,7926," \t\t"]],[7722,7964],[7722,7960]]],[1563937328287,["GJX@GJXAIOU",[[1,7722,"- "]],[7722,7722],[7724,7724]]],[1563937333847,["GJX@GJXAIOU",[[1,7906,"- "]],[7906,7906],[7908,7908]]],[1563937354300,["GJX@GJXAIOU",[[-1,7775,"\n"]],[7776,7776],[7775,7775]]],[1563937355462,["GJX@GJXAIOU",[[-1,7774,"\t"]],[7775,7775],[7774,7774]]],[1563937356863,["GJX@GJXAIOU",[[1,7774,":"]],[7774,7774],[7775,7775]]],[1563937367060,["GJX@GJXAIOU",[[-1,7848,"\n"]],[7849,7849],[7848,7848]]],[1563937370568,["GJX@GJXAIOU",[[1,7867,";"]],[7867,7867],[7868,7868]]],[1563937713598,["GJX@GJXAIOU",[[1,7987,"\n"]],[7986,7986],[7987,7987]]],[1563937721650,["GJX@GJXAIOU",[[1,7987,"//两者之间的共享资源"]],[7987,7987],[7998,7998]]],[1563938066452,["GJX@GJXAIOU",[[-1,8398,"\t\t\t\t\t// TODO Auto-generated catch block"]],[8398,8437],[8398,8398]]],[1563938066916,["GJX@GJXAIOU",[[-1,8398,"\n"]],[8398,8398],[8397,8397]]],[1563938716599,["GJX@GJXAIOU",[[1,9546," 、、"]],[9546,9546],[9549,9549]]],[1563938717251,["GJX@GJXAIOU",[[-1,9547,"、、"]],[9549,9549],[9547,9547]]],[1563938723585,["GJX@GJXAIOU",[[1,9547,"//打开线程锁"]],[9547,9547],[9554,9554]]],[1563938886123,["GJX@GJXAIOU",[[1,20,"\n"]],[19,19],[20,20]]],[1563938887654,["GJX@GJXAIOU",[[1,20,"#"]],[20,20],[21,21]]],[1563938888156,["GJX@GJXAIOU",[[-1,20,"#"]],[21,21],[20,20]]],[1563938888798,["GJX@GJXAIOU",[[1,20,"@"]],[20,20],[21,21]]],[1563938892463,["GJX@GJXAIOU",[[1,21,"toc"]],[21,21],[24,24]]],[1563938893956,["GJX@GJXAIOU",[[1,25,"\n"]],[24,24],[25,25]]],[1563938896091,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1563938902431,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1563938902589,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1563938902733,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1563938902768,["GJX@GJXAIOU",[[1,4,"\n---\n\n"]],[3,3],[4,4]]],[1563938907948,["GJX@GJXAIOU",[[1,4,"tah"]],[4,4],[7,7]]],[1563938908660,["GJX@GJXAIOU",[[-1,6,"h"]],[7,7],[6,6]]],[1563938910103,["GJX@GJXAIOU",[[1,6,"gs: "]],[6,6],[10,10]]],[1563938910811,["GJX@GJXAIOU",[[1,11,"\n"]],[10,10],[11,11]]],[1563938912167,["GJX@GJXAIOU",[[1,11,"- jinc"]],[11,11],[17,17]]],[1563938913245,["GJX@GJXAIOU",[[-1,13,"jinc"]],[17,17],[13,13]]],[1563938916327,["GJX@GJXAIOU",[[1,13,"进程"]],[13,13],[15,15]]],[1563938916580,["GJX@GJXAIOU",[[1,16,"\n"]],[15,15],[16,16]]],[1563938918863,["GJX@GJXAIOU",[[1,16,"- 线性"]],[16,16],[20,20]]],[1563938919427,["GJX@GJXAIOU",[[-1,18,"线性"]],[20,20],[18,18]]],[1563938921078,["GJX@GJXAIOU",[[1,18,"线程"]],[18,18],[20,20]]],[1563950407150,["GJX@GJXAIOU",[[1,10063,"\n"]],[10062,10062],[10063,10063]]],[1563950407463,["GJX@GJXAIOU",[[1,10064,"\n"]],[10063,10063],[10064,10064]]],[1563950407697,["GJX@GJXAIOU",[[1,10065,"\n"]],[10064,10064],[10065,10065]]],[1563950408136,["GJX@GJXAIOU",[[1,10066,"\n"]],[10065,10065],[10066,10066]]],[1563950664323,["GJX@GJXAIOU",[[1,7981,"2. zai "]],[7981,7981],[7988,7988]]],[1563950665502,["GJX@GJXAIOU",[[-1,7984,"zai "]],[7988,7988],[7984,7984]]],[1563950668498,["GJX@GJXAIOU",[[1,7984,"在小肥猪"]],[7984,7984],[7988,7988]]],[1563950669637,["GJX@GJXAIOU",[[-1,7985,"小肥猪"]],[7988,7988],[7985,7985]]],[1563950687136,["GJX@GJXAIOU",[[1,7985,"消费者生产者模式下，锁对象只能是商品；"]],[7985,7985],[8004,8004]]],[1563950964504,["GJX@GJXAIOU",[[-1,36,"5"]],[35,37],[36,36]]],[1563950964862,["GJX@GJXAIOU",[[1,36,"4 "]],[36,36],[37,37]]],[1563972771616,["GJX@GJXAIOU",[[-1,130,"  "]],[132,132],[130,130]]],[1563972772046,["GJX@GJXAIOU",[[-1,129,"\n"]],[130,130],[129,129]]],[1563972773626,["GJX@GJXAIOU",[[1,129,"与"]],[129,129],[130,130]]],[1563972780454,["GJX@GJXAIOU",[[-1,129,"与小芳"]],[132,132],[129,129]]],[1563972782966,["GJX@GJXAIOU",[[-1,132,"小红"]],[134,134],[132,132]]],[1563973538219,["GJX@GJXAIOU",[[-1,75,"com.qfedu.a_thread;\n"],[1,95,"DemoDay24;   "],[1,112,"jupiter.api."],[-1,117,"\n\n/*\n"],[1,122," "],[1,124,"/**使"],[1,127,"实现"],[-1,132,"聊天 \n */\n"],[1,140,"语音\n  * @author GJXAIOU\n * @create 2019-07-24-20:54\n */   "],[-1,172," "],[-1,175,"\t"],[1,176,"    "],[-1,186,"\t"],[1,187,"  "],[-1,207,"\t\t"],[1,209,"        "],[-1,229,"100"],[1,232,"5"],[-1,241,"\t\t\t"],[1,244,"            "],[-1,264,"和小芳"],[-1,270,"………………"],[1,276,"。。。。。"],[-1,280,"\t\t"],[1,282,"  "],[-1,284,"\t}"],[1,287,"    "],[1,289,"}"],[-1,296,"Chat"],[1,300,"Audio"],[-1,321," "],[-1,324,"\t"],[1,325,"    "],[-1,335,"\t"],[1,336,"  "],[-1,356,"\t\t"],[1,358,"        "],[-1,378,"100"],[1,381,"5"],[-1,390,"\t\t\t"],[1,393,"            "],[-1,413,"和小红聊天中~~~~~"],[1,424,"语音中。。。。。"],[-1,428,"\t\t}\n\t"],[1,433,"  }\n\n    "],[-1,436,"\t"],[1,460,"\n"],[-1,466,"直接测试就行，在test1方法名上右击，run as j"],[1,494,"方法一：使用main函数进行调试 //    public static void main(String[] args) { //        VideoThread videoThread = new VideoThread(); //        AudioThread audioThread = new AudioThread(); // //        videoThread.start(); //        audioThread.start(); //    }   //方法二：使用J"],[-1,498,"\n\t"],[1,500,"中@test进行调试\n  "],[-1,505," //注解\n\t"],[1,512,"\n  "],[-1,528,"1"],[-1,531," "],[-1,534,"\t\t"],[1,536,"        "],[-1,549,"t"],[1,550,"ideoThread"],[-1,572,"\t\tChat"],[1,578,"  AudioThread audio"],[-1,585,"ct "],[-1,594,"Chat"],[1,598,"Audio"],[-1,607,"\n\t\t\n\t\tvt"],[1,615,"    videoThread"],[-1,625,"\t\tct"],[1,629,"  audioThread"],[-1,639,"\t}"],[1,641,"  }\n"]],[67,643],[1011,1011]]],[1563973540472,["GJX@GJXAIOU",[[1,75,"com.qfedu.a_thread;\n"],[-1,75,"DemoDay24;   "],[-1,105,"jupiter.api."],[1,122,"\n\n/*\n"],[-1,122," "],[-1,125,"/**使"],[-1,132,"实现"],[1,139,"聊天 \n */\n"],[-1,139,"语音\n  * @author GJXAIOU\n * @create 2019-07-24-20:54\n */   "],[1,228," "],[1,230,"\t"],[-1,230,"    "],[1,244,"\t"],[-1,244,"  "],[1,266,"\t\t"],[-1,266,"        "],[1,294,"100"],[-1,294,"5"],[1,304,"\t\t\t"],[-1,304,"            "],[1,336,"和小芳"],[1,339,"………………"],[-1,339,"。。。。。"],[1,348,"\t\t"],[-1,348,"  "],[1,352,"\t}"],[-1,353,"    "],[-1,359,"}"],[1,367,"Chat"],[-1,367,"Audio"],[1,393," "],[1,395,"\t"],[-1,395,"    "],[1,409,"\t"],[-1,409,"  "],[1,431,"\t\t"],[-1,431,"        "],[1,459,"100"],[-1,459,"5"],[1,469,"\t\t\t"],[-1,469,"            "],[1,501,"和小红聊天中~~~~~"],[-1,501,"语音中。。。。。"],[1,513,"\t\t}\n\t"],[-1,513,"  }\n\n    "],[1,525,"\t"],[-1,548,"\n"],[1,555,"直接测试就行，在test1方法名上右击，run as j"],[-1,555,"方法一：使用main函数进行调试 //    public static void main(String[] args) { //        VideoThread videoThread = new VideoThread(); //        AudioThread audioThread = new AudioThread(); // //        videoThread.start(); //        audioThread.start(); //    }   //方法二：使用J"],[1,817,"\n\t"],[-1,817,"中@test进行调试\n  "],[1,835," //注解\n\t"],[-1,835,"\n  "],[1,854,"1"],[1,856," "],[1,858,"\t\t"],[-1,858,"        "],[1,879,"t"],[-1,879,"ideoThread"],[1,911,"\t\tChat"],[-1,911,"  AudioThread audio"],[1,937,"ct "],[1,943,"Chat"],[-1,943,"Audio"],[1,957,"\n\t\t\n\t\tvt"],[-1,957,"    videoThread"],[1,982,"\t\tct"],[-1,982,"  audioThread"],[1,1005,"\t}"],[-1,1005,"  }\n"]],[1011,1011],[67,643]]],[1563973542485,["GJX@GJXAIOU",[[-1,75,"com.qfedu.a_thread;"],[1,94,"DemoDay24;\n"],[1,112,"jupiter.api."],[-1,121,"\n  "],[1,124,"*使"],[1,127,"实现"],[-1,132,"聊天 "],[1,135,"语音\n * @author GJXAIOU\n * @create 2019-07-24-20:54"],[1,139,"\n"],[-1,172," "],[-1,175,"\t"],[1,176,"    "],[-1,186,"\t"],[1,187,"    "],[-1,207,"\t\t"],[1,209,"        "],[-1,229,"100"],[1,232,"5"],[-1,241,"\t\t\t"],[1,244,"            "],[-1,264,"和小芳"],[-1,270,"………………"],[1,276,"。。。。。"],[-1,280,"\t\t}\n\t}\n"],[1,287,"        }\n       \n    "],[1,289,"}"],[-1,296,"Chat"],[1,300,"Audio"],[-1,321," "],[-1,324,"\t"],[1,325,"    "],[-1,335,"\t"],[1,336,"    "],[-1,356,"\t\t"],[1,358,"        "],[-1,378,"100"],[1,381,"5"],[-1,390,"\t\t\t"],[1,393,"            "],[-1,413,"和小红聊天中~~~~~"],[1,424,"语音中。。。。。"],[-1,428,"\t\t}\n\t"],[1,433,"        }\n        \n    "],[-1,436,"\t"],[1,464,"\n    "],[-1,466,"直接测试就行，在test1方法名上右击，run as jUnit\n\t@Te"],[1,503,"方法一：使用main函数进行调试\n//    public static void main(String[] args) {\n//        VideoThread videoThread = new VideoThread();\n//        AudioThread audioThread = new AudioThread();\n//\n//        videoThread.start();\n//        audioThread."],[1,505,"art();\n//    }\n\n   "],[-1,508,"注解\n\t"],[1,512,"方法二：使用JUnit中@test进行调试\n    @Test\n    "],[-1,528,"1"],[-1,531," "],[-1,534,"\t\t"],[1,536,"        "],[-1,549,"t"],[1,550,"ideoThread"],[-1,572,"\t\tChat"],[1,578,"        AudioThread audio"],[-1,585,"ct "],[-1,594,"Chat"],[1,598,"Audio"],[-1,608,"\t\t\n\t\tvt"],[1,615,"\n        videoThread"],[-1,625,"\t\tct"],[1,629,"        audioThread"],[-1,639,"\t}"],[1,641,"    }\n"]],[67,643],[1069,1069]]],[1563973667589,["GJX@GJXAIOU",[[1,1075,"\n"]],[1073,1073],[1074,1074]]],[1563973668947,["GJX@GJXAIOU",[[1,1074,"程序"]],[1074,1074],[1076,1076]]],[1563973671606,["GJX@GJXAIOU",[[1,1076,"运行结果："]],[1076,1076],[1081,1081]]],[1563973673023,["GJX@GJXAIOU",[[1,1083,"\n"]],[1081,1081],[1082,1082]]],[1563973680513,["GJX@GJXAIOU",[[1,1082,"每次运行结果"]],[1082,1082],[1088,1088]]],[1563973684711,["GJX@GJXAIOU",[[-1,1086,"结果"]],[1088,1088],[1086,1086]]],[1563973702967,["GJX@GJXAIOU",[[1,1086,"结果会不同，进程会别抢占；"]],[1086,1086],[1099,1099]]],[1563973703399,["GJX@GJXAIOU",[[1,1101,"\n"]],[1099,1099],[1100,1100]]],[1563973706137,["GJX@GJXAIOU",[[1,1100,"```java"]],[1100,1100],[1107,1107]]],[1563973706277,["GJX@GJXAIOU",[[1,1109,"\n"]],[1107,1107],[1108,1108]]],[1563973706421,["GJX@GJXAIOU",[[1,1110,"\n"]],[1108,1108],[1109,1109]]],[1563973707654,["GJX@GJXAIOU",[[1,1109,"```"]],[1109,1109],[1112,1112]]],[1563973709373,["GJX@GJXAIOU",[[1,1108,"语音中。。。。。\n语音中。。。。。\n语音中。。。。。\n语音中。。。。。\n语音中。。。。。\n视频中。。。。。\n视频中。。。。。\n视频中。。。。。\n视频中。。。。。\n视频中。。。。。"]],[1108,1108],[1197,1197]]],[1563973719962,["GJX@GJXAIOU",[[1,1206,"y "]],[1206,1206],[1207,1207]]],[1563973720029,["GJX@GJXAIOU",[[1,1207,"i"]],[1207,1207],[1208,1208]]],[1563973720182,["GJX@GJXAIOU",[[1,1209," "]],[1208,1208],[1209,1209]]],[1563973721508,["GJX@GJXAIOU",[[-1,1206,"yi "]],[1209,1209],[1206,1206]]],[1563973722999,["GJX@GJXAIOU",[[1,1206,"一、"]],[1206,1206],[1208,1208]]],[1563973724173,["GJX@GJXAIOU",[[-1,1208," "]],[1209,1209],[1208,1208]]],[1563973741421,["GJX@GJXAIOU",[[1,1217,"\n"]],[1216,1216],[1217,1217]]],[1563973743541,["GJX@GJXAIOU",[[1,1218,"\n"]],[1217,1217],[1218,1218]]],[1563973754406,["GJX@GJXAIOU",[[1,1218,"方法名  | 含义  }"]],[1218,1218],[1230,1230]]],[1563973755104,["GJX@GJXAIOU",[[-1,1229,"}"]],[1230,1230],[1229,1229]]],[1563973758934,["GJX@GJXAIOU",[[1,1229,"| 说明"]],[1229,1229],[1233,1233]]],[1563973759597,["GJX@GJXAIOU",[[1,1234,"\n"]],[1233,1233],[1234,1234]]],[1563973762823,["GJX@GJXAIOU",[[1,1234,"---| ="]],[1234,1234],[1240,1240]]],[1563973763245,["GJX@GJXAIOU",[[-1,1239,"="]],[1240,1240],[1239,1239]]],[1563973763878,["GJX@GJXAIOU",[[1,1239,"00"]],[1239,1239],[1241,1241]]],[1563973764900,["GJX@GJXAIOU",[[-1,1238," 00"]],[1241,1241],[1238,1238]]],[1563973768703,["GJX@GJXAIOU",[[1,1238,"---|---"]],[1238,1238],[1245,1245]]],[1563973775349,["GJX@GJXAIOU",[[-1,1348," "],[1,1349,"-"],[-1,1529,"  \t\t\t"],[1,1534,"- "]],[1248,1630],[1248,1627]]],[1563973780117,["GJX@GJXAIOU",[[-1,1348,"- "]],[1348,1350],[1348,1348]]],[1563973781501,["GJX@GJXAIOU",[[-1,1326,"- "]],[1326,1328],[1326,1326]]],[1563973782519,["GJX@GJXAIOU",[[-1,1294,"-"]],[1294,1295],[1294,1294]]],[1563973783087,["GJX@GJXAIOU",[[-1,1246,"-"]],[1247,1247],[1246,1246]]],[1563973783908,["GJX@GJXAIOU",[[-1,1345,"-"]],[1346,1346],[1345,1345]]],[1563973784612,["GJX@GJXAIOU",[[-1,1439," "]],[1440,1440],[1439,1439]]],[1563973785197,["GJX@GJXAIOU",[[-1,1521,"-"]],[1522,1522],[1521,1521]]],[1563973786621,["GJX@GJXAIOU",[[-1,1438,"-"]],[1439,1439],[1438,1438]]],[1563973787244,["GJX@GJXAIOU",[[-1,1522,"-"]],[1523,1523],[1522,1522]]],[1563973787957,["GJX@GJXAIOU",[[-1,1575,"-"]],[1576,1576],[1575,1575]]],[1563973792011,["GJX@GJXAIOU",[[1,1268," |"]],[1268,1268],[1270,1270]]],[1563973802826,["GJX@GJXAIOU",[[1,1318,"|"]],[1318,1318],[1319,1319]]],[1563973805273,["GJX@GJXAIOU",[[1,1338,"|"]],[1338,1338],[1339,1339]]],[1563973807854,["GJX@GJXAIOU",[[1,1366,"|"]],[1366,1366],[1367,1367]]],[1563973809628,["GJX@GJXAIOU",[[-1,1348,"\n"]],[1348,1348],[1347,1347]]],[1563973812090,["GJX@GJXAIOU",[[1,1465,"|"]],[1465,1465],[1466,1466]]],[1563973815404,["GJX@GJXAIOU",[[1,1543,"\n"]],[1543,1543],[1544,1544]]],[1563973816549,["GJX@GJXAIOU",[[-1,1543,"\n"]],[1544,1544],[1543,1543]]],[1563973817523,["GJX@GJXAIOU",[[1,1543,"|"]],[1543,1543],[1544,1544]]],[1563973819872,["GJX@GJXAIOU",[[1,1612,"|"]],[1612,1612],[1613,1613]]],[1563973822852,["GJX@GJXAIOU",[[-1,1525," "]],[1526,1526],[1525,1525]]],[1563973824189,["GJX@GJXAIOU",[[-1,1525,"\n"]],[1525,1525],[1524,1524]]],[1563973833079,["GJX@GJXAIOU",[[1,1487,"|"]],[1487,1487],[1488,1488]]],[1563973838224,["GJX@GJXAIOU",[[1,1414,"|"]],[1414,1414],[1415,1415]]],[1563973846388,["GJX@GJXAIOU",[[-1,1555,"；"]],[1556,1556],[1555,1555]]],[1563973846793,["GJX@GJXAIOU",[[1,1555,"|"]],[1555,1555],[1556,1556]]],[1563974104463,["GJX@GJXAIOU",[[-1,1278,"，"]],[1279,1279],[1278,1278]]],[1563974105697,["GJX@GJXAIOU",[[1,1278,"|"]],[1278,1278],[1279,1279]]],[1563974117356,["GJX@GJXAIOU",[[-1,1348," static "]],[1348,1356],[1348,1348]]],[1563974120452,["GJX@GJXAIOU",[[-1,1435,"static "]],[1435,1442],[1435,1435]]],[1563974123731,["GJX@GJXAIOU",[[-1,1566," "]],[1567,1567],[1566,1566]]],[1563974124932,["GJX@GJXAIOU",[[-1,1512," "]],[1513,1513],[1512,1512]]],[1563974127204,["GJX@GJXAIOU",[[-1,1295," "]],[1296,1296],[1295,1295]]],[1563974128587,["GJX@GJXAIOU",[[-1,1246," "]],[1247,1247],[1246,1246]]],[1563974310367,["GJX@GJXAIOU",[[1,1791,"\n"]],[1791,1791],[1792,1792]]],[1563974332716,["GJX@GJXAIOU",[[1,1824,"是"]],[1824,1824],[1825,1825]]],[1563974333762,["GJX@GJXAIOU",[[1,1827,"不能"]],[1825,1825],[1827,1827]]],[1563974334795,["GJX@GJXAIOU",[[1,1827,"使用"]],[1827,1827],[1829,1829]]],[1563974336613,["GJX@GJXAIOU",[[-1,1829,"不能"]],[1831,1831],[1829,1829]]],[1563974358262,["GJX@GJXAIOU",[[1,3051,"二、"]],[3051,3051],[3053,3053]]],[1563974375294,["GJX@GJXAIOU",[[1,2093,"\n\t\t、、"]],[2093,2093],[2098,2098]]],[1563974375908,["GJX@GJXAIOU",[[-1,2096,"、、"]],[2098,2098],[2096,2096]]],[1563974376591,["GJX@GJXAIOU",[[1,2096,"//"]],[2096,2096],[2098,2098]]],[1563974384285,["GJX@GJXAIOU",[[1,2483,"\n\t\t\t "]],[2483,2483],[2488,2488]]],[1563974388572,["GJX@GJXAIOU",[[1,2519,"\n\t\t\t "]],[2519,2519],[2524,2524]]],[1563974394245,["GJX@GJXAIOU",[[1,2554,"\n\t\t\t "]],[2554,2554],[2559,2559]]],[1563974406308,["GJX@GJXAIOU",[[-1,2447,"\t"],[-1,2451,"\t"],[-1,2484,"\t"],[-1,2522,"\t"],[-1,2555,"\t"],[-1,2604,"\t"]],[2448,2610],[2447,2604]]],[1563974429943,["GJX@GJXAIOU",[[1,1791,"xianche"]],[1791,1791],[1798,1798]]],[1563974431059,["GJX@GJXAIOU",[[-1,1791,"xianche"]],[1798,1798],[1791,1791]]],[1563974435641,["GJX@GJXAIOU",[[1,1791,"- 线程转给你"]],[1791,1791],[1798,1798]]],[1563974436759,["GJX@GJXAIOU",[[-1,1795,"转给你"]],[1798,1798],[1795,1795]]],[1563974442526,["GJX@GJXAIOU",[[1,1795,"中常见方法的测试："]],[1795,1795],[1804,1804]]],[1563974445845,["GJX@GJXAIOU",[[1,1791,"   \n"]],[1790,1790],[1794,1794]]],[1563975114692,["GJX@GJXAIOU",[[1,1852,"\n"]],[1851,1851],[1852,1852]]],[1563975129948,["GJX@GJXAIOU",[[1,1852,"==run()方法中不能抛出异常，只能使用t"]],[1852,1852],[1874,1874]]],[1563975129986,["GJX@GJXAIOU",[[1,1873," "]],[1874,1874],[1875,1875]]],[1563975132012,["GJX@GJXAIOU",[[1,1875,"ry-cath"]],[1875,1875],[1882,1882]]],[1563975132869,["GJX@GJXAIOU",[[-1,1881,"h"]],[1882,1882],[1881,1881]]],[1563975134792,["GJX@GJXAIOU",[[1,1881,"ch=="]],[1881,1881],[1885,1885]]],[1563975282611,["GJX@GJXAIOU",[[1,1886,"\n"]],[1885,1885],[1886,1886]]],[1563975282739,["GJX@GJXAIOU",[[1,1887,"\n"]],[1886,1886],[1887,1887]]],[1563975286726,["GJX@GJXAIOU",[[1,1887,"```java"]],[1887,1887],[1894,1894]]],[1563975286876,["GJX@GJXAIOU",[[1,1895,"\n"]],[1894,1894],[1895,1895]]],[1563975287007,["GJX@GJXAIOU",[[1,1896,"\n"]],[1895,1895],[1896,1896]]],[1563975288416,["GJX@GJXAIOU",[[1,1896,"```"]],[1896,1896],[1899,1899]]],[1563975292681,["GJX@GJXAIOU",[[1,1895,"39:Thread[main,5,main]\n这里是main线程\n28:Thread[狗娃,10,main]\n自定义线程\n这里是main线程\n自定义线程\n自定义线程\n这里是main线程\n这里是main线程\n自定义线程\n自定义线程\n这里是main线程\n"]],[1895,1895],[2020,2020]]],[1563975295625,["GJX@GJXAIOU",[[-1,1895,"39:Thread[main,5,main]\n这里是main线程\n28:Thread[狗娃,10,main]\n自定义线程\n这里是main线程\n自定义线程\n自定义线程\n这里是main线程\n这里是main线程\n自定义线程\n自定义线程\n这里是main线程\n"]],[2020,2020],[1895,1895]]],[1563975298330,["GJX@GJXAIOU",[[1,1900,"\n"]],[1899,1899],[1900,1900]]],[1563975302306,["GJX@GJXAIOU",[[1,1895,"39:Thread[main,5,main]\n这里是main线程\n28:Thread[狗娃,10,main]\n自定义线程\n这里是main线程\n自定义线程\n自定义线程\n这里是main线程\n这里是main线程\n自定义线程\n自定义线程\n这里是main线程\n"]],[1895,1895],[2020,2020]]],[1563975305725,["GJX@GJXAIOU",[[1,1886,"````"]],[1886,1886],[1890,1890]]],[1563975306666,["GJX@GJXAIOU",[[-1,1889,"`"]],[1890,1890],[1889,1889]]],[1563975307467,["GJX@GJXAIOU",[[1,1889,"java"]],[1889,1889],[1893,1893]]],[1563975307658,["GJX@GJXAIOU",[[1,1894,"\n"]],[1893,1893],[1894,1894]]],[1563975309235,["GJX@GJXAIOU",[[1,1895,"\n"]],[1894,1894],[1895,1895]]],[1563975309828,["GJX@GJXAIOU",[[1,1895,"```"]],[1895,1895],[1898,1898]]],[1563975310962,["GJX@GJXAIOU",[[1,1899,"\n"]],[1898,1898],[1899,1899]]],[1563975312625,["GJX@GJXAIOU",[[1,1899,"chengu"]],[1899,1899],[1905,1905]]],[1563975313978,["GJX@GJXAIOU",[[-1,1899,"chengu"]],[1905,1905],[1899,1899]]],[1563975318060,["GJX@GJXAIOU",[[1,1899,"程序运行结果："]],[1899,1899],[1906,1906]]],[1563975356828,["GJX@GJXAIOU",[[1,1894,"package DemoDay24;   /**\n * @author GJXAIOU\n * @create 2019-07-24-21:23\n */ public class Demo2 extends Thread {\n\n    public Demo2(String name) {\n        super(name);//调用父类Thread的有参构造方法\n  }\n\n    @Override\n  public void run() {\n        //这里是Demo2线程对象的线程代码\n  System.out.println(\"28:\" + Thread.currentThread());   for (int i = 0; i < 5; i++) {\n            System.out.println(\"自定义线程\");\n  /*\n  在其他方法中， 使用sleep方法，可以抛出，可以捕获，\n 但是在run方法为什么只有捕获没有抛出？因为这是一个语法规则：\n 在Java中，重写父类的方法，要求和父类的方法声明一模一样，\n 在Thread类中，run方法没有抛出异常，所以在子类中，你也不能抛出异常，要和父类一致  */  try {\n                sleep(100);\n  } catch (InterruptedException e) {\n                e.printStackTrace();\n  }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        //这里是main线程\n  Demo2 d = new Demo2(\"狗蛋\");    d.setName(\"狗娃\");\n  d.setPriority(10);\n  d.start(); //开启自定义线程，执行自定义线程中的run方法里面的功能\n  System.out.println(\"39:\" + Thread.currentThread());   for (int i = 0; i < 5; i++) {\n            System.out.println(\"这里是main线程\");\n  sleep(100);\n  }\n    }\n}"]],[1894,1894],[2918,2918]]],[1563975360264,["GJX@GJXAIOU",[[-1,1894,"package DemoDay24;   /**\n * @author GJXAIOU\n * @create 2019-07-24-21:23\n */ public class Demo2 extends Thread {\n\n    public Demo2(String name) {\n        super(name);//调用父类Thread的有参构造方法\n  }\n\n    @Override\n  public void run() {\n        //这里是Demo2线程对象的线程代码\n  System.out.println(\"28:\" + Thread.currentThread());   for (int i = 0; i < 5; i++) {\n            System.out.println(\"自定义线程\");\n  /*\n  在其他方法中， 使用sleep方法，可以抛出，可以捕获，\n 但是在run方法为什么只有捕获没有抛出？因为这是一个语法规则：\n 在Java中，重写父类的方法，要求和父类的方法声明一模一样，\n 在Thread类中，run方法没有抛出异常，所以在子类中，你也不能抛出异常，要和父类一致  */  try {\n                sleep(100);\n  } catch (InterruptedException e) {\n                e.printStackTrace();\n  }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        //这里是main线程\n  Demo2 d = new Demo2(\"狗蛋\");    d.setName(\"狗娃\");\n  d.setPriority(10);\n  d.start(); //开启自定义线程，执行自定义线程中的run方法里面的功能\n  System.out.println(\"39:\" + Thread.currentThread());   for (int i = 0; i < 5; i++) {\n            System.out.println(\"这里是main线程\");\n  sleep(100);\n  }\n    }\n}"]],[2918,2918],[1894,1894]]],[1563975362193,["GJX@GJXAIOU",[[1,1894,"package DemoDay24;\n\n/**\n * @author GJXAIOU\n * @create 2019-07-24-21:23\n */\npublic class Demo2 extends Thread {\n\n    public Demo2(String name) {\n        super(name);//调用父类Thread的有参构造方法\n    }\n\n    \n    @Override\n    public void run() {\n        //这里是Demo2线程对象的线程代码\n        System.out.println(\"28:\" + Thread.currentThread());\n\n        for (int i = 0; i < 5; i++) {\n            System.out.println(\"自定义线程\");\n\t\t/*\n\t\t 在其他方法中， 使用sleep方法，可以抛出，可以捕获，\n\t\t 但是在run方法为什么只有捕获没有抛出？因为这是一个语法规则：\n\t\t 在Java中，重写父类的方法，要求和父类的方法声明一模一样，\n\t\t 在Thread类中，run方法没有抛出异常，所以在子类中，你也不能抛出异常，要和父类一致\n\t\t */\n            try {\n                sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        //这里是main线程\n        Demo2 d = new Demo2(\"狗蛋\");\n\n        d.setName(\"狗娃\");\n        d.setPriority(10);\n        d.start(); //开启自定义线程，执行自定义线程中的run方法里面的功能\n        System.out.println(\"39:\" + Thread.currentThread());\n\n        for (int i = 0; i < 5; i++) {\n            System.out.println(\"这里是main线程\");\n            sleep(100);\n        }\n    }\n}\n\n"]],[1894,1894],[3034,3034]]],[1563975404699,["GJX@GJXAIOU",[[-1,1809,"下面的 InterfaceA 和 testA 是为了测试什么时候是不能使用抛出异常；"]],[1809,1851],[1809,1809]]],[1563975406181,["GJX@GJXAIOU",[[-1,1809,"\n"]],[1809,1809],[1808,1808]]],[1563975412235,["GJX@GJXAIOU",[[1,3142,"下面的 InterfaceA 和 testA 是为了测试什么时候是不能使用抛出异常；"]],[3142,3142],[3184,3184]]],[1563975432811,["GJX@GJXAIOU",[[-1,3622,"\t@Override\n\tpublic void run() {\n\t\t//这里是Demo2线程对象的线程代码\n\t\tSystem.out.println(\"28:\" + Thread.currentThread());\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tSystem.out.println(\"自定义线程\");\n\t\t/*\n\t\t 在其他方法中， 使用sleep方法，可以抛出，可以捕获，\n\t\t 但是在run方法为什么只有捕获没有抛出？因为这是一个语法规则：\n\t\t 在Java中，重写父类的方法，要求和父类的方法声明一模一样，\n\t\t 在Thread类中，run方法没有抛出异常，所以在子类中，你也不能抛出异常，要和父类一致\n\t\t */\n\t\t\ttry {\n\t\t\t\tsleep(100);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\t//这里是main线程\n\t\t\n\t\tDemo2 d = new Demo2(\"狗蛋\");\n\t\td.setName(\"狗娃\");\n\t\td.setPriority(10);\n\t\td.start(); //开启自定义线程，执行自定义线程中的run方法里面的功能\n\t\tSystem.out.println(\"39:\" + Thread.currentThread());\n\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tSystem.out.println(\"这里是main线程\");\n\t\t\tsleep(100);\n\t\t}\n\t}"]],[3622,4401],[3622,3622]]],[1563975434512,["GJX@GJXAIOU",[[1,3622,"、、"]],[3622,3622],[3624,3624]]],[1563975435115,["GJX@GJXAIOU",[[-1,3622,"、、"]],[3624,3624],[3622,3622]]],[1563975435793,["GJX@GJXAIOU",[[1,3622,"？、"]],[3622,3622],[3624,3624]]],[1563975436561,["GJX@GJXAIOU",[[-1,3622,"？、"]],[3624,3624],[3622,3622]]],[1563975437270,["GJX@GJXAIOU",[[1,3622,"、、"]],[3622,3622],[3624,3624]]],[1563975437869,["GJX@GJXAIOU",[[-1,3622,"、、"]],[3624,3624],[3622,3622]]],[1563975444846,["GJX@GJXAIOU",[[1,3622,"//下面代码省略"]],[3622,3622],[3630,3630]]],[1563975962117,["GJX@GJXAIOU",[[-1,3309,"\t"]],[3310,3310],[3309,3309]]],[1563975962475,["GJX@GJXAIOU",[[-1,3309,"\n"]],[3309,3309],[3308,3308]]],[1563976052995,["GJX@GJXAIOU",[[-1,3183,"；"]],[3184,3184],[3183,3183]]],[1563976058966,["GJX@GJXAIOU",[[1,3183,"，只能使用try"]],[3183,3183],[3191,3191]]],[1563976059001,["GJX@GJXAIOU",[[1,3188," "]],[3191,3191],[3192,3192]]],[1563976061517,["GJX@GJXAIOU",[[1,3192,"-catch"]],[3192,3192],[3198,3198]]],[1563976074597,["GJX@GJXAIOU",[[1,3762,"三、"]],[3762,3762],[3764,3764]]],[1563976374595,["GJX@GJXAIOU",[[1,5377,"\n"]],[5375,5375],[5376,5376]]],[1563976381511,["GJX@GJXAIOU",[[1,5376,"程序运行结果："]],[5376,5376],[5383,5383]]],[1563976381837,["GJX@GJXAIOU",[[1,5385,"\n"]],[5383,5383],[5384,5384]]],[1563976384840,["GJX@GJXAIOU",[[1,5384,"```java"]],[5384,5384],[5391,5391]]],[1563976385042,["GJX@GJXAIOU",[[1,5393,"\n"]],[5391,5391],[5392,5392]]],[1563976385948,["GJX@GJXAIOU",[[1,5394,"\n"]],[5392,5392],[5393,5393]]],[1563976386640,["GJX@GJXAIOU",[[1,5393,"```"]],[5393,5393],[5396,5396]]],[1563976388858,["GJX@GJXAIOU",[[1,5392,"窗口1:卖出来第50张票\n窗口1:卖出来第49张票\n窗口1:卖出来第48张票\n窗口1:卖出来第47张票\n窗口1:卖出来第46张票\n窗口1:卖出来第45张票\n窗口1:卖出来第44张票\n窗口1:卖出来第43张票\n窗口1:卖出来第42张票\n窗口1:卖出来第41张票\n窗口1:卖出来第40张票\n窗口1:卖出来第39张票\n窗口1:卖出来第38张票\n窗口1:卖出来第37张票\n窗口1:卖出来第36张票\n窗口1:卖出来第35张票\n窗口1:卖出来第34张票\n窗口1:卖出来第33张票\n窗口1:卖出来第32张票\n窗口1:卖出来第31张票\n窗口1:卖出来第30张票\n窗口1:卖出来第29张票\n窗口1:卖出来第28张票\n窗口1:卖出来第27张票\n窗口1:卖出来第26张票\n窗口1:卖出来第25张票\n窗口1:卖出来第24张票\n窗口1:卖出来第23张票\n窗口1:卖出来第22张票\n窗口1:卖出来第21张票\n窗口1:卖出来第20张票\n窗口1:卖出来第19张票\n窗口1:卖出来第18张票\n窗口1:卖出来第17张票\n窗口1:卖出来第16张票\n窗口1:卖出来第15张票\n窗口1:卖出来第14张票\n窗口1:卖出来第13张票\n窗口1:卖出来第12张票\n窗口1:卖出来第11张票\n窗口1:卖出来第10张票\n窗口1:卖出来第9张票\n窗口1:卖出来第8张票\n窗口1:卖出来第7张票\n窗口1:卖出来第6张票\n窗口1:卖出来第5张票\n窗口1:卖出来第4张票\n窗口1:卖出来第3张票\n窗口1:卖出来第2张票\n窗口1:卖出来第1张票\n卖完了\n卖完了\n卖完了"]],[5392,5392],[6044,6044]]],[1563976395034,["GJX@GJXAIOU",[[-1,5418,"窗口1:卖出来第48张票\n窗口1:卖出来第47张票\n窗口1:卖出来第46张票\n窗口1:卖出来第45张票\n窗口1:卖出来第44张票\n窗口1:卖出来第43张票\n窗口1:卖出来第42张票\n窗口1:卖出来第41张票\n窗口1:卖出来第40张票\n窗口1:卖出来第39张票\n窗口1:卖出来第38张票\n窗口1:卖出来第37张票\n窗口1:卖出来第36张票"]],[5418,5586],[5418,5418]]],[1563976398124,["GJX@GJXAIOU",[[1,5418,"/"]],[5418,5418],[5419,5419]]],[1563976398643,["GJX@GJXAIOU",[[-1,5418,"/"]],[5419,5419],[5418,5418]]],[1563976400086,["GJX@GJXAIOU",[[1,5418,"。。。。。"]],[5418,5418],[5423,5423]]],[1563976409610,["GJX@GJXAIOU",[[-1,5424,"窗口1:卖出来第35张票\n窗口1:卖出来第34张票\n窗口1:卖出来第33张票\n窗口1:卖出来第32张票\n窗口1:卖出来第31张票\n窗口1:卖出来第30张票\n窗口1:卖出来第29张票"]],[5424,5514],[5424,5424]]],[1563976411034,["GJX@GJXAIOU",[[-1,5424,"\n"]],[5424,5424],[5423,5423]]],[1563976413292,["GJX@GJXAIOU",[[-1,5426,"1"]],[5427,5427],[5426,5426]]],[1563976413597,["GJX@GJXAIOU",[[1,5426,"3"]],[5426,5426],[5427,5427]]],[1563976414900,["GJX@GJXAIOU",[[-1,5439,"1"]],[5440,5440],[5439,5439]]],[1563976415038,["GJX@GJXAIOU",[[1,5439,"3"]],[5439,5439],[5440,5440]]],[1563976416573,["GJX@GJXAIOU",[[-1,5452,"1"]],[5453,5453],[5452,5452]]],[1563976416724,["GJX@GJXAIOU",[[1,5452,"3"]],[5452,5452],[5453,5453]]],[1563976419199,["GJX@GJXAIOU",[[1,5466,"3"]],[5466,5466],[5467,5467]]],[1563976420610,["GJX@GJXAIOU",[[-1,5465,"13"]],[5467,5467],[5465,5465]]],[1563976421397,["GJX@GJXAIOU",[[1,5465,"3"]],[5465,5465],[5466,5466]]],[1563976428265,["GJX@GJXAIOU",[[-1,5463,"窗口3:卖出来第25张票\n窗口1:卖出来第24张票\n窗口1:卖出来第23张票\n窗口1:卖出来第22张票\n窗口1:卖出来第21张票\n窗口1:卖出来第20张票\n窗口1:卖出来第19张票\n窗口1:卖出来第18张票\n窗口1:卖出来第17张票\n窗口1:卖出来第16张票\n窗口1:卖出来第15张票\n窗口1:卖出来第14张票\n窗口1:卖出来第13张票\n窗口1:卖出来第12张票\n窗口1:卖出来第11张票\n窗口1:卖出来第10张票\n窗口1:卖出来第9张票\n窗口1:卖出来第8张票\n窗口1:卖出来第7张票\n窗口1:卖出来第6张票\n窗口1:卖出来第5张票\n窗口1:卖出来第4张票\n窗口1:卖出来第3张票"]],[5463,5754],[5463,5463]]],[1563976430482,["GJX@GJXAIOU",[[-1,5463,"\n"]],[5463,5463],[5462,5462]]],[1563976433059,["GJX@GJXAIOU",[[-1,5465,"1"]],[5466,5466],[5465,5465]]],[1563976433373,["GJX@GJXAIOU",[[1,5465,"3"]],[5465,5465],[5466,5466]]],[1563976434572,["GJX@GJXAIOU",[[-1,5477,"1"]],[5478,5478],[5477,5477]]],[1563976434700,["GJX@GJXAIOU",[[1,5477,"3"]],[5477,5477],[5478,5478]]],[1563976445145,["GJX@GJXAIOU",[[1,4789,"\n\t\t\t"]],[4789,4789],[4793,4793]]],[1563976450542,["GJX@GJXAIOU",[[1,4795,"可以使用"]],[4795,4795],[4799,4799]]],[1563976457761,["GJX@GJXAIOU",[[1,4805,"\n\t\t\t//不能使用"]],[4805,4805],[4815,4815]]],[1563976465420,["GJX@GJXAIOU",[[1,4804,"的任何确定的对象"]],[4804,4804],[4812,4812]]],[1563976489010,["GJX@GJXAIOU",[[1,4929,"\n\t\t\t\t\t"]],[4929,4929],[4935,4935]]],[1563976518182,["GJX@GJXAIOU",[[1,3821,"第一次："]],[3821,3821],[3825,3825]]],[1563976519216,["GJX@GJXAIOU",[[-1,3824,"："]],[3825,3825],[3824,3824]]],[1563976523950,["GJX@GJXAIOU",[[1,3821,"- "]],[3821,3821],[3823,3823]]],[1563976526498,["GJX@GJXAIOU",[[1,3843,"  - "]],[3843,3843],[3847,3847]]],[1563976528949,["GJX@GJXAIOU",[[1,3921,"  - "]],[3921,3921],[3925,3925]]],[1563976535028,["GJX@GJXAIOU",[[1,3946,"- 第二次"]],[3946,3946],[3951,3951]]],[1563976537499,["GJX@GJXAIOU",[[1,3986,"  - "]],[3986,3986],[3990,3990]]],[1563976539542,["GJX@GJXAIOU",[[1,4061,"  - "]],[4061,4061],[4065,4065]]],[1563976545827,["GJX@GJXAIOU",[[1,4114,"- 第三次"]],[4114,4114],[4119,4119]]],[1563976548455,["GJX@GJXAIOU",[[1,4138,"  - "]],[4138,4138],[4142,4142]]],[1563976558397,["GJX@GJXAIOU",[[1,3775,"以"]],[3775,3775],[3776,3776]]],[1563976565972,["GJX@GJXAIOU",[[1,3779,"买票Wie"]],[3779,3779],[3784,3784]]],[1563976566009,["GJX@GJXAIOU",[[1,3781," "]],[3784,3784],[3785,3785]]],[1563976566947,["GJX@GJXAIOU",[[-1,3781," Wie"]],[3785,3785],[3781,3781]]],[1563976570574,["GJX@GJXAIOU",[[1,3781,"为示例"]],[3781,3781],[3784,3784]]],[1563976576306,["GJX@GJXAIOU",[[-1,3786,"卖票"]],[3787,3787],[3786,3786]]],[1563976581432,["GJX@GJXAIOU",[[1,3786,"一共有"]],[3786,3786],[3789,3789]]],[1563976590565,["GJX@GJXAIOU",[[1,3799,"同时"]],[3799,3799],[3801,3801]]],[1563977280488,["GJX@GJXAIOU",[[-1,4351,"格式："]],[4351,4354],[4351,4351]]],[1563977294919,["GJX@GJXAIOU",[[1,4325,"**"],[1,4337,"**"]],[4325,4337],[4325,4341]]],[1563977423084,["GJX@GJXAIOU",[[1,5585,"（）"]],[5585,5585],[5587,5587]]],[1563977425203,["GJX@GJXAIOU",[[1,5586,"一"]],[5586,5586],[5587,5587]]],[1563977428617,["GJX@GJXAIOU",[[-1,5591,"/*"]],[5591,5593],[5591,5591]]],[1563977436211,["GJX@GJXAIOU",[[-1,5592," 开发中的死锁现象"]],[5592,5601],[5592,5592]]],[1563977438112,["GJX@GJXAIOU",[[-1,5593,"  为什么会出现死锁： 【必须会】"]],[5593,5610],[5593,5593]]],[1563977442749,["GJX@GJXAIOU",[[1,5593,"出现死多"]],[5593,5593],[5597,5597]]],[1563977443407,["GJX@GJXAIOU",[[-1,5595,"死多"]],[5597,5597],[5595,5595]]],[1563977449493,["GJX@GJXAIOU",[[1,5595,"死锁的原因："]],[5595,5595],[5601,5601]]],[1563977451528,["GJX@GJXAIOU",[[-1,5592,"\n"]],[5592,5592],[5591,5591]]],[1563977451800,["GJX@GJXAIOU",[[-1,5591,"\n"]],[5591,5591],[5590,5590]]],[1563977461472,["GJX@GJXAIOU",[[-1,5649," 绝对不能用死锁！！！"]],[5649,5660],[5649,5649]]],[1563977465558,["GJX@GJXAIOU",[[-1,5650," */"]],[5653,5653],[5650,5650]]],[1563977470495,["GJX@GJXAIOU",[[-1,5651,"\n"]],[5651,5651],[5650,5650]]],[1563977470666,["GJX@GJXAIOU",[[-1,5650,"\n"]],[5650,5650],[5649,5649]]],[1563977509011,["GJX@GJXAIOU",[[1,5649,"下面的代码会出现死锁；"]],[5649,5649],[5660,5660]]],[1563977510016,["GJX@GJXAIOU",[[-1,5659,"；"]],[5660,5660],[5659,5659]]],[1563977511643,["GJX@GJXAIOU",[[1,5659,"；"]],[5659,5659],[5660,5660]]],[1563977518066,["GJX@GJXAIOU",[[1,5591,"- "]],[5591,5591],[5593,5593]]],[1563977520481,["GJX@GJXAIOU",[[1,5608,"-"]],[5605,5605],[5609,5609]]],[1563977524455,["GJX@GJXAIOU",[[-1,5607," -"]],[5609,5609],[5607,5607]]],[1563977526743,["GJX@GJXAIOU",[[-1,5627," "]],[5628,5628],[5627,5627]]],[1563977532633,["GJX@GJXAIOU",[[-1,6420,"存在死锁行为，会出现无法执行的情况；"]],[6420,6438],[6420,6420]]],[1563977533167,["GJX@GJXAIOU",[[-1,6422,"\n"]],[6420,6420],[6419,6419]]],[1563977535369,["GJX@GJXAIOU",[[-1,6421,"\n"]],[6421,6421],[6420,6420]]],[1563977538633,["GJX@GJXAIOU",[[1,6425,"（）"]],[6425,6425],[6427,6427]]],[1563977540414,["GJX@GJXAIOU",[[1,6426,"二"]],[6426,6426],[6427,6427]]],[1563977551722,["GJX@GJXAIOU",[[1,3758,"---"]],[3758,3758],[3761,3761]]],[1563977552931,["GJX@GJXAIOU",[[1,3762,"\n"]],[3761,3761],[3762,3762]]],[1563977556572,["GJX@GJXAIOU",[[1,3651,"---"]],[3651,3651],[3654,3654]]],[1563977565295,["GJX@GJXAIOU",[[-1,4605,"\n"]],[4605,4605],[4604,4604]]],[1563977566552,["GJX@GJXAIOU",[[-1,4604,"\n"]],[4604,4604],[4603,4603]]],[1563977720248,["GJX@GJXAIOU",[[1,6426,"\n"]],[6424,6424],[6425,6425]]],[1563977723708,["GJX@GJXAIOU",[[1,6425,"输出结果“"]],[6425,6425],[6430,6430]]],[1563977724177,["GJX@GJXAIOU",[[1,6432,"\n"]],[6430,6430],[6431,6431]]],[1563977724640,["GJX@GJXAIOU",[[-1,6432,"\n"]],[6431,6431],[6430,6430]]],[1563977724914,["GJX@GJXAIOU",[[-1,6429,"“"]],[6430,6430],[6429,6429]]],[1563977725542,["GJX@GJXAIOU",[[1,6429,"："]],[6429,6429],[6430,6430]]],[1563977725785,["GJX@GJXAIOU",[[1,6432,"\n"]],[6430,6430],[6431,6431]]],[1563977728663,["GJX@GJXAIOU",[[1,6431,"```java"]],[6431,6431],[6438,6438]]],[1563977728880,["GJX@GJXAIOU",[[1,6440,"\n"]],[6438,6438],[6439,6439]]],[1563977730291,["GJX@GJXAIOU",[[1,6441,"\n"]],[6439,6439],[6440,6440]]],[1563977730875,["GJX@GJXAIOU",[[1,6440,"```"]],[6440,6440],[6443,6443]]],[1563977732199,["GJX@GJXAIOU",[[1,6439,"小胖有电池，想要遥控器\n逗比有遥控器，想要电池"]],[6439,6439],[6462,6462]]],[1563977741003,["GJX@GJXAIOU",[[1,6510,"- "]],[6510,6510],[6512,6512]]],[1563977745315,["GJX@GJXAIOU",[[1,6702,"- "]],[6702,6702],[6704,6704]]],[1563977751380,["GJX@GJXAIOU",[[-1,6709,"【墙裂推荐】"],[1,6715," "]],[6709,6715],[6710,6710]]],[1563977752126,["GJX@GJXAIOU",[[1,6710,"qign"]],[6710,6710],[6714,6714]]],[1563977753096,["GJX@GJXAIOU",[[-1,6710,"qign"]],[6714,6714],[6710,6710]]],[1563977757765,["GJX@GJXAIOU",[[1,6710,"强烈推荐"]],[6710,6710],[6714,6714]]],[1563977761592,["GJX@GJXAIOU",[[1,6710,"**"],[1,6714,"**"]],[6710,6714],[6710,6718]]],[1563977776546,["GJX@GJXAIOU",[[1,6522,"- "]],[6522,6522],[6524,6524]]],[1563977777441,["GJX@GJXAIOU",[[1,6522,"  "]],[6524,6524],[6526,6526]]],[1563977779296,["GJX@GJXAIOU",[[-1,6534," "]],[6535,6535],[6534,6534]]],[1563977780175,["GJX@GJXAIOU",[[-1,6554," "]],[6555,6555],[6554,6554]]],[1563977780887,["GJX@GJXAIOU",[[-1,6592," "]],[6593,6593],[6592,6592]]],[1563977781639,["GJX@GJXAIOU",[[-1,6606," "]],[6607,6607],[6606,6606]]],[1563977785586,["GJX@GJXAIOU",[[1,6702,"  "]],[6704,6704],[6706,6706]]],[1563977796313,["GJX@GJXAIOU",[[1,6622,"  - "]],[6622,6622],[6626,6626]]],[1563977797275,["GJX@GJXAIOU",[[1,6624,"  "]],[6626,6626],[6628,6628]]],[1563977800623,["GJX@GJXAIOU",[[-1,6621,"\n"]],[6621,6621],[6620,6620]]],[1563977807366,["GJX@GJXAIOU",[[-1,6679,"\t"]],[6680,6680],[6679,6679]]],[1563977807702,["GJX@GJXAIOU",[[-1,6678,"\n"]],[6679,6679],[6678,6678]]],[1563977813488,["GJX@GJXAIOU",[[-1,6750," "]],[6751,6751],[6750,6750]]],[1563977815575,["GJX@GJXAIOU",[[-1,6775," "]],[6776,6776],[6775,6775]]],[1563977817950,["GJX@GJXAIOU",[[-1,6823," "]],[6824,6824],[6823,6823]]],[1563977820127,["GJX@GJXAIOU",[[-1,6882," "]],[6883,6883],[6882,6882]]],[1563977839931,["GJX@GJXAIOU",[[1,8200,"三、"]],[8200,8200],[8202,8202]]],[1563977857495,["GJX@GJXAIOU",[[-1,9132,"# "]],[9134,9134],[9132,9132]]],[1563977860035,["GJX@GJXAIOU",[[1,9132," 四、"]],[9132,9132],[9135,9135]]],[1563977867423,["GJX@GJXAIOU",[[-1,6509,"\n"]],[6509,6509],[6508,6508]]],[1563977956494,["GJX@GJXAIOU",[[-1,7000,"\n"]],[7000,7000],[6999,6999]]],[1563977956944,["GJX@GJXAIOU",[[-1,6999,"\n"]],[6999,6999],[6998,6998]]],[1563977960551,["GJX@GJXAIOU",[[-1,6943,"\n"]],[6943,6943],[6942,6942]]],[1563977987919,["GJX@GJXAIOU",[[1,7352,"\n\t\t"]],[7349,7349],[7352,7352]]],[1563977988938,["GJX@GJXAIOU",[[1,7352,"、、"]],[7352,7352],[7354,7354]]],[1563977989577,["GJX@GJXAIOU",[[-1,7352,"、、"]],[7354,7354],[7352,7352]]],[1563977992917,["GJX@GJXAIOU",[[1,7352,"//方法一："]],[7352,7352],[7358,7358]]],[1563977996170,["GJX@GJXAIOU",[[1,7624,"、、"]],[7624,7624],[7626,7626]]],[1563977996831,["GJX@GJXAIOU",[[-1,7624,"、、"]],[7626,7626],[7624,7624]]],[1563977997557,["GJX@GJXAIOU",[[1,7624,"？、"]],[7624,7624],[7626,7626]]],[1563977998327,["GJX@GJXAIOU",[[-1,7624,"？、"]],[7626,7626],[7624,7624]]],[1563978004860,["GJX@GJXAIOU",[[1,7624,"//方法二："]],[7624,7624],[7630,7630]]],[1563978011311,["GJX@GJXAIOU",[[-1,7412,"        //其他常见的匿名内部类的匿名对象\n//\t\tArrays.sort(a, new Comparator<String>() {\n//\n//\t\t\t@Override\n//\t\t\tpublic int compare(String o1, String o2) {\n//\t\t\t\t// TODO Auto-generated method stub\n//\t\t\t\treturn 0;\n//\t\t\t}\n//\t\t});"]],[7412,7621],[7412,7412]]],[1563978011919,["GJX@GJXAIOU",[[-1,7412,"\n"]],[7412,7412],[7411,7411]]]],null,"GJX@GJXAIOU"],["8c810eaa-8a5f-4df9-ad52-6457e13895db",1564015815025,"---\ntags: \n- 进程\n- 线程\n---\n\n# JavaDay24 多线程与多进程\n\n@toc\n\n代码示例：\n```java\npackage DemoDay24;\n\nimport org.junit.jupiter.api.Test;\n\n/**使用线程实现同时视频和语音\n * @author GJXAIOU\n * @create 2019-07-24-20:54\n */\n\nclass VideoThread extends Thread{\n    @Override\n    public void run() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(\"视频中。。。。。\");\n        }\n       \n    }\n}\nclass AudioThread extends Thread{\n    @Override\n    public void run() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(\"语音中。。。。。\");\n        }\n        \n    }\n}\n\npublic class Demo1 {\n    \n    //方法一：使用main函数进行调试\n//    public static void main(String[] args) {\n//        VideoThread videoThread = new VideoThread();\n//        AudioThread audioThread = new AudioThread();\n//\n//        videoThread.start();\n//        audioThread.start();\n//    }\n\n    //方法二：使用JUnit中@test进行调试\n    @Test\n    public void test(){\n        VideoThread videoThread = new VideoThread();\n        AudioThread audioThread = new AudioThread();\n\n        videoThread.start();\n        audioThread.start();\n    }\n\n}\n```\n程序运行结果：\n每次运行结果会不同，进程会别抢占；\n```java\n语音中。。。。。\n语音中。。。。。\n语音中。。。。。\n语音中。。。。。\n语音中。。。。。\n视频中。。。。。\n视频中。。。。。\n视频中。。。。。\n视频中。。。。。\n视频中。。。。。\n```\n\n## 一、线程中的常用方法\n\n方法名  | 含义  | 说明\n---|---|---\nThread(String name);  |初始化线程的名字|属于线程的一个有参数的构造方法\nsetName(String name); |修改线程的名字\ngetName(); | 获取线程的名字\nsleep(); |static静态方法，通过Thread类名调用，这里需要处理一些异常，要求当前线程睡觉多少毫秒;|【哪一个线程执行了sleep方法，哪一个线程就睡觉】。\ncurrentThead(); |static静态方法，返回当前的线程对象;|【哪一个线程执行了currentThread方法，就返回哪一个线程对象】。\ngetPriority(); |返回当前线程的优先级 |CPU执行的优先级，不是绝对的，仅仅是提升概率。\nsetPriority(int newPriority); |设置线程的优先级。\n\n- 【注意】\n  \t\t线程的优先级范围是从1 ~ 10， 10最高，1最低\n  \t\t这里的优先级只是提高了当前线程拥有CPU执行权的概率，并不能完全保证当前线程能够一定会占用更多的CPU时间片。线程的默认优先级为5。\n  \n  Thread[main,5,main]\n  Thread[Thread-0,5,main]\n   Thread[线程名， 优先级， 线程组名]\n   \n- 线程中常见方法的测试：\n==run()方法中不能抛出异常，只能使用 try-catch==\n```java\npackage DemoDay24;\n\n/**\n * @author GJXAIOU\n * @create 2019-07-24-21:23\n */\npublic class Demo2 extends Thread {\n\n    public Demo2(String name) {\n        super(name);//调用父类Thread的有参构造方法\n    }\n\n    \n    @Override\n    public void run() {\n        //这里是Demo2线程对象的线程代码\n        System.out.println(\"28:\" + Thread.currentThread());\n\n        for (int i = 0; i < 5; i++) {\n            System.out.println(\"自定义线程\");\n\t\t/*\n\t\t 在其他方法中， 使用sleep方法，可以抛出，可以捕获，\n\t\t 但是在run方法为什么只有捕获没有抛出？因为这是一个语法规则：\n\t\t 在Java中，重写父类的方法，要求和父类的方法声明一模一样，\n\t\t 在Thread类中，run方法没有抛出异常，所以在子类中，你也不能抛出异常，要和父类一致\n\t\t */\n            try {\n                sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        //这里是main线程\n        Demo2 d = new Demo2(\"狗蛋\");\n\n        d.setName(\"狗娃\");\n        d.setPriority(10);\n        d.start(); //开启自定义线程，执行自定义线程中的run方法里面的功能\n        System.out.println(\"39:\" + Thread.currentThread());\n\n        for (int i = 0; i < 5; i++) {\n            System.out.println(\"这里是main线程\");\n            sleep(100);\n        }\n    }\n}\n\n\n```\n程序运行结果：\n```java\n39:Thread[main,5,main]\n这里是main线程\n28:Thread[狗娃,10,main]\n自定义线程\n这里是main线程\n自定义线程\n自定义线程\n这里是main线程\n这里是main线程\n自定义线程\n自定义线程\n这里是main线程\n\n```\n下面的 InterfaceA 和 testA 是为了测试什么时候是不能使用抛出异常，只能使用 try-catch\n```java\npackage com.qfedu.a_thread;\n\ninterface A {\n\tpublic void testA();\n}\n\npublic class Demo2 extends Thread implements A{\n\tpublic Demo2(String name) {\n\t\tsuper(name);//调用父类Thread的有参构造方法\n\t}\n\t\n\t@Override\n\tpublic void testA() {\n\t\t//这里也无法抛出异常，两种处理方法，第一种，捕获异常，\n\t\t//第二种，在接口中声明方法部分，声明该异常\n\t\ttry {\n\t\t\tThread.sleep(100);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t}\n//--------------------------------------------------\t\n//下面代码省略\n}\n\n```\n\n---\n\n## 二、线程的生命周期\n\n![线程的生命周期]($resource/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)\n\n---\n\n## 三、线程的共享资源问题\n\n以动物园买票为示例：\n一共有 50张票 3个窗口同时售卖\n这里隐含多线程，这里可以把3个窗口看做是3个线程\n\n- 第一次问题:\n发现票每一张都被买了三次\n  - 原因：\n因为Ticket是在每一个线程中run方法里面的一个局部变量，这个局部变量是每一个线程对象都拥有的,这里Ticket就是不在是一个共享资源\n  - 处理方式：\n把Ticket变成成员变量\n\n- 第二次问题：\n发现貌似每一张票还都是卖了50次，而且这里还优化了售卖的算法\n  - 原因：\n这里Ticket变成了一个成员变量，在每一个线程对象中，都拥有这个Ticket成员变量，每一个成员变量是一个独立的个体，不是共享资源\n  - 处理方式:\n用static修饰ticket成员变量，变成一个存放在数据共享区的一个静态成员变量\n\n- 第三次问题：\n发现会出现几张票是买了多次的\n  - 原因：\n因为窗口1在卖票的时候，还没有运行到ticket--这条语句的时候，下一个窗口2开始执行卖票算法\n这里窗口2卖的票是窗口1还没有ticket--的票\n![线程安全问题]($resource/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.png)\n处理方式：\n上锁，锁门\n\n- **Java中的线程同步机制**：\n方式1：\n同步代码块：\n\n```java\nsynchronized (锁对象) {\n  //需要同步的代码;\n}\n```\n同步代码块的注意事项：\n1. 锁对象，可以是任意的一个对象， 但是必须是同一个对象！！！不能在这里使用new 来创建匿名对象\n2. sleep() 不会释放锁对象，不会开锁。例如： 厕所有人关门睡着了\n3. 使用synchronized 同步代码块的时候，必须是真正意义上存在共享资源的线程问题，才会使用\n而且通常情况下，用synchronized锁住的代码越少越好，提高代码执行效率\n```java\npackage com.qfedu.a_thread;\n\n\nclass SaleTicket extends Thread {\n  private static int ticket = 50;\n\n\tpublic SaleTicket(String name) {\n\t\tsuper(name);\n\t}\n\n\t@Override\n\tpublic void run() {\n\n\t\twhile (true) {\n\t\t\tsynchronized (\"你好\") { \n\t\t\t//可以使用\"你好 \"的任何确定的对象 \n\t\t\t//不能使用new Demo3()创建不同对象，即对应不同的锁 \n\t\t\t\tif (ticket > 0) {\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName()+\n\t\t\t\t\t\":卖出来第\" + ticket+ \"张票\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsleep(500); //睡眠也不会释放锁对象\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"卖完了\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tticket--;\n\t\t\t}\n\t\t}\n\t}\n}\n\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n\t\tSaleTicket s1 = new SaleTicket(\"窗口1\");\n\t\tSaleTicket s2 = new SaleTicket(\"窗口2\");\n\t\tSaleTicket s3 = new SaleTicket(\"窗口3\");\n\n\t\ts2.start();\n\t\ts1.start();\n\t\ts3.start();\n\n\t}\n}\n```\n程序运行结果：\n```java\n窗口1:卖出来第50张票\n窗口1:卖出来第49张票\n。。。。。\n窗口3:卖出来第28张票\n窗口3:卖出来第27张票\n窗口3:卖出来第26张票\n窗口3:卖出来第2张票\n窗口3:卖出来第1张票\n卖完了\n卖完了\n卖完了\n```\n\n### （一）死锁\n- 出现死锁的原因：\n  \t1.存在两个或两个以上的共享资源\n  \t2.存在两个或者两个以上的线程使用这些共享资源\n下面的代码会出现死锁；\n```java\npackage com.qfedu.a_thread;\nclass DeadLock extends Thread {\n\tpublic DeadLock(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tif (Thread.currentThread().getName().equals(\"小胖\")) {\n\t\t\tsynchronized (\"电池\") {\n\t\t\t\tSystem.out.println(\"小胖有电池，想要遥控器\");\n\t\t\t\t\n\t\t\t\tsynchronized (\"遥控器\") {\n\t\t\t\t\tSystem.out.println(\"小胖拿到了遥控器，打开了投影仪\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Thread.currentThread().getName().equals(\"逗比\")) {\n\t\t\tsynchronized (\"遥控器\") {\n\t\t\t\tSystem.out.println(\"逗比有遥控器，想要电池\");\n\t\t\t\t\n\t\t\t\tsynchronized (\"电池\") {\n\t\t\t\t\tSystem.out.println(\"逗比拿到了电池，打开了投影仪\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t}\n}\n\npublic class Demo4 {\n\tpublic static void main(String[] args) {\n\t\tDeadLock d1 = new DeadLock(\"小胖\");\n\t\tDeadLock d2 = new DeadLock(\"逗比\");\n\t\t\n\t\td1.start();\n\t\td2.start();\t\t\n\t}\n}\n```\n输出结果：\n```java\n小胖有电池，想要遥控器\n逗比有遥控器，想要电池\n```\n\n### （二）自定义线程\nJava语言是一种单继承，多实现【遵从】面向对象的语言\n- 自定义线程的方式：\n  - 方式1：\n\t1.自定义一个类，继承Thread类\n\t2.重写Thread里面的run方法，把线程的功能代码放入到run方法中\n\t3.创建自定义线程类对象\n\t4.开启线程，使用start方法\n    - 弊端：\n\t因为Java是一个单继承的语言，一旦某一个类继承了Thread类，就无法再继承其他类，或者说一个类继承了其他类，也就没有办法继承Thread类\n\n  - 方式2:  **强烈推荐**\n\t【遵从】Runnable接口实现自定线程类\n\t1.自定义一个类，【遵从】Runnable接口\n\t2.实现Runnable接口中唯一要求的方法 Run方法，把线程的功能代码写入到run方法中\n\t3.创建Thread类对象，并且把【遵从】Runnable接口的自定义类对象，作为参数传入到Thread构造方法中\n\t4.调用Thread类对象的start方法，开启线程\n\n```java\npackage com.qfedu.a_thread;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\nclass TestRunnable implements Runnable {\n\n\t//实现自定义线程类，遵从Runnable接口要求实现的Run方法，把线程代码写入到Runnable里面\n\t@Override\n\tpublic void run() {\n\t\tfor (int i = 0 ; i < 10; i++) {\n\t\t\tSystem.out.println(\"当前线程为:\" + Thread.currentThread());\n\t\t}\n\t}\t\n}\n\npublic class Demo5 {\n\tpublic static <T> void main(String[] args) {\n\t\t//创建Thread类对象，调用Thread构造方法中，需要传入Runnable接口实现类对象的方法~\n\t\t//方法一：\n\t\tThread t1 = new Thread(new TestRunnable());//匿名对象\n\n\t\t//方法二：\n\t\tThread t2 = new Thread(new Runnable() { //匿名内部类的匿名对象，不再需要定义上面的TestRunnable类 \n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tSystem.out.println(\"匿名内部类的匿名对象，作为方法的参数，这里是作为线程对象的参数\" + \n\t\t\t\t\t\t\tThread.currentThread());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tt1.start();\n\t\tt2.start();\n\t\t\n\t\t/*\n\t\ttarget是在创建Thread类对象时候，传入的【遵从】Runnable接口的实现类，这个实现类中\n\t\t实现类【遵从】Runnable接口要求实现的run方法，在run方法中，就是定义的线程代码\n\t\t在Thread类中有一个成员变量\n\t\t//What will be run\n\t\tprivate Runnable target; \n\t\t\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif (target != null) {\n\t\t\t\ttarget.run();\n\t\t\t}\n\t\t}\n\t\t*/\n\t}\n}\n```\n\n##  三、守护线程(后台线程) \n\n例如：\n软件的Log日志文件，软件的自动更新，软件的自动下载\n\n特征：\n如果整个程序再运行过程中，只剩下一个守护线程，那么这个守护线程也就没有意义了，会自动停止\n\nJVM的垃圾回收机制是守护线程。\n\n这里当主线程停止，则下载也会自动停止；\n```java\npackage com.qfedu.a_thread;\n\npublic class Demo6 extends Thread {\n\t\n\tpublic Demo6(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t//模拟后台下载更新的线程\n\t@Override\n\tpublic void run() {\n\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\tSystem.out.println(\"软件更新下载中………………\" + i + \"%\");\n\t\t\t\n\t\t\tif (i == 100) {\n\t\t\t\tSystem.out.println(\"软件更新下载完成，是否安装~~\");\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tThread.sleep(10);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tDemo6 d = new Demo6(\"后台线程\");\n\t\t\n\t\t//设置当前线程为守护线程或者是后台线程\n\t\td.setDaemon(true);//true为守护线程\n\t\t\n\t\t//System.out.println(d.isDaemon());\n\t\td.start();\n\t\tfor (int i = 0; i <= 50; i++) {\n\t\t\tThread.sleep(10);\n\t\t\tSystem.out.println(\"主线程:\" + i);\n\t\t}\n\t}\n}\n```\n\n## 四、线程通讯\n- 线程通讯:\n\t一个线程完成任务之后，通知另一个线程来完成该线程应该执行的任务\n\t\n生产者和消费者问题:这里商品是两个线程直接的共享资源\n\nwait(); 等待，如果一个线程执行了wait方法，那么这个线程就会进入临时阻塞状态，等待唤醒，这个唤醒必须其他线程调用notify() 方法唤醒;\nnotify(); 唤醒，唤醒线程池中进入【临时阻塞状态】的一个线程\n\n- 注意事项：\n1. wait()和notify()这两个方法都是Object类的方法\n2. 在消费者生产者模式下，锁对象只能是商品；\n```java\npackage com.qfedu.a_thread;\n\n//两者之间的共享资源\nclass Product {\n\tString name; //商品的名字\n\tint price; //价格\n\t\n\tboolean flag = false; //产品是否生产成功，如果成功flag设置为true，消费者购买之后，设置为false\n}\n\nclass Producer extends Thread {\n\tProduct p;  //商品的类对象，是和消费者之间的共享资源\n\t\n\tpublic Producer(Product p) {\n\t\tthis.p = p;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tint count = 0;\n\t\twhile (true) {\n\t\t\tsynchronized (p) {\n\t\t\t\ttry {\n\t\t\t\t\tsleep(100);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (!p.flag) { //p.flag == false\n\t\t\t\t\t\n\t\t\t\t\t//商品不存在，生产过程\n\t\t\t\t\tif (count % 2 == 0) {\n\t\t\t\t\t\tp.name = \"红辣椒擀面皮\";\n\t\t\t\t\t\tp.price = 5;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp.name = \"唐风阁肉夹馍\";\n\t\t\t\t\t\tp.price = 10;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcount++;\n\t\t\t\t\tSystem.out.println(\"生产者生产了:\" + p.name + \":\" + p.price);\n\t\t\t\t\tp.flag = true;\n\t\t\t\t\t//生产结束，唤醒消费者\n\t\t\t\t\tp.notify();\n\t\t\t\t} else {\n\t\t\t\t\t//商品存在，要求消费者来购买，生产者进入临时阻塞\n\t\t\t\t\ttry {\n\t\t\t\t\t\tp.wait();\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t} // try - catch\n\t\t\t\t}// if - else\n\t\t\t} // 同步代码块\n\t\t}// while (true)\n\t} //run()\n}\n\nclass Customer extends Thread {\n\tProduct p; //商品类对象，是和生产者之间的共享资源\n\t\n\tpublic Customer(Product p) {\n\t\tthis.p = p;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tsynchronized (p) {\n\t\t\t\ttry {\n\t\t\t\t\tsleep(100);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (p.flag) { //p.flag == true \n\t\t\t\t\t//这里表示商品存在\n\t\t\t\t\tSystem.out.println(\"消费者购买了:\" + p.name + \":\" + p.price);\n\t\t\t\t\t\n\t\t\t\t\tp.flag = false; //表示消费者购买完毕，要求生产者生产\n\t\t\t\t\t//需要唤醒生产者\n\t\t\t\t\tp.notify(); //打开线程锁\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//商品不存在，消费者进入临时阻塞\n\t\t\t\t\t\tp.wait();\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t} // try - catch\n\t\t\t\t}// if - else \n\t\t\t} //同步代码块\n\t\t} // while (true)\n\t} //run()\n}\n\npublic class Demo7 {\n\tpublic static void main(String[] args) {\n\t\tProduct product = new Product();\n\t\t\n\t\tProducer p = new Producer(product);\n\t\tCustomer c = new Customer(product);\n\t\t\n\t\tp.start();\n\t\tc.start();\n\t}\n}\n\n```\n\n\n\n\n",[[1564015756742,["GJX@GJXAIOU",[[1,11274,"![可遇不可求的错误]($resource/%E5%8F%AF%E9%81%87%E4%B8%8D%E5%8F%AF%E6%B1%82%E7%9A%84%E9%94%99%E8%AF%AF.png)"]],[11274,11274],[11374,11374]]]],null,"GJX@GJXAIOU"]]}