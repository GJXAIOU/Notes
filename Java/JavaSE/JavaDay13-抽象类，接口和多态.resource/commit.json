{"compress":true,"commitItems":[["f0324bcd-d9aa-40ca-a0fe-c9733acbf732",1556505435063,"## abstract 抽象类\n    昨天的问题:\n \t    英雄联盟中，要求所有的英雄都要有QWER这四个技能，但是没有一个英雄的技能都不能一样\n \t    昨天是通过重写的方式完成这个操作，但是存在隐患，就是没有强制要求子类来重写这个方法，\n    \t这样的话就有可能导致在程序开发的过程，开发者忘记了重写这个方法，而且没有任何的提示，\n \t    也不会出现任何的编译错误，但是运行时发现，会出现不符合业务逻辑或者生活逻辑的错误\n \t\n \t【需求】\n \t\t要求继承于该类的子类，【强制】重写这些技能方法，不写就报错，将业务逻辑的问题\n \t\t提升到语法问题，错误前置\n \t\n \t【解决】\n \t\tabstract 修饰抽象类的关键字\n \t\t也是修饰抽象方法的关键字\n \t\t\n \t【注意事项】\n \t\t1. 如果一个方法用abstract修饰，那么这个方法是不能有方法体的，这个称之为【方法的声明】\n \t\t一个方法如果用abstract修饰，【要求继承该类的子类必须重写这个方法】\n \t\t\n \t\t2. 如果一个类中存在用abstract修饰的方法，那么这个类必须用abstract修饰\n \t\tThe type Hero must be an abstract class to define abstract methods\n \t\t\n \t\t3. 抽象类不能有自己的类对象\n \t\t   [WHY]\n \t\t   \t 因为在用abstract修饰的抽象类当中，有可能存在抽象方法，而抽象方法是没有方法体，不\n \t\t   \t 直到应该运行什么代码，而创建抽象类对象之后看，就会存在这样的隐患，\n \t\t   \t 所以【抽象类是没有自己的类对象】\n \t\t   \t \n \t\t4. 一个类用abstract修饰，但是不包含抽象方法，是可以的，但是你觉得有意义吗？\n \t\t        语法没有问题，但是没有实际意义\n \t\n \t【总结】\n \t\t如果一个类继承了用把abstract修饰的抽象类，那么要求该类必须【实现】抽象类中所有抽象方法\n\n## 接口\n    接口：\n\tUSB 网线RJ-45 Type-C VGA 3.5MM HDMI DisplayPort DP SIMM\n\t\n\t接口有啥用 生活中是用来 拓展当前工具的功能的 U盘 鼠标 键盘\n\t\n    代码中的接口：\n\t拓展当前类的功能，或者用来打补丁\n\n    接口用到的关键字\n   \tinterface       UI User Interface\n   \n    格式：\n   \tinterface 接口名 {\n   \t\t//拓展的内容\n   \t\t成员变量 和 成员方法\n   \t}\n   \t\n   \t接口名采用的命名法是大驼峰命名法\n  \n    【遵从】接口的关键字\n  \timplements\n  \n  \n    [发现]\n\t  [补充知识]\n\t  \tfinal 最终的 \n\t  \t\tfinal关键字可以用来修饰成员变量和局部变量，用final修饰的变量在赋值之后不能发生改变\n\t  \tfinal 如果修饰一个类\n\t  \t\t一个类用final修饰，该类不能被继承\n\t  \t\t例如： String\n\t  \tfinal 修饰一个方法呢？\n\t  \t\t不能被重写\n\t    接口中的成员方法是没有方法体\n   \n    【接口中的缺省属性】\n   \t1. 在接口中成员变量默认的缺省属性是public static final修饰，要求在定义成员变量时直接赋值\n   \t\t\t例如：USB接口在定义标准的时候，就确定USB接口的尺寸\n   \t2. 在接口中成员方法的【缺省属性】是abstract，这里是要求【遵从】接口的类来完成的方法\n   \t\t\t例如：USB接口规定了连接的方式和硬件要求\n  \n    【注意事项】\n   \t1. 在interface中定义方法，都是一个abstract修饰的方法，要求【遵从】接口的类要实现这些方法\n   \t2. 在interface中定义法成员变量都是用final修饰，只有使用权，没有赋值权\n   \t3. 一个类可以【遵从】多个接口，不同的接口用逗号隔开\n   \t\n   \tJava是一门当继承，多实现/遵从\n   \t\n## 多态\n    我总结的【多态】概念如下：\n \t父类的引用指向子类的对象，或者接口的引用指向【遵从】接口类对象\n \t\n    多态的使用注意事项：【背下】\n     \t1. 多态情况下，父类的引用调用父类和子类同名的普通成员方法，那么调用是子类的方法\n     \t2. 多态情况下，父类的引用调用父类和子类同名的普通成员变量，那么调用是父类的成员变量\n     \t3. 多态情况下，父类的引用调用父类和子类同名的【静态】成员方法，那么调用的是父类的【静态】成员方法，没什么用\n      \t4. 多态情况下，父类的引用【不能】调用子类特有的成员变量",[[1556505390850,["GJX@GJXAIOU",[[1,348,"   "]],[348,348],[351,351]]],[1556507844508,["GJX@GJXAIOU",[[-1,18,"  "],[-1,27," \t    "],[-1,76," \t    "],[-1,125,"  "],[-1,173," \t    "],[-1,220," \t"],[-1,223," \t"],[-1,230," \t\t"],[-1,272," \t\t"],[-1,288," \t"],[-1,291," \t"],[-1,298," \t\t"],[-1,320," \t\t"],[-1,336," \t\t"],[-1,340," \t"],[-1,352," \t\t"],[-1,404," \t\t"],[-1,445," \t\t"],[-1,449," \t\t"],[-1,497," \t\t"],[-1,567," \t\t"],[-1,571," \t\t"],[-1,590," \t\t   "],[-1,602," \t\t   \t "],[-1,655," \t\t   \t "],[-1,697," \t\t   \t "],[-1,722," \t\t   \t "],[-1,731," \t\t"],[-1,778," \t\t        "],[-1,805," \t"],[-1,808," \t"],[-1,815," \t\t"]],[20,866],[18,862]]],[1556508014274,["GJX@GJXAIOU",[[1,96,"**"],[1,109,"**"]],[96,109],[96,113]]],[1556508525798,["GJX@GJXAIOU",[[1,459," "]],[459,459],[460,460]]],[1556515803608,["GJX@GJXAIOU",[[1,745,"\n"]],[743,743],[744,744]]],[1556515803759,["GJX@GJXAIOU",[[1,746,"\n"]],[744,744],[745,745]]],[1556515803914,["GJX@GJXAIOU",[[1,747,"\n"]],[745,745],[746,746]]],[1556515804090,["GJX@GJXAIOU",[[1,748,"\n"]],[746,746],[747,747]]],[1556515804215,["GJX@GJXAIOU",[[1,749,"\n"]],[747,747],[748,748]]],[1556515804715,["GJX@GJXAIOU",[[1,750,"\n"]],[748,748],[749,749]]],[1556515804748,["GJX@GJXAIOU",[[1,751,"\n"]],[749,749],[750,750]]],[1556515804781,["GJX@GJXAIOU",[[1,752,"\n"]],[750,750],[751,751]]],[1556515804814,["GJX@GJXAIOU",[[1,753,"\n"]],[751,751],[752,752]]],[1556515804850,["GJX@GJXAIOU",[[1,754,"\n"]],[752,752],[753,753]]],[1556515804881,["GJX@GJXAIOU",[[1,755,"\n"]],[753,753],[754,754]]],[1556515804932,["GJX@GJXAIOU",[[1,756,"\n"]],[754,754],[755,755]]],[1556515804950,["GJX@GJXAIOU",[[1,757,"\n"]],[755,755],[756,756]]],[1556515804980,["GJX@GJXAIOU",[[1,758,"\n"]],[756,756],[757,757]]],[1556515805014,["GJX@GJXAIOU",[[1,759,"\n"]],[757,757],[758,758]]],[1556515805048,["GJX@GJXAIOU",[[1,760,"\n"]],[758,758],[759,759]]],[1556515805082,["GJX@GJXAIOU",[[1,761,"\n"]],[759,759],[760,760]]],[1556515805117,["GJX@GJXAIOU",[[1,762,"\n"]],[760,760],[761,761]]],[1556515805149,["GJX@GJXAIOU",[[1,763,"\n"]],[761,761],[762,762]]],[1556515805185,["GJX@GJXAIOU",[[1,764,"\n"]],[762,762],[763,763]]],[1556515805219,["GJX@GJXAIOU",[[1,765,"\n"]],[763,763],[764,764]]],[1556515805245,["GJX@GJXAIOU",[[1,766,"\n"]],[764,764],[765,765]]],[1556515805278,["GJX@GJXAIOU",[[1,767,"\n"]],[765,765],[766,766]]],[1556515807968,["GJX@GJXAIOU",[[1,745,"·"]],[745,745],[746,746]]],[1556515809391,["GJX@GJXAIOU",[[-1,745,"·"]],[746,746],[745,745]]],[1556515810354,["GJX@GJXAIOU",[[1,745,"```"]],[745,745],[748,748]]],[1556515810380,["GJX@GJXAIOU",[[1,748,"language\n```\n"]],[748,748],[748,756]]],[1556515811841,["GJX@GJXAIOU",[[-1,748,"language"],[1,756,"j"]],[748,756],[749,749]]],[1556515812152,["GJX@GJXAIOU",[[1,749,"va"]],[749,749],[751,751]]],[1556515813161,["GJX@GJXAIOU",[[-1,749,"va"]],[751,751],[749,749]]],[1556515813952,["GJX@GJXAIOU",[[1,749,"ava"]],[749,749],[752,752]]],[1556515814480,["GJX@GJXAIOU",[[1,753,"\n"]],[752,752],[753,753]]],[1556515815192,["GJX@GJXAIOU",[[1,754,"\n"]],[753,753],[754,754]]],[1556515816096,["GJX@GJXAIOU",[[1,754,"abstract class Hero {\n\t//成员变量\n\tint blood;\n\tint power;\n\t\n\tpublic Hero() {}\n\t\n\tpublic Hero(int blood, int power) {\n\t\tthis.blood = blood;\n\t\tthis.power = power;\n\t}\n\t\n\t/*\n\t 这里【要求】所有的英雄都有三个技能，分别是QWE，而且要求继承该Hero的子类，必须重写这三个方法\n\t 这里就可以使用abstract来修饰这些方法\n\t */\n\tabstract public void Q();\n\tabstract public void W();\n\tabstract public void E();\n\t\n\tpublic void test() {\n\t\tSystem.out.println(\"测试\");\n\t}\n}\n\nabstract class Test {\n\tpublic void test() {\n\t\tSystem.out.println(\"测试\");\n\t}\n}\n\n/*\n\tFizz类 是继承了Hero类，因为Hero中包含了三个用abstract修饰的方法\n \t那么要求在Fizz类必须【实现】这三个方法\n */\nclass Fizz extends Hero {\n\t\n\t//构造方法\n\tpublic Fizz() {}\n\t\n\tpublic Fizz(int blood, int power) {\n\t\tsuper(blood, power); //调用父类的构造方法，初始化父类的成员变量\n\t}\n\t\n\t//是实现父类中要求继承该父类的子类必须【实现】的Q方法 implement\n\t@Override\n\tpublic void Q() {\n\t\tSystem.out.println(\"淘气打击\");\n\t}\n\n\t//是实现父类中要求继承该父类的子类必须【实现】的W方法 implement\n\t@Override\n\tpublic void W() {\n\t\tSystem.out.println(\"海石三叉戟\");\n\t}\n\n\t//是实现父类中要求继承该父类的子类必须【实现】的E方法 implement\n\t@Override\n\tpublic void E() {\n\t\tSystem.out.println(\"古灵精怪\");\n\t}\t\n}\n\nclass Caitlyn extends Hero{\n\t\n\tpublic Caitlyn() {}\n\t\n\tpublic Caitlyn(int blood, int power) {\n\t\tthis.blood = blood;\n\t\tthis.power = power;\n\t}\n\n\t@Override\n\tpublic void Q() {\n\t\tSystem.out.println(\"和平使者\");\n\t}\n\t\n\t@Override\n\tpublic void W() {\n\t\tSystem.out.println(\"约德尔诱捕器\");\n\t}\n\t\n\t@Override\n\tpublic void E() {\n\t\tSystem.out.println(\"90口径绳网\");\n\t}\n}\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tFizz fizz = new Fizz(100, 100);\n\t\t\n\t\tfizz.Q();\n\t\tfizz.W();\n\t\tfizz.E();\n\t\tfizz.test();\n\t\t\n\t\tCaitlyn caitlyn = new Caitlyn(100, 100);\n\t\t\n\t\tcaitlyn.Q();\n\t\tcaitlyn.W();\n\t\tcaitlyn.E();\n\t\tcaitlyn.test();\n\t\t\n\t\t//Hero h = new Hero();\n\t}\n}\n"]],[754,754],[2391,2391]]],[1556515823408,["GJX@GJXAIOU",[[-1,808,"\t"],[1,809,"\n"]],[809,809],[809,809]]],[1556515824152,["GJX@GJXAIOU",[[1,809,"/"]],[809,809],[810,810]]],[1556515825719,["GJX@GJXAIOU",[[-1,809,"/"]],[810,810],[809,809]]],[1556515839282,["GJX@GJXAIOU",[[1,809,"    // 在含有继承的父类中一把"]],[809,809],[827,827]]],[1556515840447,["GJX@GJXAIOU",[[-1,825,"一把"]],[827,827],[825,825]]],[1556515853724,["GJX@GJXAIOU",[[1,825,"一般提供两个构造方法：一个为空，="]],[825,825],[842,842]]],[1556515855767,["GJX@GJXAIOU",[[-1,836,"一个为空，="]],[842,842],[836,836]]],[1556515857670,["GJX@GJXAIOU",[[1,836,"其中一个"]],[836,836],[840,840]]],[1556515861052,["GJX@GJXAIOU",[[1,840,"为空"]],[840,840],[842,842]]],[1556516540431,["GJX@GJXAIOU",[[1,2452,"\n"]],[2428,2428],[2429,2429]]],[1556516540576,["GJX@GJXAIOU",[[1,2453,"\n"]],[2429,2429],[2430,2430]]],[1556516540904,["GJX@GJXAIOU",[[1,2454,"\n"]],[2430,2430],[2431,2431]]],[1556516557330,["GJX@GJXAIOU",[[1,2431,"··"]],[2431,2431],[2433,2433]]],[1556516558785,["GJX@GJXAIOU",[[-1,2431,"··"]],[2433,2433],[2431,2431]]],[1556516561361,["GJX@GJXAIOU",[[1,2431,"```"]],[2431,2431],[2434,2434]]],[1556516561388,["GJX@GJXAIOU",[[1,2434,"language\n```\n"]],[2434,2434],[2434,2442]]],[1556516562625,["GJX@GJXAIOU",[[-1,2434,"language"],[1,2442,"j"]],[2434,2442],[2435,2435]]],[1556516563040,["GJX@GJXAIOU",[[1,2435,"ava"]],[2435,2435],[2438,2438]]],[1556516565040,["GJX@GJXAIOU",[[1,2439,"\n"]],[2438,2438],[2439,2439]]],[1556516566495,["GJX@GJXAIOU",[[1,2439,"package com.qfedu.a_abstract;\n\n/*\n 需求：\n  \t描述一个图形类 Shape类，要求所有继承\n  \t于该类的子类都要有 计算周长 和 面积的方法\n  \t\n  \t实现shape类\n  \t实现继承月shape类的 圆类 方块 三角\n */\n\nabstract class Shape {\n\tabstract public float perimeter();\n\tabstract public float square();\n}\n\nclass MyCircle extends Shape {\n\t\n\tprivate float r;\n\tprivate float PI = 3.1415926f;\n\t\n\tpublic MyCircle() {}\n\t\n\tpublic MyCircle(float r) {\n\t\tif (r <= 0) {\n\t\t\tthis.r = 1;\n\t\t} else {\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\t@Override\n\tpublic float perimeter() {\n\t\treturn 2 * r * PI;\n\t}\n\n\t@Override\n\tpublic float square() {\n\t\treturn r * r * PI;\n\t}\t\n}\n\nclass Rect extends Shape {\n\n\tfloat length;\n\tfloat width;\n\t\n\tpublic Rect() {}\n\t\n\tpublic Rect(int length, float width) {\n\t\tthis.length = length;\n\t\tthis.width = width;\n\t}\n\t\n\t@Override\n\tpublic float perimeter() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic float square() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\t\n}\n\nclass Triangle extends Shape {\n\tfloat l1;\n\tfloat l2;\n\tfloat l3;\n\t\n\tpublic Triangle() {}\n\t\n\tpublic Triangle(float l1, float l2, float l3) {\n\t\tif (l1 < (l2 + l3) && l2 < (l1 + l3) && l3 < (l1 + l2)) {\n\t\t\tthis.l1 = l1;\n\t\t\tthis.l2 = l2;\n\t\t\tthis.l3 = l3;\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"错了！！！\");\n\t\t}\n\t}\n\t\n\t\n\t@Override\n\tpublic float perimeter() {\n\t\treturn l1 + l2 + l3;\n\t}\n\n\t@Override\n\tpublic float square() {\n\t\tfloat p = (l1 + l2 + l3) / 2;\n\t\t\n\t\treturn (float) Math.sqrt(p * (p - l1) * (p - l2) * (p - l3));\n\t\t\n\t}\n\t\n}\n\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\t\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[2439,2439],[3968,3968]]],[1556516574867,["GJX@GJXAIOU",[[-1,3952,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[3951,3968],[3951,3951]]],[1556516575808,["GJX@GJXAIOU",[[-1,3951,"\n"]],[3951,3951],[3950,3950]]],[1556519934942,["GJX@GJXAIOU",[[-1,4869,"   \t"],[1,4873,"\n"]],[4873,4873],[4870,4870]]],[1556519935078,["GJX@GJXAIOU",[[1,4871,"\n"]],[4870,4870],[4871,4871]]],[1556519935207,["GJX@GJXAIOU",[[1,4872,"\n"]],[4871,4871],[4872,4872]]],[1556519935318,["GJX@GJXAIOU",[[1,4873,"\n"]],[4872,4872],[4873,4873]]],[1556519935440,["GJX@GJXAIOU",[[1,4874,"\n"]],[4873,4873],[4874,4874]]],[1556519935557,["GJX@GJXAIOU",[[1,4875,"\n"]],[4874,4874],[4875,4875]]],[1556519938672,["GJX@GJXAIOU",[[1,4871,"```"]],[4871,4871],[4874,4874]]],[1556519938702,["GJX@GJXAIOU",[[1,4874,"language\n```\n"]],[4874,4874],[4874,4882]]],[1556519940007,["GJX@GJXAIOU",[[-1,4874,"language"],[1,4882,"j"]],[4874,4882],[4875,4875]]],[1556519940223,["GJX@GJXAIOU",[[1,4875,"v"]],[4875,4875],[4876,4876]]],[1556519940351,["GJX@GJXAIOU",[[1,4876,"a"]],[4876,4876],[4877,4877]]],[1556519941382,["GJX@GJXAIOU",[[-1,4875,"va"]],[4877,4877],[4875,4875]]],[1556519942112,["GJX@GJXAIOU",[[1,4875,"ava"]],[4875,4875],[4878,4878]]],[1556519942726,["GJX@GJXAIOU",[[1,4879,"\n"]],[4878,4878],[4879,4879]]],[1556519942838,["GJX@GJXAIOU",[[1,4880,"\n"]],[4879,4879],[4880,4880]]],[1556519943918,["GJX@GJXAIOU",[[1,4880,"interface A {\n\t//成员变量\n\tint num = 10; //【缺省属性】public static final\n\t//成员方法\n\tpublic void testA(); //【缺省属性】abstract\n}\n\ninterface B {\n\tpublic void testB();\n}\n\n//这里使用implements关键字来遵从接口\npublic class Demo1 implements A, B {\n\n\t@Override\n\tpublic void testA() {\n\t\tSystem.out.println(\"实现接口中要求完成的testA方法\");\n\t}\n\n\t@Override\n\tpublic void testB() {\n\t\tSystem.out.println(\"遵从接口B实现testB方法\");\n\t\t\n\t}\n\tpublic static void main(String[] args) {\n\t\tDemo1 d1 = new Demo1();\n\t\t\n\t\td1.testA(); //【遵从】接口，并且实现接口中规定的方法，调用该方法\n\t\tSystem.out.println(d1.num); //【遵从】接口，使用接口中的成员变量\n\t\t//d1.num = 200; 因为在街口定义的成员变量默认的缺省属性都是public static final \n\t\t//而final修饰的变量，里面的数据是不能发生改变的\n\t\td1.testB();\n\t}\n\n\t\n}"]],[4880,4880],[5532,5532]]],[1556520248018,["GJX@GJXAIOU",[[1,5008," "]],[5008,5008],[5009,5009]]],[1556520772106,["GJX@GJXAIOU",[[1,5539,"### tongyi "]],[5539,5539],[5550,5550]]],[1556520773631,["GJX@GJXAIOU",[[-1,5543,"tongyi "]],[5550,5550],[5543,5543]]],[1556520777023,["GJX@GJXAIOU",[[1,5543,"统一接口"]],[5543,5543],[5547,5547]]],[1556520777380,["GJX@GJXAIOU",[[1,5551,"\n"]],[5547,5547],[5548,5548]]],[1556520791787,["GJX@GJXAIOU",[[1,5549,"·"]],[5549,5549],[5550,5550]]],[1556520793473,["GJX@GJXAIOU",[[-1,5549,"·"]],[5550,5550],[5549,5549]]],[1556520794708,["GJX@GJXAIOU",[[1,5549,"```"]],[5549,5549],[5552,5552]]],[1556520794737,["GJX@GJXAIOU",[[1,5552,"language\n```\n"]],[5552,5552],[5552,5560]]],[1556520796596,["GJX@GJXAIOU",[[-1,5552,"language"],[1,5560,"j"]],[5552,5560],[5553,5553]]],[1556520797304,["GJX@GJXAIOU",[[1,5553,"ava"]],[5553,5553],[5556,5556]]],[1556520797631,["GJX@GJXAIOU",[[1,5557,"\n"]],[5556,5556],[5557,5557]]],[1556520799359,["GJX@GJXAIOU",[[1,5557,"package com.qfedu.c_duotai;\n\n/*\n 一个动物园：\n \tAnimal\n  \t\tMonkey\n  \t\tTiger\n  \t\tSnake\n  \t\t\n  \t限制需要对所有的动物进行喂食\n  \t\n  \t发现，每一个东西都有一个喂食的方式，而且喂食得方式其实都一样的\n  \t归纳总结的思想：能不能把这些方法放到一起啊\n  \t\n  \t思考：能不能实现一个喂食动物的方法\n  \t\n  \t喂食动物，要确定操作的是哪一个类\n  \t\n  \tAnimal类\n  \t\n  \t发现：\n  \t\t这里要求传入对象是Animal类对象的方法，传入Animal的子类对象也可以，没有任何的报错和提示\n  \t\t直接可以运行\n  \t\t\n  \t\t从生活角度分析，猴子，老虎和蛇都是动物，那么喂食动物的方法，他们也适用\n  \t\t\n  \t发现：\n  \t\t在方法中如果需要的参数是一个类对象，那么在这个参数中传入该类的【子类】对象也可以\n  \t\t例如：\n  \t\t\teat(Animal a) \n  \t\t\t传入Monkey m 方法正常运行\n */\nclass Animal {\n\tint age; \n\t\n\tpublic Animal() {}\n\t\n\tpublic Animal(int age) {\n\t\tthis.age = age;\n\t}\t\n\t\n\tpublic void eat(Animal a) {\n\t\tSystem.out.println(a.getClass() + \"再吃东西\");\n\t}\n\t\n\tpublic Animal tellMyWhoAreYou(Animal a) {\n\t\tSystem.out.println(a.getClass());\n\t\treturn a;\n\t}\n}\n\nclass Monkey extends Animal {\n\t\n}\n\nclass Tiger extends Animal {\n\n}\n\nclass Snake extends Animal {\n\t\n}\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tMonkey m = new Monkey();\n\t\tm.eat(m);\n\t\n\t\tTiger t = new Tiger();\n\t\tt.eat(t);\n\t\t\n\t\tSnake s = new Snake();\n\t\ts.eat(s);\n\t\t\n\t\tAnimal a = new Animal();\n\t\t\n\t\ta.eat(m); //这里需求的是一个Animal 的类对象，但是传入的是一个Monkey类对象，\n\t\t\t\t  //Monkey类和Animal类直接关系是，Monkey 是 Animal的一个子类\n\t\ta.eat(t);\n\t\ta.eat(s);\n\t\t\n\t\t\n\t\tMonkey ma = (Monkey) a.tellMyWhoAreYou(m);\n\t\tSystem.out.println(ma);\n\t\t\n\t\tSnake ms = (Snake) a.tellMyWhoAreYou(s);\n\t\tTiger mt = (Tiger) a.tellMyWhoAreYou(t);\n\t}\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n"]],[5557,5557],[6924,6924]]],[1556520907870,["GJX@GJXAIOU",[[1,6745,"//yuanl"]],[6745,6745],[6752,6752]]],[1556520909220,["GJX@GJXAIOU",[[-1,6747,"yuanl"]],[6752,6752],[6747,6747]]],[1556520914743,["GJX@GJXAIOU",[[1,6747,"原来的对象"]],[6747,6747],[6752,6752]]],[1556520916115,["GJX@GJXAIOU",[[-1,6750,"对象"]],[6752,6752],[6750,6750]]],[1556520946303,["GJX@GJXAIOU",[[1,6750,"表达式：Animal ma = a.tellMyWhoASre"]],[6750,6750],[6781,6781]]],[1556520948059,["GJX@GJXAIOU",[[-1,6778,"Sre"]],[6781,6781],[6778,6778]]],[1556520952681,["GJX@GJXAIOU",[[1,6778,"reYou()"]],[6778,6778],[6785,6785]]],[1556520953870,["GJX@GJXAIOU",[[1,6784,"s"]],[6784,6784],[6785,6785]]],[1556520955976,["GJX@GJXAIOU",[[1,6786,";"]],[6786,6786],[6787,6787]]],[1556521178167,["GJX@GJXAIOU",[[1,6787," "]],[6787,6787],[6788,6788]]],[1556521509042,["GJX@GJXAIOU",[[-1,5539,"### 统一接口\n\n```java\npackage com.qfedu.c_duotai;\n\n/*\n 一个动物园：\n \tAnimal\n  \t\tMonkey\n  \t\tTiger\n  \t\tSnake\n  \t\t\n  \t限制需要对所有的动物进行喂食\n  \t\n  \t发现，每一个东西都有一个喂食的方式，而且喂食得方式其实都一样的\n  \t归纳总结的思想：能不能把这些方法放到一起啊\n  \t\n  \t思考：能不能实现一个喂食动物的方法\n  \t\n  \t喂食动物，要确定操作的是哪一个类\n  \t\n  \tAnimal类\n  \t\n  \t发现：\n  \t\t这里要求传入对象是Animal类对象的方法，传入Animal的子类对象也可以，没有任何的报错和提示\n  \t\t直接可以运行\n  \t\t\n  \t\t从生活角度分析，猴子，老虎和蛇都是动物，那么喂食动物的方法，他们也适用\n  \t\t\n  \t发现：\n  \t\t在方法中如果需要的参数是一个类对象，那么在这个参数中传入该类的【子类】对象也可以\n  \t\t例如：\n  \t\t\teat(Animal a) \n  \t\t\t传入Monkey m 方法正常运行\n */\nclass Animal {\n\tint age; \n\t\n\tpublic Animal() {}\n\t\n\tpublic Animal(int age) {\n\t\tthis.age = age;\n\t}\t\n\t\n\tpublic void eat(Animal a) {\n\t\tSystem.out.println(a.getClass() + \"再吃东西\");\n\t}\n\t\n\tpublic Animal tellMyWhoAreYou(Animal a) {\n\t\tSystem.out.println(a.getClass());\n\t\treturn a;\n\t}\n}\n\nclass Monkey extends Animal {\n\t\n}\n\nclass Tiger extends Animal {\n\n}\n\nclass Snake extends Animal {\n\t\n}\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tMonkey m = new Monkey();\n\t\tm.eat(m);\n\t\n\t\tTiger t = new Tiger();\n\t\tt.eat(t);\n\t\t\n\t\tSnake s = new Snake();\n\t\ts.eat(s);\n\t\t\n\t\tAnimal a = new Animal();\n\t\t\n\t\ta.eat(m); //这里需求的是一个Animal 的类对象，但是传入的是一个Monkey类对象，\n\t\t\t\t  //Monkey类和Animal类直接关系是，Monkey 是 Animal的一个子类\n\t\ta.eat(t);\n\t\ta.eat(s);\n\t\t\n\t\t//原来的表达式：Animal ma = a.tellMyWhoAreYou(s); \n\t\tMonkey ma = (Monkey) a.tellMyWhoAreYou(m);\n\t\tSystem.out.println(ma);\n\t\t\n\t\tSnake ms = (Snake) a.tellMyWhoAreYou(s);\n\t\tTiger mt = (Tiger) a.tellMyWhoAreYou(t);\n\t}\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n```\n"]],[5539,6972],[5539,5539]]],[1556521511625,["GJX@GJXAIOU",[[1,5548,"\n"]],[5547,5547],[5548,5548]]],[1556521511778,["GJX@GJXAIOU",[[1,5549,"\n"]],[5548,5548],[5549,5549]]],[1556521511932,["GJX@GJXAIOU",[[1,5550,"\n"]],[5549,5549],[5550,5550]]],[1556521513467,["GJX@GJXAIOU",[[1,5550,"### 统一接口\n\n```java\npackage com.qfedu.c_duotai;\n\n/*\n 一个动物园：\n \tAnimal\n  \t\tMonkey\n  \t\tTiger\n  \t\tSnake\n  \t\t\n  \t限制需要对所有的动物进行喂食\n  \t\n  \t发现，每一个东西都有一个喂食的方式，而且喂食得方式其实都一样的\n  \t归纳总结的思想：能不能把这些方法放到一起啊\n  \t\n  \t思考：能不能实现一个喂食动物的方法\n  \t\n  \t喂食动物，要确定操作的是哪一个类\n  \t\n  \tAnimal类\n  \t\n  \t发现：\n  \t\t这里要求传入对象是Animal类对象的方法，传入Animal的子类对象也可以，没有任何的报错和提示\n  \t\t直接可以运行\n  \t\t\n  \t\t从生活角度分析，猴子，老虎和蛇都是动物，那么喂食动物的方法，他们也适用\n  \t\t\n  \t发现：\n  \t\t在方法中如果需要的参数是一个类对象，那么在这个参数中传入该类的【子类】对象也可以\n  \t\t例如：\n  \t\t\teat(Animal a) \n  \t\t\t传入Monkey m 方法正常运行\n */\nclass Animal {\n\tint age; \n\t\n\tpublic Animal() {}\n\t\n\tpublic Animal(int age) {\n\t\tthis.age = age;\n\t}\t\n\t\n\tpublic void eat(Animal a) {\n\t\tSystem.out.println(a.getClass() + \"再吃东西\");\n\t}\n\t\n\tpublic Animal tellMyWhoAreYou(Animal a) {\n\t\tSystem.out.println(a.getClass());\n\t\treturn a;\n\t}\n}\n\nclass Monkey extends Animal {\n\t\n}\n\nclass Tiger extends Animal {\n\n}\n\nclass Snake extends Animal {\n\t\n}\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tMonkey m = new Monkey();\n\t\tm.eat(m);\n\t\n\t\tTiger t = new Tiger();\n\t\tt.eat(t);\n\t\t\n\t\tSnake s = new Snake();\n\t\ts.eat(s);\n\t\t\n\t\tAnimal a = new Animal();\n\t\t\n\t\ta.eat(m); //这里需求的是一个Animal 的类对象，但是传入的是一个Monkey类对象，\n\t\t\t\t  //Monkey类和Animal类直接关系是，Monkey 是 Animal的一个子类\n\t\ta.eat(t);\n\t\ta.eat(s);\n\t\t\n\t\t//原来的表达式：Animal ma = a.tellMyWhoAreYou(s); \n\t\tMonkey ma = (Monkey) a.tellMyWhoAreYou(m);\n\t\tSystem.out.println(ma);\n\t\t\n\t\tSnake ms = (Snake) a.tellMyWhoAreYou(s);\n\t\tTiger mt = (Tiger) a.tellMyWhoAreYou(t);\n\t}\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n```\n"]],[5550,5550],[6983,6983]]],[1556521531513,["GJX@GJXAIOU",[[1,6984,"\n"]],[6983,6983],[6984,6984]]],[1556521531666,["GJX@GJXAIOU",[[1,6985,"\n"]],[6984,6984],[6985,6985]]],[1556521533200,["GJX@GJXAIOU",[[1,6985,"```"]],[6985,6985],[6988,6988]]],[1556521533232,["GJX@GJXAIOU",[[1,6988,"language\n```\n"]],[6988,6988],[6988,6996]]],[1556521534413,["GJX@GJXAIOU",[[-1,6988,"language"],[1,6996,"j"]],[6988,6996],[6989,6989]]],[1556521534901,["GJX@GJXAIOU",[[1,6989,"ava"]],[6989,6989],[6992,6992]]],[1556521535195,["GJX@GJXAIOU",[[1,6993,"\n"]],[6992,6992],[6993,6993]]],[1556521536289,["GJX@GJXAIOU",[[1,6993,"package com.qfedu.c_duotai;\n\n//规定一个USB接口。在USB接口中要求所有的USB设备要完成connect()\ninterface USB {\n\tpublic void connect();\n}\n\n//U盘【遵从】了USB接口，实现了connect方法\nclass UPan implements USB {\n\t@Override\n\tpublic void connect() {\n\t\tSystem.out.println(\"U盘连接电脑，传输数据\");\n\t}\n}\n\n//键盘【遵从】了USB接口，实现了connect方法\nclass Keyboard implements USB {\n\t@Override\n\tpublic void connect() {\n\t\tSystem.out.println(\"推荐filco键盘，有且是茶轴\");\n\t}\n}\n\nclass Computer {\n\t//电脑上留有一个USB接口，但是是什么设备来使用USB不确定，更具谁要连接来确定，但是连接的设备\n\t//必须【遵从】USB接口\n\tpublic void USBConnect(USB usb) {\n\t\tusb.connect();\n\t}\n}\n\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tComputer MBP = new Computer();\n\t\t\n\t\t//传入的是一个【遵从】USB接口的 U盘匿名对象\n\t\tMBP.USBConnect(new UPan());\n\t\t\n\t\t//传入的是一个【遵从】USB接口的键盘匿名对象\n\t\tMBP.USBConnect(new Keyboard());\n\t\t\n\t\t/*\n\t\t 定义的形式参数是一个接口，但是传入的是【遵从】接口的类对象 \n\t\t */\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[6993,6993],[7812,7812]]],[1556521541745,["GJX@GJXAIOU",[[-1,7803,"\n\n\n\n\n\n\n\n\n\n"]],[7802,7812],[7802,7802]]],[1556525409551,["GJX@GJXAIOU",[[1,8078,"\n      \t5. "]],[8078,8078],[8089,8089]]],[1556525409692,["GJX@GJXAIOU",[[-1,8079,"      \t5. "],[1,8089,"\n\n"]],[8089,8089],[8080,8080]]],[1556525409830,["GJX@GJXAIOU",[[1,8081,"\n"]],[8080,8080],[8081,8081]]],[1556525411223,["GJX@GJXAIOU",[[-1,8081,"\n"],[1,8082,"`"]],[8081,8081],[8082,8082]]],[1556525412503,["GJX@GJXAIOU",[[1,8082,"``"]],[8082,8082],[8084,8084]]],[1556525412532,["GJX@GJXAIOU",[[1,8084,"language\n```\n"]],[8084,8084],[8084,8092]]],[1556525413582,["GJX@GJXAIOU",[[-1,8084,"language"],[1,8092,"j"]],[8084,8092],[8085,8085]]],[1556525415776,["GJX@GJXAIOU",[[1,8085,"ava"]],[8085,8085],[8088,8088]]],[1556525418575,["GJX@GJXAIOU",[[1,8089,"\n"]],[8088,8088],[8089,8089]]],[1556525420892,["GJX@GJXAIOU",[[1,8090,"\n"]],[8089,8089],[8090,8090]]],[1556525421518,["GJX@GJXAIOU",[[1,8090,"package com.qfedu.c_duotai;\n\n/*\n 从前两个代码中总结这两句话\n \t在一个方法中，需要的参数一个类对象，但是传入的参数是该类的【子类】对象，也是可以的！！！\n \t在一个方法中，定义的参数格式是一个接口，传入的参数是【遵从】该接口的对象，没有问题！！！\n \t\n 我总结的【多态】概念如下：\n \t父类的引用指向子类的对象，或者接口的引用指向【遵从】接口类对象\n \t\n多态的使用注意事项：【背下】\n \t1. 多态情况下，父类的引用调用父类和子类同名的普通成员方法，那么调用是子类的方法\n \t2. 多态情况下，父类的引用调用父类和子类同名的普通成员变量，那么调用是父类的成员变量\n \t3. 多态情况下，父类的引用调用父类和子类同名的【静态】成员方法，那么调用的是父类的【静态】成员方法，没什么用\n  \t4. 多态情况下，父类的引用【不能】调用子类特有的成员变量\n */\nclass Father {\n\tString name; //父类中的成员变量\n\tint weight = 90; //和子类同名的成员变量\n\t\n\tpublic Father() {}\n\t \n\tpublic Father(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic void game() {\n\t\tSystem.out.println(\"曼切斯特\");\n\t}\n\t\n\tpublic static void work() {\n\t\tSystem.out.println(\"机械工程师\");\n\t}\n}\n\nclass Son extends Father {\n\tint age = 16; //子类自己的成员变量 \n\tint weight = 74; // 和父类同名的成员变量\n\t\n\tpublic Son(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t@Override\n\tpublic void game() {\n\t\tSystem.out.println(\"Housten Rocket\");\n\t}\n\t\n\tpublic static void work() {\n\t\tSystem.out.println(\"逗比程序猿导师\");\n\t}\n}\n\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n//\t\tSon s = new Son(\"David\");\n//\t\ts.game();\n//\t\ts.work();\n//\t\t\n//\t\tFather f = new Father(\"Jack\");\n//\t\tf.game();\n//\t\tf.work();\n\t\t\n\t\t//父类引用指向子类的对象 【多态】\n\t\tFather ftoS = new Son(\"23333\");\n\t\t\n\t\tftoS.game();\n\t\t\n\t\tSystem.out.println(ftoS.weight);\n\t\t\n\t\tftoS.work();\n\t\t\n//\t\tSystem.out.println(ftoS.age);\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[8090,8090],[9417,9417]]],[1556525484974,["GJX@GJXAIOU",[[-1,7826," \t"],[-1,7860," \t"],[-1,7863,"  "],[-1,7882," "],[-1,7886," "],[-1,7930,"  "],[-1,7980," "],[-1,7984," "],[-1,8042,"  "]],[7828,8078],[7826,8068]]],[1556525489085,["GJX@GJXAIOU",[[-1,7877,"  "],[-1,7922,"  "],[-1,7971,"  "],[-1,8030,"  "]],[7880,8065],[7878,8057]]],[1556525489957,["GJX@GJXAIOU",[[-1,7876," \t"],[-1,7920," \t"],[-1,7966," \t"],[-1,8024,"  "]],[7878,8057],[7876,8055]]],[1556525493889,["GJX@GJXAIOU",[[-1,7859,"  "]],[7861,7861],[7859,7859]]],[1556525497622,["GJX@GJXAIOU",[[-1,8016,"\t"]],[7874,8047],[7874,8046]]],[1556525499576,["GJX@GJXAIOU",[[1,7874,"  "],[1,7916,"  "],[1,7960,"  "],[1,8016,"  "]],[7874,8046],[7874,8054]]],[1556525504969,["GJX@GJXAIOU",[[-1,7808,"    "]],[7808,7812],[7808,7808]]],[1556525557325,["GJX@GJXAIOU",[[1,7808,"\n"]],[7808,7808],[7809,7809]]],[1556526344302,["GJX@GJXAIOU",[[-1,6968,"\n\n\n\n\n\n\n\n\n\n\n"]],[6967,6978],[6967,6967]]],[1556526368195,["GJX@GJXAIOU",[[-1,5600," "],[-1,5608," \t"],[-1,5617,"  "],[-1,5628,"  "],[-1,5638,"  "],[-1,5648,"  "],[-1,5653,"  "],[-1,5671,"  "],[-1,5675,"  "],[-1,5710,"  "],[-1,5735,"  "],[-1,5739,"  "],[-1,5760,"  "],[-1,5764,"  "],[-1,5784,"  "],[-1,5788,"  "],[-1,5799,"  "],[-1,5803,"  "],[-1,5810,"  "],[-1,5864,"  "],[-1,5875,"  "],[-1,5880,"  "],[-1,5920,"  "],[-1,5925,"  "],[-1,5932,"  "],[-1,5977,"  "],[-1,5985,"  "],[-1,6005,"  "]],[5600,6027],[5600,5975]]],[1556526369040,["GJX@GJXAIOU",[[-1,5615,"\t"],[-1,5623,"\t"],[-1,5632,"\t"],[-1,5639,"\t"],[-1,5642,"\t"],[-1,5658,"\t"],[-1,5660,"\t"],[-1,5693,"\t"],[-1,5716,"\t"],[-1,5718,"\t"],[-1,5737,"\t"],[-1,5739,"\t"],[-1,5757,"\t"],[-1,5759,"\t"],[-1,5768,"\t"],[-1,5770,"\t"],[-1,5775,"\t"],[-1,5827,"\t"],[-1,5837,"\t"],[-1,5839,"\t"],[-1,5877,"\t"],[-1,5880,"\t"],[-1,5885,"\t"],[-1,5928,"\t"],[-1,5936,"\t"],[-1,5952,"\t"],[-1,5973," "]],[5600,5975],[5600,5949]]],[1556526643046,["GJX@GJXAIOU",[[-1,115,"  \t这样的话就有可能导致在程序开发的过程，开发者忘记了重写这个方法，而且没有任何的提示，\n也不会出现任何的编译错误，但是运行时发现，会出现不符合业务逻辑或者生活逻辑的错误"]],[115,201],[115,115]]],[1556526650862,["GJX@GJXAIOU",[[-1,16,"  昨天的问题:\n英雄联盟中，要求所有的英雄都要有QWER这四个技能，但是没有一个英雄的技能都不能一样\n昨天是通过重写的方式完成这个操作，但是存在隐患，就是没有**强制要求子类来重写这个方法**，"]],[16,96],[16,16]]],[1556526654350,["GJX@GJXAIOU",[[-1,18,"\n"]],[18,18],[17,17]]],[1556526654550,["GJX@GJXAIOU",[[-1,17,"\n"]],[17,17],[16,16]]],[1556526654974,["GJX@GJXAIOU",[[-1,16,"\n"]],[16,16],[15,15]]],[1556526656402,["GJX@GJXAIOU",[[-1,59,"\n"]],[60,60],[59,59]]],[1556526661935,["GJX@GJXAIOU",[[1,21,"**"],[1,44,"**"]],[21,44],[21,48]]],[1556526692422,["GJX@GJXAIOU",[[1,132,"**"],[1,160,"**"]],[132,160],[132,164]]],[1556526702350,["GJX@GJXAIOU",[[1,178,"**"],[1,215,"**"]],[178,215],[178,219]]],[1556526710039,["GJX@GJXAIOU",[[1,226,"**"],[1,265,"**"]],[226,265],[226,269]]],[1556526728287,["GJX@GJXAIOU",[[1,342,"**"],[1,354,"**"]],[342,354],[342,358]]],[1556526913762,["GJX@GJXAIOU",[[-1,359,"[WHY]"]],[359,364],[359,359]]],[1556526914326,["GJX@GJXAIOU",[[-1,359,"\n"]],[359,359],[358,358]]],[1556526928512,["GJX@GJXAIOU",[[-1,437,"\n"]],[438,438],[437,437]]],[1556526931536,["GJX@GJXAIOU",[[-1,403,"\n"]],[404,404],[403,403]]],[1556526997783,["GJX@GJXAIOU",[[-1,2432,"public "]],[2432,2439],[2432,2432]]],[1556527001599,["GJX@GJXAIOU",[[-1,2461,"public "]],[2461,2467],[2460,2460]]],[1556527102944,["GJX@GJXAIOU",[[-1,2376,"月"]],[2377,2377],[2376,2376]]],[1556527105705,["GJX@GJXAIOU",[[1,2376,"yu"]],[2376,2376],[2378,2378]]],[1556527106535,["GJX@GJXAIOU",[[-1,2376,"yu"]],[2378,2378],[2376,2376]]],[1556527109050,["GJX@GJXAIOU",[[1,2376,"于"]],[2376,2376],[2377,2377]]],[1556527491842,["GJX@GJXAIOU",[[-1,3788,"\n"]],[3782,3782],[3781,3781]]],[1556527492340,["GJX@GJXAIOU",[[-1,3787,"\n"]],[3781,3781],[3780,3780]]],[1556527492434,["GJX@GJXAIOU",[[-1,3786,"\n"]],[3780,3780],[3779,3779]]],[1556527492507,["GJX@GJXAIOU",[[-1,3785,"\n"]],[3779,3779],[3778,3778]]],[1556527492576,["GJX@GJXAIOU",[[-1,3784,"\n"]],[3778,3778],[3777,3777]]],[1556527492643,["GJX@GJXAIOU",[[-1,3783,"\n"]],[3777,3777],[3776,3776]]],[1556527492711,["GJX@GJXAIOU",[[-1,3782,"\n"]],[3776,3776],[3775,3775]]],[1556527492777,["GJX@GJXAIOU",[[-1,3781,"\n"]],[3775,3775],[3774,3774]]],[1556527492843,["GJX@GJXAIOU",[[-1,3780,"\n"]],[3774,3774],[3773,3773]]],[1556527493375,["GJX@GJXAIOU",[[-1,3779,"\n"]],[3773,3773],[3772,3772]]],[1556527493639,["GJX@GJXAIOU",[[-1,3778,"\n"]],[3772,3772],[3771,3771]]],[1556527493840,["GJX@GJXAIOU",[[-1,3777,"\n"]],[3771,3771],[3770,3770]]],[1556527495889,["GJX@GJXAIOU",[[-1,3776,"\n"]],[3770,3770],[3769,3769]]],[1556527496256,["GJX@GJXAIOU",[[-1,3775,"\n"]],[3769,3769],[3768,3768]]],[1556527496505,["GJX@GJXAIOU",[[-1,3774,"\n"]],[3768,3768],[3767,3767]]],[1556527497131,["GJX@GJXAIOU",[[-1,3773,"\n"]],[3770,3770],[3769,3769]]],[1556527497354,["GJX@GJXAIOU",[[-1,3772,"\n"]],[3769,3769],[3768,3768]]],[1556527497593,["GJX@GJXAIOU",[[-1,3771,"\n"]],[3768,3768],[3767,3767]]],[1556527497808,["GJX@GJXAIOU",[[-1,3770,"\n"]],[3767,3767],[3766,3766]]],[1556527499777,["GJX@GJXAIOU",[[-1,3769,"\n"]],[3767,3767],[3766,3766]]],[1556527501014,["GJX@GJXAIOU",[[1,3766,"---"]],[3766,3766],[3769,3769]]],[1556527518336,["GJX@GJXAIOU",[[-1,3913," "]],[3914,3914],[3913,3913]]],[1556527527288,["GJX@GJXAIOU",[[-1,3778,"    接口：\n\tUSB 网线RJ-45 Type-C VGA 3.5MM HDMI DisplayPort DP SIMM\n\t\n\t接口有啥用 生活中是用来 拓展当前工具的功能的 U盘 鼠标 键盘"]],[3778,3876],[3778,3778]]],[1556527540345,["GJX@GJXAIOU",[[-1,3783,"  "],[-1,3793,"\t"],[-1,3812,"  "],[-1,3825,"  "],[-1,3862,"  "],[-1,3868,"  "],[-1,3874,"  "],[-1,3895,"  "],[-1,3907,"  "],[-1,3925,"  "],[-1,3930,"  "],[-1,3935,"  "],[-1,3956,"  "],[-1,3959,"  "],[-1,3974,"  "],[-1,3988,"  "],[-1,3991,"  "],[-1,3994,"  "],[-1,4003,"\t"],[-1,4013,"\t"],[-1,4028,"\t"],[-1,4080,"\t"],[-1,4098,"\t"],[-1,4123,"\t"],[-1,4139,"\t"],[-1,4158,"\t"],[-1,4169,"\t"],[-1,4190,"  "],[-1,4193,"  "],[-1,4208,"  "],[-1,4269,"  "],[-1,4304,"  "],[-1,4356,"  "],[-1,4383,"  "],[-1,4386,"  "],[-1,4397,"  "],[-1,4457,"  "],[-1,4505,"  "],[-1,4537,"  "],[-1,4541,"  "]],[3784,4562],[3782,4492]]],[1556527540954,["GJX@GJXAIOU",[[-1,3781,"  "],[1,3783,""],[-1,3809," "],[-1,3819," \t"],[-1,3855," "],[-1,3857,"  "],[-1,3863," \t"],[-1,3881," \t\t"],[-1,3892," \t\t"],[-1,3907," \t"],[-1,3911," \t"],[-1,3914," \t"],[-1,3934,"  "],[-1,3947,"\t"],[-1,3961,"  "],[-1,3968,"  "],[-1,3977,"  "],[-1,3991,"  "],[-1,4042,"  "],[-1,4059,"  "],[-1,4083,"  "],[-1,4098,"  "],[-1,4116,"  "],[-1,4126,"  "],[-1,4145," "],[-1,4147,"  "],[-1,4160," \t"],[-1,4218," \t\t\t"],[-1,4251," \t"],[-1,4301," \t\t\t"],[-1,4328,"  "],[-1,4337," \t"],[-1,4394," \t"],[-1,4440," \t"],[-1,4470," \t"],[-1,4473," \t"]],[3782,4492],[3781,4461]]],[1556527559143,["GJX@GJXAIOU",[[-1,3778,"\n"]],[3779,3779],[3778,3778]]],[1556527563403,["GJX@GJXAIOU",[[-1,3814,"\n"]],[3815,3815],[3814,3814]]],[1556527565532,["GJX@GJXAIOU",[[1,3814," ·"]],[3814,3814],[3816,3816]]],[1556527566857,["GJX@GJXAIOU",[[-1,3815,"·"]],[3816,3816],[3815,3815]]],[1556527567274,["GJX@GJXAIOU",[[1,3815,"`"]],[3815,3815],[3816,3816]]],[1556527568674,["GJX@GJXAIOU",[[1,3826,"`"]],[3826,3826],[3827,3827]]],[1556527570752,["GJX@GJXAIOU",[[-1,3825," "]],[3826,3826],[3825,3825]]],[1556527574733,["GJX@GJXAIOU",[[1,3855,"\n"]],[3854,3854],[3855,3855]]],[1556527577157,["GJX@GJXAIOU",[[1,3855,"```java"]],[3855,3855],[3862,3862]]],[1556527579859,["GJX@GJXAIOU",[[1,3901,"```"]],[3901,3901],[3904,3904]]],[1556527588346,["GJX@GJXAIOU",[[-1,3933,"\n"]],[3934,3934],[3933,3933]]],[1556527590597,["GJX@GJXAIOU",[[1,3933," `"]],[3933,3933],[3935,3935]]],[1556527592077,["GJX@GJXAIOU",[[1,3945,"`"]],[3945,3945],[3946,3946]]],[1556527610623,["GJX@GJXAIOU",[[-1,3961,"\tfinal 最终的 "]],[3961,3972],[3961,3961]]],[1556527611112,["GJX@GJXAIOU",[[-1,3961,"\n"]],[3961,3961],[3960,3960]]],[1556527613208,["GJX@GJXAIOU",[[-1,3961,"\t\t"]],[3963,3963],[3961,3961]]],[1556527622224,["GJX@GJXAIOU",[[-1,4023,"\t\t一个类用final修饰，"]],[4025,4037],[4023,4023]]],[1556527622668,["GJX@GJXAIOU",[[-1,4022,"\n"]],[4023,4023],[4022,4022]]],[1556527623971,["GJX@GJXAIOU",[[1,4022,","]],[4022,4022],[4023,4023]]],[1556527626567,["GJX@GJXAIOU",[[-1,4008,"\t"]],[4008,4009],[4008,4008]]],[1556527635849,["GJX@GJXAIOU",[[1,4030,"\n"]],[4029,4029],[4030,4030]]],[1556527639488,["GJX@GJXAIOU",[[1,4030,"final xiue"]],[4030,4030],[4040,4040]]],[1556527640575,["GJX@GJXAIOU",[[-1,4036,"xiue"]],[4040,4040],[4036,4036]]],[1556527654842,["GJX@GJXAIOU",[[1,4036,"修饰一个方法，该方法不能被重写；"]],[4036,4036],[4052,4052]]],[1556527656483,["GJX@GJXAIOU",[[1,4029,"；"]],[4029,4029],[4030,4030]]],[1556527659015,["GJX@GJXAIOU",[[1,4007,"；"]],[4007,4007],[4008,4008]]],[1556527663043,["GJX@GJXAIOU",[[-1,4055,"\t\t例如： String\n\tfinal 修饰一个方法呢？\n\t\t不能被重写"]],[4055,4091],[4055,4055]]],[1556527665816,["GJX@GJXAIOU",[[-1,4057," "]],[4058,4058],[4057,4057]]],[1556527670608,["GJX@GJXAIOU",[[-1,3949,"[发现]"]],[3949,3953],[3949,3949]]],[1556527671940,["GJX@GJXAIOU",[[1,3957,"\n"]],[3956,3956],[3957,3957]]],[1556527680052,["GJX@GJXAIOU",[[1,3957,"final关键字："]],[3957,3957],[3966,3966]]],[1556527680360,["GJX@GJXAIOU",[[1,3967,"\n"]],[3966,3966],[3967,3967]]],[1556527684689,["GJX@GJXAIOU",[[1,3968,"* "],[1,4016,"* "],[1,4039,"* "]],[3968,4061],[3970,4067]]],[1556527898891,["GJX@GJXAIOU",[[-1,4395,"当"]],[4396,4396],[4395,4395]]],[1556527902204,["GJX@GJXAIOU",[[1,4395,"单"]],[4395,4395],[4396,4396]]],[1556527911148,["GJX@GJXAIOU",[[1,4405,"的语言；"]],[4405,4405],[4409,4409]]],[1556527969314,["GJX@GJXAIOU",[[-1,4552,"public "]],[4559,4559],[4552,4552]]],[1556527975636,["GJX@GJXAIOU",[[-1,4495,"public "]],[4502,4502],[4495,4495]]],[1556528031264,["GJX@GJXAIOU",[[-1,5165,"限制"]],[5167,5167],[5165,5165]]],[1556528034463,["GJX@GJXAIOU",[[1,5165,"现在"]],[5165,5165],[5167,5167]]],[1556528058730,["GJX@GJXAIOU",[[-1,5272,"\n"]],[5273,5273],[5272,5272]]],[1556528059184,["GJX@GJXAIOU",[[-1,5271,"\n"]],[5272,5272],[5271,5271]]],[1556528063166,["GJX@GJXAIOU",[[1,5271,"，只能使用"]],[5271,5271],[5276,5276]]],[1556528075986,["GJX@GJXAIOU",[[-1,5340,"\t"]],[5341,5341],[5340,5340]]],[1556528076377,["GJX@GJXAIOU",[[-1,5339,"\n"]],[5340,5340],[5339,5339]]],[1556528077559,["GJX@GJXAIOU",[[1,5339,"，"]],[5339,5339],[5340,5340]]],[1556528086201,["GJX@GJXAIOU",[[-1,5350,"从生活角度分析，猴子，老虎和蛇都是动物，那么喂食动物的方法，他们也适用"]],[5350,5385],[5350,5350]]],[1556528090747,["GJX@GJXAIOU",[[-1,5351,"\t"]],[5352,5352],[5351,5351]]],[1556528091177,["GJX@GJXAIOU",[[-1,5351,"\n"]],[5351,5351],[5350,5350]]],[1556528091577,["GJX@GJXAIOU",[[-1,5349,"\t"]],[5350,5350],[5349,5349]]],[1556528091953,["GJX@GJXAIOU",[[-1,5349,"\n"]],[5349,5349],[5348,5348]]],[1556528092388,["GJX@GJXAIOU",[[-1,5347,"\t"]],[5348,5348],[5347,5347]]],[1556528125001,["GJX@GJXAIOU",[[-1,5348,"发现：\n"]],[5347,5351],[5347,5347]]],[1556528126403,["GJX@GJXAIOU",[[-1,5347,"\n"]],[5347,5347],[5346,5346]]],[1556528138342,["GJX@GJXAIOU",[[-1,5411,"\t\t"]],[5413,5413],[5411,5411]]],[1556528138811,["GJX@GJXAIOU",[[-1,5410,"\n"]],[5411,5411],[5410,5410]]],[1556528148374,["GJX@GJXAIOU",[[1,5410,"中，将Animal a"]],[5410,5410],[5421,5421]]],[1556528150871,["GJX@GJXAIOU",[[-1,5421,"传入"]],[5423,5423],[5421,5421]]],[1556528156164,["GJX@GJXAIOU",[[1,5421,"替换成 "]],[5421,5421],[5425,5425]]],[1556528164521,["GJX@GJXAIOU",[[1,5436,"也"]],[5436,5436],[5437,5437]]],[1556528177293,["GJX@GJXAIOU",[[1,5445,"\n"]],[5444,5444],[5445,5445]]],[1556528177466,["GJX@GJXAIOU",[[1,5446,"\n"]],[5445,5445],[5446,5446]]],[1556528193292,["GJX@GJXAIOU",[[-1,5473,"\t"]],[5474,5474],[5473,5473]]],[1556528193625,["GJX@GJXAIOU",[[-1,5473,"\n"]],[5473,5473],[5472,5472]]],[1556528196733,["GJX@GJXAIOU",[[1,5474,"\n\t"]],[5472,5472],[5474,5474]]],[1556528198593,["GJX@GJXAIOU",[[-1,5495,"\t"]],[5496,5496],[5495,5495]]],[1556528198963,["GJX@GJXAIOU",[[-1,5495,"\n"]],[5495,5495],[5494,5494]]],[1556528981599,["GJX@GJXAIOU",[[1,5618," 、、"]],[5618,5618],[5621,5621]]],[1556528982027,["GJX@GJXAIOU",[[-1,5619,"、、"]],[5621,5621],[5619,5619]]],[1556528995585,["GJX@GJXAIOU",[[1,5619,"// getclass表示获取类名"]],[5619,5619],[5636,5636]]],[1556529111688,["GJX@GJXAIOU",[[1,6233,"\n\t\t"]],[6230,6230],[6233,6233]]],[1556529120182,["GJX@GJXAIOU",[[1,6233,"//********************************"]],[6233,6233],[6267,6267]]],[1556529126345,["GJX@GJXAIOU",[[1,6249,"重要"]],[6249,6249],[6251,6251]]],[1556529386220,["GJX@GJXAIOU",[[-1,6540,"public "]],[6540,6547],[6540,6540]]],[1556529497188,["GJX@GJXAIOU",[[-1,6887,"更具"]],[6889,6889],[6887,6887]]],[1556529499722,["GJX@GJXAIOU",[[1,6887,"根据"]],[6887,6887],[6889,6889]]],[1556529846053,["GJX@GJXAIOU",[[-1,7261,"我"]],[7262,7262],[7261,7261]]],[1556530226214,["GJX@GJXAIOU",[[-1,7307,"多态的使用注意事项：【背下】"]],[7317,7321],[7307,7307]]],[1556530226318,["GJX@GJXAIOU",[[-1,7307,"\n"]],[7307,7307],[7306,7306]]],[1556530226382,["GJX@GJXAIOU",[[-1,7306,"\n"]],[7306,7306],[7305,7305]]],[1556530227979,["GJX@GJXAIOU",[[-1,7284,"对象，或者接口的引用指向【遵从】接口类对象"]],[7305,7305],[7284,7284]]],[1556530232536,["GJX@GJXAIOU",[[1,7284,"对象，或者接口的引用指向【遵从】接口类对象"]],[7284,7284],[7305,7305]]],[1556530233798,["GJX@GJXAIOU",[[1,7306,"\n"]],[7305,7305],[7306,7306]]],[1556530234755,["GJX@GJXAIOU",[[1,7307,"\n"]],[7306,7306],[7307,7307]]],[1556530235419,["GJX@GJXAIOU",[[1,7307,"多态的使用注意事项：【背下】"]],[7307,7307],[7317,7321]]],[1556530237317,["GJX@GJXAIOU",[[-1,7317,"【背下】"]],[7317,7321],[7317,7317]]],[1556530462658,["GJX@GJXAIOU",[[-1,7653," 我总结的【多态】概念如下：\n \t父类的引用指向子类的对象，或者接口的引用指向【遵从】接口类对象\n \t\n多态的使用注意事项：【背下】\n \t1. 多态情况下，父类的引用调用父类和子类同名的普通成员方法，那么调用是子类的方法\n \t2. 多态情况下，父类的引用调用父类和子类同名的普通成员变量，那么调用是父类的成员变量\n \t3. 多态情况下，父类的引用调用父类和子类同名的【静态】成员方法，那么调用的是父类的【静态】成员方法，没什么用\n  \t4. 多态情况下，父类的引用【不能】调用子类特有的成员变量"]],[7653,7900],[7653,7653]]]],null,"GJX@GJXAIOU"],["99791d53-4ee3-4f7d-b11c-b66c028f9690",1556535171214,"## abstract 抽象类\n【需求】\n**要求继承于该类的子类，【强制】重写这些技能方法**，不写就报错，将业务逻辑的问题提升到语法问题，错误前置\n\n【解决】\nabstract 修饰抽象类的关键字\n也是修饰抽象方法的关键字\n\n【注意事项】   \n1. 如果一个**方法用abstract修饰，那么这个方法是不能有方法体的**，这个称之为【方法的声明】\n**一个方法如果用abstract修饰，【要求继承该类的子类必须重写这个方法】**\n\n2. 如果**一个类中存在用abstract修饰的方法，那么这个类必须用abstract修饰**\nThe type Hero mus t be an abstract class to define abstract methods\n\n3. **抽象类不能有自己的类对象**\n因为在用abstract修饰的抽象类当中，有可能存在抽象方法，而抽象方法是没有方法体，不直到应该运行什么代码，而创建抽象类对象之后看，就会存在这样的隐患，所以【抽象类是没有自己的类对象】\n\n4. 一个类用abstract修饰，但是不包含抽象方法，是可以的，但是你觉得有意义吗？\n语法没有问题，但是没有实际意义\n\n【总结】\n如果一个类继承了用把abstract修饰的抽象类，那么要求该类必须【实现】抽象类中所有抽象方法\n\n```java\n\nabstract class Hero {\n\t//成员变量\n\tint blood;\n\tint power;\n\n    // 在含有继承的父类中一般提供两个构造方法：其中一个为空\n\tpublic Hero() {}\n\t\n\tpublic Hero(int blood, int power) {\n\t\tthis.blood = blood;\n\t\tthis.power = power;\n\t}\n\t\n\t/*\n\t 这里【要求】所有的英雄都有三个技能，分别是QWE，而且要求继承该Hero的子类，必须重写这三个方法\n\t 这里就可以使用abstract来修饰这些方法\n\t */\n\tabstract public void Q();\n\tabstract public void W();\n\tabstract public void E();\n\t\n\tpublic void test() {\n\t\tSystem.out.println(\"测试\");\n\t}\n}\n\nabstract class Test {\n\tpublic void test() {\n\t\tSystem.out.println(\"测试\");\n\t}\n}\n\n/*\n\tFizz类 是继承了Hero类，因为Hero中包含了三个用abstract修饰的方法\n \t那么要求在Fizz类必须【实现】这三个方法\n */\nclass Fizz extends Hero {\n\t\n\t//构造方法\n\tpublic Fizz() {}\n\t\n\tpublic Fizz(int blood, int power) {\n\t\tsuper(blood, power); //调用父类的构造方法，初始化父类的成员变量\n\t}\n\t\n\t//是实现父类中要求继承该父类的子类必须【实现】的Q方法 implement\n\t@Override\n\tpublic void Q() {\n\t\tSystem.out.println(\"淘气打击\");\n\t}\n\n\t//是实现父类中要求继承该父类的子类必须【实现】的W方法 implement\n\t@Override\n\tpublic void W() {\n\t\tSystem.out.println(\"海石三叉戟\");\n\t}\n\n\t//是实现父类中要求继承该父类的子类必须【实现】的E方法 implement\n\t@Override\n\tpublic void E() {\n\t\tSystem.out.println(\"古灵精怪\");\n\t}\t\n}\n\nclass Caitlyn extends Hero{\n\t\n\tpublic Caitlyn() {}\n\t\n\tpublic Caitlyn(int blood, int power) {\n\t\tthis.blood = blood;\n\t\tthis.power = power;\n\t}\n\n\t@Override\n\tpublic void Q() {\n\t\tSystem.out.println(\"和平使者\");\n\t}\n\t\n\t@Override\n\tpublic void W() {\n\t\tSystem.out.println(\"约德尔诱捕器\");\n\t}\n\t\n\t@Override\n\tpublic void E() {\n\t\tSystem.out.println(\"90口径绳网\");\n\t}\n}\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tFizz fizz = new Fizz(100, 100);\n\t\t\n\t\tfizz.Q();\n\t\tfizz.W();\n\t\tfizz.E();\n\t\tfizz.test();\n\t\t\n\t\tCaitlyn caitlyn = new Caitlyn(100, 100);\n\t\t\n\t\tcaitlyn.Q();\n\t\tcaitlyn.W();\n\t\tcaitlyn.E();\n\t\tcaitlyn.test();\n\t\t\n\t\t//Hero h = new Hero();\n\t}\n}\n\n```\n\n\n```java\npackage com.qfedu.a_abstract;\n\n/*\n 需求：\n  \t描述一个图形类 Shape类，要求所有继承\n  \t于该类的子类都要有 计算周长 和 面积的方法\n  \t\n  \t实现shape类\n  \t实现继承于shape类的 圆类 方块 三角\n */\n\nabstract class Shape {\n\tabstract float perimeter();\n\tabstract float square();\n}\n\nclass MyCircle extends Shape {\n\t\n\tprivate float r;\n\tprivate float PI = 3.1415926f;\n\t\n\tpublic MyCircle() {}\n\t\n\tpublic MyCircle(float r) {\n\t\tif (r <= 0) {\n\t\t\tthis.r = 1;\n\t\t} else {\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\t@Override\n\tpublic float perimeter() {\n\t\treturn 2 * r * PI;\n\t}\n\n\t@Override\n\tpublic float square() {\n\t\treturn r * r * PI;\n\t}\t\n}\n\nclass Rect extends Shape {\n\n\tfloat length;\n\tfloat width;\n\t\n\tpublic Rect() {}\n\t\n\tpublic Rect(int length, float width) {\n\t\tthis.length = length;\n\t\tthis.width = width;\n\t}\n\t\n\t@Override\n\tpublic float perimeter() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic float square() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\t\n}\n\nclass Triangle extends Shape {\n\tfloat l1;\n\tfloat l2;\n\tfloat l3;\n\t\n\tpublic Triangle() {}\n\t\n\tpublic Triangle(float l1, float l2, float l3) {\n\t\tif (l1 < (l2 + l3) && l2 < (l1 + l3) && l3 < (l1 + l2)) {\n\t\t\tthis.l1 = l1;\n\t\t\tthis.l2 = l2;\n\t\t\tthis.l3 = l3;\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"错了！！！\");\n\t\t}\n\t}\n\t\n\t\n\t@Override\n\tpublic float perimeter() {\n\t\treturn l1 + l2 + l3;\n\t}\n\n\t@Override\n\tpublic float square() {\n\t\tfloat p = (l1 + l2 + l3) / 2;\n\t\t\n\t\treturn (float) Math.sqrt(p * (p - l1) * (p - l2) * (p - l3));\n\t\t\n\t}\n\t\n}\n\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\t\n\t}\n}\n\n```\n\n---\n\n\n## 接口\n\t\n代码中的接口：\n拓展当前类的功能，或者用来打补丁\n\n接口用到的关键字 `interface`      UI User Interface\n\n格式：\n```java\ninterface 接口名 {\n//拓展的内容\n成员变量 和 成员方法\n}\n```\n接口名采用的命名法是大驼峰命名法\n\n【遵从】接口的关键字 `implements`\n\n\n\n[补充知识]\nfinal关键字：\n\n* final关键字可以用来修饰成员变量和局部变量，用final修饰的变量在赋值之后不能发生改变；\n* final 如果修饰一个类,该类不能被继承；\n* final 修饰一个方法，该方法不能被重写；\n\n 接口中的成员方法是没有方法体\n\n【接口中的缺省属性】\n1. 在接口中成员变量默认的缺省属性是public static final修饰，要求在定义成员变量时直接赋值\n例如：USB接口在定义标准的时候，就确定USB接口的尺寸\n2. 在接口中成员方法的【缺省属性】是abstract，这里是要求【遵从】接口的类来完成的方法\n例如：USB接口规定了连接的方式和硬件要求\n\n【注意事项】\n1. 在interface中定义方法，都是一个abstract修饰的方法，要求【遵从】接口的类要实现这些方法\n2. 在interface中定义法成员变量都是用final修饰，只有使用权，没有赋值权\n3. 一个类可以【遵从】多个接口，不同的接口用逗号隔开\n\nJava是一门单继承，多实现/遵从的语言；\n\n\n```java\n\ninterface A {\n\t//成员变量\n\tint num = 10; //【缺省属性】public static final\n\t//成员方法\n\tvoid testA(); //【缺省属性】abstract\n}\n\ninterface B { \n\tvoid testB();\n}\n\n//这里使用implements关键字来遵从接口\npublic class Demo1 implements A, B {\n\n\t@Override\n\tpublic void testA() {\n\t\tSystem.out.println(\"实现接口中要求完成的testA方法\");\n\t}\n\n\t@Override\n\tpublic void testB() {\n\t\tSystem.out.println(\"遵从接口B实现testB方法\");\n\t\t\n\t}\n\tpublic static void main(String[] args) {\n\t\tDemo1 d1 = new Demo1();\n\t\t\n\t\td1.testA(); //【遵从】接口，并且实现接口中规定的方法，调用该方法\n\t\tSystem.out.println(d1.num); //【遵从】接口，使用接口中的成员变量\n\t\t//d1.num = 200; 因为在街口定义的成员变量默认的缺省属性都是public static final \n\t\t//而final修饰的变量，里面的数据是不能发生改变的\n\t\td1.testB();\n\t}\n\n\t\n}\n```\n\n\n\n\n## 多态\n\n\n### 统一接口\n\n```java\npackage com.qfedu.c_duotai;\n\n/*\n一个动物园：\nAnimal\n\tMonkey\n\tTiger\n\tSnake\n\t\n现在需要对所有的动物进行喂食\n\n发现，每一个东西都有一个喂食的方式，而且喂食得方式其实都一样的\n归纳总结的思想：能不能把这些方法放到一起啊\n\n思考：能不能实现一个喂食动物的方法\n\n喂食动物，要确定操作的是哪一个类，只能使用Animal类\n\n发现：\n\t这里要求传入对象是Animal类对象的方法，传入Animal的子类对象也可以，没有任何的报错和提示，直接可以运行\n\t在方法中如果需要的参数是一个类对象，那么在这个参数中传入该类的【子类】对象也可以\n\t例如：\n\t\teat(Animal a) 中，将Animal a替换成 Monkey m 方法也正常运行\n*/\n\n\nclass Animal {\n\tint age; \n\t\n\tpublic Animal() {}\n\tpublic Animal(int age) {\n\t\tthis.age = age;\n\t}\t\n\t\n\tpublic void eat(Animal a) {\n\t\tSystem.out.println(a.getClass() + \"再吃东西\"); // getclass表示获取类名\n\t}\n\t\n\tpublic Animal tellMyWhoAreYou(Animal a) {\n\t\tSystem.out.println(a.getClass());\n\t\treturn a;\n\t}\n}\n\nclass Monkey extends Animal {\n\t\n}\n\nclass Tiger extends Animal {\n\n}\n\nclass Snake extends Animal {\n\t\n}\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tMonkey m = new Monkey();\n\t\tm.eat(m);\n\t\n\t\tTiger t = new Tiger();\n\t\tt.eat(t);\n\t\t\n\t\tSnake s = new Snake();\n\t\ts.eat(s);\n\t\t\n\t\tAnimal a = new Animal();\n\t\t\n\t\ta.eat(m); //这里需求的是一个Animal 的类对象，但是传入的是一个Monkey类对象，\n\t\t\t\t  //Monkey类和Animal类直接关系是，Monkey 是 Animal的一个子类\n\t\ta.eat(t);\n\t\ta.eat(s);\n\t\t\n\t\t//原来的表达式：Animal ma = a.tellMyWhoAreYou(s); \n\t\t//**************重要******************\n\t\tMonkey ma = (Monkey) a.tellMyWhoAreYou(m);\n\t\tSystem.out.println(ma);\n\t\t\n\t\tSnake ms = (Snake) a.tellMyWhoAreYou(s);\n\t\tTiger mt = (Tiger) a.tellMyWhoAreYou(t);\n\t}\n\t\n}\n\n```\n\n\n```java\npackage com.qfedu.c_duotai;\n\n//规定一个USB接口。在USB接口中要求所有的USB设备要完成connect()\ninterface USB {\n\tvoid connect();\n}\n\n//U盘【遵从】了USB接口，实现了connect方法\nclass UPan implements USB {\n\t@Override\n\tpublic void connect() {\n\t\tSystem.out.println(\"U盘连接电脑，传输数据\");\n\t}\n}\n\n//键盘【遵从】了USB接口，实现了connect方法\nclass Keyboard implements USB {\n\t@Override\n\tpublic void connect() {\n\t\tSystem.out.println(\"推荐filco键盘，有且是茶轴\");\n\t}\n}\n\nclass Computer {\n\t//电脑上留有一个USB接口，但是是什么设备来使用USB不确定，根据谁要连接来确定，但是连接的设备\n\t//必须【遵从】USB接口\n\tpublic void USBConnect(USB usb) {\n\t\tusb.connect();\n\t}\n}\n\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tComputer MBP = new Computer();\n\t\t\n\t\t//传入的是一个【遵从】USB接口的 U盘匿名对象\n\t\tMBP.USBConnect(new UPan());\n\t\t\n\t\t//传入的是一个【遵从】USB接口的键盘匿名对象\n\t\tMBP.USBConnect(new Keyboard());\n\t\t\n\t\t/*\n\t\t 定义的形式参数是一个接口，但是传入的是【遵从】接口的类对象 \n\t\t */\n\t}\n}\n\n\n\n```\n\n\n总结的【多态】概念如下：\n父类的引用指向子类的对象，或者接口的引用指向【遵从】接口类对象\n\n多态的使用注意事项：\n  1. 多态情况下，父类的引用调用父类和子类同名的普通成员方法，那么调用是子类的方法\n  2. 多态情况下，父类的引用调用父类和子类同名的普通成员变量，那么调用是父类的成员变量\n  3. 多态情况下，父类的引用调用父类和子类同名的【静态】成员方法，那么调用的是父类的【静态】成员方法，没什么用\n  4. 多态情况下，父类的引用【不能】调用子类特有的成员变量\n\n\n```java\n\npackage com.qfedu.c_duotai;\n\n/*\n 从前两个代码中总结这两句话\n \t在一个方法中，需要的参数一个类对象，但是传入的参数是该类的【子类】对象，也是可以的！！！\n \t在一个方法中，定义的参数格式是一个接口，传入的参数是【遵从】该接口的对象，没有问题！！！\n \t\n\n */\nclass Father {\n\tString name; //父类中的成员变量\n\tint weight = 90; //和子类同名的成员变量\n\t\n\tpublic Father() {}\n\t \n\tpublic Father(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic void game() {\n\t\tSystem.out.println(\"曼切斯特\");\n\t}\n\t\n\tpublic static void work() {\n\t\tSystem.out.println(\"机械工程师\");\n\t}\n}\n\nclass Son extends Father {\n\tint age = 16; //子类自己的成员变量 \n\tint weight = 74; // 和父类同名的成员变量\n\t\n\tpublic Son(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t@Override\n\tpublic void game() {\n\t\tSystem.out.println(\"Housten Rocket\");\n\t}\n\t\n\tpublic static void work() {\n\t\tSystem.out.println(\"逗比程序猿导师\");\n\t}\n}\n\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n//\t\tSon s = new Son(\"David\");\n//\t\ts.game();\n//\t\ts.work();\n//\t\t\n//\t\tFather f = new Father(\"Jack\");\n//\t\tf.game();\n//\t\tf.work();\n\t\t\n\t\t//父类引用指向子类的对象 【多态】\n\t\tFather ftoS = new Son(\"23333\");\n\t\t\n\t\tftoS.game();\n\t\t\n\t\tSystem.out.println(ftoS.weight);\n\t\t\n\t\tftoS.work();\n\t\t\n//\t\tSystem.out.println(ftoS.age);\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n",[[1556535117245,["GJX@GJXAIOU",[[1,7654,"\n"]],[7653,7653],[7654,7654]]]],null,"GJX@GJXAIOU"],["15fbb6ea-96e4-4843-8481-143a24f8584e",1561594973341,"## abstract 抽象类\n【需求】\n**要求继承于该类的子类，【强制】重写这些技能方法**，不写就报错，将业务逻辑的问题提升到语法问题，错误前置\n\n【解决】\nabstract 修饰抽象类的关键字\n也是修饰抽象方法的关键字\n\n【注意事项】   \n1. 如果一个**方法用abstract修饰，那么这个方法是不能有方法体的**，这个称之为【方法的声明】\n**一个方法如果用abstract修饰，【要求继承该类的子类必须重写这个方法】**\n\n2. 如果**一个类中存在用abstract修饰的方法，那么这个类必须用abstract修饰**\nThe type Hero mus t be an abstract class to define abstract methods\n\n3. **抽象类不能有自己的类对象**\n因为在用abstract修饰的抽象类当中，有可能存在抽象方法，而抽象方法是没有方法体，不直到应该运行什么代码，而创建抽象类对象之后看，就会存在这样的隐患，所以【抽象类是没有自己的类对象】\n\n4. 一个类用abstract修饰，但是不包含抽象方法，是可以的，但是你觉得有意义吗？\n语法没有问题，但是没有实际意义\n\n【总结】\n如果一个类继承了用把abstract修饰的抽象类，那么要求该类必须【实现】抽象类中所有抽象方法\n\n```java\n\nabstract class Hero {\n\t//成员变量\n\tint blood;\n\tint power;\n\n    // 在含有继承的父类中一般提供两个构造方法：其中一个为空\n\tpublic Hero() {}\n\t\n\tpublic Hero(int blood, int power) {\n\t\tthis.blood = blood;\n\t\tthis.power = power;\n\t}\n\t\n\t/*\n\t 这里【要求】所有的英雄都有三个技能，分别是QWE，而且要求继承该Hero的子类，必须重写这三个方法\n\t 这里就可以使用abstract来修饰这些方法\n\t */\n\tabstract public void Q();\n\tabstract public void W();\n\tabstract public void E();\n\t\n\tpublic void test() {\n\t\tSystem.out.println(\"测试\");\n\t}\n}\n\nabstract class Test {\n\tpublic void test() {\n\t\tSystem.out.println(\"测试\");\n\t}\n}\n\n/*\n\tFizz类 是继承了Hero类，因为Hero中包含了三个用abstract修饰的方法\n \t那么要求在Fizz类必须【实现】这三个方法\n */\nclass Fizz extends Hero {\n\t\n\t//构造方法\n\tpublic Fizz() {}\n\t\n\tpublic Fizz(int blood, int power) {\n\t\tsuper(blood, power); //调用父类的构造方法，初始化父类的成员变量\n\t}\n\t\n\t//是实现父类中要求继承该父类的子类必须【实现】的Q方法 implement\n\t@Override\n\tpublic void Q() {\n\t\tSystem.out.println(\"淘气打击\");\n\t}\n\n\t//是实现父类中要求继承该父类的子类必须【实现】的W方法 implement\n\t@Override\n\tpublic void W() {\n\t\tSystem.out.println(\"海石三叉戟\");\n\t}\n\n\t//是实现父类中要求继承该父类的子类必须【实现】的E方法 implement\n\t@Override\n\tpublic void E() {\n\t\tSystem.out.println(\"古灵精怪\");\n\t}\t\n}\n\nclass Caitlyn extends Hero{\n\t\n\tpublic Caitlyn() {}\n\t\n\tpublic Caitlyn(int blood, int power) {\n\t\tthis.blood = blood;\n\t\tthis.power = power;\n\t}\n\n\t@Override\n\tpublic void Q() {\n\t\tSystem.out.println(\"和平使者\");\n\t}\n\t\n\t@Override\n\tpublic void W() {\n\t\tSystem.out.println(\"约德尔诱捕器\");\n\t}\n\t\n\t@Override\n\tpublic void E() {\n\t\tSystem.out.println(\"90口径绳网\");\n\t}\n}\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tFizz fizz = new Fizz(100, 100);\n\t\t\n\t\tfizz.Q();\n\t\tfizz.W();\n\t\tfizz.E();\n\t\tfizz.test();\n\t\t\n\t\tCaitlyn caitlyn = new Caitlyn(100, 100);\n\t\t\n\t\tcaitlyn.Q();\n\t\tcaitlyn.W();\n\t\tcaitlyn.E();\n\t\tcaitlyn.test();\n\t\t\n\t\t//Hero h = new Hero();\n\t}\n}\n\n```\n\n\n```java\npackage com.qfedu.a_abstract;\n\n/*\n 需求：\n  \t描述一个图形类 Shape类，要求所有继承\n  \t于该类的子类都要有 计算周长 和 面积的方法\n  \t\n  \t实现shape类\n  \t实现继承于shape类的 圆类 方块 三角\n */\n\nabstract class Shape {\n\tabstract float perimeter();\n\tabstract float square();\n}\n\nclass MyCircle extends Shape {\n\t\n\tprivate float r;\n\tprivate float PI = 3.1415926f;\n\t\n\tpublic MyCircle() {}\n\t\n\tpublic MyCircle(float r) {\n\t\tif (r <= 0) {\n\t\t\tthis.r = 1;\n\t\t} else {\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\t@Override\n\tpublic float perimeter() {\n\t\treturn 2 * r * PI;\n\t}\n\n\t@Override\n\tpublic float square() {\n\t\treturn r * r * PI;\n\t}\t\n}\n\nclass Rect extends Shape {\n\n\tfloat length;\n\tfloat width;\n\t\n\tpublic Rect() {}\n\t\n\tpublic Rect(int length, float width) {\n\t\tthis.length = length;\n\t\tthis.width = width;\n\t}\n\t\n\t@Override\n\tpublic float perimeter() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic float square() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\t\n}\n\nclass Triangle extends Shape {\n\tfloat l1;\n\tfloat l2;\n\tfloat l3;\n\t\n\tpublic Triangle() {}\n\t\n\tpublic Triangle(float l1, float l2, float l3) {\n\t\tif (l1 < (l2 + l3) && l2 < (l1 + l3) && l3 < (l1 + l2)) {\n\t\t\tthis.l1 = l1;\n\t\t\tthis.l2 = l2;\n\t\t\tthis.l3 = l3;\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"错了！！！\");\n\t\t}\n\t}\n\t\n\t\n\t@Override\n\tpublic float perimeter() {\n\t\treturn l1 + l2 + l3;\n\t}\n\n\t@Override\n\tpublic float square() {\n\t\tfloat p = (l1 + l2 + l3) / 2;\n\t\t\n\t\treturn (float) Math.sqrt(p * (p - l1) * (p - l2) * (p - l3));\n\t\t\n\t}\n\t\n}\n\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\t\n\t}\n}\n\n```\n\n---\n\n\n## 接口\n\t\n代码中的接口：\n拓展当前类的功能，或者用来打补丁\n\n接口用到的关键字 `interface`      UI User Interface\n\n格式：\n```java\ninterface 接口名 {\n//拓展的内容\n成员变量 和 成员方法\n}\n```\n接口名采用的命名法是大驼峰命名法\n\n【遵从】接口的关键字 `implements`\n\n\n\n[补充知识]\nfinal关键字：\n\n* final关键字可以用来修饰成员变量和局部变量，用final修饰的变量在赋值之后不能发生改变；\n* final 如果修饰一个类,该类不能被继承；\n* final 修饰一个方法，该方法不能被重写；\n\n 接口中的成员方法是没有方法体\n\n【接口中的缺省属性】\n1. 在接口中成员变量默认的缺省属性是public static final修饰，要求在定义成员变量时直接赋值\n例如：USB接口在定义标准的时候，就确定USB接口的尺寸\n2. 在接口中成员方法的【缺省属性】是abstract，这里是要求【遵从】接口的类来完成的方法\n例如：USB接口规定了连接的方式和硬件要求\n\n【注意事项】\n1. 在interface中定义方法，都是一个abstract修饰的方法，要求【遵从】接口的类要实现这些方法\n2. 在interface中定义法成员变量都是用final修饰，只有使用权，没有赋值权\n3. 一个类可以【遵从】多个接口，不同的接口用逗号隔开\n\nJava是一门单继承，多实现/遵从的语言；\n\n\n```java\n\ninterface A {\n\t//成员变量\n\tint num = 10; //【缺省属性】public static final\n\t//成员方法\n\tvoid testA(); //【缺省属性】abstract\n}\n\ninterface B { \n\tvoid testB();\n}\n\n//这里使用implements关键字来遵从接口\npublic class Demo1 implements A, B {\n\n\t@Override\n\tpublic void testA() {\n\t\tSystem.out.println(\"实现接口中要求完成的testA方法\");\n\t}\n\n\t@Override\n\tpublic void testB() {\n\t\tSystem.out.println(\"遵从接口B实现testB方法\");\n\t\t\n\t}\n\tpublic static void main(String[] args) {\n\t\tDemo1 d1 = new Demo1();\n\t\t\n\t\td1.testA(); //【遵从】接口，并且实现接口中规定的方法，调用该方法\n\t\tSystem.out.println(d1.num); //【遵从】接口，使用接口中的成员变量\n\t\t//d1.num = 200; 因为在街口定义的成员变量默认的缺省属性都是public static final \n\t\t//而final修饰的变量，里面的数据是不能发生改变的\n\t\td1.testB();\n\t}\n\n\t\n}\n```\n\n\n\n\n## 多态\n\n\n### 统一接口\n\n```java\npackage com.qfedu.c_duotai;\n\n/*\n一个动物园：\nAnimal\n\tMonkey\n\tTiger\n\tSnake\n\t\n现在需要对所有的动物进行喂食\n\n发现，每一个东西都有一个喂食的方式，而且喂食得方式其实都一样的\n归纳总结的思想：能不能把这些方法放到一起啊\n\n思考：能不能实现一个喂食动物的方法\n\n喂食动物，要确定操作的是哪一个类，只能使用Animal类\n\n发现：\n\t这里要求传入对象是Animal类对象的方法，传入Animal的子类对象也可以，没有任何的报错和提示，直接可以运行\n\t在方法中如果需要的参数是一个类对象，那么在这个参数中传入该类的【子类】对象也可以\n\t例如：\n\t\teat(Animal a) 中，将Animal a替换成 Monkey m 方法也正常运行\n*/\n\n\nclass Animal {\n\tint age; \n\t\n\tpublic Animal() {}\n\tpublic Animal(int age) {\n\t\tthis.age = age;\n\t}\t\n\t\n\tpublic void eat(Animal a) {\n\t\tSystem.out.println(a.getClass() + \"再吃东西\"); // getclass表示获取类名\n\t}\n\t\n\tpublic Animal tellMyWhoAreYou(Animal a) {\n\t\tSystem.out.println(a.getClass());\n\t\treturn a;\n\t}\n}\n\nclass Monkey extends Animal {\n\t\n}\n\nclass Tiger extends Animal {\n\n}\n\nclass Snake extends Animal {\n\t\n}\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tMonkey m = new Monkey();\n\t\tm.eat(m);\n\t\n\t\tTiger t = new Tiger();\n\t\tt.eat(t);\n\t\t\n\t\tSnake s = new Snake();\n\t\ts.eat(s);\n\t\t\n\t\tAnimal a = new Animal();\n\t\t\n\t\ta.eat(m); //这里需求的是一个Animal 的类对象，但是传入的是一个Monkey类对象，\n\t\t\t\t  //Monkey类和Animal类直接关系是，Monkey 是 Animal的一个子类\n\t\ta.eat(t);\n\t\ta.eat(s);\n\t\t\n\t\t//原来的表达式：Animal ma = a.tellMyWhoAreYou(s); \n\t\t//**************重要******************\n\t\tMonkey ma = (Monkey) a.tellMyWhoAreYou(m);\n\t\tSystem.out.println(ma);\n\t\t\n\t\tSnake ms = (Snake) a.tellMyWhoAreYou(s);\n\t\tTiger mt = (Tiger) a.tellMyWhoAreYou(t);\n\t}\n\t\n}\n\n```\n\n\n```java\npackage com.qfedu.c_duotai;\n\n//规定一个USB接口。在USB接口中要求所有的USB设备要完成connect()\ninterface USB {\n\tvoid connect();\n}\n\n//U盘【遵从】了USB接口，实现了connect方法\nclass UPan implements USB {\n\t@Override\n\tpublic void connect() {\n\t\tSystem.out.println(\"U盘连接电脑，传输数据\");\n\t}\n}\n\n//键盘【遵从】了USB接口，实现了connect方法\nclass Keyboard implements USB {\n\t@Override\n\tpublic void connect() {\n\t\tSystem.out.println(\"推荐filco键盘，有且是茶轴\");\n\t}\n}\n\nclass Computer {\n\t//电脑上留有一个USB接口，但是是什么设备来使用USB不确定，根据谁要连接来确定，但是连接的设备\n\t//必须【遵从】USB接口\n\tpublic void USBConnect(USB usb) {\n\t\tusb.connect();\n\t}\n}\n\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tComputer MBP = new Computer();\n\t\t\n\t\t//传入的是一个【遵从】USB接口的 U盘匿名对象\n\t\tMBP.USBConnect(new UPan());\n\t\t\n\t\t//传入的是一个【遵从】USB接口的键盘匿名对象\n\t\tMBP.USBConnect(new Keyboard());\n\t\t\n\t\t/*\n\t\t 定义的形式参数是一个接口，但是传入的是【遵从】接口的类对象 \n\t\t */\n\t}\n}\n\n\n\n```\n\n\n总结的【多态】概念如下：\n父类的引用指向子类的对象，或者接口的引用指向【遵从】接口类对象\n\n多态的使用注意事项：\n  1. 多态情况下，父类的引用调用父类和子类同名的普通成员方法，那么调用是子类的方法\n  2. 多态情况下，父类的引用调用父类和子类同名的普通成员变量，那么调用是父类的成员变量\n  3. 多态情况下，父类的引用调用父类和子类同名的【静态】成员方法，那么调用的是父类的【静态】成员方法，没什么用\n  4. 多态情况下，父类的引用【不能】调用子类特有的成员变量\n\n\n```java\n\npackage com.qfedu.c_duotai;\n\n/*\n 从前两个代码中总结这两句话\n \t在一个方法中，需要的参数一个类对象，但是传入的参数是该类的【子类】对象，也是可以的！！！\n \t在一个方法中，定义的参数格式是一个接口，传入的参数是【遵从】该接口的对象，没有问题！！！\n \t\n\n\n */\nclass Father {\n\tString name; //父类中的成员变量\n\tint weight = 90; //和子类同名的成员变量\n\t\n\tpublic Father() {}\n\t \n\tpublic Father(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic void game() {\n\t\tSystem.out.println(\"曼切斯特\");\n\t}\n\t\n\tpublic static void work() {\n\t\tSystem.out.println(\"机械工程师\");\n\t}\n}\n\nclass Son extends Father {\n\tint age = 16; //子类自己的成员变量 \n\tint weight = 74; // 和父类同名的成员变量\n\t\n\tpublic Son(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t@Override\n\tpublic void game() {\n\t\tSystem.out.println(\"Housten Rocket\");\n\t}\n\t\n\tpublic static void work() {\n\t\tSystem.out.println(\"逗比程序猿导师\");\n\t}\n}\n\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n//\t\tSon s = new Son(\"David\");\n//\t\ts.game();\n//\t\ts.work();\n//\t\t\n//\t\tFather f = new Father(\"Jack\");\n//\t\tf.game();\n//\t\tf.work();\n\t\t\n\t\t//父类引用指向子类的对象 【多态】\n\t\tFather ftoS = new Son(\"23333\");\n\t\t\n\t\tftoS.game();\n\t\t\n\t\tSystem.out.println(ftoS.weight);\n\t\t\n\t\tftoS.work();\n\t\t\n//\t\tSystem.out.println(ftoS.age);\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n",[[1561594954623,["GJX@GJXAIOU",[[1,547,"**"],[1,567,"**"]],[547,567],[547,571]]],[1561595027032,["GJX@GJXAIOU",[[1,4362,"（）"]],[4362,4362],[4364,4364]]],[1561595032010,["GJX@GJXAIOU",[[1,4363,"修改权"]],[4363,4363],[4366,4366]]],[1561595053087,["GJX@GJXAIOU",[[1,5086,"\n"]],[5084,5084],[5085,5085]]],[1561595084313,["GJX@GJXAIOU",[[1,5085,"概念：父类的引用指向子类的对象，或者接口的引用指向【遵从】接口类对象；"]],[5085,5085],[5120,5120]]],[1561595085341,["GJX@GJXAIOU",[[1,5122,"\n"]],[5120,5120],[5121,5121]]],[1561595085469,["GJX@GJXAIOU",[[1,5123,"\n"]],[5121,5121],[5122,5122]]],[1561595085614,["GJX@GJXAIOU",[[1,5124,"\n"]],[5122,5122],[5123,5123]]],[1561595098678,["GJX@GJXAIOU",[[-1,5085,"概念：父类的引用指向子类的对象，或者接口的引用指向【遵从】接口类对象；"]],[5085,5120],[5085,5085]]],[1561595099190,["GJX@GJXAIOU",[[-1,5089,"\n"]],[5085,5085],[5084,5084]]],[1561595104677,["GJX@GJXAIOU",[[-1,7273,"总结的【多态】概念如下：\n父类的引用指向子类的对象，或者接口的引用指向【遵从】接口类对象\n\n多态的使用注意事项：\n  1. 多态情况下，父类的引用调用父类和子类同名的普通成员方法，那么调用是子类的方法\n  2. 多态情况下，父类的引用调用父类和子类同名的普通成员变量，那么调用是父类的成员变量\n  3. 多态情况下，父类的引用调用父类和子类同名的【静态】成员方法，那么调用的是父类的【静态】成员方法，没什么用\n  4. 多态情况下，父类的引用【不能】调用子类特有的成员变量"]],[7273,7509],[7273,7273]]],[1561595108957,["GJX@GJXAIOU",[[1,5085,"总结的【多态】概念如下：\n父类的引用指向子类的对象，或者接口的引用指向【遵从】接口类对象\n\n多态的使用注意事项：\n  1. 多态情况下，父类的引用调用父类和子类同名的普通成员方法，那么调用是子类的方法\n  2. 多态情况下，父类的引用调用父类和子类同名的普通成员变量，那么调用是父类的成员变量\n  3. 多态情况下，父类的引用调用父类和子类同名的【静态】成员方法，那么调用的是父类的【静态】成员方法，没什么用\n  4. 多态情况下，父类的引用【不能】调用子类特有的成员变量"]],[5085,5085],[5321,5321]]],[1561595655357,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1561595659088,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1561595659207,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1561595659343,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1561595660414,["GJX@GJXAIOU",[[1,4,"\n"]],[3,3],[4,4]]],[1561595660543,["GJX@GJXAIOU",[[1,5,"\n"]],[4,4],[5,5]]],[1561595661257,["GJX@GJXAIOU",[[1,5,"---"]],[5,5],[8,8]]],[1561595671458,["GJX@GJXAIOU",[[1,4,"tags :"]],[4,4],[10,10]]],[1561595672558,["GJX@GJXAIOU",[[-1,8," :"]],[10,10],[8,8]]],[1561595673504,["GJX@GJXAIOU",[[1,8,"："]],[8,8],[9,9]]],[1561595674400,["GJX@GJXAIOU",[[-1,8,"："]],[9,9],[8,8]]],[1561595675431,["GJX@GJXAIOU",[[1,8,": "]],[8,8],[10,10]]],[1561595676374,["GJX@GJXAIOU",[[1,11,"\n"]],[10,10],[11,11]]],[1561595678632,["GJX@GJXAIOU",[[1,11,"- java"]],[11,11],[17,17]]],[1561595679957,["GJX@GJXAIOU",[[1,18,"\n"]],[17,17],[18,18]]],[1561595681889,["GJX@GJXAIOU",[[1,18,"- 简答"]],[18,18],[22,22]]],[1561595682527,["GJX@GJXAIOU",[[-1,20,"简答"]],[22,22],[20,20]]],[1561595683858,["GJX@GJXAIOU",[[1,20,"基础"]],[20,20],[22,22]]],[1561595684118,["GJX@GJXAIOU",[[1,23,"\n"]],[22,22],[23,23]]],[1561595685128,["GJX@GJXAIOU",[[1,23,"-"]],[23,23],[24,24]]],[1561595685816,["GJX@GJXAIOU",[[-1,23,"-"]],[24,24],[23,23]]],[1561595691449,["GJX@GJXAIOU",[[1,23,"abstract"]],[23,23],[31,31]]],[1561595693562,["GJX@GJXAIOU",[[1,31,"抽象类"]],[31,31],[34,34]]],[1561595705841,["GJX@GJXAIOU",[[1,23,"- "]],[23,23],[25,25]]]],null,"GJX@GJXAIOU"],["f2d21f72-f7b4-4668-8a03-f057a79d00af",1563350512107,"---\ntags: \n- java\n- 基础\n- abstract抽象类\n---\n## abstract 抽象类\n【需求】\n**要求继承于该类的子类，【强制】重写这些技能方法**，不写就报错，将业务逻辑的问题提升到语法问题，错误前置\n\n【解决】\nabstract 修饰抽象类的关键字\n也是修饰抽象方法的关键字\n\n【注意事项】   \n1. 如果一个**方法用abstract修饰，那么这个方法是不能有方法体的**，这个称之为【方法的声明】\n**一个方法如果用abstract修饰，【要求继承该类的子类必须重写这个方法】**\n\n2. 如果**一个类中存在用abstract修饰的方法，那么这个类必须用abstract修饰**\nThe type Hero mus t be an abstract class to define abstract methods\n\n3. **抽象类不能有自己的类对象**\n因为在用abstract修饰的抽象类当中，有可能存在抽象方法，而抽象方法是没有方法体，不直到应该运行什么代码，而创建抽象类对象之后看，就会存在这样的隐患，所以【抽象类是没有自己的类对象】\n\n4. 一个类用abstract修饰，但是不包含抽象方法，是可以的，但是你觉得有意义吗？\n语法没有问题，但是没有实际意义\n\n【总结】\n如果一个类继承了用把abstract修饰的抽象类，那么**要求该类必须【实现】抽象类中所有抽象方法**\n\n```java\n\nabstract class Hero {\n\t//成员变量\n\tint blood;\n\tint power;\n\n    // 在含有继承的父类中一般提供两个构造方法：其中一个为空\n\tpublic Hero() {}\n\t\n\tpublic Hero(int blood, int power) {\n\t\tthis.blood = blood;\n\t\tthis.power = power;\n\t}\n\t\n\t/*\n\t 这里【要求】所有的英雄都有三个技能，分别是QWE，而且要求继承该Hero的子类，必须重写这三个方法\n\t 这里就可以使用abstract来修饰这些方法\n\t */\n\tabstract public void Q();\n\tabstract public void W();\n\tabstract public void E();\n\t\n\tpublic void test() {\n\t\tSystem.out.println(\"测试\");\n\t}\n}\n\nabstract class Test {\n\tpublic void test() {\n\t\tSystem.out.println(\"测试\");\n\t}\n}\n\n/*\n\tFizz类 是继承了Hero类，因为Hero中包含了三个用abstract修饰的方法\n \t那么要求在Fizz类必须【实现】这三个方法\n */\nclass Fizz extends Hero {\n\t\n\t//构造方法\n\tpublic Fizz() {}\n\t\n\tpublic Fizz(int blood, int power) {\n\t\tsuper(blood, power); //调用父类的构造方法，初始化父类的成员变量\n\t}\n\t\n\t//是实现父类中要求继承该父类的子类必须【实现】的Q方法 implement\n\t@Override\n\tpublic void Q() {\n\t\tSystem.out.println(\"淘气打击\");\n\t}\n\n\t//是实现父类中要求继承该父类的子类必须【实现】的W方法 implement\n\t@Override\n\tpublic void W() {\n\t\tSystem.out.println(\"海石三叉戟\");\n\t}\n\n\t//是实现父类中要求继承该父类的子类必须【实现】的E方法 implement\n\t@Override\n\tpublic void E() {\n\t\tSystem.out.println(\"古灵精怪\");\n\t}\t\n}\n\nclass Caitlyn extends Hero{\n\t\n\tpublic Caitlyn() {}\n\t\n\tpublic Caitlyn(int blood, int power) {\n\t\tthis.blood = blood;\n\t\tthis.power = power;\n\t}\n\n\t@Override\n\tpublic void Q() {\n\t\tSystem.out.println(\"和平使者\");\n\t}\n\t\n\t@Override\n\tpublic void W() {\n\t\tSystem.out.println(\"约德尔诱捕器\");\n\t}\n\t\n\t@Override\n\tpublic void E() {\n\t\tSystem.out.println(\"90口径绳网\");\n\t}\n}\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tFizz fizz = new Fizz(100, 100);\n\t\t\n\t\tfizz.Q();\n\t\tfizz.W();\n\t\tfizz.E();\n\t\tfizz.test();\n\t\t\n\t\tCaitlyn caitlyn = new Caitlyn(100, 100);\n\t\t\n\t\tcaitlyn.Q();\n\t\tcaitlyn.W();\n\t\tcaitlyn.E();\n\t\tcaitlyn.test();\n\t\t\n\t\t//Hero h = new Hero();\n\t}\n}\n\n```\n\n\n```java\npackage com.qfedu.a_abstract;\n\n/*\n 需求：\n  \t描述一个图形类 Shape类，要求所有继承\n  \t于该类的子类都要有 计算周长 和 面积的方法\n  \t\n  \t实现shape类\n  \t实现继承于shape类的 圆类 方块 三角\n */\n\nabstract class Shape {\n\tabstract float perimeter();\n\tabstract float square();\n}\n\nclass MyCircle extends Shape {\n\t\n\tprivate float r;\n\tprivate float PI = 3.1415926f;\n\t\n\tpublic MyCircle() {}\n\t\n\tpublic MyCircle(float r) {\n\t\tif (r <= 0) {\n\t\t\tthis.r = 1;\n\t\t} else {\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\t@Override\n\tpublic float perimeter() {\n\t\treturn 2 * r * PI;\n\t}\n\n\t@Override\n\tpublic float square() {\n\t\treturn r * r * PI;\n\t}\t\n}\n\nclass Rect extends Shape {\n\n\tfloat length;\n\tfloat width;\n\t\n\tpublic Rect() {}\n\t\n\tpublic Rect(int length, float width) {\n\t\tthis.length = length;\n\t\tthis.width = width;\n\t}\n\t\n\t@Override\n\tpublic float perimeter() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic float square() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\t\n}\n\nclass Triangle extends Shape {\n\tfloat l1;\n\tfloat l2;\n\tfloat l3;\n\t\n\tpublic Triangle() {}\n\t\n\tpublic Triangle(float l1, float l2, float l3) {\n\t\tif (l1 < (l2 + l3) && l2 < (l1 + l3) && l3 < (l1 + l2)) {\n\t\t\tthis.l1 = l1;\n\t\t\tthis.l2 = l2;\n\t\t\tthis.l3 = l3;\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"错了！！！\");\n\t\t}\n\t}\n\t\n\t\n\t@Override\n\tpublic float perimeter() {\n\t\treturn l1 + l2 + l3;\n\t}\n\n\t@Override\n\tpublic float square() {\n\t\tfloat p = (l1 + l2 + l3) / 2;\n\t\t\n\t\treturn (float) Math.sqrt(p * (p - l1) * (p - l2) * (p - l3));\n\t\t\n\t}\n\t\n}\n\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\t\n\t}\n}\n\n```\n\n---\n\n\n## 接口\n\t\n代码中的接口：\n拓展当前类的功能，或者用来打补丁\n\n接口用到的关键字 `interface`      UI User Interface\n\n格式：\n```java\ninterface 接口名 {\n//拓展的内容\n成员变量 和 成员方法\n}\n```\n接口名采用的命名法是大驼峰命名法\n\n【遵从】接口的关键字 `implements`\n\n\n\n[补充知识]\nfinal关键字：\n\n* final关键字可以用来修饰成员变量和局部变量，用final修饰的变量在赋值之后不能发生改变；\n* final 如果修饰一个类,该类不能被继承；\n* final 修饰一个方法，该方法不能被重写；\n\n 接口中的成员方法是没有方法体\n\n【接口中的缺省属性】\n1. 在接口中成员变量默认的缺省属性是public static final修饰，要求在定义成员变量时直接赋值\n例如：USB接口在定义标准的时候，就确定USB接口的尺寸\n2. 在接口中成员方法的【缺省属性】是abstract，这里是要求【遵从】接口的类来完成的方法\n例如：USB接口规定了连接的方式和硬件要求\n\n【注意事项】\n1. 在interface中定义方法，都是一个abstract修饰的方法，要求【遵从】接口的类要实现这些方法\n2. 在interface中定义法成员变量都是用final修饰，只有使用权，没有赋值权（修改权）\n3. 一个类可以【遵从】多个接口，不同的接口用逗号隔开\n\nJava是一门单继承，多实现/遵从的语言；\n\n\n```java\n\ninterface A {\n\t//成员变量\n\tint num = 10; //【缺省属性】public static final\n\t//成员方法\n\tvoid testA(); //【缺省属性】abstract\n}\n\ninterface B { \n\tvoid testB();\n}\n\n//这里使用implements关键字来遵从接口\npublic class Demo1 implements A, B {\n\n\t@Override\n\tpublic void testA() {\n\t\tSystem.out.println(\"实现接口中要求完成的testA方法\");\n\t}\n\n\t@Override\n\tpublic void testB() {\n\t\tSystem.out.println(\"遵从接口B实现testB方法\");\n\t\t\n\t}\n\tpublic static void main(String[] args) {\n\t\tDemo1 d1 = new Demo1();\n\t\t\n\t\td1.testA(); //【遵从】接口，并且实现接口中规定的方法，调用该方法\n\t\tSystem.out.println(d1.num); //【遵从】接口，使用接口中的成员变量\n\t\t//d1.num = 200; 因为在街口定义的成员变量默认的缺省属性都是public static final \n\t\t//而final修饰的变量，里面的数据是不能发生改变的\n\t\td1.testB();\n\t}\n\n\t\n}\n```\n\n\n\n\n## 多态\n\n总结的【多态】概念如下：\n父类的引用指向子类的对象，或者接口的引用指向【遵从】接口类对象\n\n多态的使用注意事项：\n  1. 多态情况下，父类的引用调用父类和子类同名的普通成员方法，那么调用是子类的方法\n  2. 多态情况下，父类的引用调用父类和子类同名的普通成员变量，那么调用是父类的成员变量\n  3. 多态情况下，父类的引用调用父类和子类同名的【静态】成员方法，那么调用的是父类的【静态】成员方法，没什么用\n  4. 多态情况下，父类的引用【不能】调用子类特有的成员变量\n\n\n\n### 统一接口\n\n```java\npackage com.qfedu.c_duotai;\n\n/*\n一个动物园：\nAnimal\n\tMonkey\n\tTiger\n\tSnake\n\t\n现在需要对所有的动物进行喂食\n\n发现，每一个东西都有一个喂食的方式，而且喂食得方式其实都一样的\n归纳总结的思想：能不能把这些方法放到一起啊\n\n思考：能不能实现一个喂食动物的方法\n\n喂食动物，要确定操作的是哪一个类，只能使用Animal类\n\n发现：\n\t这里要求传入对象是Animal类对象的方法，传入Animal的子类对象也可以，没有任何的报错和提示，直接可以运行\n\t在方法中如果需要的参数是一个类对象，那么在这个参数中传入该类的【子类】对象也可以\n\t例如：\n\t\teat(Animal a) 中，将Animal a替换成 Monkey m 方法也正常运行\n*/\n\n\nclass Animal {\n\tint age; \n\t\n\tpublic Animal() {}\n\tpublic Animal(int age) {\n\t\tthis.age = age;\n\t}\t\n\t\n\tpublic void eat(Animal a) {\n\t\tSystem.out.println(a.getClass() + \"再吃东西\"); // getclass表示获取类名\n\t}\n\t\n\tpublic Animal tellMyWhoAreYou(Animal a) {\n\t\tSystem.out.println(a.getClass());\n\t\treturn a;\n\t}\n}\n\nclass Monkey extends Animal {\n\t\n}\n\nclass Tiger extends Animal {\n\n}\n\nclass Snake extends Animal {\n\t\n}\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tMonkey m = new Monkey();\n\t\tm.eat(m);\n\t\n\t\tTiger t = new Tiger();\n\t\tt.eat(t);\n\t\t\n\t\tSnake s = new Snake();\n\t\ts.eat(s);\n\t\t\n\t\tAnimal a = new Animal();\n\t\t\n\t\ta.eat(m); //这里需求的是一个Animal 的类对象，但是传入的是一个Monkey类对象，\n\t\t\t\t  //Monkey类和Animal类直接关系是，Monkey 是 Animal的一个子类\n\t\ta.eat(t);\n\t\ta.eat(s);\n\t\t\n\t\t//原来的表达式：Animal ma = a.tellMyWhoAreYou(s); \n\t\t//**************重要******************\n\t\tMonkey ma = (Monkey) a.tellMyWhoAreYou(m);\n\t\tSystem.out.println(ma);\n\t\t\n\t\tSnake ms = (Snake) a.tellMyWhoAreYou(s);\n\t\tTiger mt = (Tiger) a.tellMyWhoAreYou(t);\n\t}\n\t\n}\n\n```\n\n\n```java\npackage com.qfedu.c_duotai;\n\n//规定一个USB接口。在USB接口中要求所有的USB设备要完成connect()\ninterface USB {\n\tvoid connect();\n}\n\n//U盘【遵从】了USB接口，实现了connect方法\nclass UPan implements USB {\n\t@Override\n\tpublic void connect() {\n\t\tSystem.out.println(\"U盘连接电脑，传输数据\");\n\t}\n}\n\n//键盘【遵从】了USB接口，实现了connect方法\nclass Keyboard implements USB {\n\t@Override\n\tpublic void connect() {\n\t\tSystem.out.println(\"推荐filco键盘，有且是茶轴\");\n\t}\n}\n\nclass Computer {\n\t//电脑上留有一个USB接口，但是是什么设备来使用USB不确定，根据谁要连接来确定，但是连接的设备\n\t//必须【遵从】USB接口\n\tpublic void USBConnect(USB usb) {\n\t\tusb.connect();\n\t}\n}\n\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tComputer MBP = new Computer();\n\t\t\n\t\t//传入的是一个【遵从】USB接口的 U盘匿名对象\n\t\tMBP.USBConnect(new UPan());\n\t\t\n\t\t//传入的是一个【遵从】USB接口的键盘匿名对象\n\t\tMBP.USBConnect(new Keyboard());\n\t\t\n\t\t/*\n\t\t 定义的形式参数是一个接口，但是传入的是【遵从】接口的类对象 \n\t\t */\n\t}\n}\n\n\n\n```\n\n\n\n\n\n```java\n\npackage com.qfedu.c_duotai;\n\n/*\n 从前两个代码中总结这两句话\n \t在一个方法中，需要的参数一个类对象，但是传入的参数是该类的【子类】对象，也是可以的！！！\n \t在一个方法中，定义的参数格式是一个接口，传入的参数是【遵从】该接口的对象，没有问题！！！\n \t\n\n\n */\nclass Father {\n\tString name; //父类中的成员变量\n\tint weight = 90; //和子类同名的成员变量\n\t\n\tpublic Father() {}\n\t \n\tpublic Father(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic void game() {\n\t\tSystem.out.println(\"曼切斯特\");\n\t}\n\t\n\tpublic static void work() {\n\t\tSystem.out.println(\"机械工程师\");\n\t}\n}\n\nclass Son extends Father {\n\tint age = 16; //子类自己的成员变量 \n\tint weight = 74; // 和父类同名的成员变量\n\t\n\tpublic Son(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t@Override\n\tpublic void game() {\n\t\tSystem.out.println(\"Housten Rocket\");\n\t}\n\t\n\tpublic static void work() {\n\t\tSystem.out.println(\"逗比程序猿导师\");\n\t}\n}\n\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n//\t\tSon s = new Son(\"David\");\n//\t\ts.game();\n//\t\ts.work();\n//\t\t\n//\t\tFather f = new Father(\"Jack\");\n//\t\tf.game();\n//\t\tf.work();\n\t\t\n\t\t//父类引用指向子类的对象 【多态】\n\t\tFather ftoS = new Son(\"23333\");\n\t\t\n\t\tftoS.game();\n\t\t\n\t\tSystem.out.println(ftoS.weight);\n\t\t\n\t\tftoS.work();\n\t\t\n//\t\tSystem.out.println(ftoS.age);\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n",[[1563350474538,["GJX@GJXAIOU",[[1,8," "],[-1,17,"\n- "],[-1,23,"- abstract抽象类"],[1,36,"\nflag: blue"],[1,40,"\n\n@toc\nJavaDay13 "]],[0,40],[57,57]]],[1563350872115,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563350872115,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563350822310,["GJX@GJXAIOU",[[-1,75,"**"],[-1,100,"**"]],[77,100],[75,98]]],[1563350824288,["GJX@GJXAIOU",[[1,75,"=="],[1,98,"=="]],[75,98],[75,102]]],[1563350826710,["GJX@GJXAIOU",[[1,70,"\n"]],[70,70],[71,71]]],[1563350839244,["GJX@GJXAIOU",[[1,3834,"二、"]],[3834,3834],[3836,3836]]],[1563350856462,["GJX@GJXAIOU",[[-1,57,"abstract 抽象类"]],[57,69],[57,57]]],[1563350859439,["GJX@GJXAIOU",[[1,58,"abstract 抽象类"]],[58,58],[70,70]]],[1563350865506,["GJX@GJXAIOU",[[1,58,"## 一 "]],[58,58],[62,62]]],[1563350865976,["GJX@GJXAIOU",[[1,62,"、"]],[62,62],[63,63]]],[1563350871905,["GJX@GJXAIOU",[[1,57," 抽象类"]],[57,57],[61,61]]],[1563350932118,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563350932118,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563350878609,["GJX@GJXAIOU",[[1,61," 接口、多态"]],[61,61],[67,67]]],[1563350881248,["GJX@GJXAIOU",[[1,62,"、"]],[62,62],[63,63]]],[1563350890900,["GJX@GJXAIOU",[[1,5155,"三、"]],[5155,5155],[5157,5157]]],[1563350893169,["GJX@GJXAIOU",[[1,5150,"---"]],[5150,5150],[5153,5153]]],[1563350905806,["GJX@GJXAIOU",[[1,88,"\n"]],[88,88],[89,89]]],[1563350907882,["GJX@GJXAIOU",[[1,89,"- "]],[89,89],[91,91]]],[1563350911107,["GJX@GJXAIOU",[[1,152,"="]],[152,152],[153,153]]],[1563350912014,["GJX@GJXAIOU",[[-1,152,"="]],[153,153],[152,152]]],[1563350912785,["GJX@GJXAIOU",[[1,152,"- "]],[152,152],[154,154]]],[1563350916078,["GJX@GJXAIOU",[[-1,177,"\n"]],[178,178],[177,177]]],[1563350917641,["GJX@GJXAIOU",[[1,177,"，"]],[177,177],[178,178]]],[1563350921591,["GJX@GJXAIOU",[[1,192,"- "]],[192,192],[194,194]]],[1563350992119,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563350992119,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563350933407,["GJX@GJXAIOU",[[1,213,"=="],[1,241,"=="]],[213,241],[213,245]]],[1563350939047,["GJX@GJXAIOU",[[-1,211,"**"],[-1,245,"**"]],[215,243],[211,243]]],[1563350952338,["GJX@GJXAIOU",[[1,257,"=="],[1,298,"=="]],[257,298],[257,302]]],[1563350963982,["GJX@GJXAIOU",[[1,213,"**"],[1,241,"**"]],[213,241],[213,245]]],[1563350968983,["GJX@GJXAIOU",[[1,211," "]],[211,211],[212,212]]],[1563350971095,["GJX@GJXAIOU",[[1,248," "]],[248,248],[249,249]]],[1563350989422,["GJX@GJXAIOU",[[1,315,"=="],[1,358,"=="]],[315,358],[315,362]]],[1563351052121,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563351052121,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563350992487,["GJX@GJXAIOU",[[1,315," "]],[315,315],[316,316]]],[1563351112242,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563351112242,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563351105783,["GJX@GJXAIOU",[[1,436,"=="],[1,452,"=="]],[436,452],[436,456]]],[1563351232238,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563351232238,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563351216695,["GJX@GJXAIOU",[[-1,501,"直到"]],[503,503],[501,501]]],[1563351217836,["GJX@GJXAIOU",[[1,501,"知道"]],[501,501],[503,503]]],[1563351352242,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563351352242,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563351296570,["GJX@GJXAIOU",[[-1,627,"把"]],[628,628],[627,627]]],[1563351412245,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563351412245,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563351404935,["GJX@GJXAIOU",[[1,618,"Markdown "]],[618,668],[626,626]]],[1563351406913,["GJX@GJXAIOU",[[1,626,"MarkdownMarkdown"]],[626,626],[642,642]]],[1563351411918,["GJX@GJXAIOU",[[-1,618,"MarkdownMarkdownMarkdown"]],[642,642],[618,618]]],[1563351472249,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563351472249,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563351420887,["GJX@GJXAIOU",[[1,619,"=="],[1,669,"=="]],[619,669],[619,673]]],[1563351532247,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563351532247,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563351494159,["GJX@GJXAIOU",[[1,675,"\n"]],[674,674],[675,675]]],[1563351496569,["GJX@GJXAIOU",[[1,675,"dain"]],[675,675],[679,679]]],[1563351497477,["GJX@GJXAIOU",[[-1,675,"dain"]],[679,679],[675,675]]],[1563351500641,["GJX@GJXAIOU",[[1,675,"代码示例一："]],[675,675],[681,681]]],[1563351592250,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563351592250,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563351567783,["GJX@GJXAIOU",[[1,2368,"\n"]],[2365,2365],[2366,2366]]],[1563351575528,["GJX@GJXAIOU",[[1,2366,"程序运行结果："]],[2366,2366],[2373,2373]]],[1563351575783,["GJX@GJXAIOU",[[1,2376,"\n"]],[2373,2373],[2374,2374]]],[1563351578729,["GJX@GJXAIOU",[[1,2374,"```java"]],[2374,2374],[2381,2381]]],[1563351578888,["GJX@GJXAIOU",[[1,2384,"\n"]],[2381,2381],[2382,2382]]],[1563351579070,["GJX@GJXAIOU",[[1,2385,"\n"]],[2382,2382],[2383,2383]]],[1563351580129,["GJX@GJXAIOU",[[1,2383,"```"]],[2383,2383],[2386,2386]]],[1563351581576,["GJX@GJXAIOU",[[1,2382,"淘气打击\n海石三叉戟\n古灵精怪\n测试\n和平使者\n约德尔诱捕器\n90口径绳网\n测试"]],[2382,2382],[2422,2422]]],[1563351652252,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563351652252,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563351595822,["GJX@GJXAIOU",[[1,2429,"\n"]],[2428,2428],[2429,2429]]],[1563351596871,["GJX@GJXAIOU",[[1,2429,"daima"]],[2429,2429],[2434,2434]]],[1563351598014,["GJX@GJXAIOU",[[-1,2429,"daima"]],[2434,2434],[2429,2429]]],[1563351601804,["GJX@GJXAIOU",[[1,2429,"代码示例二："]],[2429,2429],[2435,2435]]],[1563351892254,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563351892254,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563351888585,["GJX@GJXAIOU",[[-1,4017," "]],[4018,4018],[4017,4017]]],[1563351889577,["GJX@GJXAIOU",[[1,4017,"："]],[4017,4017],[4018,4018]]],[1563352132260,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563352132260,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563352121430,["GJX@GJXAIOU",[[-1,3961,"\t"]],[3962,3962],[3961,3961]]],[1563352121569,["GJX@GJXAIOU",[[-1,3961,"\n"]],[3961,3961],[3960,3960]]],[1563352122688,["GJX@GJXAIOU",[[1,3961,"\n"]],[3960,3960],[3961,3961]]],[1563352123522,["GJX@GJXAIOU",[[1,3962,"\n"]],[3961,3961],[3962,3962]]],[1563352124526,["GJX@GJXAIOU",[[1,3962,"[]"]],[3962,3962],[3964,3964]]],[1563352126922,["GJX@GJXAIOU",[[1,3963,"功能"]],[3963,3963],[3965,3965]]],[1563352129199,["GJX@GJXAIOU",[[1,3962,"- "]],[3962,3962],[3964,3964]]],[1563352192260,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563352192260,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563352132457,["GJX@GJXAIOU",[[1,4040,"- "]],[4040,4040],[4042,4042]]],[1563352312261,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563352312261,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563352254143,["GJX@GJXAIOU",[[1,4141,"- "]],[4141,4141],[4143,4143]]],[1563352262215,["GJX@GJXAIOU",[[1,4150,"=="],[1,4158,"=="]],[4150,4158],[4150,4162]]],[1563352272169,["GJX@GJXAIOU",[[1,4004,"=="],[1,4015,"=="]],[4004,4015],[4004,4019]]],[1563352281982,["GJX@GJXAIOU",[[-1,4004,"=="]],[4004,4006],[4004,4004]]],[1563352284023,["GJX@GJXAIOU",[[-1,4015,"==  "]],[4019,4019],[4015,4015]]],[1563352285527,["GJX@GJXAIOU",[[1,4019," "]],[4015,4015],[4016,4016]]],[1563352432263,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563352432263,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563352387151,["GJX@GJXAIOU",[[1,4166,"=="],[1,4212,"=="]],[4166,4212],[4166,4216]]],[1563352393430,["GJX@GJXAIOU",[[1,4220,"=="],[1,4241,"=="]],[4220,4241],[4220,4245]]],[1563352397507,["GJX@GJXAIOU",[[1,4249,"=="],[1,4270,"=="]],[4249,4270],[4249,4274]]],[1563352409419,["GJX@GJXAIOU",[[1,4278,"=="],[1,4292,"=="]],[4278,4292],[4278,4296]]],[1563352415017,["GJX@GJXAIOU",[[1,4298,"- "]],[4298,4298],[4300,4300]]],[1563352420998,["GJX@GJXAIOU",[[-1,4163,"\n"]],[4163,4163],[4162,4162]]],[1563352423538,["GJX@GJXAIOU",[[1,4163,"  "]],[4165,4165],[4167,4167]]],[1563352424822,["GJX@GJXAIOU",[[1,4219,"  "]],[4221,4221],[4223,4223]]],[1563352428407,["GJX@GJXAIOU",[[1,4250,"  "]],[4251,4251],[4253,4253]]],[1563352492266,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563352492266,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563352437883,["GJX@GJXAIOU",[[1,4316,"  - "]],[4316,4316],[4320,4320]]],[1563352442157,["GJX@GJXAIOU",[[-1,4322," "]],[4323,4323],[4322,4322]]],[1563352445303,["GJX@GJXAIOU",[[-1,4406," "]],[4407,4407],[4406,4406]]],[1563352447610,["GJX@GJXAIOU",[[1,4404,"  - "]],[4404,4404],[4408,4408]]],[1563352451474,["GJX@GJXAIOU",[[1,4478,"- "]],[4478,4478],[4480,4480]]],[1563352456950,["GJX@GJXAIOU",[[-1,4489," "]],[4490,4490],[4489,4489]]],[1563352461783,["GJX@GJXAIOU",[[-1,4543," "]],[4544,4544],[4543,4543]]],[1563352463575,["GJX@GJXAIOU",[[-1,4591," "]],[4592,4592],[4591,4591]]],[1563352467360,["GJX@GJXAIOU",[[1,4487,"- "],[1,4541,"- "],[1,4589,"- "]],[4489,4615],[4491,4621]]],[1563352468367,["GJX@GJXAIOU",[[1,4487,"  "],[1,4543,"  "],[1,4593,"  "]],[4491,4621],[4493,4627]]],[1563352552268,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563352552268,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563352501785,["GJX@GJXAIOU",[[1,4322,"=="],[1,4374,"=="]],[4322,4374],[4322,4378]]],[1563352511020,["GJX@GJXAIOU",[[1,4414,"=="],[1,4438,"=="]],[4414,4438],[4414,4442]]],[1563352519850,["GJX@GJXAIOU",[[-1,4440,"=="]],[4440,4442],[4440,4440]]],[1563352521406,["GJX@GJXAIOU",[[1,4460,"=="]],[4460,4460],[4462,4462]]],[1563352542079,["GJX@GJXAIOU",[[1,4499,"=="],[1,4552,"=="]],[4499,4552],[4499,4556]]],[1563352548561,["GJX@GJXAIOU",[[1,4561,"=="],[1,4608,"=="]],[4561,4608],[4561,4612]]],[1563352612269,[null,[[1,43,"\n## "],[-1,52," \n##"]],[43,43],[52,52]]],[1563352612269,[null,[[-1,43,"\n## "],[1,56," \n##"]],[52,52],[43,43]]],[1563352582870,["GJX@GJXAIOU",[[1,4617,"=="],[1,4643,"==，使用implements关键字来遵从接口"]],[4617,4643],[4666,4666]]],[1563352588702,["GJX@GJXAIOU",[[1,4648,"**"],[1,4658,"**"]],[4648,4658],[4648,4662]]],[1563352672272,[null,[[1,43,"\n## "],[-1,52," \n##"],[-1,4645,"=="],[-1,4648,"**"],[1,4652,"**"],[1,4660,"ts"],[-1,4662,"ts"],[1,4672,"=="]],[43,43],[4674,4674]]],[1563352672273,[null,[[-1,43,"\n## "],[1,56," \n##"],[1,4645,"=="],[1,4646,"**"],[-1,4648,"**"],[-1,4658,"ts"],[1,4662,"ts"],[-1,4670,"=="]],[4674,4674],[43,43]]],[1563352633887,["GJX@GJXAIOU",[[1,5380,"=="],[1,5411,"=="]],[5380,5411],[5380,5415]]],[1563352639552,["GJX@GJXAIOU",[[-1,5367,"总结的【多态】"]],[5367,5374],[5367,5367]]],[1563352640153,["GJX@GJXAIOU",[[1,5367,"- "]],[5367,5367],[5369,5369]]],[1563352644098,["GJX@GJXAIOU",[[1,5412,"- "]],[5412,5412],[5414,5414]]],[1563352852274,[null,[[1,43,"\n## "],[-1,52," \n##"],[-1,4645,"=="],[-1,4648,"**"],[1,4652,"**"],[1,4660,"ts"],[-1,4662,"ts"],[1,4672,"=="]],[43,43],[4674,4674]]],[1563352852274,[null,[[-1,43,"\n## "],[1,56," \n##"],[1,4645,"=="],[1,4646,"**"],[-1,4648,"**"],[-1,4658,"ts"],[1,4662,"ts"],[-1,4670,"=="]],[4674,4674],[43,43]]],[1563352818056,["GJX@GJXAIOU",[[1,5436,"=="],[1,5468,"=="]],[5436,5468],[5436,5472]]],[1563352823488,["GJX@GJXAIOU",[[1,5485,"=="],[1,5518,"=="]],[5485,5518],[5485,5522]]],[1563352827999,["GJX@GJXAIOU",[[-1,5484,"父"]],[5484,5485],[5484,5484]]],[1563352829663,["GJX@GJXAIOU",[[1,5486,"父"]],[5486,5486],[5487,5487]]],[1563352840248,["GJX@GJXAIOU",[[1,5534,"=="],[1,5575,"=="]],[5534,5575],[5534,5579]]],[1563352850221,["GJX@GJXAIOU",[[1,5596,"=="],[1,5616,"=="]],[5596,5616],[5596,5620]]],[1563353272279,[null,[[1,43,"\n## "],[-1,52," \n##"],[-1,4645,"=="],[-1,4648,"**"],[1,4652,"**"],[1,4660,"ts"],[-1,4662,"ts"],[1,4672,"=="]],[43,43],[4674,4674]]],[1563353272279,[null,[[-1,43,"\n## "],[1,56," \n##"],[1,4645,"=="],[1,4646,"**"],[-1,4648,"**"],[-1,4658,"ts"],[1,4662,"ts"],[-1,4670,"=="]],[4674,4674],[43,43]]],[1563353231861,["GJX@GJXAIOU",[[1,5633,"在方法中如果需要的参数是一个类对象，那么在这个参数中传入该类的【子类】对象也可以"]],[5633,5633],[5673,5673]]],[1563353234129,["GJX@GJXAIOU",[[-1,5626,"#"]],[5627,5627],[5626,5626]]],[1563353236892,["GJX@GJXAIOU",[[1,5627,"四、"]],[5627,5627],[5629,5629]]],[1563353242813,["GJX@GJXAIOU",[[1,5634,"=="],[1,5674,"=="]],[5634,5674],[5634,5678]]],[1563353392279,[null,[[1,43,"\n## "],[-1,52," \n##"],[-1,4645,"=="],[-1,4648,"**"],[1,4652,"**"],[1,4660,"ts"],[-1,4662,"ts"],[1,4672,"=="]],[43,43],[4674,4674]]],[1563353392279,[null,[[-1,43,"\n## "],[1,56," \n##"],[1,4645,"=="],[1,4646,"**"],[-1,4648,"**"],[-1,4658,"ts"],[1,4662,"ts"],[-1,4670,"=="]],[4674,4674],[43,43]]],[1563353341865,["GJX@GJXAIOU",[[-1,5987,"\t"]],[5988,5988],[5987,5987]]],[1563353377585,["GJX@GJXAIOU",[[-1,6202,"再"]],[6203,6203],[6202,6202]]],[1563353378651,["GJX@GJXAIOU",[[1,6202,"在"]],[6202,6202],[6203,6203]]],[1563353572285,[null,[[1,43,"\n## "],[-1,52," \n##"],[-1,4645,"=="],[-1,4648,"**"],[1,4652,"**"],[1,4660,"ts"],[-1,4662,"ts"],[1,4672,"=="]],[43,43],[4674,4674]]],[1563353572285,[null,[[-1,43,"\n## "],[1,56," \n##"],[1,4645,"=="],[1,4646,"**"],[-1,4648,"**"],[-1,4658,"ts"],[1,4662,"ts"],[-1,4670,"=="]],[4674,4674],[43,43]]],[1563353527314,["GJX@GJXAIOU",[[1,7033,"程序运行结果："]],[7033,7033],[7040,7040]]],[1563353527585,["GJX@GJXAIOU",[[1,7042,"\n"]],[7040,7040],[7041,7041]]],[1563353530089,["GJX@GJXAIOU",[[1,7041,"```h"]],[7041,7041],[7045,7045]]],[1563353530832,["GJX@GJXAIOU",[[-1,7044,"h"]],[7045,7045],[7044,7044]]],[1563353531548,["GJX@GJXAIOU",[[1,7044,"java"]],[7044,7044],[7048,7048]]],[1563353531752,["GJX@GJXAIOU",[[1,7050,"\n"]],[7048,7048],[7049,7049]]],[1563353532601,["GJX@GJXAIOU",[[1,7051,"\n"]],[7049,7049],[7050,7050]]],[1563353533266,["GJX@GJXAIOU",[[1,7050,"```"]],[7050,7050],[7053,7053]]],[1563353534664,["GJX@GJXAIOU",[[1,7049,"class lianxi.Monkey在吃东西\nclass lianxi.Tiger在吃东西\nclass lianxi.Snake在吃东西\nclass lianxi.Monkey在吃东西\nclass lianxi.Tiger在吃东西\nclass lianxi.Snake在吃东西\nclass lianxi.Monkey\nlianxi.Monkey@2a33fae0\nclass lianxi.Snake\nclass lianxi.Tiger"]],[7049,7049],[7269,7269]]],[1563353548185,["GJX@GJXAIOU",[[-1,5695,"com.qfedu.c_duotai"],[1,5713,"l"]],[5695,5713],[5696,5696]]],[1563353548781,["GJX@GJXAIOU",[[1,5696,"isncxi"]],[5696,5696],[5702,5702]]],[1563353550278,["GJX@GJXAIOU",[[-1,5697,"sncxi"]],[5702,5702],[5697,5697]]],[1563353551883,["GJX@GJXAIOU",[[1,5697,"anxi"]],[5697,5697],[5701,5701]]],[1563353632287,[null,[[1,43,"\n## "],[-1,52," \n##"],[-1,4645,"=="],[-1,4648,"**"],[1,4652,"**"],[1,4660,"ts"],[-1,4662,"ts"],[1,4672,"=="]],[43,43],[4674,4674]]],[1563353632287,[null,[[-1,43,"\n## "],[1,56," \n##"],[1,4645,"=="],[1,4646,"**"],[-1,4648,"**"],[-1,4658,"ts"],[1,4662,"ts"],[-1,4670,"=="]],[4674,4674],[43,43]]],[1563353586882,["GJX@GJXAIOU",[[-1,6347,"\n"]],[6348,6348],[6347,6347]]],[1563353589368,["GJX@GJXAIOU",[[-1,6381,"\n"]],[6381,6381],[6380,6380]]],[1563353594463,["GJX@GJXAIOU",[[-1,6412,"\n"]],[6413,6413],[6412,6412]]],[1563353872294,[null,[[1,43,"\n## "],[-1,52," \n##"],[-1,4645,"=="],[-1,4648,"**"],[1,4652,"**"],[1,4660,"ts"],[-1,4662,"ts"],[1,4672,"=="]],[43,43],[4674,4674]]],[1563353872294,[null,[[-1,43,"\n## "],[1,56," \n##"],[1,4645,"=="],[1,4646,"**"],[-1,4648,"**"],[-1,4658,"ts"],[1,4662,"ts"],[-1,4670,"=="]],[4674,4674],[43,43]]],[1563353831441,["GJX@GJXAIOU",[[1,7104,"---------------------------------------\n"],[1,7173,"\n---------------------------------------"]],[7034,7254],[7334,7334]]],[1563353841649,["GJX@GJXAIOU",[[-1,6598,"\t\t"],[1,6600,"\n"]],[6600,6600],[6599,6599]]],[1563353846695,["GJX@GJXAIOU",[[1,6599,"        System.out.println(\"---------------------------------------\");"]],[6599,6599],[6669,6669]]],[1563353848792,["GJX@GJXAIOU",[[1,6670,"        \n"]],[6669,6669],[6678,6678]]],[1563353851921,["GJX@GJXAIOU",[[-1,6836,"\t\t"],[1,6838,"\n"]],[6838,6838],[6837,6837]]],[1563353855456,["GJX@GJXAIOU",[[1,6837,"        System.out.println(\"---------------------------------------\");"]],[6837,6837],[6907,6907]]],[1563353856618,["GJX@GJXAIOU",[[1,6908,"        \n"]],[6907,6907],[6916,6916]]],[1563353866952,["GJX@GJXAIOU",[[1,6721,"\n\t\t"]],[6721,6721],[6724,6724]]],[1563353871249,["GJX@GJXAIOU",[[-1,6747,"是"]],[6748,6748],[6747,6747]]],[1563353932296,[null,[[1,43,"\n## "],[-1,52," \n##"],[-1,4645,"=="],[-1,4648,"**"],[1,4652,"**"],[1,4660,"ts"],[-1,4662,"ts"],[1,4672,"=="]],[43,43],[4674,4674]]],[1563353932296,[null,[[-1,43,"\n## "],[1,56," \n##"],[1,4645,"=="],[1,4646,"**"],[-1,4648,"**"],[-1,4658,"ts"],[1,4662,"ts"],[-1,4670,"=="]],[4674,4674],[43,43]]],[1563353873095,["GJX@GJXAIOU",[[-1,6749,"的"]],[6750,6750],[6749,6749]]],[1563353875983,["GJX@GJXAIOU",[[-1,6750,"一个"]],[6752,6752],[6750,6750]]],[1563353879328,["GJX@GJXAIOU",[[-1,6762,"\t\t\t  "]],[6767,6767],[6762,6762]]],[1563353881729,["GJX@GJXAIOU",[[1,6762,"   "]],[6762,6762],[6765,6765]]],[1563354172300,[null,[[1,43,"\n## "],[-1,52," \n##"],[-1,4645,"=="],[-1,4648,"**"],[1,4652,"**"],[1,4660,"ts"],[-1,4662,"ts"],[1,4672,"=="]],[43,43],[4674,4674]]],[1563354172300,[null,[[-1,43,"\n## "],[1,56," \n##"],[1,4645,"=="],[1,4646,"**"],[-1,4648,"**"],[-1,4658,"ts"],[1,4662,"ts"],[-1,4670,"=="]],[4674,4674],[43,43]]],[1563354134785,["GJX@GJXAIOU",[[1,7493,"\n"]],[7492,7492],[7493,7493]]],[1563354136434,["GJX@GJXAIOU",[[1,7493,"shili"]],[7493,7493],[7498,7498]]],[1563354137408,["GJX@GJXAIOU",[[-1,7493,"shili"]],[7498,7498],[7493,7493]]],[1563354140795,["GJX@GJXAIOU",[[1,7493,"示例代码二："]],[7493,7493],[7499,7499]]],[1563354292308,[null,[[1,43,"\n## "],[-1,52," \n##"],[-1,4645,"=="],[-1,4648,"**"],[1,4652,"**"],[1,4660,"ts"],[-1,4662,"ts"],[1,4672,"=="]],[43,43],[4674,4674]]],[1563354292308,[null,[[-1,43,"\n## "],[1,56," \n##"],[1,4645,"=="],[1,4646,"**"],[-1,4648,"**"],[-1,4658,"ts"],[1,4662,"ts"],[-1,4670,"=="]],[4674,4674],[43,43]]],[1563354244711,["GJX@GJXAIOU",[[-1,9410,"\n"]],[9410,9410],[9409,9409]]],[1563354244866,["GJX@GJXAIOU",[[-1,9409,"\n"]],[9409,9409],[9408,9408]]],[1563354245151,["GJX@GJXAIOU",[[-1,9408,"\n"]],[9408,9408],[9407,9407]]],[1563354245322,["GJX@GJXAIOU",[[-1,9407,"\n"]],[9407,9407],[9406,9406]]],[1563354245479,["GJX@GJXAIOU",[[-1,9406,"\n"]],[9406,9406],[9405,9405]]],[1563354245656,["GJX@GJXAIOU",[[-1,9405,"\n"]],[9405,9405],[9404,9404]]],[1563354245887,["GJX@GJXAIOU",[[-1,9404,"\n"]],[9404,9404],[9403,9403]]],[1563354246064,["GJX@GJXAIOU",[[-1,9403,"\n"]],[9403,9403],[9402,9402]]],[1563354246216,["GJX@GJXAIOU",[[-1,9402,"\n"]],[9402,9402],[9401,9401]]],[1563354246431,["GJX@GJXAIOU",[[-1,9401,"\n"]],[9401,9401],[9400,9400]]],[1563354246586,["GJX@GJXAIOU",[[-1,9400,"\n"]],[9400,9400],[9399,9399]]],[1563354247111,["GJX@GJXAIOU",[[-1,9399,"\n"]],[9399,9399],[9398,9398]]],[1563354254479,["GJX@GJXAIOU",[[-1,8378,"在一个方法中，需要的参数一个类对象，但是传入的参数是该类的【子类】对象，也是可以的"]],[8378,8419],[8378,8378]]],[1563354266898,["GJX@GJXAIOU",[[1,5679,"\n"]],[5678,5678],[5679,5679]]],[1563354267312,["GJX@GJXAIOU",[[1,5679,"在一个方法中，需要的参数一个类对象，但是传入的参数是该类的【子类】对象，也是可以的"]],[5679,5679],[5720,5720]]],[1563354272385,["GJX@GJXAIOU",[[-1,5679,"在一个方法中，需要的参数一个类对象，但是传入的参数是该类的【子类】对象，也是可以的"]],[5679,5720],[5679,5679]]],[1563354277418,["GJX@GJXAIOU",[[1,5634,"示例代码一；"]],[5634,5634],[5640,5640]]],[1563354278736,["GJX@GJXAIOU",[[-1,5639,"；"]],[5640,5640],[5639,5639]]],[1563354279197,["GJX@GJXAIOU",[[1,5639,"："]],[5639,5639],[5640,5640]]],[1563354282852,["GJX@GJXAIOU",[[-1,5685,"\n"]],[5685,5685],[5684,5684]]],[1563354352304,[null,[[1,43,"\n## "],[-1,52," \n##"],[-1,4645,"=="],[-1,4648,"**"],[1,4652,"**"],[1,4660,"ts"],[-1,4662,"ts"],[1,4672,"=="]],[43,43],[4674,4674]]],[1563354352304,[null,[[-1,43,"\n## "],[1,56," \n##"],[1,4645,"=="],[1,4646,"**"],[-1,4648,"**"],[-1,4658,"ts"],[1,4662,"ts"],[-1,4670,"=="]],[4674,4674],[43,43]]],[1563354292602,["GJX@GJXAIOU",[[-1,8390,"在一个方法中，定义的参数格式是一个接口，传入的参数是【遵从】该接口的对象，没有问题"]],[8390,8431],[8390,8390]]],[1563354295593,["GJX@GJXAIOU",[[1,7499,"\n"]],[7498,7498],[7499,7499]]],[1563354295712,["GJX@GJXAIOU",[[1,7500,"\n"]],[7499,7499],[7500,7500]]],[1563354298216,["GJX@GJXAIOU",[[1,7507,"在一个方法中，定义的参数格式是一个接口，传入的参数是【遵从】该接口的对象，没有问题"]],[7507,7507],[7548,7548]]],[1563354302761,["GJX@GJXAIOU",[[1,7507,"=="],[1,7548,"=="]],[7507,7548],[7507,7552]]],[1563354310003,["GJX@GJXAIOU",[[1,8371,"示例代码三："]],[8371,8371],[8377,8377]]],[1563354314048,["GJX@GJXAIOU",[[-1,8417,"/*\n 从前两个代码中总结这两句话\n \t！！！\n \t！！！\n \t\n\n\n */"]],[8417,8455],[8417,8417]]],[1563354314194,["GJX@GJXAIOU",[[-1,8417,"\n"]],[8417,8417],[8416,8416]]],[1563354344579,["GJX@GJXAIOU",[[1,8377,"多态：父类对象指向子类对西南"]],[8377,8377],[8391,8391]]],[1563354347375,["GJX@GJXAIOU",[[-1,8382,"对象指向子类对西南"]],[8391,8391],[8382,8382]]],[1563354351323,["GJX@GJXAIOU",[[1,8382,"引用指向子类"]],[8382,8382],[8388,8388]]],[1563354412308,[null,[[1,43,"\n## "],[-1,52," \n##"],[-1,4645,"=="],[-1,4648,"**"],[1,4652,"**"],[1,4660,"ts"],[-1,4662,"ts"],[1,4672,"=="]],[43,43],[4674,4674]]],[1563354412308,[null,[[-1,43,"\n## "],[1,56," \n##"],[1,4645,"=="],[1,4646,"**"],[-1,4648,"**"],[-1,4658,"ts"],[1,4662,"ts"],[-1,4670,"=="]],[4674,4674],[43,43]]],[1563354352564,["GJX@GJXAIOU",[[1,8388,"对象；"]],[8388,8388],[8391,8391]]],[1563354385492,["GJX@GJXAIOU",[[1,9355,"\n"]],[9354,9354],[9355,9355]]],[1563354387166,["GJX@GJXAIOU",[[-1,9355,"\n"],[1,9356,"程序"]],[9355,9355],[9357,9357]]],[1563354389564,["GJX@GJXAIOU",[[1,9357,"运行结果："]],[9357,9357],[9362,9362]]],[1563354389856,["GJX@GJXAIOU",[[1,9362,"\n\n"]],[9362,9362],[9363,9363]]],[1563354390955,["GJX@GJXAIOU",[[-1,9363,"\n"],[1,9364,"`"]],[9363,9363],[9364,9364]]],[1563354391324,["GJX@GJXAIOU",[[1,9364,"``"]],[9364,9364],[9366,9366]]],[1563354391359,["GJX@GJXAIOU",[[1,9366,"language\n```\n"]],[9366,9366],[9366,9374]]],[1563354391843,["GJX@GJXAIOU",[[-1,9366,"language"],[1,9374,"j"]],[9366,9374],[9367,9367]]],[1563354392266,["GJX@GJXAIOU",[[1,9367,"ava"]],[9367,9367],[9370,9370]]],[1563354392377,["GJX@GJXAIOU",[[1,9371,"\n"]],[9370,9370],[9371,9371]]],[1563354393353,["GJX@GJXAIOU",[[1,9371,"Housten Rocket\n90\n机械工程师"]],[9371,9371],[9394,9394]]]],null,"GJX@GJXAIOU"]]}