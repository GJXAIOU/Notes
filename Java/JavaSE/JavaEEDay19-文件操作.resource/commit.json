{"compress":true,"commitItems":[["765767a0-913d-48cb-b02c-1770f0cec8eb",1562305075960,"## 泛型\n    为了解决数据类型一致化问题\n    避免没有意义的强制类型转换\n    \n    自定义泛型泛型使用的格式：\n        <大写字母> 一般使用E 或者 T\n    占位符\n    \n    泛型在函数中使用\n        格式：\n        权限修饰符 <自定义泛型> 返回值类型(可以使用泛型) 函数名(形式参数列表“自定义泛型”) {\n            同样可以使用自定义泛型\n        }\n        \n    泛型在类中使用\n        格式：\n        class 类名<自定义泛型> {\n            非静态的成员变量或者成员方法都可以使用类中定义的<自定义泛型>\n            \n            静态方法不能使用类中自定义泛型，但是可以方法中自己定义泛型\n            \n        }\n        \n        Arrays.sort(T[] t, Comparator<? super T> c)\n        \n    泛型在接口中使用\n        格式：\n        interface 接口名<自定义泛型> {\n            //成员变量 缺省属性：public static final\n            //成员方法 缺省属性：abstract\n        }\n        \n        一个类遵从带有自定义泛型的接口有两种方式：\n            例如：\n                interface A<T> {\n                    public void testA(T t);\n                }\n            \n            1. 方式1：\n            class Test1<T> implements A<T> {\n                public void testA(T t) {\n                    //实现方法\n                }\n            }\n            更加自由，在创建类对象时，才对泛型进行约束\n            \n            2. 方式2 \n            class Test2 implements A<String> {\n                public void testA(String t) {\n                    //实现方法\n                }\n            }\n            遵从接口时，接口直接确定了泛型的具体类型\n            \n    泛型的上下限：\n        <? super T>\n            表示数据类型是T对象或者其父类对象\n        <? extends T>\n            表示数据类型是T对象或者其子类对象\n            \n## Map\n    Map<K, V> \n    ---| HashMap\n    ---| TreeMap\n    \n    put(K key , V value);\n    putAll(Map<? extends k, ? extends V> map)\n    \n    clear();\n    remove(Object k);\n    \n    size();\n    containsKey(Object key);\n    containsValue(Object Value);\n    \n    keySet();\n    values();\n    \n    get(Object k);\n\n## 简单介绍了一个匿名内部类\n    new Comparator<Student>() {\n        @Override   \n        public int compare(Student o1, Student o2) {\n            return o1.getAge() - o2.getAge();\n        }\n    }",[[1562305022301,["GJX@GJXAIOU",[[-1,24,"    "]],[28,28],[24,24]]],[1562305022965,["GJX@GJXAIOU",[[-1,23,"\n"]],[24,24],[23,23]]],[1562305024870,["GJX@GJXAIOU",[[1,23,","]],[23,23],[24,24]]],[1562305033960,["GJX@GJXAIOU",[[-1,8,"  "],[-1,40,"  "],[-1,43,"  "],[-1,67,"  "],[-1,89,"  "],[-1,95," "],[-1,98," "],[-1,100,"  "],[-1,119,"  "],[-1,125,"  "],[-1,192,"  "],[-1,206," "],[-1,213," "],[-1,222,"  "],[-1,225,"  "],[-1,243,"  "],[-1,249,"  "],[-1,275," "],[-1,286," "],[-1,329,"  "],[-1,332,"  "],[-1,384,"  "],[-1,387,"  "],[-1,397," "],[-1,404," "],[-1,406,"  "],[-1,464,"  "],[-1,467,"  "],[-1,486,"  "],[-1,492,"  "],[-1,533,"  "],[-1,577,"  "],[-1,600," "],[-1,607," "],[-1,616,"  "],[-1,619,"  "],[-1,659,"  "],[-1,665,"  "],[-1,698,"  "],[-1,756,"  "],[-1,760,"  "],[-1,783,"  "],[-1,793,"  "],[-1,838," "],[-1,853," "],[-1,897,"  "],[-1,906,"  "],[-1,934,"  "],[-1,938,"  "],[-1,972,"  "],[-1,995,"  "],[-1,1005,"  "],[-1,1052," "],[-1,1067," "],[-1,1116,"  "],[-1,1125,"  "],[-1,1153,"  "],[-1,1157,"  "],[-1,1190," "],[-1,1201," "],[-1,1203,"  "],[-1,1215,"  "],[-1,1245,"  "],[-1,1271,"  "],[-1,1287," "],[-1,1298," "],[-1,1327,"  "],[-1,1337,"  "],[-1,1354,"  "],[-1,1369," "],[-1,1372," "],[-1,1386," "],[-1,1389," "],[-1,1391,"  "],[-1,1417,"  "],[-1,1463," "],[-1,1466," "],[-1,1468,"  "],[-1,1481,"  "],[-1,1505,"  "],[-1,1508,"  "],[-1,1520," "],[-1,1523," "],[-1,1549,"  "],[-1,1582,"  "],[-1,1589,"  "],[-1,1601," "],[-1,1604," "],[-1,1615," "],[-1,1618," "],[-1,1620,"  "],[-1,1656,"  "],[-1,1694,"  "],[-1,1709,"  "],[-1,1762," "],[-1,1773," "],[-1,1814,"  "],[-1,1818,"  "]],[10,1823],[8,1659]]],[1562305046027,["GJX@GJXAIOU",[[-1,6,"  "],[-1,36,"  "],[-1,39,"  "],[-1,55,"  "],[-1,79,"  "],[-1,85,"  "],[-1,88,"  "],[-1,99," "],[-1,104," "],[-1,109,"  "],[-1,172,"  "],[-1,190,"  "],[-1,194,"  "],[-1,201,"  "],[-1,215,"  "],[-1,221," "],[-1,226," "],[-1,245,"  "],[-1,287," "],[-1,296," "],[-1,298,"  "],[-1,338," "],[-1,347," "],[-1,349,"  "],[-1,361,"  "],[-1,364,"  "],[-1,418,"  "],[-1,421,"  "],[-1,436,"  "],[-1,442," "],[-1,447," "],[-1,471,"  "],[-1,513," "],[-1,522," "],[-1,544,"  "],[-1,556,"  "],[-1,559,"  "],[-1,595,"  "],[-1,601,"  "],[-1,648,"  "],[-1,686,"  "],[-1,698,"  "],[-1,701," "],[-1,710," "],[-1,719,"  "],[-1,774,"  "],[-1,801,"  "],[-1,838,"  "],[-1,842,"  "],[-1,854,"  "],[-1,886," "],[-1,895," "],[-1,897,"  "],[-1,915,"  "],[-1,972,"  "],[-1,1004," "],[-1,1021," "],[-1,1029,"  "],[-1,1053,"  "],[-1,1057,"  "],[-1,1096,"  "],[-1,1099,"  "],[-1,1109,"  "],[-1,1127," "],[-1,1136," "],[-1,1159,"  "],[-1,1175," "],[-1,1184," "],[-1,1203,"  "]],[6,1213],[6,1097]]],[1562305047112,["GJX@GJXAIOU",[[-1,51,"  "],[-1,87,"  "],[-1,93,"  "],[-1,146," "],[-1,153," "],[-1,166,"  "],[-1,174,"  "],[-1,185," "],[-1,188," "],[-1,193,"  "],[-1,215,"  "],[-1,255," "],[-1,262," "],[-1,264,"  "],[-1,308,"  "],[-1,311," "],[-1,314," "],[-1,317,"  "],[-1,322,"  "],[-1,370," "],[-1,373," "],[-1,386,"  "],[-1,392,"  "],[-1,419," "],[-1,426," "],[-1,465,"  "],[-1,490,"  "],[-1,494," "],[-1,497," "],[-1,499,"  "],[-1,531,"  "],[-1,537," "],[-1,548," "],[-1,566,"  "],[-1,616,"  "],[-1,620,"  "],[-1,635,"  "],[-1,645,"  "],[-1,686,"  "],[-1,737,"  "],[-1,756,"  "],[-1,760,"  "],[-1,776,"  "],[-1,806,"  "],[-1,809,"  "],[-1,831,"  "],[-1,878,"  "],[-1,910,"  "],[-1,943,"  "],[-1,947,"  "],[-1,957,"  "],[-1,992,"  "],[-1,1003," "],[-1,1006," "],[-1,1019,"  "],[-1,1047,"  "],[-1,1063,"  "],[-1,1089,"  "]],[6,1097],[6,999]]],[1562305047710,["GJX@GJXAIOU",[[-1,49,"  "],[-1,83,"  "],[-1,89,"  "],[-1,140," "],[-1,145," "],[-1,158,"  "],[-1,162,"  "],[-1,173,"  "],[-1,179,"  "],[-1,199,"  "],[-1,237," "],[-1,242," "],[-1,244,"  "],[-1,284,"  "],[-1,287,"  "],[-1,291,"  "],[-1,294,"  "],[-1,340,"  "],[-1,352,"  "],[-1,358,"  "],[-1,383," "],[-1,388," "],[-1,425,"  "],[-1,448,"  "],[-1,452,"  "],[-1,455,"  "],[-1,483,"  "],[-1,489," "],[-1,498," "],[-1,516,"  "],[-1,562,"  "],[-1,566,"  "],[-1,577,"  "],[-1,587,"  "],[-1,626,"  "],[-1,673,"  "],[-1,690,"  "],[-1,694,"  "],[-1,706,"  "],[-1,734,"  "],[-1,737,"  "],[-1,755,"  "],[-1,800,"  "],[-1,832,"  "],[-1,861,"  "],[-1,865," "],[-1,870," "],[-1,873,"  "],[-1,904,"  "],[-1,915,"  "],[-1,929,"  "],[-1,953,"  "],[-1,969,"  "],[-1,993,"  "]],[6,999],[6,901]]],[1562305048193,["GJX@GJXAIOU",[[-1,136,"  "],[1,138,""],[-1,185,"  "],[-1,219,"  "],[-1,226,"  "],[-1,258,"  "],[-1,349,"  "],[-1,383,"  "],[-1,435,"  "],[-1,441," "],[-1,448," "],[-1,466,"  "],[-1,508,"  "],[-1,512," "],[-1,515," "],[-1,517,"  "],[-1,529,"  "],[-1,566,"  "],[-1,609,"  "],[-1,624,"  "],[-1,628,"  "],[-1,636,"  "],[-1,662,"  "],[-1,665,"  "],[-1,677," "],[-1,680," "],[-1,716,"  "],[-1,764,"  "],[-1,773," "],[-1,780," "],[-1,783,"  "],[-1,789,"  "],[-1,814,"  "],[-1,841,"  "],[-1,877,"  "],[-1,897,"  "]],[6,901],[6,839]]],[1562305054292,["GJX@GJXAIOU",[[1,6,"\n"]],[5,5],[6,6]]],[1562305082109,["GJX@GJXAIOU",[[1,34,"()"]],[34,34],[36,36]]],[1562305083878,["GJX@GJXAIOU",[[1,35,"fang"]],[35,35],[39,39]]],[1562305084839,["GJX@GJXAIOU",[[-1,35,"fang"]],[39,39],[35,35]]],[1562305094479,["GJX@GJXAIOU",[[1,35,"放进什么数据，拿出来什么数据"]],[35,35],[49,49]]],[1562305104471,["GJX@GJXAIOU",[[-1,83,"\n"]],[84,84],[83,83]]],[1562305105863,["GJX@GJXAIOU",[[1,83," "]],[83,83],[84,84]]],[1562305110981,["GJX@GJXAIOU",[[1,52,"- "]],[52,52],[54,54]]],[1562305113349,["GJX@GJXAIOU",[[1,7,"- "]],[7,7],[9,9]]],[1562305133178,["GJX@GJXAIOU",[[1,88,"，仅仅是"]],[88,88],[92,92]]],[1562305136990,["GJX@GJXAIOU",[[1,95,"；"]],[95,95],[96,96]]],[1562305139852,["GJX@GJXAIOU",[[1,98,"- "]],[98,98],[100,100]]],[1562305141869,["GJX@GJXAIOU",[[1,109,"  - "]],[109,109],[113,113]]],[1562305161357,["GJX@GJXAIOU",[[1,117,"  - \n"]],[116,116],[121,121]]],[1562305162990,["GJX@GJXAIOU",[[-1,117,"  - "]],[121,121],[117,117]]],[1562305164624,["GJX@GJXAIOU",[[1,117,"···"]],[117,117],[120,120]]],[1562305165519,["GJX@GJXAIOU",[[-1,117,"···"]],[120,120],[117,117]]],[1562305166959,["GJX@GJXAIOU",[[1,117,"```"]],[117,117],[120,120]]],[1562305166985,["GJX@GJXAIOU",[[1,120,"language\n```\n"]],[120,120],[120,128]]],[1562305168415,["GJX@GJXAIOU",[[-1,120,"language"],[1,128,"j"]],[120,128],[121,121]]],[1562305168854,["GJX@GJXAIOU",[[1,121,"ava"]],[121,121],[124,124]]],[1562305169453,["GJX@GJXAIOU",[[1,125,"\n"]],[124,124],[125,125]]],[1562305172701,["GJX@GJXAIOU",[[-1,131,"权限修饰符 <自定义泛型> 返回值类型(可以使用泛型) 函数名(形式参数列表“自定义泛型”) {\n  同样可以使用自定义泛型\n}"]],[131,195],[131,131]]],[1562305174093,["GJX@GJXAIOU",[[1,125,"权限修饰符 <自定义泛型> 返回值类型(可以使用泛型) 函数名(形式参数列表“自定义泛型”) {\n  同样可以使用自定义泛型\n}"]],[125,125],[189,189]]],[1562305177941,["GJX@GJXAIOU",[[-1,196,"\n"]],[195,195],[194,194]]],[1562305178069,["GJX@GJXAIOU",[[-1,195,"\n"]],[194,194],[193,193]]],[1562305181630,["GJX@GJXAIOU",[[1,195,"- "]],[195,195],[197,197]]],[1562305186350,["GJX@GJXAIOU",[[1,205,"  -  "]],[205,205],[210,210]]],[1562305190634,["GJX@GJXAIOU",[[1,214,"```"]],[214,214],[217,217]]],[1562305190660,["GJX@GJXAIOU",[[1,217,"language\n```\n"]],[217,217],[217,225]]],[1562305191817,["GJX@GJXAIOU",[[-1,217,"language"],[1,225,"j"]],[217,225],[218,218]]],[1562305192773,["GJX@GJXAIOU",[[1,218,"ava"]],[218,218],[221,221]]],[1562305192933,["GJX@GJXAIOU",[[1,222,"\n"]],[221,221],[222,222]]],[1562305196381,["GJX@GJXAIOU",[[-1,227,"class 类名<自定义泛型> {\n  非静态的成员变量或者成员方法都可以使用类中定义的<自定义泛型>\n  \n  静态方法不能使用类中自定义泛型，但是可以方法中自己定义泛型\n  \n}\n"]],[227,319],[227,227]]],[1562305198060,["GJX@GJXAIOU",[[1,222,"class 类名<自定义泛型> {\n  非静态的成员变量或者成员方法都可以使用类中定义的<自定义泛型>\n  \n  静态方法不能使用类中自定义泛型，但是可以方法中自己定义泛型\n  \n}\n"]],[222,222],[314,314]]],[1562305202238,["GJX@GJXAIOU",[[-1,308,"\n"]],[309,309],[308,308]]],[1562305235302,["GJX@GJXAIOU",[[1,319,"lir"]],[319,319],[322,322]]],[1562305236896,["GJX@GJXAIOU",[[-1,319,"lir"]],[322,322],[319,319]]],[1562305238041,["GJX@GJXAIOU",[[1,319,"力图 "]],[319,319],[321,321]]],[1562305238536,["GJX@GJXAIOU",[[-1,319,"力图"]],[321,321],[319,319]]],[1562305242854,["GJX@GJXAIOU",[[1,319,"例如：`"]],[319,319],[323,323]]],[1562305245254,["GJX@GJXAIOU",[[-1,323," "]],[324,324],[323,323]]],[1562305250326,["GJX@GJXAIOU",[[1,366,"`"]],[366,366],[367,367]]],[1562305255349,["GJX@GJXAIOU",[[1,369,"- "]],[369,369],[371,371]]],[1562305263208,["GJX@GJXAIOU",[[1,384,"\n"]],[384,384],[385,385]]],[1562305264399,["GJX@GJXAIOU",[[1,385,"···"]],[385,385],[388,388]]],[1562305265492,["GJX@GJXAIOU",[[-1,385,"···"]],[388,388],[385,385]]],[1562305267132,["GJX@GJXAIOU",[[-1,384,"\n"]],[385,385],[384,384]]],[1562305268429,["GJX@GJXAIOU",[[1,384,"```"]],[384,384],[387,387]]],[1562305268454,["GJX@GJXAIOU",[[1,387,"language\n```\n"]],[387,387],[387,395]]],[1562305269520,["GJX@GJXAIOU",[[-1,387,"language"],[1,395,"j"]],[387,395],[388,388]]],[1562305270181,["GJX@GJXAIOU",[[1,388,"ava"]],[388,388],[391,391]]],[1562305270309,["GJX@GJXAIOU",[[1,392,"\n"]],[391,391],[392,392]]],[1562305274341,["GJX@GJXAIOU",[[-1,397,"interface 接口名<自定义泛型> {\n  //成员变量 缺省属性：public static final\n  //成员方法 缺省属性：abstract\n}"]],[397,478],[397,397]]],[1562305275821,["GJX@GJXAIOU",[[1,392,"interface 接口名<自定义泛型> {\n  //成员变量 缺省属性：public static final\n  //成员方法 缺省属性：abstract\n}"]],[392,392],[473,473]]],[1562305292542,["GJX@GJXAIOU",[[1,480,"- "]],[480,480],[482,482]]],[1562305295224,["GJX@GJXAIOU",[[-1,479,"\n"]],[479,479],[478,478]]],[1562305326654,["GJX@GJXAIOU",[[1,507,"j"]],[507,507],[508,508]]],[1562305326678,["GJX@GJXAIOU",[[1,507," "]],[508,508],[509,509]]],[1562305326911,["GJX@GJXAIOU",[[1,509,"ie"]],[509,509],[511,511]]],[1562305328089,["GJX@GJXAIOU",[[-1,508,"jie"]],[511,511],[508,508]]],[1562305328850,["GJX@GJXAIOU",[[1,508,"Jir"]],[508,508],[511,511]]],[1562305329365,["GJX@GJXAIOU",[[-1,510,"r"]],[511,511],[510,510]]],[1562305330454,["GJX@GJXAIOU",[[1,510,"ekou"]],[510,510],[514,514]]],[1562305332013,["GJX@GJXAIOU",[[-1,507," Jiekou"]],[514,514],[507,507]]],[1562305332406,["GJX@GJXAIOU",[[1,507,"J"]],[507,507],[508,508]]],[1562305332431,["GJX@GJXAIOU",[[1,507," "]],[508,508],[509,509]]],[1562305332718,["GJX@GJXAIOU",[[1,509,"ie"]],[509,509],[511,511]]],[1562305333444,["GJX@GJXAIOU",[[-1,507," Jie"]],[511,511],[507,507]]],[1562305336983,["GJX@GJXAIOU",[[1,507,"接口如下"]],[507,507],[511,511]]],[1562305337312,["GJX@GJXAIOU",[[1,512,"："]],[511,511],[512,512]]],[1562305338029,["GJX@GJXAIOU",[[-1,512,"："]],[512,512],[511,511]]],[1562305348261,["GJX@GJXAIOU",[[1,592,"```java\n ```"]],[592,592],[604,604]]],[1562305356228,["GJX@GJXAIOU",[[-1,605,"class Test1<T> implements A<T> {\n      public void testA(T t) {\n          //实现方法\n      }\n  }"]],[605,697],[605,605]]],[1562305357701,["GJX@GJXAIOU",[[1,601,"\n "]],[599,599],[601,601]]],[1562305358117,["GJX@GJXAIOU",[[1,601,"class Test1<T> implements A<T> {\n      public void testA(T t) {\n          //实现方法\n      }\n  }"]],[601,601],[693,693]]],[1562305360181,["GJX@GJXAIOU",[[-1,591," "]],[592,592],[591,591]]],[1562305361380,["GJX@GJXAIOU",[[-1,693," "]],[694,694],[693,693]]],[1562305362717,["GJX@GJXAIOU",[[-1,692,"\n"]],[693,693],[692,692]]],[1562305363884,["GJX@GJXAIOU",[[1,692,"\n  "]],[692,692],[695,695]]],[1562305364573,["GJX@GJXAIOU",[[-1,694," "]],[695,695],[694,694]]],[1562305365821,["GJX@GJXAIOU",[[-1,590,"\n"]],[591,591],[590,590]]],[1562305366583,["GJX@GJXAIOU",[[1,590,"\n  "]],[590,590],[593,593]]],[1562305367293,["GJX@GJXAIOU",[[-1,592," "]],[593,593],[592,592]]],[1562305373319,["GJX@GJXAIOU",[[-1,694," "]],[695,695],[694,694]]],[1562305397504,["GJX@GJXAIOU",[[-1,701,"更加自由，在创建类对象时，才对泛型进行约束"]],[701,722],[701,701]]],[1562305399389,["GJX@GJXAIOU",[[1,590,"更加自由，在创建类对象时，才对泛型进行约束"]],[590,590],[611,611]]],[1562305402437,["GJX@GJXAIOU",[[-1,723,"  "]],[725,725],[723,723]]],[1562305402864,["GJX@GJXAIOU",[[-1,723,"\n"]],[723,723],[722,722]]],[1562305407413,["GJX@GJXAIOU",[[1,735,"3. \n  "]],[732,732],[738,738]]],[1562305409872,["GJX@GJXAIOU",[[-1,733,"  3. "]],[738,738],[733,733]]],[1562305410541,["GJX@GJXAIOU",[[-1,733,"\n"]],[733,733],[732,732]]],[1562305411568,["GJX@GJXAIOU",[[1,735,"3. \n  "]],[732,732],[738,738]]],[1562305412981,["GJX@GJXAIOU",[[-1,733,"  3. "]],[738,738],[733,733]]],[1562305414489,["GJX@GJXAIOU",[[1,733,"···"]],[733,733],[736,736]]],[1562305415472,["GJX@GJXAIOU",[[-1,733,"···"]],[736,736],[733,733]]],[1562305417045,["GJX@GJXAIOU",[[1,733,"```"]],[733,733],[736,736]]],[1562305417071,["GJX@GJXAIOU",[[1,736,"language\n```\n"]],[736,736],[736,744]]],[1562305417988,["GJX@GJXAIOU",[[-1,736,"language"],[1,744,"j"]],[736,744],[737,737]]],[1562305418414,["GJX@GJXAIOU",[[1,737,"ava"]],[737,737],[740,740]]],[1562305418476,["GJX@GJXAIOU",[[1,741,"\n"]],[740,740],[741,741]]],[1562305421565,["GJX@GJXAIOU",[[-1,749,"class Test2 implements A<String> {\n      public void testA(String t) {\n          //实现方法\n      }\n  }"]],[749,848],[749,749]]],[1562305423115,["GJX@GJXAIOU",[[1,741,"class Test2 implements A<String> {\n      public void testA(String t) {\n          //实现方法\n      }\n  }"]],[741,741],[840,840]]],[1562305425830,["GJX@GJXAIOU",[[-1,851,"遵从接口时，接口直接确定了泛型的具体类型"]],[851,871],[851,851]]],[1562305428644,["GJX@GJXAIOU",[[1,732,":遵从接口时，接口直接确定了泛型的具体类型"]],[732,732],[753,753]]],[1562305430678,["GJX@GJXAIOU",[[-1,721," "]],[721,721],[720,720]]],[1562305433303,["GJX@GJXAIOU",[[-1,872,"  "]],[874,874],[872,872]]],[1562305433443,["GJX@GJXAIOU",[[-1,872,"\n"]],[872,872],[871,871]]],[1562305433852,["GJX@GJXAIOU",[[-1,869,"  "]],[871,871],[869,869]]],[1562305437732,["GJX@GJXAIOU",[[-1,890,"  "]],[892,892],[890,890]]],[1562305438147,["GJX@GJXAIOU",[[-1,889,"\n"]],[890,890],[889,889]]],[1562305439192,["GJX@GJXAIOU",[[1,889,"  "]],[889,889],[891,891]]],[1562305441615,["GJX@GJXAIOU",[[-1,923,"  "]],[925,925],[923,923]]],[1562305441780,["GJX@GJXAIOU",[[-1,922,"\n"]],[923,923],[922,922]]],[1562305443256,["GJX@GJXAIOU",[[1,922,"·"]],[922,922],[923,923]]],[1562305444259,["GJX@GJXAIOU",[[-1,922,"·"]],[923,923],[922,922]]],[1562305445223,["GJX@GJXAIOU",[[1,922,"`"]],[922,922],[923,923]]],[1562305447160,["GJX@GJXAIOU",[[1,889,"`"]],[889,889],[890,890]]],[1562305449745,["GJX@GJXAIOU",[[1,878,"`"]],[878,878],[879,879]]],[1562305450665,["GJX@GJXAIOU",[[1,910,"`"]],[910,910],[911,911]]],[1562305453084,["GJX@GJXAIOU",[[1,912,"`"]],[912,912],[913,913]]],[1562305455020,["GJX@GJXAIOU",[[-1,910,"`"]],[911,911],[910,910]]],[1562305457523,["GJX@GJXAIOU",[[-1,869,"\n"]],[869,869],[868,868]]],[1562305458148,["GJX@GJXAIOU",[[-1,866,"  "]],[868,868],[866,866]]],[1562305458355,["GJX@GJXAIOU",[[-1,866,"\n"]],[866,866],[865,865]]],[1562305460949,["GJX@GJXAIOU",[[1,866,"- "]],[866,866],[868,868]]],[1562305487241,["GJX@GJXAIOU",[[1,954,"`"]],[954,954],[955,955]]],[1562305493319,["GJX@GJXAIOU",[[1,965,"` 键值对"]],[965,965],[970,970]]],[1562305497629,["GJX@GJXAIOU",[[1,973,"\n  "]],[970,970],[973,973]]],[1562305502413,["GJX@GJXAIOU",[[1,973,"两个实现类："]],[973,973],[979,979]]],[1562305553135,["GJX@GJXAIOU",[[1,1012,"常见的方式"]],[1012,1012],[1017,1017]]],[1562305554324,["GJX@GJXAIOU",[[-1,1015,"方式"]],[1017,1017],[1015,1015]]],[1562305555702,["GJX@GJXAIOU",[[1,1015,"方法："]],[1015,1015],[1018,1018]]],[1562305556036,["GJX@GJXAIOU",[[1,1021,"\n  "]],[1018,1018],[1021,1021]]],[1562305558885,["GJX@GJXAIOU",[[1,1021,"```java"]],[1021,1021],[1028,1028]]],[1562305559259,["GJX@GJXAIOU",[[1,1031,"\n  "]],[1028,1028],[1031,1031]]],[1562305561536,["GJX@GJXAIOU",[[1,1031,"```"]],[1031,1031],[1034,1034]]],[1562305564395,["GJX@GJXAIOU",[[1,1031,"\n  "]],[1028,1028],[1031,1031]]],[1562305568347,["GJX@GJXAIOU",[[-1,1039," put(K key , V value);\n  putAll(Map<? extends k, ? extends V> map)\n  \n  clear();\n  remove(Object k);\n  \n  size();\n  containsKey(Object key);\n  containsValue(Object Value);\n  \n  keySet();\n  values();\n  \n  get(Object k);"]],[1039,1257],[1039,1039]]],[1562305571644,["GJX@GJXAIOU",[[1,1031," put(K key , V value);\n  putAll(Map<? extends k, ? extends V> map)\n  \n  clear();\n  remove(Object k);\n  \n  size();\n  containsKey(Object key);\n  containsValue(Object Value);\n  \n  keySet();\n  values();\n  \n  get(Object k);"]],[1031,1031],[1249,1249]]],[1562305572973,["GJX@GJXAIOU",[[1,1021,"\n  "]],[1018,1018],[1021,1021]]],[1562305711598,["GJX@GJXAIOU",[[-1,1033,"  "],[-1,1057,"  "],[-1,1101,"  "],[-1,1104,"  "],[-1,1115,"  "],[-1,1135,"  "],[-1,1138,"  "],[-1,1148,"  "],[-1,1175,"  "],[-1,1206,"  "],[-1,1209,"  "],[-1,1221,"  "],[-1,1233,"  "],[-1,1236,"  "]],[1035,1252],[1033,1224]]],[1562305713051,["GJX@GJXAIOU",[[-1,1032," "]],[1033,1224],[1033,1224]]],[1562305719052,["GJX@GJXAIOU",[[-1,1022,"  "],[-1,1224,"  "]],[1022,1229],[1022,1225]]],[1562305721054,["GJX@GJXAIOU",[[1,1029,"  put(K key , V value);  putAll(Map<? extends k, ? extends V> map)  clear();  remove(Object k);  size();  containsKey(Object key);  containsValue(Object Value);  keySet();  values();  get(Object k);  ``````java"]],[1022,1225],[1232,1232]]],[1562305723695,["GJX@GJXAIOU",[[-1,1029,"  put(K key , V value);  putAll(Map<? extends k, ? extends V> map)  clear();  remove(Object k);  size();  containsKey(Object key);  containsValue(Object Value);  keySet();  values();  get(Object k);  ``````java"]],[1232,1232],[1022,1225]]],[1562305738163,["GJX@GJXAIOU",[[1,1247,"\n  "]],[1247,1247],[1250,1250]]],[1562305740075,["GJX@GJXAIOU",[[-1,1245,"  "]],[1247,1247],[1245,1245]]],[1562305741521,["GJX@GJXAIOU",[[1,1245,"···"]],[1245,1245],[1248,1248]]],[1562305742669,["GJX@GJXAIOU",[[-1,1245,"···"]],[1248,1248],[1245,1245]]],[1562305743895,["GJX@GJXAIOU",[[1,1245,"```"]],[1245,1245],[1248,1248]]],[1562305743921,["GJX@GJXAIOU",[[1,1248,"language\n```\n"]],[1248,1248],[1248,1256]]],[1562305744885,["GJX@GJXAIOU",[[-1,1248,"language"],[1,1256,"j"]],[1248,1256],[1249,1249]]],[1562305745373,["GJX@GJXAIOU",[[1,1249,"ava"]],[1249,1249],[1252,1252]]],[1562305745503,["GJX@GJXAIOU",[[1,1253,"\n"]],[1252,1252],[1253,1253]]],[1562305748916,["GJX@GJXAIOU",[[-1,1260," new Comparator<Student>() {\n      @Override   \n      public int compare(Student o1, Student o2) {\n          return o1.getAge() - o2.getAge();\n      }\n  }"]],[1260,1414],[1260,1260]]],[1562305750716,["GJX@GJXAIOU",[[1,1253," new Comparator<Student>() {\n      @Override   \n      public int compare(Student o1, Student o2) {\n          return o1.getAge() - o2.getAge();\n      }\n  }"]],[1253,1253],[1407,1407]]],[1562305763348,["GJX@GJXAIOU",[[-1,612," "],[-1,621," "],[-1,655," "],[-1,660," "],[-1,686," "],[-1,695," "],[-1,707,"  "],[-1,711,"  "]],[612,718],[612,710]]],[1562305766763,["GJX@GJXAIOU",[[-1,710," "],[1,711,"\n"]],[710,710],[711,711]]],[1562305780228,["GJX@GJXAIOU",[[-1,790,"  "],[-1,830,"  "],[-1,843,"  "],[-1,847,"  "]],[743,854],[743,846]]],[1562305781255,["GJX@GJXAIOU",[[-1,788,"  "],[-1,826,"  "],[-1,835,"  "]],[743,846],[743,840]]],[1562305787917,["GJX@GJXAIOU",[[-1,655,"  "],[-1,688,"  "],[-1,697,"  "]],[612,709],[612,703]]],[1562305790724,["GJX@GJXAIOU",[[-1,698,"\n"]],[699,699],[698,698]]],[1562305791863,["GJX@GJXAIOU",[[1,698,"\n"]],[698,698],[699,699]]],[1562305796132,["GJX@GJXAIOU",[[1,737,"  \n"]],[736,736],[739,739]]],[1562305800445,["GJX@GJXAIOU",[[-1,706,"  "]],[708,708],[706,706]]],[1562305803436,["GJX@GJXAIOU",[[-1,581,"  "]],[583,583],[581,581]]],[1562305820748,["GJX@GJXAIOU",[[1,1382,"\n"]],[1381,1381],[1382,1382]]],[1562305820869,["GJX@GJXAIOU",[[1,1383,"\n"]],[1382,1382],[1383,1383]]],[1562305829149,["GJX@GJXAIOU",[[1,1383,"#ma"]],[1383,1383],[1386,1386]]],[1562305829716,["GJX@GJXAIOU",[[-1,1383,"#ma"]],[1386,1386],[1383,1383]]],[1562305831209,["GJX@GJXAIOU",[[1,1383,"@"]],[1383,1383],[1384,1384]]],[1562305832036,["GJX@GJXAIOU",[[-1,1383,"@"]],[1384,1384],[1383,1383]]],[1562305836505,["GJX@GJXAIOU",[[1,1383,"## Map"]],[1383,1383],[1389,1389]]],[1562305837165,["GJX@GJXAIOU",[[1,1390,"\n"]],[1389,1389],[1390,1390]]],[1562305837303,["GJX@GJXAIOU",[[1,1391,"\n"]],[1390,1390],[1391,1391]]],[1562307017615,["GJX@GJXAIOU",[[1,1389,"bu"]],[1389,1389],[1391,1391]]],[1562307018443,["GJX@GJXAIOU",[[-1,1389,"bu"]],[1391,1391],[1389,1389]]],[1562307020295,["GJX@GJXAIOU",[[1,1389,"不中"]],[1389,1389],[1391,1391]]],[1562307020321,["GJX@GJXAIOU",[[1,1389," "]],[1391,1391],[1392,1392]]],[1562307021092,["GJX@GJXAIOU",[[-1,1389," 不中"]],[1392,1392],[1389,1389]]],[1562307023257,["GJX@GJXAIOU",[[1,1389," 补充"]],[1389,1389],[1392,1392]]],[1562307023652,["GJX@GJXAIOU",[[1,1395,"\n"]],[1392,1392],[1393,1393]]],[1562307027118,["GJX@GJXAIOU",[[1,1393,"```java"]],[1393,1393],[1400,1400]]],[1562307027223,["GJX@GJXAIOU",[[1,1403,"\n"]],[1400,1400],[1401,1401]]],[1562307030165,["GJX@GJXAIOU",[[1,1401,"```"]],[1401,1401],[1404,1404]]],[1562307032140,["GJX@GJXAIOU",[[1,1393,"\n"]],[1393,1393],[1394,1394]]],[1562307034285,["GJX@GJXAIOU",[[1,1402,"\n"]],[1401,1401],[1402,1402]]],[1562307034795,["GJX@GJXAIOU",[[1,1402,"/**\n * \n */\npackage study;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\n\t\tmap.put(\"MacBook Pro\", 22888);\n\t\tmap.put(\"iPhoneX\", 8398);\n\t\tmap.put(\"iPad Pro\", 5198);\n\t\t\n\t\tSystem.out.println(map);\n\t\t\n\t\t//第一种遍历方式：借助于keySet，通过key值拿到value值\n\t\tSet<String> set = map.keySet();\n\t\t\n\t\t//使用Set集合的Iterator迭代器\n\t\tIterator<String> it = set.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tString key = it.next(); //获取每一个Map中的key值\n\t\t\tint value = map.get(key);\n\t\t\t\n\t\t\tSystem.out.println(key + \"=\" + value);\n\t\t}\n\t\t//以上方法，不太合适，实际上获取的key值，再借助于Map里面的get方法，获取对应的Value\n\t\t//实际上并没有获取到完整的键值对\n\t\t\n\t\t\n\t\t\n\t\t//第二种方式：借助于values\n\t\tCollection<Integer> c = map.values();\n\t\t\n\t\tfor (Integer integer : c) {\n\t\t\tSystem.out.println(integer);\n\t\t}\n\t\t\n\t\t//以上方法也不适合，因为只能拿到value值，获取不到对应的key\n\t\t\n\t\t\n\t\t\n\t\t//在Java中万物皆对象，因此可以将键值对看成是一个类【必须会】\n\t\t/*\n\t \t将键值对，认为是一个对象，组成一个类，称之为Entry\n\t\t class Entry<K, V> {\n\t\t \tK key;\n\t\t \tV value;\n\t\t } \n\t\t 这里可以认为在Map集合中，保存的每一个键值对都是一个Entry对象，\n\t\t 然后将这些Entry对象获取出来，做成一个集合，然后对该集合进行遍历；\n\t\t entrySet();\n\t\t Map.Entry；Entry为Map的子接口，称为内部类\n\t\t */\n\t\tSet<Entry<String, Integer>> entrySet = map.entrySet();\n\t\t\n\t\tIterator<Entry<String, Integer>> it2 = entrySet.iterator();\n\t\t\n\t\twhile (it2.hasNext()) {\n\t\t\tSystem.out.println(it2.next());\n\t\t}\n\t}\n}\n\n\n\n\n\n"]],[1402,1402],[2818,2818]]],[1562307039627,["GJX@GJXAIOU",[[-1,2818,"\n"]],[2818,2818],[2817,2817]]],[1562307039756,["GJX@GJXAIOU",[[-1,2817,"\n"]],[2817,2817],[2816,2816]]],[1562307039911,["GJX@GJXAIOU",[[-1,2816,"\n"]],[2816,2816],[2815,2815]]],[1562307039998,["GJX@GJXAIOU",[[-1,2815,"\n"]],[2815,2815],[2814,2814]]],[1562307040140,["GJX@GJXAIOU",[[-1,2814,"\n"]],[2814,2814],[2813,2813]]],[1562307052725,["GJX@GJXAIOU",[[1,2819,"# wen"]],[2819,2819],[2824,2824]]],[1562307053550,["GJX@GJXAIOU",[[-1,2821,"wen"]],[2824,2824],[2821,2821]]],[1562307055231,["GJX@GJXAIOU",[[1,2821,"文件"]],[2821,2821],[2823,2823]]],[1562307056273,["GJX@GJXAIOU",[[1,2823,"操作"]],[2823,2823],[2825,2825]]],[1562307056788,["GJX@GJXAIOU",[[1,2826,"\n"]],[2825,2825],[2826,2826]]],[1562307056916,["GJX@GJXAIOU",[[1,2827,"\n"]],[2826,2826],[2827,2827]]],[1562307057006,["GJX@GJXAIOU",[[1,2828,"\n"]],[2827,2827],[2828,2828]]],[1562307059092,["GJX@GJXAIOU",[[1,2819,"\n"]],[2819,2819],[2820,2820]]],[1562307297147,["GJX@GJXAIOU",[[1,2828," IO:\n  \tInput Output\n  \tread  write\n  \t\n  \t只考虑文件操作情况下：\n  \t\t读取操作是：input read 从硬盘(存储设备) 到 内存\n  \t\t写入操作是：output write 从内存 到 硬盘(存储设备)\n  \t\t\n  \tHDD SSD 混合硬盘 SSD+HDD => HHD\n  \tSATA \n  \tM.2\n  \tPCIE\n  \t\n  \t如何操作文件或者文件夹：\n  \t\t创建，删除，剪切，复制，重命名，粘贴\n  \t\t\n  \t\tJava里万物皆对象\n  \t\t计算机世界里万物皆文件\n  \t\t\n  \tSun提供了一个File类，专门来操作【文件】和【文件夹】\n  \t\n  \t如何创建一个File类对象：\n  \t\tFile(String pathName);\n  \t\t根据文件路径创建File类对象，可以使【绝对路径】可以是【相对路径】\n  \t\t\n  \t\tFile(String parent, String child);\n  \t\t根据提供的父目录【文件夹】地址，和当前文件夹下的【子文件】或者【子文件夹】创建File类对象\n  \t\t\n  \t\tFile(File parent, String child);\n  \t\t根据创建好的父目录的File类对象，和这个目录下的【子文件】或者【子文件夹】创建File类对象\n  \t\t\n  \t【pathName】\n  \t\t\\n \\t \\\\ 转义字符\n  \t\t假如实际地址为：\n  \t\tC:\\aaa\\bbb 如果在代码中使用 \"C:\\\\aaa\\\\bbb\" LOW\n  \t\t\n  \t\t推荐使用 / 来区分路径\n  \t\t\n  \t\tJava是一个跨平台的语言\n  \t\tJava提供了一个系统变量\n  \t\tFile.separator 可以根据不同的系统换，自动填充文件分隔符\n  \t\t\n  \t\tisFile();\n  \t\tis文件夹英文();\n  \t\tcreateFile()\n  \t\trenameTo\n  \t\tcopy"]],[2828,2828],[3679,3679]]],[1562307307761,["GJX@GJXAIOU",[[-1,2833,"  "],[-1,2849,"  "],[-1,2864,"  "],[-1,2868,"  "],[-1,2883,"  "],[-1,2919,"  "],[-1,2957,"  "],[-1,2962,"  "],[-1,2993,"  "],[-1,3002,"  "],[-1,3009,"  "],[-1,3017,"  "],[-1,3021,"  "],[-1,3037,"  "],[-1,3060,"  "],[-1,3065,"  "],[-1,3080,"  "],[-1,3096,"  "],[-1,3101,"  "],[-1,3134,"  "],[-1,3138,"  "],[-1,3156,"  "],[-1,3183,"  "],[-1,3222,"  "],[-1,3227,"  "],[-1,3266,"  "],[-1,3317,"  "],[-1,3322,"  "],[-1,3359,"  "],[-1,3411,"  "],[-1,3416,"  "],[-1,3430,"  "],[-1,3448,"  "],[-1,3461,"  "],[-1,3504,"  "],[-1,3509,"  "],[-1,3526,"  "],[-1,3531,"  "],[-1,3549,"  "],[-1,3567,"  "],[-1,3607,"  "],[-1,3612,"  "],[-1,3626,"  "],[-1,3641,"  "],[-1,3658,"  "],[-1,3671,"  "]],[2836,3679],[2834,3587]]],[1562307308998,["GJX@GJXAIOU",[[-1,2833,"\t"],[-1,2847,"\t"],[-1,2860,"\t"],[-1,2862,"\t"],[-1,2875,"\t"],[-1,2909,"\t"],[-1,2946,"\t"],[-1,2948,"\t"],[-1,2977,"\t"],[-1,2984,"\t"],[-1,2989,"\t"],[-1,2995,"\t"],[-1,2997,"\t"],[-1,3011,"\t"],[-1,3032,"\t"],[-1,3036,"\t"],[-1,3048,"\t"],[-1,3062,"\t"],[-1,3065,"\t"],[-1,3096,"\t"],[-1,3098,"\t"],[-1,3115,"\t"],[-1,3139,"\t"],[-1,3177,"\t"],[-1,3179,"\t"],[-1,3216,"\t"],[-1,3266,"\t"],[-1,3268,"\t"],[-1,3303,"\t"],[-1,3354,"\t"],[-1,3356,"\t"],[-1,3368,"\t"],[-1,3385,"\t"],[-1,3395,"\t"],[-1,3436,"\t"],[-1,3440,"\t"],[-1,3455,"\t"],[-1,3457,"\t"],[-1,3474,"\t"],[-1,3489,"\t"],[-1,3527,"\t"],[-1,3531,"\t"],[-1,3542,"\t"],[-1,3555,"\t"],[-1,3571,"\t"],[-1,3581,"\t"]],[2834,3587],[2833,3541]]],[1562307312224,["GJX@GJXAIOU",[[-1,2871,"\t"],[-1,2904,"\t"],[-1,2939,"\t"],[-1,2998,"\t"],[-1,3018,"\t"],[-1,3020,"\t"],[-1,3032,"\t"],[-1,3045,"\t"],[-1,3093,"\t"],[-1,3117,"\t"],[-1,3153,"\t"],[-1,3155,"\t"],[-1,3191,"\t"],[-1,3239,"\t"],[-1,3241,"\t"],[-1,3275,"\t"],[-1,3324,"\t"],[-1,3337,"\t"],[-1,3352,"\t"],[-1,3362,"\t"],[-1,3402,"\t"],[-1,3404,"\t"],[-1,3418,"\t"],[-1,3420,"\t"],[-1,3435,"\t"],[-1,3450,"\t"],[-1,3487,"\t"],[-1,3489,"\t"],[-1,3500,"\t"],[-1,3512,"\t"],[-1,3526,"\t"],[-1,3536,"\t"]],[2833,3541],[2833,3509]]],[1562307358181,["GJX@GJXAIOU",[[1,2871,"   "]],[2871,2871],[2874,2874]]],[1562307359195,["GJX@GJXAIOU",[[-1,2873," "]],[2874,2874],[2873,2873]]],[1562307360684,["GJX@GJXAIOU",[[1,2905,"  "]],[2905,2905],[2907,2907]]],[1562307364655,["GJX@GJXAIOU",[[1,2872,"-"]],[2872,2872],[2873,2873]]],[1562307364849,["GJX@GJXAIOU",[[1,2874," "]],[2873,2873],[2874,2874]]],[1562307368121,["GJX@GJXAIOU",[[1,2909,"- "]],[2909,2909],[2911,2911]]],[1562307370646,["GJX@GJXAIOU",[[-1,2908," "]],[2909,2909],[2908,2908]]],[1562307546651,["GJX@GJXAIOU",[[-1,2945,"HDD SSD 混合硬盘 SSD+HDD => HHD\nSATA \nM.2\nPCIE"]],[2945,2987],[2945,2945]]],[1562307547310,["GJX@GJXAIOU",[[-1,2946,"\n"]],[2945,2945],[2944,2944]]],[1562307547661,["GJX@GJXAIOU",[[-1,2945,"\n"]],[2944,2944],[2943,2943]]],[1562308032838,["GJX@GJXAIOU",[[1,3002,"- "]],[3002,3002],[3004,3004]]],[1562308034725,["GJX@GJXAIOU",[[-1,3034,"\n"]],[3034,3034],[3033,3033]]],[1562308037918,["GJX@GJXAIOU",[[1,3034,"  - "]],[3034,3034],[3038,3038]]],[1562308052980,["GJX@GJXAIOU",[[-1,3094,"使"]],[3095,3095],[3094,3094]]],[1562308055510,["GJX@GJXAIOU",[[1,3094,"是"]],[3094,3094],[3095,3095]]],[1562308414187,["GJX@GJXAIOU",[[-1,3034,"  - "]],[3034,3038],[3034,3034]]],[1562308414965,["GJX@GJXAIOU",[[1,3034,"··"]],[3034,3034],[3036,3036]]],[1562308416348,["GJX@GJXAIOU",[[-1,3034,"··"]],[3036,3036],[3034,3034]]],[1562308418915,["GJX@GJXAIOU",[[1,3034,"```j "]],[3034,3034],[3038,3038]]],[1562308419644,["GJX@GJXAIOU",[[1,3038,"ava"]],[3038,3038],[3041,3041]]],[1562308420019,["GJX@GJXAIOU",[[1,3041,"\n"]],[3041,3041],[3042,3042]]],[1562308423700,["GJX@GJXAIOU",[[1,3281,"```"]],[3281,3281],[3284,3284]]],[1562308425988,["GJX@GJXAIOU",[[1,3034,"\n"]],[3034,3034],[3035,3035]]],[1562308474598,["GJX@GJXAIOU",[[-1,3319,"\n"]],[3320,3320],[3319,3319]]],[1562308601788,["GJX@GJXAIOU",[[1,3371,",bushi"]],[3371,3371],[3377,3377]]],[1562308602498,["GJX@GJXAIOU",[[-1,3372,"bushi"]],[3377,3377],[3372,3372]]],[1562308609527,["GJX@GJXAIOU",[[1,3372,"不使用反斜杠"]],[3372,3372],[3378,3378]]],[1562308612678,["GJX@GJXAIOU",[[-1,3379,"\n"]],[3379,3379],[3378,3378]]],[1562308649797,["GJX@GJXAIOU",[[1,3443,"```java"]],[3443,3443],[3450,3450]]],[1562308649914,["GJX@GJXAIOU",[[1,3451,"\n"]],[3450,3450],[3451,3451]]],[1562308653518,["GJX@GJXAIOU",[[1,3500,"```"]],[3500,3500],[3503,3503]]],[1562308655013,["GJX@GJXAIOU",[[-1,3451,"\n"]],[3451,3451],[3450,3450]]],[1562308657338,["GJX@GJXAIOU",[[1,3443,"\n"]],[3443,3443],[3444,3444]]],[1562308750958,["GJX@GJXAIOU",[[1,3443,"shili"]],[3443,3443],[3448,3448]]],[1562308751746,["GJX@GJXAIOU",[[-1,3443,"shili"]],[3448,3448],[3443,3443]]],[1562308753405,["GJX@GJXAIOU",[[1,3443,"示例："]],[3443,3443],[3446,3446]]],[1562308753690,["GJX@GJXAIOU",[[1,3447,"\n"]],[3446,3446],[3447,3447]]],[1562308756500,["GJX@GJXAIOU",[[1,3447,"```java"]],[3447,3447],[3454,3454]]],[1562308756716,["GJX@GJXAIOU",[[1,3455,"\n"]],[3454,3454],[3455,3455]]],[1562308756861,["GJX@GJXAIOU",[[1,3456,"\n"]],[3455,3455],[3456,3456]]],[1562308757996,["GJX@GJXAIOU",[[1,3456,"```"]],[3456,3456],[3459,3459]]],[1562308759334,["GJX@GJXAIOU",[[1,3460,"\n"]],[3459,3459],[3460,3460]]],[1562308759450,["GJX@GJXAIOU",[[1,3461,"\n"]],[3460,3460],[3461,3461]]],[1562308770237,["GJX@GJXAIOU",[[1,3455,"public class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tFile file1 = new File(\"C:\\\\aaa\"); //采用Windows的分隔符\n\t\tFile file2 = new File(\"C:/aaa\"); //用在Linux和Windows通用的分隔符\n\t\tFile file3 = new File(\"C:\" + File.separator + \"aaa\"); //这里使用Java系统变量\n\t\t\n\t\tSystem.out.println(file1);\n\t\tSystem.out.println(file2);\n\t\tSystem.out.println(file3);\n\t\t\n\t\tFile file4 = new File(\"C:\\\\aaa\", \"1.txt\");\n\t\tSystem.out.println(file4);\n\t\t\n\t\tFile file5 = new File(file1, \"1.txt\");\n\t\tSystem.out.println(file5);\n\t}\n}"]],[3455,3455],[3944,3944]]],[1562308785294,["GJX@GJXAIOU",[[1,3837," //父目录  子目录"]],[3837,3837],[3848,3848]]],[1562308788810,["GJX@GJXAIOU",[[-1,3844," "]],[3844,3844],[3843,3843]]],[1562308817869,["GJX@GJXAIOU",[[-1,3960,"\n"]],[3960,3960],[3959,3959]]],[1562308825661,["GJX@GJXAIOU",[[1,3959,"File操作"]],[3959,3959],[3965,3965]]],[1562308825690,["GJX@GJXAIOU",[[1,3963," "]],[3965,3965],[3966,3966]]],[1562308835833,["GJX@GJXAIOU",[[1,3966,"常见方法："]],[3966,3966],[3971,3971]]],[1562308840877,["GJX@GJXAIOU",[[1,3959,"\n"]],[3959,3959],[3960,3960]]],[1562309315186,["GJX@GJXAIOU",[[1,4033,"\n"]],[4032,4032],[4033,4033]]],[1562309315317,["GJX@GJXAIOU",[[1,4034,"\n"]],[4033,4033],[4034,4034]]],[1562309315467,["GJX@GJXAIOU",[[1,4035,"\n"]],[4034,4034],[4035,4035]]],[1562309316898,["GJX@GJXAIOU",[[1,4035,"可以利用File类对象，创建文件或者文件夹\n\t\n\tboolean createNewFile(); 创建文件\n\t\t使用File类对象，创建File类对象里面保存的地址 指定 的 普通文件\n\t\t返回值boolean: 创建成功返回true，创建失败返回false\n\t\t返回false失败原因:\n\t\t\t1. 该文件已经存在\n\t\t\t2. 操作路径非法，例如：文件指定所在文件夹不存在\n\t\t\t3. 操作的文件夹没有写入权限\n\t\t\t4. 硬盘坏了\n\t【要求】\n\t\t创建文件，必须带有文件后缀名！！！\n\t\t.java .class .doc .txt .xml .html .css .js .md .jsp \n\t\t.m .h .c .cpp .php .net .ppt .xls .exe .zip .rar .mp4\n\t\t.rmvb\n\t\t\n\t\t\n\tboolean mkdir(); make direcotry 创建文件夹\n\t\t使用File类对象里面保存的文件夹地址，创建对应的文件夹\n\t\t返回值：boolean 创建成功返回true 创建失败返回false\n\t\t失败原因：\n\t\t\t1. 已经存在该文件夹\n\t\t\t2. 指定创建文件夹的父目录没有写入权限\n\t\t\t3. 要创建文件夹的父目录不存在\n\tboolean mkdirs();\n\t\t使用File类对象里面保存的文件夹路径地址，创建指定文件夹，如果该路径中的【中间文件夹】不存在\n\t\t把中间路径，同时创建\n\t\t返回值：boolean 创建成功返回true 创建失败返回false\n\t\t失败原因:\n\t\t\t1. 已经存在该文件夹\n\t\t\t2. 指定创建文件夹没有写入权限\n\t\tC:/aaa/ccc/ddd/eee/fff/ggg/hhh/iii/jjj\n\t\t\n\tboolean renameTo(File dest);\n\t\t功能1：\n\t\t\t重命名！！！文件 或者 文件夹\n\t\t功能2：\n\t\t\t剪切，移动到另一个位置\n\t\t\n\t\t作业：\n\t\t测试，renameTo操作一个非空文件夹！！！"]],[4035,4035],[4897,4897]]],[1562309329515,["GJX@GJXAIOU",[[-1,4059,"\t"],[-1,4090,"\t"],[-1,4129,"\t"],[-1,4167,"\t"],[-1,4181,"\t"],[-1,4197,"\t"],[-1,4226,"\t"],[-1,4243,"\t"],[-1,4254,"\t"],[-1,4260,"\t"],[-1,4281,"\t"],[-1,4335,"\t"],[-1,4391,"\t"],[-1,4400,"\t"],[-1,4402,"\t"],[-1,4405,"\t"],[-1,4445,"\t"],[-1,4475,"\t"],[-1,4513,"\t"],[-1,4520,"\t"],[-1,4537,"\t"],[-1,4561,"\t"],[-1,4579,"\t"],[-1,4599,"\t"],[-1,4648,"\t"],[-1,4662,"\t"],[-1,4699,"\t"],[-1,4706,"\t"],[-1,4723,"\t"],[-1,4741,"\t"],[-1,4783,"\t"],[-1,4785,"\t"],[-1,4816,"\t"],[-1,4822,"\t"],[-1,4841,"\t"],[-1,4850,"\t"],[-1,4864,"\t"],[-1,4866,"\t"],[-1,4872,"\t"],[-1,4898," "]],[4060,4899],[4059,4860]]],[1562309342228,["GJX@GJXAIOU",[[1,4059,"- "]],[4059,4059],[4061,4061]]],[1562309346060,["GJX@GJXAIOU",[[1,4392,"- "]],[4392,4392],[4394,4394]]],[1562309350188,["GJX@GJXAIOU",[[1,4758,"- "]],[4758,4758],[4760,4760]]],[1562309365365,["GJX@GJXAIOU",[[1,4463,"- "]],[4463,4463],[4465,4465]]],[1562309367420,["GJX@GJXAIOU",[[1,4501,"- "]],[4501,4501],[4503,4503]]],[1562309372764,["GJX@GJXAIOU",[[1,4565,"- "]],[4565,4565],[4567,4567]]],[1562309376798,["GJX@GJXAIOU",[[1,4647,"- "]],[4647,4647],[4649,4649]]],[1562309378766,["GJX@GJXAIOU",[[1,4685,"- "]],[4685,4685],[4687,4687]]],[1562309389142,["GJX@GJXAIOU",[[1,4800,"- "]],[4800,4800],[4802,4802]]],[1562309391181,["GJX@GJXAIOU",[[1,4826,"- "]],[4826,4826],[4828,4828]]],[1562309401901,["GJX@GJXAIOU",[[1,4035,"@"]],[4035,4035],[4036,4036]]],[1562309403027,["GJX@GJXAIOU",[[-1,4035,"@"]],[4036,4036],[4035,4035]]],[1562309403555,["GJX@GJXAIOU",[[1,4035,"## "]],[4035,4035],[4059,4059]]],[1562309426467,["GJX@GJXAIOU",[[1,4882,"\t\n"]],[4881,4881],[4883,4883]]],[1562309426646,["GJX@GJXAIOU",[[-1,4882,"\t"],[1,4883,"\n"]],[4883,4883],[4883,4883]]],[1562309430209,["GJX@GJXAIOU",[[-1,4883,"\n"],[1,4884,"程序"]],[4883,4883],[4885,4885]]],[1562309432015,["GJX@GJXAIOU",[[1,4885,"测试："]],[4885,4885],[4888,4888]]],[1562309432692,["GJX@GJXAIOU",[[1,4888,"\n\n"]],[4888,4888],[4889,4889]]],[1562309433600,["GJX@GJXAIOU",[[-1,4889,"\n"],[1,4890,"`"]],[4889,4889],[4890,4890]]],[1562309435305,["GJX@GJXAIOU",[[1,4890,"``java"]],[4890,4890],[4896,4896]]],[1562309435484,["GJX@GJXAIOU",[[1,4896,"\n\n"]],[4896,4896],[4897,4897]]],[1562309435615,["GJX@GJXAIOU",[[1,4898,"\n"]],[4897,4897],[4898,4898]]],[1562309436341,["GJX@GJXAIOU",[[-1,4898,"\n"],[1,4899,"`"]],[4898,4898],[4899,4899]]],[1562309436679,["GJX@GJXAIOU",[[1,4899,"``"]],[4899,4899],[4901,4901]]],[1562309449339,["GJX@GJXAIOU",[[1,4898,"\n"]],[4897,4897],[4898,4898]]],[1562309449825,["GJX@GJXAIOU",[[1,4898,"public class Demo2 {\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\t//创建文件\n\t\tFile file1 = new File(\"C:/aaa/1.txt\");\n\t\t\n\t\tboolean ret = file1.createNewFile();\n\t\tSystem.out.println(\"文件创建成功了吗?\" + ret);\n\t\t\n//\t\tFile file2 = new File(\"C:/bb/1.txt\");\n//\t\tSystem.out.println(file2.createNewFile());\n\t\t\n\t\tFile file2 = new File(\"C:/aaa/bbb\");\n\t\tret = file2.mkdir();\n\t\tSystem.out.println(\"文件夹创建成功了吗?\" + ret);\n\t\t\n\t\tFile file3 = new File(\"C:/aaa/ccc/ddd\");\n\t\tret = file3.mkdir();\n\t\tSystem.out.println(\"文件夹创建成功了吗?\" + ret);\n\t\t\n\t\tFile file4 = new File(\"C:/aaa/ccc/ddd/eee/fff/ggg/hhh/iii/jjj\");\n\t\tret = file4.mkdirs();\n\t\tSystem.out.println(\"文件夹创建成功了吗?\" + ret);\n\t\t\n\t\t\n\t\tFile dest1 = new File(\"C:/aaa/2.txt\");\n\t\t//把C:/aaa/1.txt 重命名！！！\n\t\tret = file1.renameTo(dest1);\n\t\tSystem.out.println(\"重命名成功了吗?\" + ret);\n\t\t\n\t\tret = file2.renameTo(new File(\"C:/aaa/ddd\"));\n\t\tSystem.out.println(\"重命名文件夹成功了吗?\" + ret);\n\t\t\n\t\t//测试剪切功能\n\t\t//原地址要带有文件或者文件夹名，而且目标地址也有带有文件或者文件夹名\n\t\tFile txt3 = new File(\"C:/aaa/3.txt\");//C:\\Users\\刘晓磊\\Desktop\n\t\tFile dest2 = new File(\"C:\\\\Users\\\\刘晓磊\\\\Desktop\\\\3.txt\");\n\t\t\n\t\tret = txt3.renameTo(dest2);\n\t\tSystem.out.println(\"剪切成功了吗?\" + ret);\n\t\t\n\t}\n}"]],[4898,4898],[6051,6051]]],[1562309460121,["GJX@GJXAIOU",[[1,4897,"import java.io.File;\nimport java.io.IOException;"]],[4897,4897],[4945,4945]]],[1562309461738,["GJX@GJXAIOU",[[1,4946,"\n"]],[4945,4945],[4946,4946]]],[1562309515194,["GJX@GJXAIOU",[[-1,4637,"\t"]],[4637,4638],[4637,4637]]],[1562309516201,["GJX@GJXAIOU",[[-1,4636,"\n"]],[4637,4637],[4636,4636]]],[1562309518205,["GJX@GJXAIOU",[[1,4636,","]],[4636,4636],[4637,4637]]],[1562311305740,["GJX@GJXAIOU",[[-1,5938,"//C:\\Users\\刘晓磊\\Desktop"]],[5938,5960],[5938,5938]]],[1562312521858,["GJX@GJXAIOU",[[1,6081,"\n\n"]],[6081,6081],[6082,6082]]],[1562312522010,["GJX@GJXAIOU",[[1,6083,"\n"]],[6082,6082],[6083,6083]]],[1562312523037,["GJX@GJXAIOU",[[1,6083,"delete()\n \t\t删除文件或者文件夹，但是如果操作文件夹的话，只能删除空文件夹\n \t\t成功返回true ，失败返回false\n \t\t\n \t\t该删除操作不是把文件或者文件夹放入到回收站里，而是直接从磁盘上抹去数据\n \t\t该操作不可逆\n \t\n \tdeleteOnExit()\n \t\t当JVM虚拟机运行终止之后，删除指定的文件或者文件夹，而不是调用立即删除\n \t\t\n \t\t用途：\n \t\t\t用于删除程序运行结束之后残留的缓存文件或者运行日志文件，节约硬盘空间"]],[6083,6083],[6311,6311]]],[1562312527156,["GJX@GJXAIOU",[[1,6083,"- "]],[6083,6083],[6085,6085]]],[1562312530914,["GJX@GJXAIOU",[[-1,6208,"\t"]],[6208,6209],[6208,6208]]],[1562312531524,["GJX@GJXAIOU",[[1,6208,"- "]],[6208,6208],[6210,6210]]],[1562312540225,["GJX@GJXAIOU",[[-1,6265," \t"]],[6267,6267],[6265,6265]]],[1562312540707,["GJX@GJXAIOU",[[-1,6264,"\n"]],[6265,6265],[6264,6264]]],[1562312545696,["GJX@GJXAIOU",[[-1,6150,"\n"]],[6151,6151],[6150,6150]]],[1562312553379,["GJX@GJXAIOU",[[-1,6193," \t\t"]],[6193,6196],[6193,6193]]],[1562312554300,["GJX@GJXAIOU",[[-1,6192,"\n"]],[6193,6193],[6192,6192]]],[1562312555845,["GJX@GJXAIOU",[[1,6192,","]],[6192,6192],[6193,6193]]],[1562312563141,["GJX@GJXAIOU",[[1,6265,"- "]],[6265,6265],[6267,6267]]],[1562312566284,["GJX@GJXAIOU",[[-1,6264,"\t"]],[6265,6265],[6264,6264]]],[1562312575713,["GJX@GJXAIOU",[[-1,6128," \t\t"]],[6131,6131],[6128,6128]]],[1562312576179,["GJX@GJXAIOU",[[-1,6127,"\n"]],[6128,6128],[6127,6127]]],[1562312578678,["GJX@GJXAIOU",[[1,6127,","]],[6127,6127],[6128,6128]]],[1562312584770,["GJX@GJXAIOU",[[1,6306," \t\t\t\n"]],[6305,6305],[6310,6310]]],[1562312587309,["GJX@GJXAIOU",[[-1,6307,"\t\t\t"]],[6310,6310],[6307,6307]]],[1562312587923,["GJX@GJXAIOU",[[-1,6306," "],[1,6307,"\n"]],[6307,6307],[6307,6307]]],[1562312603914,["GJX@GJXAIOU",[[1,6308,"\n"]],[6306,6306],[6307,6307]]],[1562312604923,["GJX@GJXAIOU",[[1,6307,"daim"]],[6307,6307],[6311,6311]]],[1562312605989,["GJX@GJXAIOU",[[-1,6307,"daim"]],[6311,6311],[6307,6307]]],[1562312609757,["GJX@GJXAIOU",[[1,6307,"代码示例："]],[6307,6307],[6312,6312]]],[1562312610154,["GJX@GJXAIOU",[[1,6314,"\n"]],[6312,6312],[6313,6313]]],[1562312612883,["GJX@GJXAIOU",[[1,6313,"```java"]],[6313,6313],[6320,6320]]],[1562312612931,["GJX@GJXAIOU",[[1,6322,"\n"]],[6320,6320],[6321,6321]]],[1562312614037,["GJX@GJXAIOU",[[1,6323,"\n"]],[6321,6321],[6322,6322]]],[1562312615303,["GJX@GJXAIOU",[[1,6322,"```"]],[6322,6322],[6325,6325]]],[1562312616858,["GJX@GJXAIOU",[[1,6321,"public class Demo3 {\n\tpublic static void main(String[] args) {\n\t\tFile file1 = new File(\"C:/aaa/1.txt\");\n\t\t\n\t\tSystem.out.println(\"删除成功了吗?\" + file1.delete());\n\t\t\n\t\tFile file2 = new File(\"C:/aaa/ddd\");\n\t\tSystem.out.println(\"删除成功了吗?\" + file2.delete());\n\t\t\n\t\tFile file3 = new File(\"C:/aaa/ccc\");\n\t\tSystem.out.println(\"删除成功了吗?\" + file3.delete()); //返回false\n\t\t\n\t\t// deleteOnExit()使用方法\n\t\tFile file4 = new File(\"C:/aaa/2.txt\");\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfile4.deleteOnExit();\n\t\tsc.nextLine();\n\t}\n}"]],[6321,6321],[6827,6827]]],[1562312619601,["GJX@GJXAIOU",[[1,6321,"\n"]],[6320,6320],[6321,6321]]],[1562312626161,["GJX@GJXAIOU",[[1,6321,"import java.io.File;\nimport java.util.Scanner;"]],[6321,6321],[6367,6367]]],[1562312730850,["GJX@GJXAIOU",[[1,6880,"\n"]],[6878,6878],[6879,6879]]],[1562312731450,["GJX@GJXAIOU",[[1,6881,"\n"]],[6879,6879],[6880,6880]]],[1562312732193,["GJX@GJXAIOU",[[1,6880,"\t exists(); 判断指定的文件或者文件夹是否存在\n\t isFile(); 判断指定的File是文件吗？\n\t isDirectory(); 判断指定的File是文件夹吗？\n\t isHidden(); 判断指定的File是隐藏文件吗？\n\t isAbsolute();  判断创建File类对象使用的是绝对路径吗？\n\t \n\t 返回值全是boolean "]],[6880,6880],[7057,7057]]],[1562312738728,["GJX@GJXAIOU",[[-1,6880,"\t"],[-1,6909,"\t"],[-1,6936,"\t"],[-1,6969,"\t"],[-1,7000,"\t"],[-1,7039,"\t"],[-1,7042,"\t"]],[6881,7057],[6880,7050]]],[1562312743433,["GJX@GJXAIOU",[[1,6881,"* "],[1,6909,"* "],[1,6935,"* "],[1,6966," *"],[1,6996," *"]],[6880,7033],[6882,7043]]],[1562312746416,["GJX@GJXAIOU",[[-1,7044," "]],[7045,7045],[7044,7044]]],[1562312748019,["GJX@GJXAIOU",[[-1,7044,"\n"]],[7044,7044],[7043,7043]]],[1562312749939,["GJX@GJXAIOU",[[1,7059," \n"]],[7058,7058],[7060,7060]]],[1562312750665,["GJX@GJXAIOU",[[-1,7059," "],[1,7060,"\n"]],[7060,7060],[7060,7060]]],[1562312752820,["GJX@GJXAIOU",[[1,7060,"daima"]],[7060,7060],[7065,7065]]],[1562312753664,["GJX@GJXAIOU",[[-1,7060,"daima"]],[7065,7065],[7060,7060]]],[1562312756796,["GJX@GJXAIOU",[[1,7060,"代码示例："]],[7060,7060],[7065,7065]]],[1562312757057,["GJX@GJXAIOU",[[1,7067,"\n"]],[7065,7065],[7066,7066]]],[1562312759395,["GJX@GJXAIOU",[[1,7066,"```ja"]],[7066,7066],[7071,7071]]],[1562312759728,["GJX@GJXAIOU",[[1,7071,"va"]],[7071,7071],[7073,7073]]],[1562312759881,["GJX@GJXAIOU",[[1,7075,"\n"]],[7073,7073],[7074,7074]]],[1562312760776,["GJX@GJXAIOU",[[1,7076,"\n"]],[7074,7074],[7075,7075]]],[1562312761340,["GJX@GJXAIOU",[[1,7075,"```"]],[7075,7075],[7078,7078]]],[1562312769040,["GJX@GJXAIOU",[[1,7075,"\n"]],[7074,7074],[7075,7075]]],[1562312769472,["GJX@GJXAIOU",[[1,7075,"public class Demo4 {\n\tpublic static void main(String[] args) {\n\t\tFile file = new File(\"C:/aaa/1.txt\");\n\t\t\n\t\tSystem.out.println(\"这个文件或者文件夹存在吗?\" + file.exists());\n\t\tSystem.out.println(\"这个File类对象是一个文件类对象吗?\" + file.isFile());\n\t\t//这里使用了匿名对象，我一般称之为 一点到底！！！\n\t\tSystem.out.println(\"这个File类对象是一个文件夹类对象吗?\" + new File(\"C:/aaa\").isDirectory());\n\t\tSystem.out.println(\"这个File类对象是一个隐藏文件对象吗?\" + file.isHidden());\n\t\tSystem.out.println(\"创建File类对象使用了绝对路径吗?\" + file.isAbsolute());\n\t\tSystem.out.println(\"创建File类对象使用了绝对路径吗?\" + new File(\".\").isAbsolute());\n\t\t\n\t\n\t}\n}"]],[7075,7075],[7617,7617]]],[1562312776428,["GJX@GJXAIOU",[[1,7074,"import java.io.File;"]],[7074,7074],[7094,7094]]],[1562324440183,["GJX@GJXAIOU",[[-1,7627,"\n"]],[7628,7628],[7627,7627]]],[1562324445381,["GJX@GJXAIOU",[[1,7627," //点"]],[7627,7627],[7631,7631]]],[1562324445753,["GJX@GJXAIOU",[[-1,7630,"点"]],[7631,7631],[7630,7630]]],[1562324448272,["GJX@GJXAIOU",[[1,7630,". b"]],[7630,7630],[7633,7633]]],[1562324448678,["GJX@GJXAIOU",[[-1,7632,"b"]],[7633,7633],[7632,7632]]],[1562324453228,["GJX@GJXAIOU",[[1,7632,"表示当前目录"]],[7632,7632],[7638,7638]]],[1562324457739,["GJX@GJXAIOU",[[1,7653,"\n"]],[7651,7651],[7652,7652]]],[1562324457865,["GJX@GJXAIOU",[[1,7654,"\n"]],[7652,7652],[7653,7653]]],[1562324935411,["GJX@GJXAIOU",[[1,7655,"\n"]],[7652,7652],[7653,7653]]],[1562324936051,["GJX@GJXAIOU",[[1,7653,"String[] split(String str);\n \t123.3213.321.321.3\n  \t以下方法和文件是否【存在无关】！！！！！！\n  \tgetName(); 获取路径中的文件名或者文件夹名\n  \tgetPath(); 获取File类对象里面保存的路径\n  \tgetAbsolutePath(); 获取File对象里面保存路径对应的绝对路径\n  \tgetParent(); 获取当前文件或者文件夹的父目录，如果没有返回null\n  \t\n  \tlashModified(); 文件最后的修改时间\n  \t\t\tUNIX时间戳\n  \t\t\t计算机元年到修改时间的秒数：\n  \t\t\t1970年01月01日 00:00:00\n  \t\t\t2017年12月08日 15:24:50\n  \t\n  \tlength(); 文件的大小(字节数)，如果文件不存在，或者是一个文件夹，返回0L\n */"]],[7653,7653],[8046,8046]]],[1562324940099,["GJX@GJXAIOU",[[-1,8043," */"]],[8043,8046],[8043,8043]]],[1562324944071,["GJX@GJXAIOU",[[-1,7881,"\t"]],[7882,7882],[7881,7881]]],[1562324948240,["GJX@GJXAIOU",[[-1,7907,"  "],[-1,7920,"  "],[-1,7940,"  "],[-1,7966,"  "],[-1,7992,"  "]],[7912,7995],[7910,7985]]],[1562324949913,["GJX@GJXAIOU",[[-1,7909,"\t"],[-1,7918,"\t"],[-1,7936,"\t"],[-1,7962,"\t"],[-1,7984,"\t"]],[7910,7985],[7909,7980]]],[1562324953927,["GJX@GJXAIOU",[[-1,7983,"\t"]],[7984,7984],[7983,7983]]],[1562324958218,["GJX@GJXAIOU",[[1,7881,"- "]],[7881,7881],[7883,7883]]],[1562324961777,["GJX@GJXAIOU",[[1,7985,"- "]],[7985,7985],[7987,7987]]],[1562324966469,["GJX@GJXAIOU",[[1,7730,"- "]],[7730,7730],[7732,7732]]],[1562324968370,["GJX@GJXAIOU",[[1,7762,"- "]],[7762,7762],[7764,7764]]],[1562324970415,["GJX@GJXAIOU",[[1,7795,"- "]],[7795,7795],[7797,7797]]],[1562324972436,["GJX@GJXAIOU",[[1,7841,"- "]],[7841,7841],[7843,7843]]],[1562324975728,["GJX@GJXAIOU",[[1,7730,"\n  \t"]],[7726,7726],[7730,7730]]],[1562324980441,["GJX@GJXAIOU",[[-1,7731,"  "],[-1,7763,"  "],[-1,7796,"  "],[-1,7842,"  "]],[7731,7886],[7731,7878]]],[1562324981135,["GJX@GJXAIOU",[[-1,7731,"\t"],[-1,7761,"\t"],[-1,7792,"\t"],[-1,7836,"\t"]],[7731,7878],[7731,7874]]],[1562324987473,["GJX@GJXAIOU",[[-1,7879,"  "],[-1,7910,"\t"],[-1,7919,"\t"],[-1,7937,"\t"],[-1,7959,"\t"],[-1,7983,"  "]],[7880,8029],[7879,8021]]],[1562325004630,["GJX@GJXAIOU",[[1,8023,"代码示例："]],[8023,8023],[8028,8028]]],[1562325004967,["GJX@GJXAIOU",[[1,8030,"\n"]],[8028,8028],[8029,8029]]],[1562325007590,["GJX@GJXAIOU",[[1,8029,"```java"]],[8029,8029],[8036,8036]]],[1562325007728,["GJX@GJXAIOU",[[1,8038,"\n"]],[8036,8036],[8037,8037]]],[1562325008360,["GJX@GJXAIOU",[[1,8039,"\n"]],[8037,8037],[8038,8038]]],[1562325009065,["GJX@GJXAIOU",[[1,8038,"```"]],[8038,8038],[8041,8041]]],[1562325021320,["GJX@GJXAIOU",[[1,8037,"public class Demo5 {\n\tpublic static void main(String[] args) {\n\t\tFile file = new File(\"E:/aaa/1.txt\");\n\t\n\t\tSystem.out.println(file.getName()); //1.txt\n\t\tSystem.out.println(file.getPath()); //E:/aaa/1.txt\n\t\tSystem.out.println(file.getAbsolutePath()); //E:/aaa/1.txt\n\t\tSystem.out.println(file.getParent()); //E:/aaa\n\t\t\n\t\tlong last = new File(\"C:/aaa/1.txt\").lastModified();\n\t\t\n\t\tDate date = new Date(last);\n\t\tSimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\tSystem.out.println(format.format(date));\n\t\t\n\t\t//System.out.println(last); //直接使用这个会得到秒数\n\t}\n}\n"]],[8037,8037],[8610,8610]]],[1562325079671,["GJX@GJXAIOU",[[1,8616,"\n"]],[8614,8614],[8615,8615]]],[1562325079825,["GJX@GJXAIOU",[[1,8617,"\n"]],[8615,8615],[8616,8616]]],[1562325095112,["GJX@GJXAIOU",[[1,8037,"\n"]],[8036,8036],[8037,8037]]],[1562325096753,["GJX@GJXAIOU",[[1,8037,"import java.io.File;\nimport java.sql.Date;\nimport java.text.SimpleDateFormat;"]],[8037,8037],[8114,8114]]],[1562325103503,["GJX@GJXAIOU",[[1,8696,"\n"]],[8692,8692],[8693,8693]]],[1562325103663,["GJX@GJXAIOU",[[1,8697,"\n"]],[8693,8693],[8694,8694]]],[1562325133150,["GJX@GJXAIOU",[[1,8698,"\n"]],[8692,8692],[8693,8693]]],[1562325133822,["GJX@GJXAIOU",[[1,8699,"\n"]],[8693,8693],[8694,8694]]],[1562325137504,["GJX@GJXAIOU",[[-1,8688,"\n"]],[8688,8688],[8687,8687]]],[1562325164426,["GJX@GJXAIOU",[[1,8699,"\n"]],[8692,8692],[8693,8693]]],[1562325238393,["GJX@GJXAIOU",[[1,8693,"static File[]  listRoots(); \n \t获取当前计算机中所有的盘符，针对Windows操作系统\n \tLinux/UNIX没有区分盘符的概念 只有一个根目录 / \n \t\n String[] list();\n \t获取指定【文件夹】里面所有子文件和子文件，返回一个String类型的的数组\n \t\n File[] listFiles();\n \t获取指定【文件夹】里面所有子文件和子文件，返回一个File类型的的数组\n \t\n \t遍历一个文件夹：\n \t\t文件夹:\n \t\t\t文件夹1;\n \t\t\t文件夹2;\n \t\t\t文件夹3;\n \t\t\t………………\n \t\t文件:\n\t\t\t文件1;\n\t\t\t文件2;\n\t\t\t文件3;\n\t\t\t………………"]],[8693,8693],[9011,9011]]],[1562325241759,["GJX@GJXAIOU",[[-1,8692,"\n"]],[8693,8693],[8692,8692]]],[1562325242778,["GJX@GJXAIOU",[[1,8692,"- "]],[8692,8692],[8694,8694]]],[1562325245008,["GJX@GJXAIOU",[[1,8692,"\n"]],[8691,8691],[8692,8692]]],[1562325251138,["GJX@GJXAIOU",[[-1,8790," "],[1,8791,"-"]],[8790,8791],[8791,8791]]],[1562325251331,["GJX@GJXAIOU",[[1,8791," "]],[8791,8791],[8792,8792]]],[1562325253771,["GJX@GJXAIOU",[[1,8710,"     "]],[8709,8709],[8714,8714]]],[1562325256133,["GJX@GJXAIOU",[[1,8806,"       "]],[8806,8806],[8813,8813]]],[1562325258137,["GJX@GJXAIOU",[[1,8872,"   "]],[8871,8871],[8874,8874]]],[1562325265727,["GJX@GJXAIOU",[[-1,8929," \t"],[-1,8940," \t\t"],[-1,8948," \t\t\t"],[-1,8958," \t\t\t"],[-1,8968," \t\t\t"],[-1,8978," \t\t\t"],[-1,8989," \t\t"],[-1,8996,"\t"],[-1,9006,"\t"],[-1,9012,"\t"],[-1,9020,"\t"]],[8931,9031],[8929,9027]]],[1562325270185,["GJX@GJXAIOU",[[1,8938," "]],[8938,8938],[8939,8939]]],[1562325272197,["GJX@GJXAIOU",[[1,8944,"  "]],[8944,8944],[8946,8946]]],[1562325273234,["GJX@GJXAIOU",[[1,8952,"  "]],[8952,8952],[8954,8954]]],[1562325275130,["GJX@GJXAIOU",[[-1,8945," "]],[8945,8945],[8944,8944]]],[1562325277473,["GJX@GJXAIOU",[[-1,8952," "]],[8953,8953],[8952,8952]]],[1562325278729,["GJX@GJXAIOU",[[1,8958," "]],[8958,8958],[8959,8959]]],[1562325286362,["GJX@GJXAIOU",[[-1,8864," "],[1,8865,"-"]],[8864,8865],[8865,8865]]],[1562325286666,["GJX@GJXAIOU",[[1,8865," "]],[8865,8865],[8866,8866]]],[1562325292029,["GJX@GJXAIOU",[[1,8692,"qita"]],[8692,8692],[8696,8696]]],[1562325292757,["GJX@GJXAIOU",[[-1,8692,"qita"]],[8696,8696],[8692,8692]]],[1562325305962,["GJX@GJXAIOU",[[1,8692,"其他方法：返回值  方法  含义"]],[8692,8692],[8708,8708]]],[1562325323774,["GJX@GJXAIOU",[[1,9029,"\n"]],[9023,9023],[9024,9024]]],[1562325327185,["GJX@GJXAIOU",[[1,9024,"代码示例："]],[9024,9024],[9029,9029]]],[1562325327504,["GJX@GJXAIOU",[[1,9035,"\n"]],[9029,9029],[9030,9030]]],[1562325328953,["GJX@GJXAIOU",[[1,9030,"```"]],[9030,9030],[9033,9033]]],[1562325331012,["GJX@GJXAIOU",[[1,9033,"java"]],[9033,9033],[9037,9037]]],[1562325331136,["GJX@GJXAIOU",[[1,9043,"\n"]],[9037,9037],[9038,9038]]],[1562325332721,["GJX@GJXAIOU",[[1,9038,"```"]],[9038,9038],[9041,9041]]],[1562325335568,["GJX@GJXAIOU",[[1,9038,"\n"]],[9037,9037],[9038,9038]]],[1562325374134,["GJX@GJXAIOU",[[1,9039,"\n"]],[9038,9038],[9039,9039]]],[1562325374536,["GJX@GJXAIOU",[[1,9039,"public class Demo6 {\n\tpublic static void main(String[] args) {\n\t\tFile[] roots = File.listRoots();\n\t\tfor (File file : roots) {\n\t\t\tSystem.out.println(file.getPath());\n\t\t}\n\t\tSystem.out.println(\"---------------------------------\");\n\t\t\n\t\tFile file = new File(\"C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\");\n\t\tString[] allFilePath = file.list();\n\t\t\n\t\tfor (String string : allFilePath) {\n\t\t\tSystem.out.println(string);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"---------------------------------\");\n\t\t\n\t\tFile[] allFileObject = file.listFiles();\n\t\tfor (File file2 : allFileObject) {\n\t\t\tSystem.out.println(file2);\n\t\t}\n\t\t\n\t}\n}"]],[9039,9039],[9635,9635]]],[1562325383197,["GJX@GJXAIOU",[[1,9038,"import java.io.File;"]],[9038,9038],[9058,9058]]],[1562325444847,["GJX@GJXAIOU",[[1,8962,"      "]],[8962,8962],[8968,8968]]],[1562325446115,["GJX@GJXAIOU",[[1,8975,"      "]],[8975,8975],[8981,8981]]],[1562325448391,["GJX@GJXAIOU",[[1,8988,"       "]],[8987,8988],[8995,8995]]],[1562325449678,["GJX@GJXAIOU",[[-1,8994," "]],[8995,8995],[8994,8994]]],[1562325453904,["GJX@GJXAIOU",[[1,8946,"- "]],[8946,8946],[8948,8948]]],[1562325757106,["GJX@GJXAIOU",[[1,9685,"\n"]],[9681,9681],[9682,9682]]],[1562325758699,["GJX@GJXAIOU",[[1,9682,"·"]],[9682,9682],[9683,9683]]],[1562325759289,["GJX@GJXAIOU",[[-1,9682,"·"]],[9683,9683],[9682,9682]]],[1562325762067,["GJX@GJXAIOU",[[1,9682,"```java"]],[9682,9682],[9689,9689]]],[1562325762231,["GJX@GJXAIOU",[[1,9693,"\n"]],[9689,9689],[9690,9690]]],[1562325762383,["GJX@GJXAIOU",[[1,9694,"\n"]],[9690,9690],[9691,9691]]],[1562325763508,["GJX@GJXAIOU",[[1,9691,"```"]],[9691,9691],[9694,9694]]],[1562325764790,["GJX@GJXAIOU",[[1,9690,"public class Demo7 {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\t\n\t\tfindAllJavaFile(\"C:\\\\Users\\\\刘晓磊\\\\Desktop\\\\test\");\n\t\t\n\t\tFile srcDir = new File(\"C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\");\n\t\t\n\t\tif (srcDir.exists() && srcDir.isDirectory()) {\n\t\t\t\n\t\t\tFile[] allFiles = srcDir.listFiles();\n\t\t\t\n\t\t\tshowAllFiles(allFiles);\n\t\t\tshowAllDirectories(allFiles);\n\t\t} \n\t}\n\t\n\tprivate static void showAllFiles(File[] allFiles) {\n\t\tSystem.out.println(\"普通文件:\");\n\t\tfor (File file : allFiles) {\n\t\t\tif (file.isFile()) {\n\t\t\t\tSystem.out.println(\"\\t\" + file.getName());\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static void showAllDirectories(File[] allFiles) {\n\t\tSystem.out.println(\"文件夹:\");\n\t\tfor (File file : allFiles) {\n\t\t\tif (file.isDirectory()) {\n\t\t\t\tSystem.out.println(\"\\t\" + file.getName());\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void findAllJavaFile(String pathname) throws FileNotFoundException {\n\t\t//如果给定的路径是一个null，无法使用\n\t\tif (null == pathname) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\t\t\n\t\tFile srcDir = new File(pathname);\n\t\t\n\t\t//判断文件是否存在，是否是一个文件夹\n\t\tif (!srcDir.exists()) { //srcDir.exists() == false\n\t\t\tthrow new FileNotFoundException();\n\t\t} else if (!srcDir.isDirectory()) { //srcDir.isDirectory() == false\n\t\t\t//运行时异常，不用再函数中声明\n\t\t\tthrow new RuntimeException(\"该文件不是一个文件夹\");\n\t\t}\n\t\t\t\n\t\tFile[] allFiles = srcDir.listFiles();\n\t\t\n\t\tfor (File file : allFiles) {\n\t\t\t//文件名后缀为.java 并且 是一个普通文件\n\t\t\tif (file.getName().endsWith(\".java\") && file.isFile()) {\n\t\t\t\tSystem.out.println(file.getName());\n\t\t\t}\n\t\t}\n\t\n\t} \n}\n\n"]],[9690,9690],[11181,11181]]],[1562325777615,["GJX@GJXAIOU",[[1,9682,"\n"]],[9680,9680],[9681,9681]]],[1562325778025,["GJX@GJXAIOU",[[1,9681," 遍历一个文件夹：\n \t\t文件夹:\n \t\t\t文件夹1;\n \t\t\t文件夹2;\n \t\t\t文件夹3;\n \t\t\t………………\n \t\t文件:\n\t\t\t文件1;\n\t\t\t文件2;\n\t\t\t文件3;\n\t\t\t………………\n1. 首先利用listFiles()方法，获取指定文件夹下的所有子文件和子文件夹的File类对象数组\n2. 利用isFile或者isDirectory判断是否是文件或者是文件夹\n3. 区别对象，利用不同的函数 \n\n找出指定文件夹下的所有.java文件?\nendWith() 和 isFile()"]],[9681,9681],[9928,9928]]],[1562325780461,["GJX@GJXAIOU",[[1,9681,"-"]],[9681,9681],[9682,9682]]],[1562325780674,["GJX@GJXAIOU",[[1,9683," "]],[9682,9682],[9683,9683]]],[1562325787054,["GJX@GJXAIOU",[[-1,9909,"\n"]],[9910,9910],[9909,9909]]],[1562325788308,["GJX@GJXAIOU",[[1,9909,"   "]],[9909,9909],[9912,9912]]],[1562326073133,["GJX@GJXAIOU",[[1,11438,"ci"]],[11438,11438],[11440,11440]]],[1562326074500,["GJX@GJXAIOU",[[-1,11438,"ci"]],[11440,11440],[11438,11438]]],[1562328100241,["GJX@GJXAIOU",[[1,11441,"\n"]],[11437,11437],[11438,11438]]],[1562328100522,["GJX@GJXAIOU",[[1,11442,"\n"]],[11438,11438],[11439,11439]]],[1562328100735,["GJX@GJXAIOU",[[1,11443,"\n"]],[11439,11439],[11440,11440]]],[1562328124583,["GJX@GJXAIOU",[[1,11439,"- guida"]],[11439,11439],[11446,11446]]],[1562328126309,["GJX@GJXAIOU",[[-1,11441,"guida"]],[11446,11446],[11441,11441]]],[1562328130042,["GJX@GJXAIOU",[[1,11441,"归档文件"]],[11441,11441],[11445,11445]]],[1562328267042,["GJX@GJXAIOU",[[1,11447,"如果是普通文件，按照文件的"]],[11447,11447],[11460,11460]]],[1562328294918,["GJX@GJXAIOU",[[1,11460,"后缀名创建对应的全大写文件夹，把文件剪切进去"]],[11460,11460],[11482,11482]]],[1562328298078,["GJX@GJXAIOU",[[1,11485,"\n"]],[11482,11482],[11483,11483]]],[1562328307066,["GJX@GJXAIOU",[[1,11483,"如果是文件夹，创建s"]],[11483,11483],[11493,11493]]],[1562328307108,["GJX@GJXAIOU",[[1,11492," "]],[11493,11493],[11494,11494]]],[1562328314107,["GJX@GJXAIOU",[[1,11494,"ubDir文件夹"]],[11494,11494],[11502,11502]]],[1562328314150,["GJX@GJXAIOU",[[1,11499," "]],[11502,11502],[11503,11503]]],[1562328322347,["GJX@GJXAIOU",[[1,11503,"，剪切进去；"]],[11503,11503],[11509,11509]]],[1562328358717,["GJX@GJXAIOU",[[1,11512,"\n"]],[11509,11509],[11510,11510]]],[1562328360521,["GJX@GJXAIOU",[[1,11513,"\n"]],[11510,11510],[11511,11511]]],[1562328360655,["GJX@GJXAIOU",[[1,11514,"\n"]],[11511,11511],[11512,11512]]],[1562328367136,["GJX@GJXAIOU",[[1,11512,"特殊情况："]],[11512,11512],[11517,11517]]],[1562328367838,["GJX@GJXAIOU",[[-1,11516,"："]],[11517,11517],[11516,11516]]],[1562328389570,["GJX@GJXAIOU",[[1,11516,"，如果是没有文件后缀名的未知普通文件，就"]],[11516,11516],[11536,11536]]],[1562328393447,["GJX@GJXAIOU",[[1,11536,"放入到o"]],[11536,11536],[11540,11540]]],[1562328393489,["GJX@GJXAIOU",[[1,11539," "]],[11540,11540],[11541,11541]]],[1562328396428,["GJX@GJXAIOU",[[1,11541,"thers文件"]],[11541,11541],[11548,11548]]],[1562328396470,["GJX@GJXAIOU",[[1,11546," "]],[11548,11548],[11549,11549]]],[1562328399617,["GJX@GJXAIOU",[[1,11549,"夹；"]],[11549,11549],[11551,11551]]],[1562328400616,["GJX@GJXAIOU",[[1,11554,"\n"]],[11551,11551],[11552,11552]]],[1562328400800,["GJX@GJXAIOU",[[1,11555,"\n"]],[11552,11552],[11553,11553]]],[1562328405656,["GJX@GJXAIOU",[[1,11553,"思路："]],[11553,11553],[11556,11556]]],[1562328406637,["GJX@GJXAIOU",[[1,11559,"\n"]],[11556,11556],[11557,11557]]],[1562328419490,["GJX@GJXAIOU",[[1,11553,"  - "]],[11553,11553],[11557,11557]]],[1562328431315,["GJX@GJXAIOU",[[1,11561,"    -  1.获取芝士年糕"]],[11561,11561],[11576,11576]]],[1562328433767,["GJX@GJXAIOU",[[-1,11572,"芝士年糕"]],[11576,11576],[11572,11572]]],[1562328444993,["GJX@GJXAIOU",[[1,11572,"指定的文件夹路径，进行判断；"]],[11572,11572],[11586,11586]]],[1562328445374,["GJX@GJXAIOU",[[1,11587,"    - \n"]],[11586,11586],[11593,11593]]],[1562328449531,["GJX@GJXAIOU",[[1,11593,"2.获取"]],[11593,11593],[11597,11597]]],[1562328466818,["GJX@GJXAIOU",[[1,11597,"这个文件夹下面的所有子文件和子文件夹的F"]],[11597,11597],[11617,11617]]],[1562328466860,["GJX@GJXAIOU",[[1,11616," "]],[11617,11617],[11618,11618]]],[1562328467548,["GJX@GJXAIOU",[[1,11618,"ilew"]],[11618,11618],[11622,11622]]],[1562328468310,["GJX@GJXAIOU",[[-1,11621,"w"]],[11622,11622],[11621,11621]]],[1562328472901,["GJX@GJXAIOU",[[1,11621,"[]类对象；"]],[11621,11621],[11627,11627]]],[1562328473178,["GJX@GJXAIOU",[[1,11628,"    - \n"]],[11627,11627],[11634,11634]]],[1562328480091,["GJX@GJXAIOU",[[1,11634,"遍历这个File"]],[11634,11634],[11642,11642]]],[1562328480134,["GJX@GJXAIOU",[[1,11638," "]],[11642,11642],[11643,11643]]],[1562328482963,["GJX@GJXAIOU",[[1,11643,"【"]],[11643,11643],[11644,11644]]],[1562328483505,["GJX@GJXAIOU",[[-1,11643,"【"]],[11644,11644],[11643,11643]]],[1562328509202,["GJX@GJXAIOU",[[1,11643,"[] 类型的数组，按照文件和文件夹进行区别操作；"]],[11643,11643],[11667,11667]]],[1562328526278,["GJX@GJXAIOU",[[1,11668,"    - \n"]],[11667,11667],[11674,11674]]],[1562328528047,["GJX@GJXAIOU",[[1,11672,"  "]],[11674,11674],[11676,11676]]],[1562328530694,["GJX@GJXAIOU",[[1,11634,"3 "]],[11634,11634],[11635,11635]]],[1562328531178,["GJX@GJXAIOU",[[1,11635,"."]],[11635,11635],[11636,11636]]],[1562328536996,["GJX@GJXAIOU",[[-1,11567," "]],[11568,11568],[11567,11567]]],[1562328541054,["GJX@GJXAIOU",[[-1,11676,"-"]],[11677,11677],[11676,11676]]],[1562328548028,["GJX@GJXAIOU",[[-1,11635," "]],[11636,11636],[11635,11635]]],[1562328564772,["GJX@GJXAIOU",[[1,11676,"  - 3.1.如果是文件："]],[11676,11676],[11690,11690]]],[1562328565551,["GJX@GJXAIOU",[[1,11691,"         - \n"]],[11690,11690],[11702,11702]]],[1562328566726,["GJX@GJXAIOU",[[1,11700,"  "]],[11702,11702],[11704,11704]]],[1562328582835,["GJX@GJXAIOU",[[1,11704,"首先获取这个文件的文件后缀；"]],[11704,11704],[11718,11718]]],[1562328583183,["GJX@GJXAIOU",[[1,11719,"           - \n"]],[11718,11718],[11732,11732]]],[1562328604066,["GJX@GJXAIOU",[[1,11732,"然后创建以这个文件后缀名全大写的文件夹；"]],[11732,11732],[11752,11752]]],[1562328604405,["GJX@GJXAIOU",[[1,11753,"           - \n"]],[11752,11752],[11766,11766]]],[1562328610090,["GJX@GJXAIOU",[[1,11766,"最后一栋"]],[11766,11766],[11770,11770]]],[1562328610790,["GJX@GJXAIOU",[[-1,11768,"一栋"]],[11770,11770],[11768,11768]]],[1562328612725,["GJX@GJXAIOU",[[1,11768,"一栋"]],[11768,11768],[11770,11770]]],[1562328613815,["GJX@GJXAIOU",[[-1,11767,"后一栋"]],[11770,11770],[11767,11767]]],[1562328620058,["GJX@GJXAIOU",[[1,11767,"后移动到"]],[11767,11767],[11771,11771]]],[1562328624404,["GJX@GJXAIOU",[[-1,11770,"到"]],[11771,11771],[11770,11770]]],[1562328628530,["GJX@GJXAIOU",[[1,11770,"该文件到这个"]],[11770,11770],[11776,11776]]],[1562328630808,["GJX@GJXAIOU",[[1,11776,"文件夹；"]],[11776,11776],[11780,11780]]],[1562328631276,["GJX@GJXAIOU",[[1,11781,"           - \n"]],[11780,11780],[11794,11794]]],[1562328656939,["GJX@GJXAIOU",[[1,11794,"注：如果一个文件没有后缀名，就放入到Others"]],[11794,11794],[11818,11818]]],[1562328656982,["GJX@GJXAIOU",[[1,11812," "]],[11818,11818],[11819,11819]]],[1562328659133,["GJX@GJXAIOU",[[1,11819,"目录"]],[11819,11819],[11821,11821]]],[1562328659175,["GJX@GJXAIOU",[[1,11819," "]],[11821,11821],[11822,11822]]],[1562328661098,["GJX@GJXAIOU",[[1,11822,"下；"]],[11822,11822],[11824,11824]]],[1562328661776,["GJX@GJXAIOU",[[1,11825,"           - \n"]],[11824,11824],[11838,11838]]],[1562328663766,["GJX@GJXAIOU",[[-1,11834,"  "]],[11838,11838],[11836,11836]]],[1562328670433,["GJX@GJXAIOU",[[1,11836,"3.2.ruguo "]],[11836,11836],[11846,11846]]],[1562328671741,["GJX@GJXAIOU",[[-1,11840,"ruguo "]],[11846,11846],[11840,11840]]],[1562328677555,["GJX@GJXAIOU",[[1,11840,"如果是文件夹："]],[11840,11840],[11847,11847]]],[1562328678024,["GJX@GJXAIOU",[[1,11848,"         - \n"]],[11847,11847],[11859,11859]]],[1562328679110,["GJX@GJXAIOU",[[1,11857,"  "]],[11859,11859],[11861,11861]]],[1562328682691,["GJX@GJXAIOU",[[1,11861,"手续"]],[11861,11861],[11863,11863]]],[1562328683380,["GJX@GJXAIOU",[[-1,11861,"手续"]],[11863,11863],[11861,11861]]],[1562328685339,["GJX@GJXAIOU",[[1,11861,"首先"]],[11861,11861],[11863,11863]]],[1562328693481,["GJX@GJXAIOU",[[1,11863,"创建s"]],[11863,11863],[11866,11866]]],[1562328693525,["GJX@GJXAIOU",[[1,11865," "]],[11866,11866],[11867,11867]]],[1562328700482,["GJX@GJXAIOU",[[1,11867,"ubDir目录"]],[11867,11867],[11874,11874]]],[1562328700524,["GJX@GJXAIOU",[[1,11872," "]],[11874,11874],[11875,11875]]],[1562328703041,["GJX@GJXAIOU",[[1,11875,"；"]],[11875,11875],[11876,11876]]],[1562328703494,["GJX@GJXAIOU",[[1,11877,"           - \n"]],[11876,11876],[11890,11890]]],[1562328716529,["GJX@GJXAIOU",[[1,11890,"移动该文件夹放入到s"]],[11890,11890],[11900,11900]]],[1562328716571,["GJX@GJXAIOU",[[1,11899," "]],[11900,11900],[11901,11901]]],[1562328721939,["GJX@GJXAIOU",[[1,11901,"ubDir里面"]],[11901,11901],[11908,11908]]],[1562328721981,["GJX@GJXAIOU",[[1,11906," "]],[11908,11908],[11909,11909]]],[1562328722203,["GJX@GJXAIOU",[[1,11909,"；"]],[11909,11909],[11910,11910]]]],null,"GJX@GJXAIOU"],["f8f5ade6-58cd-4d5e-b865-2611ddb2b41e",1562370744894,"## 泛型\n\n- 为了解决数据类型一致化问题,避免没有意义的强制类型转换(放进什么数据，拿出来什么数据)\n\n- 自定义泛型泛型使用的格式：\n<大写字母> 一般使用E 或者 T ，仅仅是占位符；\n\n- 泛型在函数中使用\n  - 格式：\n```java\n权限修饰符 <自定义泛型> 返回值类型(可以使用泛型) 函数名(形式参数列表“自定义泛型”) {\n  同样可以使用自定义泛型\n}\n```\n\n- 泛型在类中使用\n  -  格式：\n```java\nclass 类名<自定义泛型> {\n  非静态的成员变量或者成员方法都可以使用类中定义的<自定义泛型>\n  \n  静态方法不能使用类中自定义泛型，但是可以方法中自己定义泛型  \n}\n\n```\n\n例如：`Arrays.sort(T[] t, Comparator<? super T> c)`\n\n- 泛型在接口中使用\n格式：\n```java\ninterface 接口名<自定义泛型> {\n  //成员变量 缺省属性：public static final\n  //成员方法 缺省属性：abstract\n}\n```\n\n- 一个类遵从带有自定义泛型的接口有两种方式：\n  例如接口如下：\n      interface A<T> {\n          public void testA(T t);\n      }\n  \n1. 方式1：更加自由，在创建类对象时，才对泛型进行约束\n```java\nclass Test1<T> implements A<T> {\n  public void testA(T t) {\n      //实现方法\n  }\n}\n``` \n\n\n2. 方式2 :遵从接口时，接口直接确定了泛型的具体类型\n  \n```java\nclass Test2 implements A<String> {\n  public void testA(String t) {\n      //实现方法\n  }\n}\n```\n\n- 泛型的上下限：\n`<? super T>`  表示数据类型是T对象或者其父类对象\n`<? extends T>`表示数据类型是T对象或者其子类对象\n  \n## Map\n  `Map<K, V> ` 键值对\n  两个实现类：\n  ---| HashMap\n  ---| TreeMap\n  常见的方法：\n  \n```java\nput(K key , V value);\nputAll(Map<? extends k, ? extends V> map)\n\nclear();\nremove(Object k);\n\nsize();\ncontainsKey(Object key);\ncontainsValue(Object Value);\n\nkeySet();\nvalues();\n\nget(Object k);\n```\n \n\n## 简单介绍了一个匿名内部类\n```java\n new Comparator<Student>() {\n      @Override   \n      public int compare(Student o1, Student o2) {\n          return o1.getAge() - o2.getAge();\n      }\n  }\n```\n\n\n## Map 补充\n\n```java\n/**\n * \n */\npackage study;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\n\t\tmap.put(\"MacBook Pro\", 22888);\n\t\tmap.put(\"iPhoneX\", 8398);\n\t\tmap.put(\"iPad Pro\", 5198);\n\t\t\n\t\tSystem.out.println(map);\n\t\t\n\t\t//第一种遍历方式：借助于keySet，通过key值拿到value值\n\t\tSet<String> set = map.keySet();\n\t\t\n\t\t//使用Set集合的Iterator迭代器\n\t\tIterator<String> it = set.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tString key = it.next(); //获取每一个Map中的key值\n\t\t\tint value = map.get(key);\n\t\t\t\n\t\t\tSystem.out.println(key + \"=\" + value);\n\t\t}\n\t\t//以上方法，不太合适，实际上获取的key值，再借助于Map里面的get方法，获取对应的Value\n\t\t//实际上并没有获取到完整的键值对\n\t\t\n\t\t\n\t\t\n\t\t//第二种方式：借助于values\n\t\tCollection<Integer> c = map.values();\n\t\t\n\t\tfor (Integer integer : c) {\n\t\t\tSystem.out.println(integer);\n\t\t}\n\t\t\n\t\t//以上方法也不适合，因为只能拿到value值，获取不到对应的key\n\t\t\n\t\t\n\t\t\n\t\t//在Java中万物皆对象，因此可以将键值对看成是一个类【必须会】\n\t\t/*\n\t \t将键值对，认为是一个对象，组成一个类，称之为Entry\n\t\t class Entry<K, V> {\n\t\t \tK key;\n\t\t \tV value;\n\t\t } \n\t\t 这里可以认为在Map集合中，保存的每一个键值对都是一个Entry对象，\n\t\t 然后将这些Entry对象获取出来，做成一个集合，然后对该集合进行遍历；\n\t\t entrySet();\n\t\t Map.Entry；Entry为Map的子接口，称为内部类\n\t\t */\n\t\tSet<Entry<String, Integer>> entrySet = map.entrySet();\n\t\t\n\t\tIterator<Entry<String, Integer>> it2 = entrySet.iterator();\n\t\t\n\t\twhile (it2.hasNext()) {\n\t\t\tSystem.out.println(it2.next());\n\t\t}\n\t}\n}\n\n```\n\n\n# 文件操作\n\n IO:\nInput Output\nread  write\n\n只考虑文件操作情况下：\n -  读取操作是：input read 从硬盘(存储设备) 到 内存\n - 写入操作是：output write 从内存 到 硬盘(存储设备)\n\n如何操作文件或者文件夹：\n创建，删除，剪切，复制，重命名，粘贴\n\nJava里万物皆对象\n计算机世界里万物皆文件\n\n- Sun提供了一个File类，专门来操作【文件】和【文件夹】\n\n```java\n 如何创建一个File类对象：\nFile(String pathName);\n根据文件路径创建File类对象，可以是【绝对路径】可以是【相对路径】\n\nFile(String parent, String child);\n根据提供的父目录【文件夹】地址，和当前文件夹下的【子文件】或者【子文件夹】创建File类对象\n\nFile(File parent, String child);\n根据创建好的父目录的File类对象，和这个目录下的【子文件】或者【子文件夹】创建File类对象\n```\n【pathName】\n\\n \\t \\\\ 转义字符\n假如实际地址为：C:\\aaa\\bbb 如果在代码中使用 \"C:\\\\aaa\\\\bbb\" LOW\n\n推荐使用 / 来区分路径,不使用反斜杠\nJava是一个跨平台的语言\nJava提供了一个系统变量\nFile.separator 可以根据不同的系统换，自动填充文件分隔符\n示例：\n```java\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tFile file1 = new File(\"C:\\\\aaa\"); //采用Windows的分隔符\n\t\tFile file2 = new File(\"C:/aaa\"); //用在Linux和Windows通用的分隔符\n\t\tFile file3 = new File(\"C:\" + File.separator + \"aaa\"); //这里使用Java系统变量\n\t\t\n\t\tSystem.out.println(file1);\n\t\tSystem.out.println(file2);\n\t\tSystem.out.println(file3);\n\t\t\n\t\tFile file4 = new File(\"C:\\\\aaa\", \"1.txt\"); //父目录 子目录\n\t\tSystem.out.println(file4);\n\t\t\n\t\tFile file5 = new File(file1, \"1.txt\");\n\t\tSystem.out.println(file5);\n\t}\n}\n```\n\nFile 操作常见方法：\n```java\nisFile();\nis文件夹英文();\ncreateFile()\nrenameTo\ncopy\n```\n\n\n## 可以利用File类对象，创建文件或者文件夹\n\t\n- boolean createNewFile(); 创建文件\n\t使用File类对象，创建File类对象里面保存的地址 指定 的 普通文件\n\t返回值boolean: 创建成功返回true，创建失败返回false\n\t返回false失败原因:\n\t\t1. 该文件已经存在\n\t\t2. 操作路径非法，例如：文件指定所在文件夹不存在\n\t\t3. 操作的文件夹没有写入权限\n\t\t4. 硬盘坏了\n【要求】\n\t创建文件，必须带有文件后缀名！！！\n\t.java .class .doc .txt .xml .html .css .js .md .jsp \n\t.m .h .c .cpp .php .net .ppt .xls .exe .zip .rar .mp4\n\t.rmvb\n\t\n\t\n- boolean mkdir(); make direcotry 创建文件夹\n\t使用File类对象里面保存的文件夹地址，创建对应的文件夹\n\t- 返回值：boolean 创建成功返回true 创建失败返回false\n\t- 失败原因：\n\t\t1. 已经存在该文件夹\n\t\t2. 指定创建文件夹的父目录没有写入权限\n\t\t3. 要创建文件夹的父目录不存在\n- boolean mkdirs();\n\t使用File类对象里面保存的文件夹路径地址，创建指定文件夹，如果该路径中的【中间文件夹】不存在,把中间路径，同时创建\n\t- 返回值：boolean 创建成功返回true 创建失败返回false\n\t- 失败原因:\n\t\t1. 已经存在该文件夹\n\t\t2. 指定创建文件夹没有写入权限\n\tC:/aaa/ccc/ddd/eee/fff/ggg/hhh/iii/jjj\n\t\n- boolean renameTo(File dest);\n\t- 功能1：\n\t\t重命名！！！文件 或者 文件夹\n\t- 功能2：\n\t\t剪切，移动到另一个位置\n\t\n\t作业：\n\t测试，renameTo操作一个非空文件夹！！！\n\n程序测试：\n```java\nimport java.io.File;\nimport java.io.IOException;\n\npublic class Demo2 {\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\t//创建文件\n\t\tFile file1 = new File(\"C:/aaa/1.txt\");\n\t\t\n\t\tboolean ret = file1.createNewFile();\n\t\tSystem.out.println(\"文件创建成功了吗?\" + ret);\n\t\t\n//\t\tFile file2 = new File(\"C:/bb/1.txt\");\n//\t\tSystem.out.println(file2.createNewFile());\n\t\t\n\t\tFile file2 = new File(\"C:/aaa/bbb\");\n\t\tret = file2.mkdir();\n\t\tSystem.out.println(\"文件夹创建成功了吗?\" + ret);\n\t\t\n\t\tFile file3 = new File(\"C:/aaa/ccc/ddd\");\n\t\tret = file3.mkdir();\n\t\tSystem.out.println(\"文件夹创建成功了吗?\" + ret);\n\t\t\n\t\tFile file4 = new File(\"C:/aaa/ccc/ddd/eee/fff/ggg/hhh/iii/jjj\");\n\t\tret = file4.mkdirs();\n\t\tSystem.out.println(\"文件夹创建成功了吗?\" + ret);\n\t\t\n\t\t\n\t\tFile dest1 = new File(\"C:/aaa/2.txt\");\n\t\t//把C:/aaa/1.txt 重命名！！！\n\t\tret = file1.renameTo(dest1);\n\t\tSystem.out.println(\"重命名成功了吗?\" + ret);\n\t\t\n\t\tret = file2.renameTo(new File(\"C:/aaa/ddd\"));\n\t\tSystem.out.println(\"重命名文件夹成功了吗?\" + ret);\n\t\t\n\t\t//测试剪切功能\n\t\t//原地址要带有文件或者文件夹名，而且目标地址也有带有文件或者文件夹名\n\t\tFile txt3 = new File(\"C:/aaa/3.txt\");\n\t\tFile dest2 = new File(\"C:\\\\Users\\\\刘晓磊\\\\Desktop\\\\3.txt\");\n\t\t\n\t\tret = txt3.renameTo(dest2);\n\t\tSystem.out.println(\"剪切成功了吗?\" + ret);\n\t\t\n\t}\n}\n```\n\n- delete()\n \t\t删除文件或者文件夹，但是如果操作文件夹的话，只能删除空文件夹,成功返回true ，失败返回false \t\t\n \t\t该删除操作不是把文件或者文件夹放入到回收站里，而是直接从磁盘上抹去数据,该操作不可逆\n \t\n - deleteOnExit()\n \t\t当JVM虚拟机运行终止之后，删除指定的文件或者文件夹，而不是调用立即删除\t\n \t- 用途：\n \t\t\t用于删除程序运行结束之后残留的缓存文件或者运行日志文件，节约硬盘空间\n\n代码示例：\n```java\nimport java.io.File;\nimport java.util.Scanner;\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n\t\tFile file1 = new File(\"C:/aaa/1.txt\");\n\t\t\n\t\tSystem.out.println(\"删除成功了吗?\" + file1.delete());\n\t\t\n\t\tFile file2 = new File(\"C:/aaa/ddd\");\n\t\tSystem.out.println(\"删除成功了吗?\" + file2.delete());\n\t\t\n\t\tFile file3 = new File(\"C:/aaa/ccc\");\n\t\tSystem.out.println(\"删除成功了吗?\" + file3.delete()); //返回false\n\t\t\n\t\t// deleteOnExit()使用方法\n\t\tFile file4 = new File(\"C:/aaa/2.txt\");\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfile4.deleteOnExit();\n\t\tsc.nextLine();\n\t}\n}\n```\n\n * exists(); 判断指定的文件或者文件夹是否存在\n * isFile(); 判断指定的File是文件吗？\n * isDirectory(); 判断指定的File是文件夹吗？\n * isHidden(); 判断指定的File是隐藏文件吗？\n * isAbsolute();  判断创建File类对象使用的是绝对路径吗？\n 返回值全是boolean \n\n代码示例：\n```java\nimport java.io.File;\npublic class Demo4 {\n\tpublic static void main(String[] args) {\n\t\tFile file = new File(\"C:/aaa/1.txt\");\n\t\t\n\t\tSystem.out.println(\"这个文件或者文件夹存在吗?\" + file.exists());\n\t\tSystem.out.println(\"这个File类对象是一个文件类对象吗?\" + file.isFile());\n\t\t//这里使用了匿名对象，我一般称之为 一点到底！！！\n\t\tSystem.out.println(\"这个File类对象是一个文件夹类对象吗?\" + new File(\"C:/aaa\").isDirectory());\n\t\tSystem.out.println(\"这个File类对象是一个隐藏文件对象吗?\" + file.isHidden());\n\t\tSystem.out.println(\"创建File类对象使用了绝对路径吗?\" + file.isAbsolute());\n\t\tSystem.out.println(\"创建File类对象使用了绝对路径吗?\" + new File(\".\").isAbsolute()); //. 表示当前目录\t\t\n\t\n\t}\n}\n```\n\nString[] split(String str);\n \t123.3213.321.321.3\n  \t以下方法和文件是否【存在无关】！！！！！！\n  \t\n- getName(); 获取路径中的文件名或者文件夹名\n- getPath(); 获取File类对象里面保存的路径\n- getAbsolutePath(); 获取File对象里面保存路径对应的绝对路径\n- getParent(); 获取当前文件或者文件夹的父目录，如果没有返回null\n  \t\n- lashModified(); 文件最后的修改时间\n\tUNIX时间戳\n\t计算机元年到修改时间的秒数：\n\t1970年01月01日 00:00:00\n\t2017年12月08日 15:24:50\n\n- length(); 文件的大小(字节数)，如果文件不存在，或者是一个文件夹，返回0L\n\n代码示例：\n```java\nimport java.io.File;\nimport java.sql.Date;\nimport java.text.SimpleDateFormat;\npublic class Demo5 {\n\tpublic static void main(String[] args) {\n\t\tFile file = new File(\"E:/aaa/1.txt\");\n\t\n\t\tSystem.out.println(file.getName()); //1.txt\n\t\tSystem.out.println(file.getPath()); //E:/aaa/1.txt\n\t\tSystem.out.println(file.getAbsolutePath()); //E:/aaa/1.txt\n\t\tSystem.out.println(file.getParent()); //E:/aaa\n\t\t\n\t\tlong last = new File(\"C:/aaa/1.txt\").lastModified();\n\t\t\n\t\tDate date = new Date(last);\n\t\tSimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\tSystem.out.println(format.format(date));\n\t\t\n\t\t//System.out.println(last); //直接使用这个会得到秒数\n\t}\n}\n```\n其他方法：返回值  方法  含义\n- static File[]       listRoots(); \n \t获取当前计算机中所有的盘符，针对Windows操作系统\n \tLinux/UNIX没有区分盘符的概念 只有一个根目录 / \n \t\n- String[]        list();\n \t获取指定【文件夹】里面所有子文件和子文件，返回一个String类型的的数组\n \t\n- File[]    listFiles();\n \t获取指定【文件夹】里面所有子文件和子文件，返回一个File类型的的数组\n \t\n- 遍历一个文件夹：\n 文件夹:\n       文件夹1;\n       文件夹2;\n       文件夹3;\n………………\n文件:\n\t\t文件1;\n\t\t文件2;\n\t\t文件3;\n\t\t………………\n\n代码示例：\n```java\nimport java.io.File;\npublic class Demo6 {\n\tpublic static void main(String[] args) {\n\t\tFile[] roots = File.listRoots();\n\t\tfor (File file : roots) {\n\t\t\tSystem.out.println(file.getPath());\n\t\t}\n\t\tSystem.out.println(\"---------------------------------\");\n\t\t\n\t\tFile file = new File(\"C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\");\n\t\tString[] allFilePath = file.list();\n\t\t\n\t\tfor (String string : allFilePath) {\n\t\t\tSystem.out.println(string);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"---------------------------------\");\n\t\t\n\t\tFile[] allFileObject = file.listFiles();\n\t\tfor (File file2 : allFileObject) {\n\t\t\tSystem.out.println(file2);\n\t\t}\n\t\t\n\t}\n}\n```\n\n-  遍历一个文件夹：\n \t\t文件夹:\n \t\t\t文件夹1;\n \t\t\t文件夹2;\n \t\t\t文件夹3;\n \t\t\t………………\n \t\t文件:\n\t\t\t文件1;\n\t\t\t文件2;\n\t\t\t文件3;\n\t\t\t………………\n1. 首先利用listFiles()方法，获取指定文件夹下的所有子文件和子文件夹的File类对象数组\n2. 利用isFile或者isDirectory判断是否是文件或者是文件夹\n3. 区别对象，利用不同的函数 \n\n找出指定文件夹下的所有.java文件?   endWith() 和 isFile()\n\n```java\npublic class Demo7 {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\t\n\t\tfindAllJavaFile(\"C:\\\\Users\\\\刘晓磊\\\\Desktop\\\\test\");\n\t\t\n\t\tFile srcDir = new File(\"C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\");\n\t\t\n\t\tif (srcDir.exists() && srcDir.isDirectory()) {\n\t\t\t\n\t\t\tFile[] allFiles = srcDir.listFiles();\n\t\t\t\n\t\t\tshowAllFiles(allFiles);\n\t\t\tshowAllDirectories(allFiles);\n\t\t} \n\t}\n\t\n\tprivate static void showAllFiles(File[] allFiles) {\n\t\tSystem.out.println(\"普通文件:\");\n\t\tfor (File file : allFiles) {\n\t\t\tif (file.isFile()) {\n\t\t\t\tSystem.out.println(\"\\t\" + file.getName());\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static void showAllDirectories(File[] allFiles) {\n\t\tSystem.out.println(\"文件夹:\");\n\t\tfor (File file : allFiles) {\n\t\t\tif (file.isDirectory()) {\n\t\t\t\tSystem.out.println(\"\\t\" + file.getName());\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void findAllJavaFile(String pathname) throws FileNotFoundException {\n\t\t//如果给定的路径是一个null，无法使用\n\t\tif (null == pathname) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\t\t\n\t\tFile srcDir = new File(pathname);\n\t\t\n\t\t//判断文件是否存在，是否是一个文件夹\n\t\tif (!srcDir.exists()) { //srcDir.exists() == false\n\t\t\tthrow new FileNotFoundException();\n\t\t} else if (!srcDir.isDirectory()) { //srcDir.isDirectory() == false\n\t\t\t//运行时异常，不用再函数中声明\n\t\t\tthrow new RuntimeException(\"该文件不是一个文件夹\");\n\t\t}\n\t\t\t\n\t\tFile[] allFiles = srcDir.listFiles();\n\t\t\n\t\tfor (File file : allFiles) {\n\t\t\t//文件名后缀为.java 并且 是一个普通文件\n\t\t\tif (file.getName().endsWith(\".java\") && file.isFile()) {\n\t\t\t\tSystem.out.println(file.getName());\n\t\t\t}\n\t\t}\n\t\n\t} \n}\n\n\n```\n\n- 归档文件\n\n如果是普通文件，按照文件的后缀名创建对应的全大写文件夹，把文件剪切进去\n如果是文件夹，创建 subDir 文件夹，剪切进去；\n\n\n特殊情况，如果是没有文件后缀名的未知普通文件，就放入到 others 文件夹；\n\n  - 思路：\n    - 1.获取指定的文件夹路径，进行判断；\n    - 2.获取这个文件夹下面的所有子文件和子文件夹的 File[]类对象；\n    - 3.遍历这个 File[] 类型的数组，按照文件和文件夹进行区别操作；\n         - 3.1.如果是文件：\n           - 首先获取这个文件的文件后缀；\n           - 然后创建以这个文件后缀名全大写的文件夹；\n           - 最后移动该文件到这个文件夹；\n           - 注：如果一个文件没有后缀名，就放入到 Others 目录下；\n         - 3.2.如果是文件夹：\n           - 首先创建 subDir 目录；\n           - 移动该文件夹放入到 subDir 里面；\n\n\n",[[1562370728205,["GJX@GJXAIOU",[[1,52,"，控制属兔"]],[52,52],[57,57]]],[1562370731545,["GJX@GJXAIOU",[[-1,52,"，控制属兔"]],[57,57],[52,52]]],[1562370735313,["GJX@GJXAIOU",[[-1,56,"自"]],[57,57],[56,56]]],[1562370739153,["GJX@GJXAIOU",[[-1,101,"在"]],[102,102],[101,101]]]],null,"GJX@GJXAIOU"],["90a20bd5-87e8-43ba-83e2-90aa9cbf3868",1562370811194,"## 泛型\n\n- 为了解决数据类型一致化问题,避免没有意义的强制类型转换(放进什么数据，拿出来什么数据)\n\n- 定义泛型泛型使用的格式：\n<大写字母> 一般使用E 或者 T ，仅仅是占位符；\n\n- 泛型函数中使用\n  - 格式：\n```java\n权限修饰符 <自定义泛型> 返回值类型(可以使用泛型) 函数名(形式参数列表“自定义泛型”) {\n  同样可以使用自定义泛型\n}\n```\n\n- 泛型在类中使用\n  -  格式：\n```java\nclass 类名<自定义泛型> {\n  非静态的成员变量或者成员方法都可以使用类中定义的<自定义泛型>\n  \n  静态方法不能使用类中自定义泛型，但是可以方法中自己定义泛型  \n}\n\n```\n\n例如：`Arrays.sort(T[] t, Comparator<? super T> c)`\n\n- 泛型在接口中使用\n格式：\n```java\ninterface 接口名<自定义泛型> {\n  //成员变量 缺省属性：public static final\n  //成员方法 缺省属性：abstract\n}\n```\n\n- 一个类遵从带有自定义泛型的接口有两种方式：\n  例如接口如下：\n      interface A<T> {\n          public void testA(T t);\n      }\n  \n1. 方式1：更加自由，在创建类对象时，才对泛型进行约束\n```java\nclass Test1<T> implements A<T> {\n  public void testA(T t) {\n      //实现方法\n  }\n}\n``` \n\n\n2. 方式2 :遵从接口时，接口直接确定了泛型的具体类型\n  \n```java\nclass Test2 implements A<String> {\n  public void testA(String t) {\n      //实现方法\n  }\n}\n```\n\n- 泛型的上下限：\n`<? super T>`  表示数据类型是T对象或者其父类对象\n`<? extends T>`表示数据类型是T对象或者其子类对象\n  \n## Map\n  `Map<K, V> ` 键值对\n  两个实现类：\n  ---| HashMap\n  ---| TreeMap\n  常见的方法：\n  \n```java\nput(K key , V value);\nputAll(Map<? extends k, ? extends V> map)\n\nclear();\nremove(Object k);\n\nsize();\ncontainsKey(Object key);\ncontainsValue(Object Value);\n\nkeySet();\nvalues();\n\nget(Object k);\n```\n \n\n## 简单介绍了一个匿名内部类\n```java\n new Comparator<Student>() {\n      @Override   \n      public int compare(Student o1, Student o2) {\n          return o1.getAge() - o2.getAge();\n      }\n  }\n```\n\n\n## Map 补充\n\n```java\n/**\n * \n */\npackage study;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\n\t\tmap.put(\"MacBook Pro\", 22888);\n\t\tmap.put(\"iPhoneX\", 8398);\n\t\tmap.put(\"iPad Pro\", 5198);\n\t\t\n\t\tSystem.out.println(map);\n\t\t\n\t\t//第一种遍历方式：借助于keySet，通过key值拿到value值\n\t\tSet<String> set = map.keySet();\n\t\t\n\t\t//使用Set集合的Iterator迭代器\n\t\tIterator<String> it = set.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tString key = it.next(); //获取每一个Map中的key值\n\t\t\tint value = map.get(key);\n\t\t\t\n\t\t\tSystem.out.println(key + \"=\" + value);\n\t\t}\n\t\t//以上方法，不太合适，实际上获取的key值，再借助于Map里面的get方法，获取对应的Value\n\t\t//实际上并没有获取到完整的键值对\n\t\t\n\t\t\n\t\t\n\t\t//第二种方式：借助于values\n\t\tCollection<Integer> c = map.values();\n\t\t\n\t\tfor (Integer integer : c) {\n\t\t\tSystem.out.println(integer);\n\t\t}\n\t\t\n\t\t//以上方法也不适合，因为只能拿到value值，获取不到对应的key\n\t\t\n\t\t\n\t\t\n\t\t//在Java中万物皆对象，因此可以将键值对看成是一个类【必须会】\n\t\t/*\n\t \t将键值对，认为是一个对象，组成一个类，称之为Entry\n\t\t class Entry<K, V> {\n\t\t \tK key;\n\t\t \tV value;\n\t\t } \n\t\t 这里可以认为在Map集合中，保存的每一个键值对都是一个Entry对象，\n\t\t 然后将这些Entry对象获取出来，做成一个集合，然后对该集合进行遍历；\n\t\t entrySet();\n\t\t Map.Entry；Entry为Map的子接口，称为内部类\n\t\t */\n\t\tSet<Entry<String, Integer>> entrySet = map.entrySet();\n\t\t\n\t\tIterator<Entry<String, Integer>> it2 = entrySet.iterator();\n\t\t\n\t\twhile (it2.hasNext()) {\n\t\t\tSystem.out.println(it2.next());\n\t\t}\n\t}\n}\n\n```\n\n\n# 文件操作\n\n IO:\nInput Output\nread  write\n\n只考虑文件操作情况下：\n -  读取操作是：input read 从硬盘(存储设备) 到 内存\n - 写入操作是：output write 从内存 到 硬盘(存储设备)\n\n如何操作文件或者文件夹：\n创建，删除，剪切，复制，重命名，粘贴\n\nJava里万物皆对象\n计算机世界里万物皆文件\n\n- Sun提供了一个File类，专门来操作【文件】和【文件夹】\n\n```java\n 如何创建一个File类对象：\nFile(String pathName);\n根据文件路径创建File类对象，可以是【绝对路径】可以是【相对路径】\n\nFile(String parent, String child);\n根据提供的父目录【文件夹】地址，和当前文件夹下的【子文件】或者【子文件夹】创建File类对象\n\nFile(File parent, String child);\n根据创建好的父目录的File类对象，和这个目录下的【子文件】或者【子文件夹】创建File类对象\n```\n【pathName】\n\\n \\t \\\\ 转义字符\n假如实际地址为：C:\\aaa\\bbb 如果在代码中使用 \"C:\\\\aaa\\\\bbb\" LOW\n\n推荐使用 / 来区分路径,不使用反斜杠\nJava是一个跨平台的语言\nJava提供了一个系统变量\nFile.separator 可以根据不同的系统换，自动填充文件分隔符\n示例：\n```java\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tFile file1 = new File(\"C:\\\\aaa\"); //采用Windows的分隔符\n\t\tFile file2 = new File(\"C:/aaa\"); //用在Linux和Windows通用的分隔符\n\t\tFile file3 = new File(\"C:\" + File.separator + \"aaa\"); //这里使用Java系统变量\n\t\t\n\t\tSystem.out.println(file1);\n\t\tSystem.out.println(file2);\n\t\tSystem.out.println(file3);\n\t\t\n\t\tFile file4 = new File(\"C:\\\\aaa\", \"1.txt\"); //父目录 子目录\n\t\tSystem.out.println(file4);\n\t\t\n\t\tFile file5 = new File(file1, \"1.txt\");\n\t\tSystem.out.println(file5);\n\t}\n}\n```\n\nFile 操作常见方法：\n```java\nisFile();\nis文件夹英文();\ncreateFile()\nrenameTo\ncopy\n```\n\n\n## 可以利用File类对象，创建文件或者文件夹\n\t\n- boolean createNewFile(); 创建文件\n\t使用File类对象，创建File类对象里面保存的地址 指定 的 普通文件\n\t返回值boolean: 创建成功返回true，创建失败返回false\n\t返回false失败原因:\n\t\t1. 该文件已经存在\n\t\t2. 操作路径非法，例如：文件指定所在文件夹不存在\n\t\t3. 操作的文件夹没有写入权限\n\t\t4. 硬盘坏了\n【要求】\n\t创建文件，必须带有文件后缀名！！！\n\t.java .class .doc .txt .xml .html .css .js .md .jsp \n\t.m .h .c .cpp .php .net .ppt .xls .exe .zip .rar .mp4\n\t.rmvb\n\t\n\t\n- boolean mkdir(); make direcotry 创建文件夹\n\t使用File类对象里面保存的文件夹地址，创建对应的文件夹\n\t- 返回值：boolean 创建成功返回true 创建失败返回false\n\t- 失败原因：\n\t\t1. 已经存在该文件夹\n\t\t2. 指定创建文件夹的父目录没有写入权限\n\t\t3. 要创建文件夹的父目录不存在\n- boolean mkdirs();\n\t使用File类对象里面保存的文件夹路径地址，创建指定文件夹，如果该路径中的【中间文件夹】不存在,把中间路径，同时创建\n\t- 返回值：boolean 创建成功返回true 创建失败返回false\n\t- 失败原因:\n\t\t1. 已经存在该文件夹\n\t\t2. 指定创建文件夹没有写入权限\n\tC:/aaa/ccc/ddd/eee/fff/ggg/hhh/iii/jjj\n\t\n- boolean renameTo(File dest);\n\t- 功能1：\n\t\t重命名！！！文件 或者 文件夹\n\t- 功能2：\n\t\t剪切，移动到另一个位置\n\t\n\t作业：\n\t测试，renameTo操作一个非空文件夹！！！\n\n程序测试：\n```java\nimport java.io.File;\nimport java.io.IOException;\n\npublic class Demo2 {\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\t//创建文件\n\t\tFile file1 = new File(\"C:/aaa/1.txt\");\n\t\t\n\t\tboolean ret = file1.createNewFile();\n\t\tSystem.out.println(\"文件创建成功了吗?\" + ret);\n\t\t\n//\t\tFile file2 = new File(\"C:/bb/1.txt\");\n//\t\tSystem.out.println(file2.createNewFile());\n\t\t\n\t\tFile file2 = new File(\"C:/aaa/bbb\");\n\t\tret = file2.mkdir();\n\t\tSystem.out.println(\"文件夹创建成功了吗?\" + ret);\n\t\t\n\t\tFile file3 = new File(\"C:/aaa/ccc/ddd\");\n\t\tret = file3.mkdir();\n\t\tSystem.out.println(\"文件夹创建成功了吗?\" + ret);\n\t\t\n\t\tFile file4 = new File(\"C:/aaa/ccc/ddd/eee/fff/ggg/hhh/iii/jjj\");\n\t\tret = file4.mkdirs();\n\t\tSystem.out.println(\"文件夹创建成功了吗?\" + ret);\n\t\t\n\t\t\n\t\tFile dest1 = new File(\"C:/aaa/2.txt\");\n\t\t//把C:/aaa/1.txt 重命名！！！\n\t\tret = file1.renameTo(dest1);\n\t\tSystem.out.println(\"重命名成功了吗?\" + ret);\n\t\t\n\t\tret = file2.renameTo(new File(\"C:/aaa/ddd\"));\n\t\tSystem.out.println(\"重命名文件夹成功了吗?\" + ret);\n\t\t\n\t\t//测试剪切功能\n\t\t//原地址要带有文件或者文件夹名，而且目标地址也有带有文件或者文件夹名\n\t\tFile txt3 = new File(\"C:/aaa/3.txt\");\n\t\tFile dest2 = new File(\"C:\\\\Users\\\\刘晓磊\\\\Desktop\\\\3.txt\");\n\t\t\n\t\tret = txt3.renameTo(dest2);\n\t\tSystem.out.println(\"剪切成功了吗?\" + ret);\n\t\t\n\t}\n}\n```\n\n- delete()\n \t\t删除文件或者文件夹，但是如果操作文件夹的话，只能删除空文件夹,成功返回true ，失败返回false \t\t\n \t\t该删除操作不是把文件或者文件夹放入到回收站里，而是直接从磁盘上抹去数据,该操作不可逆\n \t\n - deleteOnExit()\n \t\t当JVM虚拟机运行终止之后，删除指定的文件或者文件夹，而不是调用立即删除\t\n \t- 用途：\n \t\t\t用于删除程序运行结束之后残留的缓存文件或者运行日志文件，节约硬盘空间\n\n代码示例：\n```java\nimport java.io.File;\nimport java.util.Scanner;\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n\t\tFile file1 = new File(\"C:/aaa/1.txt\");\n\t\t\n\t\tSystem.out.println(\"删除成功了吗?\" + file1.delete());\n\t\t\n\t\tFile file2 = new File(\"C:/aaa/ddd\");\n\t\tSystem.out.println(\"删除成功了吗?\" + file2.delete());\n\t\t\n\t\tFile file3 = new File(\"C:/aaa/ccc\");\n\t\tSystem.out.println(\"删除成功了吗?\" + file3.delete()); //返回false\n\t\t\n\t\t// deleteOnExit()使用方法\n\t\tFile file4 = new File(\"C:/aaa/2.txt\");\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfile4.deleteOnExit();\n\t\tsc.nextLine();\n\t}\n}\n```\n\n * exists(); 判断指定的文件或者文件夹是否存在\n * isFile(); 判断指定的File是文件吗？\n * isDirectory(); 判断指定的File是文件夹吗？\n * isHidden(); 判断指定的File是隐藏文件吗？\n * isAbsolute();  判断创建File类对象使用的是绝对路径吗？\n 返回值全是boolean \n\n代码示例：\n```java\nimport java.io.File;\npublic class Demo4 {\n\tpublic static void main(String[] args) {\n\t\tFile file = new File(\"C:/aaa/1.txt\");\n\t\t\n\t\tSystem.out.println(\"这个文件或者文件夹存在吗?\" + file.exists());\n\t\tSystem.out.println(\"这个File类对象是一个文件类对象吗?\" + file.isFile());\n\t\t//这里使用了匿名对象，我一般称之为 一点到底！！！\n\t\tSystem.out.println(\"这个File类对象是一个文件夹类对象吗?\" + new File(\"C:/aaa\").isDirectory());\n\t\tSystem.out.println(\"这个File类对象是一个隐藏文件对象吗?\" + file.isHidden());\n\t\tSystem.out.println(\"创建File类对象使用了绝对路径吗?\" + file.isAbsolute());\n\t\tSystem.out.println(\"创建File类对象使用了绝对路径吗?\" + new File(\".\").isAbsolute()); //. 表示当前目录\t\t\n\t\n\t}\n}\n```\n\nString[] split(String str);\n \t123.3213.321.321.3\n  \t以下方法和文件是否【存在无关】！！！！！！\n  \t\n- getName(); 获取路径中的文件名或者文件夹名\n- getPath(); 获取File类对象里面保存的路径\n- getAbsolutePath(); 获取File对象里面保存路径对应的绝对路径\n- getParent(); 获取当前文件或者文件夹的父目录，如果没有返回null\n  \t\n- lashModified(); 文件最后的修改时间\n\tUNIX时间戳\n\t计算机元年到修改时间的秒数：\n\t1970年01月01日 00:00:00\n\t2017年12月08日 15:24:50\n\n- length(); 文件的大小(字节数)，如果文件不存在，或者是一个文件夹，返回0L\n\n代码示例：\n```java\nimport java.io.File;\nimport java.sql.Date;\nimport java.text.SimpleDateFormat;\npublic class Demo5 {\n\tpublic static void main(String[] args) {\n\t\tFile file = new File(\"E:/aaa/1.txt\");\n\t\n\t\tSystem.out.println(file.getName()); //1.txt\n\t\tSystem.out.println(file.getPath()); //E:/aaa/1.txt\n\t\tSystem.out.println(file.getAbsolutePath()); //E:/aaa/1.txt\n\t\tSystem.out.println(file.getParent()); //E:/aaa\n\t\t\n\t\tlong last = new File(\"C:/aaa/1.txt\").lastModified();\n\t\t\n\t\tDate date = new Date(last);\n\t\tSimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\tSystem.out.println(format.format(date));\n\t\t\n\t\t//System.out.println(last); //直接使用这个会得到秒数\n\t}\n}\n```\n其他方法：返回值  方法  含义\n- static File[]       listRoots(); \n \t获取当前计算机中所有的盘符，针对Windows操作系统\n \tLinux/UNIX没有区分盘符的概念 只有一个根目录 / \n \t\n- String[]        list();\n \t获取指定【文件夹】里面所有子文件和子文件，返回一个String类型的的数组\n \t\n- File[]    listFiles();\n \t获取指定【文件夹】里面所有子文件和子文件，返回一个File类型的的数组\n \t\n- 遍历一个文件夹：\n 文件夹:\n       文件夹1;\n       文件夹2;\n       文件夹3;\n………………\n文件:\n\t\t文件1;\n\t\t文件2;\n\t\t文件3;\n\t\t………………\n\n代码示例：\n```java\nimport java.io.File;\npublic class Demo6 {\n\tpublic static void main(String[] args) {\n\t\tFile[] roots = File.listRoots();\n\t\tfor (File file : roots) {\n\t\t\tSystem.out.println(file.getPath());\n\t\t}\n\t\tSystem.out.println(\"---------------------------------\");\n\t\t\n\t\tFile file = new File(\"C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\");\n\t\tString[] allFilePath = file.list();\n\t\t\n\t\tfor (String string : allFilePath) {\n\t\t\tSystem.out.println(string);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"---------------------------------\");\n\t\t\n\t\tFile[] allFileObject = file.listFiles();\n\t\tfor (File file2 : allFileObject) {\n\t\t\tSystem.out.println(file2);\n\t\t}\n\t\t\n\t}\n}\n```\n\n-  遍历一个文件夹：\n \t\t文件夹:\n \t\t\t文件夹1;\n \t\t\t文件夹2;\n \t\t\t文件夹3;\n \t\t\t………………\n \t\t文件:\n\t\t\t文件1;\n\t\t\t文件2;\n\t\t\t文件3;\n\t\t\t………………\n1. 首先利用listFiles()方法，获取指定文件夹下的所有子文件和子文件夹的File类对象数组\n2. 利用isFile或者isDirectory判断是否是文件或者是文件夹\n3. 区别对象，利用不同的函数 \n\n找出指定文件夹下的所有.java文件?   endWith() 和 isFile()\n\n```java\npublic class Demo7 {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\t\n\t\tfindAllJavaFile(\"C:\\\\Users\\\\刘晓磊\\\\Desktop\\\\test\");\n\t\t\n\t\tFile srcDir = new File(\"C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\");\n\t\t\n\t\tif (srcDir.exists() && srcDir.isDirectory()) {\n\t\t\t\n\t\t\tFile[] allFiles = srcDir.listFiles();\n\t\t\t\n\t\t\tshowAllFiles(allFiles);\n\t\t\tshowAllDirectories(allFiles);\n\t\t} \n\t}\n\t\n\tprivate static void showAllFiles(File[] allFiles) {\n\t\tSystem.out.println(\"普通文件:\");\n\t\tfor (File file : allFiles) {\n\t\t\tif (file.isFile()) {\n\t\t\t\tSystem.out.println(\"\\t\" + file.getName());\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static void showAllDirectories(File[] allFiles) {\n\t\tSystem.out.println(\"文件夹:\");\n\t\tfor (File file : allFiles) {\n\t\t\tif (file.isDirectory()) {\n\t\t\t\tSystem.out.println(\"\\t\" + file.getName());\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void findAllJavaFile(String pathname) throws FileNotFoundException {\n\t\t//如果给定的路径是一个null，无法使用\n\t\tif (null == pathname) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\t\t\n\t\tFile srcDir = new File(pathname);\n\t\t\n\t\t//判断文件是否存在，是否是一个文件夹\n\t\tif (!srcDir.exists()) { //srcDir.exists() == false\n\t\t\tthrow new FileNotFoundException();\n\t\t} else if (!srcDir.isDirectory()) { //srcDir.isDirectory() == false\n\t\t\t//运行时异常，不用再函数中声明\n\t\t\tthrow new RuntimeException(\"该文件不是一个文件夹\");\n\t\t}\n\t\t\t\n\t\tFile[] allFiles = srcDir.listFiles();\n\t\t\n\t\tfor (File file : allFiles) {\n\t\t\t//文件名后缀为.java 并且 是一个普通文件\n\t\t\tif (file.getName().endsWith(\".java\") && file.isFile()) {\n\t\t\t\tSystem.out.println(file.getName());\n\t\t\t}\n\t\t}\n\t\n\t} \n}\n\n\n```\n\n- 归档文件\n\n如果是普通文件，按照文件的后缀名创建对应的全大写文件夹，把文件剪切进去\n如果是文件夹，创建 subDir 文件夹，剪切进去；\n\n\n特殊情况，如果是没有文件后缀名的未知普通文件，就放入到 others 文件夹；\n\n  - 思路：\n    - 1.获取指定的文件夹路径，进行判断；\n    - 2.获取这个文件夹下面的所有子文件和子文件夹的 File[]类对象；\n    - 3.遍历这个 File[] 类型的数组，按照文件和文件夹进行区别操作；\n         - 3.1.如果是文件：\n           - 首先获取这个文件的文件后缀；\n           - 然后创建以这个文件后缀名全大写的文件夹；\n           - 最后移动该文件到这个文件夹；\n           - 注：如果一个文件没有后缀名，就放入到 Others 目录下；\n         - 3.2.如果是文件夹：\n           - 首先创建 subDir 目录；\n           - 移动该文件夹放入到 subDir 里面；\n\n\n",[[1562370756883,["GJX@GJXAIOU",[[1,52,"控制"]],[52,52],[54,54]]],[1562370759018,["GJX@GJXAIOU",[[1,52,"。"]],[52,52],[53,53]]],[1562370760119,["GJX@GJXAIOU",[[-1,52,"。"]],[53,53],[52,52]]],[1562370760499,["GJX@GJXAIOU",[[1,52,"，"]],[52,52],[53,53]]],[1562370771338,["GJX@GJXAIOU",[[1,55,"输入数据的格式；"]],[55,55],[63,63]]],[1562370794490,["GJX@GJXAIOU",[[1,3,"一、复习："]],[3,3],[8,8]]],[1562370815897,["GJX@GJXAIOU",[[1,113,"### "]],[113,114],[126,126]]],[1562370818743,["GJX@GJXAIOU",[[-1,117,"-"]],[118,118],[117,117]]],[1562370857424,["GJX@GJXAIOU",[[-1,212,"- "]],[212,214],[212,212]]],[1562370858680,["GJX@GJXAIOU",[[1,212,"### "]],[212,212],[223,223]]],[1562370911481,["GJX@GJXAIOU",[[-1,292,"\n"]],[293,293],[292,292]]],[1562370914489,["GJX@GJXAIOU",[[1,292,"；"]],[292,292],[293,293]]],[1562370917859,["GJX@GJXAIOU",[[1,327,"；"]],[327,327],[328,328]]],[1562370953711,["GJX@GJXAIOU",[[-1,333,"\n"]],[333,333],[332,332]]],[1562370967143,["GJX@GJXAIOU",[[1,388,"### "]],[388,389],[402,402]]],[1562370970202,["GJX@GJXAIOU",[[-1,392,"-"]],[393,393],[392,392]]],[1562370976214,["GJX@GJXAIOU",[[1,118,"（）"]],[118,118],[120,120]]],[1562370978739,["GJX@GJXAIOU",[[1,119,"一"]],[119,119],[120,120]]],[1562370982956,["GJX@GJXAIOU",[[1,219,"（）"]],[219,219],[221,221]]],[1562370985109,["GJX@GJXAIOU",[[1,220,"二"]],[220,220],[221,221]]],[1562370990003,["GJX@GJXAIOU",[[1,399,"（）"]],[399,399],[401,401]]],[1562370992267,["GJX@GJXAIOU",[[1,400,"三"]],[400,400],[401,401]]],[1562371012858,["GJX@GJXAIOU",[[-1,231," -  "]],[230,234],[230,230]]],[1562371014504,["GJX@GJXAIOU",[[-1,230," "]],[231,231],[230,230]]],[1562371017178,["GJX@GJXAIOU",[[-1,129,"  - "]],[129,133],[129,129]]],[1562372007491,["GJX@GJXAIOU",[[-1,719,"``` "],[1,723,"·"]],[719,719],[720,720]]],[1562372008579,["GJX@GJXAIOU",[[-1,719,"·"]],[720,720],[719,719]]],[1562372009596,["GJX@GJXAIOU",[[1,719,"```"]],[719,719],[722,722]]],[1562372045984,["GJX@GJXAIOU",[[-1,724,"\n"]],[724,724],[723,723]]],[1562372046584,["GJX@GJXAIOU",[[-1,723,"\n"]],[723,723],[722,722]]],[1562372049025,["GJX@GJXAIOU",[[1,723,"\n"]],[723,723],[724,724]]],[1562372051031,["GJX@GJXAIOU",[[-1,754," "]],[754,754],[753,753]]],[1562372051658,["GJX@GJXAIOU",[[-1,752,"\n"]],[753,753],[752,752]]],[1562372261031,["GJX@GJXAIOU",[[-1,968," ---| "]],[967,973],[967,967]]],[1562372263256,["GJX@GJXAIOU",[[1,968,"  "]],[967,967],[969,969]]],[1562372263450,["GJX@GJXAIOU",[[1,969,"-"]],[969,969],[970,970]]],[1562372263715,["GJX@GJXAIOU",[[1,971," "]],[970,970],[971,971]]],[1562372266423,["GJX@GJXAIOU",[[-1,982,"---|"]],[986,986],[982,982]]],[1562372268224,["GJX@GJXAIOU",[[1,983,"  "]],[982,982],[984,984]]],[1562372269221,["GJX@GJXAIOU",[[1,984,"-"]],[984,984],[985,985]]],[1562372269355,["GJX@GJXAIOU",[[1,986," "]],[985,985],[986,986]]],[1562372272431,["GJX@GJXAIOU",[[-1,982,"  "]],[984,984],[982,982]]],[1562372275017,["GJX@GJXAIOU",[[1,960,"- "]],[960,960],[962,962]]],[1562372277144,["GJX@GJXAIOU",[[1,971,"  "]],[973,973],[975,975]]],[1562372278192,["GJX@GJXAIOU",[[1,986,"  "]],[991,991],[993,993]]],[1562372281818,["GJX@GJXAIOU",[[1,1001,"- "]],[1001,1001],[1003,1003]]],[1562372286768,["GJX@GJXAIOU",[[1,1001,"\n  "]],[1001,1001],[1004,1004]]],[1562372289719,["GJX@GJXAIOU",[[-1,1013,"  "]],[1015,1015],[1013,1013]]],[1562372290186,["GJX@GJXAIOU",[[-1,1013,"\n"]],[1013,1013],[1012,1012]]],[1562372342584,["GJX@GJXAIOU",[[-1,1424,"/**\n * \n */"]],[1424,1435],[1424,1424]]],[1562372343488,["GJX@GJXAIOU",[[-1,1424,"\n"]],[1424,1424],[1423,1423]]],[1562372422711,["GJX@GJXAIOU",[[-1,2884," "]],[2885,2885],[2884,2884]]],[1562372435728,["GJX@GJXAIOU",[[-1,2997,"\n"]],[2998,2998],[2997,2997]]],[1562372437260,["GJX@GJXAIOU",[[1,2997,","]],[2997,2997],[2998,2998]]],[1562372536368,["GJX@GJXAIOU",[[1,3368,"**"],[1,3387,"**"]],[3368,3387],[3368,3391]]],[1562372539864,["GJX@GJXAIOU",[[1,3375,"`"]],[3375,3375],[3376,3376]]],[1562372541146,["GJX@GJXAIOU",[[1,3378,"`"]],[3378,3378],[3379,3379]]],[1562372560320,["GJX@GJXAIOU",[[-1,3421,"\n"]],[3422,3422],[3421,3421]]],[1562372562114,["GJX@GJXAIOU",[[1,3421,":"]],[3421,3421],[3422,3422]]],[1562373030524,["GJX@GJXAIOU",[[1,3862," fan"]],[3862,3862],[3866,3866]]],[1562373031123,["GJX@GJXAIOU",[[1,3866,"="]],[3866,3866],[3867,3867]]],[1562373032120,["GJX@GJXAIOU",[[-1,3863,"fan="]],[3867,3867],[3863,3863]]],[1562373036261,["GJX@GJXAIOU",[[1,3863,"返回的是路径"]],[3863,3863],[3869,3869]]],[1562373048638,["GJX@GJXAIOU",[[-1,3863,"返回的是路径"]],[3863,3869],[3863,3863]]],[1562373051933,["GJX@GJXAIOU",[[1,3892," 、"]],[3892,3892],[3894,3894]]],[1562373052432,["GJX@GJXAIOU",[[-1,3893,"、"]],[3894,3894],[3893,3893]]],[1562373056640,["GJX@GJXAIOU",[[1,3893,"//返回的是路径"]],[3893,3893],[3901,3901]]],[1562373122403,["GJX@GJXAIOU",[[-1,4018,"文件夹英文"],[1,4023,"Directory"]],[4018,4023],[4027,4027]]],[1562373124812,["GJX@GJXAIOU",[[1,4030," 、、"]],[4030,4030],[4033,4033]]],[1562373125577,["GJX@GJXAIOU",[[-1,4031,"、、"]],[4033,4033],[4031,4031]]],[1562373130782,["GJX@GJXAIOU",[[1,4031,"//是否为目录"]],[4031,4031],[4038,4038]]],[1562373139387,["GJX@GJXAIOU",[[1,4015," //是否为文件"]],[4015,4015],[4023,4023]]],[1562373786523,["GJX@GJXAIOU",[[1,5757," 、、"]],[5757,5757],[5760,5760]]],[1562373787239,["GJX@GJXAIOU",[[-1,5758,"、、"]],[5760,5760],[5758,5758]]],[1562373796195,["GJX@GJXAIOU",[[1,5758,"//里面的参数为新"]],[5758,5758],[5767,5767]]],[1562373797415,["GJX@GJXAIOU",[[-1,5766,"新"]],[5767,5767],[5766,5766]]],[1562373809883,["GJX@GJXAIOU",[[1,5766,"命名文件的新抽象路径"]],[5766,5766],[5776,5776]]],[1562373814653,["GJX@GJXAIOU",[[1,5776,"名称，不能是"]],[5776,5776],[5782,5782]]],[1562373817734,["GJX@GJXAIOU",[[-1,5779,"不能是"]],[5782,5782],[5779,5779]]],[1562373832981,["GJX@GJXAIOU",[[1,5779,"因为要求File类型，不能使用字符串路径；"]],[5779,5779],[5800,5800]]],[1562373862206,["GJX@GJXAIOU",[[1,5891," //需要将路径创建为一个新的File类对象"]],[5891,5891],[5913,5913]]],[1562373881995,["GJX@GJXAIOU",[[-1,6076,"\\\\"],[1,6078,"、"]],[6076,6076],[6077,6077]]],[1562373883249,["GJX@GJXAIOU",[[-1,6076,"、"]],[6077,6077],[6076,6076]]],[1562373883769,["GJX@GJXAIOU",[[1,6076,"/"]],[6076,6076],[6077,6077]]],[1562373887283,["GJX@GJXAIOU",[[-1,6082,"\\\\"],[1,6084,"/"]],[6082,6084],[6083,6083]]],[1562373892439,["GJX@GJXAIOU",[[-1,6086,"\\\\"]],[6088,6088],[6086,6086]]],[1562373893097,["GJX@GJXAIOU",[[1,6086,"/"]],[6086,6086],[6087,6087]]],[1562373895464,["GJX@GJXAIOU",[[-1,6094,"\\\\"]],[6096,6096],[6094,6094]]],[1562373895892,["GJX@GJXAIOU",[[1,6094,"/"]],[6094,6094],[6095,6095]]],[1562373907456,["GJX@GJXAIOU",[[1,6225,"**"],[1,6232,"**"]],[6225,6232],[6225,6236]]],[1562373912048,["GJX@GJXAIOU",[[1,6289,"**"],[1,6306,"**"]],[6289,6306],[6289,6310]]],[1562373915652,["GJX@GJXAIOU",[[1,6257,";"]],[6257,6257],[6258,6258]]],[1562373918157,["GJX@GJXAIOU",[[1,6311,"."]],[6311,6311],[6312,6312]]],[1562373919713,["GJX@GJXAIOU",[[-1,6311,"."]],[6312,6312],[6311,6311]]],[1562373920436,["GJX@GJXAIOU",[[1,6311,"，"]],[6311,6311],[6312,6312]]],[1562373921465,["GJX@GJXAIOU",[[-1,6311,"，"]],[6312,6312],[6311,6311]]],[1562373921948,["GJX@GJXAIOU",[[1,6311,"。"]],[6311,6311],[6312,6312]]],[1562373934660,["GJX@GJXAIOU",[[1,6373,"；"]],[6373,6373],[6374,6374]]],[1562373942707,["GJX@GJXAIOU",[[1,6422,"；"]],[6422,6422],[6423,6423]]],[1562373978407,["GJX@GJXAIOU",[[1,7823,"**"],[1,7838,"**"]],[7823,7838],[7823,7842]]],[1562373980718,["GJX@GJXAIOU",[[-1,7771,"String[] split(String str);\n \t123.3213.321.321.3\n"]],[7770,7819],[7770,7770]]],[1562373981119,["GJX@GJXAIOU",[[-1,7770,"\n"]],[7770,7770],[7769,7769]]],[1562373982930,["GJX@GJXAIOU",[[1,7773,"\n  \t"]],[7773,7773],[7777,7777]]],[1562373984062,["GJX@GJXAIOU",[[-1,7775," \t"]],[7777,7777],[7775,7775]]],[1562374275449,["GJX@GJXAIOU",[[-1,2538,"然后"]],[2540,2540],[2538,2538]]],[1562374321256,["GJX@GJXAIOU",[[-1,2517,"一"]],[2518,2518],[2517,2517]]],[1562374328609,["GJX@GJXAIOU",[[-1,2532,"，"]],[2533,2533],[2532,2532]]],[1562374353256,["GJX@GJXAIOU",[[-1,2548,"出来，"]],[2551,2551],[2548,2548]]],[1562374355307,["GJX@GJXAIOU",[[1,2548,"并"]],[2548,2548],[2549,2549]]],[1562379088281,["GJX@GJXAIOU",[[-1,11579,"\n"]],[11579,11579],[11578,11578]]],[1562379088927,["GJX@GJXAIOU",[[-1,11578,"\n"]],[11578,11578],[11577,11577]]],[1562379096944,["GJX@GJXAIOU",[[-1,11578,"特殊情况，如果是没有文件后缀名的未知普通文件，就放入到 others 文件夹；"]],[11578,11617],[11578,11578]]],[1562379098688,["GJX@GJXAIOU",[[1,11551,"\n"]],[11550,11550],[11551,11551]]],[1562379099267,["GJX@GJXAIOU",[[1,11551,"特殊情况，如果是没有文件后缀名的未知普通文件，就放入到 others 文件夹；"]],[11551,11551],[11590,11590]]],[1562379104236,["GJX@GJXAIOU",[[1,11551,"    "]],[11551,11551],[11555,11555]]],[1562394515921,["GJX@GJXAIOU",[[1,11982,"cengxu"]],[11982,11982],[11988,11988]]],[1562394517609,["GJX@GJXAIOU",[[-1,11982,"cengxu"]],[11988,11988],[11982,11982]]],[1562394518209,["GJX@GJXAIOU",[[1,11984,"\n"]],[11982,11982],[11983,11983]]],[1562394521884,["GJX@GJXAIOU",[[1,11983,"程序代码："]],[11983,11983],[11988,11988]]],[1562394522097,["GJX@GJXAIOU",[[1,11990,"\n"]],[11988,11988],[11989,11989]]],[1562394522674,["GJX@GJXAIOU",[[1,11991,"\n"]],[11989,11989],[11990,11990]]],[1562394523301,["GJX@GJXAIOU",[[1,11990,"··"]],[11990,11990],[11992,11992]]],[1562394524693,["GJX@GJXAIOU",[[-1,11990,"··"]],[11992,11992],[11990,11990]]],[1562394524875,["GJX@GJXAIOU",[[-1,11991,"\n"]],[11990,11990],[11989,11989]]],[1562394526381,["GJX@GJXAIOU",[[1,11989,"```"]],[11989,11989],[11992,11992]]],[1562394526427,["GJX@GJXAIOU",[[1,11992,"language\n```\n"]],[11992,11992],[11992,12000]]],[1562394527315,["GJX@GJXAIOU",[[-1,11992,"language"],[1,12000,"j"]],[11992,12000],[11993,11993]]],[1562394527791,["GJX@GJXAIOU",[[1,11993,"ava"]],[11993,11993],[11996,11996]]],[1562394527915,["GJX@GJXAIOU",[[1,11997,"\n"]],[11996,11996],[11997,11997]]],[1562395353552,["GJX@GJXAIOU",[[1,11997,"package study;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\n\n\n/**\n * class detail:\n * @author GJXAIOU\n * @since  2019年7月6日\n */\npublic class Demo1 {\n\tpublic static void main(String[] args)throws NullPointerException, IOException {\n\t\tachieveDirectoryAtPath(\"C:/test\");\n\t}\n\t\n\tpublic static void achieveDirectoryAtPath(String path) throws NullPointerException, IOException{\n\t\t//1.判断路径\n\t\tif (null == path) {\n\t\t\tthrow new NullPointerException(\"地址不能为null\");\n\t\t}\n\t\t\n\t\t//2.创建指定地址对应的File类对象\n\t\tFile file = new File(path);\n\t\t\n\t\t//3.判断这个是不是一个文件夹，并且是否存在\n\t\tif ((!file.exists() || !file.isDirectory())) {\n\t\t\t//等价于：file.exists() == false || file.isDirectory() == false;\n\t\t\tthrow new FileNotFoundException(\"没有指定文件\");\n\t\t}\n\t\t\n\t\t//在归档之前判断是否进行过归档操作，如果有则不再进行归档\n\t\tif (new File(file, \"file.lock\").exists()) {\n\t\t\tSystem.out.println(\"归档已完成\");\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\t//4.获取指定文件夹下面的所有子文件和子文件夹的File类对象数组\n\t\tFile[] allFiles = file.listFiles();\n\t\t\n\t\t//5.遍历该File数组，判断是文件还是文件夹，区别对待\n\t\tfor (File fileItem : allFiles) {\n\t\t\tif (fileItem.isFile()) {\n\t\t\t\t//文件操作file是当前要归档的文件夹，filename是要处理的文件名字\n\t\t\t\tachieveFile(file,fileItem.getName());\n\t\t\t}else {\n\t\t\t\t//文件夹操作\n\t\t\t\tachieveDri(file, fileItem.getName());\n\t\t\t}\n\t\t}//for\t\n\t\t\n\t\t//6.归档完成，上锁，防止再次归档\n\t\tFile lockFile = new File(file, \"file.lock\");\n\t\tlockFile.createNewFile();\n\t}\n\t\n\n\t\n\tprivate static void achieveFile(File file, String fileName) {\n\t\t//1.找到对应的文件后缀名\n\t\tint index = -1;\n\t\tString dirToCreate = null;\n\t\tFile srcFile = null; //原地址 \n\t\tFile dstFile = null;\n\t\t\n\t\t//2.获取要创建的文件夹路径的String类型字符串\n\t\t//判断文件是否存在文件后缀名，如果没有'.'则是不存在，有点但是点后面没有内容也是没有后缀名\n\t\tif ((index = fileName.lastIndexOf('.')) != -1 && fileName.substring(index + 1).length() !=0) { //不能包括index,因此加1\n\t\t\t/*上面的If语句等价于下面\n\t\t\t * index = fileName.lastIndexOf('.');\n\t\t\tif (index != -1) {\t\t\t\t\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\t /*\n\t\t\tString parent = file.getAbsolutePath();\n\t\t\tString dirName = fileName.substring(index + 1).toUpperCase();\n\t\t\tdirToCreate = parent + File.separator + dirName;\n\t\t\t*/\n\t\t\t//上面代码的简化版\n\t\t\t/*\n\t\t\t * File.separator作用：这是File类提供的一个更加运行环境而决定的文件路径分隔符，在Windows中是\\,\n\t\t\t * 在Linux和Unix中是/，这样写的好处是可以让代码的通用性和可移植性更好\n\t\t\t */\n\t\t\tdirToCreate =file.getAbsolutePath() + file.separator + fileName.substring(index + 1).toUpperCase();\t\t\t\n\t\t}else {\n\t\t\tdirToCreate = file.getAbsolutePath() + file.separator + \"other\";\n\t\t}\n\t\t\n\t\tnew File(dirToCreate).mkdir();  //创建File匿名对象，调用mkdir（）\n\t\t\n\t\tsrcFile = new File(file, fileName);\n\t\tdstFile = new File(dirToCreate,fileName);\n\t\t\n\t\tsrcFile.renameTo(dstFile);\n\t}\n\t \n\tprivate static void achieveDri(File file, String dirName) {\n\t\t//创建subDir\n\t\tFile subDir = new File(file, \"subDir\");\n\t\tsubDir.mkdir();\n\t\t\n\t\tFile srcFile = new File(file, dirName);\n\t\tFile dstFile = new File(subDir, dirName);\n\t\t\n\t\tsrcFile.renameTo(dstFile);\n\t}\n}"]],[11997,11997],[14739,14739]]],[1562398436515,["GJX@GJXAIOU",[[1,14746,"\n"]],[14743,14743],[14744,14744]]],[1562398436618,["GJX@GJXAIOU",[[1,14747,"\n"]],[14744,14744],[14745,14745]]],[1562398485135,["GJX@GJXAIOU",[[1,14745,"## danli"]],[14745,14745],[14753,14753]]],[1562398486233,["GJX@GJXAIOU",[[-1,14748,"danli"]],[14753,14753],[14748,14748]]],[1562398487996,["GJX@GJXAIOU",[[1,14748,"单利"]],[14748,14748],[14750,14750]]],[1562398488557,["GJX@GJXAIOU",[[-1,14748,"单利"]],[14750,14750],[14748,14748]]],[1562398490920,["GJX@GJXAIOU",[[1,14748,"单例"]],[14748,14748],[14750,14750]]],[1562399557077,["GJX@GJXAIOU",[[1,14751,"目的："]],[14751,14751],[14754,14754]]],[1562399631799,["GJX@GJXAIOU",[[1,14754,"使整个程序的运行过程中，有且只有一个当前类的类对象存在"]],[14754,14754],[14781,14781]]],[1562399655164,["GJX@GJXAIOU",[[1,14781,"；"]],[14781,14781],[14782,14782]]],[1562399655418,["GJX@GJXAIOU",[[1,14784,"\n"]],[14782,14782],[14783,14783]]],[1562399656626,["GJX@GJXAIOU",[[1,14785,"\n"]],[14783,14783],[14784,14784]]],[1562399666734,["GJX@GJXAIOU",[[1,14784,"方案一：在整个程序中"]],[14784,14784],[14794,14794]]],[1562399668303,["GJX@GJXAIOU",[[-1,14791,"程序中"]],[14794,14794],[14791,14791]]],[1562399692964,["GJX@GJXAIOU",[[1,14791,"程序的运行过程中，有且只调用一个构造方法（）"]],[14791,14791],[14813,14813]]],[1562399699430,["GJX@GJXAIOU",[[1,14812,"相当于仅仅"]],[14812,14812],[14817,14817]]],[1562399702490,["GJX@GJXAIOU",[[1,14817,"实例化一次"]],[14817,14817],[14822,14822]]],[1562399706016,["GJX@GJXAIOU",[[1,14823,"，"]],[14823,14823],[14824,14824]]],[1562399708047,["GJX@GJXAIOU",[[-1,14823,"，"]],[14824,14824],[14823,14823]]],[1562399708784,["GJX@GJXAIOU",[[1,14825,"\n"]],[14823,14823],[14824,14824]]],[1562399710222,["GJX@GJXAIOU",[[1,14824,"确定"]],[14824,14824],[14826,14826]]],[1562399710782,["GJX@GJXAIOU",[[-1,14824,"确定"]],[14826,14826],[14824,14824]]],[1562399723286,["GJX@GJXAIOU",[[1,14824,"缺点：第三方调研"]],[14824,14824],[14832,14832]]],[1562399724890,["GJX@GJXAIOU",[[-1,14829,"方调研"]],[14832,14832],[14829,14829]]],[1562399739314,["GJX@GJXAIOU",[[1,14829,"方调用者不知道这个规定，可以通过简单的n"]],[14829,14829],[14849,14849]]],[1562399739361,["GJX@GJXAIOU",[[1,14848," "]],[14849,14849],[14850,14850]]],[1562399742181,["GJX@GJXAIOU",[[1,14850,"ew关键字"]],[14850,14850],[14855,14855]]],[1562399742226,["GJX@GJXAIOU",[[1,14852," "]],[14855,14855],[14856,14856]]],[1562399745340,["GJX@GJXAIOU",[[1,14856,"进行调研"]],[14856,14856],[14860,14860]]],[1562399746220,["GJX@GJXAIOU",[[-1,14858,"调研"]],[14860,14860],[14858,14858]]],[1562399748018,["GJX@GJXAIOU",[[1,14858,"调用；"]],[14858,14858],[14861,14861]]],[1562401406305,["GJX@GJXAIOU",[[1,14863,"\n"]],[14861,14861],[14862,14862]]],[1562401421878,["GJX@GJXAIOU",[[1,14862,"同时如果使用private"]],[14862,14862],[14875,14875]]],[1562401421926,["GJX@GJXAIOU",[[1,14868," "]],[14875,14875],[14876,14876]]],[1562401424159,["GJX@GJXAIOU",[[1,14876,"关键字"]],[14876,14876],[14879,14879]]],[1562401424206,["GJX@GJXAIOU",[[1,14876," "]],[14879,14879],[14880,14880]]],[1562401439317,["GJX@GJXAIOU",[[1,14880,"修饰构造函数，则构造方法"]],[14880,14880],[14892,14892]]],[1562401448068,["GJX@GJXAIOU",[[1,14892,"在类外不发"]],[14892,14892],[14897,14897]]],[1562401448863,["GJX@GJXAIOU",[[-1,14895,"不发"]],[14897,14897],[14895,14895]]],[1562401500063,["GJX@GJXAIOU",[[1,14895,"无法使用且类外没有对象，则所有和对象相关的方法均不能使用，需要不通过对象就可以调研"]],[14895,14895],[14936,14936]]],[1562401501455,["GJX@GJXAIOU",[[-1,14934,"调研"]],[14936,14936],[14934,14934]]],[1562401506132,["GJX@GJXAIOU",[[1,14934,"调用方法："]],[14934,14934],[14939,14939]]],[1562401506432,["GJX@GJXAIOU",[[1,14941,"\n"]],[14939,14939],[14940,14940]]],[1562401510631,["GJX@GJXAIOU",[[1,14940,"使用static"]],[14940,14940],[14948,14948]]],[1562401510678,["GJX@GJXAIOU",[[1,14942," "]],[14948,14948],[14949,14949]]],[1562401513256,["GJX@GJXAIOU",[[1,14949,"关键字"]],[14949,14949],[14952,14952]]],[1562401513303,["GJX@GJXAIOU",[[1,14949," "]],[14952,14952],[14953,14953]]],[1562401665789,["GJX@GJXAIOU",[[1,14953,"获取或者换"]],[14953,14953],[14958,14958]]],[1562401666728,["GJX@GJXAIOU",[[-1,14957,"换"]],[14958,14958],[14957,14957]]],[1562401671133,["GJX@GJXAIOU",[[1,14957,"创建类对象"]],[14957,14957],[14962,14962]]],[1562401673408,["GJX@GJXAIOU",[[1,14964,"\n"]],[14962,14962],[14963,14963]]],[1562401679806,["GJX@GJXAIOU",[[1,14963,"- 该方法听过"]],[14963,14963],[14970,14970]]],[1562401680575,["GJX@GJXAIOU",[[-1,14968,"听过"]],[14970,14970],[14968,14968]]],[1562401699229,["GJX@GJXAIOU",[[1,14968,"提供给类外使用，因此权限修饰符为【public】"]],[14968,14968],[14992,14992]]],[1562401701768,["GJX@GJXAIOU",[[1,14993,"- \n"]],[14992,14992],[14995,14995]]],[1562401736285,["GJX@GJXAIOU",[[1,14995,"调用时候不能通过类对象进行调用，需要类名进行调用，使用【static】关键字"]],[14995,14995],[15033,15033]]],[1562401736809,["GJX@GJXAIOU",[[1,15034,"- \n"]],[15033,15033],[15036,15036]]],[1562401782781,["GJX@GJXAIOU",[[1,15036,"该方法是获取当前类的类对象，所以返回值应该是当前类对象类型【SingleDemo】"]],[15036,15036],[15077,15077]]],[1562401785312,["GJX@GJXAIOU",[[1,15078,"- \n"]],[15077,15077],[15080,15080]]],[1562401794952,["GJX@GJXAIOU",[[-1,15066,"Single"]],[15072,15072],[15066,15066]]],[1562401797954,["GJX@GJXAIOU",[[-1,15065,"【Demo】"]],[15071,15071],[15065,15065]]],[1562401817284,["GJX@GJXAIOU",[[1,15068,"方法名称：【getInstance】"]],[15068,15068],[15086,15086]]],[1562401820327,["GJX@GJXAIOU",[[1,15085,"（）"]],[15085,15085],[15087,15087]]],[1562401822758,["GJX@GJXAIOU",[[-1,15085,"（）"]],[15087,15087],[15085,15085]]],[1562401824030,["GJX@GJXAIOU",[[1,15085,"()"]],[15085,15085],[15087,15087]]],[1562401825456,["GJX@GJXAIOU",[[1,15089,"- \n"]],[15088,15088],[15091,15091]]],[1562401829526,["GJX@GJXAIOU",[[1,15091,"参数哟啊"]],[15091,15091],[15095,15095]]],[1562401830815,["GJX@GJXAIOU",[[-1,15093,"哟啊"]],[15095,15095],[15093,15093]]],[1562401831869,["GJX@GJXAIOU",[[1,15093,"哟啊"]],[15093,15093],[15095,15095]]],[1562401832641,["GJX@GJXAIOU",[[-1,15093,"哟啊"]],[15095,15095],[15093,15093]]],[1562401857850,["GJX@GJXAIOU",[[1,15093,"要和类内私有化的构造方法所需要的参数一致：【int num】"]],[15093,15093],[15123,15123]]],[1562402048193,["GJX@GJXAIOU",[[1,15125,"\n"]],[15124,15124],[15125,15125]]],[1562402481962,["GJX@GJXAIOU",[[1,15124,"但是仍然需要判断一下当前程序中有没有意见"]],[15124,15124],[15144,15144]]],[1562402483344,["GJX@GJXAIOU",[[-1,15142,"意见"]],[15144,15144],[15142,15142]]],[1562402515127,["GJX@GJXAIOU",[[1,15142,"已经创建的类对象，如果没有就调用私有化的构造方法进行穿件"]],[15142,15142],[15170,15170]]],[1562402515764,["GJX@GJXAIOU",[[-1,15168,"穿件"]],[15170,15170],[15168,15168]]],[1562402517639,["GJX@GJXAIOU",[[1,15168,"创建，"]],[15168,15168],[15171,15171]]],[1562402530444,["GJX@GJXAIOU",[[1,15171,"否则不再创建；"]],[15171,15171],[15178,15178]]],[1562402539672,["GJX@GJXAIOU",[[1,15180,"\n"]],[15178,15178],[15179,15179]]],[1562402542806,["GJX@GJXAIOU",[[1,15179,"这里需要一个"]],[15179,15179],[15185,15185]]],[1562402547751,["GJX@GJXAIOU",[[1,15124,"\n"]],[15124,15124],[15125,15125]]],[1562402580662,["GJX@GJXAIOU",[[1,15186,"当前类的数据类型来保存"]],[15186,15186],[15197,15197]]],[1562402602390,["GJX@GJXAIOU",[[1,15197,"这个变量，该变量保存创建对象的地址"]],[15197,15197],[15214,15214]]],[1562402606036,["GJX@GJXAIOU",[[1,15207,"已经"]],[15207,15207],[15209,15209]]],[1562402609443,["GJX@GJXAIOU",[[1,15216,"。"]],[15216,15216],[15217,15217]]],[1562403042433,["GJX@GJXAIOU",[[1,15219,"\n"]],[15217,15217],[15218,15218]]],[1562403060213,["GJX@GJXAIOU",[[1,15218,"- 因为"]],[15218,15218],[15222,15222]]],[1562403063948,["GJX@GJXAIOU",[[1,15222,"局部变量"]],[15222,15222],[15226,15226]]],[1562403069743,["GJX@GJXAIOU",[[1,15222,"函数"]],[15222,15222],[15224,15224]]],[1562403102096,["GJX@GJXAIOU",[[1,15228,"的生存期只有在这个方法内部，第二次再次调用的时候，知情者"]],[15228,15228],[15256,15256]]],[1562403103705,["GJX@GJXAIOU",[[-1,15253,"知情者"]],[15256,15256],[15253,15253]]],[1562403109504,["GJX@GJXAIOU",[[1,15253,"之前的局部变量以及"]],[15253,15253],[15262,15262]]],[1562403110179,["GJX@GJXAIOU",[[-1,15260,"以及"]],[15262,15262],[15260,15260]]],[1562403117631,["GJX@GJXAIOU",[[1,15260,"已经销毁；"]],[15260,15260],[15265,15265]]],[1562403118338,["GJX@GJXAIOU",[[1,15266,"- \n"]],[15265,15265],[15268,15268]]],[1562403151850,["GJX@GJXAIOU",[[1,15268,"同时因为这是静态方法，不能使用非静态的成员变量，只能使用静态陈燕"]],[15268,15268],[15300,15300]]],[1562403152661,["GJX@GJXAIOU",[[-1,15298,"陈燕"]],[15300,15300],[15298,15298]]],[1562403159039,["GJX@GJXAIOU",[[1,15298,"成员变量；"]],[15298,15298],[15303,15303]]],[1562403746726,["GJX@GJXAIOU",[[-1,15304,"\n"],[1,15305,"`"]],[15304,15304],[15305,15305]]],[1562403747349,["GJX@GJXAIOU",[[1,15305,"``"]],[15305,15305],[15307,15307]]],[1562403747401,["GJX@GJXAIOU",[[1,15307,"language\n```\n"]],[15307,15307],[15307,15315]]],[1562403748422,["GJX@GJXAIOU",[[-1,15307,"language"],[1,15315,"j"]],[15307,15315],[15308,15308]]],[1562403748922,["GJX@GJXAIOU",[[1,15308,"ava"]],[15308,15308],[15311,15311]]],[1562403749106,["GJX@GJXAIOU",[[1,15312,"\n"]],[15311,15311],[15312,15312]]],[1562403750530,["GJX@GJXAIOU",[[1,15312,"package study;\n\nclass Demo{\n\tint num;\n\tprivate static Demo demo = null; //不能在类外更改，防止再次初始化\n\t\n\tprivate Demo(int num) {\n\t\tthis.num = num;\n\t}\n\t\n\tpublic void test() {\n\t\tSystem.out.println(this.getClass() + \"的test方法\");\n\t}\n\t\n\tpublic static Demo getInstance(int  num) {\n\t\t//判断是否已经创建类对象\t\t\n\t\tif (demo == null) {\n\t\t\tdemo = new Demo(num);\n\t\t}\n\t\t//私有化的构造方法可以在类内使用\n\t\treturn demo;\n\t}\n}\n\n\npublic class SingleDemo {\n\tpublic static void main(String[] args) {\n\t\t//Demo1 demo1 = new Demo1(3);\n\t\t\n\t\tDemo demo1 = Demo.getInstance(3);\n\t\tDemo demo2 = Demo.getInstance(4);\n\t\tSystem.out.println(demo1);\n\t\tSystem.out.println(demo2);\n\t}\n}"]],[15312,15312],[15922,15922]]],[1562403752919,["GJX@GJXAIOU",[[1,15304,"\n"]],[15304,15304],[15305,15305]]],[1562403939703,["GJX@GJXAIOU",[[-1,12102,"\n/**\n * class detail:\n * @author GJXAIOU\n * @since  2019年7月6日\n */\n"]],[12101,12167],[12101,12101]]],[1562403940186,["GJX@GJXAIOU",[[-1,12101,"\n"]],[12101,12101],[12100,12100]]]],null,"GJX@GJXAIOU"],["da74ddc6-3ce1-4789-beeb-6b12d331f23d",1568985927754,"## 一、复习：泛型\n\n- 为了解决数据类型一致化问题,避免没有意义的强制类型转换(放进什么数据，拿出来什么数据)，控制输入数据的格式；\n\n- 定义泛型泛型使用的格式：\n<大写字母> 一般使用E 或者 T ，仅仅是占位符；\n\n###  （一）泛型函数中使用\n格式：\n```java\n权限修饰符 <自定义泛型> 返回值类型(可以使用泛型) 函数名(形式参数列表“自定义泛型”) {\n  同样可以使用自定义泛型\n}\n```\n\n### （二）泛型在类中使用\n格式：\n```java\nclass 类名<自定义泛型> {\n  非静态的成员变量或者成员方法都可以使用类中定义的<自定义泛型>；  \n  静态方法不能使用类中自定义泛型，但是可以方法中自己定义泛型；  \n}\n```\n\n例如：`Arrays.sort(T[] t, Comparator<? super T> c)`\n\n###  （三）泛型在接口中使用\n格式：\n```java\ninterface 接口名<自定义泛型> {\n  //成员变量 缺省属性：public static final\n  //成员方法 缺省属性：abstract\n}\n```\n\n- 一个类遵从带有自定义泛型的接口有两种方式：\n  例如接口如下：\n      interface A<T> {\n          public void testA(T t);\n      }\n  \n1. 方式1：更加自由，在创建类对象时，才对泛型进行约束\n```java\nclass Test1<T> implements A<T> {\n  public void testA(T t) {\n      //实现方法\n  }\n}\n```\n\n2. 方式2 :遵从接口时，接口直接确定了泛型的具体类型 \n```java\nclass Test2 implements A<String> {\n  public void testA(String t) {\n      //实现方法\n  }\n}\n```\n\n- 泛型的上下限：\n`<? super T>`  表示数据类型是T对象或者其父类对象\n`<? extends T>`表示数据类型是T对象或者其子类对象\n  \n## Map\n  `Map<K, V> ` 键值对\n  - 两个实现类：\n    -  HashMap\n    -  TreeMap\n  \n  - 常见的方法：\n```java\nput(K key , V value);\nputAll(Map<? extends k, ? extends V> map)\n\nclear();\nremove(Object k);\n\nsize();\ncontainsKey(Object key);\ncontainsValue(Object Value);\n\nkeySet();\nvalues();\n\nget(Object k);\n```\n \n\n## 简单介绍了一个匿名内部类\n```java\n new Comparator<Student>() {\n      @Override   \n      public int compare(Student o1, Student o2) {\n          return o1.getAge() - o2.getAge();\n      }\n  }\n```\n\n\n## Map 补充\n\n```java\npackage study;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\n\t\tmap.put(\"MacBook Pro\", 22888);\n\t\tmap.put(\"iPhoneX\", 8398);\n\t\tmap.put(\"iPad Pro\", 5198);\n\t\t\n\t\tSystem.out.println(map);\n\t\t\n\t\t//第一种遍历方式：借助于keySet，通过key值拿到value值\n\t\tSet<String> set = map.keySet();\n\t\t\n\t\t//使用Set集合的Iterator迭代器\n\t\tIterator<String> it = set.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tString key = it.next(); //获取每一个Map中的key值\n\t\t\tint value = map.get(key);\n\t\t\t\n\t\t\tSystem.out.println(key + \"=\" + value);\n\t\t}\n\t\t//以上方法，不太合适，实际上获取的key值，再借助于Map里面的get方法，获取对应的Value\n\t\t//实际上并没有获取到完整的键值对\n\t\t\n\t\t\n\t\t\n\t\t//第二种方式：借助于values\n\t\tCollection<Integer> c = map.values();\n\t\t\n\t\tfor (Integer integer : c) {\n\t\t\tSystem.out.println(integer);\n\t\t}\n\t\t\n\t\t//以上方法也不适合，因为只能拿到value值，获取不到对应的key\n\t\t\n\t\t\n\t\t\n\t\t//在Java中万物皆对象，因此可以将键值对看成是一个类【必须会】\n\t\t/*\n\t \t将键值对，认为是一个对象，组成一个类，称之为Entry\n\t\t class Entry<K, V> {\n\t\t \tK key;\n\t\t \tV value;\n\t\t } \n\t\t 这里可以认为在Map集合中，保存的每个键值对都是一个Entry对象\n\t\t 将这些Entry对象获取并做成一个集合，然后对该集合进行遍历；\n\t\t entrySet();\n\t\t Map.Entry；Entry为Map的子接口，称为内部类\n\t\t */\n\t\tSet<Entry<String, Integer>> entrySet = map.entrySet();\n\t\t\n\t\tIterator<Entry<String, Integer>> it2 = entrySet.iterator();\n\t\t\n\t\twhile (it2.hasNext()) {\n\t\t\tSystem.out.println(it2.next());\n\t\t}\n\t}\n}\n\n```\n\n\n# 文件操作\n\n IO:\nInput Output\nread  write\n\n只考虑文件操作情况下：\n - 读取操作是：input read 从硬盘(存储设备) 到 内存\n - 写入操作是：output write 从内存 到 硬盘(存储设备)\n\n如何操作文件或者文件夹：\n创建，删除，剪切，复制，重命名，粘贴\n\nJava里万物皆对象,计算机世界里万物皆文件\n\n- Sun提供了一个File类，专门来操作【文件】和【文件夹】\n\n```java\n 如何创建一个File类对象：\nFile(String pathName);\n根据文件路径创建File类对象，可以是【绝对路径】可以是【相对路径】\n\nFile(String parent, String child);\n根据提供的父目录【文件夹】地址，和当前文件夹下的【子文件】或者【子文件夹】创建File类对象\n\nFile(File parent, String child);\n根据创建好的父目录的File类对象，和这个目录下的【子文件】或者【子文件夹】创建File类对象\n```\n【pathName】\n\\n \\t \\\\ 转义字符\n假如实际地址为：C:\\aaa\\bbb 如果在代码中使用 \"C:\\\\aaa\\\\bbb\" LOW\n\n**推荐使用 `/ `来区分路径,不使用反斜杠**\nJava是一个跨平台的语言\nJava提供了一个系统变量:File.separator 可以根据不同的系统换，自动填充文件分隔符\n示例：\n```java\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tFile file1 = new File(\"C:\\\\aaa\"); //采用Windows的分隔符\n\t\tFile file2 = new File(\"C:/aaa\"); //用在Linux和Windows通用的分隔符\n\t\tFile file3 = new File(\"C:\" + File.separator + \"aaa\"); //这里使用Java系统变量\n\t\t\n\t\tSystem.out.println(file1);\n\t\tSystem.out.println(file2);\n\t\tSystem.out.println(file3);\n\t\t\n\t\tFile file4 = new File(\"C:\\\\aaa\", \"1.txt\"); //父目录 子目录 \n\t\tSystem.out.println(file4); //返回的是路径\n\t\t\n\t\tFile file5 = new File(file1, \"1.txt\");\n\t\tSystem.out.println(file5);\n\t}\n}\n```\n\nFile 操作常见方法：\n```java\nisFile(); //是否为文件\nisDirectory(); //是否为目录\ncreateFile()\nrenameTo\ncopy\n```\n\n\n## 可以利用File类对象，创建文件或者文件夹\n\t\n- boolean createNewFile(); 创建文件\n\t使用File类对象，创建File类对象里面保存的地址 指定 的 普通文件\n\t返回值boolean: 创建成功返回true，创建失败返回false\n\t返回false失败原因:\n\t\t1. 该文件已经存在\n\t\t2. 操作路径非法，例如：文件指定所在文件夹不存在\n\t\t3. 操作的文件夹没有写入权限\n\t\t4. 硬盘坏了\n【要求】\n\t创建文件，必须带有文件后缀名！！！\n\t.java .class .doc .txt .xml .html .css .js .md .jsp \n\t.m .h .c .cpp .php .net .ppt .xls .exe .zip .rar .mp4\n\t.rmvb\n\t\n\t\n- boolean mkdir(); make direcotry 创建文件夹\n\t使用File类对象里面保存的文件夹地址，创建对应的文件夹\n\t- 返回值：boolean 创建成功返回true 创建失败返回false\n\t- 失败原因：\n\t\t1. 已经存在该文件夹\n\t\t2. 指定创建文件夹的父目录没有写入权限\n\t\t3. 要创建文件夹的父目录不存在\n- boolean mkdirs();\n\t使用File类对象里面保存的文件夹路径地址，创建指定文件夹，如果该路径中的【中间文件夹】不存在,把中间路径，同时创建\n\t- 返回值：boolean 创建成功返回true 创建失败返回false\n\t- 失败原因:\n\t\t1. 已经存在该文件夹\n\t\t2. 指定创建文件夹没有写入权限\n\tC:/aaa/ccc/ddd/eee/fff/ggg/hhh/iii/jjj\n\t\n- boolean renameTo(File dest);\n\t- 功能1：\n\t\t重命名！！！文件 或者 文件夹\n\t- 功能2：\n\t\t剪切，移动到另一个位置\n\t\n\t作业：\n\t测试，renameTo操作一个非空文件夹！！！\n\n程序测试：\n```java\nimport java.io.File;\nimport java.io.IOException;\n\npublic class Demo2 {\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\t//创建文件\n\t\tFile file1 = new File(\"C:/aaa/1.txt\");\n\t\t\n\t\tboolean ret = file1.createNewFile();\n\t\tSystem.out.println(\"文件创建成功了吗?\" + ret);\n\t\t\n//\t\tFile file2 = new File(\"C:/bb/1.txt\");\n//\t\tSystem.out.println(file2.createNewFile());\n\t\t\n\t\tFile file2 = new File(\"C:/aaa/bbb\");\n\t\tret = file2.mkdir();\n\t\tSystem.out.println(\"文件夹创建成功了吗?\" + ret);\n\t\t\n\t\tFile file3 = new File(\"C:/aaa/ccc/ddd\");\n\t\tret = file3.mkdir();\n\t\tSystem.out.println(\"文件夹创建成功了吗?\" + ret);\n\t\t\n\t\tFile file4 = new File(\"C:/aaa/ccc/ddd/eee/fff/ggg/hhh/iii/jjj\");\n\t\tret = file4.mkdirs();\n\t\tSystem.out.println(\"文件夹创建成功了吗?\" + ret);\n\t\t\n\t\t\n\t\tFile dest1 = new File(\"C:/aaa/2.txt\");\n\t\t//把C:/aaa/1.txt 重命名！！！\n\t\tret = file1.renameTo(dest1); //里面的参数为命名文件的新抽象路径名称，因为要求File类型，不能使用字符串路径；\n\t\tSystem.out.println(\"重命名成功了吗?\" + ret);\n\t\t\n\t\tret = file2.renameTo(new File(\"C:/aaa/ddd\")); //需要将路径创建为一个新的File类对象\n\t\tSystem.out.println(\"重命名文件夹成功了吗?\" + ret);\n\t\t\n\t\t//测试剪切功能\n\t\t//原地址要带有文件或者文件夹名，而且目标地址也有带有文件或者文件夹名\n\t\tFile txt3 = new File(\"C:/aaa/3.txt\");\n\t\tFile dest2 = new File(\"C:/Users/刘晓磊/Desktop/3.txt\");\n\t\t\n\t\tret = txt3.renameTo(dest2);\n\t\tSystem.out.println(\"剪切成功了吗?\" + ret);\n\t\t\n\t}\n}\n```\n\n- delete()\n \t\t删除文件或者文件夹，但是如果操作文件夹的话，**只能删除空文件**夹,成功返回true ，失败返回false; \t\t\n \t\t该删除操作不是把文件或者文件夹放入到回收站里，而是**直接从磁盘上抹去数据,该操作不可逆**。\n \t\n - deleteOnExit()\n \t\t当JVM虚拟机运行终止之后，删除指定的文件或者文件夹，而不是调用立即删除；\t\n \t- 用途：\n \t\t\t用于删除程序运行结束之后残留的缓存文件或者运行日志文件，节约硬盘空间；\n\n代码示例：\n```java\nimport java.io.File;\nimport java.util.Scanner;\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n\t\tFile file1 = new File(\"C:/aaa/1.txt\");\n\t\t\n\t\tSystem.out.println(\"删除成功了吗?\" + file1.delete());\n\t\t\n\t\tFile file2 = new File(\"C:/aaa/ddd\");\n\t\tSystem.out.println(\"删除成功了吗?\" + file2.delete());\n\t\t\n\t\tFile file3 = new File(\"C:/aaa/ccc\");\n\t\tSystem.out.println(\"删除成功了吗?\" + file3.delete()); //返回false\n\t\t\n\t\t// deleteOnExit()使用方法\n\t\tFile file4 = new File(\"C:/aaa/2.txt\");\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfile4.deleteOnExit();\n\t\tsc.nextLine();\n\t}\n}\n```\n\n * exists(); 判断指定的文件或者文件夹是否存在\n * isFile(); 判断指定的File是文件吗？\n * isDirectory(); 判断指定的File是文件夹吗？\n * isHidden(); 判断指定的File是隐藏文件吗？\n * isAbsolute();  判断创建File类对象使用的是绝对路径吗？\n 返回值全是boolean \n\n代码示例：\n```java\nimport java.io.File;\npublic class Demo4 {\n\tpublic static void main(String[] args) {\n\t\tFile file = new File(\"C:/aaa/1.txt\");\n\t\t\n\t\tSystem.out.println(\"这个文件或者文件夹存在吗?\" + file.exists());\n\t\tSystem.out.println(\"这个File类对象是一个文件类对象吗?\" + file.isFile());\n\t\t//这里使用了匿名对象，我一般称之为 一点到底！！！\n\t\tSystem.out.println(\"这个File类对象是一个文件夹类对象吗?\" + new File(\"C:/aaa\").isDirectory());\n\t\tSystem.out.println(\"这个File类对象是一个隐藏文件对象吗?\" + file.isHidden());\n\t\tSystem.out.println(\"创建File类对象使用了绝对路径吗?\" + file.isAbsolute());\n\t\tSystem.out.println(\"创建File类对象使用了绝对路径吗?\" + new File(\".\").isAbsolute()); //. 表示当前目录\t\t\n\t\n\t}\n}\n```\n  \t\n **以下方法和文件是否【存在无关】**！！！！！！\n  \t\n- getName(); 获取路径中的文件名或者文件夹名\n- getPath(); 获取File类对象里面保存的路径\n- getAbsolutePath(); 获取File对象里面保存路径对应的绝对路径\n- getParent(); 获取当前文件或者文件夹的父目录，如果没有返回null\n  \t\n- lashModified(); 文件最后的修改时间\n\tUNIX时间戳\n\t计算机元年到修改时间的秒数：\n\t1970年01月01日 00:00:00\n\t2017年12月08日 15:24:50\n\n- length(); 文件的大小(字节数)，如果文件不存在，或者是一个文件夹，返回0L\n\n代码示例：\n```java\nimport java.io.File;\nimport java.sql.Date;\nimport java.text.SimpleDateFormat;\npublic class Demo5 {\n\tpublic static void main(String[] args) {\n\t\tFile file = new File(\"E:/aaa/1.txt\");\n\t\n\t\tSystem.out.println(file.getName()); //1.txt\n\t\tSystem.out.println(file.getPath()); //E:/aaa/1.txt\n\t\tSystem.out.println(file.getAbsolutePath()); //E:/aaa/1.txt\n\t\tSystem.out.println(file.getParent()); //E:/aaa\n\t\t\n\t\tlong last = new File(\"C:/aaa/1.txt\").lastModified();\n\t\t\n\t\tDate date = new Date(last);\n\t\tSimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\tSystem.out.println(format.format(date));\n\t\t\n\t\t//System.out.println(last); //直接使用这个会得到秒数\n\t}\n}\n```\n其他方法：返回值  方法  含义\n- static File[]       listRoots(); \n \t获取当前计算机中所有的盘符，针对Windows操作系统\n \tLinux/UNIX没有区分盘符的概念 只有一个根目录 / \n \t\n- String[]        list();\n \t获取指定【文件夹】里面所有子文件和子文件，返回一个String类型的的数组\n \t\n- File[]    listFiles();\n \t获取指定【文件夹】里面所有子文件和子文件，返回一个File类型的的数组\n \t\n- 遍历一个文件夹：\n 文件夹:\n       文件夹1;\n       文件夹2;\n       文件夹3;\n………………\n文件:\n\t\t文件1;\n\t\t文件2;\n\t\t文件3;\n\t\t………………\n\n代码示例：\n```java\nimport java.io.File;\npublic class Demo6 {\n\tpublic static void main(String[] args) {\n\t\tFile[] roots = File.listRoots();\n\t\tfor (File file : roots) {\n\t\t\tSystem.out.println(file.getPath());\n\t\t}\n\t\tSystem.out.println(\"---------------------------------\");\n\t\t\n\t\tFile file = new File(\"C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\");\n\t\tString[] allFilePath = file.list();\n\t\t\n\t\tfor (String string : allFilePath) {\n\t\t\tSystem.out.println(string);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"---------------------------------\");\n\t\t\n\t\tFile[] allFileObject = file.listFiles();\n\t\tfor (File file2 : allFileObject) {\n\t\t\tSystem.out.println(file2);\n\t\t}\n\t\t\n\t}\n}\n```\n\n-  遍历一个文件夹：\n \t\t文件夹:\n \t\t\t文件夹1;\n \t\t\t文件夹2;\n \t\t\t文件夹3;\n \t\t\t………………\n \t\t文件:\n\t\t\t文件1;\n\t\t\t文件2;\n\t\t\t文件3;\n\t\t\t………………\n1. 首先利用listFiles()方法，获取指定文件夹下的所有子文件和子文件夹的File类对象数组\n2. 利用isFile或者isDirectory判断是否是文件或者是文件夹\n3. 区别对象，利用不同的函数 \n\n找出指定文件夹下的所有.java文件?   endWith() 和 isFile()\n\n```java\npublic class Demo7 {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\t\n\t\tfindAllJavaFile(\"C:\\\\Users\\\\刘晓磊\\\\Desktop\\\\test\");\n\t\t\n\t\tFile srcDir = new File(\"C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\");\n\t\t\n\t\tif (srcDir.exists() && srcDir.isDirectory()) {\n\t\t\t\n\t\t\tFile[] allFiles = srcDir.listFiles();\n\t\t\t\n\t\t\tshowAllFiles(allFiles);\n\t\t\tshowAllDirectories(allFiles);\n\t\t} \n\t}\n\t\n\tprivate static void showAllFiles(File[] allFiles) {\n\t\tSystem.out.println(\"普通文件:\");\n\t\tfor (File file : allFiles) {\n\t\t\tif (file.isFile()) {\n\t\t\t\tSystem.out.println(\"\\t\" + file.getName());\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static void showAllDirectories(File[] allFiles) {\n\t\tSystem.out.println(\"文件夹:\");\n\t\tfor (File file : allFiles) {\n\t\t\tif (file.isDirectory()) {\n\t\t\t\tSystem.out.println(\"\\t\" + file.getName());\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void findAllJavaFile(String pathname) throws FileNotFoundException {\n\t\t//如果给定的路径是一个null，无法使用\n\t\tif (null == pathname) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\t\t\n\t\tFile srcDir = new File(pathname);\n\t\t\n\t\t//判断文件是否存在，是否是一个文件夹\n\t\tif (!srcDir.exists()) { //srcDir.exists() == false\n\t\t\tthrow new FileNotFoundException();\n\t\t} else if (!srcDir.isDirectory()) { //srcDir.isDirectory() == false\n\t\t\t//运行时异常，不用再函数中声明\n\t\t\tthrow new RuntimeException(\"该文件不是一个文件夹\");\n\t\t}\n\t\t\t\n\t\tFile[] allFiles = srcDir.listFiles();\n\t\t\n\t\tfor (File file : allFiles) {\n\t\t\t//文件名后缀为.java 并且 是一个普通文件\n\t\t\tif (file.getName().endsWith(\".java\") && file.isFile()) {\n\t\t\t\tSystem.out.println(file.getName());\n\t\t\t}\n\t\t}\n\t\n\t} \n}\n\n\n```\n\n- 归档文件\n\n如果是普通文件，按照文件的后缀名创建对应的全大写文件夹，把文件剪切进去\n    特殊情况，如果是没有文件后缀名的未知普通文件，就放入到 others 文件夹；\n如果是文件夹，创建 subDir 文件夹，剪切进去；\n\n\n  - 思路：\n    - 1.获取指定的文件夹路径，进行判断；\n    - 2.获取这个文件夹下面的所有子文件和子文件夹的 File[]类对象；\n    - 3.遍历这个 File[] 类型的数组，按照文件和文件夹进行区别操作；\n         - 3.1.如果是文件：\n           - 首先获取这个文件的文件后缀；\n           - 然后创建以这个文件后缀名全大写的文件夹；\n           - 最后移动该文件到这个文件夹；\n           - 注：如果一个文件没有后缀名，就放入到 Others 目录下；\n         - 3.2.如果是文件夹：\n           - 首先创建 subDir 目录；\n           - 移动该文件夹放入到 subDir 里面；\n\n程序代码：\n```java\npackage study;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\npublic class Demo1 {\n\tpublic static void main(String[] args)throws NullPointerException, IOException {\n\t\tachieveDirectoryAtPath(\"C:/test\");\n\t}\n\t\n\tpublic static void achieveDirectoryAtPath(String path) throws NullPointerException, IOException{\n\t\t//1.判断路径\n\t\tif (null == path) {\n\t\t\tthrow new NullPointerException(\"地址不能为null\");\n\t\t}\n\t\t\n\t\t//2.创建指定地址对应的File类对象\n\t\tFile file = new File(path);\n\t\t\n\t\t//3.判断这个是不是一个文件夹，并且是否存在\n\t\tif ((!file.exists() || !file.isDirectory())) {\n\t\t\t//等价于：file.exists() == false || file.isDirectory() == false;\n\t\t\tthrow new FileNotFoundException(\"没有指定文件\");\n\t\t}\n\t\t\n\t\t//在归档之前判断是否进行过归档操作，如果有则不再进行归档\n\t\tif (new File(file, \"file.lock\").exists()) {\n\t\t\tSystem.out.println(\"归档已完成\");\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\t//4.获取指定文件夹下面的所有子文件和子文件夹的File类对象数组\n\t\tFile[] allFiles = file.listFiles();\n\t\t\n\t\t//5.遍历该File数组，判断是文件还是文件夹，区别对待\n\t\tfor (File fileItem : allFiles) {\n\t\t\tif (fileItem.isFile()) {\n\t\t\t\t//文件操作file是当前要归档的文件夹，filename是要处理的文件名字\n\t\t\t\tachieveFile(file,fileItem.getName());\n\t\t\t}else {\n\t\t\t\t//文件夹操作\n\t\t\t\tachieveDri(file, fileItem.getName());\n\t\t\t}\n\t\t}//for\t\n\t\t\n\t\t//6.归档完成，上锁，防止再次归档\n\t\tFile lockFile = new File(file, \"file.lock\");\n\t\tlockFile.createNewFile();\n\t}\n\t\n\n\t\n\tprivate static void achieveFile(File file, String fileName) {\n\t\t//1.找到对应的文件后缀名\n\t\tint index = -1;\n\t\tString dirToCreate = null;\n\t\tFile srcFile = null; //原地址 \n\t\tFile dstFile = null;\n\t\t\n\t\t//2.获取要创建的文件夹路径的String类型字符串\n\t\t//判断文件是否存在文件后缀名，如果没有'.'则是不存在，有点但是点后面没有内容也是没有后缀名\n\t\tif ((index = fileName.lastIndexOf('.')) != -1 && fileName.substring(index + 1).length() !=0) { //不能包括index,因此加1\n\t\t\t/*上面的If语句等价于下面\n\t\t\t * index = fileName.lastIndexOf('.');\n\t\t\tif (index != -1) {\t\t\t\t\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\t /*\n\t\t\tString parent = file.getAbsolutePath();\n\t\t\tString dirName = fileName.substring(index + 1).toUpperCase();\n\t\t\tdirToCreate = parent + File.separator + dirName;\n\t\t\t*/\n\t\t\t//上面代码的简化版\n\t\t\t/*\n\t\t\t * File.separator作用：这是File类提供的一个更加运行环境而决定的文件路径分隔符，在Windows中是\\,\n\t\t\t * 在Linux和Unix中是/，这样写的好处是可以让代码的通用性和可移植性更好\n\t\t\t */\n\t\t\tdirToCreate =file.getAbsolutePath() + file.separator + fileName.substring(index + 1).toUpperCase();\t\t\t\n\t\t}else {\n\t\t\tdirToCreate = file.getAbsolutePath() + file.separator + \"other\";\n\t\t}\n\t\t\n\t\tnew File(dirToCreate).mkdir();  //创建File匿名对象，调用mkdir（）\n\t\t\n\t\tsrcFile = new File(file, fileName);\n\t\tdstFile = new File(dirToCreate,fileName);\n\t\t\n\t\tsrcFile.renameTo(dstFile);\n\t}\n\t \n\tprivate static void achieveDri(File file, String dirName) {\n\t\t//创建subDir\n\t\tFile subDir = new File(file, \"subDir\");\n\t\tsubDir.mkdir();\n\t\t\n\t\tFile srcFile = new File(file, dirName);\n\t\tFile dstFile = new File(subDir, dirName);\n\t\t\n\t\tsrcFile.renameTo(dstFile);\n\t}\n}\n```\n\n## 单例\n目的：使整个程序的运行过程中，有且只有一个当前类的类对象存在；\n\n方案一：在整个程序的运行过程中，有且只调用一个构造方法（相当于仅仅实例化一次）\n缺点：第三方调用者不知道这个规定，可以通过简单的 new 关键字进行调用；\n同时如果使用 private 关键字修饰构造函数，则构造方法在类外无法使用且类外没有对象，则所有和对象相关的方法均不能使用，需要不通过对象就可以调用方法：\n使用 static 关键字获取或者创建类对象\n- 该方法提供给类外使用，因此权限修饰符为【public】\n- 调用时候不能通过类对象进行调用，需要类名进行调用，使用【static】关键字\n- 该方法是获取当前类的类对象，所以返回值应该是当前类对象类型\n- 方法名称：【getInstance()】\n- 参数要和类内私有化的构造方法所需要的参数一致：【int num】\n\n但是仍然需要判断一下当前程序中有没有已经创建的类对象，如果没有就调用私有化的构造方法进行创建，否则不再创建；\n这里需要一个当前类的数据类型来保存这个变量，该变量保存已经创建对象的地址。\n- 因为函数局部变量的生存期只有在这个方法内部，第二次再次调用的时候，之前的局部变量已经销毁；\n- 同时因为这是静态方法，不能使用非静态的成员变量，只能使用静态成员变量；\n\n```java\npackage study;\n\nclass Demo{\n\tint num;\n\tprivate static Demo demo = null; //不能在类外更改，防止再次初始化\n\t\n\tprivate Demo(int num) {\n\t\tthis.num = num;\n\t}\n\t\n\tpublic void test() {\n\t\tSystem.out.println(this.getClass() + \"的test方法\");\n\t}\n\t\n\tpublic static Demo getInstance(int  num) {\n\t\t//判断是否已经创建类对象\t\t\n\t\tif (demo == null) {\n\t\t\tdemo = new Demo(num);\n\t\t}\n\t\t//私有化的构造方法可以在类内使用\n\t\treturn demo;\n\t}\n}\n\n\npublic class SingleDemo {\n\tpublic static void main(String[] args) {\n\t\t//Demo1 demo1 = new Demo1(3);\n\t\t\n\t\tDemo demo1 = Demo.getInstance(3);\n\t\tDemo demo2 = Demo.getInstance(4);\n\t\tSystem.out.println(demo1);\n\t\tSystem.out.println(demo2);\n\t}\n}\n```\n",[[1568985879576,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1568985881184,["GJX@GJXAIOU",[[1,0,"JavaEEDay19-文件操作"]],[0,0],[16,16]]],[1568985883409,["GJX@GJXAIOU",[[1,0,"# "]],[0,0],[18,18]]]],null,"GJX@GJXAIOU"]]}