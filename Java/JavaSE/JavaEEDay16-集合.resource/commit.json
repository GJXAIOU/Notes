{"compress":true,"commitItems":[["660ab8b1-41d0-4331-af58-621c347b0476",1561689877081,"",[[1561689837295,["GJX@GJXAIOU",[[1,0,"# JavaEEDay16-集合\n\n\n\n"]],[0,0],[19,19]]],[1561689875502,["GJX@GJXAIOU",[[1,20,"\n"]],[18,18],[19,19]]],[1561689876313,["GJX@GJXAIOU",[[1,19,"- "]],[19,19],[21,21]]],[1561689877410,["GJX@GJXAIOU",[[1,21,"数据"]],[21,21],[23,23]]],[1561689877991,["GJX@GJXAIOU",[[-1,21,"数据"]],[23,23],[21,21]]],[1561689903050,["GJX@GJXAIOU",[[1,21,"数组：用于 保存大量数据采取的方式；"]],[21,21],[39,39]]],[1561689903551,["GJX@GJXAIOU",[[1,40,"- \n"]],[39,39],[42,42]]],[1561689908577,["GJX@GJXAIOU",[[-1,26," "]],[27,27],[26,26]]],[1561689910239,["GJX@GJXAIOU",[[-1,39,"- "]],[41,41],[39,39]]],[1561689925210,["GJX@GJXAIOU",[[1,39,"  - 可以保存的数据类型："]],[39,39],[53,53]]],[1561689927874,["GJX@GJXAIOU",[[1,54,"  - \n"]],[53,53],[58,58]]],[1561689929407,["GJX@GJXAIOU",[[1,56,"  "]],[58,58],[60,60]]],[1561689933785,["GJX@GJXAIOU",[[1,60,"8大"]],[60,60],[62,62]]],[1561689933807,["GJX@GJXAIOU",[[1,61," "]],[62,62],[63,63]]],[1561689936443,["GJX@GJXAIOU",[[1,63,"基本"]],[63,63],[65,65]]],[1561689951864,["GJX@GJXAIOU",[[1,65,"数据类型 byte/short/int /long/fla"]],[65,65],[94,94]]],[1561689952416,["GJX@GJXAIOU",[[-1,93,"a"]],[94,94],[93,93]]],[1561689959480,["GJX@GJXAIOU",[[1,93,"oat/double/cahr"]],[93,93],[108,108]]],[1561689960928,["GJX@GJXAIOU",[[-1,105,"ahr"]],[108,108],[105,105]]],[1561689965424,["GJX@GJXAIOU",[[1,105,"har/boolean"]],[105,105],[116,116]]],[1561689966530,["GJX@GJXAIOU",[[1,117,"    - \n"]],[116,116],[123,123]]],[1561689986146,["GJX@GJXAIOU",[[1,123,"自定义类对象：例如 Student Player"]],[123,123],[147,147]]],[1561689987120,["GJX@GJXAIOU",[[1,148,"    - \n"]],[147,147],[154,154]]],[1561689993780,["GJX@GJXAIOU",[[1,154,"Java中"]],[154,154],[159,159]]],[1561689993803,["GJX@GJXAIOU",[[1,158," "]],[159,159],[160,160]]],[1561689995947,["GJX@GJXAIOU",[[1,160,"的类"]],[160,160],[162,162]]],[1561689997845,["GJX@GJXAIOU",[[1,162,"对象"]],[162,162],[164,164]]],[1561690004807,["GJX@GJXAIOU",[[1,165,"    - \n"]],[164,164],[171,171]]],[1561690006584,["GJX@GJXAIOU",[[-1,167,"  "]],[171,171],[169,169]]],[1561690009690,["GJX@GJXAIOU",[[1,169,"局限性："]],[169,169],[173,173]]],[1561690010798,["GJX@GJXAIOU",[[1,174,"  - \n"]],[173,173],[178,178]]],[1561690011985,["GJX@GJXAIOU",[[1,176,"  "]],[178,178],[180,180]]],[1561690022521,["GJX@GJXAIOU",[[1,180,"只能保存一种数据类型的数据；"]],[180,180],[194,194]]],[1561690023126,["GJX@GJXAIOU",[[1,195,"    - \n"]],[194,194],[201,201]]],[1561690136658,["GJX@GJXAIOU",[[1,201,"数组的元素个数可"]],[201,201],[209,209]]],[1561690138376,["GJX@GJXAIOU",[[-1,206,"个数可"]],[209,209],[206,206]]],[1561690143781,["GJX@GJXAIOU",[[1,206,"个数创建时间"]],[206,206],[212,212]]],[1561690144663,["GJX@GJXAIOU",[[-1,211,"间"]],[212,212],[211,211]]],[1561690206192,["GJX@GJXAIOU",[[1,211,"是确定的，无法直接对元素个数进行修改；"]],[211,211],[230,230]]],[1561690206647,["GJX@GJXAIOU",[[1,231,"    - \n"]],[230,230],[237,237]]],[1561690210257,["GJX@GJXAIOU",[[1,237,"数组藜麦"]],[237,237],[241,241]]],[1561690210926,["GJX@GJXAIOU",[[-1,239,"藜麦"]],[241,241],[239,239]]],[1561690235985,["GJX@GJXAIOU",[[1,239,"里面保存的元素内容空间是确定的"]],[239,239],[254,254]]],[1561690238151,["GJX@GJXAIOU",[[-1,251,"确定的"]],[254,254],[251,251]]],[1561690240392,["GJX@GJXAIOU",[[1,251,"连续的；"]],[251,251],[255,255]]],[1561690244503,["GJX@GJXAIOU",[[1,256,"    - \n"]],[255,255],[262,262]]],[1561690246850,["GJX@GJXAIOU",[[-1,259," - "]],[262,262],[259,259]]],[1561690247726,["GJX@GJXAIOU",[[-1,256,"   "],[1,259,"\n"]],[259,259],[257,257]]],[1561690254165,["GJX@GJXAIOU",[[1,257,"- 问题：如果想"]],[257,257],[265,265]]],[1561690258642,["GJX@GJXAIOU",[[-1,264,"想"]],[265,265],[264,264]]],[1561690267690,["GJX@GJXAIOU",[[1,264,"需要保存任意类型的数组"]],[264,264],[275,275]]],[1561690272402,["GJX@GJXAIOU",[[1,273,"一个"]],[273,273],[275,275]]],[1561690286581,["GJX@GJXAIOU",[[1,277,"，所有的数据类型都可以在这个数组总"]],[277,277],[294,294]]],[1561690287312,["GJX@GJXAIOU",[[-1,293,"总"]],[294,294],[293,293]]],[1561690291457,["GJX@GJXAIOU",[[1,293,"中保存；"]],[293,293],[297,297]]],[1561690291890,["GJX@GJXAIOU",[[1,298,"- \n"]],[297,297],[300,300]]],[1561690295486,["GJX@GJXAIOU",[[1,300,"答案：使用"]],[300,300],[305,305]]],[1561690300469,["GJX@GJXAIOU",[[1,305,"Object"]],[305,305],[311,311]]],[1561690300493,["GJX@GJXAIOU",[[1,305," "]],[311,311],[312,312]]],[1561690302386,["GJX@GJXAIOU",[[1,312,"类"]],[312,312],[313,313]]],[1561690302410,["GJX@GJXAIOU",[[1,312," "]],[313,313],[314,314]]],[1561690303480,["GJX@GJXAIOU",[[-1,313,"类"]],[314,314],[313,313]]],[1561690311412,["GJX@GJXAIOU",[[1,313,"数据类型，因为Obje"]],[313,313],[324,324]]],[1561690311437,["GJX@GJXAIOU",[[1,320," "]],[324,324],[325,325]]],[1561690318505,["GJX@GJXAIOU",[[1,325,"ct 是Java"]],[325,325],[333,333]]],[1561690318530,["GJX@GJXAIOU",[[1,329," "]],[333,333],[334,334]]],[1561690319989,["GJX@GJXAIOU",[[1,334,"中"]],[334,334],[335,335]]],[1561690320012,["GJX@GJXAIOU",[[1,334," "]],[335,335],[336,336]]],[1561690321537,["GJX@GJXAIOU",[[1,336,"多有的"]],[336,336],[339,339]]],[1561690322255,["GJX@GJXAIOU",[[-1,336,"多有的"]],[339,339],[336,336]]],[1561690323715,["GJX@GJXAIOU",[[1,336,"多有"]],[336,336],[338,338]]],[1561690324250,["GJX@GJXAIOU",[[-1,336,"多有"]],[338,338],[336,336]]],[1561690339827,["GJX@GJXAIOU",[[1,336,"所有的类的直接父类或者间接父类 基类、"]],[336,336],[355,355]]],[1561690340383,["GJX@GJXAIOU",[[-1,354,"、"]],[355,355],[354,354]]],[1561690350601,["GJX@GJXAIOU",[[1,354,"/根类；"]],[354,354],[358,358]]],[1561690354657,["GJX@GJXAIOU",[[1,359,"- \n"]],[358,358],[361,361]]],[1561690354768,["GJX@GJXAIOU",[[-1,359,"- "]],[361,361],[360,360]]],[1561690356978,["GJX@GJXAIOU",[[-1,360,"\n"],[1,361,"代码"]],[360,360],[362,362]]],[1561690360017,["GJX@GJXAIOU",[[1,362,"示例："]],[362,362],[365,365]]],[1561690360410,["GJX@GJXAIOU",[[1,365,"\n\n"]],[365,365],[366,366]]],[1561690361400,["GJX@GJXAIOU",[[-1,366,"\n"],[1,367,"`"]],[366,366],[367,367]]],[1561690361761,["GJX@GJXAIOU",[[1,367,"``"]],[367,367],[369,369]]],[1561690361787,["GJX@GJXAIOU",[[1,369,"language\n```\n"]],[369,369],[369,377]]],[1561690362724,["GJX@GJXAIOU",[[-1,369,"language"],[1,377,"j"]],[369,377],[370,370]]],[1561690362970,["GJX@GJXAIOU",[[1,370,"av"]],[370,370],[372,372]]],[1561690363099,["GJX@GJXAIOU",[[1,373,"\n"]],[372,372],[373,373]]],[1561690363136,["GJX@GJXAIOU",[[1,373,"a"]],[373,373],[374,374]]],[1561690363827,["GJX@GJXAIOU",[[-1,373,"a"]],[374,374],[373,373]]],[1561690363927,["GJX@GJXAIOU",[[-1,373,"\n"]],[373,373],[372,372]]],[1561690364251,["GJX@GJXAIOU",[[1,372,"a"]],[372,372],[373,373]]],[1561690365721,["GJX@GJXAIOU",[[1,374,"\n"]],[373,373],[374,374]]],[1561690955367,["GJX@GJXAIOU",[[1,374,"/**\n * \n */\npackage study;\nimport java.util.Arrays;\n\n\n/**\n * class detail:\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\t//创建一个数据类型为Object数组，元素个数为5\n\t\t\n\t\tObject[] arr = new Object[5];\n\t\tarr[0] = \"hello\";\n\t\tarr[1] = 23;\n\t\tarr[2] = 2.3f;\n\t\tarr[3] = new Demo1();\n\t\tarr[4] = true;\n\t\t\n\tSystem.out.println(Arrays.toString(arr));\n\t}\n}\n"]],[374,374],[765,765]]],[1561690958168,["GJX@GJXAIOU",[[-1,374,"/**\n * \n */"]],[374,385],[374,374]]],[1561690961984,["GJX@GJXAIOU",[[1,759,"\n"]],[758,758],[759,759]]],[1561690962490,["GJX@GJXAIOU",[[-1,759,"\n"],[1,760,"c"]],[759,759],[760,760]]],[1561690962840,["GJX@GJXAIOU",[[1,760,"hegn"]],[760,760],[764,764]]],[1561690963548,["GJX@GJXAIOU",[[-1,760,"hegn"]],[764,764],[760,760]]],[1561690963815,["GJX@GJXAIOU",[[-1,759,"c"],[1,760,"\n"]],[760,760],[759,759]]],[1561690969157,["GJX@GJXAIOU",[[-1,759,"\n"],[1,760,"程序"]],[759,759],[761,761]]],[1561690972050,["GJX@GJXAIOU",[[1,761,"输出结果："]],[761,761],[766,766]]],[1561690972359,["GJX@GJXAIOU",[[1,766,"\n\n"]],[766,766],[767,767]]],[1561690973690,["GJX@GJXAIOU",[[-1,767,"\n"],[1,768,"`"]],[767,767],[768,768]]],[1561690973847,["GJX@GJXAIOU",[[1,768,"`"]],[768,768],[769,769]]],[1561690981554,["GJX@GJXAIOU",[[1,768,"[hello, 23, 2.3, study.Demo1@21588809, true]"]],[768,768],[812,812]]],[1561690984864,["GJX@GJXAIOU",[[1,813,"\n\n"]],[813,813],[814,814]]],[1561690984969,["GJX@GJXAIOU",[[1,815,"\n"]],[814,814],[815,815]]],[1561691423318,["GJX@GJXAIOU",[[1,816,"\n"]],[813,813],[814,814]]],[1561691423454,["GJX@GJXAIOU",[[1,817,"\n"]],[814,814],[815,815]]],[1561691423687,["GJX@GJXAIOU",[[1,818,"\n"]],[815,815],[816,816]]],[1561691423798,["GJX@GJXAIOU",[[1,819,"\n"]],[816,816],[817,817]]],[1561691426921,["GJX@GJXAIOU",[[1,817,"## jihe"]],[817,817],[824,824]]],[1561691428328,["GJX@GJXAIOU",[[-1,820,"jihe"]],[824,824],[820,820]]],[1561691429363,["GJX@GJXAIOU",[[1,820,"集合"]],[820,820],[822,822]]],[1561691430023,["GJX@GJXAIOU",[[1,825,"\n"]],[822,822],[823,823]]],[1561691430414,["GJX@GJXAIOU",[[1,826,"\n"]],[823,823],[824,824]]],[1561691434218,["GJX@GJXAIOU",[[1,824,"概念“"]],[824,824],[827,827]]],[1561691435446,["GJX@GJXAIOU",[[-1,826,"“"]],[827,827],[826,826]]],[1561691436994,["GJX@GJXAIOU",[[1,826,"：接口"]],[826,826],[829,829]]],[1561691438215,["GJX@GJXAIOU",[[-1,827,"接口"]],[829,829],[827,827]]],[1561691445987,["GJX@GJXAIOU",[[1,827,"集合就是存储对象的【同期"]],[827,827],[839,839]]],[1561691446609,["GJX@GJXAIOU",[[-1,837,"同期"]],[839,839],[837,837]]],[1561691448666,["GJX@GJXAIOU",[[1,837,"容器】"]],[837,837],[840,840]]],[1561691449430,["GJX@GJXAIOU",[[1,843,"\n"]],[840,840],[841,841]]],[1561691463765,["GJX@GJXAIOU",[[1,841,"主要介绍：collection"]],[841,841],[856,856]]],[1561691468367,["GJX@GJXAIOU",[[-1,846,"c"]],[847,847],[846,846]]],[1561691469483,["GJX@GJXAIOU",[[1,846,"C"]],[846,846],[847,847]]],[1561691484394,["GJX@GJXAIOU",[[1,856,"、List、Set接口"]],[856,856],[867,867]]],[1561691484418,["GJX@GJXAIOU",[[1,865," "]],[867,867],[868,868]]],[1561691484870,["GJX@GJXAIOU",[[1,871,"\n"]],[868,868],[869,869]]],[1561691486806,["GJX@GJXAIOU",[[1,869,"- "]],[869,869],[871,871]]],[1561691502299,["GJX@GJXAIOU",[[1,871,"Colle餐厅"]],[871,871],[878,878]]],[1561691502324,["GJX@GJXAIOU",[[1,876," "]],[878,878],[879,879]]],[1561691504877,["GJX@GJXAIOU",[[-1,871,"Colle 餐厅"]],[879,879],[871,871]]],[1561691530753,["GJX@GJXAIOU",[[1,871,"Collection： 集合的总【接口】，规定了很多方法，要求所有的"]],[871,871],[905,905]]],[1561691532656,["GJX@GJXAIOU",[[-1,902,"所有的"]],[905,905],[902,902]]],[1561691543810,["GJX@GJXAIOU",[[1,902,"所有【遵从】该结构"]],[902,902],[911,911]]],[1561691544672,["GJX@GJXAIOU",[[-1,909,"结构"]],[911,911],[909,909]]],[1561691552937,["GJX@GJXAIOU",[[1,909,"接口的类，全部实现；"]],[909,909],[919,919]]],[1561691553285,["GJX@GJXAIOU",[[1,920,"- \n"]],[919,919],[922,922]]],[1561691554301,["GJX@GJXAIOU",[[1,920,"  "]],[922,922],[924,924]]],[1561691567240,["GJX@GJXAIOU",[[1,924,"List： 接口，如果遵循了"]],[924,924],[938,938]]],[1561691569436,["GJX@GJXAIOU",[[-1,935,"遵循了"]],[938,938],[935,935]]],[1561691573705,["GJX@GJXAIOU",[[1,935,"【遵循【"]],[935,935],[939,939]]],[1561691574414,["GJX@GJXAIOU",[[-1,938,"【"]],[939,939],[938,938]]],[1561691579320,["GJX@GJXAIOU",[[1,938,"】了List"]],[938,938],[944,944]]],[1561691579345,["GJX@GJXAIOU",[[1,940," "]],[944,944],[945,945]]],[1561691580445,["GJX@GJXAIOU",[[1,945,"接口"]],[945,945],[947,947]]],[1561691580469,["GJX@GJXAIOU",[[1,945," "]],[947,947],[948,948]]],[1561691606288,["GJX@GJXAIOU",[[1,948,"，要求实现所有List"]],[948,948],[959,959]]],[1561691606313,["GJX@GJXAIOU",[[1,955," "]],[959,959],[960,960]]],[1561691607018,["GJX@GJXAIOU",[[1,960,"中"]],[960,960],[961,961]]],[1561691607042,["GJX@GJXAIOU",[[1,960," "]],[961,961],[962,962]]],[1561691611996,["GJX@GJXAIOU",[[1,962,"的方法，具有List"]],[962,962],[972,972]]],[1561691612020,["GJX@GJXAIOU",[[1,968," "]],[972,972],[973,973]]],[1561691613754,["GJX@GJXAIOU",[[1,973,"集合"]],[973,973],[975,975]]],[1561691613778,["GJX@GJXAIOU",[[1,973," "]],[975,975],[976,976]]],[1561691616516,["GJX@GJXAIOU",[[1,976,"的特征"]],[976,976],[979,979]]],[1561691621721,["GJX@GJXAIOU",[[1,979,"：****"]],[979,979],[982,982]]],[1561691629035,["GJX@GJXAIOU",[[1,982,"有序、可重复"]],[982,982],[988,988]]],[1561691912661,["GJX@GJXAIOU",[[1,991,"  - \n"]],[990,990],[995,995]]],[1561691923573,["GJX@GJXAIOU",[[1,995,"Set：接口，如果【遵循】了 List 接口，要求实现所有 List 中的方法，具有 List 集合的特征：**有序、可重复**\n"]],[995,995],[1060,1060]]],[1561691925485,["GJX@GJXAIOU",[[1,1063,"\n"]],[1060,1060],[1061,1061]]],[1561691925598,["GJX@GJXAIOU",[[1,1064,"\n"]],[1061,1061],[1062,1062]]],[1561691925687,["GJX@GJXAIOU",[[1,1065,"\n"]],[1062,1062],[1063,1063]]],[1561691925805,["GJX@GJXAIOU",[[1,1066,"\n"]],[1063,1063],[1064,1064]]],[1561691925934,["GJX@GJXAIOU",[[1,1067,"\n"]],[1064,1064],[1065,1065]]],[1561691926061,["GJX@GJXAIOU",[[1,1068,"\n"]],[1065,1065],[1066,1066]]],[1561691926181,["GJX@GJXAIOU",[[1,1069,"\n"]],[1066,1066],[1067,1067]]],[1561691926312,["GJX@GJXAIOU",[[1,1070,"\n"]],[1067,1067],[1068,1068]]],[1561691926436,["GJX@GJXAIOU",[[1,1071,"\n"]],[1068,1068],[1069,1069]]],[1561691926565,["GJX@GJXAIOU",[[1,1072,"\n"]],[1069,1069],[1070,1070]]],[1561691926704,["GJX@GJXAIOU",[[1,1073,"\n"]],[1070,1070],[1071,1071]]],[1561691926829,["GJX@GJXAIOU",[[1,1074,"\n"]],[1071,1071],[1072,1072]]],[1561691926951,["GJX@GJXAIOU",[[1,1075,"\n"]],[1072,1072],[1073,1073]]],[1561691927085,["GJX@GJXAIOU",[[1,1076,"\n"]],[1073,1073],[1074,1074]]],[1561691927204,["GJX@GJXAIOU",[[1,1077,"\n"]],[1074,1074],[1075,1075]]],[1561691931004,["GJX@GJXAIOU",[[-1,1051,"有序、可重复"]],[1057,1057],[1051,1051]]],[1561691938698,["GJX@GJXAIOU",[[1,1051,"无序，不可重复"]],[1051,1051],[1058,1058]]],[1561691943077,["GJX@GJXAIOU",[[1,1061,"  - \n"]],[1060,1060],[1065,1065]]],[1561691943236,["GJX@GJXAIOU",[[-1,1061,"  - "]],[1065,1065],[1062,1062]]],[1561691950305,["GJX@GJXAIOU",[[1,1062,"首先从Collection"]],[1062,1062],[1075,1075]]],[1561691950329,["GJX@GJXAIOU",[[1,1065," "]],[1075,1075],[1076,1076]]],[1561691951632,["GJX@GJXAIOU",[[1,1076,"开始"]],[1076,1076],[1078,1078]]],[1561691951657,["GJX@GJXAIOU",[[1,1076," "]],[1078,1078],[1079,1079]]],[1561691961266,["GJX@GJXAIOU",[[1,1079,"学习，学习之后接口"]],[1079,1079],[1088,1088]]],[1561691962052,["GJX@GJXAIOU",[[-1,1086,"接口"]],[1088,1088],[1086,1086]]],[1561691968208,["GJX@GJXAIOU",[[1,1086,"基本上行LIst"]],[1086,1086],[1094,1094]]],[1561691968233,["GJX@GJXAIOU",[[1,1090," "]],[1094,1094],[1095,1095]]],[1561691969709,["GJX@GJXAIOU",[[-1,1092,"Ist"]],[1095,1095],[1092,1092]]],[1561691974784,["GJX@GJXAIOU",[[1,1092,"ist和"]],[1092,1092],[1096,1096]]],[1561691974808,["GJX@GJXAIOU",[[1,1095," "]],[1096,1096],[1097,1097]]],[1561691978568,["GJX@GJXAIOU",[[1,1097,"Set"]],[1097,1097],[1100,1100]]],[1561691978593,["GJX@GJXAIOU",[[1,1097," "]],[1100,1100],[1101,1101]]],[1561691980902,["GJX@GJXAIOU",[[1,1101,"jiu"]],[1101,1101],[1104,1104]]],[1561691981461,["GJX@GJXAIOU",[[-1,1101,"jiu"]],[1104,1104],[1101,1101]]],[1561691983176,["GJX@GJXAIOU",[[1,1101,"就是"]],[1101,1101],[1103,1103]]],[1561691983200,["GJX@GJXAIOU",[[1,1101," "]],[1103,1103],[1104,1104]]],[1561691991690,["GJX@GJXAIOU",[[1,1104,"在此基础上添加操作"]],[1104,1104],[1113,1113]]],[1561691993123,["GJX@GJXAIOU",[[1,1131,"\n"]],[1113,1113],[1114,1114]]],[1561691993253,["GJX@GJXAIOU",[[1,1132,"\n"]],[1114,1114],[1115,1115]]],[1561691998073,["GJX@GJXAIOU",[[1,1115,"- 增加"]],[1115,1115],[1119,1119]]],[1561691998381,["GJX@GJXAIOU",[[-1,1118,"加"]],[1119,1119],[1118,1118]]],[1561691999111,["GJX@GJXAIOU",[[1,1118,"："]],[1118,1118],[1119,1119]]],[1561691999646,["GJX@GJXAIOU",[[1,1120,"- \n"]],[1119,1119],[1122,1122]]],[1561692000454,["GJX@GJXAIOU",[[1,1120,"  "]],[1122,1122],[1124,1124]]],[1561692005102,["GJX@GJXAIOU",[[1,1124,"add()"]],[1124,1124],[1129,1129]]],[1561692007953,["GJX@GJXAIOU",[[1,1128,"Objue"]],[1128,1128],[1133,1133]]],[1561692008493,["GJX@GJXAIOU",[[-1,1131,"ue"]],[1133,1133],[1131,1131]]],[1561692011333,["GJX@GJXAIOU",[[1,1131,"ect o"]],[1131,1131],[1136,1136]]],[1561692023600,["GJX@GJXAIOU",[[1,1137,"; //添加一个元素，任意类型的"]],[1137,1137],[1153,1153]]],[1561692024021,["GJX@GJXAIOU",[[1,1154,"  - \n"]],[1153,1153],[1158,1158]]],[1561692026970,["GJX@GJXAIOU",[[1,1158,"add()"]],[1158,1158],[1163,1163]]],[1561692029038,["GJX@GJXAIOU",[[1,1162,"z"]],[1162,1162],[1163,1163]]],[1561692030068,["GJX@GJXAIOU",[[-1,1162,"z"]],[1163,1163],[1162,1162]]],[1561692032462,["GJX@GJXAIOU",[[1,1161,"All"]],[1161,1161],[1164,1164]]],[1561692036974,["GJX@GJXAIOU",[[1,1165,"Objuec"]],[1165,1165],[1171,1171]]],[1561692037485,["GJX@GJXAIOU",[[-1,1168,"uec"]],[1171,1171],[1168,1168]]],[1561692039518,["GJX@GJXAIOU",[[1,1168,"ect "]],[1168,1168],[1172,1172]]],[1561692041988,["GJX@GJXAIOU",[[-1,1165,"Object "]],[1172,1172],[1165,1165]]],[1561692047070,["GJX@GJXAIOU",[[1,1165,"Collectin"]],[1165,1165],[1174,1174]]],[1561692048413,["GJX@GJXAIOU",[[-1,1173,"n"]],[1174,1174],[1173,1173]]],[1561692049969,["GJX@GJXAIOU",[[1,1173,"on c"]],[1173,1173],[1177,1177]]],[1561692051318,["GJX@GJXAIOU",[[1,1156,"  "]],[1177,1177],[1179,1179]]],[1561692053853,["GJX@GJXAIOU",[[-1,1156,"  "]],[1179,1179],[1177,1177]]],[1561692062551,["GJX@GJXAIOU",[[1,1178,"; //添加另一个集合"]],[1178,1178],[1189,1189]]],[1561692270941,["GJX@GJXAIOU",[[1,1190,"  - \n"]],[1189,1189],[1194,1194]]],[1561692272454,["GJX@GJXAIOU",[[-1,1190,"  "]],[1194,1194],[1192,1192]]],[1561692275696,["GJX@GJXAIOU",[[1,1192,"删除"]],[1192,1192],[1194,1194]]],[1561692275966,["GJX@GJXAIOU",[[-1,1193,"除"]],[1194,1194],[1193,1193]]],[1561692276578,["GJX@GJXAIOU",[[1,1193,"："]],[1193,1193],[1194,1194]]],[1561692276804,["GJX@GJXAIOU",[[1,1195,"- \n"]],[1194,1194],[1197,1197]]],[1561692277900,["GJX@GJXAIOU",[[1,1195,"  "]],[1197,1197],[1199,1199]]],[1561692288071,["GJX@GJXAIOU",[[1,1199,"clear(); //清空整个集合"]],[1199,1199],[1216,1216]]],[1561692288391,["GJX@GJXAIOU",[[1,1217,"  - \n"]],[1216,1216],[1221,1221]]],[1561692293936,["GJX@GJXAIOU",[[1,1221,"remove()"]],[1221,1221],[1229,1229]]],[1561692296589,["GJX@GJXAIOU",[[1,1228,"Objud"]],[1228,1228],[1233,1233]]],[1561692297100,["GJX@GJXAIOU",[[-1,1231,"ud"]],[1233,1233],[1231,1231]]],[1561692299495,["GJX@GJXAIOU",[[1,1231,"ect o"]],[1231,1231],[1236,1236]]],[1561692307484,["GJX@GJXAIOU",[[1,1237,"; //删除整个"]],[1237,1237],[1245,1245]]],[1561692309444,["GJX@GJXAIOU",[[-1,1243,"整个"]],[1245,1245],[1243,1243]]],[1561692313632,["GJX@GJXAIOU",[[1,1243,"两个集合多种"]],[1243,1243],[1249,1249]]],[1561692323508,["GJX@GJXAIOU",[[-1,1248,"种"]],[1249,1249],[1248,1248]]],[1561692324891,["GJX@GJXAIOU",[[1,1248,"的"]],[1248,1248],[1249,1249]]],[1561692326220,["GJX@GJXAIOU",[[-1,1247,"多的"]],[1249,1249],[1247,1247]]],[1561692332065,["GJX@GJXAIOU",[[1,1247,"中的交集"]],[1247,1247],[1251,1251]]],[1561692333815,["GJX@GJXAIOU",[[1,1252,"  - \n"]],[1251,1251],[1256,1256]]],[1561702165364,["GJX@GJXAIOU",[[1,1256,"remove()"]],[1256,1256],[1264,1264]]],[1561702174143,["GJX@GJXAIOU",[[1,1263,"Colletcion c"]],[1263,1263],[1275,1275]]],[1561702182625,["GJX@GJXAIOU",[[1,1276,"; //删除两个"]],[1276,1276],[1284,1284]]],[1561702191383,["GJX@GJXAIOU",[[1,1262,"All"]],[1262,1262],[1265,1265]]],[1561702205546,["GJX@GJXAIOU",[[1,1287,"集合中的交集"]],[1287,1287],[1293,1293]]],[1561702208661,["GJX@GJXAIOU",[[-1,1247,"中的交集"]],[1251,1251],[1247,1247]]],[1561702209963,["GJX@GJXAIOU",[[-1,1243,"两个集合"]],[1247,1247],[1243,1243]]],[1561702217022,["GJX@GJXAIOU",[[1,1243,"该集合中 "]],[1243,1243],[1248,1248]]],[1561702217755,["GJX@GJXAIOU",[[-1,1247," "]],[1248,1248],[1247,1247]]],[1561702220361,["GJX@GJXAIOU",[[1,1247,"指定的元素"]],[1247,1247],[1252,1252]]],[1561702226668,["GJX@GJXAIOU",[[1,1295,"  - \n"]],[1294,1294],[1299,1299]]],[1561702233861,["GJX@GJXAIOU",[[1,1299,"retainAll()"]],[1299,1299],[1310,1310]]],[1561702248869,["GJX@GJXAIOU",[[1,1309,"Collection c"]],[1309,1309],[1321,1321]]],[1561702260857,["GJX@GJXAIOU",[[1,1322,"; //保留两个集合中的交集"]],[1322,1322],[1336,1336]]],[1561702263408,["GJX@GJXAIOU",[[1,1337,"  - \n"]],[1336,1336],[1341,1341]]],[1561702265869,["GJX@GJXAIOU",[[-1,1337,"  "]],[1341,1341],[1339,1339]]],[1561702268489,["GJX@GJXAIOU",[[1,1339,"查"]],[1339,1339],[1340,1340]]],[1561702269019,["GJX@GJXAIOU",[[1,1340,"："]],[1340,1340],[1341,1341]]],[1561702269567,["GJX@GJXAIOU",[[1,1342,"- \n"]],[1341,1341],[1344,1344]]],[1561702270423,["GJX@GJXAIOU",[[1,1342,"  "]],[1344,1344],[1346,1346]]],[1561702339325,["GJX@GJXAIOU",[[1,1346,"size(): "]],[1346,1346],[1354,1354]]],[1561702341139,["GJX@GJXAIOU",[[-1,1352,": "]],[1354,1354],[1352,1352]]],[1561702352184,["GJX@GJXAIOU",[[1,1352,"; //获取当前集合游侠"]],[1352,1352],[1364,1364]]],[1561702353444,["GJX@GJXAIOU",[[-1,1362,"游侠"]],[1364,1364],[1362,1362]]],[1561702359775,["GJX@GJXAIOU",[[1,1362,"有效元素的个数"]],[1362,1362],[1369,1369]]],[1561702360073,["GJX@GJXAIOU",[[1,1370,"  - \n"]],[1369,1369],[1374,1374]]],[1561702376463,["GJX@GJXAIOU",[[1,1374,"toArray(); //把当前集合中多有的"]],[1374,1374],[1396,1396]]],[1561702377141,["GJX@GJXAIOU",[[-1,1393,"多有的"]],[1396,1396],[1393,1393]]],[1561702387518,["GJX@GJXAIOU",[[1,1393,"所有的元素转换成为Object"]],[1393,1393],[1408,1408]]],[1561702387543,["GJX@GJXAIOU",[[1,1402," "]],[1408,1408],[1409,1409]]],[1561702389775,["GJX@GJXAIOU",[[1,1409,"类型"]],[1409,1409],[1411,1411]]],[1561702389800,["GJX@GJXAIOU",[[1,1409," "]],[1411,1411],[1412,1412]]],[1561702393760,["GJX@GJXAIOU",[[1,1412,"的数组返回"]],[1412,1412],[1417,1417]]],[1561702394363,["GJX@GJXAIOU",[[1,1418,"  - \n"]],[1417,1417],[1422,1422]]],[1561702395115,["GJX@GJXAIOU",[[-1,1420,"- "]],[1422,1422],[1420,1420]]],[1561703792486,["GJX@GJXAIOU",[[1,1421,"```"]],[1421,1421],[1424,1424]]],[1561703792512,["GJX@GJXAIOU",[[1,1424,"language\n```\n"]],[1424,1424],[1424,1432]]],[1561703793867,["GJX@GJXAIOU",[[-1,1424,"language"],[1,1432,"j"]],[1424,1432],[1425,1425]]],[1561703794348,["GJX@GJXAIOU",[[1,1425,"ava"]],[1425,1425],[1428,1428]]],[1561703794882,["GJX@GJXAIOU",[[1,1429,"\n"]],[1428,1428],[1429,1429]]],[1561703796062,["GJX@GJXAIOU",[[1,1429,"/**\n * \n */\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\n/**\n * class detail:\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\t//Collection 是一个接口，而接口是没有自己的类对象的，但是可以指向【遵从】该接口的类对象\n\t\t//这里借助于常用集合ArrayList来完成；\n\t\tCollection collection  = new ArrayList();\n\t\t\n\t\t//测试添加方法： add(Object 0);\n\t\tcollection.add(\"天气变热了\");\n\t\tcollection.add(\"明天30度啦\");\n\t\tcollection.add(\"测试\");\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试添加方法：addAll(Collection c);\n\t\tCollection collection2 = new ArrayList();\n\t\tcollection2.add(\"测试一\");\n\t\tcollection2.add(\"好热\");\n\t\t\n\t\tcollection.addAll(collection2);\n\t\tSystem.out.println(collection);\n\t\t\n\t\t\n\t\t//测试clear() : 清空集合中所有的元素\n\t\tSystem.out.println(collection);\n\t\tcollection.clear();\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试remove(Object o)\n\t\tcollection.remove(\"测试\");\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试removeAll\n\t\tcollection.removeAll(collection2);\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试retainAll(Collection c)\n\t\tcollection.retainAll(collection2);\n\t\tSystem.err.println(collection);\n\t\t\n\t\t//测试size()\n\t\tSystem.out.println(collection.size());\n\t\t\n\t\t//测试Arrays.toString\n\t\tSystem.out.println(Arrays.toString(collection.toArray()));\n\t\t\n\t\t\n\t}\n\t\n}\n"]],[1429,1429],[2698,2698]]],[1561703799682,["GJX@GJXAIOU",[[-1,1429,"/**\n * \n */"]],[1429,1440],[1429,1429]]],[1561703800681,["GJX@GJXAIOU",[[-1,1429,"\n"]],[1429,1429],[1428,1428]]],[1561703808010,["GJX@GJXAIOU",[[1,2708,"\n"]],[2690,2690],[2691,2691]]],[1561703808126,["GJX@GJXAIOU",[[1,2709,"\n"]],[2691,2691],[2692,2692]]],[1561703851723,["GJX@GJXAIOU",[[1,1114,"- jib"]],[1114,1114],[1119,1119]]],[1561703852522,["GJX@GJXAIOU",[[-1,1116,"jib"]],[1119,1119],[1116,1116]]],[1561703855613,["GJX@GJXAIOU",[[1,1116,"基本方法："]],[1116,1116],[1121,1121]]],[1561703858883,["GJX@GJXAIOU",[[1,1116,"**"],[1,1121,"**"]],[1116,1121],[1116,1125]]],[1561703862395,["GJX@GJXAIOU",[[1,2721,"\n"]],[2702,2702],[2703,2703]]],[1561703864484,["GJX@GJXAIOU",[[1,2703,"- ****"]],[2703,2703],[2707,2707]]],[1561703869134,["GJX@GJXAIOU",[[1,2707,"其他方法："]],[2707,2707],[2712,2712]]],[1561703870771,["GJX@GJXAIOU",[[1,2715,"- \n"]],[2714,2714],[2717,2717]]],[1561703871211,["GJX@GJXAIOU",[[1,2715,"  "]],[2717,2717],[2719,2719]]],[1561703875144,["GJX@GJXAIOU",[[1,2719,"判断方法"]],[2719,2719],[2723,2723]]],[1561703875947,["GJX@GJXAIOU",[[1,2724,"  - \n"]],[2723,2723],[2728,2728]]],[1561703877211,["GJX@GJXAIOU",[[1,2726,"  "]],[2728,2728],[2730,2730]]],[1561703889518,["GJX@GJXAIOU",[[1,2730,"isEmpty(); //"]],[2730,2730],[2743,2743]]],[1561703906804,["GJX@GJXAIOU",[[1,2743,"shi"]],[2743,2743],[2746,2746]]],[1561703907453,["GJX@GJXAIOU",[[-1,2743,"shi"]],[2746,2746],[2743,2743]]],[1561703911738,["GJX@GJXAIOU",[[1,2743,"是否为空"]],[2743,2743],[2747,2747]]],[1561703912978,["GJX@GJXAIOU",[[1,2748,"    - \n"]],[2747,2747],[2754,2754]]],[1561703921291,["GJX@GJXAIOU",[[1,2754,"contains();"]],[2754,2754],[2765,2765]]],[1561703931407,["GJX@GJXAIOU",[[1,2763,"Object o"]],[2763,2763],[2771,2771]]],[1561703949392,["GJX@GJXAIOU",[[1,2773," //是否包含当前"]],[2773,2773],[2782,2782]]],[1561703950534,["GJX@GJXAIOU",[[1,2782,"元素"]],[2782,2782],[2784,2784]]],[1561703950802,["GJX@GJXAIOU",[[1,2785,"    - \n"]],[2784,2784],[2791,2791]]],[1561703952651,["GJX@GJXAIOU",[[1,2791,"ocnt"]],[2791,2791],[2795,2795]]],[1561703953386,["GJX@GJXAIOU",[[-1,2791,"ocnt"]],[2795,2795],[2791,2791]]],[1561703954564,["GJX@GJXAIOU",[[1,2791,"contra"]],[2791,2791],[2797,2797]]],[1561703955437,["GJX@GJXAIOU",[[-1,2796,"a"]],[2797,2797],[2796,2796]]],[1561703955571,["GJX@GJXAIOU",[[1,2796,"a"]],[2796,2796],[2797,2797]]],[1561703955978,["GJX@GJXAIOU",[[-1,2795,"ra"]],[2797,2797],[2795,2795]]],[1561703959768,["GJX@GJXAIOU",[[1,2795,"ainsAll()"]],[2795,2795],[2804,2804]]],[1561703966692,["GJX@GJXAIOU",[[1,2803,"Colllection c"]],[2803,2803],[2816,2816]]],[1561703972847,["GJX@GJXAIOU",[[1,2817,"; //是够"]],[2817,2817],[2823,2823]]],[1561703973523,["GJX@GJXAIOU",[[-1,2821,"是够"]],[2823,2823],[2821,2821]]],[1561703985895,["GJX@GJXAIOU",[[1,2821,"是否包含指定集合里面的所有元素"]],[2821,2821],[2836,2836]]],[1561703986579,["GJX@GJXAIOU",[[1,2837,"    - \n"]],[2836,2836],[2843,2843]]],[1561703988476,["GJX@GJXAIOU",[[1,2843,"qu"]],[2843,2843],[2845,2845]]],[1561703989718,["GJX@GJXAIOU",[[-1,2843,"qu"]],[2845,2845],[2843,2843]]],[1561703993637,["GJX@GJXAIOU",[[1,2843,"equals()"]],[2843,2843],[2851,2851]]],[1561703996254,["GJX@GJXAIOU",[[1,2850,"Obju"]],[2850,2850],[2854,2854]]],[1561703996619,["GJX@GJXAIOU",[[-1,2853,"u"]],[2854,2854],[2853,2853]]],[1561703997536,["GJX@GJXAIOU",[[1,2853,"ed"]],[2853,2853],[2855,2855]]],[1561703998205,["GJX@GJXAIOU",[[-1,2854,"d"]],[2855,2855],[2854,2854]]],[1561703999356,["GJX@GJXAIOU",[[1,2854,"cti"]],[2854,2854],[2857,2857]]],[1561704000830,["GJX@GJXAIOU",[[-1,2856,"i"]],[2857,2857],[2856,2856]]],[1561704001740,["GJX@GJXAIOU",[[1,2856," o"]],[2856,2856],[2858,2858]]],[1561704012726,["GJX@GJXAIOU",[[1,2859,"; /./"]],[2859,2859],[2864,2864]]],[1561704013437,["GJX@GJXAIOU",[[-1,2862,"./"]],[2864,2864],[2862,2862]]],[1561704022871,["GJX@GJXAIOU",[[1,2862,"/判断是否相等"]],[2862,2862],[2869,2869]]],[1561704024845,["GJX@GJXAIOU",[[1,2870,"    - \n"]],[2869,2869],[2876,2876]]],[1561704024995,["GJX@GJXAIOU",[[-1,2870,"    - "]],[2876,2876],[2871,2871]]],[1561704025179,["GJX@GJXAIOU",[[1,2889,"\n"]],[2871,2871],[2872,2872]]],[1561704961741,["GJX@GJXAIOU",[[1,2871,"飞马"]],[2871,2871],[2873,2873]]],[1561704962537,["GJX@GJXAIOU",[[-1,2871,"飞马"]],[2873,2873],[2871,2871]]],[1561704965079,["GJX@GJXAIOU",[[1,2871,"代码示例："]],[2871,2871],[2876,2876]]],[1561704965428,["GJX@GJXAIOU",[[1,2895,"\n"]],[2876,2876],[2877,2877]]],[1561704967011,["GJX@GJXAIOU",[[1,2877,"```"]],[2877,2877],[2880,2880]]],[1561704967039,["GJX@GJXAIOU",[[1,2880,"language\n```\n"]],[2880,2880],[2880,2888]]],[1561704968156,["GJX@GJXAIOU",[[-1,2880,"language"],[1,2888,"j"]],[2880,2888],[2881,2881]]],[1561704968581,["GJX@GJXAIOU",[[1,2881,"ava"]],[2881,2881],[2884,2884]]],[1561704968681,["GJX@GJXAIOU",[[1,2885,"\n"]],[2884,2884],[2885,2885]]],[1561704969890,["GJX@GJXAIOU",[[1,2885,"/**\n * \n */\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\n/**\n * class detail:\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"A\");\n\t\tcollection.add(\"B\");\n\t\tcollection.add(\"C\");\n\t\tcollection.add(\"D\");\n\t\t\n\t\tCollection collection2 = new ArrayList();\n\t\tcollection2.add(\"A\");\n\t\tcollection2.add(\"B\");\n\t\tcollection2.add(\"D\");\n\t\tcollection2.add(\"C\");\n\t\t\n\t\t//测试equal()方法 ； //比较这两个集合之间的元素是否完全相同，放入的位置也相同；\n\t\tcollection.equals(collection2);  //因为顺序不同，结果为false\n\t\t\n\t\t//测试isEmpty方法\n\t\tcollection.isEmpty(); //结果为false\n\t\t\n\t\t//测试 contains(Object o);\n\t\tSystem.out.println(collection.contains(\"A\"));\n\t\tSystem.out.println(collection.contains(\"E\"));\n\t\t\n\t\t//测试containAll(Collection c); //判断传入的集合是不是当前集合的子集\n\t\tSystem.out.println(collection.containsAll(collection2));\n\t}\n\n}\n"]],[2885,2885],[3783,3783]]],[1561704972713,["GJX@GJXAIOU",[[-1,2885,"/**\n * \n */"]],[2885,2896],[2885,2885]]],[1561704973489,["GJX@GJXAIOU",[[-1,2885,"\n"]],[2885,2885],[2884,2884]]],[1561723537787,["GJX@GJXAIOU",[[1,3795,"\n"]],[3775,3775],[3776,3776]]],[1561723537913,["GJX@GJXAIOU",[[1,3796,"\n"]],[3776,3776],[3777,3777]]],[1561723538041,["GJX@GJXAIOU",[[1,3797,"\n"]],[3777,3777],[3778,3778]]],[1561723538145,["GJX@GJXAIOU",[[1,3798,"\n"]],[3778,3778],[3779,3779]]],[1561723539113,["GJX@GJXAIOU",[[1,3779,"## collection\n\n- contains, containAll,equals 方法；\n  - 发现：\n    - Java 语言总，默认判断两个对象是否相同的方式是：判断这两个对象的地址是否相同；\n    - 在这里 student1 对象和 new Student（1, “成龙”）;是两个完全不同的对象；\n  - 问题：\n    - 因为上面两个对象里面保存的数据其实是一样的，也是符合业务逻辑的，或者是符合生活逻辑的，实现在符合语法的前提下，也符合生活逻辑；\n  - 解决方法：\n    - 重写 equals 和 hashCode 方法；\n    - 默认情况下：\n      - hashCode 方法在系统默认情况下，是当前类的对象在内存中地址的十进制数；\n            - equals 方法是两个对象相互比较的法则；\n代码示例：\n\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\n\nclass Student{\n\tprivate int  id;\n\tprivate String name;\n\n\tpublic Student() {\t\n\t\t\n\t}\n\t\n\tpublic  Student(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\t\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\t\n\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\t@Override\n\t//描述当前类对象，当通过打印方法的时候自动调用\n\tpublic String toString() {\n\t\treturn \"[ ID : \" + id + \"    Name : \" + name + \"]\";\n\t}\n\t\n\t//重写equals方法和hashCode方法\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\t//这里的equals方法是Student类重写的方法，当集合调用contains、containsAll、equals方法的时候\n\t\t//都会调用这里的Student类中的equals方法进行比较，比较的对象是Student对象；\n\t\tSystem.out.println(\"Student的equals方法\");\n\t\t\n\t\t//原来的equals方法不符合生活逻辑，仅仅是判断两个对象的地址是否相同，不判断里面的内容是否一致，\n\t\t//重写改变为判断对象中的数据是否一致\n\t\t\n\t\t//1.首先进行强制类型转换\n\t\tStudent student = (Student)obj;\n\t\tSystem.out.println(this.name + \" 和 \" + student.name + \"进行比较\");\n\t\t\n\t\t//这里的this.name.equals(student.name)中的equals方法是调用String类型的equals方法，用于判断两字符串是否相等；\n\t\treturn this.id == student.id && this.name.equals(student.name);\n\t}\n\t\n\t@Override\n\tpublic int hashCode() {\n\t\tSystem.out.println(\"Student 的 HashCode 方法\");\n\t\t//如果重写了equals方法，同时也要重写hashCode方法\n\t\t//因为hashCode值要确定【唯一性】，只要满足自己逻辑就OK，这里认为id是唯一的\n\t\treturn this.id;\n\t}\t\n}\n\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection  =  new ArrayList();\n\t\tStudent student1 = new Student(1,\"张三\");\n\t\tStudent student2 = new Student(2,\"李四\"\t);\n\t\tStudent student3 = new Student(3,\"王五\");\n\t\t\n\t\tcollection.add(student1);\n\t\tcollection.add(student2);\n\t\tcollection.add(student3);\n\t\t\n\t\tSystem.out.println(collection);\n\t\t\n\t\tboolean ret = collection.contains(new Student(1, \"张三\")); //\n\t\tSystem.out.println(ret);\n\t} \n}\n\n```\n\n\n### 迭代器\n\n代码示例\n```java\n/**\n * \n */\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class DieDaiQi {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray();\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t/*Itreator  迭代器\n\t\t * boolean hasNext();  //判断当前迭代器是否有下一个元素\n\t\t * Object next(); //获取当前迭代器指向的元素，并且获取之后，指向下一个元素；\n\t\t * void remove(); //删除当前迭代器通过next获取到的对象\n\t\t * [要求]: 在通过迭代器调用remove方法时候，之前必须调用过next方法，否则会报异常：java.lang.IllegalAtateException\n\t\t */\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}\n\n```\n\n### 共享资源问题\n\n针对同一个资源，同时两个主体在使用，容易产生冲突；\n代码示例：集合对象和迭代器同时处理集合中的元素，造成冲突；\n```Java\n/**\n * \n */\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * class detail:共享资源处理问题\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class ShareSources {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\tIterator iterator = collection.iterator();\n\t\t\n\t\t//下面代码会抛出异常： java.util.ConcurrentModificationException\n\t\t/*\n\t\t * 这里存在两种操作集合数据的方式，第一种方式：集合的对象collection；第二种方式：集合的迭代器iterator\n\t\t * 这里两种操作都有查看和删除的权限，但是一方操作的同时，另一方也在操作，或造成共享资源问题；\n\t\t * \n\t\t * 解决方法：\n\t\t *  \t1.使用迭代器操作放弃集合对象操作\n\t\t *  \t2.使用集合对象操作放弃迭代器操作\n\t\t */\n\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tSystem.out.println(iterator.next());\n\t\t\t\t\tcollection.remove(\"李四\");\t\n\t\t}\n\t}\n}\n\n```\n\n\n\n\n\n\n## \n"]],[3779,3779],[8251,8251]]],[1561723706285,["GJX@GJXAIOU",[[1,8250,"LIst"]],[8250,8250],[8254,8254]]],[1561723710023,["GJX@GJXAIOU",[[-1,8251,"Ist"]],[8254,8254],[8251,8251]]],[1561723711274,["GJX@GJXAIOU",[[1,8251,"ist"]],[8251,8251],[8254,8254]]],[1561723712040,["GJX@GJXAIOU",[[1,8275,"\n"]],[8254,8254],[8255,8255]]],[1561723712858,["GJX@GJXAIOU",[[1,8276,"\n"]],[8255,8255],[8256,8256]]],[1561723719852,["GJX@GJXAIOU",[[1,8256,"shouxi"]],[8256,8256],[8262,8262]]],[1561723721047,["GJX@GJXAIOU",[[-1,8256,"shouxi"]],[8262,8262],[8256,8256]]],[1561723749918,["GJX@GJXAIOU",[[1,8255,"shouxian"]],[8255,8255],[8263,8263]]],[1561723751409,["GJX@GJXAIOU",[[-1,8255,"shouxian"]],[8263,8263],[8255,8255]]],[1561723754798,["GJX@GJXAIOU",[[1,8257,"List"]],[8257,8257],[8261,8261]]],[1561723754832,["GJX@GJXAIOU",[[1,8257," "]],[8261,8261],[8262,8262]]],[1561723756099,["GJX@GJXAIOU",[[1,8262,"接口"]],[8262,8262],[8264,8264]]],[1561723756133,["GJX@GJXAIOU",[[1,8262," "]],[8264,8264],[8265,8265]]],[1561723759535,["GJX@GJXAIOU",[[-1,8258,"List 接口"]],[8265,8265],[8258,8258]]],[1561723761916,["GJX@GJXAIOU",[[1,8258,"coll"]],[8258,8258],[8262,8262]]],[1561723763367,["GJX@GJXAIOU",[[-1,8258,"coll"]],[8262,8262],[8258,8258]]],[1561723768847,["GJX@GJXAIOU",[[1,8258,"Collection接口"]],[8258,8258],[8270,8270]]],[1561723768880,["GJX@GJXAIOU",[[1,8268," "]],[8270,8270],[8271,8271]]],[1561723799494,["GJX@GJXAIOU",[[1,8271,"中的所有方法在这里热呢an"]],[8271,8271],[8284,8284]]],[1561723800383,["GJX@GJXAIOU",[[-1,8280,"热呢an"]],[8284,8284],[8280,8280]]],[1561723803551,["GJX@GJXAIOU",[[1,8280,"仍然使用"]],[8280,8280],[8284,8284]]],[1561723804314,["GJX@GJXAIOU",[[-1,8282,"使用"]],[8284,8284],[8282,8282]]],[1561723812637,["GJX@GJXAIOU",[[1,8282,"可以使用，下面是"]],[8282,8282],[8290,8290]]],[1561723872806,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,8290,"\n\n"]],[8255,8255],[8292,8292]]],[1561723872806,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,8290,"\n\n"]],[8292,8292],[8255,8255]]],[1561723814565,["GJX@GJXAIOU",[[1,8290,"List"]],[8290,8290],[8294,8294]]],[1561723814599,["GJX@GJXAIOU",[[1,8290," "]],[8294,8294],[8295,8295]]],[1561723817159,["GJX@GJXAIOU",[[1,8295,"接口"]],[8295,8295],[8297,8297]]],[1561723817193,["GJX@GJXAIOU",[[1,8295," "]],[8297,8297],[8298,8298]]],[1561723824796,["GJX@GJXAIOU",[[1,8298,"中【特有的】方法："]],[8298,8298],[8307,8307]]],[1561723825072,["GJX@GJXAIOU",[[1,8329,"\n"]],[8307,8307],[8308,8308]]],[1561723829540,["GJX@GJXAIOU",[[1,8308,"- 添加"]],[8308,8308],[8312,8312]]],[1561723830480,["GJX@GJXAIOU",[[1,8313,"- \n"]],[8312,8312],[8315,8315]]],[1561723832154,["GJX@GJXAIOU",[[1,8313,"  "]],[8315,8315],[8317,8317]]],[1561723835866,["GJX@GJXAIOU",[[1,8312,"："]],[8312,8312],[8313,8313]]],[1561723842210,["GJX@GJXAIOU",[[1,8318,"add()"]],[8318,8318],[8323,8323]]],[1561723844442,["GJX@GJXAIOU",[[1,8322,"indec"]],[8322,8322],[8327,8327]]],[1561723845176,["GJX@GJXAIOU",[[-1,8326,"c"]],[8327,8327],[8326,8326]]],[1561723851595,["GJX@GJXAIOU",[[1,8326,"x, Object 0"]],[8326,8326],[8337,8337]]],[1561723860213,["GJX@GJXAIOU",[[1,8338,"; //指定位置是"]],[8338,8338],[8347,8347]]],[1561723860815,["GJX@GJXAIOU",[[-1,8346,"是"]],[8347,8347],[8346,8346]]],[1561723863300,["GJX@GJXAIOU",[[1,8346,"上防止"]],[8346,8346],[8349,8349]]],[1561723864791,["GJX@GJXAIOU",[[-1,8347,"防止"]],[8349,8349],[8347,8347]]],[1561723868390,["GJX@GJXAIOU",[[1,8347,"放入元素"]],[8347,8347],[8351,8351]]],[1561723868970,["GJX@GJXAIOU",[[1,8352,"  - \n"]],[8351,8351],[8356,8356]]],[1561723872606,["GJX@GJXAIOU",[[1,8356,"add"]],[8356,8356],[8359,8359]]],[1561723932805,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,8359,"\n\n"]],[8255,8255],[8361,8361]]],[1561723932805,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,8359,"\n\n"]],[8361,8361],[8255,8255]]],[1561723875985,["GJX@GJXAIOU",[[1,8359,"All()"]],[8359,8359],[8364,8364]]],[1561723880172,["GJX@GJXAIOU",[[1,8363,"int insex"]],[8363,8363],[8372,8372]]],[1561723881048,["GJX@GJXAIOU",[[-1,8368,"nsex"]],[8372,8372],[8368,8368]]],[1561723890893,["GJX@GJXAIOU",[[1,8368,"ndex, Collection c"]],[8368,8368],[8386,8386]]],[1561723900692,["GJX@GJXAIOU",[[1,8387,"; //在指定位置上天机"]],[8387,8387],[8399,8399]]],[1561723901343,["GJX@GJXAIOU",[[-1,8397,"天机"]],[8399,8399],[8397,8397]]],[1561723904702,["GJX@GJXAIOU",[[1,8397,"添加一个集合"]],[8397,8397],[8403,8403]]],[1561723906976,["GJX@GJXAIOU",[[1,8404,"  - \n"]],[8403,8403],[8408,8408]]],[1561723910088,["GJX@GJXAIOU",[[-1,8404,"  "]],[8408,8408],[8406,8406]]],[1561723912830,["GJX@GJXAIOU",[[1,8406,"获取："]],[8406,8406],[8409,8409]]],[1561723913202,["GJX@GJXAIOU",[[1,8410,"- \n"]],[8409,8409],[8412,8412]]],[1561723914088,["GJX@GJXAIOU",[[1,8410,"  "]],[8412,8412],[8414,8414]]],[1561723922676,["GJX@GJXAIOU",[[1,8414,"Object get()"]],[8414,8414],[8426,8426]]],[1561723925929,["GJX@GJXAIOU",[[1,8425,"int index"]],[8425,8425],[8434,8434]]],[1561723931118,["GJX@GJXAIOU",[[1,8435,"; //获取"]],[8435,8435],[8441,8441]]],[1561723992810,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,8441,"\n\n"]],[8255,8255],[8443,8443]]],[1561723992810,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,8441,"\n\n"]],[8443,8443],[8255,8255]]],[1561723934472,["GJX@GJXAIOU",[[1,8441,"下标的元素"]],[8441,8441],[8446,8446]]],[1561723934986,["GJX@GJXAIOU",[[1,8447,"  - \n"]],[8446,8446],[8451,8451]]],[1561723939971,["GJX@GJXAIOU",[[1,8451,"int ins"]],[8451,8451],[8458,8458]]],[1561723940712,["GJX@GJXAIOU",[[-1,8457,"s"]],[8458,8458],[8457,8457]]],[1561723945075,["GJX@GJXAIOU",[[1,8457,"dexOf()"]],[8457,8457],[8464,8464]]],[1561723951723,["GJX@GJXAIOU",[[1,8463,"Object 0"]],[8463,8463],[8471,8471]]],[1561723952783,["GJX@GJXAIOU",[[-1,8470,"0"]],[8471,8471],[8470,8470]]],[1561723953538,["GJX@GJXAIOU",[[1,8470,"0"]],[8470,8470],[8471,8471]]],[1561723955583,["GJX@GJXAIOU",[[-1,8470,"0"]],[8471,8471],[8470,8470]]],[1561723955865,["GJX@GJXAIOU",[[1,8470,"0"]],[8470,8470],[8471,8471]]],[1561723966589,["GJX@GJXAIOU",[[1,8472,"; //获取某个元素的下包"]],[8472,8472],[8485,8485]]],[1561723967271,["GJX@GJXAIOU",[[-1,8483,"下包"]],[8485,8485],[8483,8483]]],[1561723972767,["GJX@GJXAIOU",[[1,8483,"下标位置"]],[8483,8483],[8487,8487]]],[1561723973115,["GJX@GJXAIOU",[[1,8488,"  - \n"]],[8487,8487],[8492,8492]]],[1561723975441,["GJX@GJXAIOU",[[1,8492,"ine "]],[8492,8492],[8496,8496]]],[1561723976351,["GJX@GJXAIOU",[[-1,8494,"e "]],[8496,8496],[8494,8494]]],[1561723978946,["GJX@GJXAIOU",[[1,8494,"t lase"]],[8494,8494],[8500,8500]]],[1561723979688,["GJX@GJXAIOU",[[-1,8499,"e"]],[8500,8500],[8499,8499]]],[1561723987646,["GJX@GJXAIOU",[[1,8499,"tIndexOf()"]],[8499,8499],[8509,8509]]],[1561723992644,["GJX@GJXAIOU",[[1,8508,"Object "]],[8508,8508],[8515,8515]]],[1561724052808,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,8516,"\n\n"]],[8255,8255],[8518,8518]]],[1561724052808,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,8516,"\n\n"]],[8518,8518],[8255,8255]]],[1561723993268,["GJX@GJXAIOU",[[1,8515,"0"]],[8515,8515],[8516,8516]]],[1561724010718,["GJX@GJXAIOU",[[1,8517,"; //找到指定元素最后一个出现在集合中国的"]],[8517,8517],[8539,8539]]],[1561724011367,["GJX@GJXAIOU",[[-1,8537,"国的"]],[8539,8539],[8537,8537]]],[1561724013206,["GJX@GJXAIOU",[[1,8537,"的位置；"]],[8537,8537],[8541,8541]]],[1561724013863,["GJX@GJXAIOU",[[-1,8540,"；"]],[8541,8541],[8540,8540]]],[1561724014352,["GJX@GJXAIOU",[[1,8541,"  - \n"]],[8540,8540],[8545,8545]]],[1561724017204,["GJX@GJXAIOU",[[1,8545,"LIs"]],[8545,8545],[8548,8548]]],[1561724017808,["GJX@GJXAIOU",[[-1,8546,"Is"]],[8548,8548],[8546,8546]]],[1561724019041,["GJX@GJXAIOU",[[1,8546,"ise"]],[8546,8546],[8549,8549]]],[1561724019759,["GJX@GJXAIOU",[[-1,8548,"e"]],[8549,8549],[8548,8548]]],[1561724024425,["GJX@GJXAIOU",[[1,8548,"t subLise"]],[8548,8548],[8557,8557]]],[1561724025170,["GJX@GJXAIOU",[[-1,8556,"e"]],[8557,8557],[8556,8556]]],[1561724027348,["GJX@GJXAIOU",[[1,8556,"t()"]],[8556,8556],[8559,8559]]],[1561724041563,["GJX@GJXAIOU",[[1,8558,"int fromIndex, int toIndex"]],[8558,8558],[8584,8584]]],[1561724047443,["GJX@GJXAIOU",[[1,8585,"; /、"]],[8585,8585],[8589,8589]]],[1561724048047,["GJX@GJXAIOU",[[-1,8588,"、"]],[8589,8589],[8588,8588]]],[1561724050598,["GJX@GJXAIOU",[[1,8588,"/获取"]],[8588,8588],[8591,8591]]],[1561724112809,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,8591,"\n\n"]],[8255,8255],[8593,8593]]],[1561724112809,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,8591,"\n\n"]],[8593,8593],[8255,8255]]],[1561724055702,["GJX@GJXAIOU",[[1,8591,"子List"]],[8591,8591],[8596,8596]]],[1561724055737,["GJX@GJXAIOU",[[1,8592," "]],[8596,8596],[8597,8597]]],[1561724056566,["GJX@GJXAIOU",[[1,8597,"集合"]],[8597,8597],[8599,8599]]],[1561724056603,["GJX@GJXAIOU",[[1,8597," "]],[8599,8599],[8600,8600]]],[1561724062320,["GJX@GJXAIOU",[[1,8601,"  - \n"]],[8600,8600],[8605,8605]]],[1561724064019,["GJX@GJXAIOU",[[-1,8601,"  "]],[8605,8605],[8603,8603]]],[1561724067523,["GJX@GJXAIOU",[[1,8603,"修改："]],[8603,8603],[8606,8606]]],[1561724069111,["GJX@GJXAIOU",[[1,8607,"- \n"]],[8606,8606],[8609,8609]]],[1561724070411,["GJX@GJXAIOU",[[1,8607,"  "]],[8609,8609],[8611,8611]]],[1561724073487,["GJX@GJXAIOU",[[1,8611,"set()"]],[8611,8611],[8616,8616]]],[1561724083877,["GJX@GJXAIOU",[[1,8615,"int index, Object 0;"]],[8615,8615],[8635,8635]]],[1561724084767,["GJX@GJXAIOU",[[-1,8634,";"]],[8635,8635],[8634,8634]]],[1561724088506,["GJX@GJXAIOU",[[1,8635,"; 、、"]],[8635,8635],[8639,8639]]],[1561724089238,["GJX@GJXAIOU",[[-1,8637,"、、"]],[8639,8639],[8637,8637]]],[1561724090254,["GJX@GJXAIOU",[[1,8637,"、、"]],[8637,8637],[8639,8639]]],[1561724090943,["GJX@GJXAIOU",[[-1,8637,"、、"]],[8639,8639],[8637,8637]]],[1561724092037,["GJX@GJXAIOU",[[1,8637,"、、"]],[8637,8637],[8639,8639]]],[1561724092631,["GJX@GJXAIOU",[[-1,8637,"、、"]],[8639,8639],[8637,8637]]],[1561724105980,["GJX@GJXAIOU",[[1,8637,"//设置指定下标上的元素"]],[8637,8637],[8649,8649]]],[1561724107848,["GJX@GJXAIOU",[[1,8650,"  - \n"]],[8649,8649],[8654,8654]]],[1561724109736,["GJX@GJXAIOU",[[-1,8650,"  "]],[8654,8654],[8652,8652]]],[1561724111988,["GJX@GJXAIOU",[[1,8652,"迭代："]],[8652,8652],[8655,8655]]],[1561724112487,["GJX@GJXAIOU",[[1,8656,"- \n"]],[8655,8655],[8658,8658]]],[1561724172811,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,8658,"\n\n"]],[8255,8255],[8660,8660]]],[1561724172811,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,8658,"\n\n"]],[8660,8660],[8255,8255]]],[1561724113384,["GJX@GJXAIOU",[[1,8656,"  "]],[8658,8658],[8660,8660]]],[1561724124570,["GJX@GJXAIOU",[[1,8660,"ListIterator();"]],[8660,8660],[8675,8675]]],[1561726752863,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,8675,"\n\n"]],[8255,8255],[8677,8677]]],[1561726752863,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,8675,"\n\n"]],[8677,8677],[8255,8255]]],[1561726698330,["GJX@GJXAIOU",[[1,8677,"···"]],[8677,8677],[8680,8680]]],[1561726699693,["GJX@GJXAIOU",[[-1,8677,"···"]],[8680,8680],[8677,8677]]],[1561726700911,["GJX@GJXAIOU",[[1,8677,"```"]],[8677,8677],[8680,8680]]],[1561726700949,["GJX@GJXAIOU",[[1,8680,"language\n```\n"]],[8680,8680],[8680,8688]]],[1561726702239,["GJX@GJXAIOU",[[-1,8680,"language"],[1,8688,"j"]],[8680,8688],[8681,8681]]],[1561726702584,["GJX@GJXAIOU",[[1,8681,"ava"]],[8681,8681],[8684,8684]]],[1561726702688,["GJX@GJXAIOU",[[1,8685,"\n"]],[8684,8684],[8685,8685]]],[1561726703702,["GJX@GJXAIOU",[[1,8685,"/**\n * \n */\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * class detail:\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class ListUse {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();  //导包一定要导入java.util.List\n\t\tlist.add(\"张三\");\n\t\tlist.add(\"李四\");\n\t\tlist.add(\"王五\");\n\t\t\n\t\tSystem.out.println(list);\n\t\t\n\t\tlist.add(1, \"赵六\"); //在元素1后面插入“赵六\"\n\t\tSystem.out.println(list);\n\t\t\n\t\t\n\t\tList list2 = new ArrayList();\n\t\tlist2.add(\"陈七\");\n\t\tlist2.add(\"朱九\");\n\t\tlist2.add(\"陈七\");\n\t\tlist.addAll(2,list2);\n\t\tSystem.out.println(list);\n\t\t\n\t\t//get方法\n\t\tSystem.out.println(list.get(1)); \n\t\t\n\t\t//indexOf和lastIndexOf\n\t\tSystem.out.println(list2.indexOf(\"陈七\"));\n\t\tSystem.out.println(list2.lastIndexOf(\"陈七\"));\n\t\t\n\t\t//subList(int fromIndex, int toIndex);\n\t\t//在Java中，所有使用到区间范围的操作，全是要头不要尾；\n\t\tList sublist = list.subList(0, 5);\n\t\tSystem.out.println(sublist);\n\t\t\n\t\tlist.set(list.indexOf(\"张三\"), \"六六六\");\n\t\tSystem.out.println(list);\n\t\t\n\t\t\n\t}\n}\n\n\n\n\n\n\n\n\n\n"]],[8685,8685],[9652,9652]]],[1561726710922,["GJX@GJXAIOU",[[1,9658,"#"]],[9658,9658],[9659,9659]]],[1561726711477,["GJX@GJXAIOU",[[-1,9658,"#"]],[9659,9659],[9658,9658]]],[1561726717795,["GJX@GJXAIOU",[[1,9658,"### List迭代器"]],[9658,9658],[9669,9669]]],[1561726717831,["GJX@GJXAIOU",[[1,9666," "]],[9669,9669],[9670,9670]]],[1561726721136,["GJX@GJXAIOU",[[1,9670,"- LIs"]],[9670,9670],[9675,9675]]],[1561726722261,["GJX@GJXAIOU",[[-1,9673,"Is"]],[9675,9675],[9673,9673]]],[1561726725643,["GJX@GJXAIOU",[[1,9673,"istItea"]],[9673,9673],[9680,9680]]],[1561726726596,["GJX@GJXAIOU",[[-1,9679,"a"]],[9680,9680],[9679,9679]]],[1561726731657,["GJX@GJXAIOU",[[1,9679,"rator（）"]],[9679,9679],[9686,9686]]],[1561726732453,["GJX@GJXAIOU",[[-1,9684,"（）"]],[9686,9686],[9684,9684]]],[1561726733495,["GJX@GJXAIOU",[[1,9684,"()"]],[9684,9684],[9686,9686]]],[1561726734157,["GJX@GJXAIOU",[[1,9705,"\n"]],[9686,9686],[9687,9687]]],[1561726734297,["GJX@GJXAIOU",[[1,9706,"\n"]],[9687,9687],[9688,9688]]],[1561726744221,["GJX@GJXAIOU",[[1,9667,"特有"]],[9667,9667],[9669,9669]]],[1561726812866,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,9688,"\n\n"]],[8255,8255],[9690,9690]]],[1561726812866,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,9688,"\n\n"]],[9690,9690],[8255,8255]]],[1561726755989,["GJX@GJXAIOU",[[1,9709,"\n"]],[9689,9689],[9690,9690]]],[1561726759073,["GJX@GJXAIOU",[[1,9690,"方法："]],[9690,9690],[9693,9693]]],[1561726759487,["GJX@GJXAIOU",[[1,9713,"\n"]],[9693,9693],[9694,9694]]],[1561726766663,["GJX@GJXAIOU",[[1,9694,"- hasNext();"]],[9694,9694],[9706,9706]]],[1561726767069,["GJX@GJXAIOU",[[1,9707,"- \n"]],[9706,9706],[9709,9709]]],[1561726771527,["GJX@GJXAIOU",[[1,9709,"next();"]],[9709,9709],[9716,9716]]],[1561726771789,["GJX@GJXAIOU",[[1,9717,"- \n"]],[9716,9716],[9719,9719]]],[1561726776033,["GJX@GJXAIOU",[[1,9719,"remove();"]],[9719,9719],[9728,9728]]],[1561726776279,["GJX@GJXAIOU",[[1,9729,"- \n"]],[9728,9728],[9731,9731]]],[1561726780538,["GJX@GJXAIOU",[[1,9731,"add()"]],[9731,9731],[9736,9736]]],[1561726785239,["GJX@GJXAIOU",[[1,9735,"Object 0"]],[9735,9735],[9743,9743]]],[1561726804225,["GJX@GJXAIOU",[[1,9744,"; //在当前迭代器指向的位置上，天剑"]],[9744,9744],[9763,9763]]],[1561726804886,["GJX@GJXAIOU",[[-1,9761,"天剑"]],[9763,9763],[9761,9761]]],[1561726809268,["GJX@GJXAIOU",[[1,9761,"降价"]],[9761,9761],[9763,9763]]],[1561726810069,["GJX@GJXAIOU",[[-1,9761,"降价"]],[9763,9763],[9761,9761]]],[1561726812709,["GJX@GJXAIOU",[[1,9761,"添加元素"]],[9761,9761],[9765,9765]]],[1561726872868,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,9765,"\n\n"]],[8255,8255],[9767,9767]]],[1561726872868,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,9765,"\n\n"]],[9767,9767],[8255,8255]]],[1561726813562,["GJX@GJXAIOU",[[1,9765,"；"]],[9765,9765],[9766,9766]]],[1561726814718,["GJX@GJXAIOU",[[1,9767,"- \n"]],[9766,9766],[9769,9769]]],[1561726818080,["GJX@GJXAIOU",[[1,9769,"set()"]],[9769,9769],[9774,9774]]],[1561726822400,["GJX@GJXAIOU",[[1,9773,"Object 0"]],[9773,9773],[9781,9781]]],[1561726840970,["GJX@GJXAIOU",[[1,9782,"; //替换n"]],[9782,9782],[9789,9789]]],[1561726841009,["GJX@GJXAIOU",[[1,9788," "]],[9789,9789],[9790,9790]]],[1561726843473,["GJX@GJXAIOU",[[1,9790,"ext获取"]],[9790,9790],[9795,9795]]],[1561726843510,["GJX@GJXAIOU",[[1,9793," "]],[9795,9795],[9796,9796]]],[1561726845411,["GJX@GJXAIOU",[[1,9796,"到的元素怒"]],[9796,9796],[9801,9801]]],[1561726845853,["GJX@GJXAIOU",[[-1,9800,"怒"]],[9801,9801],[9800,9800]]],[1561726846377,["GJX@GJXAIOU",[[1,9800,"；"]],[9800,9800],[9801,9801]]],[1561726846782,["GJX@GJXAIOU",[[1,9802,"- \n"]],[9801,9801],[9804,9804]]],[1561726858817,["GJX@GJXAIOU",[[1,9804,"nextIndex(); //下一个匀速"]],[9804,9804],[9824,9824]]],[1561726859407,["GJX@GJXAIOU",[[-1,9822,"匀速"]],[9824,9824],[9822,9822]]],[1561726863944,["GJX@GJXAIOU",[[1,9822,"元素的下标；"]],[9822,9822],[9828,9828]]],[1561727472882,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,9828,"\n\n"]],[8255,8255],[9830,9830]]],[1561727472882,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,9828,"\n\n"]],[9830,9830],[8255,8255]]],[1561727434078,["GJX@GJXAIOU",[[-1,9765,"；"]],[9766,9766],[9765,9765]]],[1561727443611,["GJX@GJXAIOU",[[1,9765,"，其他元素向后移动；"]],[9765,9765],[9775,9775]]],[1561727447928,["GJX@GJXAIOU",[[1,9690,"- "]],[9690,9690],[9692,9692]]],[1561727450704,["GJX@GJXAIOU",[[1,9696,"  "],[1,9709,"  "],[1,9719,"  "],[1,9731,"  "],[1,9778,"  "],[1,9813,"  "]],[9698,9838],[9700,9850]]],[1561728072895,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,9851,"\n\n"]],[8255,8255],[9853,9853]]],[1561728072895,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,9851,"\n\n"]],[9853,9853],[8255,8255]]],[1561728064188,["GJX@GJXAIOU",[[1,9854,"代码示例："]],[9854,9854],[9859,9859]]],[1561728064597,["GJX@GJXAIOU",[[1,9876,"\n"]],[9859,9859],[9860,9860]]],[1561728066345,["GJX@GJXAIOU",[[1,9860,"```"]],[9860,9860],[9863,9863]]],[1561728066383,["GJX@GJXAIOU",[[1,9863,"language\n```\n"]],[9863,9863],[9863,9871]]],[1561728067454,["GJX@GJXAIOU",[[-1,9863,"language"],[1,9871,"j"]],[9863,9871],[9864,9864]]],[1561728067846,["GJX@GJXAIOU",[[1,9864,"ava"]],[9864,9864],[9867,9867]]],[1561728067953,["GJX@GJXAIOU",[[1,9868,"\n"]],[9867,9867],[9868,9868]]],[1561728069062,["GJX@GJXAIOU",[[1,9868,"/**\n * \n */\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\n/**\n * class detail:ListIterator\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Listitetator_use {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();\n\t\tlist.add(\"小米\");\n\t\tlist.add(\"华为\");\n\t\tlist.add(\"苹果\");\n\t\t\n\t\t//获取List的特有迭代器\n\tListIterator iterator = list.listIterator();\n\t\n\tSystem.out.println(\"下一个元素\" + iterator.hasNext());\n\tSystem.out.println(\"next获取数据\" + iterator.next());\n\tSystem.out.println(\"set方法进行替换\");\n\titerator.set(\"mi\");\n\t\n\tSystem.out.println(\"添加内容：\");\n\titerator.add(\"VO\");\n\tSystem.out.println(list);\n\t\n\tSystem.out.println(iterator.nextIndex());\n\t}\n}\n\n\n\n\n"]],[9868,9868],[10575,10575]]],[1561728072046,["GJX@GJXAIOU",[[-1,9868,"/**\n * \n */"]],[9868,9879],[9868,9868]]],[1561728072596,["GJX@GJXAIOU",[[-1,9868,"\n"]],[9868,9868],[9867,9867]]],[1561728132896,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,10567,"\n\n"]],[8255,8255],[10569,10569]]],[1561728132896,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,10567,"\n\n"]],[10569,10569],[8255,8255]]],[1561728075771,["GJX@GJXAIOU",[[-1,10563,"\n"]],[10562,10563],[10562,10562]]],[1561728075900,["GJX@GJXAIOU",[[-1,10562,"\n"]],[10562,10562],[10561,10561]]],[1561728076060,["GJX@GJXAIOU",[[-1,10561,"\n"]],[10561,10561],[10560,10560]]],[1561728076259,["GJX@GJXAIOU",[[-1,10560,"\n"]],[10560,10560],[10559,10559]]],[1561728078343,["GJX@GJXAIOU",[[1,10581,"\n"]],[10563,10563],[10564,10564]]],[1561728078469,["GJX@GJXAIOU",[[1,10582,"\n"]],[10564,10564],[10565,10565]]],[1561728192898,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,10563,"\n\n"]],[8255,8255],[10565,10565]]],[1561728192898,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,10563,"\n\n"]],[10565,10565],[8255,8255]]],[1561728179092,["GJX@GJXAIOU",[[1,10565,"****"]],[10565,10565],[10567,10567]]],[1561728182648,["GJX@GJXAIOU",[[1,10567,"LIst"]],[10567,10567],[10571,10571]]],[1561728183652,["GJX@GJXAIOU",[[-1,10568,"Ist"]],[10571,10571],[10568,10568]]],[1561728186366,["GJX@GJXAIOU",[[1,10568,"istji"]],[10568,10568],[10573,10573]]],[1561728186859,["GJX@GJXAIOU",[[-1,10571,"ji"]],[10573,10573],[10571,10571]]],[1561728188538,["GJX@GJXAIOU",[[1,10571,"集合"]],[10571,10571],[10573,10573]]],[1561728188575,["GJX@GJXAIOU",[[1,10571," "]],[10573,10573],[10574,10574]]],[1561728192712,["GJX@GJXAIOU",[[1,10574,"的三种"]],[10574,10574],[10577,10577]]],[1561728252899,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,10579,"\n\n"]],[8255,8255],[10581,10581]]],[1561728252899,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,10579,"\n\n"]],[10581,10581],[8255,8255]]],[1561728195458,["GJX@GJXAIOU",[[1,10577,"遍历方式："]],[10577,10577],[10582,10582]]],[1561728197236,["GJX@GJXAIOU",[[1,10602,"\n"]],[10584,10584],[10585,10585]]],[1561728204130,["GJX@GJXAIOU",[[1,10585,"- for循环"]],[10585,10585],[10592,10592]]],[1561728204170,["GJX@GJXAIOU",[[1,10590," "]],[10592,10592],[10593,10593]]],[1561728204437,["GJX@GJXAIOU",[[1,10594,"- \n"]],[10593,10593],[10596,10596]]],[1561728207754,["GJX@GJXAIOU",[[1,10596,"迭代器"]],[10596,10596],[10599,10599]]],[1561728208061,["GJX@GJXAIOU",[[1,10600,"- \n"]],[10599,10599],[10602,10602]]],[1561728211912,["GJX@GJXAIOU",[[1,10602,"增强f"]],[10602,10602],[10605,10605]]],[1561728211951,["GJX@GJXAIOU",[[1,10604," "]],[10605,10605],[10606,10606]]],[1561728214875,["GJX@GJXAIOU",[[1,10606,"or循环"]],[10606,10606],[10610,10610]]],[1561728214913,["GJX@GJXAIOU",[[1,10608," "]],[10610,10610],[10611,10611]]],[1561728215333,["GJX@GJXAIOU",[[1,10611,"，"]],[10611,10611],[10612,10612]]],[1561728216502,["GJX@GJXAIOU",[[-1,10611,"，"]],[10612,10612],[10611,10611]]],[1561728217767,["GJX@GJXAIOU",[[1,10612,"- \n"]],[10611,10611],[10614,10614]]],[1561728219083,["GJX@GJXAIOU",[[-1,10612,"- "]],[10614,10614],[10612,10612]]],[1561728220007,["GJX@GJXAIOU",[[1,10630,"\n"]],[10612,10612],[10613,10613]]],[1561729392920,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,10611,"\n\n"]],[8255,8255],[10613,10613]]],[1561729392920,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,10611,"\n\n"]],[10613,10613],[8255,8255]]],[1561729387333,["GJX@GJXAIOU",[[1,10613,"```"]],[10613,10613],[10616,10616]]],[1561729387377,["GJX@GJXAIOU",[[1,10616,"language\n```\n"]],[10616,10616],[10616,10624]]],[1561729388566,["GJX@GJXAIOU",[[-1,10616,"language"],[1,10624,"j"]],[10616,10624],[10617,10617]]],[1561729388976,["GJX@GJXAIOU",[[1,10617,"ava"]],[10617,10617],[10620,10620]]],[1561729389213,["GJX@GJXAIOU",[[1,10621,"\n"]],[10620,10620],[10621,10621]]],[1561729390375,["GJX@GJXAIOU",[[1,10621,"/**\n * \n */\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\n/**\n * class detail:\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class ListBianLi {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();\n\t\t\n\t\tlist.add(\"A\");\n\t\tlist.add(\"B\");\n\t\tlist.add(\"C\");\n\t\tlist.add(\"D\");\n\t\tlist.add(\"E\");\n\t\t\n\t\t//使用for循环进行遍历：使用get(int index)  和size()方法\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i));\n\t\t}\n\t\t\n\t\tSystem.out.println(\"*********************\");\n\t\t\n\t\t//使用ListIterator迭代器\n\t\tListIterator iterator = list.listIterator();\n\t\t\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(iterator.next());\n\t\t\t}\n\t\t\n\t\tSystem.out.println(\"*********************\");\n\t\t\n\t\t//增强for循环：实质为迭代器的实现\n\t\tfor(Object object : list) {  //数据类型  变量名\n\t\t\tSystem.out.println(object);\n\t\t}\n\t\t\n\t\t\n\t}\n}\n\n\n\n\n\n\n\n\n\n"]],[10621,10621],[11487,11487]]],[1561729452922,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11491,"\n\n"]],[8255,8255],[11493,11493]]],[1561729452922,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11491,"\n\n"]],[11493,11493],[8255,8255]]],[1561729393573,["GJX@GJXAIOU",[[1,11510,"\n"]],[11491,11491],[11492,11492]]],[1561729393716,["GJX@GJXAIOU",[[1,11511,"\n"]],[11492,11492],[11493,11493]]],[1561729395567,["GJX@GJXAIOU",[[1,11493,"#"]],[11493,11493],[11494,11494]]],[1561729398110,["GJX@GJXAIOU",[[-1,11493,"#"]],[11494,11494],[11493,11493]]],[1561729436635,["GJX@GJXAIOU",[[-1,11480,"\n\n\n\n\n\n\n\n"]],[11479,11487],[11479,11479]]],[1561729512923,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11483,"\n\n"]],[8255,8255],[11485,11485]]],[1561729512923,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11483,"\n\n"]],[11485,11485],[8255,8255]]],[1561729479971,["GJX@GJXAIOU",[[1,11479," "]],[11479,11479],[11480,11480]]],[1561729632928,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11484,"\n\n"]],[8255,8255],[11486,11486]]],[1561729632928,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11484,"\n\n"]],[11486,11486],[8255,8255]]],[1561729619436,["GJX@GJXAIOU",[[-1,11471,"\t"]],[11471,11471],[11470,11470]]],[1561729620108,["GJX@GJXAIOU",[[-1,11469,"\n"]],[11470,11470],[11469,11469]]],[1561729621553,["GJX@GJXAIOU",[[-1,11468,"\t\t"]],[11469,11469],[11467,11467]]],[1561729621969,["GJX@GJXAIOU",[[-1,11466,"\n"]],[11467,11467],[11466,11466]]],[1561729627019,["GJX@GJXAIOU",[[-1,11473,"\n"]],[11474,11474],[11473,11473]]],[1561729627682,["GJX@GJXAIOU",[[-1,11472,"\n"]],[11473,11473],[11472,11472]]],[1561729692928,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11477,"\n\n"]],[8255,8255],[11479,11479]]],[1561729692928,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11477,"\n\n"]],[11479,11479],[8255,8255]]],[1561729635717,["GJX@GJXAIOU",[[-1,10621,"/**\n * \n */"]],[10621,10632],[10621,10621]]],[1561729636521,["GJX@GJXAIOU",[[-1,10621,"\n"]],[10621,10621],[10620,10620]]],[1561729642876,["GJX@GJXAIOU",[[-1,10720,"/**\n * class detail:\n * @author GJXAIOU\n * @since  2019年6月28日\n */"]],[10720,10785],[10720,10720]]],[1561729643437,["GJX@GJXAIOU",[[-1,10720,"\n"]],[10720,10720],[10719,10719]]],[1561729648234,["GJX@GJXAIOU",[[1,11420,"\n"]],[11399,11399],[11400,11400]]],[1561729648659,["GJX@GJXAIOU",[[1,11421,"\n"]],[11400,11400],[11401,11401]]],[1561730112935,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11399,"\n\n"]],[8255,8255],[11401,11401]]],[1561730112935,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11399,"\n\n"]],[11401,11401],[8255,8255]]],[1561730098892,["GJX@GJXAIOU",[[1,11402,"## "]],[11402,11402],[11405,11405]]],[1561730101388,["GJX@GJXAIOU",[[1,11404,"#"]],[11405,11405],[11406,11406]]],[1561730112100,["GJX@GJXAIOU",[[1,11406,"ArrayList"]],[11406,11406],[11415,11415]]],[1561730172937,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11415,"\n\n"]],[8255,8255],[11417,11417]]],[1561730172937,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11415,"\n\n"]],[11417,11417],[8255,8255]]],[1561730115445,["GJX@GJXAIOU",[[1,11415," ["]],[11415,11415],[11417,11417]]],[1561730116657,["GJX@GJXAIOU",[[-1,11416,"["]],[11417,11417],[11416,11416]]],[1561730117375,["GJX@GJXAIOU",[[1,11416,"】"]],[11416,11416],[11417,11417]]],[1561730118156,["GJX@GJXAIOU",[[-1,11416,"】"]],[11417,11417],[11416,11416]]],[1561730122641,["GJX@GJXAIOU",[[1,11416,"【中的"]],[11416,11416],[11419,11419]]],[1561730123361,["GJX@GJXAIOU",[[-1,11417,"中的"]],[11419,11419],[11417,11417]]],[1561730126590,["GJX@GJXAIOU",[[1,11417,"重点】"]],[11417,11417],[11420,11420]]],[1561730127517,["GJX@GJXAIOU",[[1,11440,"\n"]],[11420,11420],[11421,11421]]],[1561730352941,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11420,"\n\n"]],[8255,8255],[11422,11422]]],[1561730352941,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11420,"\n\n"]],[11422,11422],[8255,8255]]],[1561730303672,["GJX@GJXAIOU",[[1,11421,"ArrayListshi"]],[11421,11421],[11433,11433]]],[1561730304658,["GJX@GJXAIOU",[[-1,11430,"shi"]],[11433,11433],[11430,11430]]],[1561730305506,["GJX@GJXAIOU",[[1,11430,"是"]],[11430,11430],[11431,11431]]],[1561730305546,["GJX@GJXAIOU",[[1,11430," "]],[11431,11431],[11432,11432]]],[1561730315505,["GJX@GJXAIOU",[[1,11432,"底层维护了一个Object"]],[11432,11432],[11445,11445]]],[1561730315543,["GJX@GJXAIOU",[[1,11439," "]],[11445,11445],[11446,11446]]],[1561730317617,["GJX@GJXAIOU",[[1,11446,"类型"]],[11446,11446],[11448,11448]]],[1561730317656,["GJX@GJXAIOU",[[1,11446," "]],[11448,11448],[11449,11449]]],[1561730331318,["GJX@GJXAIOU",[[1,11449,"的数组，这样的话这个ArrayList"]],[11449,11449],[11468,11468]]],[1561730331358,["GJX@GJXAIOU",[[1,11459," "]],[11468,11468],[11469,11469]]],[1561730334256,["GJX@GJXAIOU",[[1,11469,"皆可以"]],[11469,11469],[11472,11472]]],[1561730334295,["GJX@GJXAIOU",[[1,11469," "]],[11472,11472],[11473,11473]]],[1561730335383,["GJX@GJXAIOU",[[-1,11470,"皆可以"]],[11473,11473],[11470,11470]]],[1561730347785,["GJX@GJXAIOU",[[1,11470,"既可以保存任意类型的数据"]],[11470,11470],[11482,11482]]],[1561730413009,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11482,"\n\n"]],[8255,8255],[11484,11484]]],[1561730413009,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11482,"\n\n"]],[11484,11484],[8255,8255]]],[1561730364694,["GJX@GJXAIOU",[[1,11482,"，又有数组的优势；"]],[11482,11482],[11491,11491]]],[1561730365190,["GJX@GJXAIOU",[[1,11511,"\n"]],[11491,11491],[11492,11492]]],[1561730368446,["GJX@GJXAIOU",[[1,11492,"特征："]],[11492,11492],[11495,11495]]],[1561730370110,["GJX@GJXAIOU",[[1,11515,"\n"]],[11495,11495],[11496,11496]]],[1561730374093,["GJX@GJXAIOU",[[1,11492,"\n"]],[11492,11492],[11493,11493]]],[1561730374741,["GJX@GJXAIOU",[[1,11493,"- "]],[11493,11493],[11495,11495]]],[1561730390336,["GJX@GJXAIOU",[[1,11499,"  - 当调用无参构造方法ArrayList"]],[11499,11499],[11521,11521]]],[1561730390374,["GJX@GJXAIOU",[[1,11512," "]],[11521,11521],[11522,11522]]],[1561730402344,["GJX@GJXAIOU",[[1,11522,"，这里创建的底层Object"]],[11522,11522],[11536,11536]]],[1561730402383,["GJX@GJXAIOU",[[1,11530," "]],[11536,11536],[11537,11537]]],[1561730404759,["GJX@GJXAIOU",[[1,11537,"类型"]],[11537,11537],[11539,11539]]],[1561730404799,["GJX@GJXAIOU",[[1,11537," "]],[11539,11539],[11540,11540]]],[1561730412904,["GJX@GJXAIOU",[[1,11540,"的数组元素个数默认"]],[11540,11540],[11549,11549]]],[1561730473010,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11549,"\n\n"]],[8255,8255],[11551,11551]]],[1561730473010,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11549,"\n\n"]],[11551,11551],[8255,8255]]],[1561730414034,["GJX@GJXAIOU",[[1,11549,"Wie"]],[11549,11549],[11552,11552]]],[1561730414075,["GJX@GJXAIOU",[[1,11549," "]],[11552,11552],[11553,11553]]],[1561730415085,["GJX@GJXAIOU",[[1,11553,"0"]],[11553,11553],[11554,11554]]],[1561730416470,["GJX@GJXAIOU",[[-1,11550,"Wie0"]],[11554,11554],[11550,11550]]],[1561730418149,["GJX@GJXAIOU",[[1,11550,"为0"]],[11550,11550],[11552,11552]]],[1561730418189,["GJX@GJXAIOU",[[1,11551," "]],[11552,11552],[11553,11553]]],[1561730420538,["GJX@GJXAIOU",[[-1,11549," 为 0"]],[11553,11553],[11549,11549]]],[1561730422111,["GJX@GJXAIOU",[[1,11549,"为1"]],[11549,11549],[11551,11551]]],[1561730422151,["GJX@GJXAIOU",[[1,11550," "]],[11551,11551],[11552,11552]]],[1561730432708,["GJX@GJXAIOU",[[1,11552,"0 ，即D"]],[11552,11552],[11557,11557]]],[1561730432748,["GJX@GJXAIOU",[[1,11556," "]],[11557,11557],[11558,11558]]],[1561730433503,["GJX@GJXAIOU",[[1,11558,"D"]],[11558,11558],[11559,11559]]],[1561730433985,["GJX@GJXAIOU",[[-1,11558,"D"]],[11559,11559],[11558,11558]]],[1561730448932,["GJX@GJXAIOU",[[1,11558,"EFAULT_CAPACITY = 10"]],[11558,11558],[11578,11578]]],[1561730450730,["GJX@GJXAIOU",[[1,11579,"  - \n"]],[11578,11578],[11583,11583]]],[1561730454380,["GJX@GJXAIOU",[[1,11583,"shu"]],[11583,11583],[11586,11586]]],[1561730455057,["GJX@GJXAIOU",[[-1,11583,"shu"]],[11586,11586],[11583,11583]]],[1561730472462,["GJX@GJXAIOU",[[1,11583,"数组查询快、增删慢的特征；"]],[11583,11583],[11596,11596]]],[1561730533015,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11596,"\n\n"]],[8255,8255],[11598,11598]]],[1561730533015,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11596,"\n\n"]],[11598,11598],[8255,8255]]],[1561730474477,["GJX@GJXAIOU",[[1,11578,"；"]],[11578,11578],[11579,11579]]],[1561730477421,["GJX@GJXAIOU",[[1,11598,"  - \n"]],[11597,11597],[11602,11602]]],[1561730494578,["GJX@GJXAIOU",[[-1,11598,"  "]],[11602,11602],[11600,11600]]],[1561730502488,["GJX@GJXAIOU",[[1,11600,"开发中使用较多的场景："]],[11600,11600],[11611,11611]]],[1561730503365,["GJX@GJXAIOU",[[1,11612,"- \n"]],[11611,11611],[11614,11614]]],[1561730504851,["GJX@GJXAIOU",[[1,11612,"  "]],[11614,11614],[11616,11616]]],[1561730508882,["GJX@GJXAIOU",[[1,11616,"需要"]],[11616,11616],[11618,11618]]],[1561730511076,["GJX@GJXAIOU",[[-1,11616,"需要"]],[11618,11618],[11616,11616]]],[1561730528231,["GJX@GJXAIOU",[[1,11616,"查询场景较多但是增删较少的晨曦"]],[11616,11616],[11631,11631]]],[1561730528936,["GJX@GJXAIOU",[[-1,11629,"晨曦"]],[11631,11631],[11629,11629]]],[1561730532397,["GJX@GJXAIOU",[[1,11629,"程序：例如"]],[11629,11629],[11634,11634]]],[1561730593013,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11634,"\n\n"]],[8255,8255],[11636,11636]]],[1561730593013,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11634,"\n\n"]],[11636,11636],[8255,8255]]],[1561730545816,["GJX@GJXAIOU",[[1,11634,"：图书馆管理系统，人员管理系统；"]],[11634,11634],[11650,11650]]],[1561730554452,["GJX@GJXAIOU",[[1,11651,"  - \n"]],[11650,11650],[11655,11655]]],[1561730554602,["GJX@GJXAIOU",[[-1,11651,"  - "]],[11655,11655],[11652,11652]]],[1561730554796,["GJX@GJXAIOU",[[1,11671,"\n"]],[11652,11652],[11653,11653]]],[1561730563958,["GJX@GJXAIOU",[[1,11653,"- ArrayList特有"]],[11653,11653],[11666,11666]]],[1561730563999,["GJX@GJXAIOU",[[1,11664," "]],[11666,11666],[11667,11667]]],[1561730566885,["GJX@GJXAIOU",[[1,11667,"的方法："]],[11667,11667],[11671,11671]]],[1561730567113,["GJX@GJXAIOU",[[1,11672,"- \n"]],[11671,11671],[11674,11674]]],[1561730568066,["GJX@GJXAIOU",[[1,11672,"  "]],[11674,11674],[11676,11676]]],[1561730579979,["GJX@GJXAIOU",[[1,11676,"ensureCapacity（）"]],[11676,11676],[11692,11692]]],[1561730581281,["GJX@GJXAIOU",[[-1,11690,"（）"]],[11692,11692],[11690,11690]]],[1561730582507,["GJX@GJXAIOU",[[1,11690,"(0"]],[11690,11690],[11692,11692]]],[1561730584092,["GJX@GJXAIOU",[[-1,11691,"0"]],[11692,11692],[11691,11691]]],[1561730584444,["GJX@GJXAIOU",[[1,11691,")"]],[11691,11691],[11692,11692]]],[1561730592501,["GJX@GJXAIOU",[[1,11691,"int minCapacity"]],[11691,11691],[11706,11706]]],[1561730653013,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11707,"\n\n"]],[8255,8255],[11709,11709]]],[1561730653013,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11707,"\n\n"]],[11709,11709],[8255,8255]]],[1561730603623,["GJX@GJXAIOU",[[1,11707,"; //判断当前ArrayList"]],[11707,11707],[11724,11724]]],[1561730603662,["GJX@GJXAIOU",[[1,11715," "]],[11724,11724],[11725,11725]]],[1561730606314,["GJX@GJXAIOU",[[1,11725,"里面"]],[11725,11725],[11727,11727]]],[1561730606356,["GJX@GJXAIOU",[[1,11725," "]],[11727,11727],[11728,11728]]],[1561730611638,["GJX@GJXAIOU",[[1,11728,"保存的"]],[11728,11728],[11731,11731]]],[1561730713016,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11731,"\n\n"]],[8255,8255],[11733,11733]]],[1561730713016,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11731,"\n\n"]],[11733,11733],[8255,8255]]],[1561730660938,["GJX@GJXAIOU",[[-1,11730,"的"]],[11731,11731],[11730,11730]]],[1561730670263,["GJX@GJXAIOU",[[1,11730,"元素内容Obje"]],[11730,11730],[11738,11738]]],[1561730670304,["GJX@GJXAIOU",[[1,11734," "]],[11738,11738],[11739,11739]]],[1561730676570,["GJX@GJXAIOU",[[1,11739,"ct数组"]],[11739,11739],[11743,11743]]],[1561730676609,["GJX@GJXAIOU",[[1,11741," "]],[11743,11743],[11744,11744]]],[1561730682103,["GJX@GJXAIOU",[[1,11744,"，袁术个数"]],[11744,11744],[11749,11749]]],[1561730684266,["GJX@GJXAIOU",[[-1,11745,"袁术个数"]],[11749,11749],[11745,11745]]],[1561730689856,["GJX@GJXAIOU",[[1,11745,"元素个数是够"]],[11745,11745],[11751,11751]]],[1561730690586,["GJX@GJXAIOU",[[-1,11749,"是够"]],[11751,11751],[11749,11749]]],[1561730696856,["GJX@GJXAIOU",[[1,11749,"是否大于min"]],[11749,11749],[11756,11756]]],[1561730696896,["GJX@GJXAIOU",[[1,11753," "]],[11756,11756],[11757,11757]]],[1561730704085,["GJX@GJXAIOU",[[1,11757,"Capacity;"]],[11757,11757],[11766,11766]]],[1561730704763,["GJX@GJXAIOU",[[1,11767,"  - \n"]],[11766,11766],[11771,11771]]],[1561730773017,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11771,"\n\n"]],[8255,8255],[11773,11773]]],[1561730773017,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11771,"\n\n"]],[11773,11773],[8255,8255]]],[1561730719536,["GJX@GJXAIOU",[[1,11771,"trimToSize(); 、、"]],[11771,11771],[11787,11787]]],[1561730720156,["GJX@GJXAIOU",[[-1,11785,"、、"]],[11787,11787],[11785,11785]]],[1561730721174,["GJX@GJXAIOU",[[1,11785,"、、"]],[11785,11785],[11787,11787]]],[1561730722091,["GJX@GJXAIOU",[[-1,11785,"、、"]],[11787,11787],[11785,11785]]],[1561730723767,["GJX@GJXAIOU",[[1,11785,"、"]],[11785,11785],[11786,11786]]],[1561730724473,["GJX@GJXAIOU",[[-1,11785,"、"]],[11786,11786],[11785,11785]]],[1561730725180,["GJX@GJXAIOU",[[1,11785,"//"]],[11785,11785],[11787,11787]]],[1561730729318,["GJX@GJXAIOU",[[1,11671,"dou"]],[11671,11671],[11674,11674]]],[1561730729953,["GJX@GJXAIOU",[[-1,11671,"dou"]],[11674,11674],[11671,11671]]],[1561730736001,["GJX@GJXAIOU",[[1,11671,"都不太常用"]],[11671,11671],[11676,11676]]],[1561730740045,["GJX@GJXAIOU",[[1,11792,"d"]],[11792,11792],[11793,11793]]],[1561730740386,["GJX@GJXAIOU",[[-1,11792,"d"]],[11793,11793],[11792,11792]]],[1561730753494,["GJX@GJXAIOU",[[1,11792,"截断底层维护的Object"]],[11792,11792],[11805,11805]]],[1561730753534,["GJX@GJXAIOU",[[1,11799," "]],[11805,11805],[11806,11806]]],[1561730759934,["GJX@GJXAIOU",[[1,11806,"类型"]],[11806,11806],[11808,11808]]],[1561730759975,["GJX@GJXAIOU",[[1,11806," "]],[11808,11808],[11809,11809]]],[1561730763317,["GJX@GJXAIOU",[[1,11809,"的数组，"]],[11809,11809],[11813,11813]]],[1561730833020,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11813,"\n\n"]],[8255,8255],[11815,11815]]],[1561730833020,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11813,"\n\n"]],[11815,11815],[8255,8255]]],[1561730797254,["GJX@GJXAIOU",[[1,11813,"让数组容量变成当前ArrayList"]],[11813,11813],[11831,11831]]],[1561730797294,["GJX@GJXAIOU",[[1,11822," "]],[11831,11831],[11832,11832]]],[1561730799378,["GJX@GJXAIOU",[[1,11832,"的"]],[11832,11832],[11833,11833]]],[1561730799418,["GJX@GJXAIOU",[[1,11832," "]],[11833,11833],[11834,11834]]],[1561730803912,["GJX@GJXAIOU",[[1,11834,"size"]],[11834,11834],[11838,11838]]],[1561730803951,["GJX@GJXAIOU",[[1,11834," "]],[11838,11838],[11839,11839]]],[1561730805200,["GJX@GJXAIOU",[[1,11839,"值"]],[11839,11839],[11840,11840]]],[1561730805240,["GJX@GJXAIOU",[[1,11839," "]],[11840,11840],[11841,11841]]],[1561730806223,["GJX@GJXAIOU",[[1,11841,"（）"]],[11841,11841],[11843,11843]]],[1561730818989,["GJX@GJXAIOU",[[1,11842,"有效元素个数"]],[11842,11842],[11848,11848]]],[1561730953023,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11849,"\n\n"]],[8255,8255],[11851,11851]]],[1561730953023,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11849,"\n\n"]],[11851,11851],[8255,8255]]],[1561730920799,["GJX@GJXAIOU",[[1,11851,"- 查询快、增删慢的原理："]],[11851,11851],[11864,11864]]],[1561730921139,["GJX@GJXAIOU",[[1,11865,"- \n"]],[11864,11864],[11867,11867]]],[1561730922532,["GJX@GJXAIOU",[[1,11865,"  "]],[11867,11867],[11869,11869]]],[1561730947560,["GJX@GJXAIOU",[[1,11869,"查询快：因为底层维护的是一个Object"]],[11869,11869],[11889,11889]]],[1561730947601,["GJX@GJXAIOU",[[1,11883," "]],[11889,11889],[11890,11890]]],[1561730951791,["GJX@GJXAIOU",[[1,11890,"类型"]],[11890,11890],[11892,11892]]],[1561730951831,["GJX@GJXAIOU",[[1,11890," "]],[11892,11892],[11893,11893]]],[1561730952105,["GJX@GJXAIOU",[[1,11893,"的"]],[11893,11893],[11894,11894]]],[1561731013022,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11894,"\n\n"]],[8255,8255],[11896,11896]]],[1561731013022,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11894,"\n\n"]],[11896,11896],[8255,8255]]],[1561730957001,["GJX@GJXAIOU",[[1,11894,"数组，可以往前"]],[11894,11894],[11901,11901]]],[1561730958968,["GJX@GJXAIOU",[[-1,11897,"可以往前"]],[11901,11901],[11897,11897]]],[1561730991670,["GJX@GJXAIOU",[[1,11897,"可以完全使用数组的下标机制来访问数据，这种访问的形式是非常快的；"]],[11897,11897],[11929,11929]]],[1561730992484,["GJX@GJXAIOU",[[1,11930,"  - \n"]],[11929,11929],[11934,11934]]],[1561730996981,["GJX@GJXAIOU",[[1,11934,"增删慢："]],[11934,11934],[11938,11938]]],[1561731553057,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11938,"\n\n"]],[8255,8255],[11940,11940]]],[1561731553057,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11938,"\n\n"]],[11940,11940],[8255,8255]]],[1561731506853,["GJX@GJXAIOU",[[1,11938,"增加和删除都会拷贝，"]],[11938,11938],[11948,11948]]],[1561731516433,["GJX@GJXAIOU",[[-1,11938,"增加和删除都会拷贝，"]],[11948,11948],[11938,11938]]],[1561731527381,["GJX@GJXAIOU",[[1,11938,"增加数据时候，可能导致ArrayList"]],[11938,11938],[11958,11958]]],[1561731527422,["GJX@GJXAIOU",[[1,11949," "]],[11958,11958],[11959,11959]]],[1561731529478,["GJX@GJXAIOU",[[1,11959,"底层"]],[11959,11959],[11961,11961]]],[1561731529519,["GJX@GJXAIOU",[[1,11959," "]],[11961,11961],[11962,11962]]],[1561731533574,["GJX@GJXAIOU",[[1,11962,"的Object"]],[11962,11962],[11969,11969]]],[1561731533615,["GJX@GJXAIOU",[[1,11963," "]],[11969,11969],[11970,11970]]],[1561731536473,["GJX@GJXAIOU",[[1,11970,"数组"]],[11970,11970],[11972,11972]]],[1561731536514,["GJX@GJXAIOU",[[1,11970," "]],[11972,11972],[11973,11973]]],[1561731539065,["GJX@GJXAIOU",[[1,11973,"的元素的"]],[11973,11973],[11977,11977]]],[1561731540498,["GJX@GJXAIOU",[[-1,11976,"的"]],[11977,11977],[11976,11976]]],[1561731552911,["GJX@GJXAIOU",[[1,11976,"不够用，那么会调用数组的"]],[11976,11976],[11988,11988]]],[1561731613053,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,11988,"\n\n"]],[8255,8255],[11990,11990]]],[1561731613053,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,11988,"\n\n"]],[11990,11990],[8255,8255]]],[1561731561519,["GJX@GJXAIOU",[[1,11988,"扩容方法f"]],[11988,11988],[11993,11993]]],[1561731561561,["GJX@GJXAIOU",[[1,11992," "]],[11993,11993],[11994,11994]]],[1561731561971,["GJX@GJXAIOU",[[-1,11993,"f"]],[11994,11994],[11993,11993]]],[1561731572607,["GJX@GJXAIOU",[[1,11993,"grow，而扩容方法"]],[11993,11993],[12003,12003]]],[1561731673054,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,12003,"\n\n"]],[8255,8255],[12005,12005]]],[1561731673054,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,12003,"\n\n"]],[12005,12005],[8255,8255]]],[1561731648705,["GJX@GJXAIOU",[[1,12003,"会创建银行股IE"]],[12003,12003],[12011,12011]]],[1561731650450,["GJX@GJXAIOU",[[-1,12006,"银行股IE"]],[12011,12011],[12006,12006]]],[1561731659854,["GJX@GJXAIOU",[[1,12006,"一个新的数组，数组的元素待遇"]],[12006,12006],[12020,12020]]],[1561731660858,["GJX@GJXAIOU",[[-1,12018,"待遇"]],[12020,12020],[12018,12018]]],[1561731671882,["GJX@GJXAIOU",[[1,12018,"大于原来数组，同时会将"]],[12018,12018],[12029,12029]]],[1561731733055,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,12029,"\n\n"]],[8255,8255],[12031,12031]]],[1561731733055,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,12029,"\n\n"]],[12031,12031],[8255,8255]]],[1561731690053,["GJX@GJXAIOU",[[1,12029,"源数据拷贝到新数组中，拷贝过程耗费实际"]],[12029,12029],[12048,12048]]],[1561731690896,["GJX@GJXAIOU",[[-1,12046,"实际"]],[12048,12048],[12046,12046]]],[1561731694047,["GJX@GJXAIOU",[[1,12046,"时间；"]],[12046,12046],[12049,12049]]],[1561731694321,["GJX@GJXAIOU",[[1,12050,"  - \n"]],[12049,12049],[12054,12054]]],[1561731699926,["GJX@GJXAIOU",[[1,12054,"删除满："]],[12054,12054],[12058,12058]]],[1561731700473,["GJX@GJXAIOU",[[-1,12056,"满："]],[12058,12058],[12056,12056]]],[1561731701061,["GJX@GJXAIOU",[[1,12056,"，"]],[12056,12056],[12057,12057]]],[1561731702203,["GJX@GJXAIOU",[[-1,12056,"，"]],[12057,12057],[12056,12056]]],[1561731722911,["GJX@GJXAIOU",[[1,12056,"慢：因为删除一个数据，会导致数组中该元素之后的而所有"]],[12056,12056],[12082,12082]]],[1561731724521,["GJX@GJXAIOU",[[-1,12079,"而"]],[12080,12080],[12079,12079]]],[1561731732037,["GJX@GJXAIOU",[[1,12081,"数据做一个整体的"]],[12081,12081],[12089,12089]]],[1561731793055,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,12089,"\n\n"]],[8255,8255],[12091,12091]]],[1561731793055,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,12089,"\n\n"]],[12091,12091],[8255,8255]]],[1561731733756,["GJX@GJXAIOU",[[1,12089,"座椅，"]],[12089,12089],[12092,12092]]],[1561731736640,["GJX@GJXAIOU",[[-1,12089,"座椅，"]],[12092,12092],[12089,12089]]],[1561731757128,["GJX@GJXAIOU",[[1,12089,"左移，这也是一次数组的拷贝，浪费时间；"]],[12089,12089],[12108,12108]]],[1561732033062,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,12108,"\n\n"]],[8255,8255],[12110,12110]]],[1561732033062,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,12108,"\n\n"]],[12110,12110],[8255,8255]]],[1561732016321,["GJX@GJXAIOU",[[1,12125,"\n"]],[12109,12109],[12110,12110]]],[1561732023214,["GJX@GJXAIOU",[[1,12110,"ArrayList是"]],[12110,12110],[12120,12120]]],[1561732023256,["GJX@GJXAIOU",[[1,12119," "]],[12120,12120],[12121,12121]]],[1561732023737,["GJX@GJXAIOU",[[1,12121,"一个"]],[12121,12121],[12123,12123]]],[1561732028800,["GJX@GJXAIOU",[[1,12110,"问 "]],[12110,12110],[12111,12111]]],[1561732029007,["GJX@GJXAIOU",[[1,12111,"："]],[12111,12111],[12112,12112]]],[1561732093064,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,12126,"\n\n"]],[8255,8255],[12128,12128]]],[1561732093064,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,12126,"\n\n"]],[12128,12128],[8255,8255]]],[1561732078095,["GJX@GJXAIOU",[[1,12126,"可以自增长的空间，请问，增加的原理是什么？增长的长度是多少？"]],[12126,12126],[12156,12156]]],[1561732153068,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,12156,"\n\n"]],[8255,8255],[12158,12158]]],[1561732153068,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,12156,"\n\n"]],[12158,12158],[8255,8255]]],[1561732101488,["GJX@GJXAIOU",[[1,12172,"\n"]],[12156,12156],[12157,12157]]],[1561732213070,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,12156,"\n\n"]],[8255,8255],[12158,12158]]],[1561732213070,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,12156,"\n\n"]],[12158,12158],[8255,8255]]],[1561732196054,["GJX@GJXAIOU",[[1,12157,"ArrayList底层"]],[12157,12157],[12168,12168]]],[1561732196095,["GJX@GJXAIOU",[[1,12166," "]],[12168,12168],[12169,12169]]],[1561732197198,["GJX@GJXAIOU",[[1,12169,"委会"]],[12169,12169],[12171,12171]]],[1561732198684,["GJX@GJXAIOU",[[-1,12169,"委会"]],[12171,12171],[12169,12169]]],[1561732205542,["GJX@GJXAIOU",[[1,12169,"维护的是一个Object"]],[12169,12169],[12181,12181]]],[1561732205583,["GJX@GJXAIOU",[[1,12175," "]],[12181,12181],[12182,12182]]],[1561732207119,["GJX@GJXAIOU",[[1,12182,"数组"]],[12182,12182],[12184,12184]]],[1561732207159,["GJX@GJXAIOU",[[1,12182," "]],[12184,12184],[12185,12185]]],[1561732212638,["GJX@GJXAIOU",[[1,12185,"，默认的元素个数"]],[12185,12185],[12193,12193]]],[1561732273074,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,12193,"\n\n"]],[8255,8255],[12195,12195]]],[1561732273074,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,12193,"\n\n"]],[12195,12195],[8255,8255]]],[1561732213852,["GJX@GJXAIOU",[[1,12193,"为1"]],[12193,12193],[12195,12195]]],[1561732213893,["GJX@GJXAIOU",[[1,12194," "]],[12195,12195],[12196,12196]]],[1561732235801,["GJX@GJXAIOU",[[1,12196,"0，如果添加元素，当前需求的元素空间超过了Object"]],[12196,12196],[12223,12223]]],[1561732235842,["GJX@GJXAIOU",[[1,12217," "]],[12223,12223],[12224,12224]]],[1561732238673,["GJX@GJXAIOU",[[1,12224,"数组"]],[12224,12224],[12226,12226]]],[1561732238713,["GJX@GJXAIOU",[[1,12224," "]],[12226,12226],[12227,12227]]],[1561732248831,["GJX@GJXAIOU",[[1,12227,"的元素个数，会调用底层的g"]],[12227,12227],[12240,12240]]],[1561732248872,["GJX@GJXAIOU",[[1,12239," "]],[12240,12240],[12241,12241]]],[1561732249638,["GJX@GJXAIOU",[[1,12241,"roe"]],[12241,12241],[12244,12244]]],[1561732250225,["GJX@GJXAIOU",[[-1,12243,"e"]],[12244,12244],[12243,12243]]],[1561732252101,["GJX@GJXAIOU",[[1,12243,"w方法"]],[12243,12243],[12246,12246]]],[1561732252141,["GJX@GJXAIOU",[[1,12244," "]],[12246,12246],[12247,12247]]],[1561732266191,["GJX@GJXAIOU",[[1,12247,"，进行数组的扩容和拷贝；"]],[12247,12247],[12259,12259]]],[1561732267756,["GJX@GJXAIOU",[[1,12275,"\n"]],[12259,12259],[12260,12260]]],[1561732270293,["GJX@GJXAIOU",[[1,12260,"其中"]],[12260,12260],[12262,12262]]],[1561732333108,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,12262,"\n\n"]],[8255,8255],[12264,12264]]],[1561732333108,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,12262,"\n\n"]],[12264,12264],[8255,8255]]],[1561732274902,["GJX@GJXAIOU",[[1,12262,"扩容了"]],[12262,12262],[12265,12265]]],[1561732275464,["GJX@GJXAIOU",[[-1,12264,"了"]],[12265,12265],[12264,12264]]],[1561732286972,["GJX@GJXAIOU",[[1,12264,"量大约为1"]],[12264,12264],[12269,12269]]],[1561732287014,["GJX@GJXAIOU",[[1,12268," "]],[12269,12269],[12270,12270]]],[1561732289600,["GJX@GJXAIOU",[[1,12270,".5倍"]],[12270,12270],[12273,12273]]],[1561732289640,["GJX@GJXAIOU",[[1,12272," "]],[12273,12273],[12274,12274]]],[1561732306131,["GJX@GJXAIOU",[[1,12274,"；：newCpaacity"]],[12274,12274],[12287,12287]]],[1561732308547,["GJX@GJXAIOU",[[-1,12279,"Cpaacity"]],[12287,12287],[12279,12279]]],[1561732308797,["GJX@GJXAIOU",[[1,12279,"a"]],[12279,12279],[12280,12280]]],[1561732309455,["GJX@GJXAIOU",[[-1,12279,"a"]],[12280,12280],[12279,12279]]],[1561732318363,["GJX@GJXAIOU",[[1,12279,"Capacity = od"]],[12279,12279],[12292,12292]]],[1561732318875,["GJX@GJXAIOU",[[-1,12291,"d"]],[12292,12292],[12291,12291]]],[1561732319502,["GJX@GJXAIOU",[[1,12291,"ls"]],[12291,12291],[12293,12293]]],[1561732320209,["GJX@GJXAIOU",[[-1,12292,"s"]],[12293,12293],[12292,12292]]],[1561732322157,["GJX@GJXAIOU",[[1,12292,"d Cap"]],[12292,12292],[12297,12297]]],[1561732323048,["GJX@GJXAIOU",[[-1,12293," Cap"]],[12297,12297],[12293,12293]]],[1561732326916,["GJX@GJXAIOU",[[1,12293,"Capcity"]],[12293,12293],[12300,12300]]],[1561732329755,["GJX@GJXAIOU",[[1,12296,"s"]],[12296,12296],[12297,12297]]],[1561732332628,["GJX@GJXAIOU",[[-1,12296,"s"]],[12297,12297],[12296,12296]]],[1561732332966,["GJX@GJXAIOU",[[1,12296,"a"]],[12296,12296],[12297,12297]]],[1561732393102,[null,[[-1,8255,"\n\n"],[1,8257,"首先"],[1,12301,"\n\n"]],[8255,8255],[12303,12303]]],[1561732393102,[null,[[1,8255,"\n\n"],[-1,8255,"首先"],[-1,12301,"\n\n"]],[12303,12303],[8255,8255]]],[1561732339583,["GJX@GJXAIOU",[[1,12301," +()"]],[12301,12301],[12305,12305]]],[1561732341502,["GJX@GJXAIOU",[[1,12304,"od"]],[12304,12304],[12306,12306]]],[1561732342417,["GJX@GJXAIOU",[[-1,12305,"d"]],[12306,12306],[12305,12305]]],[1561732342884,["GJX@GJXAIOU",[[1,12305,"ls"]],[12305,12305],[12307,12307]]],[1561732343728,["GJX@GJXAIOU",[[-1,12306,"s"]],[12307,12307],[12306,12306]]],[1561732351985,["GJX@GJXAIOU",[[1,12306,"dCapacity <<"]],[12306,12306],[12318,12318]]],[1561732352706,["GJX@GJXAIOU",[[-1,12316,"<<"]],[12318,12318],[12316,12316]]],[1561732354707,["GJX@GJXAIOU",[[1,12316,">> 1"]],[12316,12316],[12320,12320]]],[1561732356510,["GJX@GJXAIOU",[[1,12321,";"]],[12321,12321],[12322,12322]]],[1561732357241,["GJX@GJXAIOU",[[1,12338,"\n"]],[12322,12322],[12323,12323]]],[1561732374567,["GJX@GJXAIOU",[[1,12323,"即 新元素个数 = 老元素个数 + （）"]],[12323,12323],[12343,12343]]],[1561732379918,["GJX@GJXAIOU",[[1,12342,"老元素个数 《《"]],[12342,12342],[12350,12350]]],[1561732380512,["GJX@GJXAIOU",[[-1,12348,"《《"]],[12350,12350],[12348,12348]]],[1561732382667,["GJX@GJXAIOU",[[1,12348,">> 1"]],[12348,12348],[12352,12352]]]],null,"GJX@GJXAIOU"],["8fb3335a-5ab2-4aa9-83c2-402d46b5ea02",1561771628050,"# JavaEEDay16-集合\n\n\n- 数组：用于保存大量数据采取的方式；\n  - 可以保存的数据类型：\n    - 8 大基本数据类型 byte/short/int /long/float/double/char/boolean\n    - 自定义类对象：例如 Student Player\n    - Java 中的类对象\n  - 局限性：\n    - 只能保存一种数据类型的数据；\n    - 数组的元素个数创建时是确定的，无法直接对元素个数进行修改；\n    - 数组里面保存的元素内容空间是连续的；\n\n- 问题：如果需要保存任意类型的一个数组，所有的数据类型都可以在这个数组中保存；\n- 答案：使用 Object 数据类型，因为 Object 是 Java 中所有的类的直接父类或者间接父类 基类/根类；\n\n代码示例：\n```java\n\npackage study;\nimport java.util.Arrays;\n\n\n/**\n * class detail:\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\t//创建一个数据类型为Object数组，元素个数为5\n\t\t\n\t\tObject[] arr = new Object[5];\n\t\tarr[0] = \"hello\";\n\t\tarr[1] = 23;\n\t\tarr[2] = 2.3f;\n\t\tarr[3] = new Demo1();\n\t\tarr[4] = true;\n\t\t\n\tSystem.out.println(Arrays.toString(arr));\n\t}\n}\n\n```\n程序输出结果：\n`[hello, 23, 2.3, study.Demo1@21588809, true]`\n\n\n\n## 集合\n\n概念：集合就是存储对象的【容器】\n主要介绍：Collection、List、Set 接口\n- Collection： 集合的总【接口】，规定了很多方法，要求所有【遵从】该接口的类，全部实现；\n  - List： 接口，如果【遵循】了 List 接口，要求实现所有 List 中的方法，具有 List 集合的特征：**有序、可重复**\n  - Set：接口，如果【遵循】了 List 接口，要求实现所有 List 中的方法，具有 List 集合的特征：**无序，不可重复**\n\n首先从 Collection 开始学习，学习之后基本上行 List 和 Set 就是在此基础上添加操作\n- **基本方法：**\n- 增：\n  - add(Object o); //添加一个元素，任意类型的\n  - addAll(Collection c); //添加另一个集合\n- 删：\n  - clear(); //清空整个集合\n  - remove(Object o); //删除该集合中指定的元素\n  - removeAll(Colletcion c); //删除两个集合中的交集\n  - retainAll(Collection c); //保留两个集合中的交集\n- 查：\n  - size(); //获取当前集合有效元素的个数\n  - toArray(); //把当前集合中所有的元素转换成为 Object 类型的数组返回\n  \n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\n/**\n * class detail:\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\t//Collection 是一个接口，而接口是没有自己的类对象的，但是可以指向【遵从】该接口的类对象\n\t\t//这里借助于常用集合ArrayList来完成；\n\t\tCollection collection  = new ArrayList();\n\t\t\n\t\t//测试添加方法： add(Object 0);\n\t\tcollection.add(\"天气变热了\");\n\t\tcollection.add(\"明天30度啦\");\n\t\tcollection.add(\"测试\");\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试添加方法：addAll(Collection c);\n\t\tCollection collection2 = new ArrayList();\n\t\tcollection2.add(\"测试一\");\n\t\tcollection2.add(\"好热\");\n\t\t\n\t\tcollection.addAll(collection2);\n\t\tSystem.out.println(collection);\n\t\t\n\t\t\n\t\t//测试clear() : 清空集合中所有的元素\n\t\tSystem.out.println(collection);\n\t\tcollection.clear();\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试remove(Object o)\n\t\tcollection.remove(\"测试\");\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试removeAll\n\t\tcollection.removeAll(collection2);\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试retainAll(Collection c)\n\t\tcollection.retainAll(collection2);\n\t\tSystem.err.println(collection);\n\t\t\n\t\t//测试size()\n\t\tSystem.out.println(collection.size());\n\t\t\n\t\t//测试Arrays.toString\n\t\tSystem.out.println(Arrays.toString(collection.toArray()));\n\t\t\n\t\t\n\t}\n\t\n}\n\n```\n\n- **其他方法：**\n  - 判断方法\n    - isEmpty(); //是否为空\n    - contains(Object o); //是否包含当前元素\n    - containsAll(Colllection c); //是否包含指定集合里面的所有元素\n    - equals(Object o); //判断是否相等\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\n/**\n * class detail:\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"A\");\n\t\tcollection.add(\"B\");\n\t\tcollection.add(\"C\");\n\t\tcollection.add(\"D\");\n\t\t\n\t\tCollection collection2 = new ArrayList();\n\t\tcollection2.add(\"A\");\n\t\tcollection2.add(\"B\");\n\t\tcollection2.add(\"D\");\n\t\tcollection2.add(\"C\");\n\t\t\n\t\t//测试equal()方法 ； //比较这两个集合之间的元素是否完全相同，放入的位置也相同；\n\t\tcollection.equals(collection2);  //因为顺序不同，结果为false\n\t\t\n\t\t//测试isEmpty方法\n\t\tcollection.isEmpty(); //结果为false\n\t\t\n\t\t//测试 contains(Object o);\n\t\tSystem.out.println(collection.contains(\"A\"));\n\t\tSystem.out.println(collection.contains(\"E\"));\n\t\t\n\t\t//测试containAll(Collection c); //判断传入的集合是不是当前集合的子集\n\t\tSystem.out.println(collection.containsAll(collection2));\n\t}\n\n}\n\n```\n\n\n\n## collection\n\n- contains, containAll,equals 方法；\n  - 发现：\n    - Java 语言总，默认判断两个对象是否相同的方式是：判断这两个对象的地址是否相同；\n    - 在这里 student1 对象和 new Student（1, “成龙”）;是两个完全不同的对象；\n  - 问题：\n    - 因为上面两个对象里面保存的数据其实是一样的，也是符合业务逻辑的，或者是符合生活逻辑的，实现在符合语法的前提下，也符合生活逻辑；\n  - 解决方法：\n    - 重写 equals 和 hashCode 方法；\n    - 默认情况下：\n      - hashCode 方法在系统默认情况下，是当前类的对象在内存中地址的十进制数；\n            - equals 方法是两个对象相互比较的法则；\n代码示例：\n\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\n\nclass Student{\n\tprivate int  id;\n\tprivate String name;\n\n\tpublic Student() {\t\n\t\t\n\t}\n\t\n\tpublic  Student(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\t\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\t\n\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\t@Override\n\t//描述当前类对象，当通过打印方法的时候自动调用\n\tpublic String toString() {\n\t\treturn \"[ ID : \" + id + \"    Name : \" + name + \"]\";\n\t}\n\t\n\t//重写equals方法和hashCode方法\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\t//这里的equals方法是Student类重写的方法，当集合调用contains、containsAll、equals方法的时候\n\t\t//都会调用这里的Student类中的equals方法进行比较，比较的对象是Student对象；\n\t\tSystem.out.println(\"Student的equals方法\");\n\t\t\n\t\t//原来的equals方法不符合生活逻辑，仅仅是判断两个对象的地址是否相同，不判断里面的内容是否一致，\n\t\t//重写改变为判断对象中的数据是否一致\n\t\t\n\t\t//1.首先进行强制类型转换\n\t\tStudent student = (Student)obj;\n\t\tSystem.out.println(this.name + \" 和 \" + student.name + \"进行比较\");\n\t\t\n\t\t//这里的this.name.equals(student.name)中的equals方法是调用String类型的equals方法，用于判断两字符串是否相等；\n\t\treturn this.id == student.id && this.name.equals(student.name);\n\t}\n\t\n\t@Override\n\tpublic int hashCode() {\n\t\tSystem.out.println(\"Student 的 HashCode 方法\");\n\t\t//如果重写了equals方法，同时也要重写hashCode方法\n\t\t//因为hashCode值要确定【唯一性】，只要满足自己逻辑就OK，这里认为id是唯一的\n\t\treturn this.id;\n\t}\t\n}\n\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection  =  new ArrayList();\n\t\tStudent student1 = new Student(1,\"张三\");\n\t\tStudent student2 = new Student(2,\"李四\"\t);\n\t\tStudent student3 = new Student(3,\"王五\");\n\t\t\n\t\tcollection.add(student1);\n\t\tcollection.add(student2);\n\t\tcollection.add(student3);\n\t\t\n\t\tSystem.out.println(collection);\n\t\t\n\t\tboolean ret = collection.contains(new Student(1, \"张三\")); //\n\t\tSystem.out.println(ret);\n\t} \n}\n\n```\n\n\n### 迭代器\n\n代码示例\n```java\n/**\n * \n */\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class DieDaiQi {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray();\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t/*Itreator  迭代器\n\t\t * boolean hasNext();  //判断当前迭代器是否有下一个元素\n\t\t * Object next(); //获取当前迭代器指向的元素，并且获取之后，指向下一个元素；\n\t\t * void remove(); //删除当前迭代器通过next获取到的对象\n\t\t * [要求]: 在通过迭代器调用remove方法时候，之前必须调用过next方法，否则会报异常：java.lang.IllegalAtateException\n\t\t */\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}\n\n```\n\n### 共享资源问题\n\n针对同一个资源，同时两个主体在使用，容易产生冲突；\n代码示例：集合对象和迭代器同时处理集合中的元素，造成冲突；\n```Java\n/**\n * \n */\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * class detail:共享资源处理问题\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class ShareSources {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\tIterator iterator = collection.iterator();\n\t\t\n\t\t//下面代码会抛出异常： java.util.ConcurrentModificationException\n\t\t/*\n\t\t * 这里存在两种操作集合数据的方式，第一种方式：集合的对象collection；第二种方式：集合的迭代器iterator\n\t\t * 这里两种操作都有查看和删除的权限，但是一方操作的同时，另一方也在操作，或造成共享资源问题；\n\t\t * \n\t\t * 解决方法：\n\t\t *  \t1.使用迭代器操作放弃集合对象操作\n\t\t *  \t2.使用集合对象操作放弃迭代器操作\n\t\t */\n\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tSystem.out.println(iterator.next());\n\t\t\t\t\tcollection.remove(\"李四\");\t\n\t\t}\n\t}\n}\n\n```\n\n\n\n\n\n\n## List\n首先 Collection 接口中的所有方法在这里仍然可以使用，下面是 List 接口中【特有的】方法：\n- 添加：\n  - add(index, Object 0); //指定位置上放入元素\n  - addAll(int index, Collection c); //在指定位置上添加一个集合\n- 获取：\n  - Object get(int index); //获取下标的元素\n  - int indexOf(Object 0); //获取某个元素的下标位置\n  - int lastIndexOf(Object 0); //找到指定元素最后一个出现在集合中的位置\n  - List subList(int fromIndex, int toIndex); //获取子 List 集合\n- 修改：\n  - set(int index, Object 0); //设置指定下标上的元素\n- 迭代：\n  - ListIterator();\n\n```java\n/**\n * \n */\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * class detail:\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class ListUse {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();  //导包一定要导入java.util.List\n\t\tlist.add(\"张三\");\n\t\tlist.add(\"李四\");\n\t\tlist.add(\"王五\");\n\t\t\n\t\tSystem.out.println(list);\n\t\t\n\t\tlist.add(1, \"赵六\"); //在元素1后面插入“赵六\"\n\t\tSystem.out.println(list);\n\t\t\n\t\t\n\t\tList list2 = new ArrayList();\n\t\tlist2.add(\"陈七\");\n\t\tlist2.add(\"朱九\");\n\t\tlist2.add(\"陈七\");\n\t\tlist.addAll(2,list2);\n\t\tSystem.out.println(list);\n\t\t\n\t\t//get方法\n\t\tSystem.out.println(list.get(1)); \n\t\t\n\t\t//indexOf和lastIndexOf\n\t\tSystem.out.println(list2.indexOf(\"陈七\"));\n\t\tSystem.out.println(list2.lastIndexOf(\"陈七\"));\n\t\t\n\t\t//subList(int fromIndex, int toIndex);\n\t\t//在Java中，所有使用到区间范围的操作，全是要头不要尾；\n\t\tList sublist = list.subList(0, 5);\n\t\tSystem.out.println(sublist);\n\t\t\n\t\tlist.set(list.indexOf(\"张三\"), \"六六六\");\n\t\tSystem.out.println(list);\n\t\t\n\t\t\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n```\n\n### List 特有迭代器- ListIterator()\n\n- 方法：\n  - hasNext();\n  - next();\n  - remove();\n  - add(Object 0); //在当前迭代器指向的位置上，添加元素，其他元素向后移动；\n  - set(Object 0); //替换 next 获取到的元素；\n  - nextIndex(); //下一个元素的下标；\n\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\n/**\n * class detail:ListIterator\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Listitetator_use {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();\n\t\tlist.add(\"小米\");\n\t\tlist.add(\"华为\");\n\t\tlist.add(\"苹果\");\n\t\t\n\t\t//获取List的特有迭代器\n\tListIterator iterator = list.listIterator();\n\t\n\tSystem.out.println(\"下一个元素\" + iterator.hasNext());\n\tSystem.out.println(\"next获取数据\" + iterator.next());\n\tSystem.out.println(\"set方法进行替换\");\n\titerator.set(\"mi\");\n\t\n\tSystem.out.println(\"添加内容：\");\n\titerator.add(\"VO\");\n\tSystem.out.println(list);\n\t\n\tSystem.out.println(iterator.nextIndex());\n\t}\n}\n\n```\n\n**List 集合的三种遍历方式：**\n- for 循环\n- 迭代器\n- 增强 for 循环\n\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\npublic class ListBianLi {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();\n\t\t\n\t\tlist.add(\"A\");\n\t\tlist.add(\"B\");\n\t\tlist.add(\"C\");\n\t\tlist.add(\"D\");\n\t\tlist.add(\"E\");\n\t\t\n\t\t//使用for循环进行遍历：使用get(int index)  和size()方法\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i));\n\t\t}\n\t\t\n\t\tSystem.out.println(\"*********************\");\n\t\t\n\t\t//使用ListIterator迭代器\n\t\tListIterator iterator = list.listIterator();\n\t\t\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(iterator.next());\n\t\t\t}\n\t\t\n\t\tSystem.out.println(\"*********************\");\n\t\t\n\t\t//增强for循环：实质为迭代器的实现\n\t\tfor(Object object : list) {  //数据类型  变量名\n\t\t\tSystem.out.println(object);\n\t\t}\t\n\t}\n} \n```\n\n\n### ArrayList 【重点】\nArrayList 是底层维护了一个 Object 类型的数组，这样的话这个 ArrayList 既可以保存任意类型的数据，又有数组的优势；\n\n- 特征：\n  - 当调用无参构造方法 ArrayList，这里创建的底层 Object 类型的数组元素个数默认为 10 ，即 DEFAULT_CAPACITY = 10；\n  - 数组查询快、增删慢的特征；\n- 开发中使用较多的场景：\n  - 查询场景较多但是增删较少的程序：例如：图书馆管理系统，人员管理系统；\n\n\n- ArrayList 特有的方法：都不太常用\n  - ensureCapacity(int minCapacity); //判断当前 ArrayList 里面保存元素内容 Object 数组，元素个数是否大于 minCapacity;\n  - trimToSize(); //截断底层维护的 Object 类型的数组，让数组容量变成当前 ArrayList 的 size 值（有效元素个数）\n\n- 查询快、增删慢的原理：\n  - 查询快：因为底层维护的是一个 Object 类型的数组，可以完全使用数组的下标机制来访问数据，这种访问的形式是非常快的；\n  - 增删慢：增加数据时候，可能导致 ArrayList 底层的 Object 数组的元素不够用，那么会调用数组的扩容方法 grow，而扩容方法会创建一个新的数组，数组的元素大于原来数组，同时会将源数据拷贝到新数组中，拷贝过程耗费时间；\n  - 删除慢：因为删除一个数据，会导致数组中该元素之后的所有数据做一个整体的左移，这也是一次数组的拷贝，浪费时间；\n\n问： ArrayList 是一个可以自增长的空间，请问，增加的原理是什么？增长的长度是多少？\nArrayList 底层维护的是一个 Object 数组，默认的元素个数为 10，如果添加元素，当前需求的元素空间超过了 Object 数组的元素个数，会调用底层的 grow 方法，进行数组的扩容和拷贝；\n其中扩容量大约为 1.5 倍；：newCapacity = oldCapacity +(oldCapacity >> 1);\n即 新元素个数 = 老元素个数 + （老元素个数 >> 1）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",[[1561771595225,["GJX@GJXAIOU",[[1,18,"## 背景："]],[18,18],[24,24]]],[1561771599088,["GJX@GJXAIOU",[[1,21,"一、"]],[21,21],[23,23]]],[1561771691674,["GJX@GJXAIOU",[[-1,424,"\n/**\n * class detail:\n * @author GJXAIOU\n * @since  2019年6月28日\n */\n"]],[423,490],[423,423]]],[1561771694706,["GJX@GJXAIOU",[[-1,382,"\n"]],[382,382],[381,381]]],[1561771734949,["GJX@GJXAIOU",[[1,760,"二、"]],[760,760],[762,762]]],[1561771803313,["GJX@GJXAIOU",[[-1,952,"List"]],[956,956],[952,952]]],[1561771805208,["GJX@GJXAIOU",[[1,952,"Srt"]],[952,952],[955,955]]],[1561771806206,["GJX@GJXAIOU",[[-1,953,"rt"]],[955,955],[953,953]]],[1561771806869,["GJX@GJXAIOU",[[1,953,"et"]],[953,953],[955,955]]],[1561771812304,["GJX@GJXAIOU",[[-1,966,"List"]],[970,970],[966,966]]],[1561771813315,["GJX@GJXAIOU",[[1,966,"s"]],[966,966],[967,967]]],[1561771814209,["GJX@GJXAIOU",[[-1,966,"s"]],[967,967],[966,966]]],[1561771818308,["GJX@GJXAIOU",[[1,966,"Set"]],[966,966],[969,969]]],[1561771822117,["GJX@GJXAIOU",[[-1,978,"Lis"]],[981,981],[978,978]]],[1561771823845,["GJX@GJXAIOU",[[1,978,"Se"]],[978,978],[980,980]]],[1561771870128,["GJX@GJXAIOU",[[-1,1028,"行"]],[1029,1029],[1028,1028]]],[1561771883036,["GJX@GJXAIOU",[[1,1056,"C "]],[1056,1056],[1057,1057]]],[1561771885030,["GJX@GJXAIOU",[[1,1057,"olle"]],[1057,1057],[1061,1061]]],[1561771885852,["GJX@GJXAIOU",[[-1,1060,"e"]],[1061,1061],[1060,1060]]],[1561771886686,["GJX@GJXAIOU",[[1,1060,"ction"]],[1060,1060],[1065,1065]]],[1561771938369,["GJX@GJXAIOU",[[1,1295,",sahn"]],[1295,1295],[1300,1300]]],[1561771940217,["GJX@GJXAIOU",[[-1,1295,",sahn"]],[1300,1300],[1295,1295]]],[1561771947213,["GJX@GJXAIOU",[[1,1295,"，删除其他元素"]],[1295,1295],[1302,1302]]],[1561771967451,["GJX@GJXAIOU",[[-1,1052,"- "]],[1054,1054],[1052,1052]]],[1561771967597,["GJX@GJXAIOU",[[-1,1051,"\n"]],[1052,1052],[1051,1051]]],[1561771969671,["GJX@GJXAIOU",[[1,1051,"\n"]],[1051,1051],[1052,1052]]],[1561771985316,["GJX@GJXAIOU",[[-1,1492,"/**\n * class detail:\n * @author GJXAIOU\n * @since  2019年6月28日\n */"]],[1492,1557],[1492,1492]]],[1561771985841,["GJX@GJXAIOU",[[-1,1492,"\n"]],[1492,1492],[1491,1491]]],[1561772009537,["GJX@GJXAIOU",[[-1,2590,"- "]],[2590,2592],[2590,2590]]],[1561772016584,["GJX@GJXAIOU",[[1,2592,"Collection "]],[2592,2592],[2602,2602]]],[1561772044382,["GJX@GJXAIOU",[[1,2610,"判断方法"]],[2610,2610],[2614,2614]]],[1561772046315,["GJX@GJXAIOU",[[1,2610," "]],[2610,2610],[2611,2611]]],[1561772050954,["GJX@GJXAIOU",[[-1,2616,"  - 判断方法"]],[2616,2624],[2616,2616]]],[1561772052784,["GJX@GJXAIOU",[[-1,2616,"\n"]],[2616,2616],[2615,2615]]],[1561772058196,["GJX@GJXAIOU",[[-1,2618,"  "],[-1,2640,"  "],[-1,2679,"  "],[-1,2729,"  "]],[2620,2761],[2618,2753]]],[1561772059041,["GJX@GJXAIOU",[[-1,2616,"  "],[-1,2638,"  "],[-1,2673,"  "],[-1,2723,"  "]],[2618,2753],[2616,2745]]],[1561772066427,["GJX@GJXAIOU",[[-1,2835,"/**\n * class detail:\n * @author GJXAIOU\n * @since  2019年6月28日\n */"]],[2835,2900],[2835,2835]]],[1561772066955,["GJX@GJXAIOU",[[-1,2835,"\n"]],[2835,2835],[2834,2834]]],[1561772080440,["GJX@GJXAIOU",[[1,3602,"中"]],[3602,3602],[3603,3603]]],[1561772080479,["GJX@GJXAIOU",[[1,3602," "]],[3603,3603],[3604,3604]]],[1561772085255,["GJX@GJXAIOU",[[1,3604,"判断方法的重写"]],[3604,3604],[3611,3611]]],[1561772108835,["GJX@GJXAIOU",[[-1,3668,"总，"]],[3670,3670],[3668,3668]]],[1561772110681,["GJX@GJXAIOU",[[1,3668,"中"]],[3668,3668],[3669,3669]]],[1561772142334,["GJX@GJXAIOU",[[-1,3756,"；"]],[3757,3757],[3756,3756]]],[1561772150382,["GJX@GJXAIOU",[[1,3756,"，因此判断结果Wie"]],[3756,3756],[3766,3766]]],[1561772150420,["GJX@GJXAIOU",[[1,3763," "]],[3766,3766],[3767,3767]]],[1561772151620,["GJX@GJXAIOU",[[-1,3763," Wie"]],[3767,3767],[3763,3763]]],[1561772155510,["GJX@GJXAIOU",[[1,3763,"为false"]],[3763,3763],[3769,3769]]],[1561772155551,["GJX@GJXAIOU",[[1,3764," "]],[3769,3769],[3770,3770]]],[1561772155919,["GJX@GJXAIOU",[[1,3770,"；"]],[3770,3770],[3771,3771]]],[1561772182288,["GJX@GJXAIOU",[[1,3829,"因此想"]],[3829,3829],[3832,3832]]],[1561772196791,["GJX@GJXAIOU",[[1,3851,"（）"]],[3851,3851],[3853,3853]]],[1561772203094,["GJX@GJXAIOU",[[1,3852,"即当里面"]],[3852,3852],[3856,3856]]],[1561772206314,["GJX@GJXAIOU",[[-1,3853,"当里面"]],[3856,3856],[3853,3853]]],[1561772213039,["GJX@GJXAIOU",[[1,3853,"当两个对此案"]],[3853,3853],[3859,3859]]],[1561772214450,["GJX@GJXAIOU",[[-1,3856,"对此案"]],[3859,3859],[3856,3856]]],[1561772222823,["GJX@GJXAIOU",[[1,3856,"对象中保存的数据时"]],[3856,3856],[3865,3865]]],[1561772223280,["GJX@GJXAIOU",[[-1,3864,"时"]],[3865,3865],[3864,3864]]],[1561772225839,["GJX@GJXAIOU",[[1,3864,"一致时候"]],[3864,3864],[3868,3868]]],[1561772226346,["GJX@GJXAIOU",[[-1,3867,"候"]],[3868,3868],[3867,3867]]],[1561772226894,["GJX@GJXAIOU",[[1,3867,"，"]],[3867,3867],[3868,3868]]],[1561772236712,["GJX@GJXAIOU",[[1,3868,"判为相等"]],[3868,3868],[3872,3872]]],[1561772266293,["GJX@GJXAIOU",[[1,3976,"（）"]],[3976,3976],[3978,3978]]],[1561772271693,["GJX@GJXAIOU",[[1,3977,"地址默认为1"]],[3977,3977],[3983,3983]]],[1561772271734,["GJX@GJXAIOU",[[1,3982," "]],[3983,3983],[3984,3984]]],[1561772274325,["GJX@GJXAIOU",[[1,3984,"6进制"]],[3984,3984],[3987,3987]]],[1561772274365,["GJX@GJXAIOU",[[1,3985," "]],[3987,3987],[3988,3988]]],[1561772285246,["GJX@GJXAIOU",[[1,3988,"显示，hashCode为"]],[3988,3988],[4000,4000]]],[1561772285285,["GJX@GJXAIOU",[[1,3999," "]],[4000,4000],[4001,4001]]],[1561772285739,["GJX@GJXAIOU",[[1,4001,"1"]],[4001,4001],[4002,4002]]],[1561772285779,["GJX@GJXAIOU",[[1,4001," "]],[4002,4002],[4003,4003]]],[1561772287510,["GJX@GJXAIOU",[[1,4003,"0进制"]],[4003,4003],[4006,4006]]],[1561772287550,["GJX@GJXAIOU",[[1,4004," "]],[4006,4006],[4007,4007]]],[1561772288437,["GJX@GJXAIOU",[[1,4007,"显示"]],[4007,4007],[4009,4009]]],[1561772300220,["GJX@GJXAIOU",[[-1,4017,"      "]],[4023,4023],[4017,4017]]],[1561772307174,["GJX@GJXAIOU",[[1,4042,"\n"]],[4042,4042],[4043,4043]]],[1561772309448,["GJX@GJXAIOU",[[-1,4049,"\n"]],[4049,4049],[4048,4048]]],[1561772314021,["GJX@GJXAIOU",[[-1,4131,"\n"]],[4131,4131],[4130,4130]]],[1561772315176,["GJX@GJXAIOU",[[-1,4130,"\n"]],[4130,4130],[4129,4129]]],[1561772316452,["GJX@GJXAIOU",[[1,4130,"\n"]],[4129,4129],[4130,4130]]],[1561772338136,["GJX@GJXAIOU",[[-1,5866,"#"]],[5866,5866],[5865,5865]]],[1561772343722,["GJX@GJXAIOU",[[-1,5885,"/**\n * \n */"]],[5885,5896],[5885,5885]]],[1561772344318,["GJX@GJXAIOU",[[-1,5885,"\n"]],[5885,5885],[5884,5884]]],[1561772371583,["GJX@GJXAIOU",[[-1,8556,"/**\n * \n */"]],[8556,8567],[8556,8556]]],[1561772376070,["GJX@GJXAIOU",[[-1,8625,"/**\n * class detail:\n * @author GJXAIOU\n * @since  2019年6月28日\n */"]],[8625,8690],[8625,8625]]],[1561772376636,["GJX@GJXAIOU",[[-1,8625,"\n"]],[8625,8625],[8624,8624]]],[1561772382977,["GJX@GJXAIOU",[[-1,9446,"\n"]],[9446,9446],[9445,9445]]],[1561772383107,["GJX@GJXAIOU",[[-1,9445,"\n"]],[9445,9445],[9444,9444]]],[1561772383260,["GJX@GJXAIOU",[[-1,9444,"\n"]],[9444,9444],[9443,9443]]],[1561772383443,["GJX@GJXAIOU",[[-1,9443,"\n"]],[9443,9443],[9442,9442]]],[1561772383626,["GJX@GJXAIOU",[[-1,9442,"\n"]],[9442,9442],[9441,9441]]],[1561772383794,["GJX@GJXAIOU",[[-1,9441,"\n"]],[9441,9441],[9440,9440]]],[1561772383944,["GJX@GJXAIOU",[[-1,9440,"\n"]],[9440,9440],[9439,9439]]],[1561772384111,["GJX@GJXAIOU",[[-1,9439,"\n"]],[9439,9439],[9438,9438]]],[1561772384654,["GJX@GJXAIOU",[[-1,9438,"\n"]],[9438,9438],[9437,9437]]],[1561772385125,["GJX@GJXAIOU",[[-1,9437,"\n"]],[9437,9437],[9436,9436]]],[1561773286259,["GJX@GJXAIOU",[[1,12139,"### "]],[12139,12139],[12143,12143]]],[1561773392606,["GJX@GJXAIOU",[[1,12143,"LinkedList"]],[12143,12143],[12153,12153]]],[1561773395595,["GJX@GJXAIOU",[[1,12167,"\n"]],[12153,12153],[12154,12154]]],[1561773418934,["GJX@GJXAIOU",[[1,12154,"底层维护的是一个链表，特征：增删快、查找慢"]],[12154,12154],[12175,12175]]],[1561773421979,["GJX@GJXAIOU",[[1,12189,"\n"]],[12175,12175],[12176,12176]]],[1561773422313,["GJX@GJXAIOU",[[1,12190,"\n"]],[12176,12176],[12177,12177]]],[1561773425634,["GJX@GJXAIOU",[[1,12177,"Linked"]],[12177,12177],[12183,12183]]],[1561773432991,["GJX@GJXAIOU",[[1,12183,"List特有"]],[12183,12183],[12189,12189]]],[1561773433035,["GJX@GJXAIOU",[[1,12187," "]],[12189,12189],[12190,12190]]],[1561773435768,["GJX@GJXAIOU",[[1,12190,"的方法："]],[12190,12190],[12194,12194]]],[1561773435995,["GJX@GJXAIOU",[[1,12208,"\n"]],[12194,12194],[12195,12195]]],[1561773511541,["GJX@GJXAIOU",[[1,12195,"- addFirst()"]],[12195,12195],[12207,12207]]],[1561773515196,["GJX@GJXAIOU",[[1,12206,"Oo"]],[12206,12206],[12208,12208]]],[1561773516424,["GJX@GJXAIOU",[[-1,12207,"o"]],[12208,12208],[12207,12207]]],[1561773517347,["GJX@GJXAIOU",[[1,12207,"bju"]],[12207,12207],[12210,12210]]],[1561773518000,["GJX@GJXAIOU",[[-1,12209,"u"]],[12210,12210],[12209,12209]]],[1561773539931,["GJX@GJXAIOU",[[1,12209,"ect 0"]],[12209,12209],[12214,12214]]],[1561773541342,["GJX@GJXAIOU",[[1,12215,";"]],[12215,12215],[12216,12216]]],[1561773544648,["GJX@GJXAIOU",[[1,12217,"- \n"]],[12216,12216],[12219,12219]]],[1561773546427,["GJX@GJXAIOU",[[1,12219,"sdd"]],[12219,12219],[12222,12222]]],[1561773547113,["GJX@GJXAIOU",[[-1,12219,"sdd"]],[12222,12222],[12219,12219]]],[1561773547947,["GJX@GJXAIOU",[[1,12219,"add"]],[12219,12219],[12222,12222]]],[1561773551482,["GJX@GJXAIOU",[[1,12222,"Lat()"]],[12222,12222],[12227,12227]]],[1561773555443,["GJX@GJXAIOU",[[1,12226,"Object o"]],[12226,12226],[12234,12234]]],[1561773557736,["GJX@GJXAIOU",[[-1,12213,"0"]],[12214,12214],[12213,12213]]],[1561773558198,["GJX@GJXAIOU",[[1,12213,"o"]],[12213,12213],[12214,12214]]],[1561773561091,["GJX@GJXAIOU",[[1,12235,";"]],[12235,12235],[12236,12236]]],[1561773562315,["GJX@GJXAIOU",[[1,12237,"- \n"]],[12236,12236],[12239,12239]]],[1561773569554,["GJX@GJXAIOU",[[1,12224,"s"]],[12224,12224],[12225,12225]]],[1561773577507,["GJX@GJXAIOU",[[1,12240,"getFirst();"]],[12240,12240],[12251,12251]]],[1561773577760,["GJX@GJXAIOU",[[1,12252,"- \n"]],[12251,12251],[12254,12254]]],[1561773583629,["GJX@GJXAIOU",[[1,12254,"getLast();"]],[12254,12254],[12264,12264]]],[1561773583920,["GJX@GJXAIOU",[[1,12265,"- \n"]],[12264,12264],[12267,12267]]],[1561773592324,["GJX@GJXAIOU",[[1,12267,"removeFirst();"]],[12267,12267],[12281,12281]]],[1561773592563,["GJX@GJXAIOU",[[1,12282,"- \n"]],[12281,12281],[12284,12284]]],[1561773599395,["GJX@GJXAIOU",[[1,12284,"removeLast();"]],[12284,12284],[12297,12297]]]],null,"GJX@GJXAIOU"],["ba1dbf3c-e633-4413-94ea-8f67c895d17e",1561815397205,"# JavaEEDay16-集合\n\n## 一、背景：\n- 数组：用于保存大量数据采取的方式；\n  - 可以保存的数据类型：\n    - 8 大基本数据类型 byte/short/int /long/float/double/char/boolean\n    - 自定义类对象：例如 Student Player\n    - Java 中的类对象\n  - 局限性：\n    - 只能保存一种数据类型的数据；\n    - 数组的元素个数创建时是确定的，无法直接对元素个数进行修改；\n    - 数组里面保存的元素内容空间是连续的；\n\n- 问题：如果需要保存任意类型的一个数组，所有的数据类型都可以在这个数组中保存；\n- 答案：使用 Object 数据类型，因为 Object 是 Java 中所有的类的直接父类或者间接父类 基类/根类；\n\n代码示例：\n```java\npackage study;\nimport java.util.Arrays;\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\t//创建一个数据类型为Object数组，元素个数为5\n\t\t\n\t\tObject[] arr = new Object[5];\n\t\tarr[0] = \"hello\";\n\t\tarr[1] = 23;\n\t\tarr[2] = 2.3f;\n\t\tarr[3] = new Demo1();\n\t\tarr[4] = true;\n\t\t\n\tSystem.out.println(Arrays.toString(arr));\n\t}\n}\n\n```\n程序输出结果：\n`[hello, 23, 2.3, study.Demo1@21588809, true]`\n\n\n\n## 二、集合\n\n概念：集合就是存储对象的【容器】\n主要介绍：Collection、List、Set 接口\n- Collection： 集合的总【接口】，规定了很多方法，要求所有【遵从】该接口的类，全部实现；\n  - List： 接口，如果【遵循】了 List 接口，要求实现所有 List 中的方法，具有 List 集合的特征：**有序、可重复**\n  - Set：接口，如果【遵循】了 Set 接口，要求实现所有 Set 中的方法，具有 Set 集合的特征：**无序，不可重复**\n\n首先从 Collection 开始学习，学习之后基本上 List 和 Set 就是在此基础上添加操作\n**Collction 基本方法：**\n- 增：\n  - add(Object o); //添加一个元素，任意类型的\n  - addAll(Collection c); //添加另一个集合\n- 删：\n  - clear(); //清空整个集合\n  - remove(Object o); //删除该集合中指定的元素\n  - removeAll(Colletcion c); //删除两个集合中的交集\n  - retainAll(Collection c); //保留两个集合中的交集，删除其他元素\n- 查：\n  - size(); //获取当前集合有效元素的个数\n  - toArray(); //把当前集合中所有的元素转换成为 Object 类型的数组返回\n  \n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\t//Collection 是一个接口，而接口是没有自己的类对象的，但是可以指向【遵从】该接口的类对象\n\t\t//这里借助于常用集合ArrayList来完成；\n\t\tCollection collection  = new ArrayList();\n\t\t\n\t\t//测试添加方法： add(Object 0);\n\t\tcollection.add(\"天气变热了\");\n\t\tcollection.add(\"明天30度啦\");\n\t\tcollection.add(\"测试\");\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试添加方法：addAll(Collection c);\n\t\tCollection collection2 = new ArrayList();\n\t\tcollection2.add(\"测试一\");\n\t\tcollection2.add(\"好热\");\n\t\t\n\t\tcollection.addAll(collection2);\n\t\tSystem.out.println(collection);\n\t\t\n\t\t\n\t\t//测试clear() : 清空集合中所有的元素\n\t\tSystem.out.println(collection);\n\t\tcollection.clear();\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试remove(Object o)\n\t\tcollection.remove(\"测试\");\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试removeAll\n\t\tcollection.removeAll(collection2);\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试retainAll(Collection c)\n\t\tcollection.retainAll(collection2);\n\t\tSystem.err.println(collection);\n\t\t\n\t\t//测试size()\n\t\tSystem.out.println(collection.size());\n\t\t\n\t\t//测试Arrays.toString\n\t\tSystem.out.println(Arrays.toString(collection.toArray()));\n\t\t\n\t\t\n\t}\n\t\n}\n\n```\n\n**Collection 其他方法：** 判断方法\n- isEmpty(); //是否为空\n- contains(Object o); //是否包含当前元素\n- containsAll(Colllection c); //是否包含指定集合里面的所有元素\n- equals(Object o); //判断是否相等\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"A\");\n\t\tcollection.add(\"B\");\n\t\tcollection.add(\"C\");\n\t\tcollection.add(\"D\");\n\t\t\n\t\tCollection collection2 = new ArrayList();\n\t\tcollection2.add(\"A\");\n\t\tcollection2.add(\"B\");\n\t\tcollection2.add(\"D\");\n\t\tcollection2.add(\"C\");\n\t\t\n\t\t//测试equal()方法 ； //比较这两个集合之间的元素是否完全相同，放入的位置也相同；\n\t\tcollection.equals(collection2);  //因为顺序不同，结果为false\n\t\t\n\t\t//测试isEmpty方法\n\t\tcollection.isEmpty(); //结果为false\n\t\t\n\t\t//测试 contains(Object o);\n\t\tSystem.out.println(collection.contains(\"A\"));\n\t\tSystem.out.println(collection.contains(\"E\"));\n\t\t\n\t\t//测试containAll(Collection c); //判断传入的集合是不是当前集合的子集\n\t\tSystem.out.println(collection.containsAll(collection2));\n\t}\n\n}\n\n```\n\n\n\n## collection 中判断方法的重写\n\n- contains, containAll,equals 方法；\n  - 发现：\n    - Java 语言中默认判断两个对象是否相同的方式是：判断这两个对象的地址是否相同；\n    - 在这里 student1 对象和 new Student（1, “成龙”）;是两个完全不同的对象，因此判断结果为 false；\n  - 问题：\n    - 因为上面两个对象里面保存的数据其实是一样的，也是符合业务逻辑的，或者是符合生活逻辑的，因此想实现在符合语法的前提下，也符合生活逻辑（即当两个对象中保存的数据一致时，判为相等）；\n  - 解决方法：\n    - 重写 equals 和 hashCode 方法；\n    - 默认情况下：\n      - hashCode 方法在系统默认情况下，是当前类的对象在内存中地址的十进制数；（地址默认为 16 进制显示，hashCode 为 10 进制显示）\n      - equals 方法是两个对象相互比较的法则；\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\nclass Student{\n\tprivate int  id;\n\tprivate String name;\n\n\tpublic Student() {\t\n\t\t\n\t}\n\t\n\tpublic  Student(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\t\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\t\n\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\t@Override\n\t//描述当前类对象，当通过打印方法的时候自动调用\n\tpublic String toString() {\n\t\treturn \"[ ID : \" + id + \"    Name : \" + name + \"]\";\n\t}\n\t\n\t//重写equals方法和hashCode方法\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\t//这里的equals方法是Student类重写的方法，当集合调用contains、containsAll、equals方法的时候\n\t\t//都会调用这里的Student类中的equals方法进行比较，比较的对象是Student对象；\n\t\tSystem.out.println(\"Student的equals方法\");\n\t\t\n\t\t//原来的equals方法不符合生活逻辑，仅仅是判断两个对象的地址是否相同，不判断里面的内容是否一致，\n\t\t//重写改变为判断对象中的数据是否一致\n\t\t\n\t\t//1.首先进行强制类型转换\n\t\tStudent student = (Student)obj;\n\t\tSystem.out.println(this.name + \" 和 \" + student.name + \"进行比较\");\n\t\t\n\t\t//这里的this.name.equals(student.name)中的equals方法是调用String类型的equals方法，用于判断两字符串是否相等；\n\t\treturn this.id == student.id && this.name.equals(student.name);\n\t}\n\t\n\t@Override\n\tpublic int hashCode() {\n\t\tSystem.out.println(\"Student 的 HashCode 方法\");\n\t\t//如果重写了equals方法，同时也要重写hashCode方法\n\t\t//因为hashCode值要确定【唯一性】，只要满足自己逻辑就OK，这里认为id是唯一的\n\t\treturn this.id;\n\t}\t\n}\n\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection  =  new ArrayList();\n\t\tStudent student1 = new Student(1,\"张三\");\n\t\tStudent student2 = new Student(2,\"李四\"\t);\n\t\tStudent student3 = new Student(3,\"王五\");\n\t\t\n\t\tcollection.add(student1);\n\t\tcollection.add(student2);\n\t\tcollection.add(student3);\n\t\t\n\t\tSystem.out.println(collection);\n\t\t\n\t\tboolean ret = collection.contains(new Student(1, \"张三\")); //\n\t\tSystem.out.println(ret);\n\t} \n}\n\n```\n\n\n## 迭代器\n\n代码示例\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class DieDaiQi {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray();\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t/*Itreator  迭代器\n\t\t * boolean hasNext();  //判断当前迭代器是否有下一个元素\n\t\t * Object next(); //获取当前迭代器指向的元素，并且获取之后，指向下一个元素；\n\t\t * void remove(); //删除当前迭代器通过next获取到的对象\n\t\t * [要求]: 在通过迭代器调用remove方法时候，之前必须调用过next方法，否则会报异常：java.lang.IllegalAtateException\n\t\t */\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}\n\n```\n\n### 共享资源问题\n\n针对同一个资源，同时两个主体在使用，容易产生冲突；\n代码示例：集合对象和迭代器同时处理集合中的元素，造成冲突；\n```Java\n/**\n * \n */\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * class detail:共享资源处理问题\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class ShareSources {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\tIterator iterator = collection.iterator();\n\t\t\n\t\t//下面代码会抛出异常： java.util.ConcurrentModificationException\n\t\t/*\n\t\t * 这里存在两种操作集合数据的方式，第一种方式：集合的对象collection；第二种方式：集合的迭代器iterator\n\t\t * 这里两种操作都有查看和删除的权限，但是一方操作的同时，另一方也在操作，或造成共享资源问题；\n\t\t * \n\t\t * 解决方法：\n\t\t *  \t1.使用迭代器操作放弃集合对象操作\n\t\t *  \t2.使用集合对象操作放弃迭代器操作\n\t\t */\n\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tSystem.out.println(iterator.next());\n\t\t\t\t\tcollection.remove(\"李四\");\t\n\t\t}\n\t}\n}\n\n```\n\n\n\n\n\n\n## List\n首先 Collection 接口中的所有方法在这里仍然可以使用，下面是 List 接口中【特有的】方法：\n- 添加：\n  - add(index, Object 0); //指定位置上放入元素\n  - addAll(int index, Collection c); //在指定位置上添加一个集合\n- 获取：\n  - Object get(int index); //获取下标的元素\n  - int indexOf(Object 0); //获取某个元素的下标位置\n  - int lastIndexOf(Object 0); //找到指定元素最后一个出现在集合中的位置\n  - List subList(int fromIndex, int toIndex); //获取子 List 集合\n- 修改：\n  - set(int index, Object 0); //设置指定下标上的元素\n- 迭代：\n  - ListIterator();\n\n```java\n\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ListUse {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();  //导包一定要导入java.util.List\n\t\tlist.add(\"张三\");\n\t\tlist.add(\"李四\");\n\t\tlist.add(\"王五\");\n\t\t\n\t\tSystem.out.println(list);\n\t\t\n\t\tlist.add(1, \"赵六\"); //在元素1后面插入“赵六\"\n\t\tSystem.out.println(list);\n\t\t\n\t\t\n\t\tList list2 = new ArrayList();\n\t\tlist2.add(\"陈七\");\n\t\tlist2.add(\"朱九\");\n\t\tlist2.add(\"陈七\");\n\t\tlist.addAll(2,list2);\n\t\tSystem.out.println(list);\n\t\t\n\t\t//get方法\n\t\tSystem.out.println(list.get(1)); \n\t\t\n\t\t//indexOf和lastIndexOf\n\t\tSystem.out.println(list2.indexOf(\"陈七\"));\n\t\tSystem.out.println(list2.lastIndexOf(\"陈七\"));\n\t\t\n\t\t//subList(int fromIndex, int toIndex);\n\t\t//在Java中，所有使用到区间范围的操作，全是要头不要尾；\n\t\tList sublist = list.subList(0, 5);\n\t\tSystem.out.println(sublist);\n\t\t\n\t\tlist.set(list.indexOf(\"张三\"), \"六六六\");\n\t\tSystem.out.println(list);\n\t\t\n\t\t\n\t}\n}\n```\n\n### List 特有迭代器- ListIterator()\n\n- 方法：\n  - hasNext();\n  - next();\n  - remove();\n  - add(Object 0); //在当前迭代器指向的位置上，添加元素，其他元素向后移动；\n  - set(Object 0); //替换 next 获取到的元素；\n  - nextIndex(); //下一个元素的下标；\n\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\n/**\n * class detail:ListIterator\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Listitetator_use {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();\n\t\tlist.add(\"小米\");\n\t\tlist.add(\"华为\");\n\t\tlist.add(\"苹果\");\n\t\t\n\t\t//获取List的特有迭代器\n\tListIterator iterator = list.listIterator();\n\t\n\tSystem.out.println(\"下一个元素\" + iterator.hasNext());\n\tSystem.out.println(\"next获取数据\" + iterator.next());\n\tSystem.out.println(\"set方法进行替换\");\n\titerator.set(\"mi\");\n\t\n\tSystem.out.println(\"添加内容：\");\n\titerator.add(\"VO\");\n\tSystem.out.println(list);\n\t\n\tSystem.out.println(iterator.nextIndex());\n\t}\n}\n\n```\n\n**List 集合的三种遍历方式：**\n- for 循环\n- 迭代器\n- 增强 for 循环\n\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\npublic class ListBianLi {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();\n\t\t\n\t\tlist.add(\"A\");\n\t\tlist.add(\"B\");\n\t\tlist.add(\"C\");\n\t\tlist.add(\"D\");\n\t\tlist.add(\"E\");\n\t\t\n\t\t//使用for循环进行遍历：使用get(int index)  和size()方法\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i));\n\t\t}\n\t\t\n\t\tSystem.out.println(\"*********************\");\n\t\t\n\t\t//使用ListIterator迭代器\n\t\tListIterator iterator = list.listIterator();\n\t\t\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(iterator.next());\n\t\t\t}\n\t\t\n\t\tSystem.out.println(\"*********************\");\n\t\t\n\t\t//增强for循环：实质为迭代器的实现\n\t\tfor(Object object : list) {  //数据类型  变量名\n\t\t\tSystem.out.println(object);\n\t\t}\t\n\t}\n} \n```\n\n\n### ArrayList 【重点】\nArrayList 是底层维护了一个 Object 类型的数组，这样的话这个 ArrayList 既可以保存任意类型的数据，又有数组的优势；\n\n- 特征：\n  - 当调用无参构造方法 ArrayList，这里创建的底层 Object 类型的数组元素个数默认为 10 ，即 DEFAULT_CAPACITY = 10；\n  - 数组查询快、增删慢的特征；\n- 开发中使用较多的场景：\n  - 查询场景较多但是增删较少的程序：例如：图书馆管理系统，人员管理系统；\n\n\n- ArrayList 特有的方法：都不太常用\n  - ensureCapacity(int minCapacity); //判断当前 ArrayList 里面保存元素内容 Object 数组，元素个数是否大于 minCapacity;\n  - trimToSize(); //截断底层维护的 Object 类型的数组，让数组容量变成当前 ArrayList 的 size 值（有效元素个数）\n\n- 查询快、增删慢的原理：\n  - 查询快：因为底层维护的是一个 Object 类型的数组，可以完全使用数组的下标机制来访问数据，这种访问的形式是非常快的；\n  - 增删慢：增加数据时候，可能导致 ArrayList 底层的 Object 数组的元素不够用，那么会调用数组的扩容方法 grow，而扩容方法会创建一个新的数组，数组的元素大于原来数组，同时会将源数据拷贝到新数组中，拷贝过程耗费时间；\n  - 删除慢：因为删除一个数据，会导致数组中该元素之后的所有数据做一个整体的左移，这也是一次数组的拷贝，浪费时间；\n\n问： ArrayList 是一个可以自增长的空间，请问，增加的原理是什么？增长的长度是多少？\nArrayList 底层维护的是一个 Object 数组，默认的元素个数为 10，如果添加元素，当前需求的元素空间超过了 Object 数组的元素个数，会调用底层的 grow 方法，进行数组的扩容和拷贝；\n其中扩容量大约为 1.5 倍；：newCapacity = oldCapacity +(oldCapacity >> 1);\n即 新元素个数 = 老元素个数 + （老元素个数 >> 1）\n\n### LinkedList\n底层维护的是一个链表，特征：增删快、查找慢\n\nLinkedList 特有的方法：\n- addFirst(Object o);\n- addLast(Object o);\n- getFirst();\n- getLast();\n- removeFirst();\n- removeLast();\n\n\n\n\n\n\n\n\n\n\n\n\n\n",[[1561815388803,["GJX@GJXAIOU",[[1,12300,"![LinkedList和ArrayList继承区别]($resource/LinkedList%E5%92%8CArrayList%E7%BB%A7%E6%89%BF%E5%8C%BA%E5%88%AB.png)"]],[12300,12300],[12408,12408]]]],null,"GJX@GJXAIOU"],["0d624f5b-4e9c-4ee9-a0e6-f290e1a633ce",1561854778707,"# JavaEEDay16-集合\n\n## 一、背景：\n- 数组：用于保存大量数据采取的方式；\n  - 可以保存的数据类型：\n    - 8 大基本数据类型 byte/short/int /long/float/double/char/boolean\n    - 自定义类对象：例如 Student Player\n    - Java 中的类对象\n  - 局限性：\n    - 只能保存一种数据类型的数据；\n    - 数组的元素个数创建时是确定的，无法直接对元素个数进行修改；\n    - 数组里面保存的元素内容空间是连续的；\n\n- 问题：如果需要保存任意类型的一个数组，所有的数据类型都可以在这个数组中保存；\n- 答案：使用 Object 数据类型，因为 Object 是 Java 中所有的类的直接父类或者间接父类 基类/根类；\n\n代码示例：\n```java\npackage study;\nimport java.util.Arrays;\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\t//创建一个数据类型为Object数组，元素个数为5\n\t\t\n\t\tObject[] arr = new Object[5];\n\t\tarr[0] = \"hello\";\n\t\tarr[1] = 23;\n\t\tarr[2] = 2.3f;\n\t\tarr[3] = new Demo1();\n\t\tarr[4] = true;\n\t\t\n\tSystem.out.println(Arrays.toString(arr));\n\t}\n}\n\n```\n程序输出结果：\n`[hello, 23, 2.3, study.Demo1@21588809, true]`\n\n\n\n## 二、集合\n\n概念：集合就是存储对象的【容器】\n主要介绍：Collection、List、Set 接口\n- Collection： 集合的总【接口】，规定了很多方法，要求所有【遵从】该接口的类，全部实现；\n  - List： 接口，如果【遵循】了 List 接口，要求实现所有 List 中的方法，具有 List 集合的特征：**有序、可重复**\n  - Set：接口，如果【遵循】了 Set 接口，要求实现所有 Set 中的方法，具有 Set 集合的特征：**无序，不可重复**\n\n首先从 Collection 开始学习，学习之后基本上 List 和 Set 就是在此基础上添加操作\n**Collction 基本方法：**\n- 增：\n  - add(Object o); //添加一个元素，任意类型的\n  - addAll(Collection c); //添加另一个集合\n- 删：\n  - clear(); //清空整个集合\n  - remove(Object o); //删除该集合中指定的元素\n  - removeAll(Colletcion c); //删除两个集合中的交集\n  - retainAll(Collection c); //保留两个集合中的交集，删除其他元素\n- 查：\n  - size(); //获取当前集合有效元素的个数\n  - toArray(); //把当前集合中所有的元素转换成为 Object 类型的数组返回\n  \n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\t//Collection 是一个接口，而接口是没有自己的类对象的，但是可以指向【遵从】该接口的类对象\n\t\t//这里借助于常用集合ArrayList来完成；\n\t\tCollection collection  = new ArrayList();\n\t\t\n\t\t//测试添加方法： add(Object 0);\n\t\tcollection.add(\"天气变热了\");\n\t\tcollection.add(\"明天30度啦\");\n\t\tcollection.add(\"测试\");\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试添加方法：addAll(Collection c);\n\t\tCollection collection2 = new ArrayList();\n\t\tcollection2.add(\"测试一\");\n\t\tcollection2.add(\"好热\");\n\t\t\n\t\tcollection.addAll(collection2);\n\t\tSystem.out.println(collection);\n\t\t\n\t\t\n\t\t//测试clear() : 清空集合中所有的元素\n\t\tSystem.out.println(collection);\n\t\tcollection.clear();\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试remove(Object o)\n\t\tcollection.remove(\"测试\");\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试removeAll\n\t\tcollection.removeAll(collection2);\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试retainAll(Collection c)\n\t\tcollection.retainAll(collection2);\n\t\tSystem.err.println(collection);\n\t\t\n\t\t//测试size()\n\t\tSystem.out.println(collection.size());\n\t\t\n\t\t//测试Arrays.toString\n\t\tSystem.out.println(Arrays.toString(collection.toArray()));\n\t\t\n\t\t\n\t}\n\t\n}\n\n```\n\n**Collection 其他方法：** 判断方法\n- isEmpty(); //是否为空\n- contains(Object o); //是否包含当前元素\n- containsAll(Colllection c); //是否包含指定集合里面的所有元素\n- equals(Object o); //判断是否相等\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"A\");\n\t\tcollection.add(\"B\");\n\t\tcollection.add(\"C\");\n\t\tcollection.add(\"D\");\n\t\t\n\t\tCollection collection2 = new ArrayList();\n\t\tcollection2.add(\"A\");\n\t\tcollection2.add(\"B\");\n\t\tcollection2.add(\"D\");\n\t\tcollection2.add(\"C\");\n\t\t\n\t\t//测试equal()方法 ； //比较这两个集合之间的元素是否完全相同，放入的位置也相同；\n\t\tcollection.equals(collection2);  //因为顺序不同，结果为false\n\t\t\n\t\t//测试isEmpty方法\n\t\tcollection.isEmpty(); //结果为false\n\t\t\n\t\t//测试 contains(Object o);\n\t\tSystem.out.println(collection.contains(\"A\"));\n\t\tSystem.out.println(collection.contains(\"E\"));\n\t\t\n\t\t//测试containAll(Collection c); //判断传入的集合是不是当前集合的子集\n\t\tSystem.out.println(collection.containsAll(collection2));\n\t}\n\n}\n\n```\n\n\n\n## collection 中判断方法的重写\n\n- contains, containAll,equals 方法；\n  - 发现：\n    - Java 语言中默认判断两个对象是否相同的方式是：判断这两个对象的地址是否相同；\n    - 在这里 student1 对象和 new Student（1, “成龙”）;是两个完全不同的对象，因此判断结果为 false；\n  - 问题：\n    - 因为上面两个对象里面保存的数据其实是一样的，也是符合业务逻辑的，或者是符合生活逻辑的，因此想实现在符合语法的前提下，也符合生活逻辑（即当两个对象中保存的数据一致时，判为相等）；\n  - 解决方法：\n    - 重写 equals 和 hashCode 方法；\n    - 默认情况下：\n      - hashCode 方法在系统默认情况下，是当前类的对象在内存中地址的十进制数；（地址默认为 16 进制显示，hashCode 为 10 进制显示）\n      - equals 方法是两个对象相互比较的法则；\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\nclass Student{\n\tprivate int  id;\n\tprivate String name;\n\n\tpublic Student() {\t\n\t\t\n\t}\n\t\n\tpublic  Student(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\t\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\t\n\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\t@Override\n\t//描述当前类对象，当通过打印方法的时候自动调用\n\tpublic String toString() {\n\t\treturn \"[ ID : \" + id + \"    Name : \" + name + \"]\";\n\t}\n\t\n\t//重写equals方法和hashCode方法\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\t//这里的equals方法是Student类重写的方法，当集合调用contains、containsAll、equals方法的时候\n\t\t//都会调用这里的Student类中的equals方法进行比较，比较的对象是Student对象；\n\t\tSystem.out.println(\"Student的equals方法\");\n\t\t\n\t\t//原来的equals方法不符合生活逻辑，仅仅是判断两个对象的地址是否相同，不判断里面的内容是否一致，\n\t\t//重写改变为判断对象中的数据是否一致\n\t\t\n\t\t//1.首先进行强制类型转换\n\t\tStudent student = (Student)obj;\n\t\tSystem.out.println(this.name + \" 和 \" + student.name + \"进行比较\");\n\t\t\n\t\t//这里的this.name.equals(student.name)中的equals方法是调用String类型的equals方法，用于判断两字符串是否相等；\n\t\treturn this.id == student.id && this.name.equals(student.name);\n\t}\n\t\n\t@Override\n\tpublic int hashCode() {\n\t\tSystem.out.println(\"Student 的 HashCode 方法\");\n\t\t//如果重写了equals方法，同时也要重写hashCode方法\n\t\t//因为hashCode值要确定【唯一性】，只要满足自己逻辑就OK，这里认为id是唯一的\n\t\treturn this.id;\n\t}\t\n}\n\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection  =  new ArrayList();\n\t\tStudent student1 = new Student(1,\"张三\");\n\t\tStudent student2 = new Student(2,\"李四\"\t);\n\t\tStudent student3 = new Student(3,\"王五\");\n\t\t\n\t\tcollection.add(student1);\n\t\tcollection.add(student2);\n\t\tcollection.add(student3);\n\t\t\n\t\tSystem.out.println(collection);\n\t\t\n\t\tboolean ret = collection.contains(new Student(1, \"张三\")); //\n\t\tSystem.out.println(ret);\n\t} \n}\n\n```\n\n\n## 迭代器\n\n代码示例\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class DieDaiQi {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray();\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t/*Itreator  迭代器\n\t\t * boolean hasNext();  //判断当前迭代器是否有下一个元素\n\t\t * Object next(); //获取当前迭代器指向的元素，并且获取之后，指向下一个元素；\n\t\t * void remove(); //删除当前迭代器通过next获取到的对象\n\t\t * [要求]: 在通过迭代器调用remove方法时候，之前必须调用过next方法，否则会报异常：java.lang.IllegalAtateException\n\t\t */\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}\n\n```\n\n### 共享资源问题\n\n针对同一个资源，同时两个主体在使用，容易产生冲突；\n代码示例：集合对象和迭代器同时处理集合中的元素，造成冲突；\n```Java\n/**\n * \n */\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * class detail:共享资源处理问题\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class ShareSources {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\tIterator iterator = collection.iterator();\n\t\t\n\t\t//下面代码会抛出异常： java.util.ConcurrentModificationException\n\t\t/*\n\t\t * 这里存在两种操作集合数据的方式，第一种方式：集合的对象collection；第二种方式：集合的迭代器iterator\n\t\t * 这里两种操作都有查看和删除的权限，但是一方操作的同时，另一方也在操作，或造成共享资源问题；\n\t\t * \n\t\t * 解决方法：\n\t\t *  \t1.使用迭代器操作放弃集合对象操作\n\t\t *  \t2.使用集合对象操作放弃迭代器操作\n\t\t */\n\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tSystem.out.println(iterator.next());\n\t\t\t\t\tcollection.remove(\"李四\");\t\n\t\t}\n\t}\n}\n\n```\n\n\n\n\n\n\n## List\n首先 Collection 接口中的所有方法在这里仍然可以使用，下面是 List 接口中【特有的】方法：\n- 添加：\n  - add(index, Object 0); //指定位置上放入元素\n  - addAll(int index, Collection c); //在指定位置上添加一个集合\n- 获取：\n  - Object get(int index); //获取下标的元素\n  - int indexOf(Object 0); //获取某个元素的下标位置\n  - int lastIndexOf(Object 0); //找到指定元素最后一个出现在集合中的位置\n  - List subList(int fromIndex, int toIndex); //获取子 List 集合\n- 修改：\n  - set(int index, Object 0); //设置指定下标上的元素\n- 迭代：\n  - ListIterator();\n\n```java\n\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ListUse {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();  //导包一定要导入java.util.List\n\t\tlist.add(\"张三\");\n\t\tlist.add(\"李四\");\n\t\tlist.add(\"王五\");\n\t\t\n\t\tSystem.out.println(list);\n\t\t\n\t\tlist.add(1, \"赵六\"); //在元素1后面插入“赵六\"\n\t\tSystem.out.println(list);\n\t\t\n\t\t\n\t\tList list2 = new ArrayList();\n\t\tlist2.add(\"陈七\");\n\t\tlist2.add(\"朱九\");\n\t\tlist2.add(\"陈七\");\n\t\tlist.addAll(2,list2);\n\t\tSystem.out.println(list);\n\t\t\n\t\t//get方法\n\t\tSystem.out.println(list.get(1)); \n\t\t\n\t\t//indexOf和lastIndexOf\n\t\tSystem.out.println(list2.indexOf(\"陈七\"));\n\t\tSystem.out.println(list2.lastIndexOf(\"陈七\"));\n\t\t\n\t\t//subList(int fromIndex, int toIndex);\n\t\t//在Java中，所有使用到区间范围的操作，全是要头不要尾；\n\t\tList sublist = list.subList(0, 5);\n\t\tSystem.out.println(sublist);\n\t\t\n\t\tlist.set(list.indexOf(\"张三\"), \"六六六\");\n\t\tSystem.out.println(list);\n\t\t\n\t\t\n\t}\n}\n```\n\n### List 特有迭代器- ListIterator()\n\n- 方法：\n  - hasNext();\n  - next();\n  - remove();\n  - add(Object 0); //在当前迭代器指向的位置上，添加元素，其他元素向后移动；\n  - set(Object 0); //替换 next 获取到的元素；\n  - nextIndex(); //下一个元素的下标；\n\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\n/**\n * class detail:ListIterator\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Listitetator_use {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();\n\t\tlist.add(\"小米\");\n\t\tlist.add(\"华为\");\n\t\tlist.add(\"苹果\");\n\t\t\n\t\t//获取List的特有迭代器\n\tListIterator iterator = list.listIterator();\n\t\n\tSystem.out.println(\"下一个元素\" + iterator.hasNext());\n\tSystem.out.println(\"next获取数据\" + iterator.next());\n\tSystem.out.println(\"set方法进行替换\");\n\titerator.set(\"mi\");\n\t\n\tSystem.out.println(\"添加内容：\");\n\titerator.add(\"VO\");\n\tSystem.out.println(list);\n\t\n\tSystem.out.println(iterator.nextIndex());\n\t}\n}\n\n```\n\n**List 集合的三种遍历方式：**\n- for 循环\n- 迭代器\n- 增强 for 循环\n\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\npublic class ListBianLi {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();\n\t\t\n\t\tlist.add(\"A\");\n\t\tlist.add(\"B\");\n\t\tlist.add(\"C\");\n\t\tlist.add(\"D\");\n\t\tlist.add(\"E\");\n\t\t\n\t\t//使用for循环进行遍历：使用get(int index)  和size()方法\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i));\n\t\t}\n\t\t\n\t\tSystem.out.println(\"*********************\");\n\t\t\n\t\t//使用ListIterator迭代器\n\t\tListIterator iterator = list.listIterator();\n\t\t\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(iterator.next());\n\t\t\t}\n\t\t\n\t\tSystem.out.println(\"*********************\");\n\t\t\n\t\t//增强for循环：实质为迭代器的实现\n\t\tfor(Object object : list) {  //数据类型  变量名\n\t\t\tSystem.out.println(object);\n\t\t}\t\n\t}\n} \n```\n\n\n### ArrayList 【重点】\nArrayList 是底层维护了一个 Object 类型的数组，这样的话这个 ArrayList 既可以保存任意类型的数据，又有数组的优势；\n\n- 特征：\n  - 当调用无参构造方法 ArrayList，这里创建的底层 Object 类型的数组元素个数默认为 10 ，即 DEFAULT_CAPACITY = 10；\n  - 数组查询快、增删慢的特征；\n- 开发中使用较多的场景：\n  - 查询场景较多但是增删较少的程序：例如：图书馆管理系统，人员管理系统；\n\n\n- ArrayList 特有的方法：都不太常用\n  - ensureCapacity(int minCapacity); //判断当前 ArrayList 里面保存元素内容 Object 数组，元素个数是否大于 minCapacity;\n  - trimToSize(); //截断底层维护的 Object 类型的数组，让数组容量变成当前 ArrayList 的 size 值（有效元素个数）\n\n- 查询快、增删慢的原理：\n  - 查询快：因为底层维护的是一个 Object 类型的数组，可以完全使用数组的下标机制来访问数据，这种访问的形式是非常快的；\n  - 增删慢：增加数据时候，可能导致 ArrayList 底层的 Object 数组的元素不够用，那么会调用数组的扩容方法 grow，而扩容方法会创建一个新的数组，数组的元素大于原来数组，同时会将源数据拷贝到新数组中，拷贝过程耗费时间；\n  - 删除慢：因为删除一个数据，会导致数组中该元素之后的所有数据做一个整体的左移，这也是一次数组的拷贝，浪费时间；\n\n问： ArrayList 是一个可以自增长的空间，请问，增加的原理是什么？增长的长度是多少？\nArrayList 底层维护的是一个 Object 数组，默认的元素个数为 10，如果添加元素，当前需求的元素空间超过了 Object 数组的元素个数，会调用底层的 grow 方法，进行数组的扩容和拷贝；\n其中扩容量大约为 1.5 倍；：newCapacity = oldCapacity +(oldCapacity >> 1);\n即 新元素个数 = 老元素个数 + （老元素个数 >> 1）\n\n### LinkedList\n底层维护的是一个链表，特征：增删快、查找慢\n\nLinkedList 特有的方法：\n- addFirst(Object o);\n- addLast(Object o);\n- getFirst();\n- getLast();\n- removeFirst();\n- removeLast();\n\n\n![LinkedList和ArrayList继承区别]($resource/LinkedList%E5%92%8CArrayList%E7%BB%A7%E6%89%BF%E5%8C%BA%E5%88%AB.png)\n\n\n\n\n\n\n\n\n\n\n",[[1561854758056,["GJX@GJXAIOU",[[1,3591,"#"]],[3591,3591],[3612,3612]]],[1561855880729,["GJX@GJXAIOU",[[1,11825,"s "]],[11825,11825],[11826,11826]]],[1561855881327,["GJX@GJXAIOU",[[1,11826,"huju"]],[11826,11826],[11830,11830]]],[1561855882274,["GJX@GJXAIOU",[[-1,11825,"shuju"]],[11830,11830],[11825,11825]]],[1561855889561,["GJX@GJXAIOU",[[1,11825,"数据量较大的时候，"]],[11825,11825],[11834,11834]]]],null,"GJX@GJXAIOU"],["acf5554b-f463-4f69-8115-435e1f111e27",1562286961343,"# JavaEEDay16-集合\n\n## 一、背景：\n- 数组：用于保存大量数据采取的方式；\n  - 可以保存的数据类型：\n    - 8 大基本数据类型 byte/short/int /long/float/double/char/boolean\n    - 自定义类对象：例如 Student Player\n    - Java 中的类对象\n  - 局限性：\n    - 只能保存一种数据类型的数据；\n    - 数组的元素个数创建时是确定的，无法直接对元素个数进行修改；\n    - 数组里面保存的元素内容空间是连续的；\n\n- 问题：如果需要保存任意类型的一个数组，所有的数据类型都可以在这个数组中保存；\n- 答案：使用 Object 数据类型，因为 Object 是 Java 中所有的类的直接父类或者间接父类 基类/根类；\n\n代码示例：\n```java\npackage study;\nimport java.util.Arrays;\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\t//创建一个数据类型为Object数组，元素个数为5\n\t\t\n\t\tObject[] arr = new Object[5];\n\t\tarr[0] = \"hello\";\n\t\tarr[1] = 23;\n\t\tarr[2] = 2.3f;\n\t\tarr[3] = new Demo1();\n\t\tarr[4] = true;\n\t\t\n\tSystem.out.println(Arrays.toString(arr));\n\t}\n}\n\n```\n程序输出结果：\n`[hello, 23, 2.3, study.Demo1@21588809, true]`\n\n\n\n## 二、集合\n\n概念：集合就是存储对象的【容器】\n主要介绍：Collection、List、Set 接口\n- Collection： 集合的总【接口】，规定了很多方法，要求所有【遵从】该接口的类，全部实现；\n  - List： 接口，如果【遵循】了 List 接口，要求实现所有 List 中的方法，具有 List 集合的特征：**有序、可重复**\n  - Set：接口，如果【遵循】了 Set 接口，要求实现所有 Set 中的方法，具有 Set 集合的特征：**无序，不可重复**\n\n首先从 Collection 开始学习，学习之后基本上 List 和 Set 就是在此基础上添加操作\n**Collction 基本方法：**\n- 增：\n  - add(Object o); //添加一个元素，任意类型的\n  - addAll(Collection c); //添加另一个集合\n- 删：\n  - clear(); //清空整个集合\n  - remove(Object o); //删除该集合中指定的元素\n  - removeAll(Colletcion c); //删除两个集合中的交集\n  - retainAll(Collection c); //保留两个集合中的交集，删除其他元素\n- 查：\n  - size(); //获取当前集合有效元素的个数\n  - toArray(); //把当前集合中所有的元素转换成为 Object 类型的数组返回\n  \n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\t//Collection 是一个接口，而接口是没有自己的类对象的，但是可以指向【遵从】该接口的类对象\n\t\t//这里借助于常用集合ArrayList来完成；\n\t\tCollection collection  = new ArrayList();\n\t\t\n\t\t//测试添加方法： add(Object 0);\n\t\tcollection.add(\"天气变热了\");\n\t\tcollection.add(\"明天30度啦\");\n\t\tcollection.add(\"测试\");\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试添加方法：addAll(Collection c);\n\t\tCollection collection2 = new ArrayList();\n\t\tcollection2.add(\"测试一\");\n\t\tcollection2.add(\"好热\");\n\t\t\n\t\tcollection.addAll(collection2);\n\t\tSystem.out.println(collection);\n\t\t\n\t\t\n\t\t//测试clear() : 清空集合中所有的元素\n\t\tSystem.out.println(collection);\n\t\tcollection.clear();\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试remove(Object o)\n\t\tcollection.remove(\"测试\");\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试removeAll\n\t\tcollection.removeAll(collection2);\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试retainAll(Collection c)\n\t\tcollection.retainAll(collection2);\n\t\tSystem.err.println(collection);\n\t\t\n\t\t//测试size()\n\t\tSystem.out.println(collection.size());\n\t\t\n\t\t//测试Arrays.toString\n\t\tSystem.out.println(Arrays.toString(collection.toArray()));\n\t\t\n\t\t\n\t}\n\t\n}\n\n```\n\n**Collection 其他方法：** 判断方法\n- isEmpty(); //是否为空\n- contains(Object o); //是否包含当前元素\n- containsAll(Colllection c); //是否包含指定集合里面的所有元素\n- equals(Object o); //判断是否相等\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"A\");\n\t\tcollection.add(\"B\");\n\t\tcollection.add(\"C\");\n\t\tcollection.add(\"D\");\n\t\t\n\t\tCollection collection2 = new ArrayList();\n\t\tcollection2.add(\"A\");\n\t\tcollection2.add(\"B\");\n\t\tcollection2.add(\"D\");\n\t\tcollection2.add(\"C\");\n\t\t\n\t\t//测试equal()方法 ； //比较这两个集合之间的元素是否完全相同，放入的位置也相同；\n\t\tcollection.equals(collection2);  //因为顺序不同，结果为false\n\t\t\n\t\t//测试isEmpty方法\n\t\tcollection.isEmpty(); //结果为false\n\t\t\n\t\t//测试 contains(Object o);\n\t\tSystem.out.println(collection.contains(\"A\"));\n\t\tSystem.out.println(collection.contains(\"E\"));\n\t\t\n\t\t//测试containAll(Collection c); //判断传入的集合是不是当前集合的子集\n\t\tSystem.out.println(collection.containsAll(collection2));\n\t}\n\n}\n\n```\n\n\n\n### collection 中判断方法的重写\n\n- contains, containAll,equals 方法；\n  - 发现：\n    - Java 语言中默认判断两个对象是否相同的方式是：判断这两个对象的地址是否相同；\n    - 在这里 student1 对象和 new Student（1, “成龙”）;是两个完全不同的对象，因此判断结果为 false；\n  - 问题：\n    - 因为上面两个对象里面保存的数据其实是一样的，也是符合业务逻辑的，或者是符合生活逻辑的，因此想实现在符合语法的前提下，也符合生活逻辑（即当两个对象中保存的数据一致时，判为相等）；\n  - 解决方法：\n    - 重写 equals 和 hashCode 方法；\n    - 默认情况下：\n      - hashCode 方法在系统默认情况下，是当前类的对象在内存中地址的十进制数；（地址默认为 16 进制显示，hashCode 为 10 进制显示）\n      - equals 方法是两个对象相互比较的法则；\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\nclass Student{\n\tprivate int  id;\n\tprivate String name;\n\n\tpublic Student() {\t\n\t\t\n\t}\n\t\n\tpublic  Student(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\t\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\t\n\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\t@Override\n\t//描述当前类对象，当通过打印方法的时候自动调用\n\tpublic String toString() {\n\t\treturn \"[ ID : \" + id + \"    Name : \" + name + \"]\";\n\t}\n\t\n\t//重写equals方法和hashCode方法\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\t//这里的equals方法是Student类重写的方法，当集合调用contains、containsAll、equals方法的时候\n\t\t//都会调用这里的Student类中的equals方法进行比较，比较的对象是Student对象；\n\t\tSystem.out.println(\"Student的equals方法\");\n\t\t\n\t\t//原来的equals方法不符合生活逻辑，仅仅是判断两个对象的地址是否相同，不判断里面的内容是否一致，\n\t\t//重写改变为判断对象中的数据是否一致\n\t\t\n\t\t//1.首先进行强制类型转换\n\t\tStudent student = (Student)obj;\n\t\tSystem.out.println(this.name + \" 和 \" + student.name + \"进行比较\");\n\t\t\n\t\t//这里的this.name.equals(student.name)中的equals方法是调用String类型的equals方法，用于判断两字符串是否相等；\n\t\treturn this.id == student.id && this.name.equals(student.name);\n\t}\n\t\n\t@Override\n\tpublic int hashCode() {\n\t\tSystem.out.println(\"Student 的 HashCode 方法\");\n\t\t//如果重写了equals方法，同时也要重写hashCode方法\n\t\t//因为hashCode值要确定【唯一性】，只要满足自己逻辑就OK，这里认为id是唯一的\n\t\treturn this.id;\n\t}\t\n}\n\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection  =  new ArrayList();\n\t\tStudent student1 = new Student(1,\"张三\");\n\t\tStudent student2 = new Student(2,\"李四\"\t);\n\t\tStudent student3 = new Student(3,\"王五\");\n\t\t\n\t\tcollection.add(student1);\n\t\tcollection.add(student2);\n\t\tcollection.add(student3);\n\t\t\n\t\tSystem.out.println(collection);\n\t\t\n\t\tboolean ret = collection.contains(new Student(1, \"张三\")); //\n\t\tSystem.out.println(ret);\n\t} \n}\n\n```\n\n\n## 迭代器\n\n代码示例\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class DieDaiQi {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray();\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t/*Itreator  迭代器\n\t\t * boolean hasNext();  //判断当前迭代器是否有下一个元素\n\t\t * Object next(); //获取当前迭代器指向的元素，并且获取之后，指向下一个元素；\n\t\t * void remove(); //删除当前迭代器通过next获取到的对象\n\t\t * [要求]: 在通过迭代器调用remove方法时候，之前必须调用过next方法，否则会报异常：java.lang.IllegalAtateException\n\t\t */\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}\n\n```\n\n### 共享资源问题\n\n针对同一个资源，同时两个主体在使用，容易产生冲突；\n代码示例：集合对象和迭代器同时处理集合中的元素，造成冲突；\n```Java\n/**\n * \n */\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * class detail:共享资源处理问题\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class ShareSources {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\tIterator iterator = collection.iterator();\n\t\t\n\t\t//下面代码会抛出异常： java.util.ConcurrentModificationException\n\t\t/*\n\t\t * 这里存在两种操作集合数据的方式，第一种方式：集合的对象collection；第二种方式：集合的迭代器iterator\n\t\t * 这里两种操作都有查看和删除的权限，但是一方操作的同时，另一方也在操作，或造成共享资源问题；\n\t\t * \n\t\t * 解决方法：\n\t\t *  \t1.使用迭代器操作放弃集合对象操作\n\t\t *  \t2.使用集合对象操作放弃迭代器操作\n\t\t */\n\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tSystem.out.println(iterator.next());\n\t\t\t\t\tcollection.remove(\"李四\");\t\n\t\t}\n\t}\n}\n\n```\n\n\n\n\n\n\n## List\n首先 Collection 接口中的所有方法在这里仍然可以使用，下面是 List 接口中【特有的】方法：\n- 添加：\n  - add(index, Object 0); //指定位置上放入元素\n  - addAll(int index, Collection c); //在指定位置上添加一个集合\n- 获取：\n  - Object get(int index); //获取下标的元素\n  - int indexOf(Object 0); //获取某个元素的下标位置\n  - int lastIndexOf(Object 0); //找到指定元素最后一个出现在集合中的位置\n  - List subList(int fromIndex, int toIndex); //获取子 List 集合\n- 修改：\n  - set(int index, Object 0); //设置指定下标上的元素\n- 迭代：\n  - ListIterator();\n\n```java\n\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ListUse {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();  //导包一定要导入java.util.List\n\t\tlist.add(\"张三\");\n\t\tlist.add(\"李四\");\n\t\tlist.add(\"王五\");\n\t\t\n\t\tSystem.out.println(list);\n\t\t\n\t\tlist.add(1, \"赵六\"); //在元素1后面插入“赵六\"\n\t\tSystem.out.println(list);\n\t\t\n\t\t\n\t\tList list2 = new ArrayList();\n\t\tlist2.add(\"陈七\");\n\t\tlist2.add(\"朱九\");\n\t\tlist2.add(\"陈七\");\n\t\tlist.addAll(2,list2);\n\t\tSystem.out.println(list);\n\t\t\n\t\t//get方法\n\t\tSystem.out.println(list.get(1)); \n\t\t\n\t\t//indexOf和lastIndexOf\n\t\tSystem.out.println(list2.indexOf(\"陈七\"));\n\t\tSystem.out.println(list2.lastIndexOf(\"陈七\"));\n\t\t\n\t\t//subList(int fromIndex, int toIndex);\n\t\t//在Java中，所有使用到区间范围的操作，全是要头不要尾；\n\t\tList sublist = list.subList(0, 5);\n\t\tSystem.out.println(sublist);\n\t\t\n\t\tlist.set(list.indexOf(\"张三\"), \"六六六\");\n\t\tSystem.out.println(list);\n\t\t\n\t\t\n\t}\n}\n```\n\n### List 特有迭代器- ListIterator()\n\n- 方法：\n  - hasNext();\n  - next();\n  - remove();\n  - add(Object 0); //在当前迭代器指向的位置上，添加元素，其他元素向后移动；\n  - set(Object 0); //替换 next 获取到的元素；\n  - nextIndex(); //下一个元素的下标；\n\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\n/**\n * class detail:ListIterator\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Listitetator_use {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();\n\t\tlist.add(\"小米\");\n\t\tlist.add(\"华为\");\n\t\tlist.add(\"苹果\");\n\t\t\n\t\t//获取List的特有迭代器\n\tListIterator iterator = list.listIterator();\n\t\n\tSystem.out.println(\"下一个元素\" + iterator.hasNext());\n\tSystem.out.println(\"next获取数据\" + iterator.next());\n\tSystem.out.println(\"set方法进行替换\");\n\titerator.set(\"mi\");\n\t\n\tSystem.out.println(\"添加内容：\");\n\titerator.add(\"VO\");\n\tSystem.out.println(list);\n\t\n\tSystem.out.println(iterator.nextIndex());\n\t}\n}\n\n```\n\n**List 集合的三种遍历方式：**\n- for 循环\n- 迭代器\n- 增强 for 循环\n\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\npublic class ListBianLi {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();\n\t\t\n\t\tlist.add(\"A\");\n\t\tlist.add(\"B\");\n\t\tlist.add(\"C\");\n\t\tlist.add(\"D\");\n\t\tlist.add(\"E\");\n\t\t\n\t\t//使用for循环进行遍历：使用get(int index)  和size()方法\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i));\n\t\t}\n\t\t\n\t\tSystem.out.println(\"*********************\");\n\t\t\n\t\t//使用ListIterator迭代器\n\t\tListIterator iterator = list.listIterator();\n\t\t\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(iterator.next());\n\t\t\t}\n\t\t\n\t\tSystem.out.println(\"*********************\");\n\t\t\n\t\t//增强for循环：实质为迭代器的实现\n\t\tfor(Object object : list) {  //数据类型  变量名\n\t\t\tSystem.out.println(object);\n\t\t}\t\n\t}\n} \n```\n\n\n### ArrayList 【重点】\nArrayList 是底层维护了一个 Object 类型的数组，这样的话这个 ArrayList 既可以保存任意类型的数据，又有数组的优势；\n\n- 特征：\n  - 当调用无参构造方法 ArrayList，这里创建的底层 Object 类型的数组元素个数默认为 10 ，即 DEFAULT_CAPACITY = 10；\n  - 数组查询快、增删慢的特征；\n- 开发中使用较多的场景：\n  - 查询场景较多但是增删较少的程序：例如：图书馆管理系统，人员管理系统；\n\n\n- ArrayList 特有的方法：都不太常用\n  - ensureCapacity(int minCapacity); //判断当前 ArrayList 里面保存元素内容 Object 数组，元素个数是否大于 minCapacity;\n  - trimToSize(); //截断底层维护的 Object 类型的数组，让数组容量变成当前 ArrayList 的 size 值（有效元素个数）\n\n- 查询快、增删慢的原理：\n  - 查询快：因为底层维护的是一个 Object 类型的数组，可以完全使用数组的下标机制来访问数据，这种访问的形式是非常快的；\n  - 增删慢：增加数据时候，可能导致 ArrayList 底层的 Object 数组的元素不够用，那么会调用数组的扩容方法 grow，而扩容方法会创建一个新的数组，数组的元素大于原来数组，同时会将源数据拷贝到新数组中，数据量较大的时候， 拷贝过程耗费时间；\n  - 删除慢：因为删除一个数据，会导致数组中该元素之后的所有数据做一个整体的左移，这也是一次数组的拷贝，浪费时间；\n\n问： ArrayList 是一个可以自增长的空间，请问，增加的原理是什么？增长的长度是多少？\nArrayList 底层维护的是一个 Object 数组，默认的元素个数为 10，如果添加元素，当前需求的元素空间超过了 Object 数组的元素个数，会调用底层的 grow 方法，进行数组的扩容和拷贝；\n其中扩容量大约为 1.5 倍；：newCapacity = oldCapacity +(oldCapacity >> 1);\n即 新元素个数 = 老元素个数 + （老元素个数 >> 1）\n\n### LinkedList\n底层维护的是一个链表，特征：增删快、查找慢\n\nLinkedList 特有的方法：\n- addFirst(Object o);\n- addLast(Object o);\n- getFirst();\n- getLast();\n- removeFirst();\n- removeLast();\n\n\n![LinkedList和ArrayList继承区别]($resource/LinkedList%E5%92%8CArrayList%E7%BB%A7%E6%89%BF%E5%8C%BA%E5%88%AB.png)\n\n\n\n\n\n\n\n\n\n\n",[[1562286921460,["GJX@GJXAIOU",[[1,1436," "]],[1436,1436],[1437,1437]]],[1562286922919,["GJX@GJXAIOU",[[-1,1435,"; "]],[1437,1437],[1435,1435]]],[1562286924396,["GJX@GJXAIOU",[[1,1435,"；"]],[1435,1435],[1436,1436]]],[1562286925017,["GJX@GJXAIOU",[[-1,1435,"；"]],[1436,1436],[1435,1435]]],[1562286936076,["GJX@GJXAIOU",[[1,1435,"; //注意导包：jaba"]],[1435,1435],[1448,1448]]],[1562286936503,["GJX@GJXAIOU",[[-1,1447,"a"]],[1448,1448],[1447,1447]]],[1562286936841,["GJX@GJXAIOU",[[1,1447,"v"]],[1447,1447],[1448,1448]]],[1562286937288,["GJX@GJXAIOU",[[-1,1446,"bv"]],[1448,1448],[1446,1446]]],[1562286947011,["GJX@GJXAIOU",[[1,1446,"va.util.ArrayList包"]],[1446,1446],[1464,1464]]],[1562287203081,["GJX@GJXAIOU",[[-1,2601,"\n"]],[2602,2602],[2601,2601]]],[1562287204184,["GJX@GJXAIOU",[[-1,2601,"\t\t"]],[2601,2601],[2599,2599]]],[1562287204430,["GJX@GJXAIOU",[[-1,2598,"\n"]],[2599,2599],[2598,2598]]],[1562287206903,["GJX@GJXAIOU",[[-1,2603,"\n"]],[2604,2604],[2603,2603]]],[1562287330825,["GJX@GJXAIOU",[[1,3961,"**"],[1,3999,"**"]],[3961,3999],[3961,4003]]],[1562287886655,["GJX@GJXAIOU",[[-1,8235,"0"]],[8236,8236],[8235,8235]]],[1562287888382,["GJX@GJXAIOU",[[1,8235,"o"]],[8235,8235],[8236,8236]]],[1562287891654,["GJX@GJXAIOU",[[-1,8369,"0"]],[8370,8370],[8369,8369]]],[1562287891820,["GJX@GJXAIOU",[[1,8369,"o"]],[8369,8369],[8370,8370]]],[1562287894159,["GJX@GJXAIOU",[[-1,8414,"0"]],[8415,8415],[8414,8414]]],[1562287894322,["GJX@GJXAIOU",[[1,8414,"o"]],[8414,8414],[8415,8415]]],[1562287896935,["GJX@GJXAIOU",[[-1,8532,"0"]],[8533,8533],[8532,8532]]],[1562287897265,["GJX@GJXAIOU",[[1,8532,"o"]],[8532,8532],[8533,8533]]]],null,"GJX@GJXAIOU"],["7ce1bb1a-7250-4405-a3d2-5fe33f89366b",1563368302547,"# JavaEEDay16-集合\n\n## 一、背景：\n- 数组：用于保存大量数据采取的方式；\n  - 可以保存的数据类型：\n    - 8 大基本数据类型 byte/short/int /long/float/double/char/boolean\n    - 自定义类对象：例如 Student Player\n    - Java 中的类对象\n  - 局限性：\n    - 只能保存一种数据类型的数据；\n    - 数组的元素个数创建时是确定的，无法直接对元素个数进行修改；\n    - 数组里面保存的元素内容空间是连续的；\n\n- 问题：如果需要保存任意类型的一个数组，所有的数据类型都可以在这个数组中保存；\n- 答案：使用 Object 数据类型，因为 Object 是 Java 中所有的类的直接父类或者间接父类 基类/根类；\n\n代码示例：\n```java\npackage study;\nimport java.util.Arrays;\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\t//创建一个数据类型为Object数组，元素个数为5\n\t\t\n\t\tObject[] arr = new Object[5];\n\t\tarr[0] = \"hello\";\n\t\tarr[1] = 23;\n\t\tarr[2] = 2.3f;\n\t\tarr[3] = new Demo1();\n\t\tarr[4] = true;\n\t\t\n\tSystem.out.println(Arrays.toString(arr));\n\t}\n}\n\n```\n程序输出结果：\n`[hello, 23, 2.3, study.Demo1@21588809, true]`\n\n\n\n## 二、集合\n\n概念：集合就是存储对象的【容器】\n主要介绍：Collection、List、Set 接口\n- Collection： 集合的总【接口】，规定了很多方法，要求所有【遵从】该接口的类，全部实现；\n  - List： 接口，如果【遵循】了 List 接口，要求实现所有 List 中的方法，具有 List 集合的特征：**有序、可重复**\n  - Set：接口，如果【遵循】了 Set 接口，要求实现所有 Set 中的方法，具有 Set 集合的特征：**无序，不可重复**\n\n首先从 Collection 开始学习，学习之后基本上 List 和 Set 就是在此基础上添加操作\n**Collction 基本方法：**\n- 增：\n  - add(Object o); //添加一个元素，任意类型的\n  - addAll(Collection c); //添加另一个集合\n- 删：\n  - clear(); //清空整个集合\n  - remove(Object o); //删除该集合中指定的元素\n  - removeAll(Colletcion c); //删除两个集合中的交集\n  - retainAll(Collection c); //保留两个集合中的交集，删除其他元素\n- 查：\n  - size(); //获取当前集合有效元素的个数\n  - toArray(); //把当前集合中所有的元素转换成为 Object 类型的数组返回\n  \n```java\npackage study;\n\nimport java.util.ArrayList; //注意导包：java.util.ArrayList包\nimport java.util.Arrays;\nimport java.util.Collection;\n\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\t//Collection 是一个接口，而接口是没有自己的类对象的，但是可以指向【遵从】该接口的类对象\n\t\t//这里借助于常用集合ArrayList来完成；\n\t\tCollection collection  = new ArrayList();\n\t\t\n\t\t//测试添加方法： add(Object 0);\n\t\tcollection.add(\"天气变热了\");\n\t\tcollection.add(\"明天30度啦\");\n\t\tcollection.add(\"测试\");\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试添加方法：addAll(Collection c);\n\t\tCollection collection2 = new ArrayList();\n\t\tcollection2.add(\"测试一\");\n\t\tcollection2.add(\"好热\");\n\t\t\n\t\tcollection.addAll(collection2);\n\t\tSystem.out.println(collection);\n\t\t\n\t\t\n\t\t//测试clear() : 清空集合中所有的元素\n\t\tSystem.out.println(collection);\n\t\tcollection.clear();\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试remove(Object o)\n\t\tcollection.remove(\"测试\");\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试removeAll\n\t\tcollection.removeAll(collection2);\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试retainAll(Collection c)\n\t\tcollection.retainAll(collection2);\n\t\tSystem.err.println(collection);\n\t\t\n\t\t//测试size()\n\t\tSystem.out.println(collection.size());\n\t\t\n\t\t//测试Arrays.toString\n\t\tSystem.out.println(Arrays.toString(collection.toArray()));\t\t\n\t}\t\n}\n\n```\n\n**Collection 其他方法：** 判断方法\n- isEmpty(); //是否为空\n- contains(Object o); //是否包含当前元素\n- containsAll(Colllection c); //是否包含指定集合里面的所有元素\n- equals(Object o); //判断是否相等\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"A\");\n\t\tcollection.add(\"B\");\n\t\tcollection.add(\"C\");\n\t\tcollection.add(\"D\");\n\t\t\n\t\tCollection collection2 = new ArrayList();\n\t\tcollection2.add(\"A\");\n\t\tcollection2.add(\"B\");\n\t\tcollection2.add(\"D\");\n\t\tcollection2.add(\"C\");\n\t\t\n\t\t//测试equal()方法 ； //比较这两个集合之间的元素是否完全相同，放入的位置也相同；\n\t\tcollection.equals(collection2);  //因为顺序不同，结果为false\n\t\t\n\t\t//测试isEmpty方法\n\t\tcollection.isEmpty(); //结果为false\n\t\t\n\t\t//测试 contains(Object o);\n\t\tSystem.out.println(collection.contains(\"A\"));\n\t\tSystem.out.println(collection.contains(\"E\"));\n\t\t\n\t\t//测试containAll(Collection c); //判断传入的集合是不是当前集合的子集\n\t\tSystem.out.println(collection.containsAll(collection2));\n\t}\n\n}\n\n```\n\n\n\n### collection 中判断方法的重写\n\n- contains, containAll,equals 方法；\n  - 发现：\n    - Java 语言中默认判断两个对象是否相同的方式是：判断这两个对象的地址是否相同；\n    - 在这里 student1 对象和 new Student（1, “成龙”）;是两个完全不同的对象，因此判断结果为 false；\n  - 问题：\n    - 因为上面两个对象里面保存的数据其实是一样的，也是符合业务逻辑的，或者是符合生活逻辑的，因此想实现在符合语法的前提下，也符合生活逻辑（即当两个对象中保存的数据一致时，判为相等）；\n  - 解决方法：\n    - 重写 equals 和 hashCode 方法；\n    - 默认情况下：\n      - **hashCode 方法在系统默认情况下，是当前类的对象在内存中地址的十进制数**；（地址默认为 16 进制显示，hashCode 为 10 进制显示）\n      - equals 方法是两个对象相互比较的法则；\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\nclass Student{\n\tprivate int  id;\n\tprivate String name;\n\n\tpublic Student() {\t\n\t\t\n\t}\n\t\n\tpublic  Student(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\t\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\t\n\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\t@Override\n\t//描述当前类对象，当通过打印方法的时候自动调用\n\tpublic String toString() {\n\t\treturn \"[ ID : \" + id + \"    Name : \" + name + \"]\";\n\t}\n\t\n\t//重写equals方法和hashCode方法\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\t//这里的equals方法是Student类重写的方法，当集合调用contains、containsAll、equals方法的时候\n\t\t//都会调用这里的Student类中的equals方法进行比较，比较的对象是Student对象；\n\t\tSystem.out.println(\"Student的equals方法\");\n\t\t\n\t\t//原来的equals方法不符合生活逻辑，仅仅是判断两个对象的地址是否相同，不判断里面的内容是否一致，\n\t\t//重写改变为判断对象中的数据是否一致\n\t\t\n\t\t//1.首先进行强制类型转换\n\t\tStudent student = (Student)obj;\n\t\tSystem.out.println(this.name + \" 和 \" + student.name + \"进行比较\");\n\t\t\n\t\t//这里的this.name.equals(student.name)中的equals方法是调用String类型的equals方法，用于判断两字符串是否相等；\n\t\treturn this.id == student.id && this.name.equals(student.name);\n\t}\n\t\n\t@Override\n\tpublic int hashCode() {\n\t\tSystem.out.println(\"Student 的 HashCode 方法\");\n\t\t//如果重写了equals方法，同时也要重写hashCode方法\n\t\t//因为hashCode值要确定【唯一性】，只要满足自己逻辑就OK，这里认为id是唯一的\n\t\treturn this.id;\n\t}\t\n}\n\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection  =  new ArrayList();\n\t\tStudent student1 = new Student(1,\"张三\");\n\t\tStudent student2 = new Student(2,\"李四\"\t);\n\t\tStudent student3 = new Student(3,\"王五\");\n\t\t\n\t\tcollection.add(student1);\n\t\tcollection.add(student2);\n\t\tcollection.add(student3);\n\t\t\n\t\tSystem.out.println(collection);\n\t\t\n\t\tboolean ret = collection.contains(new Student(1, \"张三\")); //\n\t\tSystem.out.println(ret);\n\t} \n}\n\n```\n\n\n## 迭代器\n\n代码示例\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class DieDaiQi {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray();\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t/*Itreator  迭代器\n\t\t * boolean hasNext();  //判断当前迭代器是否有下一个元素\n\t\t * Object next(); //获取当前迭代器指向的元素，并且获取之后，指向下一个元素；\n\t\t * void remove(); //删除当前迭代器通过next获取到的对象\n\t\t * [要求]: 在通过迭代器调用remove方法时候，之前必须调用过next方法，否则会报异常：java.lang.IllegalAtateException\n\t\t */\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}\n\n```\n\n### 共享资源问题\n\n针对同一个资源，同时两个主体在使用，容易产生冲突；\n代码示例：集合对象和迭代器同时处理集合中的元素，造成冲突；\n```Java\n/**\n * \n */\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * class detail:共享资源处理问题\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class ShareSources {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\tIterator iterator = collection.iterator();\n\t\t\n\t\t//下面代码会抛出异常： java.util.ConcurrentModificationException\n\t\t/*\n\t\t * 这里存在两种操作集合数据的方式，第一种方式：集合的对象collection；第二种方式：集合的迭代器iterator\n\t\t * 这里两种操作都有查看和删除的权限，但是一方操作的同时，另一方也在操作，或造成共享资源问题；\n\t\t * \n\t\t * 解决方法：\n\t\t *  \t1.使用迭代器操作放弃集合对象操作\n\t\t *  \t2.使用集合对象操作放弃迭代器操作\n\t\t */\n\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tSystem.out.println(iterator.next());\n\t\t\t\t\tcollection.remove(\"李四\");\t\n\t\t}\n\t}\n}\n\n```\n\n\n\n\n\n\n## List\n首先 Collection 接口中的所有方法在这里仍然可以使用，下面是 List 接口中【特有的】方法：\n- 添加：\n  - add(index, Object o); //指定位置上放入元素\n  - addAll(int index, Collection c); //在指定位置上添加一个集合\n- 获取：\n  - Object get(int index); //获取下标的元素\n  - int indexOf(Object o); //获取某个元素的下标位置\n  - int lastIndexOf(Object o); //找到指定元素最后一个出现在集合中的位置\n  - List subList(int fromIndex, int toIndex); //获取子 List 集合\n- 修改：\n  - set(int index, Object o); //设置指定下标上的元素\n- 迭代：\n  - ListIterator();\n\n```java\n\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ListUse {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();  //导包一定要导入java.util.List\n\t\tlist.add(\"张三\");\n\t\tlist.add(\"李四\");\n\t\tlist.add(\"王五\");\n\t\t\n\t\tSystem.out.println(list);\n\t\t\n\t\tlist.add(1, \"赵六\"); //在元素1后面插入“赵六\"\n\t\tSystem.out.println(list);\n\t\t\n\t\t\n\t\tList list2 = new ArrayList();\n\t\tlist2.add(\"陈七\");\n\t\tlist2.add(\"朱九\");\n\t\tlist2.add(\"陈七\");\n\t\tlist.addAll(2,list2);\n\t\tSystem.out.println(list);\n\t\t\n\t\t//get方法\n\t\tSystem.out.println(list.get(1)); \n\t\t\n\t\t//indexOf和lastIndexOf\n\t\tSystem.out.println(list2.indexOf(\"陈七\"));\n\t\tSystem.out.println(list2.lastIndexOf(\"陈七\"));\n\t\t\n\t\t//subList(int fromIndex, int toIndex);\n\t\t//在Java中，所有使用到区间范围的操作，全是要头不要尾；\n\t\tList sublist = list.subList(0, 5);\n\t\tSystem.out.println(sublist);\n\t\t\n\t\tlist.set(list.indexOf(\"张三\"), \"六六六\");\n\t\tSystem.out.println(list);\n\t\t\n\t\t\n\t}\n}\n```\n\n### List 特有迭代器- ListIterator()\n\n- 方法：\n  - hasNext();\n  - next();\n  - remove();\n  - add(Object 0); //在当前迭代器指向的位置上，添加元素，其他元素向后移动；\n  - set(Object 0); //替换 next 获取到的元素；\n  - nextIndex(); //下一个元素的下标；\n\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\n/**\n * class detail:ListIterator\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Listitetator_use {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();\n\t\tlist.add(\"小米\");\n\t\tlist.add(\"华为\");\n\t\tlist.add(\"苹果\");\n\t\t\n\t\t//获取List的特有迭代器\n\tListIterator iterator = list.listIterator();\n\t\n\tSystem.out.println(\"下一个元素\" + iterator.hasNext());\n\tSystem.out.println(\"next获取数据\" + iterator.next());\n\tSystem.out.println(\"set方法进行替换\");\n\titerator.set(\"mi\");\n\t\n\tSystem.out.println(\"添加内容：\");\n\titerator.add(\"VO\");\n\tSystem.out.println(list);\n\t\n\tSystem.out.println(iterator.nextIndex());\n\t}\n}\n\n```\n\n**List 集合的三种遍历方式：**\n- for 循环\n- 迭代器\n- 增强 for 循环\n\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\npublic class ListBianLi {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();\n\t\t\n\t\tlist.add(\"A\");\n\t\tlist.add(\"B\");\n\t\tlist.add(\"C\");\n\t\tlist.add(\"D\");\n\t\tlist.add(\"E\");\n\t\t\n\t\t//使用for循环进行遍历：使用get(int index)  和size()方法\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i));\n\t\t}\n\t\t\n\t\tSystem.out.println(\"*********************\");\n\t\t\n\t\t//使用ListIterator迭代器\n\t\tListIterator iterator = list.listIterator();\n\t\t\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(iterator.next());\n\t\t\t}\n\t\t\n\t\tSystem.out.println(\"*********************\");\n\t\t\n\t\t//增强for循环：实质为迭代器的实现\n\t\tfor(Object object : list) {  //数据类型  变量名\n\t\t\tSystem.out.println(object);\n\t\t}\t\n\t}\n} \n```\n\n\n### ArrayList 【重点】\nArrayList 是底层维护了一个 Object 类型的数组，这样的话这个 ArrayList 既可以保存任意类型的数据，又有数组的优势；\n\n- 特征：\n  - 当调用无参构造方法 ArrayList，这里创建的底层 Object 类型的数组元素个数默认为 10 ，即 DEFAULT_CAPACITY = 10；\n  - 数组查询快、增删慢的特征；\n- 开发中使用较多的场景：\n  - 查询场景较多但是增删较少的程序：例如：图书馆管理系统，人员管理系统；\n\n\n- ArrayList 特有的方法：都不太常用\n  - ensureCapacity(int minCapacity); //判断当前 ArrayList 里面保存元素内容 Object 数组，元素个数是否大于 minCapacity;\n  - trimToSize(); //截断底层维护的 Object 类型的数组，让数组容量变成当前 ArrayList 的 size 值（有效元素个数）\n\n- 查询快、增删慢的原理：\n  - 查询快：因为底层维护的是一个 Object 类型的数组，可以完全使用数组的下标机制来访问数据，这种访问的形式是非常快的；\n  - 增删慢：增加数据时候，可能导致 ArrayList 底层的 Object 数组的元素不够用，那么会调用数组的扩容方法 grow，而扩容方法会创建一个新的数组，数组的元素大于原来数组，同时会将源数据拷贝到新数组中，数据量较大的时候， 拷贝过程耗费时间；\n  - 删除慢：因为删除一个数据，会导致数组中该元素之后的所有数据做一个整体的左移，这也是一次数组的拷贝，浪费时间；\n\n问： ArrayList 是一个可以自增长的空间，请问，增加的原理是什么？增长的长度是多少？\nArrayList 底层维护的是一个 Object 数组，默认的元素个数为 10，如果添加元素，当前需求的元素空间超过了 Object 数组的元素个数，会调用底层的 grow 方法，进行数组的扩容和拷贝；\n其中扩容量大约为 1.5 倍；：newCapacity = oldCapacity +(oldCapacity >> 1);\n即 新元素个数 = 老元素个数 + （老元素个数 >> 1）\n\n### LinkedList\n底层维护的是一个链表，特征：增删快、查找慢\n\nLinkedList 特有的方法：\n- addFirst(Object o);\n- addLast(Object o);\n- getFirst();\n- getLast();\n- removeFirst();\n- removeLast();\n\n\n![LinkedList和ArrayList继承区别]($resource/LinkedList%E5%92%8CArrayList%E7%BB%A7%E6%89%BF%E5%8C%BA%E5%88%AB.png)\n\n\n\n\n\n\n\n\n\n\n",[[1563368258757,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1563368258895,["GJX@GJXAIOU",[[1,0,"\n"]],[1,1],[2,2]]],[1563368259007,["GJX@GJXAIOU",[[1,2,"\n"]],[2,2],[3,3]]],[1563368261413,["GJX@GJXAIOU",[[1,0,"---\ntags : \n- java基础\n\nflag: yellow\n---\n@toc\n"]],[0,0],[44,44]]],[1563368264101,["GJX@GJXAIOU",[[-1,46,"\n"]],[46,46],[45,45]]],[1563368264461,["GJX@GJXAIOU",[[-1,45,"\n"]],[45,45],[44,44]]],[1563368779903,["GJX@GJXAIOU",[[1,315,"=="],[1,330,"=="]],[315,330],[315,334]]],[1563368783488,["GJX@GJXAIOU",[[1,360,"=="],[1,374,"=="]],[360,374],[360,378]]],[1563368887795,["GJX@GJXAIOU",[[1,964,"=="],[1,985,"=="]],[964,985],[964,989]]],[1563368891335,["GJX@GJXAIOU",[[1,1035,"=="],[1,1056,"=="]],[1035,1056],[1035,1060]]],[1563369655086,["GJX@GJXAIOU",[[1,822,"\n"]],[822,822],[823,823]]],[1563369658215,["GJX@GJXAIOU",[[-1,821,"："]],[822,822],[821,821]]],[1563369665918,["GJX@GJXAIOU",[[1,819,"### （）"]],[819,819],[825,825]]],[1563369667667,["GJX@GJXAIOU",[[1,824,"一"]],[824,824],[825,825]]],[1563369673479,["GJX@GJXAIOU",[[1,1120,"### "]],[1120,1120],[1143,1143]]],[1563369675710,["GJX@GJXAIOU",[[-1,1141,"**"]],[1143,1143],[1141,1141]]],[1563369678406,["GJX@GJXAIOU",[[-1,1124,"**"]],[1126,1126],[1124,1124]]],[1563369680248,["GJX@GJXAIOU",[[1,1124,"（）"]],[1124,1124],[1126,1126]]],[1563369682371,["GJX@GJXAIOU",[[1,1125,"二"]],[1125,1125],[1126,1126]]],[1563369724296,["GJX@GJXAIOU",[[1,2684,"### "]],[2685,2685],[2713,2713]]],[1563369728134,["GJX@GJXAIOU",[[-1,2706,"** "]],[2706,2709],[2706,2706]]],[1563369729719,["GJX@GJXAIOU",[[-1,2688,"**"]],[2690,2690],[2688,2688]]],[1563369733016,["GJX@GJXAIOU",[[1,2688,"（）"]],[2688,2688],[2690,2690]]],[1563369734740,["GJX@GJXAIOU",[[1,2689,"三"]],[2689,2689],[2690,2690]]],[1563369770154,["GJX@GJXAIOU",[[1,3689,"（）"]],[3689,3689],[3691,3691]]],[1563369772331,["GJX@GJXAIOU",[[1,3690,"四"]],[3690,3690],[3691,3691]]],[1563370724024,["GJX@GJXAIOU",[[1,5968,"\n"]],[5965,5965],[5966,5966]]],[1563370728467,["GJX@GJXAIOU",[[1,5966,"程序运行结果："]],[5966,5966],[5973,5973]]],[1563370728865,["GJX@GJXAIOU",[[1,5976,"\n"]],[5973,5973],[5974,5974]]],[1563370730970,["GJX@GJXAIOU",[[1,5974,"```java"]],[5974,5974],[5981,5981]]],[1563370731304,["GJX@GJXAIOU",[[1,5984,"\n"]],[5981,5981],[5982,5982]]],[1563370731506,["GJX@GJXAIOU",[[1,5985,"\n"]],[5982,5982],[5983,5983]]],[1563370732347,["GJX@GJXAIOU",[[1,5983,"```"]],[5983,5983],[5986,5986]]],[1563370733727,["GJX@GJXAIOU",[[1,5982,"[[ ID : 1    Name : 张三], [ ID : 2    Name : 李四], [ ID : 3    Name : 王五]]\nStudent的equals方法\n张三 和 张三进行比较\ntrue"]],[5982,5982],[6088,6088]]],[1563370748082,["GJX@GJXAIOU",[[1,808,"---"]],[808,808],[811,811]]],[1563370757500,["GJX@GJXAIOU",[[1,6101,"s "]],[6101,6101],[6102,6102]]],[1563370757745,["GJX@GJXAIOU",[[1,6102,"an"]],[6102,6102],[6104,6104]]],[1563370759200,["GJX@GJXAIOU",[[-1,6101,"san"]],[6104,6104],[6101,6101]]],[1563370760789,["GJX@GJXAIOU",[[1,6101,"三、"]],[6101,6101],[6103,6103]]],[1563370763776,["GJX@GJXAIOU",[[1,6098,"\n"]],[6097,6097],[6098,6098]]],[1563370763961,["GJX@GJXAIOU",[[1,6099,"\n"]],[6098,6098],[6099,6099]]],[1563370765627,["GJX@GJXAIOU",[[1,6098,"---"]],[6098,6098],[6101,6101]]],[1563371600819,["GJX@GJXAIOU",[[-1,7489,"#"]],[7490,7490],[7489,7489]]],[1563371603822,["GJX@GJXAIOU",[[1,7490,"四、"]],[7490,7490],[7492,7492]]],[1563371608561,["GJX@GJXAIOU",[[-1,7564,"/**\n * \n */"]],[7564,7575],[7564,7564]]],[1563371609215,["GJX@GJXAIOU",[[-1,7564,"\n"]],[7564,7564],[7563,7563]]],[1563371622593,["GJX@GJXAIOU",[[1,8352,"五 "]],[8352,8352],[8353,8353]]],[1563371622875,["GJX@GJXAIOU",[[1,8353,"、"]],[8353,8353],[8354,8354]]],[1563371628585,["GJX@GJXAIOU",[[-1,8354," "]],[8355,8355],[8354,8354]]],[1563371636336,["GJX@GJXAIOU",[[-1,8789,"\n"]],[8789,8789],[8788,8788]]],[1563371642373,["GJX@GJXAIOU",[[1,9678,"（）"]],[9678,9678],[9680,9680]]],[1563371643604,["GJX@GJXAIOU",[[1,9679,"一"]],[9679,9679],[9680,9680]]],[1563371651808,["GJX@GJXAIOU",[[-1,10584,"**"]],[10584,10586],[10584,10584]]],[1563371654242,["GJX@GJXAIOU",[[1,10584,"### "]],[10584,10584],[10605,10605]]],[1563371655935,["GJX@GJXAIOU",[[1,10605,"90"]],[10605,10605],[10607,10607]]],[1563371659399,["GJX@GJXAIOU",[[-1,10603,"**90"]],[10607,10607],[10603,10603]]],[1563371662794,["GJX@GJXAIOU",[[1,10588,"()"]],[10588,10588],[10590,10590]]],[1563371664232,["GJX@GJXAIOU",[[1,10589,"er "]],[10589,10589],[10592,10592]]],[1563371665854,["GJX@GJXAIOU",[[-1,10589,"er "]],[10592,10592],[10589,10589]]],[1563371666635,["GJX@GJXAIOU",[[1,10589,"er "]],[10589,10589],[10592,10592]]],[1563371667865,["GJX@GJXAIOU",[[-1,10589,"er "]],[10592,10592],[10589,10589]]],[1563371669199,["GJX@GJXAIOU",[[1,10589,"二"]],[10589,10589],[10590,10590]]],[1563371675774,["GJX@GJXAIOU",[[1,11428,"（）"]],[11428,11428],[11430,11430]]],[1563371677495,["GJX@GJXAIOU",[[1,11429,"三"]],[11429,11429],[11430,11430]]],[1563371683636,["GJX@GJXAIOU",[[1,12394,"（）"]],[12394,12394],[12396,12396]]],[1563371685365,["GJX@GJXAIOU",[[1,12395,"四"]],[12395,12395],[12396,12396]]],[1563371761011,["GJX@GJXAIOU",[[1,10591," "]],[10591,10591],[10592,10592]]],[1563371763611,["GJX@GJXAIOU",[[1,10588," "]],[10587,10587],[10588,10588]]],[1563371780544,["GJX@GJXAIOU",[[-1,10588," (二) "]],[10587,10592],[10587,10587]]],[1563371781091,["GJX@GJXAIOU",[[1,10588," "]],[10587,10587],[10588,10588]]],[1563371782279,["GJX@GJXAIOU",[[1,10588,"（）"]],[10588,10588],[10590,10590]]],[1563371783989,["GJX@GJXAIOU",[[1,10589,"二"]],[10589,10589],[10590,10590]]],[1563371786464,["GJX@GJXAIOU",[[-1,10591," "]],[10592,10592],[10591,10591]]]],null,"GJX@GJXAIOU"],["edfc0186-b054-424b-92ab-3ee608d57141",1563411244359,"---\ntags : \n- java基础\n\nflag: yellow\n---\n@toc\n\n# JavaEEDay16-集合\n\n## 一、背景：\n- 数组：用于保存大量数据采取的方式；\n  - 可以保存的数据类型：\n    - 8 大基本数据类型 byte/short/int /long/float/double/char/boolean\n    - 自定义类对象：例如 Student Player\n    - Java 中的类对象\n  - 局限性：\n    - 只能保存一种数据类型的数据；\n    - 数组的元素个数创建时是确定的，无法直接对元素个数进行修改；\n    - 数组里面保存的元素内容空间是连续的；\n\n- 问题：==如果需要保存任意类型的一个数组==，所有的数据类型都可以在这个数组中保存；\n- 答案：==使用 Object 数据类型==，因为 Object 是 Java 中所有的类的直接父类或者间接父类 基类/根类；\n\n代码示例：\n```java\npackage study;\nimport java.util.Arrays;\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\t//创建一个数据类型为Object数组，元素个数为5\n\t\t\n\t\tObject[] arr = new Object[5];\n\t\tarr[0] = \"hello\";\n\t\tarr[1] = 23;\n\t\tarr[2] = 2.3f;\n\t\tarr[3] = new Demo1();\n\t\tarr[4] = true;\n\t\t\n\tSystem.out.println(Arrays.toString(arr));\n\t}\n}\n\n```\n程序输出结果：\n`[hello, 23, 2.3, study.Demo1@21588809, true]`\n\n---\n\n## 二、集合\n\n### （一）概念\n集合就是存储对象的【容器】\n主要介绍：Collection、List、Set 接口\n- Collection： 集合的总【接口】，规定了很多方法，要求所有【遵从】该接口的类，全部实现；\n  - List： 接口，如果【遵循】了 List 接口，要求实现所有 List 中的方法，具有 ==List 集合的特征：**有序、可重复**==\n  - Set：接口，如果【遵循】了 Set 接口，要求实现所有 Set 中的方法，具有 ==Set 集合的特征：**无序，不可重复**==\n\n首先从 Collection 开始学习，学习之后基本上 List 和 Set 就是在此基础上添加操作\n### （二）Collction 基本方法：\n- 增：\n  - add(Object o); //添加一个元素，任意类型的\n  - addAll(Collection c); //添加另一个集合\n- 删：\n  - clear(); //清空整个集合\n  - remove(Object o); //删除该集合中指定的元素\n  - removeAll(Colletcion c); //删除两个集合中的交集\n  - retainAll(Collection c); //保留两个集合中的交集，删除其他元素\n- 查：\n  - size(); //获取当前集合有效元素的个数\n  - toArray(); //把当前集合中所有的元素转换成为 Object 类型的数组返回\n  \n```java\npackage study;\n\nimport java.util.ArrayList; //注意导包：java.util.ArrayList包\nimport java.util.Arrays;\nimport java.util.Collection;\n\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\t//Collection 是一个接口，而接口是没有自己的类对象的，但是可以指向【遵从】该接口的类对象\n\t\t//这里借助于常用集合ArrayList来完成；\n\t\tCollection collection  = new ArrayList();\n\t\t\n\t\t//测试添加方法： add(Object 0);\n\t\tcollection.add(\"天气变热了\");\n\t\tcollection.add(\"明天30度啦\");\n\t\tcollection.add(\"测试\");\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试添加方法：addAll(Collection c);\n\t\tCollection collection2 = new ArrayList();\n\t\tcollection2.add(\"测试一\");\n\t\tcollection2.add(\"好热\");\n\t\t\n\t\tcollection.addAll(collection2);\n\t\tSystem.out.println(collection);\n\t\t\n\t\t\n\t\t//测试clear() : 清空集合中所有的元素\n\t\tSystem.out.println(collection);\n\t\tcollection.clear();\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试remove(Object o)\n\t\tcollection.remove(\"测试\");\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试removeAll\n\t\tcollection.removeAll(collection2);\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//测试retainAll(Collection c)\n\t\tcollection.retainAll(collection2);\n\t\tSystem.err.println(collection);\n\t\t\n\t\t//测试size()\n\t\tSystem.out.println(collection.size());\n\t\t\n\t\t//测试Arrays.toString\n\t\tSystem.out.println(Arrays.toString(collection.toArray()));\t\t\n\t}\t\n}\n\n```\n\n### （三）Collection 其他方法：判断方法\n- isEmpty(); //是否为空\n- contains(Object o); //是否包含当前元素\n- containsAll(Colllection c); //是否包含指定集合里面的所有元素\n- equals(Object o); //判断是否相等\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class Demo3 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"A\");\n\t\tcollection.add(\"B\");\n\t\tcollection.add(\"C\");\n\t\tcollection.add(\"D\");\n\t\t\n\t\tCollection collection2 = new ArrayList();\n\t\tcollection2.add(\"A\");\n\t\tcollection2.add(\"B\");\n\t\tcollection2.add(\"D\");\n\t\tcollection2.add(\"C\");\n\t\t\n\t\t//测试equal()方法 ； //比较这两个集合之间的元素是否完全相同，放入的位置也相同；\n\t\tcollection.equals(collection2);  //因为顺序不同，结果为false\n\t\t\n\t\t//测试isEmpty方法\n\t\tcollection.isEmpty(); //结果为false\n\t\t\n\t\t//测试 contains(Object o);\n\t\tSystem.out.println(collection.contains(\"A\"));\n\t\tSystem.out.println(collection.contains(\"E\"));\n\t\t\n\t\t//测试containAll(Collection c); //判断传入的集合是不是当前集合的子集\n\t\tSystem.out.println(collection.containsAll(collection2));\n\t}\n\n}\n\n```\n\n\n\n### （四）collection 中判断方法的重写\n\n- contains, containAll,equals 方法；\n  - 发现：\n    - Java 语言中默认判断两个对象是否相同的方式是：判断这两个对象的地址是否相同；\n    - 在这里 student1 对象和 new Student（1, “成龙”）;是两个完全不同的对象，因此判断结果为 false；\n  - 问题：\n    - 因为上面两个对象里面保存的数据其实是一样的，也是符合业务逻辑的，或者是符合生活逻辑的，因此想实现在符合语法的前提下，也符合生活逻辑（即当两个对象中保存的数据一致时，判为相等）；\n  - 解决方法：\n    - 重写 equals 和 hashCode 方法；\n    - 默认情况下：\n      - **hashCode 方法在系统默认情况下，是当前类的对象在内存中地址的十进制数**；（地址默认为 16 进制显示，hashCode 为 10 进制显示）\n      - equals 方法是两个对象相互比较的法则；\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\nclass Student{\n\tprivate int  id;\n\tprivate String name;\n\n\tpublic Student() {\t\n\t\t\n\t}\n\t\n\tpublic  Student(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\t\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\t\n\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\t@Override\n\t//描述当前类对象，当通过打印方法的时候自动调用\n\tpublic String toString() {\n\t\treturn \"[ ID : \" + id + \"    Name : \" + name + \"]\";\n\t}\n\t\n\t//重写equals方法和hashCode方法\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\t//这里的equals方法是Student类重写的方法，当集合调用contains、containsAll、equals方法的时候\n\t\t//都会调用这里的Student类中的equals方法进行比较，比较的对象是Student对象；\n\t\tSystem.out.println(\"Student的equals方法\");\n\t\t\n\t\t//原来的equals方法不符合生活逻辑，仅仅是判断两个对象的地址是否相同，不判断里面的内容是否一致，\n\t\t//重写改变为判断对象中的数据是否一致\n\t\t\n\t\t//1.首先进行强制类型转换\n\t\tStudent student = (Student)obj;\n\t\tSystem.out.println(this.name + \" 和 \" + student.name + \"进行比较\");\n\t\t\n\t\t//这里的this.name.equals(student.name)中的equals方法是调用String类型的equals方法，用于判断两字符串是否相等；\n\t\treturn this.id == student.id && this.name.equals(student.name);\n\t}\n\t\n\t@Override\n\tpublic int hashCode() {\n\t\tSystem.out.println(\"Student 的 HashCode 方法\");\n\t\t//如果重写了equals方法，同时也要重写hashCode方法\n\t\t//因为hashCode值要确定【唯一性】，只要满足自己逻辑就OK，这里认为id是唯一的\n\t\treturn this.id;\n\t}\t\n}\n\n\npublic class Demo1 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection  =  new ArrayList();\n\t\tStudent student1 = new Student(1,\"张三\");\n\t\tStudent student2 = new Student(2,\"李四\"\t);\n\t\tStudent student3 = new Student(3,\"王五\");\n\t\t\n\t\tcollection.add(student1);\n\t\tcollection.add(student2);\n\t\tcollection.add(student3);\n\t\t\n\t\tSystem.out.println(collection);\n\t\t\n\t\tboolean ret = collection.contains(new Student(1, \"张三\")); //\n\t\tSystem.out.println(ret);\n\t} \n}\n\n```\n程序运行结果：\n```java\n[[ ID : 1    Name : 张三], [ ID : 2    Name : 李四], [ ID : 3    Name : 王五]]\nStudent的equals方法\n张三 和 张三进行比较\ntrue\n```\n\n\n---\n\n## 三、 迭代器\n\n代码示例\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class DieDaiQi {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray();\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t/*Itreator  迭代器\n\t\t * boolean hasNext();  //判断当前迭代器是否有下一个元素\n\t\t * Object next(); //获取当前迭代器指向的元素，并且获取之后，指向下一个元素；\n\t\t * void remove(); //删除当前迭代器通过next获取到的对象\n\t\t * [要求]: 在通过迭代器调用remove方法时候，之前必须调用过next方法，否则会报异常：java.lang.IllegalAtateException\n\t\t */\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}\n\n```\n\n## 四、共享资源问题\n\n针对同一个资源，同时两个主体在使用，容易产生冲突；\n代码示例：集合对象和迭代器同时处理集合中的元素，造成冲突；\n```Java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * class detail:共享资源处理问题\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class ShareSources {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\tIterator iterator = collection.iterator();\n\t\t\n\t\t//下面代码会抛出异常： java.util.ConcurrentModificationException\n\t\t/*\n\t\t * 这里存在两种操作集合数据的方式，第一种方式：集合的对象collection；第二种方式：集合的迭代器iterator\n\t\t * 这里两种操作都有查看和删除的权限，但是一方操作的同时，另一方也在操作，或造成共享资源问题；\n\t\t * \n\t\t * 解决方法：\n\t\t *  \t1.使用迭代器操作放弃集合对象操作\n\t\t *  \t2.使用集合对象操作放弃迭代器操作\n\t\t */\n\t\twhile (iterator.hasNext()) {\n\t\t\t\t\tSystem.out.println(iterator.next());\n\t\t\t\t\tcollection.remove(\"李四\");\t\n\t\t}\n\t}\n}\n\n```\n\n\n\n\n\n\n## 五、List\n首先 Collection 接口中的所有方法在这里仍然可以使用，下面是 List 接口中【特有的】方法：\n- 添加：\n  - add(index, Object o); //指定位置上放入元素\n  - addAll(int index, Collection c); //在指定位置上添加一个集合\n- 获取：\n  - Object get(int index); //获取下标的元素\n  - int indexOf(Object o); //获取某个元素的下标位置\n  - int lastIndexOf(Object o); //找到指定元素最后一个出现在集合中的位置\n  - List subList(int fromIndex, int toIndex); //获取子 List 集合\n- 修改：\n  - set(int index, Object o); //设置指定下标上的元素\n- 迭代：\n  - ListIterator();\n\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ListUse {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();  //导包一定要导入java.util.List\n\t\tlist.add(\"张三\");\n\t\tlist.add(\"李四\");\n\t\tlist.add(\"王五\");\n\t\t\n\t\tSystem.out.println(list);\n\t\t\n\t\tlist.add(1, \"赵六\"); //在元素1后面插入“赵六\"\n\t\tSystem.out.println(list);\n\t\t\n\t\t\n\t\tList list2 = new ArrayList();\n\t\tlist2.add(\"陈七\");\n\t\tlist2.add(\"朱九\");\n\t\tlist2.add(\"陈七\");\n\t\tlist.addAll(2,list2);\n\t\tSystem.out.println(list);\n\t\t\n\t\t//get方法\n\t\tSystem.out.println(list.get(1)); \n\t\t\n\t\t//indexOf和lastIndexOf\n\t\tSystem.out.println(list2.indexOf(\"陈七\"));\n\t\tSystem.out.println(list2.lastIndexOf(\"陈七\"));\n\t\t\n\t\t//subList(int fromIndex, int toIndex);\n\t\t//在Java中，所有使用到区间范围的操作，全是要头不要尾；\n\t\tList sublist = list.subList(0, 5);\n\t\tSystem.out.println(sublist);\n\t\t\n\t\tlist.set(list.indexOf(\"张三\"), \"六六六\");\n\t\tSystem.out.println(list);\n\t\t\n\t\t\n\t}\n}\n```\n\n### （一）List 特有迭代器- ListIterator()\n\n- 方法：\n  - hasNext();\n  - next();\n  - remove();\n  - add(Object 0); //在当前迭代器指向的位置上，添加元素，其他元素向后移动；\n  - set(Object 0); //替换 next 获取到的元素；\n  - nextIndex(); //下一个元素的下标；\n\n\n代码示例：\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\n/**\n * class detail:ListIterator\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Listitetator_use {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();\n\t\tlist.add(\"小米\");\n\t\tlist.add(\"华为\");\n\t\tlist.add(\"苹果\");\n\t\t\n\t\t//获取List的特有迭代器\n\tListIterator iterator = list.listIterator();\n\t\n\tSystem.out.println(\"下一个元素\" + iterator.hasNext());\n\tSystem.out.println(\"next获取数据\" + iterator.next());\n\tSystem.out.println(\"set方法进行替换\");\n\titerator.set(\"mi\");\n\t\n\tSystem.out.println(\"添加内容：\");\n\titerator.add(\"VO\");\n\tSystem.out.println(list);\n\t\n\tSystem.out.println(iterator.nextIndex());\n\t}\n}\n\n```\n\n### （二）List 集合的三种遍历方式：\n- for 循环\n- 迭代器\n- 增强 for 循环\n\n```java\npackage study;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\npublic class ListBianLi {\n\tpublic static void main(String[] args) {\n\t\tList list = new ArrayList();\n\t\t\n\t\tlist.add(\"A\");\n\t\tlist.add(\"B\");\n\t\tlist.add(\"C\");\n\t\tlist.add(\"D\");\n\t\tlist.add(\"E\");\n\t\t\n\t\t//使用for循环进行遍历：使用get(int index)  和size()方法\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i));\n\t\t}\n\t\t\n\t\tSystem.out.println(\"*********************\");\n\t\t\n\t\t//使用ListIterator迭代器\n\t\tListIterator iterator = list.listIterator();\n\t\t\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(iterator.next());\n\t\t\t}\n\t\t\n\t\tSystem.out.println(\"*********************\");\n\t\t\n\t\t//增强for循环：实质为迭代器的实现\n\t\tfor(Object object : list) {  //数据类型  变量名\n\t\t\tSystem.out.println(object);\n\t\t}\t\n\t}\n} \n```\n\n\n### （三）ArrayList 【重点】\nArrayList 是底层维护了一个 Object 类型的数组，这样的话这个 ArrayList 既可以保存任意类型的数据，又有数组的优势；\n\n- 特征：\n  - 当调用无参构造方法 ArrayList，这里创建的底层 Object 类型的数组元素个数默认为 10 ，即 DEFAULT_CAPACITY = 10；\n  - 数组查询快、增删慢的特征；\n- 开发中使用较多的场景：\n  - 查询场景较多但是增删较少的程序：例如：图书馆管理系统，人员管理系统；\n\n\n- ArrayList 特有的方法：都不太常用\n  - ensureCapacity(int minCapacity); //判断当前 ArrayList 里面保存元素内容 Object 数组，元素个数是否大于 minCapacity;\n  - trimToSize(); //截断底层维护的 Object 类型的数组，让数组容量变成当前 ArrayList 的 size 值（有效元素个数）\n\n- 查询快、增删慢的原理：\n  - 查询快：因为底层维护的是一个 Object 类型的数组，可以完全使用数组的下标机制来访问数据，这种访问的形式是非常快的；\n  - 增删慢：增加数据时候，可能导致 ArrayList 底层的 Object 数组的元素不够用，那么会调用数组的扩容方法 grow，而扩容方法会创建一个新的数组，数组的元素大于原来数组，同时会将源数据拷贝到新数组中，数据量较大的时候， 拷贝过程耗费时间；\n  - 删除慢：因为删除一个数据，会导致数组中该元素之后的所有数据做一个整体的左移，这也是一次数组的拷贝，浪费时间；\n\n问： ArrayList 是一个可以自增长的空间，请问，增加的原理是什么？增长的长度是多少？\nArrayList 底层维护的是一个 Object 数组，默认的元素个数为 10，如果添加元素，当前需求的元素空间超过了 Object 数组的元素个数，会调用底层的 grow 方法，进行数组的扩容和拷贝；\n其中扩容量大约为 1.5 倍；：newCapacity = oldCapacity +(oldCapacity >> 1);\n即 新元素个数 = 老元素个数 + （老元素个数 >> 1）\n\n### （四）LinkedList\n底层维护的是一个链表，特征：增删快、查找慢\n\nLinkedList 特有的方法：\n- addFirst(Object o);\n- addLast(Object o);\n- getFirst();\n- getLast();\n- removeFirst();\n- removeLast();\n\n\n![LinkedList和ArrayList继承区别]($resource/LinkedList%E5%92%8CArrayList%E7%BB%A7%E6%89%BF%E5%8C%BA%E5%88%AB.png)\n\n\n\n\n\n\n\n\n\n\n",[[1563411189248,["GJX@GJXAIOU",[[1,6610," 、、"]],[6610,6610],[6613,6613]]],[1563411189927,["GJX@GJXAIOU",[[-1,6611,"、、"]],[6613,6613],[6611,6611]]],[1563411197466,["GJX@GJXAIOU",[[1,6611,"//toArrayshi"]],[6611,6611],[6623,6623]]],[1563411198189,["GJX@GJXAIOU",[[-1,6620,"shi"]],[6623,6623],[6620,6620]]],[1563411199406,["GJX@GJXAIOU",[[1,6620,"（）"]],[6620,6620],[6622,6622]]],[1563411200501,["GJX@GJXAIOU",[[-1,6619,"y（）"]],[6622,6622],[6619,6619]]],[1563411205795,["GJX@GJXAIOU",[[1,6619,"y()是转换为"]],[6619,6619],[6626,6626]]],[1563411234993,["GJX@GJXAIOU",[[1,6611,"\n\t\t"]],[6611,6611],[6614,6614]]],[1563411253978,["GJX@GJXAIOU",[[1,6629,"Object类型的数组"]],[6629,6629],[6640,6640]]],[1563411256766,["GJX@GJXAIOU",[[1,6643,"\n\t\t"]],[6640,6640],[6643,6643]]],[1563411350878,["GJX@GJXAIOU",[[1,6114,"\n"]],[6113,6113],[6114,6114]]],[1563411351008,["GJX@GJXAIOU",[[1,6115,"\n"]],[6114,6114],[6115,6115]]],[1563411352600,["GJX@GJXAIOU",[[1,6114,"/*Itreator  迭代器\n\t\t * boolean hasNext();  //判断当前迭代器是否有下一个元素\n\t\t * Object next(); //获取当前迭代器指向的元素，并且获取之后，指向下一个元素；\n\t\t * void remove(); //删除当前迭代器通过next获取到的对象\n\t\t * [要求]: 在通过迭代器调用remove方法时候，之前必须调用过next方法，否则会报异常：java.lang.IllegalAtateException\n\t\t */"]],[6114,6114],[6354,6354]]],[1563411359879,["GJX@GJXAIOU",[[-1,6114,"/*Itreator"]],[6114,6116],[6114,6114]]],[1563411362141,["GJX@GJXAIOU",[[1,6112," Itreator"]],[6112,6112],[6121,6121]]],[1563411371336,["GJX@GJXAIOU",[[-1,6123,"  迭代器"]],[6123,6128],[6123,6123]]],[1563411375625,["GJX@GJXAIOU",[[1,6123,"- 常用方法："]],[6123,6123],[6130,6130]]],[1563411382896,["GJX@GJXAIOU",[[-1,6132,"\t"],[-1,6174,"\t"],[-1,6226,"\t"],[-1,6267,"\t"]],[6134,6277],[6133,6273]]],[1563411383638,["GJX@GJXAIOU",[[-1,6131,"\t"],[-1,6173,"\t"],[-1,6223,"\t"],[-1,6264,"\t"]],[6133,6273],[6132,6269]]],[1563411385310,["GJX@GJXAIOU",[[-1,6131," "],[-1,6172," "],[-1,6221," "],[-1,6261," "]],[6132,6269],[6132,6269]]],[1563411386352,["GJX@GJXAIOU",[[1,6131,"  "],[1,6171,"  "],[1,6219,"  "],[1,6258,"  "]],[6132,6269],[6134,6277]]],[1563411510792,["GJX@GJXAIOU",[[1,6131,"- \n"]],[6130,6130],[6133,6133]]],[1563411511965,["GJX@GJXAIOU",[[-1,6131,"- "]],[6133,6133],[6131,6131]]],[1563411527996,["GJX@GJXAIOU",[[1,6131,"返回值类型 | 方法名  | 含义"]],[6131,6131],[6148,6148]]],[1563411528965,["GJX@GJXAIOU",[[1,6149,"\n"]],[6148,6148],[6149,6149]]],[1563411533962,["GJX@GJXAIOU",[[1,6149,"---| -- |---"]],[6149,6149],[6161,6161]]],[1563411535175,["GJX@GJXAIOU",[[1,6164," |    |   \n  "]],[6161,6161],[6162,6165]]],[1563411539517,["GJX@GJXAIOU",[[-1,6176," * "]],[6175,6178],[6175,6175]]],[1563411541456,["GJX@GJXAIOU",[[-1,6214,"  * "]],[6214,6218],[6214,6214]]],[1563411542605,["GJX@GJXAIOU",[[-1,6175," "]],[6176,6176],[6175,6175]]],[1563411544453,["GJX@GJXAIOU",[[-1,6259,"  * "]],[6259,6263],[6259,6259]]],[1563411546016,["GJX@GJXAIOU",[[1,6183," "]],[6182,6182],[6183,6183]]],[1563411547082,["GJX@GJXAIOU",[[1,6183,"|"]],[6183,6183],[6184,6184]]],[1563411551324,["GJX@GJXAIOU",[[1,6222," | "]],[6222,6222],[6225,6225]]],[1563411554506,["GJX@GJXAIOU",[[1,6269,"| "]],[6269,6269],[6271,6271]]],[1563411557588,["GJX@GJXAIOU",[[1,6195,"|"]],[6195,6195],[6196,6196]]],[1563411560107,["GJX@GJXAIOU",[[1,6234," |"]],[6234,6234],[6236,6236]]],[1563411562114,["GJX@GJXAIOU",[[1,6283,"|"]],[6283,6283],[6284,6284]]],[1563411563464,["GJX@GJXAIOU",[[1,6283," "]],[6283,6283],[6284,6284]]],[1563411564490,["GJX@GJXAIOU",[[1,6236," "]],[6236,6236],[6237,6237]]],[1563411566717,["GJX@GJXAIOU",[[-1,6162,"   |    |   "]],[6162,6174],[6162,6162]]],[1563411567383,["GJX@GJXAIOU",[[-1,6162,"\n"]],[6162,6162],[6161,6161]]],[1563411578638,["GJX@GJXAIOU",[[-1,6378,"\t\t */"]],[6378,6383],[6378,6378]]],[1563411582257,["GJX@GJXAIOU",[[1,6298,"\n  "]],[6298,6298],[6301,6301]]],[1563411584600,["GJX@GJXAIOU",[[1,6131,"- \n"]],[6130,6130],[6133,6133]]],[1563411585262,["GJX@GJXAIOU",[[-1,6131,"- "]],[6133,6133],[6131,6131]]],[1563411590878,["GJX@GJXAIOU",[[-1,6300,"  * "]],[6300,6304],[6300,6300]]],[1563411597039,["GJX@GJXAIOU",[[-1,6297,"  "]],[6299,6299],[6297,6297]]],[1563411597536,["GJX@GJXAIOU",[[-1,6297,"\n"]],[6297,6297],[6296,6296]]],[1563411600728,["GJX@GJXAIOU",[[1,6297,"\n"]],[6297,6297],[6298,6298]]],[1563411601206,["GJX@GJXAIOU",[[1,6298,"\n"]],[6298,6298],[6299,6299]]],[1563411605248,["GJX@GJXAIOU",[[1,6299,"- "]],[6299,6299],[6301,6301]]],[1563411606518,["GJX@GJXAIOU",[[-1,6300," "]],[6301,6301],[6300,6300]]],[1563411620572,["GJX@GJXAIOU",[[-1,6131,"\n"]],[6131,6131],[6130,6130]]],[1563411621998,["GJX@GJXAIOU",[[1,6131,"- \n"]],[6130,6130],[6133,6133]]],[1563411622927,["GJX@GJXAIOU",[[-1,6131,"- "]],[6133,6133],[6131,6131]]],[1563411632093,["GJX@GJXAIOU",[[-1,6299,"-[要求]"]],[6299,6304],[6299,6299]]],[1563411634450,["GJX@GJXAIOU",[[1,6299,"注意"]],[6299,6299],[6301,6301]]],[1563411644105,["GJX@GJXAIOU",[[1,6304,"=="],[1,6335,"=="]],[6304,6335],[6304,6339]]],[1563411897774,["GJX@GJXAIOU",[[-1,7012,"/*Itreator  迭代器\n\t\t * boolean hasNext();  //判断当前迭代器是否有下一个元素\n\t\t * Object next(); //获取当前迭代器指向的元素，并且获取之后，指向下一个元素；\n\t\t * void remove(); //删除当前迭代器通过next获取到的对象\n\t\t * [要求]: 在通过迭代器调用remove方法时候，之前必须调用过next方法，否则会报异常：java.lang.IllegalAtateException\n\t\t */"]],[7012,7252],[7012,7012]]],[1563412098182,["GJX@GJXAIOU",[[1,7547,"\n"]],[7545,7545],[7546,7546]]],[1563412099063,["GJX@GJXAIOU",[[1,7548,"\n"]],[7546,7546],[7547,7547]]],[1563412100921,["GJX@GJXAIOU",[[1,7547,"程勋"]],[7547,7547],[7549,7549]]],[1563412101534,["GJX@GJXAIOU",[[-1,7547,"程勋"]],[7549,7549],[7547,7547]]],[1563412105555,["GJX@GJXAIOU",[[1,7547,"程序运行结果："]],[7547,7547],[7554,7554]]],[1563412105998,["GJX@GJXAIOU",[[1,7556,"\n"]],[7554,7554],[7555,7555]]],[1563412108850,["GJX@GJXAIOU",[[1,7555,"```java"]],[7555,7555],[7562,7562]]],[1563412108928,["GJX@GJXAIOU",[[1,7564,"\n"]],[7562,7562],[7563,7563]]],[1563412110761,["GJX@GJXAIOU",[[1,7565,"\n"]],[7563,7563],[7564,7564]]],[1563412111344,["GJX@GJXAIOU",[[1,7564,"```"]],[7564,7564],[7567,7567]]],[1563412112760,["GJX@GJXAIOU",[[1,7563,"张三\n李四\n王五\n-------------------------------------\n当前元素有没有下一个元素：true\n当前迭代器指向的元素：张三\n当前迭代器指向的元素：李四\n调用了一下删除的方法\n[张三, 王五]\n---------------------------------------\n迭代器操作：王五"]],[7563,7563],[7724,7724]]],[1563412141245,["GJX@GJXAIOU",[[-1,6394,"package study;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class DieDaiQi {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}\n"]],[6394,7541],[6394,6394]]],[1563412350400,["GJX@GJXAIOU",[[1,7854,"张三\n迭代器操作：李四\n迭代器操作："]],[7848,7856],[7874,7874]]],[1563412353368,["GJX@GJXAIOU",[[1,7848,"\n"]],[7848,7848],[7849,7849]]],[1563412353534,["GJX@GJXAIOU",[[1,7849,"\n"]],[7849,7849],[7850,7850]]],[1563412357200,["GJX@GJXAIOU",[[1,7848,"///"]],[7848,7848],[7851,7851]]],[1563412358025,["GJX@GJXAIOU",[[-1,7850,"/"]],[7851,7851],[7850,7850]]],[1563412359314,["GJX@GJXAIOU",[[1,7850,"zhus"]],[7850,7850],[7854,7854]]],[1563412359949,["GJX@GJXAIOU",[[-1,7850,"zhus"]],[7854,7854],[7850,7850]]],[1563412375282,["GJX@GJXAIOU",[[1,7850,"注：这里因为上面迭代器以及"]],[7850,7850],[7863,7863]]],[1563412375929,["GJX@GJXAIOU",[[-1,7861,"以及"]],[7863,7863],[7861,7861]]],[1563412382963,["GJX@GJXAIOU",[[1,7861,"已经指向了李四，"]],[7861,7861],[7869,7869]]],[1563412444384,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，\n\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，\n\n"],[-1,7877,"张三\n迭代器操作：李四\n迭代器操作："]],[6394,6394],[7877,7877]]],[1563412444384,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，\n\n迭代器操作：张三\n迭代器操作：李四\n"],[1,9168,"//注：这里因为上面迭代器已经指向了李四，\n\n"],[1,9174,"张三\n迭代器操作：李四\n迭代器操作："]],[7877,7877],[6394,6394]]],[1563412386083,["GJX@GJXAIOU",[[1,7869,"因此结果为"]],[7869,7869],[7874,7874]]],[1563412387110,["GJX@GJXAIOU",[[1,7876,"\n"]],[7874,7874],[7875,7875]]],[1563412391697,["GJX@GJXAIOU",[[1,7875,"迭代器操作："]],[7875,7875],[7881,7881]]],[1563412392616,["GJX@GJXAIOU",[[-1,7880,"："]],[7881,7881],[7880,7880]]],[1563412396036,["GJX@GJXAIOU",[[1,7880,"：王五"]],[7880,7880],[7883,7883]]],[1563412397181,["GJX@GJXAIOU",[[1,7885,"\n"]],[7883,7883],[7884,7884]]],[1563412399896,["GJX@GJXAIOU",[[1,7886,"\n"]],[7884,7884],[7885,7885]]],[1563412421034,["GJX@GJXAIOU",[[1,7885,"//如果将上面的语句都注释掉的话，结果应该为："]],[7885,7885],[7908,7908]]],[1563412423273,["GJX@GJXAIOU",[[-1,7909,"\n"]],[7909,7909],[7908,7908]]],[1563412864390,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[-1,7915,"张三\n迭代器操作：李四\n迭代器操作："]],[6394,6394],[7915,7915]]],[1563412864390,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[1,9206,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[1,9212,"张三\n迭代器操作：李四\n迭代器操作："]],[7915,7915],[6394,6394]]],[1563412834750,["GJX@GJXAIOU",[[-1,8511,"，"]],[8512,8512],[8511,8511]]],[1563412838222,["GJX@GJXAIOU",[[1,8511,"：\n\t\t "]],[8511,8511],[8516,8516]]],[1563412845997,["GJX@GJXAIOU",[[1,8591,"\n\t\t "]],[8591,8591],[8595,8595]]],[1563412924392,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7153,"，"],[1,7154,"：\n\t\t "],[1,7229,"\n\t\t "],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[-1,7915,"张三\n迭代器操作：李四\n迭代器操作："],[-1,8511,"：\n\t\t "],[1,8516,"e"],[-1,8591,"\n\t\t "],[1,8595,""]],[6394,6394],[8595,8595]]],[1563412924392,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[1,8511,"，"],[-1,8511,"：\n\t\t "],[-1,8591,"\n\t\t "],[1,9214,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[1,9220,"张三\n迭代器操作：李四\n迭代器操作："],[1,9798,"：\n\t\t "],[-1,9798,"e"],[1,9874,"\n\t\t "],[-1,9874,""]],[8595,8595],[6394,6394]]],[1563412924342,["GJX@GJXAIOU",[[-1,8603,"或"]],[8604,8604],[8603,8603]]],[1563412984388,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7153,"，"],[1,7154,"：\n\t\t "],[1,7229,"\n\t\t "],[-1,7237,"或"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[-1,7915,"张三\n迭代器操作：李四\n迭代器操作："],[-1,8511,"：\n\t\t "],[1,8516,"e"],[-1,8591,"\n\t\t "],[1,8603,"t"]],[6394,6394],[8604,8604]]],[1563412984388,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[1,8511,"，"],[-1,8511,"：\n\t\t "],[-1,8591,"\n\t\t "],[1,8603,"或"],[1,9213,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[1,9219,"张三\n迭代器操作：李四\n迭代器操作："],[1,9797,"：\n\t\t "],[-1,9797,"e"],[1,9873,"\n\t\t "],[-1,9881,"t"]],[8604,8604],[6394,6394]]],[1563412925786,["GJX@GJXAIOU",[[1,8603,"会"]],[8603,8603],[8604,8604]]],[1563412950454,["GJX@GJXAIOU",[[-1,8810,"\n"]],[8809,8809],[8808,8808]]],[1563412950598,["GJX@GJXAIOU",[[-1,8809,"\n"]],[8808,8808],[8807,8807]]],[1563412950750,["GJX@GJXAIOU",[[-1,8808,"\n"]],[8807,8807],[8806,8806]]],[1563412953763,["GJX@GJXAIOU",[[1,8806,"---"]],[8806,8806],[8809,8809]]],[1563412958479,["GJX@GJXAIOU",[[1,7941,"\n"]],[7940,7940],[7941,7941]]],[1563412958607,["GJX@GJXAIOU",[[1,7942,"\n"]],[7941,7941],[7942,7942]]],[1563412959339,["GJX@GJXAIOU",[[1,7942,"---"]],[7942,7942],[7945,7945]]],[1563412960719,["GJX@GJXAIOU",[[1,7946,"\n"]],[7945,7945],[7946,7946]]],[1563412962750,["GJX@GJXAIOU",[[-1,7941,"\n"]],[7941,7941],[7940,7940]]],[1563413044397,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[1,6583,"---\n\n"],[-1,7153,"，"],[1,7154,"：\n\t\t "],[1,7229,"\n\t\t "],[-1,7237,"或"],[1,7238,"会"],[-1,7440,"\n\n\n"],[1,7443,"---"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[-1,7915,"张三\n迭代器操作：李四\n迭代器操作："],[-1,7941,"---\n\n"],[-1,8516,"：\n\t\t "],[1,8521,"e"],[-1,8596,"\n\t\t "],[-1,8608,"会"],[1,8609,"t"],[-1,8811,"---"],[1,8816,"六\")"]],[6394,6394],[8819,8819]]],[1563413044397,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7941,"---\n\n"],[1,8516,"，"],[-1,8516,"：\n\t\t "],[-1,8596,"\n\t\t "],[1,8608,"或"],[-1,8608,"会"],[1,8811,"\n\n\n"],[-1,8811,"---"],[1,9219,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[1,9225,"张三\n迭代器操作：李四\n迭代器操作："],[1,9233,"---\n\n"],[1,9803,"：\n\t\t "],[-1,9803,"e"],[1,9879,"\n\t\t "],[1,9887,"会"],[-1,9887,"t"],[1,10090,"---"],[-1,10092,"六\")"]],[8819,8819],[6394,6394]]],[1563412997120,["GJX@GJXAIOU",[[1,8895,"tin"]],[8893,8893],[8896,8896]]],[1563412997686,["GJX@GJXAIOU",[[1,8896," "]],[8896,8896],[8897,8897]]],[1563413224391,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[1,6583,"---\n\n"],[-1,7153,"，"],[1,7154,"：\n\t\t "],[1,7229,"\n\t\t "],[-1,7237,"或"],[1,7238,"会"],[-1,7440,"\n\n\n"],[1,7443,"---"],[-1,7524,""],[1,7524,"t in"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[-1,7915,"张三\n迭代器操作：李四\n迭代器操作："],[-1,7941,"---\n\n"],[-1,8516,"：\n\t\t "],[1,8521,"e"],[-1,8596,"\n\t\t "],[-1,8608,"会"],[1,8609,"t"],[-1,8811,"---"],[1,8816,"六\")"],[-1,8895,"t in"],[1,8899,""]],[6394,6394],[8899,8899]]],[1563413224391,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7941,"---\n\n"],[1,8516,"，"],[-1,8516,"：\n\t\t "],[-1,8596,"\n\t\t "],[1,8608,"或"],[-1,8608,"会"],[1,8811,"\n\n\n"],[-1,8811,"---"],[1,8895,""],[-1,8895,"t in"],[1,9223,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[1,9229,"张三\n迭代器操作：李四\n迭代器操作："],[1,9237,"---\n\n"],[1,9807,"：\n\t\t "],[-1,9807,"e"],[1,9883,"\n\t\t "],[1,9891,"会"],[-1,9891,"t"],[1,10094,"---"],[-1,10096,"六\")"],[1,10178,"t in"],[-1,10178,""]],[8899,8899],[6394,6394]]],[1563413215905,["GJX@GJXAIOU",[[1,8996," ---   "]],[8996,8996],[9003,9003]]],[1563413218085,["GJX@GJXAIOU",[[-1,8997,"---   "]],[9003,9003],[8997,8997]]],[1563413218808,["GJX@GJXAIOU",[[1,8997,"  "]],[8997,8997],[8999,8999]]],[1563413221833,["GJX@GJXAIOU",[[1,9033,"    "]],[9032,9032],[9036,9036]]],[1563413222937,["GJX@GJXAIOU",[[1,9078,"   "]],[9077,9077],[9080,9080]]],[1563413224184,["GJX@GJXAIOU",[[1,9135,"   "]],[9135,9135],[9138,9138]]],[1563413344398,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[1,6583,"---\n\n"],[-1,7153,"，"],[1,7154,"：\n\t\t "],[1,7229,"\n\t\t "],[-1,7237,"或"],[1,7238,"会"],[-1,7440,"\n\n\n"],[1,7443,"---"],[-1,7524,""],[1,7524,"t in"],[1,7621,"   "],[1,7654,"    "],[1,7696,"   "],[1,7749,"   "],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[-1,7915,"张三\n迭代器操作：李四\n迭代器操作："],[-1,7941,"---\n\n"],[-1,8516,"：\n\t\t "],[1,8521,"e"],[-1,8596,"\n\t\t "],[-1,8608,"会"],[1,8609,"t"],[-1,8811,"---"],[1,8816,"六\")"],[-1,8895,"t in"],[1,8899,""],[-1,8996,"   "],[-1,9033,"    "],[-1,9078,"   "],[1,9081,""],[-1,9135,"   "],[1,9138,""]],[6394,6394],[9138,9138]]],[1563413344398,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7941,"---\n\n"],[1,8516,"，"],[-1,8516,"：\n\t\t "],[-1,8596,"\n\t\t "],[1,8608,"或"],[-1,8608,"会"],[1,8811,"\n\n\n"],[-1,8811,"---"],[1,8895,""],[-1,8895,"t in"],[-1,8996,"   "],[-1,9032,"    "],[-1,9078,"   "],[-1,9134,"   "],[1,9236,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[1,9242,"张三\n迭代器操作：李四\n迭代器操作："],[1,9250,"---\n\n"],[1,9820,"：\n\t\t "],[-1,9820,"e"],[1,9896,"\n\t\t "],[1,9904,"会"],[-1,9904,"t"],[1,10107,"---"],[-1,10109,"六\")"],[1,10191,"t in"],[-1,10191,""],[1,10288,"   "],[1,10322,"    "],[1,10363,"   "],[-1,10363,""],[1,10417,"   "],[-1,10417,""]],[9138,9138],[6394,6394]]],[1563413301977,["GJX@GJXAIOU",[[1,9438,"\n\t\t"]],[9438,9438],[9441,9441]]],[1563413321363,["GJX@GJXAIOU",[[1,9264,"方法的使用示例程序："]],[9264,9264],[9274,9274]]],[1563413324354,["GJX@GJXAIOU",[[1,9264,"\n"]],[9264,9264],[9265,9265]]],[1563413644400,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[1,6583,"---\n\n"],[-1,7153,"，"],[1,7154,"：\n\t\t "],[1,7229,"\n\t\t "],[-1,7237,"或"],[1,7238,"会"],[-1,7440,"\n\n\n"],[1,7443,"---"],[-1,7524,""],[1,7524,"t in"],[1,7621,"   "],[1,7654,"    "],[1,7696,"   "],[1,7749,"   "],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[-1,7915,"张三\n迭代器操作：李四\n迭代器操作："],[-1,7941,"---\n\n"],[1,7960,"\n方法的使用示例程序："],[-1,8134,""],[1,8134,"\n\t\t"],[-1,8516,"：\n\t\t "],[1,8521,"e"],[-1,8596,"\n\t\t "],[-1,8608,"会"],[1,8609,"t"],[-1,8811,"---"],[1,8816,"六\")"],[-1,8895,"t in"],[1,8899,""],[-1,8996,"   "],[-1,9033,"    "],[-1,9078,"   "],[1,9081,""],[-1,9135,"   "],[1,9138,""],[-1,9265,"方法的使用示例程序：\n"],[-1,9449,"\n\t\t"],[1,9452,""]],[6394,6394],[9452,9452]]],[1563413644400,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7941,"---\n\n"],[1,8516,"，"],[-1,8516,"：\n\t\t "],[-1,8596,"\n\t\t "],[1,8608,"或"],[-1,8608,"会"],[1,8811,"\n\n\n"],[-1,8811,"---"],[1,8895,""],[-1,8895,"t in"],[-1,8996,"   "],[-1,9032,"    "],[-1,9078,"   "],[-1,9134,"   "],[1,9236,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[1,9242,"张三\n迭代器操作：李四\n迭代器操作："],[1,9250,"---\n\n"],[-1,9264,"\n方法的使用示例程序："],[1,9449,""],[-1,9449,"\n\t\t"],[1,9834,"：\n\t\t "],[-1,9834,"e"],[1,9910,"\n\t\t "],[1,9918,"会"],[-1,9918,"t"],[1,10121,"---"],[-1,10123,"六\")"],[1,10205,"t in"],[-1,10205,""],[1,10302,"   "],[1,10336,"    "],[1,10377,"   "],[-1,10377,""],[1,10431,"   "],[-1,10431,""],[1,10558,"方法的使用示例程序：\n"],[1,10731,"\n\t\t"],[-1,10731,""]],[9452,9452],[6394,6394]]],[1563413601784,["GJX@GJXAIOU",[[-1,9365,"ListUse"],[1,9372,"Demo2"],[1,9563,"System.out.println(\"------------------------\");\n\t\t"],[1,9627,"\t\t"],[1,9630,"System.out.println(\"------------------------\");"],[1,9777,"System.out.println(\"------------------------\");\n\t\t"],[1,9823,"\n\t\tSystem.out.println(\"------------------------\");"],[1,9941,"\t\tSystem.out.println(\"------------------------\");\n"],[-1,10155,"\n"],[-1,10158,"\n"]],[9300,10166],[10411,10411]]],[1563413608242,["GJX@GJXAIOU",[[1,10417,"\n"]],[10415,10415],[10416,10416]]],[1563413615170,["GJX@GJXAIOU",[[1,10416,"程序运行结果："]],[10416,10416],[10423,10423]]],[1563413615601,["GJX@GJXAIOU",[[1,10425,"\n"]],[10423,10423],[10424,10424]]],[1563413618423,["GJX@GJXAIOU",[[1,10424,"```java"]],[10424,10424],[10431,10431]]],[1563413618608,["GJX@GJXAIOU",[[1,10433,"\n"]],[10431,10431],[10432,10432]]],[1563413618903,["GJX@GJXAIOU",[[1,10434,"\n"]],[10432,10432],[10433,10433]]],[1563413620114,["GJX@GJXAIOU",[[1,10433,"```"]],[10433,10433],[10436,10436]]],[1563413635919,["GJX@GJXAIOU",[[1,10432,"[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]"]],[10432,10432],[10673,10673]]],[1563413884415,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[1,6583,"---\n\n"],[-1,7153,"，"],[1,7154,"：\n\t\t "],[1,7229,"\n\t\t "],[-1,7237,"或"],[1,7238,"会"],[-1,7440,"\n\n\n"],[1,7443,"---"],[-1,7524,""],[1,7524,"t in"],[1,7621,"   "],[1,7654,"    "],[1,7696,"   "],[1,7749,"   "],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[-1,7915,"张三\n迭代器操作：李四\n迭代器操作："],[-1,7941,"---\n\n"],[1,7960,"\n方法的使用示例程序："],[-1,8050,"ListUse"],[1,8057,"Demo2"],[-1,8134,""],[1,8134,"\n\t\t"],[1,8245,"System.out.println(\"------------------------\");\n\t\t"],[1,8309,"\t\t"],[1,8312,"System.out.println(\"------------------------\");"],[1,8459,"System.out.println(\"------------------------\");\n\t\t"],[1,8508,"System.out.println(\"------------------------\");\n\t\t"],[-1,8516,"：\n\t\t "],[1,8521,"e"],[-1,8596,"\n\t\t "],[-1,8608,"会"],[1,8609,"t"],[1,8633,"System.out.println(\"------------------------\");\n\t\t"],[-1,8811,"---"],[1,8816,"六\")"],[-1,8845,"\n"],[-1,8848,"\n"],[1,8861,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[-1,8895,"t in"],[-1,8996,"   "],[-1,9033,"    "],[-1,9078,"   "],[1,9081,""],[-1,9135,"   "],[1,9138,""],[-1,9265,"方法的使用示例程序：\n"],[-1,9365,"Demo2"],[1,9370," = new "],[-1,9447,"\n\t\t"],[1,9450,""],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\t"],[-1,9680,"System.out.println(\"------------------------\");"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[-1,9970,"\n\t\tSystem.out.println(\"------------------------\");"],[-1,10138,"\t\tSystem.out.println(\"------------------------\");\n"],[1,10188,""],[1,10402,"使"],[1,10404,"o"],[-1,10416,"程序运行结果："],[-1,10424,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"]],[6394,6394],[10424,10424]]],[1563413884415,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7941,"---\n\n"],[1,8516,"，"],[-1,8516,"：\n\t\t "],[-1,8596,"\n\t\t "],[1,8608,"或"],[-1,8608,"会"],[1,8811,"\n\n\n"],[-1,8811,"---"],[1,8895,""],[-1,8895,"t in"],[-1,8996,"   "],[-1,9032,"    "],[-1,9078,"   "],[-1,9134,"   "],[1,9236,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[1,9242,"张三\n迭代器操作：李四\n迭代器操作："],[1,9250,"---\n\n"],[-1,9264,"\n方法的使用示例程序："],[1,9365,"ListUse"],[-1,9365,"Demo2"],[1,9447,""],[-1,9447,"\n\t\t"],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\t"],[-1,9680,"System.out.println(\"------------------------\");"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[-1,9973,"System.out.println(\"------------------------\");\n\t\t"],[1,10031,"：\n\t\t "],[-1,10031,"e"],[1,10107,"\n\t\t "],[1,10115,"会"],[-1,10115,"t"],[-1,10140,"System.out.println(\"------------------------\");\n\t\t"],[1,10368,"---"],[-1,10370,"六\")"],[1,10402,"\n"],[1,10404,"\n"],[-1,10416,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[1,10712,"t in"],[1,10809,"   "],[1,10843,"    "],[1,10884,"   "],[-1,10884,""],[1,10938,"   "],[-1,10938,""],[1,11065,"方法的使用示例程序：\n"],[1,11154,"Demo2"],[-1,11154," = new "],[1,11238,"\n\t\t"],[-1,11238,""],[1,11349,"System.out.println(\"------------------------\");\n\t\t"],[1,11413,"\t\t"],[1,11416,"System.out.println(\"------------------------\");"],[1,11563,"System.out.println(\"------------------------\");\n\t\t"],[1,11609,"\n\t\tSystem.out.println(\"------------------------\");"],[1,11727,"\t\tSystem.out.println(\"------------------------\");\n"],[-1,11727,""],[-1,11941,"使"],[-1,11944,"o"],[1,11957,"程序运行结果："],[1,11958,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"]],[10424,10424],[6394,6394]]],[1563413856191,["GJX@GJXAIOU",[[1,11589,"\n"]],[11587,11587],[11588,11588]]],[1563413858568,["GJX@GJXAIOU",[[1,11588,"chegnxu"]],[11588,11588],[11595,11595]]],[1563413861183,["GJX@GJXAIOU",[[-1,11588,"chegnxu"]],[11595,11595],[11588,11588]]],[1563413866365,["GJX@GJXAIOU",[[1,11588,"程序运行结果："]],[11588,11588],[11595,11595]]],[1563413866633,["GJX@GJXAIOU",[[1,11597,"\n"]],[11595,11595],[11596,11596]]],[1563413869429,["GJX@GJXAIOU",[[1,11596,"```java"]],[11596,11596],[11603,11603]]],[1563413869561,["GJX@GJXAIOU",[[1,11605,"\n"]],[11603,11603],[11604,11604]]],[1563413869690,["GJX@GJXAIOU",[[1,11606,"\n"]],[11604,11604],[11605,11605]]],[1563413869837,["GJX@GJXAIOU",[[1,11607,"\n"]],[11605,11605],[11606,11606]]],[1563413870802,["GJX@GJXAIOU",[[1,11606,"```"]],[11606,11606],[11609,11609]]],[1563413872919,["GJX@GJXAIOU",[[-1,11605,"\n"]],[11605,11605],[11604,11604]]],[1563413873751,["GJX@GJXAIOU",[[1,11604,"下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n"]],[11604,11604],[11660,11660]]],[1563413876929,["GJX@GJXAIOU",[[-1,11660,"\n"]],[11660,11660],[11659,11659]]],[1563414424423,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[1,6583,"---\n\n"],[-1,7153,"，"],[1,7154,"：\n\t\t "],[1,7229,"\n\t\t "],[-1,7237,"或"],[1,7238,"会"],[-1,7440,"\n\n\n"],[1,7443,"---"],[-1,7524,""],[1,7524,"t in"],[1,7621,"   "],[1,7654,"    "],[1,7696,"   "],[1,7749,"   "],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[-1,7915,"张三\n迭代器操作：李四\n迭代器操作："],[-1,7941,"---\n\n"],[1,7960,"\n方法的使用示例程序："],[-1,8050,"ListUse"],[1,8057,"Demo2"],[-1,8134,""],[1,8134,"\n\t\t"],[1,8245,"System.out.println(\"------------------------\");\n\t\t"],[1,8309,"\t\t"],[1,8312,"System.out.println(\"------------------------\");"],[1,8459,"System.out.println(\"------------------------\");\n\t\t"],[1,8508,"System.out.println(\"------------------------\");\n\t\t"],[-1,8516,"：\n\t\t "],[1,8521,"e"],[-1,8596,"\n\t\t "],[-1,8608,"会"],[1,8609,"t"],[1,8633,"System.out.println(\"------------------------\");\n\t\t"],[-1,8811,"---"],[1,8816,"六\")"],[-1,8845,"\n"],[-1,8848,"\n"],[1,8861,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[-1,8895,"t in"],[-1,8996,"   "],[-1,9033,"    "],[-1,9078,"   "],[1,9081,""],[-1,9135,"   "],[1,9138,""],[-1,9265,"方法的使用示例程序：\n"],[-1,9365,"Demo2"],[1,9370," = new "],[-1,9447,"\n\t\t"],[1,9450,""],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9661,"System.out.pri\t\tntl"],[-1,9700,"------------------------\");n(\""],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[1,9949,"程序运行结果：\n```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n"],[-1,9970,"\n\t\tSystem.out.println(\"------------------------\");"],[-1,10138,"\t\tSystem.out.println(\"------------------------\");\n"],[1,10188,""],[1,10402,"使"],[1,10404,"o"],[-1,10416,"程序运行结果："],[-1,10424,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"],[-1,11588,"程序运行结果："],[-1,11596,"```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n\n"]],[6394,6394],[11596,11596]]],[1563414424423,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7941,"---\n\n"],[1,8516,"，"],[-1,8516,"：\n\t\t "],[-1,8596,"\n\t\t "],[1,8608,"或"],[-1,8608,"会"],[1,8811,"\n\n\n"],[-1,8811,"---"],[1,8895,""],[-1,8895,"t in"],[-1,8996,"   "],[-1,9032,"    "],[-1,9078,"   "],[-1,9134,"   "],[1,9236,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[1,9242,"张三\n迭代器操作：李四\n迭代器操作："],[1,9250,"---\n\n"],[-1,9264,"\n方法的使用示例程序："],[1,9365,"ListUse"],[-1,9365,"Demo2"],[1,9447,""],[-1,9447,"\n\t\t"],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\t"],[-1,9680,"System.out.println(\"------------------------\");"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[-1,9973,"System.out.println(\"------------------------\");\n\t\t"],[1,10031,"：\n\t\t "],[-1,10031,"e"],[1,10107,"\n\t\t "],[1,10115,"会"],[-1,10115,"t"],[-1,10140,"System.out.println(\"------------------------\");\n\t\t"],[1,10368,"---"],[-1,10370,"六\")"],[1,10402,"\n"],[1,10404,"\n"],[-1,10416,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[1,10712,"t in"],[1,10809,"   "],[1,10843,"    "],[1,10884,"   "],[-1,10884,""],[1,10938,"   "],[-1,10938,""],[1,11065,"方法的使用示例程序：\n"],[1,11154,"Demo2"],[-1,11154," = new "],[1,11238,"\n\t\t"],[-1,11238,""],[1,11349,"System.out.println(\"------------------------\");\n\t\t"],[1,11399,"System.out.pri\t\tntl"],[1,11419,"------------------------\");n(\""],[1,11563,"System.out.println(\"------------------------\");\n\t\t"],[-1,11588,"程序运行结果：\n```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n"],[1,11685,"\n\t\tSystem.out.println(\"------------------------\");"],[1,11803,"\t\tSystem.out.println(\"------------------------\");\n"],[-1,11803,""],[-1,12017,"使"],[-1,12020,"o"],[1,12033,"程序运行结果："],[1,12034,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"],[1,12943,"程序运行结果："],[1,12944,"```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n\n"]],[11596,11596],[6394,6394]]],[1563414419252,["GJX@GJXAIOU",[[1,11452," //替换next获取到的元素"]],[11452,11452],[11467,11467]]],[1563414484423,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[1,6583,"---\n\n"],[-1,7153,"，"],[1,7154,"：\n\t\t "],[1,7229,"\n\t\t "],[-1,7237,"或"],[1,7238,"会"],[-1,7440,"\n\n\n"],[1,7443,"---"],[-1,7524,""],[1,7524,"t in"],[1,7621,"   "],[1,7654,"    "],[1,7696,"   "],[1,7749,"   "],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[-1,7915,"张三\n迭代器操作：李四\n迭代器操作："],[-1,7941,"---\n\n"],[1,7960,"\n方法的使用示例程序："],[-1,8050,"ListUse"],[1,8057,"Demo2"],[-1,8134,""],[1,8134,"\n\t\t"],[1,8245,"System.out.println(\"------------------------\");\n\t\t"],[1,8309,"\t\t"],[1,8312,"System.out.println(\"------------------------\");"],[1,8459,"System.out.println(\"------------------------\");\n\t\t"],[1,8508,"System.out.println(\"------------------------\");\n\t\t"],[-1,8516,"：\n\t\t "],[1,8521,"e"],[-1,8596,"\n\t\t "],[-1,8608,"会"],[1,8609,"t"],[1,8633,"System.out.println(\"------------------------\");\n\t\t"],[-1,8811,"---"],[1,8816,"六\")"],[-1,8845,"\n"],[-1,8848,"\n"],[1,8861,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[-1,8895,"t in"],[-1,8996,"   "],[-1,9033,"    "],[-1,9078,"   "],[1,9081,""],[-1,9135,"   "],[1,9138,""],[-1,9265,"方法的使用示例程序：\n"],[-1,9365,"Demo2"],[1,9370," = new "],[-1,9447,"\n\t\t"],[1,9450,""],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\tntlSystem.out.pri"],[-1,9700,"------------------------\");n(\""],[1,9763," //替换next获取到的元素"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[1,9949,"程序运行结果：\n```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n"],[-1,9970,"\n\t\tSystem.out.println(\"------------------------\");"],[-1,10138,"\t\tSystem.out.println(\"------------------------\");\n"],[1,10188,""],[1,10402,"使"],[1,10404,"o"],[-1,10416,"程序运行结果："],[-1,10424,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"],[-1,11452," //替换next获取到的元素"],[-1,11603,"程序运行结果："],[-1,11611,"```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n\n"]],[6394,6394],[11611,11611]]],[1563414484423,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7941,"---\n\n"],[1,8516,"，"],[-1,8516,"：\n\t\t "],[-1,8596,"\n\t\t "],[1,8608,"或"],[-1,8608,"会"],[1,8811,"\n\n\n"],[-1,8811,"---"],[1,8895,""],[-1,8895,"t in"],[-1,8996,"   "],[-1,9032,"    "],[-1,9078,"   "],[-1,9134,"   "],[1,9236,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[1,9242,"张三\n迭代器操作：李四\n迭代器操作："],[1,9250,"---\n\n"],[-1,9264,"\n方法的使用示例程序："],[1,9365,"ListUse"],[-1,9365,"Demo2"],[1,9447,""],[-1,9447,"\n\t\t"],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\t"],[-1,9680,"System.out.println(\"------------------------\");"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[-1,9973,"System.out.println(\"------------------------\");\n\t\t"],[1,10031,"：\n\t\t "],[-1,10031,"e"],[1,10107,"\n\t\t "],[1,10115,"会"],[-1,10115,"t"],[-1,10140,"System.out.println(\"------------------------\");\n\t\t"],[1,10368,"---"],[-1,10370,"六\")"],[1,10402,"\n"],[1,10404,"\n"],[-1,10416,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[1,10712,"t in"],[1,10809,"   "],[1,10843,"    "],[1,10884,"   "],[-1,10884,""],[1,10938,"   "],[-1,10938,""],[1,11065,"方法的使用示例程序：\n"],[1,11154,"Demo2"],[-1,11154," = new "],[1,11238,"\n\t\t"],[-1,11238,""],[1,11349,"System.out.println(\"------------------------\");\n\t\t"],[1,11413,"\t\tntlSystem.out.pri"],[1,11419,"------------------------\");n(\""],[-1,11452," //替换next获取到的元素"],[1,11578,"System.out.println(\"------------------------\");\n\t\t"],[-1,11603,"程序运行结果：\n```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n"],[1,11700,"\n\t\tSystem.out.println(\"------------------------\");"],[1,11818,"\t\tSystem.out.println(\"------------------------\");\n"],[-1,11818,""],[-1,12032,"使"],[-1,12035,"o"],[1,12048,"程序运行结果："],[1,12049,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"],[1,12822," //替换next获取到的元素"],[1,12958,"程序运行结果："],[1,12959,"```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n\n"]],[11611,11611],[6394,6394]]],[1563414437439,["GJX@GJXAIOU",[[1,11520," 、、"]],[11520,11520],[11523,11523]]],[1563414438399,["GJX@GJXAIOU",[[-1,11521,"、、"]],[11523,11523],[11521,11521]]],[1563414463255,["GJX@GJXAIOU",[[1,11521,"//在当前迭代器位置上增加元素"]],[11521,11521],[11536,11536]]],[1563415084436,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[1,6583,"---\n\n"],[-1,7153,"，"],[1,7154,"：\n\t\t "],[1,7229,"\n\t\t "],[-1,7237,"或"],[1,7238,"会"],[-1,7440,"\n\n\n"],[1,7443,"---"],[-1,7524,""],[1,7524,"t in"],[1,7621,"   "],[1,7654,"    "],[1,7696,"   "],[1,7749,"   "],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[-1,7915,"张三\n迭代器操作：李四\n迭代器操作："],[-1,7941,"---\n\n"],[1,7960,"\n方法的使用示例程序："],[-1,8050,"ListUse"],[1,8057,"Demo2"],[-1,8134,""],[1,8134,"\n\t\t"],[1,8245,"System.out.println(\"------------------------\");\n\t\t"],[1,8309,"\t\t"],[1,8312,"System.out.println(\"------------------------\");"],[1,8459,"System.out.println(\"------------------------\");\n\t\t"],[1,8508,"System.out.println(\"------------------------\");\n\t\t"],[-1,8516,"：\n\t\t "],[1,8521,"e"],[-1,8596,"\n\t\t "],[-1,8608,"会"],[1,8609,"t"],[1,8633,"System.out.println(\"------------------------\");\n\t\t"],[-1,8811,"---"],[1,8816,"六\")"],[-1,8845,"\n"],[-1,8848,"\n"],[1,8861,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[-1,8895,"t in"],[-1,8996,"   "],[-1,9033,"    "],[-1,9078,"   "],[1,9081,""],[-1,9135,"   "],[1,9138,""],[-1,9265,"方法的使用示例程序：\n"],[-1,9365,"Demo2"],[1,9370," = new "],[-1,9447,"\n\t\t"],[1,9450,""],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\tntlSystem.out.pri"],[-1,9700,"------------------------\");n(\""],[1,9763," //替换next获取到的元素"],[1,9816," //在当前迭代器位置上增加元素"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[1,9949,"程序运行结果：\n```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n"],[-1,9970,"\n\t\tSystem.out.println(\"------------------------\");"],[-1,10138,"\t\tSystem.out.println(\"------------------------\");\n"],[1,10188,""],[1,10402,"使"],[1,10404,"o"],[-1,10416,"程序运行结果："],[-1,10424,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"],[-1,11452," //替换next获取到的元素"],[-1,11520," //在当前迭代器位置上增加元素"],[-1,11619,"程序运行结果："],[-1,11627,"```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n\n"]],[6394,6394],[11627,11627]]],[1563415084436,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7941,"---\n\n"],[1,8516,"，"],[-1,8516,"：\n\t\t "],[-1,8596,"\n\t\t "],[1,8608,"或"],[-1,8608,"会"],[1,8811,"\n\n\n"],[-1,8811,"---"],[1,8895,""],[-1,8895,"t in"],[-1,8996,"   "],[-1,9032,"    "],[-1,9078,"   "],[-1,9134,"   "],[1,9236,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[1,9242,"张三\n迭代器操作：李四\n迭代器操作："],[1,9250,"---\n\n"],[-1,9264,"\n方法的使用示例程序："],[1,9365,"ListUse"],[-1,9365,"Demo2"],[1,9447,""],[-1,9447,"\n\t\t"],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\t"],[-1,9680,"System.out.println(\"------------------------\");"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[-1,9973,"System.out.println(\"------------------------\");\n\t\t"],[1,10031,"：\n\t\t "],[-1,10031,"e"],[1,10107,"\n\t\t "],[1,10115,"会"],[-1,10115,"t"],[-1,10140,"System.out.println(\"------------------------\");\n\t\t"],[1,10368,"---"],[-1,10370,"六\")"],[1,10402,"\n"],[1,10404,"\n"],[-1,10416,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[1,10712,"t in"],[1,10809,"   "],[1,10843,"    "],[1,10884,"   "],[-1,10884,""],[1,10938,"   "],[-1,10938,""],[1,11065,"方法的使用示例程序：\n"],[1,11154,"Demo2"],[-1,11154," = new "],[1,11238,"\n\t\t"],[-1,11238,""],[1,11349,"System.out.println(\"------------------------\");\n\t\t"],[1,11413,"\t\tntlSystem.out.pri"],[1,11419,"------------------------\");n(\""],[-1,11452," //替换next获取到的元素"],[-1,11520," //在当前迭代器位置上增加元素"],[1,11594,"System.out.println(\"------------------------\");\n\t\t"],[-1,11619,"程序运行结果：\n```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n"],[1,11716,"\n\t\tSystem.out.println(\"------------------------\");"],[1,11834,"\t\tSystem.out.println(\"------------------------\");\n"],[-1,11834,""],[-1,12048,"使"],[-1,12051,"o"],[1,12064,"程序运行结果："],[1,12065,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"],[1,12838," //替换next获取到的元素"],[1,12891," //在当前迭代器位置上增加元素"],[1,12974,"程序运行结果："],[1,12975,"```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n\n"]],[11627,11627],[6394,6394]]],[1563415074504,["GJX@GJXAIOU",[[1,12536,"\n"]],[12533,12533],[12534,12534]]],[1563415078965,["GJX@GJXAIOU",[[1,12534,"程序运行结果："]],[12534,12534],[12541,12541]]],[1563415079258,["GJX@GJXAIOU",[[1,12544,"\n"]],[12541,12541],[12542,12542]]],[1563415080870,["GJX@GJXAIOU",[[1,12542,"```"]],[12542,12542],[12545,12545]]],[1563415080921,["GJX@GJXAIOU",[[1,12545,"language\n```\n"]],[12545,12545],[12545,12553]]],[1563415081683,["GJX@GJXAIOU",[[-1,12545,"language"],[1,12553,"j"]],[12545,12553],[12546,12546]]],[1563415082151,["GJX@GJXAIOU",[[1,12546,"ava"]],[12546,12546],[12549,12549]]],[1563415082321,["GJX@GJXAIOU",[[1,12550,"\n"]],[12549,12549],[12550,12550]]],[1563415083383,["GJX@GJXAIOU",[[1,12550,"A\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE"]],[12550,12550],[12623,12623]]],[1563415324437,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[1,6583,"---\n\n"],[-1,7153,"，"],[1,7154,"：\n\t\t "],[1,7229,"\n\t\t "],[-1,7237,"或"],[1,7238,"会"],[-1,7440,"\n\n\n"],[1,7443,"---"],[-1,7524,""],[1,7524,"t in"],[1,7621,"   "],[1,7654,"    "],[1,7696,"   "],[1,7749,"   "],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[-1,7915,"张三\n迭代器操作：李四\n迭代器操作："],[-1,7941,"---\n\n"],[1,7960,"\n方法的使用示例程序："],[-1,8050,"ListUse"],[1,8057,"Demo2"],[-1,8134,""],[1,8134,"\n\t\t"],[1,8245,"System.out.println(\"------------------------\");\n\t\t"],[1,8309,"\t\t"],[1,8312,"System.out.println(\"------------------------\");"],[1,8459,"System.out.println(\"------------------------\");\n\t\t"],[1,8508,"System.out.println(\"------------------------\");\n\t\t"],[-1,8516,"：\n\t\t "],[1,8521,"e"],[-1,8596,"\n\t\t "],[-1,8608,"会"],[1,8609,"t"],[1,8633,"System.out.println(\"------------------------\");\n\t\t"],[-1,8811,"---"],[1,8816,"六\")"],[-1,8845,"\n"],[-1,8848,"\n"],[1,8861,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[-1,8895,"t in"],[-1,8996,"   "],[-1,9033,"    "],[-1,9078,"   "],[1,9081,""],[-1,9135,"   "],[1,9138,""],[-1,9265,"方法的使用示例程序：\n"],[-1,9365,"Demo2"],[1,9370," = new "],[-1,9447,"\n\t\t"],[1,9450,""],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\tntlSystem.out.pri"],[-1,9700,"------------------------\");n(\""],[1,9763," //替换next获取到的元素"],[1,9816," //在当前迭代器位置上增加元素"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[1,9949,"程序运行结果：\n```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n"],[-1,9970,"\n\t\tSystem.out.println(\"------------------------\");"],[-1,10138,"\t\tSystem.out.println(\"------------------------\");\n"],[1,10188,""],[1,10402,"使"],[1,10404,"o"],[-1,10416,"程序运行结果："],[-1,10424,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"],[1,11148,"程序运行结果：\n```java\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n```\n\n"],[-1,11452," //替换next获取到的元素"],[-1,11520," //在当前迭代器位置上增加元素"],[-1,11619,"程序运行结果："],[-1,11627,"```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n\n"],[-1,12505,"\n程序运行结果：\n```language\n```\njava\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE"]],[6394,6394],[12505,12505]]],[1563415324437,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7941,"---\n\n"],[1,8516,"，"],[-1,8516,"：\n\t\t "],[-1,8596,"\n\t\t "],[1,8608,"或"],[-1,8608,"会"],[1,8811,"\n\n\n"],[-1,8811,"---"],[1,8895,""],[-1,8895,"t in"],[-1,8996,"   "],[-1,9032,"    "],[-1,9078,"   "],[-1,9134,"   "],[1,9236,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[1,9242,"张三\n迭代器操作：李四\n迭代器操作："],[1,9250,"---\n\n"],[-1,9264,"\n方法的使用示例程序："],[1,9365,"ListUse"],[-1,9365,"Demo2"],[1,9447,""],[-1,9447,"\n\t\t"],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\t"],[-1,9680,"System.out.println(\"------------------------\");"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[-1,9973,"System.out.println(\"------------------------\");\n\t\t"],[1,10031,"：\n\t\t "],[-1,10031,"e"],[1,10107,"\n\t\t "],[1,10115,"会"],[-1,10115,"t"],[-1,10140,"System.out.println(\"------------------------\");\n\t\t"],[1,10368,"---"],[-1,10370,"六\")"],[1,10402,"\n"],[1,10404,"\n"],[-1,10416,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[1,10712,"t in"],[1,10809,"   "],[1,10843,"    "],[1,10884,"   "],[-1,10884,""],[1,10938,"   "],[-1,10938,""],[1,11065,"方法的使用示例程序：\n"],[1,11154,"Demo2"],[-1,11154," = new "],[1,11238,"\n\t\t"],[-1,11238,""],[1,11349,"System.out.println(\"------------------------\");\n\t\t"],[1,11413,"\t\tntlSystem.out.pri"],[1,11419,"------------------------\");n(\""],[-1,11452," //替换next获取到的元素"],[-1,11520," //在当前迭代器位置上增加元素"],[1,11594,"System.out.println(\"------------------------\");\n\t\t"],[-1,11619,"程序运行结果：\n```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n"],[1,11716,"\n\t\tSystem.out.println(\"------------------------\");"],[1,11834,"\t\tSystem.out.println(\"------------------------\");\n"],[-1,11834,""],[-1,12048,"使"],[-1,12051,"o"],[1,12064,"程序运行结果："],[1,12065,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"],[-1,12534,"程序运行结果：\n```java\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n```\n\n"],[1,12933," //替换next获取到的元素"],[1,12986," //在当前迭代器位置上增加元素"],[1,13069,"程序运行结果："],[1,13070,"```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n\n"],[1,13879,"\n程序运行结果：\n```language\n```\njava\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE"]],[12505,12505],[6394,6394]]],[1563415287592,["GJX@GJXAIOU",[[1,12653,"**"],[1,12684,"**"]],[12653,12684],[12653,12688]]],[1563415924446,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[1,6583,"---\n\n"],[-1,7153,"，"],[1,7154,"：\n\t\t "],[1,7229,"\n\t\t "],[-1,7237,"或"],[1,7238,"会"],[-1,7440,"\n\n\n"],[1,7443,"---"],[-1,7524,""],[1,7524,"t in"],[1,7621,"   "],[1,7654,"    "],[1,7696,"   "],[1,7749,"   "],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[-1,7915,"张三\n迭代器操作：李四\n迭代器操作："],[-1,7941,"---\n\n"],[1,7960,"\n方法的使用示例程序："],[-1,8050,"ListUse"],[1,8057,"Demo2"],[-1,8134,""],[1,8134,"\n\t\t"],[1,8245,"System.out.println(\"------------------------\");\n\t\t"],[1,8309,"\t\t"],[1,8312,"System.out.println(\"------------------------\");"],[1,8459,"System.out.println(\"------------------------\");\n\t\t"],[1,8508,"System.out.println(\"------------------------\");\n\t\t"],[-1,8516,"：\n\t\t "],[1,8521,"e"],[-1,8596,"\n\t\t "],[-1,8608,"会"],[1,8609,"t"],[1,8633,"System.out.println(\"------------------------\");\n\t\t"],[-1,8811,"---"],[1,8816,"六\")"],[-1,8845,"\n"],[-1,8848,"\n"],[1,8861,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[-1,8895,"t in"],[-1,8996,"   "],[-1,9033,"    "],[-1,9078,"   "],[1,9081,""],[-1,9135,"   "],[1,9138,""],[-1,9265,"方法的使用示例程序：\n"],[-1,9365,"Demo2"],[1,9370," = new "],[-1,9447,"\n\t\t"],[1,9450,""],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\tntlSystem.out.pri"],[-1,9700,"------------------------\");n(\""],[1,9763," //替换next获取到的元素"],[1,9816," //在当前迭代器位置上增加元素"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[1,9949,"程序运行结果：\n```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n"],[-1,9970,"\n\t\tSystem.out.println(\"------------------------\");"],[-1,10138,"\t\tSystem.out.println(\"------------------------\");\n"],[1,10188,""],[1,10402,"使"],[1,10404,"o"],[-1,10416,"程序运行结果："],[-1,10424,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"],[1,11148,"程序运行结果：\n```java\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n```\n\n"],[1,11172,"**"],[1,11203,"**"],[-1,11452," //替换next获取到的元素"],[-1,11520," //在当前迭代器位置上增加元素"],[-1,11619,"程序运行结果："],[-1,11627,"```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n\n"],[-1,12505,"\n程序运行结果：\n```language\n```\njava\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE****"]],[6394,6394],[12505,12505]]],[1563415924446,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7941,"---\n\n"],[1,8516,"，"],[-1,8516,"：\n\t\t "],[-1,8596,"\n\t\t "],[1,8608,"或"],[-1,8608,"会"],[1,8811,"\n\n\n"],[-1,8811,"---"],[1,8895,""],[-1,8895,"t in"],[-1,8996,"   "],[-1,9032,"    "],[-1,9078,"   "],[-1,9134,"   "],[1,9236,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[1,9242,"张三\n迭代器操作：李四\n迭代器操作："],[1,9250,"---\n\n"],[-1,9264,"\n方法的使用示例程序："],[1,9365,"ListUse"],[-1,9365,"Demo2"],[1,9447,""],[-1,9447,"\n\t\t"],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\t"],[-1,9680,"System.out.println(\"------------------------\");"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[-1,9973,"System.out.println(\"------------------------\");\n\t\t"],[1,10031,"：\n\t\t "],[-1,10031,"e"],[1,10107,"\n\t\t "],[1,10115,"会"],[-1,10115,"t"],[-1,10140,"System.out.println(\"------------------------\");\n\t\t"],[1,10368,"---"],[-1,10370,"六\")"],[1,10402,"\n"],[1,10404,"\n"],[-1,10416,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[1,10712,"t in"],[1,10809,"   "],[1,10843,"    "],[1,10884,"   "],[-1,10884,""],[1,10938,"   "],[-1,10938,""],[1,11065,"方法的使用示例程序：\n"],[1,11154,"Demo2"],[-1,11154," = new "],[1,11238,"\n\t\t"],[-1,11238,""],[1,11349,"System.out.println(\"------------------------\");\n\t\t"],[1,11413,"\t\tntlSystem.out.pri"],[1,11419,"------------------------\");n(\""],[-1,11452," //替换next获取到的元素"],[-1,11520," //在当前迭代器位置上增加元素"],[1,11594,"System.out.println(\"------------------------\");\n\t\t"],[-1,11619,"程序运行结果：\n```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n"],[1,11716,"\n\t\tSystem.out.println(\"------------------------\");"],[1,11834,"\t\tSystem.out.println(\"------------------------\");\n"],[-1,11834,""],[-1,12048,"使"],[-1,12051,"o"],[1,12064,"程序运行结果："],[1,12065,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"],[-1,12534,"程序运行结果：\n```java\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n```\n\n"],[-1,12653,"**"],[-1,12686,"**"],[1,12937," //替换next获取到的元素"],[1,12990," //在当前迭代器位置上增加元素"],[1,13073,"程序运行结果："],[1,13074,"```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n\n"],[1,13883,"\n程序运行结果：\n```language\n```\njava\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE****"]],[12505,12505],[6394,6394]]],[1563415897834,["GJX@GJXAIOU",[[-1,13170,"增删"]],[13172,13172],[13170,13170]]],[1563415898810,["GJX@GJXAIOU",[[1,13170,"z "]],[13170,13170],[13171,13171]]],[1563415899389,["GJX@GJXAIOU",[[1,13171,"engj"]],[13171,13171],[13175,13175]]],[1563415900849,["GJX@GJXAIOU",[[-1,13170,"zengj"]],[13175,13175],[13170,13170]]],[1563415902406,["GJX@GJXAIOU",[[1,13170,"增加"]],[13170,13170],[13172,13172]]],[1563415904247,["GJX@GJXAIOU",[[-1,13172," "]],[13173,13173],[13172,13172]]],[1563417124469,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[1,6583,"---\n\n"],[-1,7153,"，"],[1,7154,"：\n\t\t "],[1,7229,"\n\t\t "],[-1,7237,"或"],[1,7238,"会"],[-1,7440,"\n\n\n"],[1,7443,"---"],[-1,7524,""],[1,7524,"t in"],[1,7621,"   "],[1,7654,"    "],[1,7696,"   "],[1,7749,"   "],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[-1,7915,"张三\n迭代器操作：李四\n迭代器操作："],[-1,7941,"---\n\n"],[1,7960,"\n方法的使用示例程序："],[-1,8050,"ListUse"],[1,8057,"Demo2"],[-1,8134,""],[1,8134,"\n\t\t"],[1,8245,"System.out.println(\"------------------------\");\n\t\t"],[1,8309,"\t\t"],[1,8312,"System.out.println(\"------------------------\");"],[1,8459,"System.out.println(\"------------------------\");\n\t\t"],[1,8508,"System.out.println(\"------------------------\");\n\t\t"],[-1,8516,"：\n\t\t "],[1,8521,"e"],[-1,8596,"\n\t\t "],[-1,8608,"会"],[1,8609,"t"],[1,8633,"System.out.println(\"------------------------\");\n\t\t"],[-1,8811,"---"],[1,8816,"六\")"],[-1,8845,"\n"],[-1,8848,"\n"],[1,8861,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[-1,8895,"t in"],[-1,8996,"   "],[-1,9033,"    "],[-1,9078,"   "],[1,9081,""],[-1,9135,"   "],[1,9138,""],[-1,9265,"方法的使用示例程序：\n"],[-1,9365,"Demo2"],[1,9370," = new "],[-1,9447,"\n\t\t"],[1,9450,""],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\tntlSystem.out.pri"],[-1,9700,"------------------------\");n(\""],[1,9763," //替换next获取到的元素"],[1,9816," //在当前迭代器位置上增加元素"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[1,9949,"程序运行结果：\n```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n"],[-1,9970,"\n\t\tSystem.out.println(\"------------------------\");"],[-1,10138,"\t\tSystem.out.println(\"------------------------\");\n"],[1,10188,""],[1,10402,"使"],[1,10404,"o"],[-1,10416,"程序运行结果："],[-1,10424,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"],[1,11148,"程序运行结果：\n```java\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n```\n"],[1,11150,"\n"],[1,11172,"**"],[1,11203,"**"],[-1,11452," //替换next获取到的元素"],[-1,11520," //在当前迭代器位置上增加元素"],[-1,11619,"程序运行结果："],[-1,11627,"```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n\n"],[-1,11793,"删"],[1,11794,"加"],[-1,12505,"\n程序运行结果：\n```language\n```\njava\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE****z engj增加"]],[6394,6394],[12505,12505]]],[1563417124469,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7941,"---\n\n"],[1,8516,"，"],[-1,8516,"：\n\t\t "],[-1,8596,"\n\t\t "],[1,8608,"或"],[-1,8608,"会"],[1,8811,"\n\n\n"],[-1,8811,"---"],[1,8895,""],[-1,8895,"t in"],[-1,8996,"   "],[-1,9032,"    "],[-1,9078,"   "],[-1,9134,"   "],[1,9236,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[1,9242,"张三\n迭代器操作：李四\n迭代器操作："],[1,9250,"---\n\n"],[-1,9264,"\n方法的使用示例程序："],[1,9365,"ListUse"],[-1,9365,"Demo2"],[1,9447,""],[-1,9447,"\n\t\t"],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\t"],[-1,9680,"System.out.println(\"------------------------\");"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[-1,9973,"System.out.println(\"------------------------\");\n\t\t"],[1,10031,"：\n\t\t "],[-1,10031,"e"],[1,10107,"\n\t\t "],[1,10115,"会"],[-1,10115,"t"],[-1,10140,"System.out.println(\"------------------------\");\n\t\t"],[1,10368,"---"],[-1,10370,"六\")"],[1,10402,"\n"],[1,10404,"\n"],[-1,10416,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[1,10712,"t in"],[1,10809,"   "],[1,10843,"    "],[1,10884,"   "],[-1,10884,""],[1,10938,"   "],[-1,10938,""],[1,11065,"方法的使用示例程序：\n"],[1,11154,"Demo2"],[-1,11154," = new "],[1,11238,"\n\t\t"],[-1,11238,""],[1,11349,"System.out.println(\"------------------------\");\n\t\t"],[1,11413,"\t\tntlSystem.out.pri"],[1,11419,"------------------------\");n(\""],[-1,11452," //替换next获取到的元素"],[-1,11520," //在当前迭代器位置上增加元素"],[1,11594,"System.out.println(\"------------------------\");\n\t\t"],[-1,11619,"程序运行结果：\n```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n"],[1,11716,"\n\t\tSystem.out.println(\"------------------------\");"],[1,11834,"\t\tSystem.out.println(\"------------------------\");\n"],[-1,11834,""],[-1,12048,"使"],[-1,12051,"o"],[1,12064,"程序运行结果："],[1,12065,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"],[-1,12534,"程序运行结果：\n```java\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n```\n"],[-1,12630,"\n"],[-1,12653,"**"],[-1,12686,"**"],[1,12937," //替换next获取到的元素"],[1,12990," //在当前迭代器位置上增加元素"],[1,13073,"程序运行结果："],[1,13074,"```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n\n"],[1,13171,"删"],[-1,13171,"加"],[1,13883,"\n程序运行结果：\n```language\n```\njava\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE****z engj增加"]],[12505,12505],[6394,6394]]],[1563417101147,["GJX@GJXAIOU",[[1,12425,"\n\t\t"]],[12419,12419],[12422,12422]]],[1563417101868,["GJX@GJXAIOU",[[-1,12420,"\t\t"],[1,12422,"\n"]],[12422,12422],[12421,12421]]],[1563417102721,["GJX@GJXAIOU",[[1,12421,"//逆向  //hasPrevious 判断前一个元素有没有  while(lisIterator.hasPrevious()){ System.out.println(listIterator.previous()); } }"]],[12421,12421],[12535,12535]]],[1563417109147,["GJX@GJXAIOU",[[-1,12421,"//逆向"],[-1,12427,"//hasPrevious 判断前一个元素有没有  while(lisIterator.hasPrevious()){ System.out.println(listIterator.previous()); } }"]],[12421,12535],[12423,12423]]],[1563417115872,["GJX@GJXAIOU",[[1,12423,"      //逆向  //hasPrevious 判断前一个元素有没有  while(lisIterator.hasPrevious()){ System.out.println(listIterator.previous()); } }"]],[12423,12423],[12543,12543]]],[1563417119651,["GJX@GJXAIOU",[[1,12435,"\n        "]],[12435,12435],[12444,12444]]],[1563417123668,["GJX@GJXAIOU",[[1,12470,"    "]],[12470,12470],[12474,12474]]],[1563417184472,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[1,6583,"---\n\n"],[-1,7153,"，"],[1,7154,"：\n\t\t "],[1,7229,"\n\t\t "],[-1,7237,"或"],[1,7238,"会"],[-1,7440,"\n\n\n"],[1,7443,"---"],[-1,7524,""],[1,7524,"t in"],[1,7621,"   "],[1,7654,"    "],[1,7696,"   "],[1,7749,"   "],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[-1,7915,"张三\n迭代器操作：李四\n迭代器操作："],[-1,7941,"---\n\n"],[1,7960,"\n方法的使用示例程序："],[-1,8050,"ListUse"],[1,8057,"Demo2"],[-1,8134,""],[1,8134,"\n\t\t"],[1,8245,"System.out.println(\"------------------------\");\n\t\t"],[1,8309,"\t\t"],[1,8312,"System.out.println(\"------------------------\");"],[1,8459,"System.out.println(\"------------------------\");\n\t\t"],[1,8508,"System.out.println(\"------------------------\");\n\t\t"],[-1,8516,"：\n\t\t "],[1,8521,"e"],[-1,8596,"\n\t\t "],[-1,8608,"会"],[1,8609,"t"],[1,8633,"System.out.println(\"------------------------\");\n\t\t"],[-1,8811,"---"],[1,8816,"六\")"],[-1,8845,"\n"],[-1,8848,"\n"],[1,8861,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[-1,8895,"t in"],[-1,8996,"   "],[-1,9033,"    "],[-1,9078,"   "],[1,9081,""],[-1,9135,"   "],[1,9138,""],[-1,9265,"方法的使用示例程序：\n"],[-1,9365,"Demo2"],[1,9370," = new "],[-1,9447,"\n\t\t"],[1,9450,""],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\tntlSystem.out.pri"],[-1,9700,"------------------------\");n(\""],[1,9763," //替换next获取到的元素"],[1,9816," //在当前迭代器位置上增加元素"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[1,9949,"程序运行结果：\n```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n"],[-1,9970,"\n\t\tSystem.out.println(\"------------------------\");"],[-1,10138,"\t\tSystem.out.println(\"------------------------\");\n"],[1,10188,""],[1,10402,"使"],[1,10404,"o"],[-1,10416,"程序运行结果："],[-1,10424,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"],[1,11033,"\n\n        //逆向  \n        //hasPrevious 判断前一个元素有没有      while(lisIterator.hasPrevious()){ System.out.println(listIterator.previous()); } }"],[1,11148,"程序运行结果：\n```java\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n```\n"],[1,11150,"\n"],[1,11172,"**"],[1,11203,"**"],[-1,11452," //替换next获取到的元素"],[-1,11520," //在当前迭代器位置上增加元素"],[-1,11619,"程序运行结果："],[-1,11627,"```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n\n"],[-1,11793,"删"],[1,11794,"加"],[-1,12420,"\n        //逆向  \n        //hasPrevio"],[-1,12456,"s 判断前一个元素有没有      while(lisIte"],[-1,12487,"ator.hasPrevious()){ System.out.println(listIterator.previous()); } }"],[-1,12559,"\n\t\t"],[-1,12642,"\n程序运行结果：\n```language\n```\njava\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE****z engj增加"]],[6394,6394],[12642,12642]]],[1563417184472,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7941,"---\n\n"],[1,8516,"，"],[-1,8516,"：\n\t\t "],[-1,8596,"\n\t\t "],[1,8608,"或"],[-1,8608,"会"],[1,8811,"\n\n\n"],[-1,8811,"---"],[1,8895,""],[-1,8895,"t in"],[-1,8996,"   "],[-1,9032,"    "],[-1,9078,"   "],[-1,9134,"   "],[1,9236,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[1,9242,"张三\n迭代器操作：李四\n迭代器操作："],[1,9250,"---\n\n"],[-1,9264,"\n方法的使用示例程序："],[1,9365,"ListUse"],[-1,9365,"Demo2"],[1,9447,""],[-1,9447,"\n\t\t"],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\t"],[-1,9680,"System.out.println(\"------------------------\");"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[-1,9973,"System.out.println(\"------------------------\");\n\t\t"],[1,10031,"：\n\t\t "],[-1,10031,"e"],[1,10107,"\n\t\t "],[1,10115,"会"],[-1,10115,"t"],[-1,10140,"System.out.println(\"------------------------\");\n\t\t"],[1,10368,"---"],[-1,10370,"六\")"],[1,10402,"\n"],[1,10404,"\n"],[-1,10416,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[1,10712,"t in"],[1,10809,"   "],[1,10843,"    "],[1,10884,"   "],[-1,10884,""],[1,10938,"   "],[-1,10938,""],[1,11065,"方法的使用示例程序：\n"],[1,11154,"Demo2"],[-1,11154," = new "],[1,11238,"\n\t\t"],[-1,11238,""],[1,11349,"System.out.println(\"------------------------\");\n\t\t"],[1,11413,"\t\tntlSystem.out.pri"],[1,11419,"------------------------\");n(\""],[-1,11452," //替换next获取到的元素"],[-1,11520," //在当前迭代器位置上增加元素"],[1,11594,"System.out.println(\"------------------------\");\n\t\t"],[-1,11619,"程序运行结果：\n```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n"],[1,11716,"\n\t\tSystem.out.println(\"------------------------\");"],[1,11834,"\t\tSystem.out.println(\"------------------------\");\n"],[-1,11834,""],[-1,12048,"使"],[-1,12051,"o"],[1,12064,"程序运行结果："],[1,12065,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"],[-1,12419,"\n\n        //逆向  \n        //hasPrevious 判断前一个元素有没有      while(lisIterator.hasPrevious()){ System.out.println(listIterator.previous()); } }"],[-1,12671,"程序运行结果：\n```java\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n```\n"],[-1,12767,"\n"],[-1,12790,"**"],[-1,12823,"**"],[1,13074," //替换next获取到的元素"],[1,13127," //在当前迭代器位置上增加元素"],[1,13210,"程序运行结果："],[1,13211,"```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n\n"],[1,13308,"删"],[-1,13308,"加"],[1,13935,"\n        //逆向  \n        //hasPrevio"],[1,13936,"s 判断前一个元素有没有      while(lisIte"],[1,13937,"ator.hasPrevious()){ System.out.println(listIterator.previous()); } }"],[1,13940,"\n\t\t"],[1,14020,"\n程序运行结果：\n```language\n```\njava\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE****z engj增加"]],[12642,12642],[6394,6394]]],[1563417128410,["GJX@GJXAIOU",[[1,12553,"\n        "]],[12553,12553],[12562,12562]]],[1563417131441,["GJX@GJXAIOU",[[1,12564,"\n        "]],[12564,12564],[12573,12573]]],[1563417134776,["GJX@GJXAIOU",[[1,12508,"  "]],[12508,12508],[12510,12510]]],[1563417143463,["GJX@GJXAIOU",[[-1,12474,"while(lisIterator.hasPrevious()){   System.out.println(listIterator.previous());"]],[12474,12554],[12474,12474]]],[1563417145730,["GJX@GJXAIOU",[[1,12469,"\n        "]],[12469,12469],[12478,12478]]],[1563417148878,["GJX@GJXAIOU",[[1,12480,"while(lisIterator.hasPrevious()){   System.out.println(listIterator.previous());"]],[12480,12480],[12560,12560]]],[1563417157588,["GJX@GJXAIOU",[[-1,12516,"System.out.println(listIterator.previous());"]],[12516,12560],[12516,12516]]],[1563417159953,["GJX@GJXAIOU",[[1,12514,"\n          "]],[12514,12514],[12525,12525]]],[1563417162196,["GJX@GJXAIOU",[[1,12531,"    "]],[12525,12525],[12529,12529]]],[1563417164212,["GJX@GJXAIOU",[[1,12530,"System.out.println(listIterator.previous());"]],[12530,12530],[12574,12574]]],[1563417171312,["GJX@GJXAIOU",[[-1,12486,"lisI"]],[12489,12489],[12486,12486]]],[1563417172645,["GJX@GJXAIOU",[[1,12486,"i"]],[12486,12486],[12487,12487]]],[1563417177493,["GJX@GJXAIOU",[[-1,12546,"l"],[-1,12548,"stI"]],[12546,12551],[12547,12547]]],[1563417181491,["GJX@GJXAIOU",[[1,12581,"    "]],[12581,12581],[12585,12585]]],[1563417183556,["GJX@GJXAIOU",[[1,12596,"  "]],[12596,12596],[12598,12598]]],[1563417904483,[null,[[-1,6394,""],[1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[1,6569,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[1,6583,"---\n\n"],[-1,7153,"，"],[1,7154,"：\n\t\t "],[1,7229,"\n\t\t "],[-1,7237,"或"],[1,7238,"会"],[-1,7440,"\n\n\n"],[1,7443,"---"],[-1,7524,""],[1,7524,"t in"],[1,7621,"   "],[1,7654,"    "],[1,7696,"   "],[1,7749,"   "],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[-1,7915,"张三\n迭代器操作：李四\n迭代器操作："],[-1,7941,"---\n\n"],[1,7960,"\n方法的使用示例程序："],[-1,8050,"ListUse"],[1,8057,"Demo2"],[-1,8134,""],[1,8134,"\n\t\t"],[1,8245,"System.out.println(\"------------------------\");\n\t\t"],[1,8309,"\t\t"],[1,8312,"System.out.println(\"------------------------\");"],[1,8459,"System.out.println(\"------------------------\");\n\t\t"],[1,8508,"System.out.println(\"------------------------\");\n\t\t"],[-1,8516,"：\n\t\t "],[1,8521,"e"],[-1,8596,"\n\t\t "],[-1,8608,"会"],[1,8609,"t"],[1,8633,"System.out.println(\"------------------------\");\n\t\t"],[-1,8811,"---"],[1,8816,"六\")"],[-1,8845,"\n"],[-1,8848,"\n"],[1,8861,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[-1,8895,"t in"],[-1,8996,"   "],[-1,9033,"    "],[-1,9078,"   "],[1,9081,""],[-1,9135,"   "],[1,9138,""],[-1,9265,"方法的使用示例程序：\n"],[-1,9365,"Demo2"],[1,9370," = new "],[-1,9447,"\n\t\t"],[1,9450,""],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\tntlSystem.out.pri"],[-1,9700,"------------------------\");n(\""],[1,9763," //替换next获取到的元素"],[1,9816," //在当前迭代器位置上增加元素"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[1,9949,"程序运行结果：\n```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n"],[-1,9970,"\n\t\tSystem.out.println(\"------------------------\");"],[-1,10138,"\t\tSystem.out.println(\"------------------------\");\n"],[1,10188,""],[1,10402,"使"],[1,10404,"o"],[-1,10416,"程序运行结果："],[-1,10424,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"],[1,11034,"\n        //逆向  \n        //hasPrevious 判断前一个元素有没有 \n          while(iterator.hasPrevious()){ \n               System.out.println(iterator.previous());     \n            } \n          }\n"],[1,11148,"程序运行结果：\n```java\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n```\n\n"],[1,11172,"**"],[1,11203,"**"],[-1,11452," //替换next获取到的元素"],[-1,11520," //在当前迭代器位置上增加元素"],[-1,11619,"程序运行结果："],[-1,11627,"```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n\n"],[-1,11793,"删"],[1,11794,"加"],[-1,12420,"\n        //逆向  \n        //hasPrevio"],[-1,12456,"s 判断前一个元素有没有 \n          while(ite"],[-1,12490,"ator.hasPrevious()){ \n               System.out.println(iterator.previous());     \n            } \n          }"],[-1,12602,"\n\t\t"],[-1,12685,"\n程序运行结果：\n```language\n```\njava\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE****z engj增加"]],[6394,6394],[12685,12685]]],[1563417904483,[null,[[1,6394,""],[-1,6394,"package lianxi ;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * class detail:迭代器\n * @author GJXAIOU\n * @since  2019年6月28日\n */\npublic class Demo2 {\n\tpublic static void main(String[] args) {\n\t\tCollection collection = new ArrayList();\n\t\tcollection.add(\"张三\");\n\t\tcollection.add(\"李四\");\n\t\tcollection.add(\"王五\");\n\t\t\n\t\t//第一种遍历方式：将集合转化为数组，然后按照数组的方式进行遍历\n\t\t//缺点：需要拷贝一份完整的集合数据，如果集合的数据过多，会造成内存的极大浪费，甚至超过内存的最大值\n\t\tObject[] array = collection.toArray(); \n\t\t//toArray()是转换为Object类型的数组\n\t\t\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tSystem.out.println(array[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------------------------------\");\n\t\t\n\t\t//第二种方式：使用迭代器\n\t\t\n\t\t//上述方法使用示例\n\t\tIterator iterator = collection.iterator(); //返回当前集合的一个迭代器\n\t\tSystem.out.println(\"当前元素有没有下一个元素：\" + iterator.hasNext());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"当前迭代器指向的元素：\" + iterator.next());\n\t\tSystem.out.println(\"调用了一下删除的方法\");\n\t\titerator.remove(); //这里删除的是上一个指向的next元素；\n\t\tSystem.out.println(collection);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\t\n\t\t//使用迭代器，借助hasNext和next方法，完成对整个集合的遍历\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(\"迭代器操作：\" + iterator.next());\n\t\t\t//将整个集合清空\n\t\t\t//iterator.remove();\n\t\t}\n\t\t\n\t}\n}"],[-1,7848,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n迭代器操作：张三\n迭代器操作：李四\n"],[-1,7941,"---\n\n"],[1,8516,"，"],[-1,8516,"：\n\t\t "],[-1,8596,"\n\t\t "],[1,8608,"或"],[-1,8608,"会"],[1,8811,"\n\n\n"],[-1,8811,"---"],[1,8895,""],[-1,8895,"t in"],[-1,8996,"   "],[-1,9032,"    "],[-1,9078,"   "],[-1,9134,"   "],[1,9236,"//注：这里因为上面迭代器已经指向了李四，因此结果为\n迭代器操作：王五\n\n//如果将上面的语句都注释掉的话，结果应该为：\n"],[1,9242,"张三\n迭代器操作：李四\n迭代器操作："],[1,9250,"---\n\n"],[-1,9264,"\n方法的使用示例程序："],[1,9365,"ListUse"],[-1,9365,"Demo2"],[1,9447,""],[-1,9447,"\n\t\t"],[-1,9561,"System.out.println(\"------------------------\");\n\t\t"],[-1,9675,"\t\t"],[-1,9680,"System.out.println(\"------------------------\");"],[-1,9874,"System.out.println(\"------------------------\");\n\t\t"],[-1,9973,"System.out.println(\"------------------------\");\n\t\t"],[1,10031,"：\n\t\t "],[-1,10031,"e"],[1,10107,"\n\t\t "],[1,10115,"会"],[-1,10115,"t"],[-1,10140,"System.out.println(\"------------------------\");\n\t\t"],[1,10368,"---"],[-1,10370,"六\")"],[1,10402,"\n"],[1,10404,"\n"],[-1,10416,"程序运行结果：\n```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n"],[1,10712,"t in"],[1,10809,"   "],[1,10843,"    "],[1,10884,"   "],[-1,10884,""],[1,10938,"   "],[-1,10938,""],[1,11065,"方法的使用示例程序：\n"],[1,11154,"Demo2"],[-1,11154," = new "],[1,11238,"\n\t\t"],[-1,11238,""],[1,11349,"System.out.println(\"------------------------\");\n\t\t"],[1,11413,"\t\tntlSystem.out.pri"],[1,11419,"------------------------\");n(\""],[-1,11452," //替换next获取到的元素"],[-1,11520," //在当前迭代器位置上增加元素"],[1,11594,"System.out.println(\"------------------------\");\n\t\t"],[-1,11619,"程序运行结果：\n```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n"],[1,11716,"\n\t\tSystem.out.println(\"------------------------\");"],[1,11834,"\t\tSystem.out.println(\"------------------------\");\n"],[-1,11834,""],[-1,12048,"使"],[-1,12051,"o"],[1,12064,"程序运行结果："],[1,12065,"```java\n[张三, 李四, 王五]\n------------------------\n[张三, 赵六, 李四, 王五]\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n------------------------\n赵六\n------------------------\n0\n2\n------------------------\n[张三, 赵六, 陈七, 朱九, 陈七]\n[六六六, 赵六, 陈七, 朱九, 陈七, 李四, 王五]\n```\n\n"],[-1,12420,"\n        //逆向  \n        //hasPrevious 判断前一个元素有没有 \n          while(iterator.hasPrevious()){ \n               System.out.println(iterator.previous());     \n            } \n          }\n"],[-1,12714,"程序运行结果：\n```java\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n```\n\n"],[-1,12833,"**"],[-1,12866,"**"],[1,13117," //替换next获取到的元素"],[1,13170," //在当前迭代器位置上增加元素"],[1,13253,"程序运行结果："],[1,13254,"```java\n下一个元素true\nnext获取数据小米\nset方法进行替换\n添加内容：\n[mi, VO, 华为, 苹果]\n2\n```\n\n"],[1,13351,"删"],[-1,13351,"加"],[1,13978,"\n        //逆向  \n        //hasPrevio"],[1,13979,"s 判断前一个元素有没有 \n          while(ite"],[1,13980,"ator.hasPrevious()){ \n               System.out.println(iterator.previous());     \n            } \n          }"],[1,13983,"\n\t\t"],[1,14063,"\n程序运行结果：\n```language\n```\njava\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE\n*********************\nA\nB\nC\nD\nE****z engj增加"]],[12685,12685],[6394,6394]]],[1563417870840,["GJX@GJXAIOU",[[1,12598," "]],[12598,12598],[12599,12599]]]],null,"GJX@GJXAIOU"]]}