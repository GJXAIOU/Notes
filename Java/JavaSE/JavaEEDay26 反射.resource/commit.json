{"compress":true,"commitItems":[["79c36267-ceba-4acc-88be-fbdec16d6ccd",1564016653533,"## 反射\n    1. 获取Class对象的三种方式：\n        1> Class.forName(\"完整的类名字符串\");\n            完整类名字符串是指 包名.类名\n        2> 类名.class;\n        3> 指定类对象.getClass();\n        \n        最常用的是Class.forName(\"完整的类名字符串\");\n        后期大量使用\n    \n    2. Constructor, Method, Field \n        都是Java反射这个包里面的类 java.lang.reflect\n        Constructor 是构造方法类\n        Method 是成员方法类\n        Field 是成员变量类\n        \n    3. Constructor常用方法：\n        Constructor[] getConstructors(); 获取所有public修饰的构造方法\n        Constructor[] getDeclaredConstructors(); 获取当前类里面所有的构造方法，包含用private修饰的构造方法\n        Constructor getConstructor(Object... paramterTyeps);\n                    根据所需参数不同，获取指定的构造方法对象\n        Constructor getDeclaredConstructor(Object... paramterTyeps);\n                    根据所需参数不同，获取指定的构造方法对象，包括私有化的方法\n        Object newInstance(Object... initargs); \n                    给予确定的参数，通过反射调用构造方法，这里的参数列表是一个不定参数列表\n                    \n    4. Method常用方法\n        Method[] getMethods(); \n                获取当前类里面所有的public修饰的成员方法，这里或显示父类继承而来的public方法\n        Method[] getDeclaredMethods(); \n                获取当前类里面的所有方法，包括private修饰的方法，但是会过滤父类继承而来的方法\n        Method getMethod(String methodName, Object... args);\n                根据方法的名字和对应的参数列表，获取指定方法\n        Method getDeclaredMethod(String methodName, Object... args);\n                根据方法的名字和对应的参数列表，获取指定方法，可以获取private修饰的方法\n        invoke(Object obj, Object... args); \n                执行成员方法的函数，第一个参数是执行该方法的类对象，第二个参数是执行该方法需要的参数列表\n    \n    5. Field常用方法\n        Field[] getFields();\n                获取所有的用public修饰的成员变量\n        Field[] getDeclaredFields();\n                获取所用成员变量，包括用private 修饰的成员变量\n        Field getField(String fieldName);\n                根据成员变量的名字获取对应的成员变量\n        Field getDeclaredField(String fieldName);\n                根据成员变量的名字获取包括private修饰在内的成员变量\n        set(Object obj, Object value);\n                设置成员变量的数值，第一个参数是调用该成员变量的对象，第二个参数是赋予数值\n    \n    6. 暴力反射赋予权限的函数\n        setAccessible(boolean )\n        \n        ",[[1564016598031,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1564016612715,["GJX@GJXAIOU",[[1,0,"# JavaDay27 放射"]],[0,0],[14,14]]],[1564016614262,["GJX@GJXAIOU",[[-1,12,"放射"]],[14,14],[12,12]]],[1564016617729,["GJX@GJXAIOU",[[1,12,"反射"]],[12,12],[14,14]]],[1564022777089,["GJX@GJXAIOU",[[-1,1942,"   "]],[1937,1940],[1937,1937]]],[1564022792321,["GJX@GJXAIOU",[[1,1937,"## "]],[1937,1937],[1945,1945]]],[1564022793263,["GJX@GJXAIOU",[[1,1945,"\n\n"]],[1945,1945],[1946,1946]]],[1564022793681,["GJX@GJXAIOU",[[1,1947,"\n"]],[1946,1946],[1947,1947]]],[1564022794506,["GJX@GJXAIOU",[[-1,1947,"\n"],[1,1948,"1"]],[1947,1947],[1948,1948]]],[1564022801137,["GJX@GJXAIOU",[[1,1948,".首先新建一个Person"]],[1948,1948],[1961,1961]]],[1564022801162,["GJX@GJXAIOU",[[1,1955," "]],[1961,1961],[1962,1962]]],[1564022802573,["GJX@GJXAIOU",[[1,1962,"类"]],[1962,1962],[1963,1963]]],[1564022802599,["GJX@GJXAIOU",[[1,1962," "]],[1963,1963],[1964,1964]]],[1564022803088,["GJX@GJXAIOU",[[1,1964,"\n\n"]],[1964,1964],[1965,1965]]],[1564022804227,["GJX@GJXAIOU",[[-1,1965,"\n"],[1,1966,"`"]],[1965,1965],[1966,1966]]],[1564022804650,["GJX@GJXAIOU",[[1,1966,"``"]],[1966,1966],[1968,1968]]],[1564022804675,["GJX@GJXAIOU",[[1,1968,"language\n```\n"]],[1968,1968],[1968,1976]]],[1564022805312,["GJX@GJXAIOU",[[-1,1968,"language"],[1,1976,"j"]],[1968,1976],[1969,1969]]],[1564022805700,["GJX@GJXAIOU",[[1,1969,"ava"]],[1969,1969],[1972,1972]]],[1564022805776,["GJX@GJXAIOU",[[1,1973,"\n"]],[1972,1972],[1973,1973]]],[1564022807819,["GJX@GJXAIOU",[[1,1973,"package com.qfedu.a_reflect;\n\n//如何获取一个类对象\npublic class Person {\n\tprivate int id;\n\tprivate String name;\n\t\n\tpublic int test;\n\tpublic static int testStatic = 10;\n\t\n\tprivate Person() {}\n\t\n\tpublic Person(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\t\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic static void eat() {\n\t\tSystem.out.println(\"黄焖鸡米饭~~~\");\n\t}\n\t\n\tpublic void sleep(int num) {\n\t\tSystem.out.println(name + \"每天睡\" + num + \"个小时\");\n\t}\n\t\n\tpublic void game() {\n\t\tSystem.out.println(\"大吉大利，今晚吃鸡~~~\");\n\t}\n\t\n\tprivate void testPrivate() {\n\t\tSystem.out.println(\"这是一个Private修饰的私有化方法\");\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Person [id=\" + id + \", name=\" + name + \"]\";\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[1973,1973],[2846,2846]]],[1564022814144,["GJX@GJXAIOU",[[-1,2825,"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[2824,2846],[2824,2824]]],[1564022816591,["GJX@GJXAIOU",[[1,2829,"\n"]],[2828,2828],[2829,2829]]],[1564022816719,["GJX@GJXAIOU",[[1,2830,"\n"]],[2829,2829],[2830,2830]]],[1564022851260,["GJX@GJXAIOU",[[-1,2830,"\n"],[1,2831,"2"]],[2830,2830],[2831,2831]]],[1564022852360,["GJX@GJXAIOU",[[1,2831,".tongg"]],[2831,2831],[2837,2837]]],[1564022853126,["GJX@GJXAIOU",[[-1,2832,"tongg"]],[2837,2837],[2832,2832]]],[1564022860103,["GJX@GJXAIOU",[[1,2832,"通过反射获取类对象"]],[2832,2832],[2841,2841]]],[1564022860375,["GJX@GJXAIOU",[[1,2841,"\n\n"]],[2841,2841],[2842,2842]]],[1564022861409,["GJX@GJXAIOU",[[-1,2842,"\n"],[1,2843,"`"]],[2842,2842],[2843,2843]]],[1564022861767,["GJX@GJXAIOU",[[1,2843,"``"]],[2843,2843],[2845,2845]]],[1564022861793,["GJX@GJXAIOU",[[1,2845,"language\n```\n"]],[2845,2845],[2845,2853]]],[1564022862010,["GJX@GJXAIOU",[[-1,2845,"language"],[1,2853,"j"]],[2845,2853],[2846,2846]]],[1564022862905,["GJX@GJXAIOU",[[1,2846,"ava"]],[2846,2846],[2849,2849]]],[1564022863041,["GJX@GJXAIOU",[[1,2850,"\n"]],[2849,2849],[2850,2850]]],[1564022865822,["GJX@GJXAIOU",[[1,2850,"package com.qfedu.a_reflect;\n\n/*\n  反射：\n \t当一个Java文件编译之后，编译成一个.class文件，也就是字节码问题，当这个字节码文件【加载】到\n \t内存的方法区/代码区，JVM会根据【加载】的字节码文件内容，创建一个Class的类对象。这个Class\n \t类对象里面包含了当前字节码文件里面的所有内容。\n \t\n \t只要我们获取到这个Class对象，就可以为所欲为！！！\n \t这个Class对象中包含了对应字节码文件的所有成员变量(Field) 所有成员方法(Method)\n \t构造方法(Constructor)\n */\npublic class GetClassObject {\n\tpublic static void main(String[] args) throws ClassNotFoundException {\n\t\t//如果想要为所欲为，首先回去到Class类对象\n\t\t\n\t\t/*方式1：Class.forName(\"完整的类名字符串\");\n\t\t完整类名是包括    包名.类名\n\t\tJDBC 会经常使用！！！ 规范，接口 Mybatis\n\t\t最常用的！！！\n\t\t*/\n\t\tClass cls1 = Class.forName(\"com.qfedu.a_reflect.Person\");\n\t\tSystem.out.println(cls1);\n\t\t\n\t\t//方式2：类名.class\n\t\tClass cls2 = Person.class;\n\t\tSystem.out.println(cls2);\n\t\t\n\t\t//方式3：通过对象获取到对应的Class类对象\n\t\tClass cls3 = new Person(1, \"逗比\").getClass();\n\t\tSystem.out.println(cls3);\n\t\t\n\t\tSystem.out.println(cls1 == cls2);\n\t\tSystem.out.println(cls2 == cls3);\n\t\tSystem.out.println(cls1 == cls3);\n\t}\n}\n"]],[2850,2850],[3748,3748]]],[1564022869478,["GJX@GJXAIOU",[[1,3753,"\n"]],[3752,3752],[3753,3753]]],[1564022869617,["GJX@GJXAIOU",[[1,3754,"\n"]],[3753,3753],[3754,3754]]],[1564022898224,["GJX@GJXAIOU",[[-1,3754,"\n"],[1,3755,"3"]],[3754,3754],[3755,3755]]],[1564022899768,["GJX@GJXAIOU",[[1,3755,".通过Class类对象获取当前类的构造方法"]],[3755,3755],[3776,3776]]],[1564022900223,["GJX@GJXAIOU",[[1,3776,"\n\n"]],[3776,3776],[3777,3777]]],[1564022901276,["GJX@GJXAIOU",[[-1,3777,"\n"],[1,3778,"·"]],[3777,3777],[3778,3778]]],[1564022901666,["GJX@GJXAIOU",[[1,3778,"··"]],[3778,3778],[3780,3780]]],[1564022902950,["GJX@GJXAIOU",[[-1,3778,"··"]],[3780,3780],[3778,3778]]],[1564022903703,["GJX@GJXAIOU",[[1,3778,"`"]],[3778,3778],[3779,3779]]],[1564022904094,["GJX@GJXAIOU",[[-1,3778,"`"]],[3779,3779],[3778,3778]]],[1564022904343,["GJX@GJXAIOU",[[-1,3777,"·"],[1,3778,"\n"]],[3778,3778],[3777,3777]]],[1564022904604,["GJX@GJXAIOU",[[-1,3777,"\n"],[1,3778,"`"]],[3777,3777],[3778,3778]]],[1564022905010,["GJX@GJXAIOU",[[1,3778,"``"]],[3778,3778],[3780,3780]]],[1564022905037,["GJX@GJXAIOU",[[1,3780,"language\n```\n"]],[3780,3780],[3780,3788]]],[1564022905408,["GJX@GJXAIOU",[[-1,3780,"language"],[1,3788,"j"]],[3780,3788],[3781,3781]]],[1564022905980,["GJX@GJXAIOU",[[1,3781,"ava"]],[3781,3781],[3784,3784]]],[1564022906096,["GJX@GJXAIOU",[[1,3785,"\n"]],[3784,3784],[3785,3785]]],[1564022915999,["GJX@GJXAIOU",[[1,3785,"package com.qfedu.a_reflect;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\n/**\n * 通过Class类对象获取当前类的构造方法\n * 用到Constructor 构造方法类\n *\n */\n\npublic class GetClassConstructor {\n\tpublic static void main(String[] args) throws \n\tClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n\t\t/*\n\t\t 【加载】指定类的字节码文件，获取对应的Class对象\n\t\t\t下面的语句做了两件事情：\n\t\t\t1. 让JVM根据类名，加载Person.java对应的字节码文件Person.class 到内存的代码区\n\t\t\t2. 把加载到内存代码区Person.class 字节码文件生成一个Class类对象返回\n\t\t*/\n\t\tClass cls = Class.forName(\"com.qfedu.a_reflect.Person\");\n\t\t\n\t\t\n\t\t//Constructor 这是构造方法的类\n\t\t//可以通过Class获取所有的【非私有化构造方法】，方法是Constructor[]（这是返回值） getConstuctors();\n\t\tConstructor[] constructors = cls.getConstructors();\n\t\t\n\t\tfor (Constructor constructor : constructors) {\n\t\t\tSystem.out.println(constructor);\n\t\t}\n\t\tSystem.out.println(\"----------------------------------------------------\");\n\n\n\t\t//暴力反射（获取所有构造方法，不管是不是私有化）\n\t\tConstructor[] allConstructors = cls.getDeclaredConstructors();\n\t\tfor (Constructor constructor : allConstructors) {\n\t\t\tSystem.out.println(constructor);\n\t\t}\n\t\t\n\t\t//第三种方法：\n\t\t/*\n\t\t 根据参数获取具体的构造方法 \n\t\t getConstructor(Class... parameterTypes);\n\t\t 上面括号里面是不定参数列表，表示参数的类型要求是Class类型，但是数量不限制\n\t\t 在确定数据类型的情况下，可以直接通过数据类型.class获取对应Class数据类型\n\t\t 例如：\n\t\t \tint.class String.class 这里会自动包装为Integer.class和String.class\n\t\t */\n\t\tSystem.out.println(\"----------------------------------------------------\");\n\t\tConstructor aConstructor = cls.getConstructor(int.class, String.class);\n\t\tSystem.out.println(aConstructor);\n\t\t\n\t\t\n\n\t\t//☆☆☆☆根据Constructor对象创建类对象\n\n\t\t/*\n\t\t 构造方法Constructor对象获取完毕，怎么利用Constructor对象创建一个Person类对象\n\t\t newInstance(Object... initargs) \n\t\t 也是一个不定参的方法，需要的参数都是Object类型的，参数个数不确定\n\t\t */\n\t\tPerson p = (Person) aConstructor.newInstance(1, \"海洋\");//默认产生是Object对象，因此需要强转\n\t\tSystem.out.println(p.getId() + \":\" + p.getName());\n\t\tp.sleep(5);\n\t\tp.game();\n\t\tp.eat(); //如何通过反射机制，调用static修饰的成员方法，并且不报警告\n\t\t\n\n\t\t/*\n\t\t 通过暴力反射，借助于指定的参数，获取private修饰的无参构造方法 \n\t\t */\n\t\tSystem.out.println(\"----------------------------------------------------\");\n\t\tConstructor privateConstructor = cls.getDeclaredConstructor(null);\n\t\tSystem.out.println(privateConstructor);\n\t\t\n\t\t//这里需要通过setAccessible(boolean ) 给予操作Private修饰方法的权限\n\t\tprivateConstructor.setAccessible(true);\n\t\tPerson p2 = (Person) privateConstructor.newInstance(null);\n\t\tp2.setId(2);\n\t\tp2.setName(\"刘德华\");\n\t\tSystem.out.println(p2);\n\t\t\n\t\t/*\n\t\t 单例和反射的共存：\n\t\t  \t在实际开发中，如果一个类是一个单例类，那么一般不会有程序猿通过反射的方式来使用这个类里面\n\t\t  \t私有化的构造方法，这违背了单例的原则\n\t\t */\n\t}\n}\n"]],[3785,3785],[6334,6334]]],[1564022922161,["GJX@GJXAIOU",[[1,6339,"\n"]],[6338,6338],[6339,6339]]],[1564022922310,["GJX@GJXAIOU",[[1,6340,"\n"]],[6339,6339],[6340,6340]]],[1564022926288,["GJX@GJXAIOU",[[1,6341,"\n"]],[6339,6339],[6340,6340]]],[1564022927377,["GJX@GJXAIOU",[[1,6340,"buchon"]],[6340,6340],[6346,6346]]],[1564022928224,["GJX@GJXAIOU",[[-1,6340,"buchon"]],[6346,6346],[6340,6340]]],[1564022928359,["GJX@GJXAIOU",[[-1,6341,"\n"]],[6340,6340],[6339,6339]]],[1564022934878,["GJX@GJXAIOU",[[1,6339,"补充：单例"]],[6339,6339],[6344,6344]]],[1564022935463,["GJX@GJXAIOU",[[1,6346,"\n"]],[6344,6344],[6345,6345]]],[1564022936651,["GJX@GJXAIOU",[[1,6345,"```"]],[6345,6345],[6348,6348]]],[1564022936681,["GJX@GJXAIOU",[[1,6348,"language\n```\n"]],[6348,6348],[6348,6356]]],[1564022936927,["GJX@GJXAIOU",[[1,6348,"`"],[1,6356,"`"]],[6348,6356],[6348,6358]]],[1564022937822,["GJX@GJXAIOU",[[-1,6348,"`language`"]],[6348,6358],[6348,6348]]],[1564022938930,["GJX@GJXAIOU",[[1,6348,"java"]],[6348,6348],[6352,6352]]],[1564022939030,["GJX@GJXAIOU",[[1,6353,"\n"]],[6352,6352],[6353,6353]]],[1564022951256,["GJX@GJXAIOU",[[1,6353,"package com.qfedu.a_reflect;\n\npublic class SingleDemo {\n\t\n\tint id;\n\t\n\t//为了判定数据，定义一个静态私有化成员变量，数据类型为该类的变量，保存上次创建的数据的类对象的首地址\n\tprivate static SingleDemo s = null;\n\t\n\t//1.私有化构造方法\n\tprivate SingleDemo(int id) {  \n\t\tthis.id = id;\n\t}\n\t\n\t//2.提供一个类外可以通过类名直接调用的，返回值为当前类对象类型的，参数为对应需要的构造方法参数，\n\t//方法名通常为getInstance，作为类外获取方式\n\tpublic static SingleDemo getInstance(int id) {\n\t\t//但我们调用这个公开的，静态方法修饰的获取类对象的这种方法时，对这个保存地址的变量进行判定\n\t\tif (null == s) {\n\t\t\ts = new SingleDemo(id);\n\t\t}\t\n\t\treturn s; //返回上次创建对象\n\t}\n}\n"]],[6353,6353],[6838,6838]]],[1564022953583,["GJX@GJXAIOU",[[1,6845,"\n"]],[6842,6842],[6843,6843]]],[1564022953719,["GJX@GJXAIOU",[[1,6846,"\n"]],[6843,6843],[6844,6844]]],[1564023812592,["GJX@GJXAIOU",[[1,6844,"4.通过反射借助于Class类对象，获取这个类里面所有的成员方法,binq"]],[6844,6844],[6881,6881]]],[1564023813318,["GJX@GJXAIOU",[[-1,6877,"binq"]],[6881,6881],[6877,6877]]],[1564023816799,["GJX@GJXAIOU",[[1,6877,"并且进行调用"]],[6877,6877],[6883,6883]]],[1564023817117,["GJX@GJXAIOU",[[1,6886,"\n"]],[6883,6883],[6884,6884]]],[1564023818572,["GJX@GJXAIOU",[[1,6884,"    "]],[6884,6884],[6888,6888]]],[1564023820260,["GJX@GJXAIOU",[[-1,6884,"    "]],[6888,6888],[6884,6884]]],[1564023820629,["GJX@GJXAIOU",[[-1,6886,"\n"]],[6884,6884],[6883,6883]]],[1564023822164,["GJX@GJXAIOU",[[1,6886,"\n"]],[6883,6883],[6884,6884]]],[1564023823075,["GJX@GJXAIOU",[[1,6884,"```"]],[6884,6884],[6887,6887]]],[1564023823104,["GJX@GJXAIOU",[[1,6887,"language\n```\n"]],[6887,6887],[6887,6895]]],[1564023823728,["GJX@GJXAIOU",[[-1,6887,"language"],[1,6895,"j"]],[6887,6895],[6888,6888]]],[1564023824696,["GJX@GJXAIOU",[[1,6888,"ava"]],[6888,6888],[6891,6891]]],[1564023824844,["GJX@GJXAIOU",[[1,6892,"\n"]],[6891,6891],[6892,6892]]],[1564023832925,["GJX@GJXAIOU",[[1,6892,"package com.qfedu.a_reflect;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * 通过反射借助于Class类对象，获取这个类里面所有的成员方法\n * \n * Method 就是成员方法类\n *\n */\n\npublic class GetClassMethod {\n\tpublic static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException {\n\t\t//1.加载对应类的字节码文件，获取该类的Class类对象\n\t\tClass cls = Class.forName(\"com.qfedu.a_reflect.Person\");\n\t\t\n\t\t//获取所有的公共的方法，这里也会获取一些额外Object里面公开的方法\n\t\tMethod[] allPublicMethods = cls.getMethods();\n\t\tfor (Method method : allPublicMethods) {\n\t\t\tSystem.out.println(method);\n\t\t}\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\n\t\t//暴力反射\n\t\t//能够获取Person里面的private方法， 并且能够过滤掉从父类继承而来的方法\t\n\t\tMethod[] allMethods = cls.getDeclaredMethods();\n\t\tfor (Method method : allMethods) {\n\t\t\tSystem.out.println(method);\n\t\t}\n\t\t\n\t\t/*\n\t\t 通过反射机制，执行类中的成员方法 \n\t\t invoke(Object obj, Object... args);\n\t\t Object obj 这是底层调用该方法的类对象\t\n\t\t \tthe object the underlying method is invoked from\n\t\t Object... args 不定参数，是执行该放的参数列表，是Object类型\n\t\t \targs is arguments used for method call\n\t\t */\n\t\t//1.先利用反射，创建一个当前类的对象\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\tPerson p = (Person) cls.getConstructor(int.class, String.class).\n\t\t\t\tnewInstance(1, \"狗蛋\");\n\t\t\n\t\t//获取一个指定的方法，需要的参数是方法的名字字符串和参数列表，\n\t\tMethod aPublicMethod = cls.getMethod(\"sleep\", int.class);\n\t\tSystem.out.println(aPublicMethod);\n\t\t\n\t\taPublicMethod.invoke(p, 15);\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//获取一个静态方法\n\t\tMethod aPublicStaticMethod = cls.getMethod(\"eat\", null);\n\t\taPublicStaticMethod.invoke(null, null);\n\t\t\n\t\t//利用暴力反射获取一个私有化的成员方法\n\t\tMethod aPrivateMethod = cls.getDeclaredMethod(\"testPrivate\", null);\n\t\taPrivateMethod.setAccessible(true);\n\t\taPrivateMethod.invoke(p, null);\n\t\t\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n"]],[6892,6892],[8848,8848]]],[1564023837179,["GJX@GJXAIOU",[[-1,8848,"\n"]],[8848,8848],[8847,8847]]],[1564023837319,["GJX@GJXAIOU",[[-1,8847,"\n"]],[8847,8847],[8846,8846]]],[1564023837485,["GJX@GJXAIOU",[[-1,8846,"\n"]],[8846,8846],[8845,8845]]],[1564023837588,["GJX@GJXAIOU",[[-1,8845,"\n"]],[8845,8845],[8844,8844]]],[1564023837693,["GJX@GJXAIOU",[[-1,8844,"\n"]],[8844,8844],[8843,8843]]],[1564023837829,["GJX@GJXAIOU",[[-1,8843,"\n"]],[8843,8843],[8842,8842]]],[1564023837948,["GJX@GJXAIOU",[[-1,8842,"\n"]],[8842,8842],[8841,8841]]],[1564023838076,["GJX@GJXAIOU",[[-1,8841,"\n"]],[8841,8841],[8840,8840]]],[1564023838212,["GJX@GJXAIOU",[[-1,8840,"\n"]],[8840,8840],[8839,8839]]],[1564023838565,["GJX@GJXAIOU",[[-1,8839,"\n"]],[8839,8839],[8838,8838]]],[1564023901795,["GJX@GJXAIOU",[[1,8844,"5."]],[8844,8844],[8846,8846]]],[1564024236579,["GJX@GJXAIOU",[[1,8846,"·"]],[8846,8846],[8847,8847]]],[1564024236780,["GJX@GJXAIOU",[[-1,8848,"\n"],[1,8849,"·"]],[8847,8847],[8849,8849]]],[1564024236948,["GJX@GJXAIOU",[[1,8849,"·"]],[8849,8849],[8850,8850]]],[1564024237825,["GJX@GJXAIOU",[[-1,8849,"·"]],[8850,8850],[8849,8849]]],[1564024238032,["GJX@GJXAIOU",[[-1,8848,"·"]],[8849,8849],[0,0]]],[1564024246404,["GJX@GJXAIOU",[[-1,8846,"·"]],[8847,8847],[8846,8846]]],[1564024246686,["GJX@GJXAIOU",[[1,8847,"\n"]],[8846,8846],[8847,8847]]],[1564024247418,["GJX@GJXAIOU",[[-1,8847,"\n"],[1,8848,"`"]],[8847,8847],[8848,8848]]],[1564024248126,["GJX@GJXAIOU",[[1,8848,"``"]],[8848,8848],[8850,8850]]],[1564024248158,["GJX@GJXAIOU",[[1,8850,"language\n```\n"]],[8850,8850],[8850,8858]]],[1564024249063,["GJX@GJXAIOU",[[-1,8850,"language"],[1,8858,"j"]],[8850,8858],[8851,8851]]],[1564024249541,["GJX@GJXAIOU",[[1,8851,"ava"]],[8851,8851],[8854,8854]]],[1564024249749,["GJX@GJXAIOU",[[1,8855,"\n"]],[8854,8854],[8855,8855]]],[1564024251029,["GJX@GJXAIOU",[[1,8855,"package com.qfedu.a_reflect;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\n\n/**\n * 通过反射获取Class类对象里面所有的成员变量\n * Field 成员变量类\n * @author 刘晓磊\n *\n */\n\npublic class GetClassField {\n\tpublic static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException {\n\t\t//加载字节码文件，获取Class类对象\n\t\tClass cls = Class.forName(\"com.qfedu.a_reflect.Person\");\n\n\t\t//获取所有用public修饰的成员变量\n\t\tField[] allPublicFields = cls.getFields();\n\n\t\tfor (Field field : allPublicFields) {\n\t\t\tSystem.out.println(field);\n\t\t}\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//暴力反射，获取私有化成员变量\n\t\tField[] allFields = cls.getDeclaredFields();\n\t\tfor (Field field : allFields) {\n\t\t\tSystem.out.println(field);\n\t\t}\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//获取一个公开的成员变量\n\t\tField aPublicField = cls.getField(\"test\");\n\t\tSystem.out.println(aPublicField);\n\n\t\t\n\t\t//set方法\n\t\t//set(Oject obj, Object value);\n\t\t//第一个参数: 要操作的是哪一个对象里面的成员变量\n\t\t//第二个参数: 需要设置的值\n\t\t\n\t\t//首先获得对象，然后调用set方法\n\t\tPerson p = (Person) cls.getConstructor(int.class, String.class).\n\t\t\t\tnewInstance(1, \"狗蛋\");\n\t\taPublicField.set(p, 20);\n\t\t\n\t\tSystem.out.println(p.test);\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//静态的\n\t\tField aStaticField = cls.getField(\"testStatic\");\n\t\tSystem.out.println(aStaticField);\n\t\taStaticField.set(null, 20);\n\t\tSystem.out.println(Person.testStatic);\n\t\t\n\t\t//暴力反射：私有化的\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\tField aPrivateField = cls.getDeclaredField(\"id\");\n\t\tSystem.out.println(aPrivateField);\n\t\taPrivateField.setAccessible(true);\n\t\taPrivateField.set(p, 10);\n\t\tSystem.out.println(p.getId());\n\t\t\n\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[8855,8855],[10732,10732]]],[1564024257696,["GJX@GJXAIOU",[[1,8846,"通过反射获取Class类对象里面所有的成员变量"]],[8846,8846],[8869,8869]]],[1564024334174,["GJX@GJXAIOU",[[-1,288,"java.lang.reflect"]],[288,305],[288,288]]],[1564024336312,["GJX@GJXAIOU",[[1,283,"（）"]],[283,283],[285,285]]],[1564024337797,["GJX@GJXAIOU",[[-1,283,"（）"]],[285,285],[283,283]]],[1564024338886,["GJX@GJXAIOU",[[1,283,"()"]],[283,283],[285,285]]],[1564024340134,["GJX@GJXAIOU",[[1,284,"java.lang.reflect"]],[284,284],[301,301]]],[1564024359727,["GJX@GJXAIOU",[[1,415,"4. \n    "]],[410,410],[418,418]]],[1564024362908,["GJX@GJXAIOU",[[-1,414," 4. "]],[418,418],[414,414]]],[1564024363624,["GJX@GJXAIOU",[[1,414,"gan"]],[414,414],[417,417]]],[1564024365076,["GJX@GJXAIOU",[[-1,411,"   gan"]],[417,417],[411,411]]],[1564024380260,["GJX@GJXAIOU",[[1,411,"返回值 | 方法名| 作用"]],[411,411],[424,424]]],[1564024381263,["GJX@GJXAIOU",[[1,425,"\n"]],[424,424],[425,425]]],[1564024384936,["GJX@GJXAIOU",[[1,425,"---| ="]],[425,425],[431,431]]],[1564024385356,["GJX@GJXAIOU",[[-1,430,"="]],[431,431],[430,430]]],[1564024385799,["GJX@GJXAIOU",[[1,430,"00"]],[430,430],[432,432]]],[1564024386860,["GJX@GJXAIOU",[[-1,429," 00"]],[432,432],[429,429]]],[1564024390665,["GJX@GJXAIOU",[[1,429,"---|----"]],[429,429],[437,437]]],[1564024393271,["GJX@GJXAIOU",[[1,460," "]],[459,459],[460,460]]],[1564024394090,["GJX@GJXAIOU",[[1,460,"|"]],[460,460],[461,461]]],[1564024397553,["GJX@GJXAIOU",[[1,481,"|"]],[481,481],[482,482]]],[1564024400358,["GJX@GJXAIOU",[[1,522,"|"]],[522,522],[523,523]]],[1564024404574,["GJX@GJXAIOU",[[1,549,"|"]],[549,549],[550,550]]],[1564024410832,["GJX@GJXAIOU",[[1,604,"|"]],[604,604],[605,605]]],[1564024421172,["GJX@GJXAIOU",[[-1,646,"                    "]],[666,666],[646,646]]],[1564024421564,["GJX@GJXAIOU",[[-1,645,"\n"]],[646,646],[645,645]]],[1564024422978,["GJX@GJXAIOU",[[1,645,"|"]],[645,645],[646,646]]],[1564024427601,["GJX@GJXAIOU",[[1,735,"|"]],[735,735],[736,736]]],[1564024431303,["GJX@GJXAIOU",[[1,686,"|"]],[686,686],[687,687]]],[1564024437877,["GJX@GJXAIOU",[[-1,738,"                    "]],[758,758],[738,738]]],[1564024439103,["GJX@GJXAIOU",[[-1,737,"\n"]],[738,738],[737,737]]],[1564024444352,["GJX@GJXAIOU",[[1,782," "]],[781,781],[782,782]]],[1564024444730,["GJX@GJXAIOU",[[1,782,"|"]],[782,782],[783,783]]],[1564024450580,["GJX@GJXAIOU",[[-1,818,"                    "]],[838,838],[818,818]]],[1564024450948,["GJX@GJXAIOU",[[-1,817,"\n"]],[818,818],[817,817]]],[1564024451887,["GJX@GJXAIOU",[[1,817,"|"]],[817,817],[818,818]]],[1564024462416,["GJX@GJXAIOU",[[1,897,"5. \n    "]],[892,892],[900,900]]],[1564024462452,["GJX@GJXAIOU",[[1,892," 5. "],[-1,896," 5."]],[900,900],[901,901]]],[1564024463680,["GJX@GJXAIOU",[[1,901,"返回值 | 方法名| 作用\n---|---|----"]],[901,901],[927,927]]],[1564024466166,["GJX@GJXAIOU",[[-1,897,"    "]],[897,901],[897,897]]],[1564024471030,["GJX@GJXAIOU",[[1,941," |"]],[941,941],[943,943]]],[1564024474909,["GJX@GJXAIOU",[[-1,957,"\n                "]],[957,974],[957,957]]],[1564024476057,["GJX@GJXAIOU",[[1,957,"|"]],[957,957],[958,958]]],[1564024478302,["GJX@GJXAIOU",[[1,1020," "]],[1019,1019],[1020,1020]]],[1564024478697,["GJX@GJXAIOU",[[1,1020,"|"]],[1020,1020],[1021,1021]]],[1564024481421,["GJX@GJXAIOU",[[-1,1044,"\n                "]],[1044,1061],[1044,1044]]],[1564024481729,["GJX@GJXAIOU",[[1,1044,"|"]],[1044,1044],[1045,1045]]],[1564024485342,["GJX@GJXAIOU",[[1,1103," | "]],[1103,1103],[1106,1106]]],[1564024488326,["GJX@GJXAIOU",[[-1,1151,"\n                "]],[1151,1168],[1151,1151]]],[1564024488590,["GJX@GJXAIOU",[[1,1151,"|"]],[1151,1151],[1152,1152]]],[1564024491665,["GJX@GJXAIOU",[[-1,1189," "],[1,1190,"|"]],[1189,1189],[1190,1190]]],[1564024493558,["GJX@GJXAIOU",[[1,1190," "]],[1190,1190],[1191,1191]]],[1564024494285,["GJX@GJXAIOU",[[1,1189," "]],[1189,1189],[1190,1190]]],[1564024496549,["GJX@GJXAIOU",[[-1,1245,"\n                "]],[1245,1262],[1245,1245]]],[1564024496895,["GJX@GJXAIOU",[[1,1245,"|"]],[1245,1245],[1246,1246]]],[1564024502257,["GJX@GJXAIOU",[[1,1347,"|"]],[1347,1347],[1348,1348]]],[1564024504791,["GJX@GJXAIOU",[[1,1293,"|"]],[1293,1293],[1294,1294]]],[1564024507695,["GJX@GJXAIOU",[[-1,1331,"\n               "]],[1331,1347],[1331,1331]]],[1564024518791,["GJX@GJXAIOU",[[-1,924,"        "]],[924,932],[924,924]]],[1564024521492,["GJX@GJXAIOU",[[-1,893,"5. "]],[896,896],[893,893]]],[1564024522480,["GJX@GJXAIOU",[[1,894,"    5. \n"]],[893,893],[901,901]]],[1564024524012,["GJX@GJXAIOU",[[-1,894,"    5. "]],[894,901],[894,894]]],[1564024526996,["GJX@GJXAIOU",[[-1,875,"    "]],[875,879],[875,875]]],[1564024532039,["GJX@GJXAIOU",[[-1,989,"        "]],[989,997],[989,989]]],[1564024533966,["GJX@GJXAIOU",[[-1,1066,"        "]],[1066,1074],[1066,1066]]],[1564024535156,["GJX@GJXAIOU",[[-1,1145,"        "]],[1145,1153],[1145,1145]]],[1564024538070,["GJX@GJXAIOU",[[-1,1253,"  "]],[1252,1252],[1250,1250]]],[1564024545695,["GJX@GJXAIOU",[[-1,438,"        "]],[438,446],[438,438]]],[1564024547860,["GJX@GJXAIOU",[[-1,494,"      "]],[493,499],[493,493]]],[1564024549236,["GJX@GJXAIOU",[[-1,570,"        "]],[570,578],[570,570]]],[1564024551213,["GJX@GJXAIOU",[[-1,645,"        "]],[645,653],[645,645]]],[1564024552871,["GJX@GJXAIOU",[[-1,738,"       "]],[737,744],[737,737]]],[1564024562168,["GJX@GJXAIOU",[[1,1212,"无"]],[1212,1212],[1213,1213]]],[1564024569591,["GJX@GJXAIOU",[[-1,23,"  "],[-1,44,"  "],[-1,92,"  "],[-1,110," "],[-1,117," "],[-1,131,"  "],[-1,166,"  "],[-1,169,"  "],[-1,215,"  "],[-1,226,"  "],[-1,229,"  "],[-1,264," "],[-1,271," "],[-1,314,"  "],[-1,335," "],[-1,342," "],[-1,357,"  "]],[25,377],[23,349]]],[1564024570094,["GJX@GJXAIOU",[[-1,21,"  "],[-1,42,"  "],[-1,86,"  "],[-1,104," "],[-1,109," "],[-1,123,"  "],[-1,154,"  "],[-1,157,"  "],[-1,199,"  "],[-1,208,"  "],[-1,211,"  "],[-1,244," "],[-1,249," "],[-1,290,"  "],[-1,311," "],[-1,316," "],[-1,331,"  "]],[23,349],[21,321]]],[1564024575636,["GJX@GJXAIOU",[[-1,331,"    "]],[335,335],[331,331]]],[1564024578495,["GJX@GJXAIOU",[[-1,333," "]],[334,334],[333,333]]],[1564024582317,["GJX@GJXAIOU",[[-1,195," "]],[196,196],[195,195]]],[1564024583548,["GJX@GJXAIOU",[[-1,23," "]],[24,24],[23,23]]],[1564024587903,["GJX@GJXAIOU",[[1,21,"- "]],[21,21],[23,23]]],[1564024590205,["GJX@GJXAIOU",[[1,194,"- "]],[194,194],[196,196]]],[1564024592367,["GJX@GJXAIOU",[[1,333,"- "]],[333,333],[335,335]]],[1564024594581,["GJX@GJXAIOU",[[1,354,"- \n"]],[353,353],[356,356]]],[1564024595253,["GJX@GJXAIOU",[[-1,354,"- "]],[356,356],[354,354]]],[1564024601324,["GJX@GJXAIOU",[[-1,784," "]],[785,785],[784,784]]],[1564024602925,["GJX@GJXAIOU",[[1,782,"- "]],[782,782],[784,784]]],[1564024608732,["GJX@GJXAIOU",[[-1,1252,"    "]],[1252,1256],[1252,1252]]],[1564024609208,["GJX@GJXAIOU",[[1,1252,"- "]],[1252,1252],[1254,1254]]],[1564024611384,["GJX@GJXAIOU",[[-1,1256," "]],[1257,1257],[1256,1256]]],[1564024614172,["GJX@GJXAIOU",[[1,1266,"- \n"]],[1265,1265],[1268,1268]]],[1564024614628,["GJX@GJXAIOU",[[-1,1266,"- "]],[1268,1268],[1266,1266]]],[1564024621789,["GJX@GJXAIOU",[[1,1267,"\n"]],[1266,1266],[1267,1267]]],[1564024622212,["GJX@GJXAIOU",[[1,1267,"****"]],[1267,1267],[1269,1269]]],[1564024624981,["GJX@GJXAIOU",[[-1,1271,"\n"]],[1272,1272],[1271,1271]]],[1564024625868,["GJX@GJXAIOU",[[-1,1267,"****"]],[1271,1271],[1267,1267]]],[1564024628151,["GJX@GJXAIOU",[[1,1267,"****"]],[1267,1267],[1271,1271]]],[1564024628679,["GJX@GJXAIOU",[[1,1271,"\n"]],[1271,1271],[1272,1272]]],[1564024631244,["GJX@GJXAIOU",[[-1,1267,"****"],[1,1271,"返回值 | 方法名| 作用\n---|---|----"]],[1267,1271],[1293,1293]]],[1564024634572,["GJX@GJXAIOU",[[-1,1295,"       "]],[1294,1301],[1294,1294]]],[1564024637670,["GJX@GJXAIOU",[[1,1303," |"]],[1303,1303],[1305,1305]]],[1564024641567,["GJX@GJXAIOU",[[1,1317," |"]],[1317,1317],[1319,1319]]],[1564024645532,["GJX@GJXAIOU",[[-1,1319,"\n               "]],[1319,1335],[1319,1319]]],[1564024648977,["GJX@GJXAIOU",[[1,1512,"|"]],[1512,1512],[1513,1513]]],[1564024651338,["GJX@GJXAIOU",[[1,1435,"|"]],[1435,1435],[1436,1436]]],[1564024653423,["GJX@GJXAIOU",[[1,1355,"|"]],[1355,1355],[1356,1356]]],[1564024655897,["GJX@GJXAIOU",[[1,1377,"|"]],[1377,1377],[1378,1378]]],[1564024658223,["GJX@GJXAIOU",[[1,1465,"|"]],[1465,1465],[1466,1466]]],[1564024661158,["GJX@GJXAIOU",[[1,1552,"|"]],[1552,1552],[1553,1553]]],[1564024663147,["GJX@GJXAIOU",[[1,1638,"|"]],[1638,1638],[1639,1639]]],[1564024665900,["GJX@GJXAIOU",[[1,1607,"|"]],[1607,1607],[1608,1608]]],[1564024668901,["GJX@GJXAIOU",[[-1,1640,"\n                "]],[1640,1657],[1640,1640]]],[1564024671580,["GJX@GJXAIOU",[[-1,1553,"\n                "]],[1553,1570],[1553,1553]]],[1564024673556,["GJX@GJXAIOU",[[-1,1466,"\n                "]],[1466,1483],[1466,1466]]],[1564024675900,["GJX@GJXAIOU",[[-1,1378,"\n               "]],[1378,1394],[1378,1378]]],[1564024677324,["GJX@GJXAIOU",[[-1,1341,"       "]],[1340,1347],[1340,1340]]],[1564024678813,["GJX@GJXAIOU",[[-1,1400,"        "]],[1400,1408],[1400,1400]]],[1564024679916,["GJX@GJXAIOU",[[-1,1454,"        "]],[1454,1462],[1454,1454]]],[1564024682888,["GJX@GJXAIOU",[[1,1531,"无"]],[1531,1531],[1532,1532]]],[1564024687744,["GJX@GJXAIOU",[[-1,1527,"    "]],[1527,1531],[1527,1527]]],[1564024690668,["GJX@GJXAIOU",[[-1,1607,"    "]],[1607,1611],[1607,1607]]],[1564024691743,["GJX@GJXAIOU",[[-1,1609," "]],[1610,1610],[1609,1609]]],[1564024695072,["GJX@GJXAIOU",[[1,1607,"- "]],[1607,1607],[1609,1609]]],[1564024729223,["GJX@GJXAIOU",[[1,18,"一、"]],[18,18],[20,20]]],[1564024732496,["GJX@GJXAIOU",[[1,22,"总结"]],[22,22],[24,24]]],[1564024734365,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1564024734468,["GJX@GJXAIOU",[[1,0,"\n"]],[1,1],[2,2]]],[1564024736157,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1564024736286,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1564024736390,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1564024736427,["GJX@GJXAIOU",[[1,5,"---\n\n\n"]],[3,3],[4,4]]],[1564024736685,["GJX@GJXAIOU",[[1,4,"l"]],[4,4],[5,5]]],[1564024736860,["GJX@GJXAIOU",[[1,6,"\n"]],[5,5],[6,6]]],[1564024737494,["GJX@GJXAIOU",[[-1,6,"\n"]],[6,6],[5,5]]],[1564024737596,["GJX@GJXAIOU",[[-1,4,"l"]],[5,5],[4,4]]],[1564024740229,["GJX@GJXAIOU",[[1,4,"tags : "]],[4,4],[11,11]]],[1564024741150,["GJX@GJXAIOU",[[1,12,"\n"]],[11,11],[12,12]]],[1564024742998,["GJX@GJXAIOU",[[1,12,"- fan"]],[12,12],[17,17]]],[1564024743759,["GJX@GJXAIOU",[[-1,14,"fan"]],[17,17],[14,14]]],[1564024745250,["GJX@GJXAIOU",[[1,14,"反射"]],[14,14],[16,16]]],[1564024794192,["GJX@GJXAIOU",[[1,1696,"二"]],[1696,1696],[1697,1697]]],[1564024797021,["GJX@GJXAIOU",[[-1,1695," "]],[1696,1696],[1695,1695]]],[1564024800669,["GJX@GJXAIOU",[[1,1696,"、获取Class对象的三种方式"]],[1696,1696],[1711,1711]]],[1564024830300,["GJX@GJXAIOU",[[1,3523,"\n"]],[3522,3522],[3523,3523]]],[1564024830430,["GJX@GJXAIOU",[[1,3524,"\n"]],[3523,3523],[3524,3524]]],[1564024834278,["GJX@GJXAIOU",[[1,3524,"## 三、Constructor常用方法"]],[3524,3524],[3544,3544]]],[1564024859333,["GJX@GJXAIOU",[[1,6635,"\n"]],[6634,6634],[6635,6635]]],[1564024859463,["GJX@GJXAIOU",[[1,6636,"\n"]],[6635,6635],[6636,6636]]],[1564024866419,["GJX@GJXAIOU",[[1,6636,"## 四、Method常用方法 "]],[6636,6636],[6652,6652]]],[1564024871700,["GJX@GJXAIOU",[[1,8653,"\n"]],[8652,8652],[8653,8653]]],[1564024873502,["GJX@GJXAIOU",[[1,8653,"## "]],[8653,8653],[8656,8656]]],[1564024875059,["GJX@GJXAIOU",[[1,8656,"无"]],[8656,8656],[8657,8657]]],[1564024875597,["GJX@GJXAIOU",[[-1,8656,"无"]],[8657,8657],[8656,8656]]],[1564024880446,["GJX@GJXAIOU",[[1,8656,"五、Field常用方法"]],[8656,8656],[8667,8667]]],[1564024887533,["GJX@GJXAIOU",[[-1,10579,"\n"]],[10579,10579],[10578,10578]]],[1564024887644,["GJX@GJXAIOU",[[-1,10578,"\n"]],[10578,10578],[10577,10577]]],[1564024887811,["GJX@GJXAIOU",[[-1,10577,"\n"]],[10577,10577],[10576,10576]]],[1564024887932,["GJX@GJXAIOU",[[-1,10576,"\n"]],[10576,10576],[10575,10575]]],[1564024888044,["GJX@GJXAIOU",[[-1,10575,"\n"]],[10575,10575],[10574,10574]]],[1564024888279,["GJX@GJXAIOU",[[-1,10574,"\n"]],[10574,10574],[10573,10573]]],[1564024888605,["GJX@GJXAIOU",[[-1,10573,"\n"]],[10573,10573],[10572,10572]]],[1564024888773,["GJX@GJXAIOU",[[-1,10572,"\n"]],[10572,10572],[10571,10571]]],[1564024888932,["GJX@GJXAIOU",[[-1,10571,"\n"]],[10571,10571],[10570,10570]]],[1564024889085,["GJX@GJXAIOU",[[-1,10570,"\n"]],[10570,10570],[10569,10569]]],[1564024889244,["GJX@GJXAIOU",[[-1,10569,"\n"]],[10569,10569],[10568,10568]]],[1564024889483,["GJX@GJXAIOU",[[-1,10568,"\n"]],[10568,10568],[10567,10567]]],[1564024889620,["GJX@GJXAIOU",[[-1,10567,"\n"]],[10567,10567],[10566,10566]]],[1564024889759,["GJX@GJXAIOU",[[-1,10566,"\n"]],[10566,10566],[10565,10565]]],[1564024889886,["GJX@GJXAIOU",[[-1,10565,"\n"]],[10565,10565],[10564,10564]]],[1564024890039,["GJX@GJXAIOU",[[-1,10564,"\n"]],[10564,10564],[10563,10563]]],[1564024890172,["GJX@GJXAIOU",[[-1,10563,"\n"]],[10563,10563],[10562,10562]]],[1564024890340,["GJX@GJXAIOU",[[-1,10562,"\n"]],[10562,10562],[10561,10561]]],[1564024890541,["GJX@GJXAIOU",[[-1,10561,"\n"]],[10561,10561],[10560,10560]]],[1564024890732,["GJX@GJXAIOU",[[-1,10560,"\n"]],[10560,10560],[10559,10559]]],[1564024890932,["GJX@GJXAIOU",[[-1,10559,"\n"]],[10559,10559],[10558,10558]]],[1564024891300,["GJX@GJXAIOU",[[-1,10558,"\n"]],[10558,10558],[10557,10557]]],[1564024891683,["GJX@GJXAIOU",[[-1,10557,"\n"]],[10557,10557],[10556,10556]]],[1564024893500,["GJX@GJXAIOU",[[-1,10551,"\n"]],[10551,10551],[10550,10550]]],[1564024893659,["GJX@GJXAIOU",[[-1,10549,"\t"]],[10550,10550],[10549,10549]]]],null,"GJX@GJXAIOU"],["1dee258c-8bc1-4b95-af0e-fd47fef50c1f",1564052983635,"---\ntags : \n- 反射\n---\n\n\n# JavaDay27 反射\n## 一、反射总结\n- 1.获取Class对象的三种方式：\n    1> Class.forName(\"完整的类名字符串\");\n        完整类名字符串是指 包名.类名\n    2> 类名.class;\n    3> 指定类对象.getClass();\n    \n    最常用的是Class.forName(\"完整的类名字符串\");\n    后期大量使用\n\n- 2.Constructor, Method, Field \n    都是Java反射这个包(java.lang.reflect)里面的类 \n    Constructor 是构造方法类\n    Method 是成员方法类\n    Field 是成员变量类\n        \n- 3.Constructor常用方法：\n\n返回值 | 方法名| 作用\n---|---|----\nConstructor[] | getConstructors(); |获取所有public修饰的构造方法\n  Constructor[] |getDeclaredConstructors();| 获取当前类里面所有的构造方法，包含用private修饰的构造方法\nConstructor |getConstructor(Object... paramterTyeps);|根据所需参数不同，获取指定的构造方法对象\nConstructor| getDeclaredConstructor(Object... paramterTyeps);|根据所需参数不同，获取指定的构造方法对象，包括私有化的方法\n Object | newInstance(Object... initargs); |给予确定的参数，通过反射调用构造方法，这里的参数列表是一个不定参数列表\n                    \n- 4.Method常用方法 \n\n返回值 | 方法名| 作用\n---|---|----\nMethod[]  |getMethods(); |获取当前类里面所有的public修饰的成员方法，这里或显示父类继承而来的public方法\nMethod[] | getDeclaredMethods(); |获取当前类里面的所有方法，包括private修饰的方法，但是会过滤父类继承而来的方法\nMethod  | getMethod(String methodName, Object... args);|根据方法的名字和对应的参数列表，获取指定方法\nMethod | getDeclaredMethod(String methodName, Object... args);|根据方法的名字和对应的参数列表，获取指定方法，可以获取private修饰的方法\n 无    | invoke(Object obj, Object... args);  |执行成员方法的函数，第一个参数是执行该方法的类对象，第二个参数是执行该方法需要的参数列表\n    \n- 5.Field常用方法\n\n返回值 | 方法名| 作用\n---|---|----\n Field[]  |getFields(); | 获取所有的用public修饰的成员变量\n Field[]| getDeclaredFields();| 获取所用成员变量，包括用private 修饰的成员变量\nField |getField(String fieldName);|根据成员变量的名字获取对应的成员变量\nField |getDeclaredField(String fieldName);|根据成员变量的名字获取包括private修饰在内的成员变量\n无   | set(Object obj, Object value);|设置成员变量的数值，第一个参数是调用该成员变量的对象，第二个参数是赋予数值\n    \n- 6.暴力反射赋予权限的函数\n        setAccessible(boolean )\n        \n##  二、获取Class对象的三种方式   \n\n1.首先新建一个 Person 类\n```java\npackage com.qfedu.a_reflect;\n\n//如何获取一个类对象\npublic class Person {\n\tprivate int id;\n\tprivate String name;\n\t\n\tpublic int test;\n\tpublic static int testStatic = 10;\n\t\n\tprivate Person() {}\n\t\n\tpublic Person(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\t\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic static void eat() {\n\t\tSystem.out.println(\"黄焖鸡米饭~~~\");\n\t}\n\t\n\tpublic void sleep(int num) {\n\t\tSystem.out.println(name + \"每天睡\" + num + \"个小时\");\n\t}\n\t\n\tpublic void game() {\n\t\tSystem.out.println(\"大吉大利，今晚吃鸡~~~\");\n\t}\n\t\n\tprivate void testPrivate() {\n\t\tSystem.out.println(\"这是一个Private修饰的私有化方法\");\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Person [id=\" + id + \", name=\" + name + \"]\";\n\t}\n}\n\n```\n\n2.通过反射获取类对象\n```java\npackage com.qfedu.a_reflect;\n\n/*\n  反射：\n \t当一个Java文件编译之后，编译成一个.class文件，也就是字节码问题，当这个字节码文件【加载】到\n \t内存的方法区/代码区，JVM会根据【加载】的字节码文件内容，创建一个Class的类对象。这个Class\n \t类对象里面包含了当前字节码文件里面的所有内容。\n \t\n \t只要我们获取到这个Class对象，就可以为所欲为！！！\n \t这个Class对象中包含了对应字节码文件的所有成员变量(Field) 所有成员方法(Method)\n \t构造方法(Constructor)\n */\npublic class GetClassObject {\n\tpublic static void main(String[] args) throws ClassNotFoundException {\n\t\t//如果想要为所欲为，首先回去到Class类对象\n\t\t\n\t\t/*方式1：Class.forName(\"完整的类名字符串\");\n\t\t完整类名是包括    包名.类名\n\t\tJDBC 会经常使用！！！ 规范，接口 Mybatis\n\t\t最常用的！！！\n\t\t*/\n\t\tClass cls1 = Class.forName(\"com.qfedu.a_reflect.Person\");\n\t\tSystem.out.println(cls1);\n\t\t\n\t\t//方式2：类名.class\n\t\tClass cls2 = Person.class;\n\t\tSystem.out.println(cls2);\n\t\t\n\t\t//方式3：通过对象获取到对应的Class类对象\n\t\tClass cls3 = new Person(1, \"逗比\").getClass();\n\t\tSystem.out.println(cls3);\n\t\t\n\t\tSystem.out.println(cls1 == cls2);\n\t\tSystem.out.println(cls2 == cls3);\n\t\tSystem.out.println(cls1 == cls3);\n\t}\n}\n\n```\n\n\n## 三、Constructor常用方法\n3.通过Class类对象获取当前类的构造方法\n```java\npackage com.qfedu.a_reflect;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\n/**\n * 通过Class类对象获取当前类的构造方法\n * 用到Constructor 构造方法类\n *\n */\n\npublic class GetClassConstructor {\n\tpublic static void main(String[] args) throws \n\tClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n\t\t/*\n\t\t 【加载】指定类的字节码文件，获取对应的Class对象\n\t\t\t下面的语句做了两件事情：\n\t\t\t1. 让JVM根据类名，加载Person.java对应的字节码文件Person.class 到内存的代码区\n\t\t\t2. 把加载到内存代码区Person.class 字节码文件生成一个Class类对象返回\n\t\t*/\n\t\tClass cls = Class.forName(\"com.qfedu.a_reflect.Person\");\n\t\t\n\t\t\n\t\t//Constructor 这是构造方法的类\n\t\t//可以通过Class获取所有的【非私有化构造方法】，方法是Constructor[]（这是返回值） getConstuctors();\n\t\tConstructor[] constructors = cls.getConstructors();\n\t\t\n\t\tfor (Constructor constructor : constructors) {\n\t\t\tSystem.out.println(constructor);\n\t\t}\n\t\tSystem.out.println(\"----------------------------------------------------\");\n\n\n\t\t//暴力反射（获取所有构造方法，不管是不是私有化）\n\t\tConstructor[] allConstructors = cls.getDeclaredConstructors();\n\t\tfor (Constructor constructor : allConstructors) {\n\t\t\tSystem.out.println(constructor);\n\t\t}\n\t\t\n\t\t//第三种方法：\n\t\t/*\n\t\t 根据参数获取具体的构造方法 \n\t\t getConstructor(Class... parameterTypes);\n\t\t 上面括号里面是不定参数列表，表示参数的类型要求是Class类型，但是数量不限制\n\t\t 在确定数据类型的情况下，可以直接通过数据类型.class获取对应Class数据类型\n\t\t 例如：\n\t\t \tint.class String.class 这里会自动包装为Integer.class和String.class\n\t\t */\n\t\tSystem.out.println(\"----------------------------------------------------\");\n\t\tConstructor aConstructor = cls.getConstructor(int.class, String.class);\n\t\tSystem.out.println(aConstructor);\n\t\t\n\t\t\n\n\t\t//☆☆☆☆根据Constructor对象创建类对象\n\n\t\t/*\n\t\t 构造方法Constructor对象获取完毕，怎么利用Constructor对象创建一个Person类对象\n\t\t newInstance(Object... initargs) \n\t\t 也是一个不定参的方法，需要的参数都是Object类型的，参数个数不确定\n\t\t */\n\t\tPerson p = (Person) aConstructor.newInstance(1, \"海洋\");//默认产生是Object对象，因此需要强转\n\t\tSystem.out.println(p.getId() + \":\" + p.getName());\n\t\tp.sleep(5);\n\t\tp.game();\n\t\tp.eat(); //如何通过反射机制，调用static修饰的成员方法，并且不报警告\n\t\t\n\n\t\t/*\n\t\t 通过暴力反射，借助于指定的参数，获取private修饰的无参构造方法 \n\t\t */\n\t\tSystem.out.println(\"----------------------------------------------------\");\n\t\tConstructor privateConstructor = cls.getDeclaredConstructor(null);\n\t\tSystem.out.println(privateConstructor);\n\t\t\n\t\t//这里需要通过setAccessible(boolean ) 给予操作Private修饰方法的权限\n\t\tprivateConstructor.setAccessible(true);\n\t\tPerson p2 = (Person) privateConstructor.newInstance(null);\n\t\tp2.setId(2);\n\t\tp2.setName(\"刘德华\");\n\t\tSystem.out.println(p2);\n\t\t\n\t\t/*\n\t\t 单例和反射的共存：\n\t\t  \t在实际开发中，如果一个类是一个单例类，那么一般不会有程序猿通过反射的方式来使用这个类里面\n\t\t  \t私有化的构造方法，这违背了单例的原则\n\t\t */\n\t}\n}\n\n```\n补充：单例\n```java\npackage com.qfedu.a_reflect;\n\npublic class SingleDemo {\n\t\n\tint id;\n\t\n\t//为了判定数据，定义一个静态私有化成员变量，数据类型为该类的变量，保存上次创建的数据的类对象的首地址\n\tprivate static SingleDemo s = null;\n\t\n\t//1.私有化构造方法\n\tprivate SingleDemo(int id) {  \n\t\tthis.id = id;\n\t}\n\t\n\t//2.提供一个类外可以通过类名直接调用的，返回值为当前类对象类型的，参数为对应需要的构造方法参数，\n\t//方法名通常为getInstance，作为类外获取方式\n\tpublic static SingleDemo getInstance(int id) {\n\t\t//但我们调用这个公开的，静态方法修饰的获取类对象的这种方法时，对这个保存地址的变量进行判定\n\t\tif (null == s) {\n\t\t\ts = new SingleDemo(id);\n\t\t}\t\n\t\treturn s; //返回上次创建对象\n\t}\n}\n\n```\n\n\n## 四、Method常用方法 \n4.通过反射借助于Class类对象，获取这个类里面所有的成员方法,并且进行调用\n```java\npackage com.qfedu.a_reflect;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * 通过反射借助于Class类对象，获取这个类里面所有的成员方法\n * \n * Method 就是成员方法类\n *\n */\n\npublic class GetClassMethod {\n\tpublic static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException {\n\t\t//1.加载对应类的字节码文件，获取该类的Class类对象\n\t\tClass cls = Class.forName(\"com.qfedu.a_reflect.Person\");\n\t\t\n\t\t//获取所有的公共的方法，这里也会获取一些额外Object里面公开的方法\n\t\tMethod[] allPublicMethods = cls.getMethods();\n\t\tfor (Method method : allPublicMethods) {\n\t\t\tSystem.out.println(method);\n\t\t}\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\n\t\t//暴力反射\n\t\t//能够获取Person里面的private方法， 并且能够过滤掉从父类继承而来的方法\t\n\t\tMethod[] allMethods = cls.getDeclaredMethods();\n\t\tfor (Method method : allMethods) {\n\t\t\tSystem.out.println(method);\n\t\t}\n\t\t\n\t\t/*\n\t\t 通过反射机制，执行类中的成员方法 \n\t\t invoke(Object obj, Object... args);\n\t\t Object obj 这是底层调用该方法的类对象\t\n\t\t \tthe object the underlying method is invoked from\n\t\t Object... args 不定参数，是执行该放的参数列表，是Object类型\n\t\t \targs is arguments used for method call\n\t\t */\n\t\t//1.先利用反射，创建一个当前类的对象\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\tPerson p = (Person) cls.getConstructor(int.class, String.class).\n\t\t\t\tnewInstance(1, \"狗蛋\");\n\t\t\n\t\t//获取一个指定的方法，需要的参数是方法的名字字符串和参数列表，\n\t\tMethod aPublicMethod = cls.getMethod(\"sleep\", int.class);\n\t\tSystem.out.println(aPublicMethod);\n\t\t\n\t\taPublicMethod.invoke(p, 15);\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//获取一个静态方法\n\t\tMethod aPublicStaticMethod = cls.getMethod(\"eat\", null);\n\t\taPublicStaticMethod.invoke(null, null);\n\t\t\n\t\t//利用暴力反射获取一个私有化的成员方法\n\t\tMethod aPrivateMethod = cls.getDeclaredMethod(\"testPrivate\", null);\n\t\taPrivateMethod.setAccessible(true);\n\t\taPrivateMethod.invoke(p, null);\n\t\t\n\t}\n}\n\n```\n\n## 五、Field常用方法\n5.通过反射获取Class类对象里面所有的成员变量\n```java\npackage com.qfedu.a_reflect;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\n\n/**\n * 通过反射获取Class类对象里面所有的成员变量\n * Field 成员变量类\n * @author 刘晓磊\n *\n */\n\npublic class GetClassField {\n\tpublic static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException {\n\t\t//加载字节码文件，获取Class类对象\n\t\tClass cls = Class.forName(\"com.qfedu.a_reflect.Person\");\n\n\t\t//获取所有用public修饰的成员变量\n\t\tField[] allPublicFields = cls.getFields();\n\n\t\tfor (Field field : allPublicFields) {\n\t\t\tSystem.out.println(field);\n\t\t}\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//暴力反射，获取私有化成员变量\n\t\tField[] allFields = cls.getDeclaredFields();\n\t\tfor (Field field : allFields) {\n\t\t\tSystem.out.println(field);\n\t\t}\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//获取一个公开的成员变量\n\t\tField aPublicField = cls.getField(\"test\");\n\t\tSystem.out.println(aPublicField);\n\n\t\t\n\t\t//set方法\n\t\t//set(Oject obj, Object value);\n\t\t//第一个参数: 要操作的是哪一个对象里面的成员变量\n\t\t//第二个参数: 需要设置的值\n\t\t\n\t\t//首先获得对象，然后调用set方法\n\t\tPerson p = (Person) cls.getConstructor(int.class, String.class).\n\t\t\t\tnewInstance(1, \"狗蛋\");\n\t\taPublicField.set(p, 20);\n\t\t\n\t\tSystem.out.println(p.test);\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//静态的\n\t\tField aStaticField = cls.getField(\"testStatic\");\n\t\tSystem.out.println(aStaticField);\n\t\taStaticField.set(null, 20);\n\t\tSystem.out.println(Person.testStatic);\n\t\t\n\t\t//暴力反射：私有化的\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\tField aPrivateField = cls.getDeclaredField(\"id\");\n\t\tSystem.out.println(aPrivateField);\n\t\taPrivateField.setAccessible(true);\n\t\taPrivateField.set(p, 10);\n\t\tSystem.out.println(p.getId());\n\t\n\t}\n}\n```\n",[[1564052937591,["GJX@GJXAIOU",[[1,10559,"\n"]],[10558,10558],[10559,10559]]],[1564052937726,["GJX@GJXAIOU",[[1,10560,"\n"]],[10559,10559],[10560,10560]]],[1564052937854,["GJX@GJXAIOU",[[1,10561,"\n"]],[10560,10560],[10561,10561]]],[1564052940901,["GJX@GJXAIOU",[[1,10561,"## zongjie"]],[10561,10561],[10571,10571]]],[1564052942181,["GJX@GJXAIOU",[[-1,10564,"zongjie"]],[10571,10571],[10564,10564]]],[1564052944378,["GJX@GJXAIOU",[[1,10564,"总结"]],[10564,10564],[10566,10566]]],[1564052944721,["GJX@GJXAIOU",[[1,10567,"\n"]],[10566,10566],[10567,10567]]],[1564052946800,["GJX@GJXAIOU",[[1,10567,"- 反射：\n  一个Java文件，编译之后生成的.class文件，程序运行时加载到内存中，会保存在内存的【代码区】，而这个.class字节码文件，会对应生成一个Class类对象，借助于Class类对象，可以完成一系列反射操作\n  \n  - 获取Class类对象的方式：\n      1.Class.forName(\"完整的类名\"); 最常用！！！\n      2.已知类名.class;\n      3.对应类的类对象.getClass();\n  \n  - Constructor \n      getConstructors();\n      getDeclaredConstructors();\n      getConstructor(Class... parameterTypes);\n          例如：getConstructor(int.class, String.class);\n      getDeclaredConstructor(Class... parameterTypes);\n      Constructor的类对象.newInstance(Object... args);\n  - Method\n      invoke(Object obj, Object... args);\n  - Field\n      set(Object obj, Object value);\n      \n  - 设置权限的方式：\n      setAccessible(boolean b);\n      \n  - 反射和单例类的一个平衡\n      一个类如果是单例类，一般不会采用反射的方式去暴力获取该类的构造方法，不符合单例的机制"]],[10567,10567],[11297,11297]]]],null,"GJX@GJXAIOU"],["56e7aef1-be33-4b3d-9266-f6f529e15916",1564101850729,"---\ntags : \n- 反射\n---\n\n\n# JavaDay27 反射\n## 一、反射总结\n- 1.获取Class对象的三种方式：\n    1> Class.forName(\"完整的类名字符串\");\n        完整类名字符串是指 包名.类名\n    2> 类名.class;\n    3> 指定类对象.getClass();\n    \n    最常用的是Class.forName(\"完整的类名字符串\");\n    后期大量使用\n\n- 2.Constructor, Method, Field \n    都是Java反射这个包(java.lang.reflect)里面的类 \n    Constructor 是构造方法类\n    Method 是成员方法类\n    Field 是成员变量类\n        \n- 3.Constructor常用方法：\n\n返回值 | 方法名| 作用\n---|---|----\nConstructor[] | getConstructors(); |获取所有public修饰的构造方法\n  Constructor[] |getDeclaredConstructors();| 获取当前类里面所有的构造方法，包含用private修饰的构造方法\nConstructor |getConstructor(Object... paramterTyeps);|根据所需参数不同，获取指定的构造方法对象\nConstructor| getDeclaredConstructor(Object... paramterTyeps);|根据所需参数不同，获取指定的构造方法对象，包括私有化的方法\n Object | newInstance(Object... initargs); |给予确定的参数，通过反射调用构造方法，这里的参数列表是一个不定参数列表\n                    \n- 4.Method常用方法 \n\n返回值 | 方法名| 作用\n---|---|----\nMethod[]  |getMethods(); |获取当前类里面所有的public修饰的成员方法，这里或显示父类继承而来的public方法\nMethod[] | getDeclaredMethods(); |获取当前类里面的所有方法，包括private修饰的方法，但是会过滤父类继承而来的方法\nMethod  | getMethod(String methodName, Object... args);|根据方法的名字和对应的参数列表，获取指定方法\nMethod | getDeclaredMethod(String methodName, Object... args);|根据方法的名字和对应的参数列表，获取指定方法，可以获取private修饰的方法\n 无    | invoke(Object obj, Object... args);  |执行成员方法的函数，第一个参数是执行该方法的类对象，第二个参数是执行该方法需要的参数列表\n    \n- 5.Field常用方法\n\n返回值 | 方法名| 作用\n---|---|----\n Field[]  |getFields(); | 获取所有的用public修饰的成员变量\n Field[]| getDeclaredFields();| 获取所用成员变量，包括用private 修饰的成员变量\nField |getField(String fieldName);|根据成员变量的名字获取对应的成员变量\nField |getDeclaredField(String fieldName);|根据成员变量的名字获取包括private修饰在内的成员变量\n无   | set(Object obj, Object value);|设置成员变量的数值，第一个参数是调用该成员变量的对象，第二个参数是赋予数值\n    \n- 6.暴力反射赋予权限的函数\n        setAccessible(boolean )\n        \n##  二、获取Class对象的三种方式   \n\n1.首先新建一个 Person 类\n```java\npackage com.qfedu.a_reflect;\n\n//如何获取一个类对象\npublic class Person {\n\tprivate int id;\n\tprivate String name;\n\t\n\tpublic int test;\n\tpublic static int testStatic = 10;\n\t\n\tprivate Person() {}\n\t\n\tpublic Person(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\t\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic static void eat() {\n\t\tSystem.out.println(\"黄焖鸡米饭~~~\");\n\t}\n\t\n\tpublic void sleep(int num) {\n\t\tSystem.out.println(name + \"每天睡\" + num + \"个小时\");\n\t}\n\t\n\tpublic void game() {\n\t\tSystem.out.println(\"大吉大利，今晚吃鸡~~~\");\n\t}\n\t\n\tprivate void testPrivate() {\n\t\tSystem.out.println(\"这是一个Private修饰的私有化方法\");\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Person [id=\" + id + \", name=\" + name + \"]\";\n\t}\n}\n\n```\n\n2.通过反射获取类对象\n```java\npackage com.qfedu.a_reflect;\n\n/*\n  反射：\n \t当一个Java文件编译之后，编译成一个.class文件，也就是字节码问题，当这个字节码文件【加载】到\n \t内存的方法区/代码区，JVM会根据【加载】的字节码文件内容，创建一个Class的类对象。这个Class\n \t类对象里面包含了当前字节码文件里面的所有内容。\n \t\n \t只要我们获取到这个Class对象，就可以为所欲为！！！\n \t这个Class对象中包含了对应字节码文件的所有成员变量(Field) 所有成员方法(Method)\n \t构造方法(Constructor)\n */\npublic class GetClassObject {\n\tpublic static void main(String[] args) throws ClassNotFoundException {\n\t\t//如果想要为所欲为，首先回去到Class类对象\n\t\t\n\t\t/*方式1：Class.forName(\"完整的类名字符串\");\n\t\t完整类名是包括    包名.类名\n\t\tJDBC 会经常使用！！！ 规范，接口 Mybatis\n\t\t最常用的！！！\n\t\t*/\n\t\tClass cls1 = Class.forName(\"com.qfedu.a_reflect.Person\");\n\t\tSystem.out.println(cls1);\n\t\t\n\t\t//方式2：类名.class\n\t\tClass cls2 = Person.class;\n\t\tSystem.out.println(cls2);\n\t\t\n\t\t//方式3：通过对象获取到对应的Class类对象\n\t\tClass cls3 = new Person(1, \"逗比\").getClass();\n\t\tSystem.out.println(cls3);\n\t\t\n\t\tSystem.out.println(cls1 == cls2);\n\t\tSystem.out.println(cls2 == cls3);\n\t\tSystem.out.println(cls1 == cls3);\n\t}\n}\n\n```\n\n\n## 三、Constructor常用方法\n3.通过Class类对象获取当前类的构造方法\n```java\npackage com.qfedu.a_reflect;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\n/**\n * 通过Class类对象获取当前类的构造方法\n * 用到Constructor 构造方法类\n *\n */\n\npublic class GetClassConstructor {\n\tpublic static void main(String[] args) throws \n\tClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n\t\t/*\n\t\t 【加载】指定类的字节码文件，获取对应的Class对象\n\t\t\t下面的语句做了两件事情：\n\t\t\t1. 让JVM根据类名，加载Person.java对应的字节码文件Person.class 到内存的代码区\n\t\t\t2. 把加载到内存代码区Person.class 字节码文件生成一个Class类对象返回\n\t\t*/\n\t\tClass cls = Class.forName(\"com.qfedu.a_reflect.Person\");\n\t\t\n\t\t\n\t\t//Constructor 这是构造方法的类\n\t\t//可以通过Class获取所有的【非私有化构造方法】，方法是Constructor[]（这是返回值） getConstuctors();\n\t\tConstructor[] constructors = cls.getConstructors();\n\t\t\n\t\tfor (Constructor constructor : constructors) {\n\t\t\tSystem.out.println(constructor);\n\t\t}\n\t\tSystem.out.println(\"----------------------------------------------------\");\n\n\n\t\t//暴力反射（获取所有构造方法，不管是不是私有化）\n\t\tConstructor[] allConstructors = cls.getDeclaredConstructors();\n\t\tfor (Constructor constructor : allConstructors) {\n\t\t\tSystem.out.println(constructor);\n\t\t}\n\t\t\n\t\t//第三种方法：\n\t\t/*\n\t\t 根据参数获取具体的构造方法 \n\t\t getConstructor(Class... parameterTypes);\n\t\t 上面括号里面是不定参数列表，表示参数的类型要求是Class类型，但是数量不限制\n\t\t 在确定数据类型的情况下，可以直接通过数据类型.class获取对应Class数据类型\n\t\t 例如：\n\t\t \tint.class String.class 这里会自动包装为Integer.class和String.class\n\t\t */\n\t\tSystem.out.println(\"----------------------------------------------------\");\n\t\tConstructor aConstructor = cls.getConstructor(int.class, String.class);\n\t\tSystem.out.println(aConstructor);\n\t\t\n\t\t\n\n\t\t//☆☆☆☆根据Constructor对象创建类对象\n\n\t\t/*\n\t\t 构造方法Constructor对象获取完毕，怎么利用Constructor对象创建一个Person类对象\n\t\t newInstance(Object... initargs) \n\t\t 也是一个不定参的方法，需要的参数都是Object类型的，参数个数不确定\n\t\t */\n\t\tPerson p = (Person) aConstructor.newInstance(1, \"海洋\");//默认产生是Object对象，因此需要强转\n\t\tSystem.out.println(p.getId() + \":\" + p.getName());\n\t\tp.sleep(5);\n\t\tp.game();\n\t\tp.eat(); //如何通过反射机制，调用static修饰的成员方法，并且不报警告\n\t\t\n\n\t\t/*\n\t\t 通过暴力反射，借助于指定的参数，获取private修饰的无参构造方法 \n\t\t */\n\t\tSystem.out.println(\"----------------------------------------------------\");\n\t\tConstructor privateConstructor = cls.getDeclaredConstructor(null);\n\t\tSystem.out.println(privateConstructor);\n\t\t\n\t\t//这里需要通过setAccessible(boolean ) 给予操作Private修饰方法的权限\n\t\tprivateConstructor.setAccessible(true);\n\t\tPerson p2 = (Person) privateConstructor.newInstance(null);\n\t\tp2.setId(2);\n\t\tp2.setName(\"刘德华\");\n\t\tSystem.out.println(p2);\n\t\t\n\t\t/*\n\t\t 单例和反射的共存：\n\t\t  \t在实际开发中，如果一个类是一个单例类，那么一般不会有程序猿通过反射的方式来使用这个类里面\n\t\t  \t私有化的构造方法，这违背了单例的原则\n\t\t */\n\t}\n}\n\n```\n补充：单例\n```java\npackage com.qfedu.a_reflect;\n\npublic class SingleDemo {\n\t\n\tint id;\n\t\n\t//为了判定数据，定义一个静态私有化成员变量，数据类型为该类的变量，保存上次创建的数据的类对象的首地址\n\tprivate static SingleDemo s = null;\n\t\n\t//1.私有化构造方法\n\tprivate SingleDemo(int id) {  \n\t\tthis.id = id;\n\t}\n\t\n\t//2.提供一个类外可以通过类名直接调用的，返回值为当前类对象类型的，参数为对应需要的构造方法参数，\n\t//方法名通常为getInstance，作为类外获取方式\n\tpublic static SingleDemo getInstance(int id) {\n\t\t//但我们调用这个公开的，静态方法修饰的获取类对象的这种方法时，对这个保存地址的变量进行判定\n\t\tif (null == s) {\n\t\t\ts = new SingleDemo(id);\n\t\t}\t\n\t\treturn s; //返回上次创建对象\n\t}\n}\n\n```\n\n\n## 四、Method常用方法 \n4.通过反射借助于Class类对象，获取这个类里面所有的成员方法,并且进行调用\n```java\npackage com.qfedu.a_reflect;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * 通过反射借助于Class类对象，获取这个类里面所有的成员方法\n * \n * Method 就是成员方法类\n *\n */\n\npublic class GetClassMethod {\n\tpublic static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException {\n\t\t//1.加载对应类的字节码文件，获取该类的Class类对象\n\t\tClass cls = Class.forName(\"com.qfedu.a_reflect.Person\");\n\t\t\n\t\t//获取所有的公共的方法，这里也会获取一些额外Object里面公开的方法\n\t\tMethod[] allPublicMethods = cls.getMethods();\n\t\tfor (Method method : allPublicMethods) {\n\t\t\tSystem.out.println(method);\n\t\t}\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\n\t\t//暴力反射\n\t\t//能够获取Person里面的private方法， 并且能够过滤掉从父类继承而来的方法\t\n\t\tMethod[] allMethods = cls.getDeclaredMethods();\n\t\tfor (Method method : allMethods) {\n\t\t\tSystem.out.println(method);\n\t\t}\n\t\t\n\t\t/*\n\t\t 通过反射机制，执行类中的成员方法 \n\t\t invoke(Object obj, Object... args);\n\t\t Object obj 这是底层调用该方法的类对象\t\n\t\t \tthe object the underlying method is invoked from\n\t\t Object... args 不定参数，是执行该放的参数列表，是Object类型\n\t\t \targs is arguments used for method call\n\t\t */\n\t\t//1.先利用反射，创建一个当前类的对象\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\tPerson p = (Person) cls.getConstructor(int.class, String.class).\n\t\t\t\tnewInstance(1, \"狗蛋\");\n\t\t\n\t\t//获取一个指定的方法，需要的参数是方法的名字字符串和参数列表，\n\t\tMethod aPublicMethod = cls.getMethod(\"sleep\", int.class);\n\t\tSystem.out.println(aPublicMethod);\n\t\t\n\t\taPublicMethod.invoke(p, 15);\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//获取一个静态方法\n\t\tMethod aPublicStaticMethod = cls.getMethod(\"eat\", null);\n\t\taPublicStaticMethod.invoke(null, null);\n\t\t\n\t\t//利用暴力反射获取一个私有化的成员方法\n\t\tMethod aPrivateMethod = cls.getDeclaredMethod(\"testPrivate\", null);\n\t\taPrivateMethod.setAccessible(true);\n\t\taPrivateMethod.invoke(p, null);\n\t\t\n\t}\n}\n\n```\n\n## 五、Field常用方法\n5.通过反射获取Class类对象里面所有的成员变量\n```java\npackage com.qfedu.a_reflect;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\n\n/**\n * 通过反射获取Class类对象里面所有的成员变量\n * Field 成员变量类\n * @author 刘晓磊\n *\n */\n\npublic class GetClassField {\n\tpublic static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException {\n\t\t//加载字节码文件，获取Class类对象\n\t\tClass cls = Class.forName(\"com.qfedu.a_reflect.Person\");\n\n\t\t//获取所有用public修饰的成员变量\n\t\tField[] allPublicFields = cls.getFields();\n\n\t\tfor (Field field : allPublicFields) {\n\t\t\tSystem.out.println(field);\n\t\t}\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//暴力反射，获取私有化成员变量\n\t\tField[] allFields = cls.getDeclaredFields();\n\t\tfor (Field field : allFields) {\n\t\t\tSystem.out.println(field);\n\t\t}\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//获取一个公开的成员变量\n\t\tField aPublicField = cls.getField(\"test\");\n\t\tSystem.out.println(aPublicField);\n\n\t\t\n\t\t//set方法\n\t\t//set(Oject obj, Object value);\n\t\t//第一个参数: 要操作的是哪一个对象里面的成员变量\n\t\t//第二个参数: 需要设置的值\n\t\t\n\t\t//首先获得对象，然后调用set方法\n\t\tPerson p = (Person) cls.getConstructor(int.class, String.class).\n\t\t\t\tnewInstance(1, \"狗蛋\");\n\t\taPublicField.set(p, 20);\n\t\t\n\t\tSystem.out.println(p.test);\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//静态的\n\t\tField aStaticField = cls.getField(\"testStatic\");\n\t\tSystem.out.println(aStaticField);\n\t\taStaticField.set(null, 20);\n\t\tSystem.out.println(Person.testStatic);\n\t\t\n\t\t//暴力反射：私有化的\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\tField aPrivateField = cls.getDeclaredField(\"id\");\n\t\tSystem.out.println(aPrivateField);\n\t\taPrivateField.setAccessible(true);\n\t\taPrivateField.set(p, 10);\n\t\tSystem.out.println(p.getId());\n\t\n\t}\n}\n```\n\n\n## 总结\n- 反射：\n  一个Java文件，编译之后生成的.class文件，程序运行时加载到内存中，会保存在内存的【代码区】，而这个.class字节码文件，会对应生成一个Class类对象，借助于Class类对象，可以完成一系列反射操作\n  \n  - 获取Class类对象的方式：\n      1.Class.forName(\"完整的类名\"); 最常用！！！\n      2.已知类名.class;\n      3.对应类的类对象.getClass();\n  \n  - Constructor \n      getConstructors();\n      getDeclaredConstructors();\n      getConstructor(Class... parameterTypes);\n          例如：getConstructor(int.class, String.class);\n      getDeclaredConstructor(Class... parameterTypes);\n      Constructor的类对象.newInstance(Object... args);\n  - Method\n      invoke(Object obj, Object... args);\n  - Field\n      set(Object obj, Object value);\n      \n  - 设置权限的方式：\n      setAccessible(boolean b);\n      \n  - 反射和单例类的一个平衡\n      一个类如果是单例类，一般不会采用反射的方式去暴力获取该类的构造方法，不符合单例的机制\n",[[1564101804632,["GJX@GJXAIOU",[[1,75,"**"],[1,101,"**"]],[75,101],[75,105]]],[1564101915122,["GJX@GJXAIOU",[[1,1708,"l "]],[1708,1708],[1709,1709]]],[1564101915318,["GJX@GJXAIOU",[[1,1709,"ei"]],[1709,1709],[1711,1711]]],[1564101916104,["GJX@GJXAIOU",[[-1,1708,"lei"]],[1711,1711],[1708,1708]]],[1564101917286,["GJX@GJXAIOU",[[1,1708,"类"]],[1708,1708],[1709,1709]]],[1564101917323,["GJX@GJXAIOU",[[1,1708," "]],[1709,1709],[1710,1710]]],[1564101924221,["GJX@GJXAIOU",[[1,1740,"，作为示例"]],[1740,1740],[1745,1745]]],[1564101934408,["GJX@GJXAIOU",[[-1,1784,"//如何获取一个类对象"]],[1784,1795],[1784,1784]]],[1564101934968,["GJX@GJXAIOU",[[-1,1784,"\n"]],[1784,1784],[1783,1783]]],[1564101963478,["GJX@GJXAIOU",[[-1,2654,"反射：\n \t当一个Java文件编译之后，编译成一个.class文件，也就是字节码问题，当这个字节码文件【加载】到\n \t内存的方法区/代码区，JVM会根据【加载】的字节码文件内容，创建一个Class的类对象。这个Class\n \t类对象里面包含了当前字节码文件里面的所有内容。\n \t\n \t只要我们获取到这个Class对象，就可以为所欲为！！！\n \t这个Class对象中包含了对应字节码文件的所有成员变量(Field) 所有成员方法(Method)\n \t构造方法(Constructor)"]],[2654,2895],[2654,2654]]],[1564101965767,["GJX@GJXAIOU",[[-1,2649,"/*\n  \n */"]],[2649,2658],[2649,2649]]],[1564101966220,["GJX@GJXAIOU",[[-1,2649,"\n"]],[2649,2649],[2648,2648]]],[1564101980833,["GJX@GJXAIOU",[[-1,1686,"        "],[1,1694,"\n"]],[1694,1694],[1687,1687]]],[1564101980992,["GJX@GJXAIOU",[[1,1688,"\n"]],[1687,1687],[1688,1688]]],[1564101981706,["GJX@GJXAIOU",[[1,1689,"\n"]],[1688,1688],[1689,1689]]],[1564101981905,["GJX@GJXAIOU",[[1,1690,"\n"]],[1689,1689],[1690,1690]]],[1564101984202,["GJX@GJXAIOU",[[-1,1690,"\n"]],[1690,1690],[1689,1689]]],[1564101984336,["GJX@GJXAIOU",[[-1,1689,"\n"]],[1689,1689],[1688,1688]]],[1564101990438,["GJX@GJXAIOU",[[1,1687,"--------------------------"]],[1687,1687],[1713,1713]]],[1564101995208,["GJX@GJXAIOU",[[1,48,"\n"]],[47,47],[48,48]]],[1564101997120,["GJX@GJXAIOU",[[1,48,"反射：\n \t当一个Java文件编译之后，编译成一个.class文件，也就是字节码问题，当这个字节码文件【加载】到\n \t内存的方法区/代码区，JVM会根据【加载】的字节码文件内容，创建一个Class的类对象。这个Class\n \t类对象里面包含了当前字节码文件里面的所有内容。\n \t\n \t只要我们获取到这个Class对象，就可以为所欲为！！！\n \t这个Class对象中包含了对应字节码文件的所有成员变量(Field) 所有成员方法(Method)\n \t构造方法(Constructor)"]],[48,48],[289,289]]],[1564102001466,["GJX@GJXAIOU",[[1,48,"- "]],[48,48],[50,50]]],[1564102005561,["GJX@GJXAIOU",[[-1,271,"\n \t"]],[271,274],[271,271]]],[1564102008251,["GJX@GJXAIOU",[[1,288,"。"]],[288,288],[289,289]]],[1564102008688,["GJX@GJXAIOU",[[1,290," \t\n"]],[289,289],[292,292]]],[1564102024296,["GJX@GJXAIOU",[[-1,106,"\n \t"]],[106,109],[106,106]]],[1564102028799,["GJX@GJXAIOU",[[-1,157,"\n \t"]],[157,160],[157,157]]],[1564102051751,["GJX@GJXAIOU",[[-1,3025,"回去"]],[3027,3027],[3025,3025]]],[1564102053357,["GJX@GJXAIOU",[[1,3025,"获取"]],[3025,3025],[3027,3027]]],[1564102061472,["GJX@GJXAIOU",[[-1,3094,"\t\tJDBC 会经常使用！！！ 规范，接口 Mybatis\n\t\t最常用的！！！"]],[3096,3133],[3094,3094]]],[1564102061718,["GJX@GJXAIOU",[[-1,3094,"\n"]],[3094,3094],[3093,3093]]],[1564102079751,["GJX@GJXAIOU",[[-1,3513,"3."],[1,3515,"1"]],[3513,3515],[3514,3514]]],[1564102079961,["GJX@GJXAIOU",[[1,3514,"."]],[3514,3514],[3515,3515]]],[1564102100333,["GJX@GJXAIOU",[[1,3512,"并"]],[3512,3512],[3513,3513]]],[1564102113839,["GJX@GJXAIOU",[[-1,3512,"并"]],[3513,3513],[3512,3512]]],[1564102117071,["GJX@GJXAIOU",[[-1,3513,"1."]],[3513,3515],[3513,3513]]],[1564102122077,["GJX@GJXAIOU",[[1,3533,"并且调用"]],[3533,3533],[3537,3537]]],[1564102137079,["GJX@GJXAIOU",[[-1,3667,"/**\n * 通过Class类对象获取当前类的构造方法\n * 用到Constructor 构造方法类\n *\n */"]],[3667,3724],[3667,3667]]],[1564102137454,["GJX@GJXAIOU",[[-1,3668,"\n"]],[3667,3667],[3666,3666]]],[1564102138503,["GJX@GJXAIOU",[[-1,3667,"\n"]],[3666,3666],[3665,3665]]],[1564102140911,["GJX@GJXAIOU",[[-1,3575,"\n"]],[3575,3575],[3574,3574]]],[1564102174359,["GJX@GJXAIOU",[[-1,4201,"Constructor[]（这是返回值）"]],[4201,4221],[4201,4201]]],[1564102182627,["GJX@GJXAIOU",[[-1,3919,"\t"],[-1,3923,"\t"],[-1,3953,"\t"],[-1,3971,"\t"],[-1,4028,"\t"],[-1,4074,"\t"]],[3920,4078],[3919,4072]]],[1564102183968,["GJX@GJXAIOU",[[-1,3918,"\t"],[-1,3922,"\t"],[-1,3951,"\t"],[-1,3967,"\t"],[-1,4023,"\t"],[-1,4069,"\t"]],[3919,4072],[3918,4066]]],[1564102213312,["GJX@GJXAIOU",[[-1,4133,"\t"],[-1,4157,"\t"]],[4134,4166],[4133,4164]]],[1564102256915,["GJX@GJXAIOU",[[1,4436,"第二种："]],[4436,4436],[4440,4440]]],[1564102261947,["GJX@GJXAIOU",[[1,4159,"第一种："]],[4159,4159],[4163,4163]]],[1564102267623,["GJX@GJXAIOU",[[-1,4629,"\t"]],[4629,4630],[4629,4629]]],[1564102270447,["GJX@GJXAIOU",[[-1,4437,"\t"]],[4437,4438],[4437,4437]]],[1564102280734,["GJX@GJXAIOU",[[-1,5063,"\t"]],[5063,5064],[5063,5063]]],[1564102293187,["GJX@GJXAIOU",[[1,5089,"，即调用构造函数"]],[5089,5089],[5097,5097]]]],null,"GJX@GJXAIOU"],["39b6079c-0f51-4b83-9291-1c51e7a5c51a",1565415210168,"---\ntags : \n- 反射\n---\n\n\n# JavaDay27 反射\n## 一、反射总结\n- 反射：\n \t当一个Java文件编译之后，编译成一个.class文件，也就是字节码问题，当这个字节码文件【加载】到内存的方法区/代码区，JVM会根据【加载】的字节码文件内容，创建一个Class的类对象。这个Class类对象里面包含了当前字节码文件里面的所有内容。\n \t\n \t只要我们获取到这个Class对象，就可以为所欲为！！！\n \t这个Class对象中包含了对应字节码文件的所有成员变量(Field) 所有成员方法(Method)构造方法(Constructor)。\n \t\n- 1.获取Class对象的三种方式：\n    1> **Class.forName(\"完整的类名字符串\");**\n        完整类名字符串是指 包名.类名\n    2> 类名.class;\n    3> 指定类对象.getClass();\n    \n    最常用的是Class.forName(\"完整的类名字符串\");\n    后期大量使用\n\n- 2.Constructor, Method, Field \n    都是Java反射这个包(java.lang.reflect)里面的类 \n    Constructor 是构造方法类\n    Method 是成员方法类\n    Field 是成员变量类\n        \n- 3.Constructor常用方法：\n\n返回值 | 方法名| 作用\n---|---|----\nConstructor[] | getConstructors(); |获取所有public修饰的构造方法\n  Constructor[] |getDeclaredConstructors();| 获取当前类里面所有的构造方法，包含用private修饰的构造方法\nConstructor |getConstructor(Object... paramterTyeps);|根据所需参数不同，获取指定的构造方法对象\nConstructor| getDeclaredConstructor(Object... paramterTyeps);|根据所需参数不同，获取指定的构造方法对象，包括私有化的方法\n Object | newInstance(Object... initargs); |给予确定的参数，通过反射调用构造方法，这里的参数列表是一个不定参数列表\n                    \n- 4.Method常用方法 \n\n返回值 | 方法名| 作用\n---|---|----\nMethod[]  |getMethods(); |获取当前类里面所有的public修饰的成员方法，这里或显示父类继承而来的public方法\nMethod[] | getDeclaredMethods(); |获取当前类里面的所有方法，包括private修饰的方法，但是会过滤父类继承而来的方法\nMethod  | getMethod(String methodName, Object... args);|根据方法的名字和对应的参数列表，获取指定方法\nMethod | getDeclaredMethod(String methodName, Object... args);|根据方法的名字和对应的参数列表，获取指定方法，可以获取private修饰的方法\n 无    | invoke(Object obj, Object... args);  |执行成员方法的函数，第一个参数是执行该方法的类对象，第二个参数是执行该方法需要的参数列表\n    \n- 5.Field常用方法\n\n返回值 | 方法名| 作用\n---|---|----\n Field[]  |getFields(); | 获取所有的用public修饰的成员变量\n Field[]| getDeclaredFields();| 获取所用成员变量，包括用private 修饰的成员变量\nField |getField(String fieldName);|根据成员变量的名字获取对应的成员变量\nField |getDeclaredField(String fieldName);|根据成员变量的名字获取包括private修饰在内的成员变量\n无   | set(Object obj, Object value);|设置成员变量的数值，第一个参数是调用该成员变量的对象，第二个参数是赋予数值\n    \n- 6.暴力反射赋予权限的函数\n        setAccessible(boolean )\n\n--------------------------\n\n##  二、获取Class 类 对象的三种方式   \n\n1.首先新建一个 Person 类，作为示例\n```java\npackage com.qfedu.a_reflect;\n\npublic class Person {\n\tprivate int id;\n\tprivate String name;\n\t\n\tpublic int test;\n\tpublic static int testStatic = 10;\n\t\n\tprivate Person() {}\n\t\n\tpublic Person(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\t\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic static void eat() {\n\t\tSystem.out.println(\"黄焖鸡米饭~~~\");\n\t}\n\t\n\tpublic void sleep(int num) {\n\t\tSystem.out.println(name + \"每天睡\" + num + \"个小时\");\n\t}\n\t\n\tpublic void game() {\n\t\tSystem.out.println(\"大吉大利，今晚吃鸡~~~\");\n\t}\n\t\n\tprivate void testPrivate() {\n\t\tSystem.out.println(\"这是一个Private修饰的私有化方法\");\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Person [id=\" + id + \", name=\" + name + \"]\";\n\t}\n}\n\n```\n\n2.通过反射获取类对象\n```java\npackage com.qfedu.a_reflect;\n\npublic class GetClassObject {\n\tpublic static void main(String[] args) throws ClassNotFoundException {\n\t\t//如果想要为所欲为，首先获取到Class类对象\n\t\t\n\t\t/*方式1：Class.forName(\"完整的类名字符串\");\n\t\t完整类名是包括    包名.类名\n\t\t*/\n\t\tClass cls1 = Class.forName(\"com.qfedu.a_reflect.Person\");\n\t\tSystem.out.println(cls1);\n\t\t\n\t\t//方式2：类名.class\n\t\tClass cls2 = Person.class;\n\t\tSystem.out.println(cls2);\n\t\t\n\t\t//方式3：通过对象获取到对应的Class类对象\n\t\tClass cls3 = new Person(1, \"逗比\").getClass();\n\t\tSystem.out.println(cls3);\n\t\t\n\t\tSystem.out.println(cls1 == cls2);\n\t\tSystem.out.println(cls2 == cls3);\n\t\tSystem.out.println(cls1 == cls3);\n\t}\n}\n\n```\n\n\n## 三、Constructor常用方法\n通过Class类对象获取当前类的构造方法并且调用\n```java\npackage com.qfedu.a_reflect;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\npublic class GetClassConstructor {\n\tpublic static void main(String[] args) throws \n\tClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n/*\n 【加载】指定类的字节码文件，获取对应的Class对象\n\t下面的语句做了两件事情：\n\t1. 让JVM根据类名，加载Person.java对应的字节码文件Person.class 到内存的代码区\n\t2. 把加载到内存代码区Person.class 字节码文件生成一个Class类对象返回\n*/\n\t\tClass cls = Class.forName(\"com.qfedu.a_reflect.Person\");\n\t\t\n\t\t\n\t//Constructor 这是构造方法的类\n\t//第一种：可以通过Class获取所有的【非私有化构造方法】，方法是 getConstuctors();\n\t\tConstructor[] constructors = cls.getConstructors();\n\t\t\n\t\tfor (Constructor constructor : constructors) {\n\t\t\tSystem.out.println(constructor);\n\t\t}\n\t\tSystem.out.println(\"----------------------------------------------------\");\n\n\n\t//第二种：暴力反射（获取所有构造方法，不管是不是私有化）\n\t\tConstructor[] allConstructors = cls.getDeclaredConstructors();\n\t\tfor (Constructor constructor : allConstructors) {\n\t\t\tSystem.out.println(constructor);\n\t\t}\n\t\t\n\t//第三种方法：\n\t\t/*\n\t\t 根据参数获取具体的构造方法 \n\t\t getConstructor(Class... parameterTypes);\n\t\t 上面括号里面是不定参数列表，表示参数的类型要求是Class类型，但是数量不限制\n\t\t 在确定数据类型的情况下，可以直接通过数据类型.class获取对应Class数据类型\n\t\t 例如：\n\t\t \tint.class String.class 这里会自动包装为Integer.class和String.class\n\t\t */\n\t\tSystem.out.println(\"----------------------------------------------------\");\n\t\tConstructor aConstructor = cls.getConstructor(int.class, String.class);\n\t\tSystem.out.println(aConstructor);\n\t\t\n\t\t\n\n\t//☆☆☆☆根据Constructor对象创建类对象，即调用构造函数\n\n\t\t/*\n\t\t 构造方法Constructor对象获取完毕，怎么利用Constructor对象创建一个Person类对象\n\t\t newInstance(Object... initargs) \n\t\t 也是一个不定参的方法，需要的参数都是Object类型的，参数个数不确定\n\t\t */\n\t\tPerson p = (Person) aConstructor.newInstance(1, \"海洋\");//默认产生是Object对象，因此需要强转\n\t\tSystem.out.println(p.getId() + \":\" + p.getName());\n\t\tp.sleep(5);\n\t\tp.game();\n\t\tp.eat(); //如何通过反射机制，调用static修饰的成员方法，并且不报警告\n\t\t\n\n\t\t/*\n\t\t 通过暴力反射，借助于指定的参数，获取private修饰的无参构造方法 \n\t\t */\n\t\tSystem.out.println(\"----------------------------------------------------\");\n\t\tConstructor privateConstructor = cls.getDeclaredConstructor(null);\n\t\tSystem.out.println(privateConstructor);\n\t\t\n\t\t//这里需要通过setAccessible(boolean ) 给予操作Private修饰方法的权限\n\t\tprivateConstructor.setAccessible(true);\n\t\tPerson p2 = (Person) privateConstructor.newInstance(null);\n\t\tp2.setId(2);\n\t\tp2.setName(\"刘德华\");\n\t\tSystem.out.println(p2);\n\t\t\n\t\t/*\n\t\t 单例和反射的共存：\n\t\t  \t在实际开发中，如果一个类是一个单例类，那么一般不会有程序猿通过反射的方式来使用这个类里面\n\t\t  \t私有化的构造方法，这违背了单例的原则\n\t\t */\n\t}\n}\n\n```\n补充：单例\n```java\npackage com.qfedu.a_reflect;\n\npublic class SingleDemo {\n\t\n\tint id;\n\t\n\t//为了判定数据，定义一个静态私有化成员变量，数据类型为该类的变量，保存上次创建的数据的类对象的首地址\n\tprivate static SingleDemo s = null;\n\t\n\t//1.私有化构造方法\n\tprivate SingleDemo(int id) {  \n\t\tthis.id = id;\n\t}\n\t\n\t//2.提供一个类外可以通过类名直接调用的，返回值为当前类对象类型的，参数为对应需要的构造方法参数，\n\t//方法名通常为getInstance，作为类外获取方式\n\tpublic static SingleDemo getInstance(int id) {\n\t\t//但我们调用这个公开的，静态方法修饰的获取类对象的这种方法时，对这个保存地址的变量进行判定\n\t\tif (null == s) {\n\t\t\ts = new SingleDemo(id);\n\t\t}\t\n\t\treturn s; //返回上次创建对象\n\t}\n}\n\n```\n\n\n## 四、Method常用方法 \n4.通过反射借助于Class类对象，获取这个类里面所有的成员方法,并且进行调用\n```java\npackage com.qfedu.a_reflect;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * 通过反射借助于Class类对象，获取这个类里面所有的成员方法\n * \n * Method 就是成员方法类\n *\n */\n\npublic class GetClassMethod {\n\tpublic static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException {\n\t\t//1.加载对应类的字节码文件，获取该类的Class类对象\n\t\tClass cls = Class.forName(\"com.qfedu.a_reflect.Person\");\n\t\t\n\t\t//获取所有的公共的方法，这里也会获取一些额外Object里面公开的方法\n\t\tMethod[] allPublicMethods = cls.getMethods();\n\t\tfor (Method method : allPublicMethods) {\n\t\t\tSystem.out.println(method);\n\t\t}\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\n\t\t//暴力反射\n\t\t//能够获取Person里面的private方法， 并且能够过滤掉从父类继承而来的方法\t\n\t\tMethod[] allMethods = cls.getDeclaredMethods();\n\t\tfor (Method method : allMethods) {\n\t\t\tSystem.out.println(method);\n\t\t}\n\t\t\n\t\t/*\n\t\t 通过反射机制，执行类中的成员方法 \n\t\t invoke(Object obj, Object... args);\n\t\t Object obj 这是底层调用该方法的类对象\t\n\t\t \tthe object the underlying method is invoked from\n\t\t Object... args 不定参数，是执行该放的参数列表，是Object类型\n\t\t \targs is arguments used for method call\n\t\t */\n\t\t//1.先利用反射，创建一个当前类的对象\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\tPerson p = (Person) cls.getConstructor(int.class, String.class).\n\t\t\t\tnewInstance(1, \"狗蛋\");\n\t\t\n\t\t//获取一个指定的方法，需要的参数是方法的名字字符串和参数列表，\n\t\tMethod aPublicMethod = cls.getMethod(\"sleep\", int.class);\n\t\tSystem.out.println(aPublicMethod);\n\t\t\n\t\taPublicMethod.invoke(p, 15);\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//获取一个静态方法\n\t\tMethod aPublicStaticMethod = cls.getMethod(\"eat\", null);\n\t\taPublicStaticMethod.invoke(null, null);\n\t\t\n\t\t//利用暴力反射获取一个私有化的成员方法\n\t\tMethod aPrivateMethod = cls.getDeclaredMethod(\"testPrivate\", null);\n\t\taPrivateMethod.setAccessible(true);\n\t\taPrivateMethod.invoke(p, null);\n\t\t\n\t}\n}\n\n```\n\n## 五、Field常用方法\n5.通过反射获取Class类对象里面所有的成员变量\n```java\npackage com.qfedu.a_reflect;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\n\n/**\n * 通过反射获取Class类对象里面所有的成员变量\n * Field 成员变量类\n * @author 刘晓磊\n *\n */\n\npublic class GetClassField {\n\tpublic static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException {\n\t\t//加载字节码文件，获取Class类对象\n\t\tClass cls = Class.forName(\"com.qfedu.a_reflect.Person\");\n\n\t\t//获取所有用public修饰的成员变量\n\t\tField[] allPublicFields = cls.getFields();\n\n\t\tfor (Field field : allPublicFields) {\n\t\t\tSystem.out.println(field);\n\t\t}\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//暴力反射，获取私有化成员变量\n\t\tField[] allFields = cls.getDeclaredFields();\n\t\tfor (Field field : allFields) {\n\t\t\tSystem.out.println(field);\n\t\t}\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//获取一个公开的成员变量\n\t\tField aPublicField = cls.getField(\"test\");\n\t\tSystem.out.println(aPublicField);\n\n\t\t\n\t\t//set方法\n\t\t//set(Oject obj, Object value);\n\t\t//第一个参数: 要操作的是哪一个对象里面的成员变量\n\t\t//第二个参数: 需要设置的值\n\t\t\n\t\t//首先获得对象，然后调用set方法\n\t\tPerson p = (Person) cls.getConstructor(int.class, String.class).\n\t\t\t\tnewInstance(1, \"狗蛋\");\n\t\taPublicField.set(p, 20);\n\t\t\n\t\tSystem.out.println(p.test);\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//静态的\n\t\tField aStaticField = cls.getField(\"testStatic\");\n\t\tSystem.out.println(aStaticField);\n\t\taStaticField.set(null, 20);\n\t\tSystem.out.println(Person.testStatic);\n\t\t\n\t\t//暴力反射：私有化的\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\tField aPrivateField = cls.getDeclaredField(\"id\");\n\t\tSystem.out.println(aPrivateField);\n\t\taPrivateField.setAccessible(true);\n\t\taPrivateField.set(p, 10);\n\t\tSystem.out.println(p.getId());\n\t\n\t}\n}\n```\n\n\n## 总结\n- 反射：\n  一个Java文件，编译之后生成的.class文件，程序运行时加载到内存中，会保存在内存的【代码区】，而这个.class字节码文件，会对应生成一个Class类对象，借助于Class类对象，可以完成一系列反射操作\n  \n  - 获取Class类对象的方式：\n      1.Class.forName(\"完整的类名\"); 最常用！！！\n      2.已知类名.class;\n      3.对应类的类对象.getClass();\n  \n  - Constructor \n      getConstructors();\n      getDeclaredConstructors();\n      getConstructor(Class... parameterTypes);\n          例如：getConstructor(int.class, String.class);\n      getDeclaredConstructor(Class... parameterTypes);\n      Constructor的类对象.newInstance(Object... args);\n  - Method\n      invoke(Object obj, Object... args);\n  - Field\n      set(Object obj, Object value);\n      \n  - 设置权限的方式：\n      setAccessible(boolean b);\n      \n  - 反射和单例类的一个平衡\n      一个类如果是单例类，一般不会采用反射的方式去暴力获取该类的构造方法，不符合单例的机制\n",[[1565415150712,["GJX@GJXAIOU",[[1,56,"**"],[1,179,"**"]],[56,179],[56,183]]],[1565415160514,["GJX@GJXAIOU",[[-1,92,"问题"]],[94,94],[92,92]]],[1565415161906,["GJX@GJXAIOU",[[1,92,"d"]],[92,92],[93,93]]],[1565415161946,["GJX@GJXAIOU",[[1,92," "]],[93,93],[94,94]]],[1565415162612,["GJX@GJXAIOU",[[1,94,"uixang"]],[94,94],[100,100]]],[1565415164488,["GJX@GJXAIOU",[[-1,92," duixang"]],[100,100],[92,92]]],[1565415165615,["GJX@GJXAIOU",[[1,92,"文件"]],[92,92],[94,94]]],[1565416193107,["GJX@GJXAIOU",[[-1,4409,"-------------------------"]],[4389,4414],[4389,4389]]],[1565416197942,["GJX@GJXAIOU",[[-1,4902,"------------------"]],[4876,4894],[4876,4876]]],[1565416223431,["GJX@GJXAIOU",[[1,5980,"\n"]],[5979,5979],[5980,5980]]],[1565416819566,["GJX@GJXAIOU",[[-1,5520,"-------------"]],[5500,5513],[5500,5500]]],[1565416998497,["GJX@GJXAIOU",[[1,3517,"\n"]],[3516,3516],[3517,3517]]],[1565416998641,["GJX@GJXAIOU",[[1,3518,"\n"]],[3517,3517],[3518,3518]]],[1565416998799,["GJX@GJXAIOU",[[1,3519,"\n"]],[3518,3518],[3519,3519]]],[1565416999119,["GJX@GJXAIOU",[[1,3520,"\n"]],[3519,3519],[3520,3520]]],[1565417008455,["GJX@GJXAIOU",[[-1,3520,"\n"]],[3518,3518],[3517,3517]]],[1565417008625,["GJX@GJXAIOU",[[-1,3519,"\n"]],[3517,3517],[3516,3516]]],[1565417010002,["GJX@GJXAIOU",[[-1,3518,"\n"]],[3517,3517],[3516,3516]]],[1565417010479,["GJX@GJXAIOU",[[-1,3515,"法"]],[3516,3516],[3515,3515]]],[1565417012221,["GJX@GJXAIOU",[[1,3515,"法"]],[3515,3515],[3516,3516]]],[1565417027087,["GJX@GJXAIOU",[[1,5969,"\n"]],[5967,5967],[5968,5968]]],[1565417027218,["GJX@GJXAIOU",[[1,5970,"\n"]],[5968,5968],[5969,5969]]],[1565417027351,["GJX@GJXAIOU",[[1,5971,"\n"]],[5969,5969],[5970,5970]]],[1565417029393,["GJX@GJXAIOU",[[1,5969,"****"]],[5969,5969],[5971,5971]]],[1565417038204,["GJX@GJXAIOU",[[1,5971,"至此：上面除了Person"]],[5971,5971],[5984,5984]]],[1565417038242,["GJX@GJXAIOU",[[1,5978," "]],[5984,5984],[5985,5985]]],[1565417039083,["GJX@GJXAIOU",[[1,5985,"类"]],[5985,5985],[5986,5986]]],[1565417039120,["GJX@GJXAIOU",[[1,5985," "]],[5986,5986],[5987,5987]]],[1565417055647,["GJX@GJXAIOU",[[1,5987,"之外所有代码的整理精简版如下"]],[5987,5987],[6001,6001]]],[1565417060655,["GJX@GJXAIOU",[[1,6004,"```java"]],[6004,6004],[6011,6011]]],[1565417060724,["GJX@GJXAIOU",[[1,6013,"\n"]],[6011,6011],[6012,6012]]],[1565417060841,["GJX@GJXAIOU",[[1,6014,"\n"]],[6012,6012],[6013,6013]]],[1565417061078,["GJX@GJXAIOU",[[1,6015,"\n"]],[6013,6013],[6014,6014]]],[1565417062048,["GJX@GJXAIOU",[[1,6014,"```"]],[6014,6014],[6017,6017]]],[1565418611137,["GJX@GJXAIOU",[[1,6012,"/**\n * @author GJXAIOU\n * @create 2019-08-10-13:56\n */\npublic class ReflectPractice {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        // 1.获取class类对象\n        Class person = Class.forName(\"entity.Person\");\n\n        // 2.获取具体的构造方法\n        // 获取无参构造方法\n        Constructor constructor = person.getConstructor();\n        // 获取带有参数的构造方法\n        Constructor constructor1 = person.getConstructor(int.class,String.class);\n        // 获取全部构造方法（非私有的）\n        Constructor[] constructors = person.getConstructors();\n        for (Constructor constructor2 : constructors) {\n            System.out.println(constructor);\n        }\n\n        // 3.使用构造方法构建类对象,默认是Object类型，需要强转\n        Person person1 = (Person) constructor.newInstance();\n        Person person2 = (Person) constructor1.newInstance(2, \"张三\");\n\n        // 4.使用成员变量和成员方法\n        System.out.println(person1.getName());\n        System.out.println(person2.getName());\n    }"]],[6012,6012],[7056,7056]]],[1565418618261,["GJX@GJXAIOU",[[1,5987,"以及暴力反射"]],[5987,5987],[5993,5993]]],[1565419149485,["GJX@GJXAIOU",[[-1,7794," * "]],[7794,7797],[7794,7794]]],[1565419149941,["GJX@GJXAIOU",[[-1,7794,"\n"]],[7794,7794],[7793,7793]]],[1565419152318,["GJX@GJXAIOU",[[-1,7812," *"]],[7812,7814],[7812,7812]]],[1565419152678,["GJX@GJXAIOU",[[-1,7812,"\n"]],[7812,7812],[7811,7811]]],[1565419155232,["GJX@GJXAIOU",[[-1,7816,"\n"]],[7816,7816],[7815,7815]]],[1565419165032,["GJX@GJXAIOU",[[-1,8376,"$$$$$$$$$$$$$$$$$$$$$$$$$$"]],[8352,8378],[8352,8352]]],[1565419177813,["GJX@GJXAIOU",[[-1,8875,"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"]],[8856,8888],[8856,8856]]]],null,"GJX@GJXAIOU"],["b6e38cd8-9c34-435d-9b0e-d78e051ed3ae",1569851797266,"---\ntags : \n- 反射\n---\n\n\n# JavaDay27 反射\n## 一、反射总结\n- 反射：\n \t**当一个Java文件编译之后，编译成一个.class文件，也就是字节码文件，当这个字节码文件【加载】到内存的方法区/代码区，JVM会根据【加载】的字节码文件内容，创建一个Class的类对象。这个Class类对象里面包含了当前字节码文件里面的所有内容**。\n \t\n \t只要我们获取到这个Class对象，就可以为所欲为！！！\n \t这个Class对象中包含了对应字节码文件的所有成员变量(Field) 所有成员方法(Method)构造方法(Constructor)。\n \t\n- 1.获取Class对象的三种方式：\n    1> **Class.forName(\"完整的类名字符串\");**\n        完整类名字符串是指 包名.类名\n    2> 类名.class;\n    3> 指定类对象.getClass();\n    \n    最常用的是Class.forName(\"完整的类名字符串\");\n    后期大量使用\n\n- 2.Constructor, Method, Field \n    都是Java反射这个包(java.lang.reflect)里面的类 \n    Constructor 是构造方法类\n    Method 是成员方法类\n    Field 是成员变量类\n        \n- 3.Constructor常用方法：\n\n返回值 | 方法名| 作用\n---|---|----\nConstructor[] | getConstructors(); |获取所有public修饰的构造方法\n  Constructor[] |getDeclaredConstructors();| 获取当前类里面所有的构造方法，包含用private修饰的构造方法\nConstructor |getConstructor(Object... paramterTyeps);|根据所需参数不同，获取指定的构造方法对象\nConstructor| getDeclaredConstructor(Object... paramterTyeps);|根据所需参数不同，获取指定的构造方法对象，包括私有化的方法\n Object | newInstance(Object... initargs); |给予确定的参数，通过反射调用构造方法，这里的参数列表是一个不定参数列表\n                    \n- 4.Method常用方法 \n\n返回值 | 方法名| 作用\n---|---|----\nMethod[]  |getMethods(); |获取当前类里面所有的public修饰的成员方法，这里或显示父类继承而来的public方法\nMethod[] | getDeclaredMethods(); |获取当前类里面的所有方法，包括private修饰的方法，但是会过滤父类继承而来的方法\nMethod  | getMethod(String methodName, Object... args);|根据方法的名字和对应的参数列表，获取指定方法\nMethod | getDeclaredMethod(String methodName, Object... args);|根据方法的名字和对应的参数列表，获取指定方法，可以获取private修饰的方法\n 无    | invoke(Object obj, Object... args);  |执行成员方法的函数，第一个参数是执行该方法的类对象，第二个参数是执行该方法需要的参数列表\n    \n- 5.Field常用方法\n\n返回值 | 方法名| 作用\n---|---|----\n Field[]  |getFields(); | 获取所有的用public修饰的成员变量\n Field[]| getDeclaredFields();| 获取所用成员变量，包括用private 修饰的成员变量\nField |getField(String fieldName);|根据成员变量的名字获取对应的成员变量\nField |getDeclaredField(String fieldName);|根据成员变量的名字获取包括private修饰在内的成员变量\n无   | set(Object obj, Object value);|设置成员变量的数值，第一个参数是调用该成员变量的对象，第二个参数是赋予数值\n    \n- 6.暴力反射赋予权限的函数\n        setAccessible(boolean )\n\n--------------------------\n\n##  二、获取Class 类 对象的三种方式   \n\n1.首先新建一个 Person 类，作为示例\n```java\npackage com.qfedu.a_reflect;\n\npublic class Person {\n\tprivate int id;\n\tprivate String name;\n\t\n\tpublic int test;\n\tpublic static int testStatic = 10;\n\t\n\tprivate Person() {}\n\t\n\tpublic Person(int id, String name) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t}\n\t\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic static void eat() {\n\t\tSystem.out.println(\"黄焖鸡米饭~~~\");\n\t}\n\t\n\tpublic void sleep(int num) {\n\t\tSystem.out.println(name + \"每天睡\" + num + \"个小时\");\n\t}\n\t\n\tpublic void game() {\n\t\tSystem.out.println(\"大吉大利，今晚吃鸡~~~\");\n\t}\n\t\n\tprivate void testPrivate() {\n\t\tSystem.out.println(\"这是一个Private修饰的私有化方法\");\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Person [id=\" + id + \", name=\" + name + \"]\";\n\t}\n}\n\n```\n\n2.通过反射获取类对象\n```java\npackage com.qfedu.a_reflect;\n\npublic class GetClassObject {\n\tpublic static void main(String[] args) throws ClassNotFoundException {\n\t\t//如果想要为所欲为，首先获取到Class类对象\n\t\t\n\t\t/*方式1：Class.forName(\"完整的类名字符串\");\n\t\t完整类名是包括    包名.类名\n\t\t*/\n\t\tClass cls1 = Class.forName(\"com.qfedu.a_reflect.Person\");\n\t\tSystem.out.println(cls1);\n\t\t\n\t\t//方式2：类名.class\n\t\tClass cls2 = Person.class;\n\t\tSystem.out.println(cls2);\n\t\t\n\t\t//方式3：通过对象获取到对应的Class类对象\n\t\tClass cls3 = new Person(1, \"逗比\").getClass();\n\t\tSystem.out.println(cls3);\n\t\t\n\t\tSystem.out.println(cls1 == cls2);\n\t\tSystem.out.println(cls2 == cls3);\n\t\tSystem.out.println(cls1 == cls3);\n\t}\n}\n\n```\n\n\n## 三、Constructor常用方法\n\n通过Class类对象获取当前类的构造方法并且调用\n```java\npackage com.qfedu.a_reflect;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\npublic class GetClassConstructor {\n\tpublic static void main(String[] args) throws \n\tClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n/*\n 【加载】指定类的字节码文件，获取对应的Class对象\n\t下面的语句做了两件事情：\n\t1. 让JVM根据类名，加载Person.java对应的字节码文件Person.class 到内存的代码区\n\t2. 把加载到内存代码区Person.class 字节码文件生成一个Class类对象返回\n*/\n\t\tClass cls = Class.forName(\"com.qfedu.a_reflect.Person\");\n\t\t\n\t\t\n\t//Constructor 这是构造方法的类\n\t//第一种：可以通过Class获取所有的【非私有化构造方法】，方法是 getConstuctors();\n\t\tConstructor[] constructors = cls.getConstructors();\n\t\t\n\t\tfor (Constructor constructor : constructors) {\n\t\t\tSystem.out.println(constructor);\n\t\t}\n\t\tSystem.out.println(\"---------------------------\");\n\n\n\t//第二种：暴力反射（获取所有构造方法，不管是不是私有化）\n\t\tConstructor[] allConstructors = cls.getDeclaredConstructors();\n\t\tfor (Constructor constructor : allConstructors) {\n\t\t\tSystem.out.println(constructor);\n\t\t}\n\t\t\n\t//第三种方法：\n\t\t/*\n\t\t 根据参数获取具体的构造方法 \n\t\t getConstructor(Class... parameterTypes);\n\t\t 上面括号里面是不定参数列表，表示参数的类型要求是Class类型，但是数量不限制\n\t\t 在确定数据类型的情况下，可以直接通过数据类型.class获取对应Class数据类型\n\t\t 例如：\n\t\t \tint.class String.class 这里会自动包装为Integer.class和String.class\n\t\t */\n\t\tSystem.out.println(\"----------------------------------\");\n\t\tConstructor aConstructor = cls.getConstructor(int.class, String.class);\n\t\tSystem.out.println(aConstructor);\n\t\t\n\t\t\n\n\t//☆☆☆☆根据Constructor对象创建类对象，即调用构造函数\n\n\t\t/*\n\t\t 构造方法Constructor对象获取完毕，怎么利用Constructor对象创建一个Person类对象\n\t\t newInstance(Object... initargs) \n\t\t 也是一个不定参的方法，需要的参数都是Object类型的，参数个数不确定\n\t\t */\n\t\tPerson p = (Person) aConstructor.newInstance(1, \"海洋\");//默认产生是Object对象，因此需要强转\n\t\tSystem.out.println(p.getId() + \":\" + p.getName());\n\t\tp.sleep(5);\n\t\tp.game();\n\t\tp.eat(); //如何通过反射机制，调用static修饰的成员方法，并且不报警告\n\t\t\n\n\t\t/*\n\t\t 通过暴力反射，借助于指定的参数，获取private修饰的无参构造方法 \n\t\t */\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\tConstructor privateConstructor = cls.getDeclaredConstructor(null);\n\t\tSystem.out.println(privateConstructor);\n\t\t\n\t\t//这里需要通过setAccessible(boolean ) 给予操作Private修饰方法的权限\n\t\tprivateConstructor.setAccessible(true);\n\t\tPerson p2 = (Person) privateConstructor.newInstance(null);\n\t\tp2.setId(2);\n\t\tp2.setName(\"刘德华\");\n\t\tSystem.out.println(p2);\n\t\t\n\t\t/*\n\t\t 单例和反射的共存：\n\t\t  \t在实际开发中，如果一个类是一个单例类，那么一般不会有程序猿通过反射的方式来使用这个类里面\n\t\t  \t私有化的构造方法，这违背了单例的原则\n\t\t */\n\t}\n}\n\n```\n\n**至此：上面除了 Person 类以及暴力反射之外所有代码的整理精简版如下**\n```java\n/**\n * @author GJXAIOU\n * @create 2019-08-10-13:56\n */\npublic class ReflectPractice {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        // 1.获取class类对象\n        Class person = Class.forName(\"entity.Person\");\n\n        // 2.获取具体的构造方法\n        // 获取无参构造方法\n        Constructor constructor = person.getConstructor();\n        // 获取带有参数的构造方法\n        Constructor constructor1 = person.getConstructor(int.class,String.class);\n        // 获取全部构造方法（非私有的）\n        Constructor[] constructors = person.getConstructors();\n        for (Constructor constructor2 : constructors) {\n            System.out.println(constructor);\n        }\n\n        // 3.使用构造方法构建类对象,默认是Object类型，需要强转\n        Person person1 = (Person) constructor.newInstance();\n        Person person2 = (Person) constructor1.newInstance(2, \"张三\");\n\n        // 4.使用成员变量和成员方法\n        System.out.println(person1.getName());\n        System.out.println(person2.getName());\n    }\n\n```\n\n补充：单例\n```java\npackage com.qfedu.a_reflect;\n\npublic class SingleDemo {\n\t\n\tint id;\n\t\n\t//为了判定数据，定义一个静态私有化成员变量，数据类型为该类的变量，保存上次创建的数据的类对象的首地址\n\tprivate static SingleDemo s = null;\n\t\n\t//1.私有化构造方法\n\tprivate SingleDemo(int id) {  \n\t\tthis.id = id;\n\t}\n\t\n\t//2.提供一个类外可以通过类名直接调用的，返回值为当前类对象类型的，参数为对应需要的构造方法参数，\n\t//方法名通常为getInstance，作为类外获取方式\n\tpublic static SingleDemo getInstance(int id) {\n\t\t//但我们调用这个公开的，静态方法修饰的获取类对象的这种方法时，对这个保存地址的变量进行判定\n\t\tif (null == s) {\n\t\t\ts = new SingleDemo(id);\n\t\t}\t\n\t\treturn s; //返回上次创建对象\n\t}\n}\n\n```\n\n\n## 四、Method常用方法 \n4.通过反射借助于Class类对象，获取这个类里面所有的成员方法,并且进行调用\n```java\npackage com.qfedu.a_reflect;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * 通过反射借助于Class类对象，获取这个类里面所有的成员方法\n * Method 就是成员方法类\n */\npublic class GetClassMethod {\n\tpublic static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException {\n\t\t//1.加载对应类的字节码文件，获取该类的Class类对象\n\t\tClass cls = Class.forName(\"com.qfedu.a_reflect.Person\");\n\t\t\n\t\t//获取所有的公共的方法，这里也会获取一些额外Object里面公开的方法\n\t\tMethod[] allPublicMethods = cls.getMethods();\n\t\tfor (Method method : allPublicMethods) {\n\t\t\tSystem.out.println(method);\n\t\t}\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\n\t\t//暴力反射\n\t\t//能够获取Person里面的private方法， 并且能够过滤掉从父类继承而来的方法\t\n\t\tMethod[] allMethods = cls.getDeclaredMethods();\n\t\tfor (Method method : allMethods) {\n\t\t\tSystem.out.println(method);\n\t\t}\n\t\t\n\t\t/*\n\t\t 通过反射机制，执行类中的成员方法 \n\t\t invoke(Object obj, Object... args);\n\t\t Object obj 这是底层调用该方法的类对象\t\n\t\t \tthe object the underlying method is invoked from\n\t\t Object... args 不定参数，是执行该放的参数列表，是Object类型\n\t\t \targs is arguments used for method call\n\t\t */\n\t\t//1.先利用反射，创建一个当前类的对象\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\tPerson p = (Person) cls.getConstructor(int.class, String.class).\n\t\t\t\tnewInstance(1, \"狗蛋\");\n\t\t\n\t\t//获取一个指定的方法，需要的参数是方法的名字字符串和参数列表，\n\t\tMethod aPublicMethod = cls.getMethod(\"sleep\", int.class);\n\t\tSystem.out.println(aPublicMethod);\n\t\t\n\t\taPublicMethod.invoke(p, 15);\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//获取一个静态方法\n\t\tMethod aPublicStaticMethod = cls.getMethod(\"eat\", null);\n\t\taPublicStaticMethod.invoke(null, null);\n\t\t\n\t\t//利用暴力反射获取一个私有化的成员方法\n\t\tMethod aPrivateMethod = cls.getDeclaredMethod(\"testPrivate\", null);\n\t\taPrivateMethod.setAccessible(true);\n\t\taPrivateMethod.invoke(p, null);\n\t\t\n\t}\n}\n\n```\n\n## 五、Field常用方法\n5.通过反射获取Class类对象里面所有的成员变量\n```java\npackage com.qfedu.a_reflect;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\n\n/**\n * 通过反射获取Class类对象里面所有的成员变量\n * Field 成员变量类\n * @author 刘晓磊\n *\n */\n\npublic class GetClassField {\n\tpublic static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException {\n\t\t//加载字节码文件，获取Class类对象\n\t\tClass cls = Class.forName(\"com.qfedu.a_reflect.Person\");\n\n\t\t//获取所有用public修饰的成员变量\n\t\tField[] allPublicFields = cls.getFields();\n\n\t\tfor (Field field : allPublicFields) {\n\t\t\tSystem.out.println(field);\n\t\t}\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//暴力反射，获取私有化成员变量\n\t\tField[] allFields = cls.getDeclaredFields();\n\t\tfor (Field field : allFields) {\n\t\t\tSystem.out.println(field);\n\t\t}\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//获取一个公开的成员变量\n\t\tField aPublicField = cls.getField(\"test\");\n\t\tSystem.out.println(aPublicField);\n\n\t\t\n\t\t//set方法\n\t\t//set(Oject obj, Object value);\n\t\t//第一个参数: 要操作的是哪一个对象里面的成员变量\n\t\t//第二个参数: 需要设置的值\n\t\t\n\t\t//首先获得对象，然后调用set方法\n\t\tPerson p = (Person) cls.getConstructor(int.class, String.class).\n\t\t\t\tnewInstance(1, \"狗蛋\");\n\t\taPublicField.set(p, 20);\n\t\t\n\t\tSystem.out.println(p.test);\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\t\n\t\t//静态的\n\t\tField aStaticField = cls.getField(\"testStatic\");\n\t\tSystem.out.println(aStaticField);\n\t\taStaticField.set(null, 20);\n\t\tSystem.out.println(Person.testStatic);\n\t\t\n\t\t//暴力反射：私有化的\n\t\tSystem.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\");\n\t\tField aPrivateField = cls.getDeclaredField(\"id\");\n\t\tSystem.out.println(aPrivateField);\n\t\taPrivateField.setAccessible(true);\n\t\taPrivateField.set(p, 10);\n\t\tSystem.out.println(p.getId());\n\t\n\t}\n}\n```\n\n\n## 总结\n- 反射：\n  一个Java文件，编译之后生成的.class文件，程序运行时加载到内存中，会保存在内存的【代码区】，而这个.class字节码文件，会对应生成一个Class类对象，借助于Class类对象，可以完成一系列反射操作\n  \n  - 获取Class类对象的方式：\n      1.Class.forName(\"完整的类名\"); 最常用！！！\n      2.已知类名.class;\n      3.对应类的类对象.getClass();\n  \n  - Constructor \n      getConstructors();\n      getDeclaredConstructors();\n      getConstructor(Class... parameterTypes);\n          例如：getConstructor(int.class, String.class);\n      getDeclaredConstructor(Class... parameterTypes);\n      Constructor的类对象.newInstance(Object... args);\n  - Method\n      invoke(Object obj, Object... args);\n  - Field\n      set(Object obj, Object value);\n      \n  - 设置权限的方式：\n      setAccessible(boolean b);\n      \n  - 反射和单例类的一个平衡\n      一个类如果是单例类，一般不会采用反射的方式去暴力获取该类的构造方法，不符合单例的机制\n",[[1569851788765,["GJX@GJXAIOU",[[-1,9736," * @author 刘晓磊"]],[9736,9750],[9736,9736]]],[1569851789101,["GJX@GJXAIOU",[[-1,9736,"\n"]],[9736,9736],[9735,9735]]]],null,"GJX@GJXAIOU"]]}