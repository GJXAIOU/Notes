{"compress":true,"commitItems":[["aac0cd40-785d-4a67-a929-115ea7df09c2",1565244489750,"## Servlet实现记录你是当前第几个访问者\n\n注意事项：\n 1\\. 防止线程安全问题\n 2\\. 在使用同步代码块选择锁对象，通常会使用当前servlet程序对象\n\n## ServletConfig对象\n\n <servlet>\n <servlet-name>ConfigServlet</servlet-name>\n <servlet-class>b_servletconfig.ConfigServlet</servlet-class>\n <!-- servlet程序的初始化参数 -->\n <init-param>\n <param-name>user</param-name>\n <param-value>root</param-value>\n </init-param>\n <init-param>\n <param-name>password</param-name>\n <param-value>123456</param-value>\n </init-param>\n </servlet>\n\n在web.xml文件中利用<init-param>标签来定义servlet初始化参数，主要包含两个子标签\n<param-name> <param-value>\n​\n当Tomcat服务器程序启动，WEB容器在创建servlet时，会把初始化参数封装到ServletConfig对象中，\n这个ServletConfig对象，会作为Servlet对象的初始化方法init的参数\n​\n【注意】\n 在一个Servlet 对应一个ServletConfig\n\n## ServletContext\n\n表示当前整个WEB应用，一个WEB应用有且只有一个ServletContext对象\n​\n1 获取WEB应用的路径\n ServletContext context = this.getServletContext();\n context.getContextPath();\n request.getContextPath();\n​\n2.WEB应用的全局参数\n <!-- 这是针对整个WEB项目的初始化参数 -->\n <context-param>\n <param-name>AAA</param-name>\n <param-value>aaa</param-value>\n </context-param>\n context.getInitParameter(Stirng paramName);\n\n3.ServletContext 是一个域对象\n​\n request域，session域\n​\n 可以利用ServletContext域对象特征，完成在整个WEB项目中的数据共享传递\n 不单单能传递基本数据类型，也可以传递类对象类型\n setAttribute(String name, Object value);\n Object getAttribute(String name);\n​\n4.转发和重定向\n WEB服务器接受到客户端的请求之后，让Tomcat服务器去调用另一个WEB资源，这称之为转发\n\n request域转发\n request.setAttribute(String name, Object value);\n //转发的方法\n req.getRequestDispatcher(String uri).forward(HttpServletRequest req, HttpServletResponse resp);\n uri：服务器端要访问别的WEB资源路径，这里是服务器端的地址，一般用 / 开头，表示WEB项目的根目录\n HttpServletRequest req: 原本用户请求当前页面的request对象\n HttpServletResponse resp: 原本用户请求当前页面生成对应的response对象\n\n 重定向\n response.sendRedirect(String url);\n 这个URL是相对于webapps的，是提供给浏览器使用的URL\n\n 推荐写法是：\n response.sendRedirect(request.getContextPath() + \"重定向地址\");\n\n 【注意】\n 在重定向的情况下，request域不能使用\n\n## 会话控制\n\n1.  生活的中的会话  我: 中午吃了吗？您嘞？  海洋：吃了，吃得炸酱面  我：巧了，我们吃的饺子  海洋：什么馅儿  我：韭菜猪肉！！！\n\n2.  软件程序中的会话  一次会话：  打开浏览器 -> 访问服务器上的内容 -> 关闭浏览器\n\n    登录业务场景：  打开浏览器 -> 访问登录页面 -> 输入 用户名 密码 验证码 -> 发送给服务器 -> 服务器验证消息  -> 返回给浏览器 -> 浏览器加载主页\n\n    发现：在百度首页登录了用户名，在所有的百度服务的页面下都是一个登录的状态\n\n    购物车场景：  在手机淘宝APP选择了一个商品，加入购物车\n\n    打开浏览器 -> 淘宝网 -> 登录账号 -> 查看购物车，也可以看到手机APP添加商品\n    ​\n    这里的购物车数据在那里保存？？？\n\n    会话控制技术：  管理 浏览器客户端 和 服务器 之间进行会话过程生产的会话数据\n\n## 会话控制技术\n\nCookie技术： 会话数据保存在浏览器客户端，也就是用户本地\nSession技术：会话数据保存在服务器上\n\n### Cookie技术\n\n核心方法：\n 1\\. 创建Cookie对象\n Cookie(String name, String value); \n 2\\. 设置Cookie\n setValue(String value) //通过name来设置Cookie的Value\n setPath(String path); //设置Cookie的有效范围 \n setMaxAge(int time);     //设置最大有效时间\n 3\\. 发送Cookie到浏览器保存\n response.addCookie(Cookie c); //发送Cookie给浏览器\n 4\\. 服务器接受浏览器访问时带来的Cookie数据\n Cookie[] request.getCookies();\n\nCookie有一定的局限性\n 1\\. 限制数据类型 必须是String\n 2\\. 不能保存中文\n 3\\. Cookie保存数据容量较小，只有4KB\n\n 如果要保存4KB以上数据，或者要保存中文数据，就不能使用Cookie技术，只能用Session\n\n 【但是有一个前提】\n 如果浏览器没有打开Cookie功能， Session也无法使用\n\n Sesion的特点：\n 会话数据保存在服务上，可以生成一个临时或者永久的temp文件\n\n### Session技术\n\nHttpSession\n 1\\. 获取Session对象\n HttpSession getSession();\n HttpSession getSession(boolean create);\n\n 2\\. 设置Session对象\n void setMaxInactiveInterval(int interval); //设置Session 的有效时间\n void invalidate(); //销毁Session\n String getId();    //获取Session的ID\n\n 3\\. Session也是一个域对象，这里可以保存数据属性到Session\n void setAttribute(String name, Object value); //设置Session里面保存是会话数据内容，可以保存一个对象\n Object getAttribute(String name); //获取到Session里面数据\n void removeAttribute(String name); //清空Session里面的数据",[[1565244449147,["GJX@GJXAIOU",[[1,85,"\n"]],[84,84],[85,85]]],[1565244449261,["GJX@GJXAIOU",[[1,86,"\n"]],[85,85],[86,86]]],[1565244449394,["GJX@GJXAIOU",[[1,87,"\n"]],[86,86],[87,87]]],[1565244449498,["GJX@GJXAIOU",[[1,88,"\n"]],[87,87],[88,88]]],[1565244449627,["GJX@GJXAIOU",[[1,89,"\n"]],[88,88],[89,89]]],[1565244449750,["GJX@GJXAIOU",[[1,90,"\n"]],[89,89],[90,90]]],[1565244449997,["GJX@GJXAIOU",[[1,91,"\n"]],[90,90],[91,91]]],[1565244450154,["GJX@GJXAIOU",[[1,92,"\n"]],[91,91],[92,92]]],[1565244454016,["GJX@GJXAIOU",[[1,85,"·"],[-1,2487,"   "],[1,2490,"   "],[-1,3085," "],[1,3086," "]],[85,85],[86,86]]],[1565244454407,["GJX@GJXAIOU",[[1,86,"··"]],[86,86],[88,88]]],[1565244455669,["GJX@GJXAIOU",[[-1,85,"···"]],[88,88],[85,85]]],[1565244456972,["GJX@GJXAIOU",[[1,85,"```"]],[85,85],[88,88]]],[1565244456999,["GJX@GJXAIOU",[[1,88,"language\n```\n"]],[88,88],[88,96]]],[1565244457836,["GJX@GJXAIOU",[[-1,88,"language"],[1,96,"j"]],[88,96],[89,89]]],[1565244458278,["GJX@GJXAIOU",[[1,89,"ava"]],[89,89],[92,92]]],[1565244458390,["GJX@GJXAIOU",[[1,93,"\n"]],[92,92],[93,93]]],[1565244471838,["GJX@GJXAIOU",[[1,93,"package a_thread;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * 统计你是当前页面的第几个访问者\n * 利用一个计数器，每一次有一个人访问就  + 1\n */\npublic class VisitedCount extends HttpServlet {\n    int count = 1;\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n\t\t/*int count = 1;\n\t\t局部变量，每一次调用doGet方法，都会重新创建一个count变量, 无法作为计数器*/\n        //告诉浏览器解析数据的方式和使用的字符集\n        resp.setContentType(\"text/html;charset=utf-8\");\n        //服务器发送数据使用的字符集\n        resp.setCharacterEncoding(\"utf-8\");\n\t\t\n        synchronized (this) { \n\t\t\t/*\n\t\t\t 这里因为操作的了共享资源计数器count，为了避免线程的安全问题，这里采用加锁的方式(同步代码块)\n\t\t\t锁对象用this，this表示当前Servlet程序类VisitedCount的对象，因为在Tomcat服务器\n\t\t\t上当VisitedCount对象被创建和init之后，不会在创建新的VisitedCount对象，满足锁对象\n\t\t\t的基本要求\n\t\t\t */\n            resp.getWriter().write(\"你是第\" + count + \"访问者\");\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            count++;\n        }\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n"]],[93,93],[1498,1498]]],[1565244476626,["GJX@GJXAIOU",[[-1,1510,"\n"]],[1509,1509],[1508,1508]]],[1565244476754,["GJX@GJXAIOU",[[-1,1509,"\n"]],[1508,1508],[1507,1507]]],[1565244476914,["GJX@GJXAIOU",[[-1,1508,"\n"]],[1507,1507],[1506,1506]]],[1565244477003,["GJX@GJXAIOU",[[-1,1507,"\n"]],[1506,1506],[1505,1505]]],[1565244477154,["GJX@GJXAIOU",[[-1,1506,"\n"]],[1505,1505],[1504,1504]]],[1565244506899,["GJX@GJXAIOU",[[-1,3349,"  "],[-1,3439,"  "],[-1,3481,"  "],[-1,3514," "],[-1,3517," "],[-1,3565,"  "],[-1,3569,"  "],[-1,3591,"  "]],[3351,3635],[3349,3621]]],[1565244529612,["GJX@GJXAIOU",[[1,1525,"zai"]],[1525,1525],[1528,1528]]],[1565244530345,["GJX@GJXAIOU",[[-1,1525,"zai"]],[1528,1528],[1525,1525]]],[1565244533662,["GJX@GJXAIOU",[[1,1525,"在web"]],[1525,1525],[1529,1529]]],[1565244533692,["GJX@GJXAIOU",[[1,1526," "]],[1529,1529],[1530,1530]]],[1565244537119,["GJX@GJXAIOU",[[1,1530,".xml中"]],[1530,1530],[1535,1535]]],[1565244537147,["GJX@GJXAIOU",[[1,1534," "]],[1535,1535],[1536,1536]]],[1565244543976,["GJX@GJXAIOU",[[1,1536,"补充一下信息"]],[1536,1536],[1542,1542]]],[1565244546077,["GJX@GJXAIOU",[[-1,1538,"一下"]],[1540,1540],[1538,1538]]],[1565244548233,["GJX@GJXAIOU",[[1,1538,"以下"]],[1538,1538],[1540,1540]]],[1565244552022,["GJX@GJXAIOU",[[1,1542,"："]],[1542,1542],[1543,1543]]],[1565244554218,["GJX@GJXAIOU",[[1,1544,"\n"]],[1543,1543],[1544,1544]]],[1565244555390,["GJX@GJXAIOU",[[1,1545,"\n"]],[1544,1544],[1545,1545]]],[1565244556149,["GJX@GJXAIOU",[[1,1545,"···"]],[1545,1545],[1548,1548]]],[1565244557266,["GJX@GJXAIOU",[[-1,1545,"···"]],[1548,1548],[1545,1545]]],[1565244558219,["GJX@GJXAIOU",[[1,1545,"```"]],[1545,1545],[1548,1548]]],[1565244558248,["GJX@GJXAIOU",[[1,1548,"language\n```\n"]],[1548,1548],[1548,1556]]],[1565244559263,["GJX@GJXAIOU",[[-1,1548,"language"],[1,1556,"x"]],[1548,1556],[1549,1549]]],[1565244560003,["GJX@GJXAIOU",[[1,1549,"ml"]],[1549,1549],[1551,1551]]],[1565244560514,["GJX@GJXAIOU",[[1,1552,"\n"]],[1551,1551],[1552,1552]]],[1565244564578,["GJX@GJXAIOU",[[-1,1559,"<servlet>\n <servlet-name>ConfigServlet</servlet-name>\n <servlet-class>b_servletconfig.ConfigServlet</servlet-class>\n <!-- servlet程序的初始化参数 -->\n <init-param>\n <param-name>user</param-name>\n <param-value>root</param-value>\n </init-param>\n <init-param>\n <param-name>password</param-name>\n <param-value>123456</param-value>\n </init-param>\n </servlet>"]],[1559,1904],[1559,1559]]],[1565244566452,["GJX@GJXAIOU",[[1,1552,"<servlet>\n <servlet-name>ConfigServlet</servlet-name>\n <servlet-class>b_servletconfig.ConfigServlet</servlet-class>\n <!-- servlet程序的初始化参数 -->\n <init-param>\n <param-name>user</param-name>\n <param-value>root</param-value>\n </init-param>\n <init-param>\n <param-name>password</param-name>\n <param-value>123456</param-value>\n </init-param>\n </servlet>"]],[1552,1552],[1897,1897]]],[1565244619953,["GJX@GJXAIOU",[[-1,1905,"\n"]],[1905,1905],[1904,1904]]],[1565244620120,["GJX@GJXAIOU",[[-1,1903," "]],[1904,1904],[1903,1903]]],[1565244620572,["GJX@GJXAIOU",[[-1,1903,"\n"]],[1903,1903],[1902,1902]]],[1565244620965,["GJX@GJXAIOU",[[-1,1902,"\n"]],[1902,1902],[1901,1901]]],[1565244729246,["GJX@GJXAIOU",[[-1,2043,"\n"]],[2044,2044],[2043,2043]]],[1565245042227,["GJX@GJXAIOU",[[1,2125,"\n"]],[2124,2124],[2125,2125]]],[1565245042373,["GJX@GJXAIOU",[[1,2126,"\n"]],[2125,2125],[2126,2126]]],[1565245042506,["GJX@GJXAIOU",[[1,2127,"\n"]],[2126,2126],[2127,2127]]],[1565245045215,["GJX@GJXAIOU",[[1,2125,"···"]],[2125,2125],[2128,2128]]],[1565245045954,["GJX@GJXAIOU",[[-1,2125,"···"]],[2128,2128],[2125,2125]]],[1565245046293,["GJX@GJXAIOU",[[-1,2127,"\n"]],[2125,2125],[2124,2124]]],[1565245047595,["GJX@GJXAIOU",[[1,2124,"```"]],[2124,2124],[2127,2127]]],[1565245047623,["GJX@GJXAIOU",[[1,2127,"language\n```\n"]],[2127,2127],[2127,2135]]],[1565245050068,["GJX@GJXAIOU",[[-1,2127,"language"],[1,2135,"j"]],[2127,2135],[2128,2128]]],[1565245050523,["GJX@GJXAIOU",[[1,2128,"ava"]],[2128,2128],[2131,2131]]],[1565245050733,["GJX@GJXAIOU",[[1,2132,"\n"]],[2131,2131],[2132,2132]]],[1565245053832,["GJX@GJXAIOU",[[1,2132,"package b_servletconfig;\n\nimport java.io.IOException;\nimport java.util.Enumeration;\n\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class ConfigServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        //因为获取的是当前ConfigServlet程序的ServletConfig对象,因此使用this调用getServletConfig()方法\n        ServletConfig config = this.getServletConfig();\n\n        //获取当前Servlet程序的名字\n        System.out.println(config.getServletName());\n\t\t\n\t\t/*\n\t\t<init-param>\n\t    \t<param-name>user</param-name>\n\t    \t<param-value>root</param-value>\n\t    </init-param>\n\t    <init-param>\n\t    \t<param-name>password</param-name>\n\t    \t<param-value>123456</param-value>\n\t    </init-param>\n\t\t */\n        //根据param-name获取对应的param-value值\n        String value = config.getInitParameter(\"user\");\n        System.out.println(value);\n\t\t\n        //获取到所有初始化参数的枚举类型\n        Enumeration<String> names = config.getInitParameterNames();\n        while (names.hasMoreElements()) {\n            String name = names.nextElement();\n            System.out.println(name + \":\" + config.getInitParameter(name));\n        }\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n"]],[2132,2132],[3658,3658]]],[1565245061466,["GJX@GJXAIOU",[[1,3666,"\n"]],[3662,3662],[3663,3663]]],[1565245063235,["GJX@GJXAIOU",[[1,3663,"yongyu"]],[3663,3663],[3669,3669]]],[1565245064234,["GJX@GJXAIOU",[[-1,3663,"yongyu"]],[3669,3669],[3663,3663]]],[1565245071614,["GJX@GJXAIOU",[[1,3663,"用于获取参数值的"]],[3663,3663],[3671,3671]]],[1565245072404,["GJX@GJXAIOU",[[-1,3670,"的"]],[3671,3671],[3670,3670]]],[1565245076076,["GJX@GJXAIOU",[[1,3670,"以及属性；"]],[3670,3670],[3675,3675]]],[1565245755107,["GJX@GJXAIOU",[[-1,4071,"​"]],[4072,4072],[4071,4071]]],[1565245755898,["GJX@GJXAIOU",[[-1,4071,"\n"]],[4071,4071],[4070,4070]]],[1565245759810,["GJX@GJXAIOU",[[-1,4079,"域，"]],[4079,4081],[4079,4079]]],[1565245761920,["GJX@GJXAIOU",[[1,4079,"，"]],[4079,4079],[4080,4080]]],[1565245765080,["GJX@GJXAIOU",[[1,4088,"夜视仪"]],[4088,4088],[4091,4091]]],[1565245766002,["GJX@GJXAIOU",[[-1,4087,"域夜视仪"]],[4091,4091],[4087,4087]]],[1565245767237,["GJX@GJXAIOU",[[1,4087,"也会是"]],[4087,4087],[4090,4090]]],[1565245767268,["GJX@GJXAIOU",[[1,4087," "]],[4090,4090],[4091,4091]]],[1565245767833,["GJX@GJXAIOU",[[-1,4089,"会是"]],[4091,4091],[4089,4089]]],[1565245770845,["GJX@GJXAIOU",[[1,4089,"是域对象"]],[4089,4089],[4093,4093]]],[1565245836653,["GJX@GJXAIOU",[[1,4215,"   "]],[4215,4215],[4218,4218]]],[1565245877899,["GJX@GJXAIOU",[[1,4256,"\n"]],[4255,4255],[4256,4256]]],[1565245901187,["GJX@GJXAIOU",[[1,4256,"转发会携带数据，但是重定向没有携带数据；"]],[4256,4256],[4276,4276]]],[1565245911529,["GJX@GJXAIOU",[[1,4326,"\n"]],[4325,4325],[4326,4326]]],[1565246301332,["GJX@GJXAIOU",[[1,4327,"-"]],[4327,4327],[4328,4328]]],[1565246301484,["GJX@GJXAIOU",[[1,4329," "]],[4328,4328],[4329,4329]]],[1565246304444,["GJX@GJXAIOU",[[1,4342,"  - "]],[4342,4342],[4346,4346]]],[1565246307149,["GJX@GJXAIOU",[[1,4405,"  - "]],[4405,4405],[4409,4409]]],[1565246335658,["GJX@GJXAIOU",[[-1,4395," //"]],[4395,4398],[4395,4395]]],[1565246354953,["GJX@GJXAIOU",[[1,4503,"  - "],[1,4557,"  - "],[1,4602,"   -"]],[4503,4654],[4507,4666]]],[1565246355490,["GJX@GJXAIOU",[[1,4505,"  "],[1,4563,"  "],[1,4610,"  "]],[4507,4666],[4509,4672]]],[1565246355674,["GJX@GJXAIOU",[[1,4507,"  "],[1,4567,"  "],[1,4614,"  "]],[4509,4672],[4511,4678]]],[1565246365716,["GJX@GJXAIOU",[[-1,4395,"转发的方法"]],[4395,4400],[4395,4395]]],[1565246369720,["GJX@GJXAIOU",[[1,4401,"转发的方法 ·"]],[4401,4401],[4408,4408]]],[1565246371169,["GJX@GJXAIOU",[[-1,4407,"·"]],[4408,4408],[4407,4407]]],[1565246371677,["GJX@GJXAIOU",[[1,4407,"`"]],[4407,4407],[4408,4408]]],[1565246373091,["GJX@GJXAIOU",[[1,4503,"`"]],[4503,4503],[4504,4504]]],[1565246382083,["GJX@GJXAIOU",[[1,4684,"- "]],[4684,4684],[4686,4686]]],[1565246881090,["GJX@GJXAIOU",[[-1,4868,"1.  生活的中的会话  我: 中午吃了吗？您嘞？  海洋：吃了，吃得炸酱面  我：巧了，我们吃的饺子  海洋：什么馅儿  我：韭菜猪肉！！！"]],[4868,4939],[4868,4868]]],[1565246881585,["GJX@GJXAIOU",[[-1,4869,"\n"]],[4868,4868],[4867,4867]]],[1565246881963,["GJX@GJXAIOU",[[-1,4868,"\n"]],[4867,4867],[4866,4866]]],[1565246885123,["GJX@GJXAIOU",[[-1,4868,"2.  "]],[4868,4872],[4868,4868]]],[1565246885733,["GJX@GJXAIOU",[[1,4868,"1 "]],[4868,4868],[4869,4869]]],[1565246886395,["GJX@GJXAIOU",[[1,4869,"."]],[4869,4869],[4870,4870]]],[1565246974371,["GJX@GJXAIOU",[[-1,4917,"  "]],[4917,4919],[4917,4917]]],[1565247173420,["GJX@GJXAIOU",[[-1,5075,"\n"]],[5075,5075],[5074,5074]]],[1565247177001,["GJX@GJXAIOU",[[-1,5122,"  ​"]],[5125,5125],[5122,5122]]],[1565247177544,["GJX@GJXAIOU",[[-1,5122,"\n"]],[5122,5122],[5121,5121]]],[1565247208501,["GJX@GJXAIOU",[[-1,5274,"\\"],[1,5275," "]],[5274,5275],[5274,5275]]],[1565247209489,["GJX@GJXAIOU",[[-1,5327,"\\"],[1,5328," "]],[5327,5328],[5327,5328]]],[1565247209936,["GJX@GJXAIOU",[[-1,5466,"\\"],[1,5467," "]],[5466,5467],[5466,5467]]],[1565247210274,["GJX@GJXAIOU",[[-1,5532,"\\"],[1,5533," "]],[5532,5533],[5532,5533]]],[1565247210560,["GJX@GJXAIOU",[[-1,5607,"\\"],[1,5608," "]],[5607,5608],[5607,5608]]],[1565247210906,["GJX@GJXAIOU",[[-1,5629,"\\"],[1,5630," "]],[5629,5630],[5629,5630]]],[1565247211178,["GJX@GJXAIOU",[[-1,5641,"\\"],[1,5642," "]],[5641,5642],[5641,5642]]],[1565247211449,["GJX@GJXAIOU",[[-1,5835,"\\"],[1,5836," "]],[5835,5836],[5835,5836]]],[1565247212145,["GJX@GJXAIOU",[[-1,5921,"\\"],[1,5922," "]],[5921,5922],[5921,5922]]],[1565247212645,["GJX@GJXAIOU",[[-1,6068,"\\"],[1,6069," "]],[6068,6069],[6068,6069]]],[1565247213788,["GJX@GJXAIOU",[[-1,34,"\\"],[1,35," "]],[34,35],[34,35]]],[1565247214220,["GJX@GJXAIOU",[[-1,48,"\\"],[1,49," "]],[48,49],[48,49]]],[1565248725372,["GJX@GJXAIOU",[[1,5591,"- "]],[5591,5591],[5593,5593]]],[1565248727818,["GJX@GJXAIOU",[[1,5266,"- "]],[5266,5266],[5268,5268]]],[1565248785143,["GJX@GJXAIOU",[[-1,5785,"服务"]],[5787,5787],[5785,5785]]],[1565248785798,["GJX@GJXAIOU",[[1,5785,"w"]],[5785,5785],[5786,5786]]],[1565248785930,["GJX@GJXAIOU",[[1,5785," "],[1,5786," u"]],[5786,5786],[5788,5788]]],[1565248786731,["GJX@GJXAIOU",[[-1,5786,"wu"]],[5788,5788],[5786,5786]]],[1565248791379,["GJX@GJXAIOU",[[1,5786,"服务器"]],[5786,5786],[5789,5789]]],[1565248929845,[null,[[-1,5789,"u"],[1,5790," "]],[5789,5789],[5791,5791]]],[1565248929845,[null,[[1,5789,"u"],[-1,5789," "]],[5791,5791],[5789,5789]]],[1565248906346,["GJX@GJXAIOU",[[1,5924,"  、、"]],[5924,5924],[5928,5928]]],[1565248907028,["GJX@GJXAIOU",[[-1,5926,"、、"]],[5928,5928],[5926,5926]]],[1565248916094,["GJX@GJXAIOU",[[1,5926,"// 再创建一个session"]],[5926,5926],[5941,5941]]],[1565248916125,["GJX@GJXAIOU",[[1,5934," "]],[5941,5941],[5942,5942]]],[1565248989843,[null,[[-1,5789,"u"],[1,5790," "]],[5789,5789],[5791,5791]]],[1565248989843,[null,[[1,5789,"u"],[-1,5789," "]],[5791,5791],[5789,5789]]],[1565248938244,["GJX@GJXAIOU",[[1,5967,"  "]],[5966,5966],[5968,5968]]],[1565248939405,["GJX@GJXAIOU",[[1,6031,"  "]],[6031,6031],[6033,6033]]],[1565248940985,["GJX@GJXAIOU",[[1,6067,"  "]],[6066,6066],[6068,6068]]]],null,"GJX@GJXAIOU"],["55229222-0638-4331-8e35-01fea84f394c",1566802620817,"## Servlet实现记录你是当前第几个访问者\n\n注意事项：\n 1 . 防止线程安全问题\n 2 . 在使用同步代码块选择锁对象，通常会使用当前servlet程序对象\n\n```java\npackage a_thread;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * 统计你是当前页面的第几个访问者\n * 利用一个计数器，每一次有一个人访问就  + 1\n */\npublic class VisitedCount extends HttpServlet {\n    int count = 1;\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n\t\t/*int count = 1;\n\t\t局部变量，每一次调用doGet方法，都会重新创建一个count变量, 无法作为计数器*/\n        //告诉浏览器解析数据的方式和使用的字符集\n        resp.setContentType(\"text/html;charset=utf-8\");\n        //服务器发送数据使用的字符集\n        resp.setCharacterEncoding(\"utf-8\");\n\t\t\n        synchronized (this) { \n\t\t\t/*\n\t\t\t 这里因为操作的了共享资源计数器count，为了避免线程的安全问题，这里采用加锁的方式(同步代码块)\n\t\t\t锁对象用this，this表示当前Servlet程序类VisitedCount的对象，因为在Tomcat服务器\n\t\t\t上当VisitedCount对象被创建和init之后，不会在创建新的VisitedCount对象，满足锁对象\n\t\t\t的基本要求\n\t\t\t */\n            resp.getWriter().write(\"你是第\" + count + \"访问者\");\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            count++;\n        }\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n\n```\n\n\n\n## ServletConfig对象\n在 web.xml 中补充以下信息：\n\n```xml\n<servlet>\n <servlet-name>ConfigServlet</servlet-name>\n <servlet-class>b_servletconfig.ConfigServlet</servlet-class>\n <!-- servlet程序的初始化参数 -->\n <init-param>\n <param-name>user</param-name>\n <param-value>root</param-value>\n </init-param>\n <init-param>\n <param-name>password</param-name>\n <param-value>123456</param-value>\n </init-param>\n </servlet>\n```\n在web.xml文件中利用<init-param>标签来定义servlet初始化参数，主要包含两个子标签\n<param-name> <param-value>\n​\n当Tomcat服务器程序启动，WEB容器在创建servlet时，会把初始化参数封装到ServletConfig对象中，这个ServletConfig对象，会作为Servlet对象的初始化方法init的参数\n​\n【注意】\n 在一个Servlet 对应一个ServletConfig\n```java\npackage b_servletconfig;\n\nimport java.io.IOException;\nimport java.util.Enumeration;\n\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class ConfigServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        //因为获取的是当前ConfigServlet程序的ServletConfig对象,因此使用this调用getServletConfig()方法\n        ServletConfig config = this.getServletConfig();\n\n        //获取当前Servlet程序的名字\n        System.out.println(config.getServletName());\n\t\t\n\t\t/*\n\t\t<init-param>\n\t    \t<param-name>user</param-name>\n\t    \t<param-value>root</param-value>\n\t    </init-param>\n\t    <init-param>\n\t    \t<param-name>password</param-name>\n\t    \t<param-value>123456</param-value>\n\t    </init-param>\n\t\t */\n        //根据param-name获取对应的param-value值\n        String value = config.getInitParameter(\"user\");\n        System.out.println(value);\n\t\t\n        //获取到所有初始化参数的枚举类型\n        Enumeration<String> names = config.getInitParameterNames();\n        while (names.hasMoreElements()) {\n            String name = names.nextElement();\n            System.out.println(name + \":\" + config.getInitParameter(name));\n        }\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n\n```\n用于获取参数值以及属性；\n\n\n\n## ServletContext\n\n表示当前整个WEB应用，一个WEB应用有且只有一个ServletContext对象\n​\n1 获取WEB应用的路径\n ServletContext context = this.getServletContext();\n context.getContextPath();\n request.getContextPath();\n​\n2.WEB应用的全局参数\n <!-- 这是针对整个WEB项目的初始化参数 -->\n <context-param>\n <param-name>AAA</param-name>\n <param-value>aaa</param-value>\n </context-param>\n context.getInitParameter(Stirng paramName);\n\n3.ServletContext 是一个域对象\n request，session 也是域对象\n​\n 可以利用ServletContext域对象特征，完成在整个WEB项目中的数据共享传递\n 不单单能传递基本数据类型，也可以传递类对象类型\n setAttribute(String name, Object value);\n Object    getAttribute(String name);\n​\n4.转发和重定向\n转发会携带数据，但是重定向没有携带数据；\n WEB服务器接受到客户端的请求之后，让Tomcat服务器去调用另一个WEB资源，这称之为转发\n\n\n-  request域转发\n   - request.setAttribute(String name, Object value);\n\n   - 转发的方法 `req.getRequestDispatcher(String uri).forward(HttpServletRequest req, HttpServletResponse resp);`\n       - uri：服务器端要访问别的WEB资源路径，这里是服务器端的地址，一般用 / 开头，表示WEB项目的根目录\n       - HttpServletRequest req: 原本用户请求当前页面的request对象\n       - HttpServletResponse resp: 原本用户请求当前页面生成对应的response对象\n\n - 重定向\n response.sendRedirect(String url);\n 这个URL是相对于webapps的，是提供给浏览器使用的URL\n\n 推荐写法是：\n response.sendRedirect(request.getContextPath() + \"重定向地址\");\n\n 【注意】\n 在重定向的情况下，request域不能使用\n\n## 会话控制\n\n1. 软件程序中的会话  一次会话：  打开浏览器 -> 访问服务器上的内容 -> 关闭浏览器\n\n登录业务场景：  打开浏览器 -> 访问登录页面 -> 输入 用户名 密码 验证码 -> 发送给服务器 -> 服务器验证消息  -> 返回给浏览器 -> 浏览器加载主页\n\n  发现：在百度首页登录了用户名，在所有的百度服务的页面下都是一个登录的状态\n\n  购物车场景：  在手机淘宝APP选择了一个商品，加入购物车\n  打开浏览器 -> 淘宝网 -> 登录账号 -> 查看购物车，也可以看到手机APP添加商品\n  这里的购物车数据在那里保存？？？\n\n  会话控制技术：  管理 浏览器客户端 和 服务器 之间进行会话过程生产的会话数据\n\n## 会话控制技术\n\nCookie技术： 会话数据保存在浏览器客户端，也就是用户本地\nSession技术：会话数据保存在服务器上\n\n### Cookie技术\n\n- 核心方法：\n 1 . 创建Cookie对象\n Cookie(String name, String value); \n 2 . 设置Cookie\n setValue(String value) //通过name来设置Cookie的Value\n setPath(String path); //设置Cookie的有效范围 \n setMaxAge(int time);     //设置最大有效时间\n 3 . 发送Cookie到浏览器保存\n response.addCookie(Cookie c); //发送Cookie给浏览器\n 4 . 服务器接受浏览器访问时带来的Cookie数据\n Cookie[] request.getCookies();\n\n- Cookie有一定的局限性\n 1 . 限制数据类型 必须是String\n 2 . 不能保存中文\n 3 . Cookie保存数据容量较小，只有4KB\n\n 如果要保存4KB以上数据，或者要保存中文数据，就不能使用Cookie技术，只能用Session\n\n 【但是有一个前提】\n 如果浏览器没有打开Cookie功能， Session也无法使用\n\n Sesion的特点：\n 会话数据保存在 服务器 上，可以生成一个临时或者永久的temp文件\n\n### Session技术\n\nHttpSession\n 1 . 获取Session对象\n HttpSession getSession();\n HttpSession getSession(boolean create);  // 再创建一个 session\n\n 2 . 设置Session对象\n void   setMaxInactiveInterval(int interval); //设置Session 的有效时间\n void   invalidate(); //销毁Session\n String   getId();    //获取Session的ID\n\n 3 . Session也是一个域对象，这里可以保存数据属性到Session\n void setAttribute(String name, Object value); //设置Session里面保存是会话数据内容，可以保存一个对象\n Object getAttribute(String name); //获取到Session里面数据\n void removeAttribute(String name); //清空Session里面的数据",[[1566802616027,["GJX@GJXAIOU",[[-1,10,"实现记录你是当前第几个访问者"]],[10,24],[10,10]]],[1566802619424,["GJX@GJXAIOU",[[1,10," 与session"]],[10,10],[19,19]]],[1566802622645,["GJX@GJXAIOU",[[1,3," "]],[2,2],[3,3]]],[1566802630212,["GJX@GJXAIOU",[[1,3,"JavaEEDay41"]],[3,3],[14,14]]],[1566802630621,["GJX@GJXAIOU",[[1,15," "]],[14,14],[15,15]]],[1566802633502,["GJX@GJXAIOU",[[-1,15," "]],[16,16],[15,15]]],[1566802635925,["GJX@GJXAIOU",[[1,3," "],[1,14," "]],[3,3],[4,4]]],[1566802640413,["GJX@GJXAIOU",[[-1,15,"  "]],[15,17],[15,15]]]],null,"GJX@GJXAIOU"],["086f0401-4169-41e1-9759-1e5a75a98c38",1566802707637,"##  JavaEEDay41Servlet 与session\n\n注意事项：\n 1 . 防止线程安全问题\n 2 . 在使用同步代码块选择锁对象，通常会使用当前servlet程序对象\n\n```java\npackage a_thread;\n\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * 统计你是当前页面的第几个访问者\n * 利用一个计数器，每一次有一个人访问就  + 1\n */\npublic class VisitedCount extends HttpServlet {\n    int count = 1;\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n\t\t/*int count = 1;\n\t\t局部变量，每一次调用doGet方法，都会重新创建一个count变量, 无法作为计数器*/\n        //告诉浏览器解析数据的方式和使用的字符集\n        resp.setContentType(\"text/html;charset=utf-8\");\n        //服务器发送数据使用的字符集\n        resp.setCharacterEncoding(\"utf-8\");\n\t\t\n        synchronized (this) { \n\t\t\t/*\n\t\t\t 这里因为操作的了共享资源计数器count，为了避免线程的安全问题，这里采用加锁的方式(同步代码块)\n\t\t\t锁对象用this，this表示当前Servlet程序类VisitedCount的对象，因为在Tomcat服务器\n\t\t\t上当VisitedCount对象被创建和init之后，不会在创建新的VisitedCount对象，满足锁对象\n\t\t\t的基本要求\n\t\t\t */\n            resp.getWriter().write(\"你是第\" + count + \"访问者\");\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            count++;\n        }\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n\n```\n\n\n\n## ServletConfig对象\n在 web.xml 中补充以下信息：\n\n```xml\n<servlet>\n <servlet-name>ConfigServlet</servlet-name>\n <servlet-class>b_servletconfig.ConfigServlet</servlet-class>\n <!-- servlet程序的初始化参数 -->\n <init-param>\n <param-name>user</param-name>\n <param-value>root</param-value>\n </init-param>\n <init-param>\n <param-name>password</param-name>\n <param-value>123456</param-value>\n </init-param>\n </servlet>\n```\n在web.xml文件中利用<init-param>标签来定义servlet初始化参数，主要包含两个子标签\n<param-name> <param-value>\n​\n当Tomcat服务器程序启动，WEB容器在创建servlet时，会把初始化参数封装到ServletConfig对象中，这个ServletConfig对象，会作为Servlet对象的初始化方法init的参数\n​\n【注意】\n 在一个Servlet 对应一个ServletConfig\n```java\npackage b_servletconfig;\n\nimport java.io.IOException;\nimport java.util.Enumeration;\n\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class ConfigServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        //因为获取的是当前ConfigServlet程序的ServletConfig对象,因此使用this调用getServletConfig()方法\n        ServletConfig config = this.getServletConfig();\n\n        //获取当前Servlet程序的名字\n        System.out.println(config.getServletName());\n\t\t\n\t\t/*\n\t\t<init-param>\n\t    \t<param-name>user</param-name>\n\t    \t<param-value>root</param-value>\n\t    </init-param>\n\t    <init-param>\n\t    \t<param-name>password</param-name>\n\t    \t<param-value>123456</param-value>\n\t    </init-param>\n\t\t */\n        //根据param-name获取对应的param-value值\n        String value = config.getInitParameter(\"user\");\n        System.out.println(value);\n\t\t\n        //获取到所有初始化参数的枚举类型\n        Enumeration<String> names = config.getInitParameterNames();\n        while (names.hasMoreElements()) {\n            String name = names.nextElement();\n            System.out.println(name + \":\" + config.getInitParameter(name));\n        }\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n\n```\n用于获取参数值以及属性；\n\n\n\n## ServletContext\n\n表示当前整个WEB应用，一个WEB应用有且只有一个ServletContext对象\n​\n1 获取WEB应用的路径\n ServletContext context = this.getServletContext();\n context.getContextPath();\n request.getContextPath();\n​\n2.WEB应用的全局参数\n <!-- 这是针对整个WEB项目的初始化参数 -->\n <context-param>\n <param-name>AAA</param-name>\n <param-value>aaa</param-value>\n </context-param>\n context.getInitParameter(Stirng paramName);\n\n3.ServletContext 是一个域对象\n request，session 也是域对象\n​\n 可以利用ServletContext域对象特征，完成在整个WEB项目中的数据共享传递\n 不单单能传递基本数据类型，也可以传递类对象类型\n setAttribute(String name, Object value);\n Object    getAttribute(String name);\n​\n4.转发和重定向\n转发会携带数据，但是重定向没有携带数据；\n WEB服务器接受到客户端的请求之后，让Tomcat服务器去调用另一个WEB资源，这称之为转发\n\n\n-  request域转发\n   - request.setAttribute(String name, Object value);\n\n   - 转发的方法 `req.getRequestDispatcher(String uri).forward(HttpServletRequest req, HttpServletResponse resp);`\n       - uri：服务器端要访问别的WEB资源路径，这里是服务器端的地址，一般用 / 开头，表示WEB项目的根目录\n       - HttpServletRequest req: 原本用户请求当前页面的request对象\n       - HttpServletResponse resp: 原本用户请求当前页面生成对应的response对象\n\n - 重定向\n response.sendRedirect(String url);\n 这个URL是相对于webapps的，是提供给浏览器使用的URL\n\n 推荐写法是：\n response.sendRedirect(request.getContextPath() + \"重定向地址\");\n\n 【注意】\n 在重定向的情况下，request域不能使用\n\n## 会话控制\n\n1. 软件程序中的会话  一次会话：  打开浏览器 -> 访问服务器上的内容 -> 关闭浏览器\n\n登录业务场景：  打开浏览器 -> 访问登录页面 -> 输入 用户名 密码 验证码 -> 发送给服务器 -> 服务器验证消息  -> 返回给浏览器 -> 浏览器加载主页\n\n  发现：在百度首页登录了用户名，在所有的百度服务的页面下都是一个登录的状态\n\n  购物车场景：  在手机淘宝APP选择了一个商品，加入购物车\n  打开浏览器 -> 淘宝网 -> 登录账号 -> 查看购物车，也可以看到手机APP添加商品\n  这里的购物车数据在那里保存？？？\n\n  会话控制技术：  管理 浏览器客户端 和 服务器 之间进行会话过程生产的会话数据\n\n## 会话控制技术\n\nCookie技术： 会话数据保存在浏览器客户端，也就是用户本地\nSession技术：会话数据保存在服务器上\n\n### Cookie技术\n\n- 核心方法：\n 1 . 创建Cookie对象\n Cookie(String name, String value); \n 2 . 设置Cookie\n setValue(String value) //通过name来设置Cookie的Value\n setPath(String path); //设置Cookie的有效范围 \n setMaxAge(int time);     //设置最大有效时间\n 3 . 发送Cookie到浏览器保存\n response.addCookie(Cookie c); //发送Cookie给浏览器\n 4 . 服务器接受浏览器访问时带来的Cookie数据\n Cookie[] request.getCookies();\n\n- Cookie有一定的局限性\n 1 . 限制数据类型 必须是String\n 2 . 不能保存中文\n 3 . Cookie保存数据容量较小，只有4KB\n\n 如果要保存4KB以上数据，或者要保存中文数据，就不能使用Cookie技术，只能用Session\n\n 【但是有一个前提】\n 如果浏览器没有打开Cookie功能， Session也无法使用\n\n Sesion的特点：\n 会话数据保存在 服务器 上，可以生成一个临时或者永久的temp文件\n\n### Session技术\n\nHttpSession\n 1 . 获取Session对象\n HttpSession getSession();\n HttpSession getSession(boolean create);  // 再创建一个 session\n\n 2 . 设置Session对象\n void   setMaxInactiveInterval(int interval); //设置Session 的有效时间\n void   invalidate(); //销毁Session\n String   getId();    //获取Session的ID\n\n 3 . Session也是一个域对象，这里可以保存数据属性到Session\n void setAttribute(String name, Object value); //设置Session里面保存是会话数据内容，可以保存一个对象\n Object getAttribute(String name); //获取到Session里面数据\n void removeAttribute(String name); //清空Session里面的数据",[[1566802649723,["GJX@GJXAIOU",[[1,15," "]],[15,15],[16,16]]],[1566802653587,["GJX@GJXAIOU",[[1,34,"\n"]],[33,33],[34,34]]],[1566802655750,["GJX@GJXAIOU",[[1,34,"### "]],[34,34],[38,38]]],[1566802658517,["GJX@GJXAIOU",[[-1,36,"# "]],[38,38],[36,36]]],[1566802663785,["GJX@GJXAIOU",[[1,36," 一、Servlet"]],[36,36],[46,46]]],[1566802666540,["GJX@GJXAIOU",[[-1,0,"#"]],[2,2],[1,1]]],[1566802676924,["GJX@GJXAIOU",[[-1,131,"\n"]],[131,131],[130,130]]],[1566802683363,["GJX@GJXAIOU",[[-1,377," "]],[377,377],[376,376]]],[1566803334942,["GJX@GJXAIOU",[[-1,863,"的"]],[864,864],[863,863]]],[1566803441014,["GJX@GJXAIOU",[[-1,1199,"                // TODO Auto-generated catch block"]],[1199,1249],[1199,1199]]],[1566803441428,["GJX@GJXAIOU",[[-1,1199,"\n"]],[1199,1199],[1198,1198]]],[1566803444196,["GJX@GJXAIOU",[[-1,1281,"\n"]],[1281,1281],[1280,1280]]],[1566803456116,["GJX@GJXAIOU",[[-1,1463,"\n"]],[1463,1463],[1462,1462]]],[1566803467860,["GJX@GJXAIOU",[[-1,1508,"\n"]],[1508,1508],[1507,1507]]],[1566803475126,["GJX@GJXAIOU",[[1,1472,"#"]],[1472,1472],[1489,1489]]],[1566803482551,["GJX@GJXAIOU",[[-1,1469,"\n"]],[1468,1468],[1467,1467]]],[1566803483455,["GJX@GJXAIOU",[[-1,1468,"\n"]],[1467,1467],[1466,1466]]],[1566803510144,["GJX@GJXAIOU",[[1,1750,"\n "]],[1748,1748],[1750,1750]]],[1566803519064,["GJX@GJXAIOU",[[1,1631,"\n "]],[1629,1629],[1631,1631]]],[1566803553707,["GJX@GJXAIOU",[[-1,2123,"\n"]],[2123,2123],[2122,2122]]],[1566803555907,["GJX@GJXAIOU",[[-1,2181,"\n"]],[2181,2181],[2180,2180]]],[1566803701064,["GJX@GJXAIOU",[[-1,2800,"\t\t/*\n\t\t<init-param>\n\t    \t<param-name>user</param-name>\n\t    \t<param-value>root</param-value>\n\t    </init-param>\n\t    <init-param>\n\t    \t<param-name>password</param-name>\n\t    \t<param-value>123456</param-value>\n\t    </init-param>\n\t\t */"]],[2802,3035],[2800,2800]]],[1566803701413,["GJX@GJXAIOU",[[-1,2800,"\n"]],[2800,2800],[2799,2799]]],[1566803719973,["GJX@GJXAIOU",[[-1,3386,"\n"]],[3386,3386],[3385,3385]]]],null,"GJX@GJXAIOU"],["4cb4aaa1-ea98-4a91-8c3e-53d2ec79b3eb",1570025957845,"#  JavaEEDay41 Servlet 与session\n\n## 一、Servlet\n注意事项：\n 1 . 防止线程安全问题\n 2 . 在使用同步代码块选择锁对象，通常会使用当前servlet程序对象\n\n```java\npackage a_thread;\nimport java.io.IOException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * 统计你是当前页面的第几个访问者\n * 利用一个计数器，每一次有一个人访问就 + 1\n */\npublic class VisitedCount extends HttpServlet {\n    int count = 1;\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n\t\t/*int count = 1;\n\t\t局部变量，每一次调用doGet方法，都会重新创建一个count变量, 无法作为计数器*/\n        //告诉浏览器解析数据的方式和使用的字符集\n        resp.setContentType(\"text/html;charset=utf-8\");\n        //服务器发送数据使用的字符集\n        resp.setCharacterEncoding(\"utf-8\");\n\t\t\n        synchronized (this) { \n\t\t\t/*\n\t\t\t 这里因为操作了共享资源计数器count，为了避免线程的安全问题，这里采用加锁的方式(同步代码块)\n\t\t\t锁对象用this，this表示当前Servlet程序类VisitedCount的对象，因为在Tomcat服务器\n\t\t\t上当VisitedCount对象被创建和init之后，不会在创建新的VisitedCount对象，满足锁对象\n\t\t\t的基本要求\n\t\t\t */\n            resp.getWriter().write(\"你是第\" + count + \"访问者\");\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            count++;\n        }\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n```\n\n### ServletConfig对象\n在 web.xml 中补充以下信息：\n```xml\n<servlet>\n <servlet-name>ConfigServlet</servlet-name>\n <servlet-class>b_servletconfig.ConfigServlet</servlet-class>\n \n <!-- servlet程序的初始化参数 -->\n <init-param>\n <param-name>user</param-name>\n <param-value>root</param-value>\n </init-param>\n \n <init-param>\n <param-name>password</param-name>\n <param-value>123456</param-value>\n </init-param>\n </servlet>\n```\n在web.xml文件中利用<init-param>标签来定义servlet初始化参数，主要包含两个子标签\n<param-name> <param-value>\n​\n当Tomcat服务器程序启动，WEB容器在创建servlet时，会把初始化参数封装到ServletConfig对象中，这个ServletConfig对象，会作为Servlet对象的初始化方法init的参数\n​\n【注意】\n 在一个Servlet 对应一个ServletConfig\n```java\npackage b_servletconfig;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class ConfigServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        //因为获取的是当前ConfigServlet程序的ServletConfig对象,因此使用this调用getServletConfig()方法\n        ServletConfig config = this.getServletConfig();\n\n        //获取当前Servlet程序的名字\n        System.out.println(config.getServletName());\n\t\t\n        //根据param-name获取对应的param-value值\n        String value = config.getInitParameter(\"user\");\n        System.out.println(value);\n\t\t\n        //获取到所有初始化参数的枚举类型\n        Enumeration<String> names = config.getInitParameterNames();\n        while (names.hasMoreElements()) {\n            String name = names.nextElement();\n            System.out.println(name + \":\" + config.getInitParameter(name));\n        }\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        doGet(req, resp);\n    }\n}\n```\n用于获取参数值以及属性；\n\n\n\n## ServletContext\n\n表示当前整个WEB应用，一个WEB应用有且只有一个ServletContext对象\n​\n1 获取WEB应用的路径\n ServletContext context = this.getServletContext();\n context.getContextPath();\n request.getContextPath();\n​\n2.WEB应用的全局参数\n <!-- 这是针对整个WEB项目的初始化参数 -->\n <context-param>\n <param-name>AAA</param-name>\n <param-value>aaa</param-value>\n </context-param>\n context.getInitParameter(Stirng paramName);\n\n3.ServletContext 是一个域对象\n request，session 也是域对象\n​\n 可以利用ServletContext域对象特征，完成在整个WEB项目中的数据共享传递\n 不单单能传递基本数据类型，也可以传递类对象类型\n setAttribute(String name, Object value);\n Object    getAttribute(String name);\n​\n4.转发和重定向\n转发会携带数据，但是重定向没有携带数据；\n WEB服务器接受到客户端的请求之后，让Tomcat服务器去调用另一个WEB资源，这称之为转发\n\n\n-  request域转发\n   - request.setAttribute(String name, Object value);\n\n   - 转发的方法 `req.getRequestDispatcher(String uri).forward(HttpServletRequest req, HttpServletResponse resp);`\n       - uri：服务器端要访问别的WEB资源路径，这里是服务器端的地址，一般用 / 开头，表示WEB项目的根目录\n       - HttpServletRequest req: 原本用户请求当前页面的request对象\n       - HttpServletResponse resp: 原本用户请求当前页面生成对应的response对象\n\n - 重定向\n response.sendRedirect(String url);\n 这个URL是相对于webapps的，是提供给浏览器使用的URL\n\n 推荐写法是：\n response.sendRedirect(request.getContextPath() + \"重定向地址\");\n\n 【注意】\n 在重定向的情况下，request域不能使用\n\n## 会话控制\n\n1. 软件程序中的会话  一次会话：  打开浏览器 -> 访问服务器上的内容 -> 关闭浏览器\n\n登录业务场景：  打开浏览器 -> 访问登录页面 -> 输入 用户名 密码 验证码 -> 发送给服务器 -> 服务器验证消息  -> 返回给浏览器 -> 浏览器加载主页\n\n  发现：在百度首页登录了用户名，在所有的百度服务的页面下都是一个登录的状态\n\n  购物车场景：  在手机淘宝APP选择了一个商品，加入购物车\n  打开浏览器 -> 淘宝网 -> 登录账号 -> 查看购物车，也可以看到手机APP添加商品\n  这里的购物车数据在那里保存？？？\n\n  会话控制技术：  管理 浏览器客户端 和 服务器 之间进行会话过程生产的会话数据\n\n## 会话控制技术\n\nCookie技术： 会话数据保存在浏览器客户端，也就是用户本地\nSession技术：会话数据保存在服务器上\n\n### Cookie技术\n\n- 核心方法：\n 1 . 创建Cookie对象\n Cookie(String name, String value); \n 2 . 设置Cookie\n setValue(String value) //通过name来设置Cookie的Value\n setPath(String path); //设置Cookie的有效范围 \n setMaxAge(int time);     //设置最大有效时间\n 3 . 发送Cookie到浏览器保存\n response.addCookie(Cookie c); //发送Cookie给浏览器\n 4 . 服务器接受浏览器访问时带来的Cookie数据\n Cookie[] request.getCookies();\n\n- Cookie有一定的局限性\n 1 . 限制数据类型 必须是String\n 2 . 不能保存中文\n 3 . Cookie保存数据容量较小，只有4KB\n\n 如果要保存4KB以上数据，或者要保存中文数据，就不能使用Cookie技术，只能用Session\n\n 【但是有一个前提】\n 如果浏览器没有打开Cookie功能， Session也无法使用\n\n Sesion的特点：\n 会话数据保存在 服务器 上，可以生成一个临时或者永久的temp文件\n\n### Session技术\n\nHttpSession\n 1 . 获取Session对象\n HttpSession getSession();\n HttpSession getSession(boolean create);  // 再创建一个 session\n\n 2 . 设置Session对象\n void   setMaxInactiveInterval(int interval); //设置Session 的有效时间\n void   invalidate(); //销毁Session\n String   getId();    //获取Session的ID\n\n 3 . Session也是一个域对象，这里可以保存数据属性到Session\n void setAttribute(String name, Object value); //设置Session里面保存是会话数据内容，可以保存一个对象\n Object getAttribute(String name); //获取到Session里面数据\n void removeAttribute(String name); //清空Session里面的数据",[[1570025927554,["GJX@GJXAIOU",[[1,3425,"**"],[1,3466,"**"]],[3425,3466],[3425,3470]]]],null,"GJX@GJXAIOU"]]}