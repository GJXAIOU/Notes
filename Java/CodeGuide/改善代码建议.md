# 快速改善代码的几个小建议

> https://www.yuque.com/docs/share/6062e6ba-7166-4e7c-a44c-fe2491832695?#

本文举例的代码，仅做案例讨论。影响代码质量最大的因素其实是开发进度，写得不好有时未必是能力不够。



前几天，小册群里有位同学私信我关于代码质量的问题：

昨天下午11:19

挺哥,极客时间有什么适合入行不久看的课吗,像你以前提到的代码质量之类的

代码之丑可以看看

不过感觉对你帮助可能不是很大

你可以先去观察同事代码

讲真,多看看Java8多抽取方法,改善会好很多

![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1057015/1626441343034-48fce6a4-c9c6-4f09-aabc-8a847ae72807.png?x-oss-process=image%2Fresize%2Cw_826%2Climit_0)



由于工作日很忙，没展开细说，特别在这里补一篇。我不敢说自己的代码风格就是好的，权当抛砖引玉吧。



 ## 可读性 

什么样的代码才是高质量的代码呢？

对于这个问题，每个人都有自己的看法，但我始终坚持认为：高质量的代码必然要简单、易读。

```java
@Test
public void testListSimpleStyle() {
    // 有点像匿名类，但本质是重写代码块，在代码块里调用本对象的add()方法
    List<Superman> list = new ArrayList<Superman>(){
        {
            add(new Superman("AAA"));
            add(new Superman("BBB"));
            add(new Superman("CCC"));
        }
    };

    System.out.println(list);
}
```

这样的代码固然骚，但也只剩下骚了。想要简化变量的初始化，其实有更优雅的写法。





Java

复制代码

1

﻿

```
@Test
```

2

﻿

```
public void testListSimpleStyle() {
```

3

﻿

```
    // 利用可变形参的特性直接把多个参数传入，而不需要另外创建数组
```

4

﻿

```
    List<Superman> list = Arrays.asList(
```

5

﻿

```
            new Superman("xixi"),
```

6

﻿

```
            new Superman("haha")
```

7

﻿

```
    );
```

8

﻿

```

```

9

﻿

```
    System.out.println(list);
```

10

﻿

```
}
```

如果你觉得Arrays不好（返回的List不可增删元素），还可以使用Guava：





Java

复制代码

1

﻿

```
@Test
```

2

﻿

```
public void testListSimpleStyle() {
```

3

﻿

```
    List<Superman> list = Lists.newArrayList(
```

4

﻿

```
            new Superman("xixi"),
```

5

﻿

```
            new Superman("haha")
```

6

﻿

```
    );
```

7

﻿

```

```

8

﻿

```
    System.out.println(list);
```

9

﻿

```
}
```

后两种代码风格显然更具备可读性。很多刚入职场的热血青年，常常会有一个误区：我写的代码，一定要把同事绕晕，让他哭着求我给他解释，这样才能鹤立鸡群。



不好意思，如果你敢这样，大概率会被开除。随着互联网的普及与壮大，现在的软件设计变得愈发复杂，像中国初代程序员求伯君那样一个人写出WPS的时代早就过去了，更多时候我们都是在集体战斗。个人能力固然重要，但终有一天你会发现自己只是一个平凡的程序员，编码能力并没有大幅领先身边的同事，甚至反过来经常被同事教做人。与其写骚代码炫技，不如想想如何把代码写得更简单易懂，让别人正确理解你的意图。





 不要使用魔法值 





Java

复制代码

1

﻿

```
public boolean saveUser() {
```

2

﻿

```
    // do something...
```

3

﻿

```
    user.setType(1);
```

4

﻿

```
    
```

5

﻿

```
    return userService.save(user) > 1;
```

6

﻿

```
}
```

上面代码setType(1)中的数字就是魔法值，它既不由参数传入，也不是枚举或常量，而是凭空出现的。看到这个数字1，你会疑惑：1代表什么呢？学生还是教师？亦或是某种状态？真是让人抓狂！



一般来说，应该把type、status等变化有限的数据抽取到枚举或常量中，并赋予有意义的名字，然后在需要的地方引用：





Java

复制代码

1

﻿

```
public boolean saveUser() {
```

2

﻿

```
    // do something...
```

3

﻿

```
    user.setType(UserTypeEnum.STUDENT.getType);
```

4

﻿

```
    
```

5

﻿

```
    return userService.save(user) > 1;
```

6

﻿

```
}
```

如果只有当前代码用到，而你又懒得抽取枚举或常量，最好用一个变量去接收：





Java

复制代码

1

﻿

```
public boolean saveUser() {
```

2

﻿

```
    // do something...
```

3

﻿

```
    Integer studentType = 1;
```

4

﻿

```
    user.setType(studentType);
```

5

﻿

```
    
```

6

﻿

```
    return userService.save(user) > 1;
```

7

﻿

```
}
```





 变量声明后立即使用 

很多人都知道“变量要先声明再使用”，但实际开发时，却容易“只声明不使用”或者“声明后过很久才使用”：





Java

复制代码

1

﻿

```
/**
```

2

﻿

```
 * 格式化官方素材信息
```

3

﻿

```
 *
```

4

﻿

```
 * @param uid
```

5

﻿

```
 * @param momentTOList
```

6

﻿

```
 * @param isMomentUser
```

7

﻿

```
 * @param versionNum
```

8

﻿

```
 * @param loginUid
```

9

﻿

```
 * @return
```

10

﻿

```
 */
```

11

﻿

```
private List<XxxMomentTypeInfoTO> formatXxxMomentTO(Long uid, List<MomentTO> momentTOList, Boolean isSeller,
```

12

﻿

```
                                                            Boolean isMomentUser, int versionNum, Long loginUid) {
```

13

﻿

```
    // 你能看出plusGrade是干嘛用的吗？
```

14

﻿

```
    Integer plusGrade = xxxMemberProfileManager.getPlusGrade(loginUid);
```

15

﻿

```
    Boolean isGeneralFansSeller = relationUserTypeManager.isGeneralFansSeller(loginUid);
```

16

﻿

```
    List<Long> momentUidList = ConvertUtil.resultToList(momentTOList, "uid");
```

17

﻿

```
    List<XxxMemberTO> memberTOS = xxxMemberManager.listMemberByUids(momentUidList);
```

18

﻿

```
    List<Long> adviserXxxUidList = bizXxxGroupCrm.listAdviserXxxUid();
```

19

﻿

```
    Map<Long, XxxMemberTO> xxxMemberTOMap = getXxxMemberTOMap(ConvertUtil.listToMap(memberTOS, "uid"));
```

20

﻿

```
    List<Long> momentIds = ConvertUtil.resultToList(momentTOList, "id", t -> Validator.greaterZero(t.getId()));
```

21

﻿

```
    List<Long> pids = ConvertUtil.resultToList(momentTOList, "pid", t ->
```

22

﻿

```
            Validator.isId(t.getPid()) && !Validator.isId(t.getIid()));
```

23

﻿

```
    List<Long> iids = ConvertUtil.resultToList(momentTOList, "iid", t -> Validator.greaterZero(t.getIid()));
```

24

﻿

```
    Map<Long, XxxFormatSearchItemTO> formatSearchItemTOMap = new HashMap<>(momentTOList.size());
```

25

﻿

```
    XxxMomentSearchItemTO momentSearchItemTO = null;
```

26

﻿

```
    if (!Validator.isNullOrEmpty(pids) || !Validator.isNullOrEmpty(iids)) {
```

27

﻿

```
        momentSearchItemTO = getItemListByPidIid(pids, iids, loginUid);
```

28

﻿

```
    }
```

29

﻿

```
    Map<Long, XxxMomentStoreItemResTO> momentStoreItemResTOMap = mapStoreItemInfo(loginUid, iids);
```

30

﻿

```
    XxxShopInfoTO shopInfoTO = xxxShopInfoManager.getByUid(uid);
```

31

﻿

```
    Long shopId = Validator.isNull(shopInfoTO) ? null : shopInfoTO.getId();
```

32

﻿

```
    Map<String, Boolean> hasForwardMap = checkHasForwardByMomentTOList(uid, momentTOList);
```

33

﻿

```
    List<PlusGradeInfoTO> plusGradeInfoTOList = xxxMemberProfileManager.listPlusGradeInfoByUid(momentUidList);
```

34

﻿

```
    Map<Long, PlusGradeInfoTO> plusGradeInfoTOMap = ConvertUtil.listToMap(plusGradeInfoTOList, "uid");
```

35

﻿

```
    List<XxxMomentTypeInfoTO> momentTypeInfoTOList = Lists.newArrayList();
```

36

﻿

```
    Map<Long, MomentLikeInfoTO> momentLikeMap = xxxMomentManager.momentLikeInfo(uid, momentIds);
```

37

﻿

```
    for (MomentTO momentTO : momentTOList) {
```

38

﻿

```
        XxxMomentTO xxxMomentTO = new XxxMomentTO();
```

39

﻿

```
        XxxMomentTypeInfoTO momentTypeInfoTO = new XxxMomentTypeInfoTO();
```

40

﻿

```
        if (xxxMemberTOMap.containsKey(momentTO.getUid())) {
```

41

﻿

```
            if (Validator.isNotNull(uid) && plusGradeInfoTOMap.containsKey(momentTO.getUid())
```

42

﻿

```
                    && Validator.isNotNull(plusGradeInfoTOMap.get(momentTO.getUid()).getGrade())) {
```

43

﻿

```
                Integer shopGrade = plusGradeInfoTOMap.get(momentTO.getUid()).getGrade();
```

44

﻿

```
                // 顾问的icon取VIP3的
```

45

﻿

```
                if (adviserXxxUidList.contains(momentTO.getUid())) {
```

46

﻿

```
                    shopGrade = ShopPlusUtil.SHOP_PLUS_VIP3;
```

47

﻿

```
                }
```

48

﻿

```
                xxxMomentTO.setShopkeeperIcon(getShopkeeperIconInfoTO(shopGrade));
```

49

﻿

```
            }
```

50

﻿

```
            if (Validator.isNotNull(xxxMomentTO.getShopkeeperIcon())
```

51

﻿

```
                    && getOfficialUidList().contains(momentTO.getUid())) {
```

52

﻿

```
                xxxMomentTO.getShopkeeperIcon().setUrl(XxxMomentConstant.OFFICIAL_ICON_DEFAULT);
```

53

﻿

```
            }
```

54

﻿

```
            Long mapId = null;
```

55

﻿

```
            if (Validator.isNotNull(momentSearchItemTO)) {
```

56

﻿

```
                if (Validator.greaterZero(momentTO.getPid()) && !Validator.greaterZero(momentTO.getIid()) &&
```

57

﻿

```
                        momentSearchItemTO.getPidItemMap().containsKey(momentTO.getPid())) {
```

58

﻿

```
                    formatSearchItemTOMap = momentSearchItemTO.getPidItemMap();
```

59

﻿

```
                    mapId = momentTO.getPid();
```

60

﻿

```
                }
```

61

﻿

```
                if (Validator.greaterZero(momentTO.getIid()) &&
```

62

﻿

```
                        momentSearchItemTO.getIidItemMap().containsKey(momentTO.getIid())) {
```

63

﻿

```
                    formatSearchItemTOMap = momentSearchItemTO.getIidItemMap();
```

64

﻿

```
                    mapId = momentTO.getIid();
```

65

﻿

```
                }
```

66

﻿

```
            }
```

67

﻿

```
            // 是否有效的iid
```

68

﻿

```
            Boolean isEffectiveIid = momentStoreItemResTOMap.containsKey(momentTO.getIid())
```

69

﻿

```
                    ? Boolean.TRUE : Boolean.FALSE;
```

70

﻿

```
            String productTitle = null;
```

71

﻿

```
            String productImg = null;
```

72

﻿

```
            if (Validator.isNotNull(mapId) && formatSearchItemTOMap.containsKey(mapId)) {
```

73

﻿

```
                isEffectiveIid = Boolean.TRUE;
```

74

﻿

```
                productTitle = formatSearchItemTOMap.get(mapId).getTitle();
```

75

﻿

```
                productImg = formatSearchItemTOMap.get(mapId).getImg();
```

76

﻿

```
                if (!momentStoreItemResTOMap.containsKey(momentTO.getIid())) {
```

77

﻿

```
                    momentTO.setIid(formatSearchItemTOMap.get(mapId).getIid());
```

78

﻿

```
                    momentTO.setPid(formatSearchItemTOMap.get(mapId).getProductId());
```

79

﻿

```
                }
```

80

﻿

```
                xxxMomentTO = getDefaultMomentPriceCms(xxxMomentTO, formatSearchItemTOMap.get(mapId),
```

81

﻿

```
                        loginUid);
```

82

﻿

```
            }
```

83

﻿

```
            xxxMomentTO = setMomentPriceCommissionInfo(uid, isMomentUser, isGeneralFansSeller, shopId,
```

84

﻿

```
                    xxxMomentTO, momentTO, momentStoreItemResTOMap, plusGrade, versionNum);
```

85

﻿

```
            // 买家不显示赚多少
```

86

﻿

```
            if (!isGeneralFansSeller) {
```

87

﻿

```
                xxxMomentTO.setCms(null);
```

88

﻿

```
            }
```

89

﻿

```
            // 省略100行...
```

90

﻿

```
        }
```

91

﻿

```
    }
```

92

﻿

```
}
```

不知道大家有没有“变量焦虑”：当我看到一个变量被声明，却无法在5行以内找到它的使用时，我会感到焦虑。在上面的代码中，plusGrade代表用户等级，用于计算不同等级对应的佣金。但是，变量声明在第14行，使用却在第83行...这会造成至少两个困惑：第14行初见时我不知它将去往何处，第83行再见时我不知它来自何方，两次相见都只能默默流泪。



变量声明与变量使用隔得太远，是很多程序员的通病。这种不良的编码风格，不仅影响可读性，还可能造成性能浪费。比如：





Java

复制代码

1

﻿

```
public void method() {
```

2

﻿

```
    Integer plusGrade = memberProfileManager.getPlusGrade(loginUid);
```

3

﻿

```
    
```

4

﻿

```
    // 隔了80行...
```

5

﻿

```
    
```

6

﻿

```
    Long commission = caculateCms(originPrice, plusGrade);
```

7

﻿

```
}
```

如果中间发生了异常，代码没有执行到caculateCms()，那么plusGrade的获取就毫无意义，白白浪费一次网络调用。所以，对于变量声明，不仅要见名知意，还要遵守“使用时再声明”，或者“声明后立即使用”。



 用卫函数代替if else 

小册在介绍Optional时，曾经提到过卫函数。所谓卫函数，一句话概括就是“及时return，以避免过深的嵌套”。





Java

复制代码

1

﻿

```
public static String getDepartmentNameOfUser(String username) {
```

2

﻿

```

```

3

﻿

```
    ResultTO<User> resultTO = getUserByName(username);
```

4

﻿

```

```

5

﻿

```
    if (resultTO != null) {
```

6

﻿

```
        User user = resultTO.getData();
```

7

﻿

```
        if (user != null) {
```

8

﻿

```
            Department department = user.getDepartment();
```

9

﻿

```
            if (department != null) {
```

10

﻿

```
                return department.getName();
```

11

﻿

```
            }
```

12

﻿

```
        }
```

13

﻿

```
    }
```

14

﻿

```

```

15

﻿

```
    return "未知部门";
```

16

﻿

```
}
```

像上面这种情况，嵌套就太深了（通常我连双层嵌套都无法忍受），如果每层嵌套中代码量再上去一些，阅读难度就会陡增。此时可以通过卫函数，分步消解：





Java

复制代码

1

﻿

```
public static String getDepartmentNameOfUser(String username) {
```

2

﻿

```
    ResultTO<User> resultTO = getUserByName(username);
```

3

﻿

```
    if (resultTO == null) {
```

4

﻿

```
        return "ResultTO为空";
```

5

﻿

```
    }
```

6

﻿

```
    
```

7

﻿

```
    User user = resultTO.getData();
```

8

﻿

```
    if (user == null) {
```

9

﻿

```
        return "User为空";
```

10

﻿

```
    }
```

11

﻿

```
    
```

12

﻿

```
    Department department = user.getDepartment();
```

13

﻿

```
    if (department == null) {
```

14

﻿

```
        return "Department为空";
```

15

﻿

```
    }
```

16

﻿

```
    
```

17

﻿

```
    return department.getName();
```

18

﻿

```
}
```

大家平时也可以多一个心眼，出现if嵌套时考虑下使用卫函数（特别是参数校验的场景），毕竟我们的大脑更习惯结构化的内容，强行套娃容易把自己搞晕。

网上有很多《求求你，别再用if else了》之类的文章，翻来覆去就那几种方式，有兴趣可以去了解一下。



 像写诗一样换行 

自从新文化运动以后，我们国家开始提倡白话文，为后面的扫盲打下了坚实的基础。现如今，普通人也能自己写诗了，唯一的诀窍就是：换行。





Plain Text

复制代码

1

﻿

```
宝
```

2

﻿

```
今天我去输液了
```

3

﻿

```
输的什么液
```

4

﻿

```
想你的夜
```

换行的好处在于，通过在合适的地方切断信息流，让读者能快速理清行文逻辑。编写代码也是如此，有时只需简单地换行，就能大大地提高可读性。





Java

复制代码

1

﻿

```
private List<RebateItemDetailInfo.ShopScore> getScoreList(ProductDetail productDetail) {
```

2

﻿

```
    // 描述
```

3

﻿

```
    RebateItemDetailInfo.ShopScore descScore = new RebateItemDetailInfo.ShopScore();
```

4

﻿

```
    descScore.setScore(formatScore(productDetail.getDescScore()));
```

5

﻿

```
    descScore.setType(ShopScoreTypeEnum.DESC.getType());
```

6

﻿

```

```

7

﻿

```
    // 服务
```

8

﻿

```
    RebateItemDetailInfo.ShopScore serviceScore = new RebateItemDetailInfo.ShopScore();
```

9

﻿

```
    serviceScore.setScore(formatScore(productDetail.getServiceScore()));
```

10

﻿

```
    serviceScore.setType(ShopScoreTypeEnum.SERVICE.getType());
```

11

﻿

```

```

12

﻿

```
    // 物流
```

13

﻿

```
    RebateItemDetailInfo.ShopScore shipScore = new RebateItemDetailInfo.ShopScore();
```

14

﻿

```
    shipScore.setScore(formatScore(productDetail.getShipScore()));
```

15

﻿

```
    shipScore.setType(ShopScoreTypeEnum.SHIP.getType());
```

16

﻿

```

```

17

﻿

```
    return Lists.newArrayList(descScore, serviceScore, shipScore);
```

18

﻿

```
}
```

哦，对了，刚才那个plusGrade的代码，之所以读起来那么痛苦，其中一个原因就是没换行，甚至一点注释都没有...整个方法只有一个信息流，太大块了！如果想要临时去改一些逻辑，不得不从头到尾理解每个细节，有种你明明不想吃屎，却被强行按着头吃了一口屎的感觉，难受至极。



好的代码，应该可以让阅读它的人立即找到他关心的逻辑，而不是强迫对方去关注无关紧要的细节。



看到这，扪心自问，你写的代码像诗呢，还是像屎呢...



 抽取方法 

当一个方法的行数过多时，简单的换行就显得力不从心了，此时可以考虑抽取方法。抽取方法的核心要点是，把强相关的代码抽取到同一个方法中，保证一个方法只做一件事。假设10~20行都是查询用户信息的，那么就可以抽取出private User getUser(Long uid)。



由于借助IDE很容易就可以做到，这里就不再扩展。但有一点需要特别强调，是关于编码习惯的。很多新手程序员，喜欢一上来就噼里啪啦一顿敲，中间删删改改，代码块移来移去，最终显得异常凌乱。



我个人的习惯是，上来先写好注释：





Java

复制代码

1

﻿

```
/**
```

2

﻿

```
 * 增加用户成长值
```

3

﻿

```
 */
```

4

﻿

```
public boolean upgradeGrowthValue(Long uid, Long iid) {
```

5

﻿

```
    // 用户是否存在
```

6

﻿

```
    
```

7

﻿

```
    // 查询用户等级
```

8

﻿

```
    
```

9

﻿

```
    // 查询当前用户等级对应的成长值比例
```

10

﻿

```
    
```

11

﻿

```
    // 查询商品成长值
```

12

﻿

```
    
```

13

﻿

```
    // 计算实际成长值并更新    
```

14

﻿

```
}
```

有了这个骨架，其实很自然就能写出结构化的代码：





Java

复制代码

1

﻿

```
/**
```

2

﻿

```
 * 增加用户成长值
```

3

﻿

```
 */
```

4

﻿

```
public boolean upgradeGrowthValue(Long uid, Long iid) {
```

5

﻿

```
    // 用户是否存在
```

6

﻿

```
    boolean userExist = checkIfUserExist(uid);
```

7

﻿

```
    if(!userExist) {
```

8

﻿

```
        return false;
```

9

﻿

```
    }
```

10

﻿

```
    
```

11

﻿

```
    // 查询用户等级
```

12

﻿

```
    Integer plusGrade = getUserLevel(uid);
```

13

﻿

```
    
```

14

﻿

```
    // 查询当前用户等级对应的成长值比例
```

15

﻿

```
    Long growthRate = getGrowthRate(plusGrade);
```

16

﻿

```
    
```

17

﻿

```
    // 查询商品成长值
```

18

﻿

```
    Long itemGrowthValue = getItemGrowthValue(iid);
```

19

﻿

```
    
```

20

﻿

```
    // 计算实际成长值并更新 
```

21

﻿

```
    Long finalGrowthValue = calculateGrowth(growthRate, itemGrowthValue);
```

22

﻿

```
    return updateGrowthValue(uid, finalGrowthValue);
```

23

﻿

```
}
```

哪怕有一天你离职了，新同事需要在这基础上调整成长值比例，他只需要关心getGrowthRate()方法即可，根本不用理会其他逻辑。换句话说，他会感谢你没有强行让他吃屎...至于这位新同事会不会让后面的人感到为难，就要看他的职业操守了。如果他接到的需求不是修改逻辑，而是新增逻辑呢？希望他也能记得抽取方法，不要让代码腐败得太快。



有一次我在处理另一个需求，太忙了，没时间对原先写的搜索接口做关键词屏蔽，于是让另一个同事帮忙，不到十分钟他就写好了。等晚上忙完之后，我重新pull代码，发现他写得很清爽：





Java

复制代码

1

﻿

```
@Override
```

2

﻿

```
public ApiResultTO<ItemSearchResTO> execute(ItemSearchReqTO reqTO) {
```

3

﻿

```
    if (Validator.isNullOrEmpty(reqTO.getKeyword())) {
```

4

﻿

```
        return ApiResultTO.buildFailed("请输入关键词");
```

5

﻿

```
    }
```

6

﻿

```
    
```

7

﻿

```
    ItemSearchResTO resTO = new ItemSearchResTO();
```

8

﻿

```
    resTO.setItems(Collections.emptyList());
```

9

﻿

```
    // IOS审核期间，关键词屏蔽（在我的主流程方法里，他只加了3行代码）
```

10

﻿

```
    if (searchForbidden(reqTO.getKeyword())) {
```

11

﻿

```
        return ApiResultTO.buildSuccess(resTO);
```

12

﻿

```
    }
```

13

﻿

```

```

14

﻿

```
    // ... 省略50行
```

15

﻿

```
}
```

16

﻿

```

```

17

﻿

```
private boolean searchForbidden(String keyword) {
```

18

﻿

```
    // 是否IOS审核期间
```

19

﻿

```
    boolean isIos = RebateVersionUtils.isIos();
```

20

﻿

```
    Integer versionNum = RebateVersionUtils.getVersionNum();
```

21

﻿

```
    boolean isIosAuditVersion = isIos && appVersionGrayManager.isAuditVersion(versionNum);
```

22

﻿

```
    if(!isIosAuditVersion) {
```

23

﻿

```
        return false;
```

24

﻿

```
    }
```

25

﻿

```
    
```

26

﻿

```
    // 需要屏蔽的关键词
```

27

﻿

```
    String conf = BconfUtil.getConfValueByPath(BconfConstants.SEARCH_FORBIDDEN_KEYWORDS, null);
```

28

﻿

```
    List<String> searchForbiddenKeywords = Optional.ofNullable(JSON.parseArray(conf, String.class))
```

29

﻿

```
            .orElse(Collections.emptyList());
```

30

﻿

```

```

31

﻿

```
    // 是否包含屏蔽的关键词
```

32

﻿

```
    boolean matchForbiddenKeyword = matchForbiddenKeyword(keyword, searchForbiddenKeywords);
```

33

﻿

```

```

34

﻿

```
    // IOS审核期间 && 关键词被屏蔽
```

35

﻿

```
    if (isIosAuditVersion && matchForbiddenKeyword) {
```

36

﻿

```
        return true;
```

37

﻿

```
    }
```

38

﻿

```
    return false;
```

39

﻿

```
}
```

40

﻿

```

```

41

﻿

```
private boolean matchForbiddenKeyword(String keyword, List<String> searchForbiddenKeywords) {
```

42

﻿

```
    if (Validator.isNullOrEmpty(keyword) || Validator.isNullOrEmpty(searchForbiddenKeywords)) {
```

43

﻿

```
        return false;
```

44

﻿

```
    }
```

45

﻿

```

```

46

﻿

```
    String trimKeyword = keyword.trim();
```

47

﻿

```
    return searchForbiddenKeywords.stream()
```

48

﻿

```
            .anyMatch(forbiddenKeyword ->
```

49

﻿

```
                    forbiddenKeyword.contains(trimKeyword) || trimKeyword.contains(forbiddenKeyword));
```

50

﻿

```
}
```

一个方法最好不要超过80行，甚至50行。平时可以把IDE的字体调大一些（size=14挺舒服的），既能缓解眼疲劳，又能强迫自己不会写出行数超过一个屏幕的方法。

Preferences

EDitor

Font

font

AppearanceBehavior

Showonlymonospacedfonts

MenLo

Font:

Appearance

Size:

14

Keymap

EDitor

Linespacing:

1.2

General

Font

FoRsymbolsnotsupportedbytheMainfont

FaLBackfonT:

<None>

ColorScheme

Enablefontligatures

ColorSCHeMeFont

CONSOLEFont

RestoreDefaults

VCS

![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1057015/1630292679666-c7786d32-d00a-47a6-b8ac-88a069dbd686.png?x-oss-process=image%2Fresize%2Cw_932%2Climit_0)





最后，任何你觉得不是很重要的代码，都可以抽出来，不要占用主流程宝贵的篇幅，比如POJO的set方法：





Java

复制代码

1

﻿

```
public UserTO selectUser(Long uid) {
```

2

﻿

```
    UserDO userDO = userService.selectOne(uid);
```

3

﻿

```
    return buildUserTO(userDO);
```

4

﻿

```
}
```

5

﻿

```

```

6

﻿

```
private UserTO buildUserTO(UserDO userDO) {
```

7

﻿

```
    // setters...
```

8

﻿

```
}
```

又或者，任何你觉得冗余的地方：





Java

复制代码

1

﻿

```
public void method() {
```

2

﻿

```
    // ...
```

3

﻿

```
    if(Validator.isNotNullOrEmpty(activityList)) {
```

4

﻿

```
        for(Activity activity : activityList) {
```

5

﻿

```
            if (isOverlap(reqTO.getGmtBegin(), reqTO.getGmtEnd(), obmActivityBizMapTO.getGmtBegin(),
```

6

﻿

```
                        obmActivityBizMapTO.getGmtEnd())
```

7

﻿

```
                        && !obmActivityBizMapTO.getActivityId().equals(reqTO.getId())
```

8

﻿

```
                        && bizIdList.contains(obmActivityBizMapTO.getBizId())) {
```

9

﻿

```
                    return ServiceResultTO.buildFailed("当前时间段有重复活动在线，活动id" + obmActivityBizMapTO.getActivityId());
```

10

﻿

```
            }
```

11

﻿

```
        }
```

12

﻿

```
    }
```

13

﻿

```
    // ...
```

14

﻿

```
}
```

15

﻿

```

```

16

﻿

```
private boolean isOverlap(Long leftStartTime, Long leftEndTime, Long rightStartTime, Long rightEndTime) {
```

17

﻿

```
    return ((leftStartTime >= rightStartTime)
```

18

﻿

```
            && leftStartTime < rightEndTime)
```

19

﻿

```
            ||
```

20

﻿

```
            ((leftStartTime > rightStartTime)
```

21

﻿

```
                    && leftStartTime <= rightEndTime)
```

22

﻿

```
            ||
```

23

﻿

```
            ((rightStartTime >= leftStartTime)
```

24

﻿

```
                    && rightStartTime < leftEndTime)
```

25

﻿

```
            ||
```

26

﻿

```
            ((rightStartTime > leftStartTime)
```

27

﻿

```
                    && rightStartTime <= leftEndTime);
```

28

﻿

```
}
```

isOverlap()既然抽取了方法，那就干脆抽取得彻底一些：





Java

复制代码

1

﻿

```
public void method() {
```

2

﻿

```
    // ...
```

3

﻿

```
    if(Validator.isNotNullOrEmpty(activityList)) {
```

4

﻿

```
        for(Activity onlineActivity : activityList) {
```

5

﻿

```
            if (timeScheduleConflict(currentActivity, onlineActivity)) {
```

6

﻿

```
                    return ServiceResultTO.buildFailed("当前时间段有重复活动在线，活动id" + obmActivityBizMapTO.getActivityId());
```

7

﻿

```
            }
```

8

﻿

```
        }
```

9

﻿

```
    }
```

10

﻿

```
    // ...
```

11

﻿

```
}
```

12

﻿

```

```

13

﻿

```
boolean timeScheduleConflict(ActivityModifyReqTO current, ActivityBizMapTO online) {
```

14

﻿

```
    boolean beginConflict = online.getGmtBegin() <= current.getGmtBegin() && current.getGmtBegin() <= online.getGmtEnd();
```

15

﻿

```
    boolean endConflict = online.getGmtBegin() <= current.getGmtEnd() && current.getGmtEnd() <= online.getGmtEnd();
```

16

﻿

```
    boolean isSelf = online.getActivityId().equals(current.getId());
```

17

﻿

```
    // 和别的活动时间冲突
```

18

﻿

```
    return (beginConflict || endConflict) && !isSelf;
```

19

﻿

```
}
```



 抽取类 

代码块换行不管用时，需要抽取方法。同样地，当方法重复、膨胀时，你就该考虑这些方法是否可以抽取到类中。比如，可能很多地方都要用到getGrowthValue(Long iid)这个方法，如果每个方法内部都抽取一个getGrowthValue(Long iid)，就太冗余了，后期改动也不方便，甚至会漏改。如果说，抽取方法是结构化编程思维，那么抽取到类，就稍微有点面向对象的味道了。



但是，如果你理解的面向对象就是把方法抽取到类，那就太肤浅了。在文章末尾，我会提出自己的见解。



 少用显式for循环（多使用Java8） 

我已经不止一次推荐大家多多使用Java8了，小册也花费了很多笔墨介绍Java8的诸多特性，特别是Stream API。Stream API都是内部迭代，它的好处是方便将遍历的流程与业务逻辑解耦，让我们能更加专注于业务逻辑的编写（如果你觉得Java8不好用，可能是不够了解它，可以先去复习小册Java8相关章节）。



比如：





Java

复制代码

1

﻿

```
public class StreamTest {
```

2

﻿

```

```

3

﻿

```
    private final static List<Person> personList = ImmutableList.of(
```

4

﻿

```
            new Person("i", 18, "杭州", 999.9),
```

5

﻿

```
            new Person("am", 19, "温州", 777.7),
```

6

﻿

```
            new Person("iron", 21, "杭州", 888.8),
```

7

﻿

```
            new Person("iron", 17, "宁波", 888.8)
```

8

﻿

```
    );
```

9

﻿

```
    
```

10

﻿

```
    public static void main(String[] args) {
```

11

﻿

```
        List<String> suitablePersonNames = filterSuitablePersonNames(List<Person> personList);
```

12

﻿

```
        System.out.println(suitablePersonNames);
```

13

﻿

```
    }
```

14

﻿

```

```

15

﻿

```
    public static List<String> filterSuitablePersonNames(List<Person> personList) {
```

16

﻿

```
        List<String> names = new ArrayList<>();
```

17

﻿

```
        
```

18

﻿

```
        for (Person person : personList) {
```

19

﻿

```
            if (person.getAge() < 18) {
```

20

﻿

```
                continue;
```

21

﻿

```
            }
```

22

﻿

```
            if (!"宁波".equals(person.getAddress())) {
```

23

﻿

```
                continue;
```

24

﻿

```
            }
```

25

﻿

```
            if (names.contains(person.getName())) {
```

26

﻿

```
                continue;
```

27

﻿

```
            }
```

28

﻿

```
            names.add(person.getName());
```

29

﻿

```
        }
```

30

﻿

```

```

31

﻿

```
        return names;
```

32

﻿

```
    }
```

33

﻿

```
}
```

上面这段代码没什么太大问题，但传统的for循环有个弊端：容易暴露过多无关紧要的细节，让人无所适从。还是开头plusGrade那个案例，一个for循环100+行代码，如果你想搞清楚这里头都干了啥，不得不硬着头皮一行行读下去，最差的情况是，里面可能还充斥各种if嵌套、变量随处声明、不换行也不抽取方法，十分蛋疼。这个时候，如果女朋友刚好无理取闹，轻则感情破裂、重则分手边缘。这种毁人幸福的事，还是要少做。



但有了Java8的Stream API后，我们就可以挽回这段感情：





Java

复制代码

1

﻿

```
public class StreamTest {
```

2

﻿

```

```

3

﻿

```
    private final static List<Person> personList = ImmutableList.of(
```

4

﻿

```
            new Person("i", 18, "杭州", 999.9),
```

5

﻿

```
            new Person("am", 19, "温州", 777.7),
```

6

﻿

```
            new Person("iron", 21, "杭州", 888.8),
```

7

﻿

```
            new Person("iron", 17, "宁波", 888.8)
```

8

﻿

```
    );
```

9

﻿

```

```

10

﻿

```
    // Stream API本身具有良好的可读性，filter、map等函数本身就是结构化的
```

11

﻿

```
    public static void main(String[] args) {
```

12

﻿

```
        Set<String> suitablePersonNames = personList.stream()
```

13

﻿

```
                .filter(person.getAge() > 18 && "宁波".equals(person.getAddress()))  // 过滤出年龄大于18 && 来自宁波的
```

14

﻿

```
                .map(Person::getName)                                               // 只要他们的名字
```

15

﻿

```
                .collect(Collectors.toSet());                                       // 收集到set，避免重复
```

16

﻿

```
        
```

17

﻿

```
        System.out.println(suitablePersonNames);
```

18

﻿

```
    }
```

19

﻿

```
}
```

如果条件再复杂些，可以考虑抽取方法：





Java

复制代码

1

﻿

```
public static void main(String[] args) {
```

2

﻿

```
    Set<String> suitablePersonNames = personList.stream()
```

3

﻿

```
            .filter(StreamTest::ageGt18AndFromNingbo)  // 过滤出年龄大于18 && 来自宁波的
```

4

﻿

```
            .map(Person::getName)                      // 只要他们的名字
```

5

﻿

```
            .collect(Collectors.toSet());              // 收集到set，避免重复
```

6

﻿

```

```

7

﻿

```
    System.out.println(suitablePersonNames);
```

8

﻿

```
}
```

9

﻿

```

```

10

﻿

```
private static boolean ageGt18AndFromNingbo(Person person) {
```

11

﻿

```
    return person.getAge() > 18 && "宁波".equals(person.getAddress());
```

12

﻿

```
}
```

是不是逻辑清晰、代码量又少？还是那句话，尽量别给爱你的同事强行喂屎...



当然，Java8可不止Stream API，还有很多好用的新增方法，比如Map的computeIfPresent()、Collection的removeIf()等，使用得当可以帮我们简化一部分冗余的代码：





Java

复制代码

1

﻿

```
public class StreamTest {
```

2

﻿

```

```

3

﻿

```
    private static List<Person> personList = Lists.newArrayList(
```

4

﻿

```
            new Person("i", 18, "杭州", 999.9),
```

5

﻿

```
            new Person("am", 19, "温州", 777.7),
```

6

﻿

```
            new Person("iron", 21, "杭州", 888.8),
```

7

﻿

```
            new Person("iron", 17, "宁波", 888.8)
```

8

﻿

```
    );
```

9

﻿

```

```

10

﻿

```
    public static void main(String[] args) {
```

11

﻿

```
        // 可以避免并发修改异常
```

12

﻿

```
        boolean removed = personList.removeIf(person -> "杭州".equals(person.getAddress()));
```

13

﻿

```
        System.out.println(personList);
```

14

﻿

```
    }
```

15

﻿

```
}
```

最后需要说明的是，在一定条件下（开启并行流或者大数据量）Stream的效率确实要优于普通for/foreach，而一般编程场景中普通for/foreach可能效率更好些。但是，我仍推荐使用Java8，因为可读性是最重要的，而且内存计算0.x毫秒的差距是微不足道的，与其争这点时间，不如多注意网络IO（一次数据库访问是100ms左右）。



 记得打日志 

很多新手程序员，特别是从外包或者小公司出来的同学，都不太喜欢打日志。究其原因，大致有两点考量：

●以前的项目很小，发现bug可以直接本地打断点排查，直接System.out.println()即可，久而久之养成了不打日志的“好习惯”

●担心日志会拖慢性能，能不打就不打



实际上很多大型的项目，比如电商系统，一般来说本地是无法启动的，无论是问题排查还是个人测试，都是直接在预发环境做的，专门去打断点比较浪费时间（公司提供了远程调试，但还是比较麻烦）。退一步讲，线上出现个问题，你难道要和产品说：等我一下，我拉个分支本地去打断点？



至于说打日志会降低性能，大可不必...log的性能损耗微乎其微。



通常来说，自己负责的业务出现问题时，心里基本能猜个八九不离六的，更多时候你只需要验证和排除可能存在的问题。我的习惯是直接打开公司的ELK，搜索代码中的日志关键字，看看出入参，基本就能知道是什么问题。实在定位不了问题，才会拉分支远程调试。



比如产品反馈某个页面的数据没了：

15:16

4G

新人免单

规则

新人首单0元

先下单再返款

KONKA

SBOYA

3.B

蓝月亮

实利电串产

第2步

第3步

第1步

第4步

返佣提现

领券下单

选择商品

确认收货

*下单前先完成授权,才可以同步订单哦

天猫双1

一次性医用口罩医疗三层防护...

医用口罩

单片独立包装

新人补贴￥1.9

片一包千净卫生

医用络锁布

组菌过滤率295%

药脂局认证备案

到手价￥0

去抢购

.0.72跨店满减200减30

赠送

工厂童

运费险

创净不锈钢清洁膏家用厨房洗...

新人补贴￥5.9

不桥钢清洁膏

去抢购

到手价￥0

除桥去垢去除焦痕

邀请好友

GO

![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1057015/1636358480775-77e31745-916b-4aae-8db3-ee901a0ea273.png?x-oss-process=image%2Fresize%2Cw_296%2Climit_0)



那么排查过程是怎样的呢？



先定责：客户端/前端的问题，还是后端接口的问题？抓包发现接口数据确实为空，所以是接口问题。



查看具体接口，发现有日志，于是上ELK查看数据：

获取配置的首单免单商品

47

ListstringitemIdsbconBiz.zerBuytemconfg;

48

Log.info("zerobuyconfigitemIds")

49

50

1/分页获取

51

limititemIds

EitemIds.stream)

list'string>

52

skip((PageInforo.getpagenumageInfoogetpagesize)

53

timit(pageInfoTo.g

etpagesize))

54

collect(Collectors.tolist)

55

Log.info("zerobuypageitemIds:"iiteId)

56

![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1057015/1636357956014-6318c48c-5b0a-43ed-8ff0-f6eaaade8c4a.png?x-oss-process=image%2Fresize%2Cw_710%2Climit_0)



Discover

保存打开共享检查

新洋

刷新

15minutesago

zerobuyconfig

Lucene

now

添加岸运

企

234次市中

ogataah-java-

fa..(便政)

品

自动

Nov7

搜素字段

C

已佛选字段

4c

gan

送定字段

可用于镜

a@tImestemp

15:41:00

15:49:c0

15:38:80

TImE

Nov8202115:52:35.445

na55apo

itomldg

zorabuyconfi

!

type

15LOglevel:INFot

5fa2768157c4822962B319

15:52:35.445hsnmetg

StIMTamp:NavB,2821

Him:271170415:9:

Fanli-monolith-acla5s

15:52:35445

一W:turuetrrseoevicemol.litte

394id:k8alnwBnPgwBIi

docindex:iogstash-java-rf

![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1057015/1636358332861-b00b6425-2774-4bd3-9d67-3dbd497c469b.png?x-oss-process=image%2Fresize%2Cw_1540%2Climit_0)

发现两个log都是有数据的，但是最终返回却没有数据，于是继续往下游追溯：



获取配置的首单免单商品

47

ListstringitemdbconfBiz.zeoBuyitemconfig;

48

Log.info("zerobuyconfigiteIds"I)

49

50

1分页获取

51

ListustringZimititemIdsitemids.stea

52

skip((PageInfoTo.getPagenum1)*agfoo.getagesize)

53

Limit(pageInforo.getpagesize)

54

.colLect(Collectors.tolist)

55

Log.info("zerobuypageitemd:md)

56

57

批量获取商品信息

58

Htbtatethde.

59

RBTETABTCHAUY.TURTETOTUEYBTOO

60

itemCondition.setIte(te)

61

tenConditionPLo

62

returnitemcondition;

63

J):

64

ListsRebatetennfootmaenon

withext:true

withDetail:false);

65

![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1057015/1636358664564-4a43c3b0-2e57-4cfe-95fe-2e632e987cd6.png?x-oss-process=image%2Fresize%2Cw_1065%2Climit_0)



RPC调用后返回emptyList，那么问题肯定在batchQueryItem接口：

126

**

*批量查询商品信息,单次调用最多2条,直接丢弃

127

128

@paramitemConditionLi+m唯确定商品信息

129

*@pa

是否返回扩展信息(优惠券等)

*@paramwithExt

130

是否返回商品详情

*@paramwithDetail

131

132

*@return

*/

133

pbtcUGt:btetmmobt

134

BooLeanwithExt,

135

BooLeanwithDetaiL)

136

137

牛

限制大数据量

138

(itemconditionLtHQUYMAXSZ)

139

Collections.emptylist;

140

return

141

142

批量查询基础商品信息

143

![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1057015/1636358819057-7e051ebe-f1ad-46ab-bd10-5b8c8ca0045a.png?x-oss-process=image%2Fresize%2Cw_1008%2Climit_0)



哦，原来是因为下游出于性能考虑限制了批量请求的数量，而前端并没有按规定分页，直接传了pageSize=100。



所以最后让前端加上分页条件，顺利解决。日志在本次排查中发挥了关键作用 ！





 性能 

很多人以为，代码性能优化很神秘，其实就我个人的体会来说，大部分所谓的性能优化，归根结底就两个原则：

●要么减少IO

●要么减小IO

其中，大部分时候我们会选择减少IO（网络IO)。



 避免循环嵌套 

大家平时可能会尽量避免在Service方法中多次调用DAO方法（代码来自某培训班电商项目）：

publicMapstring,objclodat(Longud)

newHashMapel;

Mapsstring,object>

map

1/根据id查询spu对象

Spusputhis.goodscuientqueryuyId(u);

//查询spudetail

rySpuDetailBySpuId(spuId);

SpuDetailspuDetailthisgoodcqu

查询sku集合

E

Listskuskusthis.goodcint.quySud);

/查询分类

ListiLongcdsAays

Liststringnamesthic

Listlapstring,jcoriwrayli

foR(intioicids.size;++)

Mapsstring,object>categoryMapnwHashMa

categoryMap.put("id"cidge()

categoryMap.put("name",names.get(i);

categories.add(categoryMap)

/查询品牌

Brandbrand-this.brandciur

/查询规格参数组

Listspecoroupgroupsthisspcificationcup

查询特殊的规格参数

searching:false:;

Listspecraramparons-thspcification.ur

generic:nult,

MapkLong,string>par

ngparamMapnewHashMa;

params.forEach(param>

paramMap.put(param.getido),aram.geam

H):

![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1057015/1626600599623-6b5c1f9f-0113-4f51-a9f3-5c0e14edb4b8.png?x-oss-process=image%2Fresize%2Cw_885%2Climit_0)



这种肉眼可见的网络调用，大部分人往往一眼就能看出来。然而，一旦把它们塞到循环语句中，很多人就不敏感了。



举一个实际工作中遇到的案例。有一天测试过来找我，说客户端反应有个素材接口偶尔会超时，导致页面不展示数据。我排查了一下，原来是同事在代码里循环调用了当前素材的分享数：





Java

复制代码

1

﻿

```
List<Material> list = listMaterial();
```

2

﻿

```
list.foreach(material->{
```

3

﻿

```
    Integer shareCount = getShareCount(material.getId()); // 循环调用了分享次数统计SQL
```

4

﻿

```
});
```

于是我对这个接口进行了优化：





Java

复制代码

1

﻿

```
List<Material> list = listMaterial();
```

2

﻿

```
List<Long> materialIds = list.stream().map(Material::getId).collect(Collectors.toList());
```

3

﻿

```
// 批量获取素材对应的分享数
```

4

﻿

```
Map<Long, Integer> materialIdWithShareCount = getShareCount(materialIds);
```

5

﻿

```
list.foreach(material->{
```

6

﻿

```
    // 循环里只做数据匹配，不进行网络调用
```

7

﻿

```
    Integer shareCount = materialIdWithShareCount.getOrDefault(material.getId(), 0);
```

8

﻿

```
});
```

最终接口耗时降了100ms：

应用响应时间

800

600

400

wwwwuuulsw

200

Yu

09:00

08:00

11:00

06:00

10:00

07:00

max代t

p90

p95

p99

![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1057015/1626600843571-ac18b998-1f1b-4cda-a0f6-d060f58c09be.png)



同样地，类似双层for循环调用dao啥的，就更该避免了...

@Override

pubticListPositioc

//一级

ListPosttiontopostionoostelectir

//二级

if(1Collectionutils.iEmpty(sition)

foR(PositionDtopositionDto:positionDtos)

//二级行业

ListF03t

if(lCoLlectionutils.iEmpty(position))

positionDto.setPositiontos(osition)

for(PositionDtosecondaryIndustry:position)

//三级行业

nulL,secondaryIndustry.getcode),u

LIstPosition

t(name:nult,

if(lcoLLectionutiy(nd

secondaryIndustry.setPositi

子

returnpositionDtos;

![图片.png](https://cdn.nlark.com/yuque/0/2021/png/1057015/1626600924838-27c4795f-523c-4acf-adb5-adb98e0e5fe8.png?x-oss-process=image%2Fresize%2Cw_746%2Climit_0)



注意，上面问题的根结是网络IO次数，而不是循环的次数。如果本身不涉及IO，只是内存数据的处理，其实双层for效率也没有差很多（特别是一般分页只有10条）。



 时刻注意非空判断 

空指针是我们一生的宿敌，这个我已经在



[第一回：万恶的空指针](https://www.yuque.com/bravo1988/java/oza69f)

提过了。





 考虑使用缓存 

在合适的地方，考虑使用缓存。而一旦使用缓存，就要做好觉悟：能否接受一定程度的更新延迟，也就是缓存脏读问题。





Java

复制代码

1

﻿

```
@Service
```

2

﻿

```
public class ItemServiceImpl implements ItemService {
```

3

﻿

```

```

4

﻿

```
    @Resource
```

5

﻿

```
    private CacheClient cacheClient;
```

6

﻿

```

```

7

﻿

```
    private static final String ITEM_CACHE_PREFIX = "item:detail:";
```

8

﻿

```

```

9

﻿

```
    /**
```

10

﻿

```
     * 查询商品
```

11

﻿

```
     *
```

12

﻿

```
     * @param itemId   商品id
```

13

﻿

```
     * @param useCache 是否使用缓存
```

14

﻿

```
     * @return
```

15

﻿

```
     */
```

16

﻿

```
    public Item getItem(Long itemId, boolean useCache) {
```

17

﻿

```
        if (!useCache) {
```

18

﻿

```
            return this.doGetItem(itemId);
```

19

﻿

```
        }
```

20

﻿

```

```

21

﻿

```
        String cacheKey = ITEM_CACHE_PREFIX + itemId;
```

22

﻿

```
        String itemJson = cacheClient.get(cacheKey);
```

23

﻿

```
        if (itemJson != null && !"".equals(itemJson)) {
```

24

﻿

```
            // parse and return
```

25

﻿

```
            return JSON.parseObject(itemJson, Item.class);
```

26

﻿

```
        }
```

27

﻿

```

```

28

﻿

```
        // the data is not cached, then query DB and store it
```

29

﻿

```
        Item item = this.doGetItem(itemId);
```

30

﻿

```
        // in case the result is null, put an empty Object into the cache
```

31

﻿

```
        item = Optional.ofNullable(item).orElse(this.createEmptyItem(itemId));
```

32

﻿

```
        cacheClient.cache(cacheKey, item, 60, TimeUnit.SECONDS);
```

33

﻿

```

```

34

﻿

```
        return item;
```

35

﻿

```
    }
```

36

﻿

```

```

37

﻿

```
    private Item doGetItem(Long itemId) {
```

38

﻿

```
        // query DB
```

39

﻿

```
        return null;
```

40

﻿

```
    }
```

41

﻿

```

```

42

﻿

```
    private Item createEmptyItem(Long itemId) {
```

43

﻿

```
        // create an empty item Object
```

44

﻿

```
        return null;
```

45

﻿

```
    }
```

46

﻿

```
}
```



 为常用的SQL添加索引 

参考小册SQL优化章节。



 设计 

最后聊一下代码设计。



 结构化编程与面向对象 

上面提到过，代码多了抽取到方法，方法多了抽取到对象，这是符合一般常识的做法。但是，把方法抽取到对象中就算面向对象编程了吗？个人觉得，面向对象的精髓是多态，也正因为有了多态，才让Java等面向对象的语言具备更多的可玩性，也让代码具备抽象性，更趋于稳定。



比如，原本工程中有个查询外部商品的接口：





Java

复制代码

1

﻿

```
@Service
```

2

﻿

```
public class ItemService {
```

3

﻿

```
    @Resource
```

4

﻿

```
    private TaobaoClient taobaoClient;
```

5

﻿

```
    @Resource
```

6

﻿

```
    private PddClient pddClient;
```

7

﻿

```
    
```

8

﻿

```
    public Item queryItem(String itemId, Integer platform, boolean useCache){
```

9

﻿

```
        // 判断是否使用缓存
```

10

﻿

```
        ...
```

11

﻿

```
            
```

12

﻿

```
        if(PlatformEnum.TAOBAO.getCode().equals(platform)) {
```

13

﻿

```
            // 调用淘宝接口
```

14

﻿

```
        } else if(PlatformEnum.PDD.getCode().equals(platform)) {
```

15

﻿

```
            // 调用拼多多接口
```

16

﻿

```
        }
```

17

﻿

```
        
```

18

﻿

```
        // 缓存商品信息
```

19

﻿

```
        ...
```

20

﻿

```
    }
```

21

﻿

```
}
```

随着对接的第三方平台越来越多，代码开始膨胀（这个Service内部会有两个几乎相同逻辑的外部接口调用流程），于是我们把淘宝和拼多多抽取到对应的类中：





Java

复制代码

1

﻿

```
@Service
```

2

﻿

```
public class TaobaoItemService {
```

3

﻿

```
    @Resource
```

4

﻿

```
    private TaobaoClient taobaoClient;
```

5

﻿

```
    
```

6

﻿

```
    public Item queryItem(String itemId){
```

7

﻿

```
        // 省略具体代码
```

8

﻿

```
    }
```

9

﻿

```
}
```

10

﻿

```

```

11

﻿

```
@Service
```

12

﻿

```
public class PddItemService {
```

13

﻿

```
    @Resource
```

14

﻿

```
    private PddClient pddClient;
```

15

﻿

```
    
```

16

﻿

```
    public Item queryItem(String itemId){
```

17

﻿

```
        // 省略具体代码
```

18

﻿

```
    }
```

19

﻿

```
}
```

一个魔术，最难的不是怎么把东西变没，而是如何把消失的东西变回来。现在淘宝和拼多多被我们拆成两个服务，而我们期望的代码是：





Java

复制代码

1

﻿

```
@Service
```

2

﻿

```
public class ItemService {
```

3

﻿

```
    
```

4

﻿

```
    public Item queryItem(String itemId, Integer platform, boolean useCache){
```

5

﻿

```
        // 判断是否使用缓存
```

6

﻿

```
        ...
```

7

﻿

```

```

8

﻿

```
        // 调用第三方服务（不关心具体的类型）
```

9

﻿

```
        Item item = thirdpartyItemService.queryItem(itemId, platform);
```

10

﻿

```

```

11

﻿

```
        // 缓存商品信息
```

12

﻿

```
        ...
```

13

﻿

```
    }
```

14

﻿

```
}
```

所以，怎么把它们合起来呢？比较可行的处理方案是：





Java

复制代码

1

﻿

```
// 抽取接口
```

2

﻿

```
public interface ThirdPartyItemDetailService {
```

3

﻿

```
    Item queryItem(String itemId);
```

4

﻿

```
}
```

5

﻿

```

```

6

﻿

```
@Service("taobaoItemService")
```

7

﻿

```
public class TaobaoItemServiceImpl implements ThirdPartyItemDetailService {
```

8

﻿

```
    @Resource
```

9

﻿

```
    private TaobaoClient taobaoClient;
```

10

﻿

```
    
```

11

﻿

```
    @Override
```

12

﻿

```
    public Item queryItem(String itemId){
```

13

﻿

```
        // 省略具体代码
```

14

﻿

```
    }
```

15

﻿

```
}
```

16

﻿

```

```

17

﻿

```
@Service("pddItemService")
```

18

﻿

```
public class PddItemServiceImpl implements ThirdPartyItemDetailService {
```

19

﻿

```
    @Resource
```

20

﻿

```
    private PddClient pddClient;
```

21

﻿

```
    
```

22

﻿

```
    @Override
```

23

﻿

```
    public Item queryItem(String itemId){
```

24

﻿

```
        // 省略具体代码
```

25

﻿

```
    }
```

26

﻿

```
}
```

现在策略是有好多种了，怎么用呢？难道还是这样？





Java

复制代码

1

﻿

```
if(PlatformEnum.TAOBAO.getCode().equals(platform)) {
```

2

﻿

```
    // 调用淘宝
```

3

﻿

```
    return taobaoItemService.queryItem(itemId);
```

4

﻿

```
} else if(PlatformEnum.PDD.getCode().equals(platform)) {
```

5

﻿

```
    // 调用拼多多
```

6

﻿

```
    return pddItemService.queryItem(itemId);
```

7

﻿

```
}
```

这不就走回头路了嘛...其实Spring可以帮我们。



很多人都知道@Autowired/@Resource能帮我们自动注入Bean，但实际上Spring不仅能帮我们自动注入单个Bean，还能帮我们注入BeanList、BeanMap。

比如：





Java

复制代码

1

﻿

```
@Autowired
```

2

﻿

```
private List<ItemService> itemServiceList;
```

Spring会把项目中所有实现了ItemService接口的类的实例汇聚到itemServiceList中（不仅实现接口，继承类也行），在我们的案例中，itemServiceList将会包含TaobaoItemService、PddItemService。

如果使用Map注入：





Java

复制代码

1

﻿

```
@Autowired
```

2

﻿

```
private Map<String, ItemService> itemServiceMap;
```

那么itemServiceMap也会被注入，大概是这样：





JSON

复制代码

1

﻿

```
{
```

2

﻿

```
    "taobaoItemService": 淘宝商品服务实例对象,
```

3

﻿

```
    "pddItemService": 拼多多商品服务实例对象,
```

4

﻿

```
}
```

Map的key就是Bean实例的名字（大家可以回到上面看看，我特地在定义TaobaoItemServiceImpl时指定了bean name）。



所以，刚才的案例可以优化为：





Java

复制代码

1

﻿

```
@Slf4j
```

2

﻿

```
@Component
```

3

﻿

```
public class ItemFactory {
```

4

﻿

```

```

5

﻿

```
    // 第一步：Spring帮我们收集了所有实现了ThirdPartyItemDetailService接口的bean
```

6

﻿

```
    @Resource
```

7

﻿

```
    private Map<String, ThirdPartyItemDetailService> itemDetailServiceMap;
```

8

﻿

```

```

9

﻿

```
    public Item queryItem(String itemId, Integer platformCode) {
```

10

﻿

```
        // 第二步：根据platformCode获取PlatformEnum（Enum里定义了taobao、pdd字符串）
```

11

﻿

```
        PlatformEnum platform = PlatformEnum.getSourceKeyByCode(platformCode);
```

12

﻿

```
        
```

13

﻿

```
        // 第三步：拼凑出正确的bean name，比如 taobao+ItemService => taobaoItemService
```

14

﻿

```
        String serviceName = platform.getSourceKey() + "ItemService";
```

15

﻿

```
        
```

16

﻿

```
        // 第四步：从Map中得到对应的service bean
```

17

﻿

```
        ThirdPartyRecommendItemService thirdPartyItemDetailService = itemDetailServiceMap.get(serviceName);
```

18

﻿

```

```

19

﻿

```
        // 查询商品
```

20

﻿

```
        return thirdPartyItemDetailService.queryItem(itemId);
```

21

﻿

```
    }
```

22

﻿

```

```

23

﻿

```
}
```

最终暴露出去的接口：





Java

复制代码

1

﻿

```
@Service
```

2

﻿

```
public class ItemService {
```

3

﻿

```
    @Resource
```

4

﻿

```
    private ItemFactory itemFactory;
```

5

﻿

```
    
```

6

﻿

```
    public Item queryItem(String itemId, Integer platform, boolean useCache){
```

7

﻿

```
        // 判断是否使用缓存
```

8

﻿

```
        ...
```

9

﻿

```

```

10

﻿

```
        // 获取商品（不关心具体平台）
```

11

﻿

```
        Item item = itemFactory.queryItem(itemId, platform);
```

12

﻿

```

```

13

﻿

```
        // 缓存商品信息
```

14

﻿

```
        ...
```

15

﻿

```
    }
```

16

﻿

```
}
```

兰保(工厂获家)

低压核块(节路核式)

GSI汤

@CoTporen:

MuElLEETBNNTERcETPInPeTerkThPArtmetlre

高层拉快

pulslieelesiLeinfacloryt

你esaurec

QSeTiz片

prveleTaoceocLrntkocbsclient:

一步ing+盟

REROurce

phlctmqunierisffingterin.tnmgotflttm.hanlanrh

publefemeucylcrisuirgHarNdrtccopaicnCade

抽索(百向摇口棉理)

二:CdRoET

力博为配保积字

S栏氓长甲

TlettomEnurplttom-flttonEnugelsoucedecosea

依动

依车

puRiteaeT-artEnDetaSarie

低层界妹(羊容快式]

LemgulerISlungiletrar.

Spring

e

软取产品(不关心口体千台)

pserwce:fealensomvte

SLIiRgINAFlalarg-Louko

ltemitem-itenfactory.queryltemtitemd.laom

brreaPdntrislplirewethidalilscric

院四本:从11:p中国.应门iceboen

pweluFduclenlguiclierrt:

Thizpntyheonterdems

GO元TI'E

立

cturnthirtPartylecmtctisiuc

雀未淋1雨

![new pattern.png](https://cdn.nlark.com/yuque/0/2021/png/1057015/1630471813290-63961e78-7d04-4826-851b-6f18e67086b5.png?x-oss-process=image%2Fresize%2Cw_1540%2Climit_0)

上面的结构看起来好像比原先if else要麻烦很多，但整体设计思路已经发生了质的改变，后面有新的平台接入时，只需要新建一个XxxItemServiceImpl并实现接口即可，做到了“以

增量

的方式应对变化的需求”，是符合好的设计原则的（开闭原则）。





这才是面向对象，核心是多态。



 掌握常用的几种设计模式 

部分同学可能不认为上面使用的是工厂模式，但我想说的是，是什么模式不重要，能解决问题就行。很多人，对各种设计模式如数家珍，但实际开发却总是在编写“扁平的代码”，所有的逻辑平铺直叙，拥挤在一个大类中，职责划分不清，各种业务逻辑相互纠缠、盘根错节。



这个时候，我们需要回归设计模式的本质，即：为什么要使用设计模式？



首先，设计模式其实只是对特定语言缺陷的一种补救措施，比如对于Java早期版本来说，策略模式是很有必要的，但随着Lambda表达式的引入，策略模式也慢慢失去了原有的意义（不再需要补救），对于JS等脚本语言来说，干脆天然就支持传递Function（从一开始就不需要补救）。



其次，设计模式的根本目的，其实还是抵御变化，或者减少变化带来的影响。好的设计模式能够阻止或者延缓迭代过程中代码的腐败，让软件的生命周期更加长久。就好比上面的ItemFactory，后面如果对接京东的商品服务，我们只需要另外写一个JdItemService实现ThirdPartyItemDetailService即可。也就是以增量的方式来应对变化的需求，进而达到较为理想的软件管理（符合开闭原则）。



实际开发最常用的设计模式无非策略模式、模板方法模式、工厂模式、责任链模式，反正绝对不会23种都用得上（实际上也不止23种），平时可以多了解一些有用的、常用的。但还是那句话，是什么模式不重要，能解决问题就行。有些模式是不好区分的，也没必要区分。





 小结 

今天看似洋洋洒洒说了很多，其实总结起来就是：要对自己的代码负责，为他人着想。写完代码后自己看一遍，是否通俗易懂。自己都看不懂，别人就更加云里雾里了。总之，不要强行喂人吃屎，话糙理不糙。



对了，文章里提到的很多注意事项，其实装个IDEA插件就能得到提示。人啊，还是要靠外在约束。有时屁事一多，真的很想就这么拉了算了，别人爱吃不吃...阿弥陀佛，罪过罪过。