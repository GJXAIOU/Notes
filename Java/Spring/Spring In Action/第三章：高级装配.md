本章内容：

- Spring profile
- 条件化的 bean 声明
- 自动装配与歧义性
- bean 的作用域
- Spring 表达式语言

3.1、环境与 profile

开发软件的时候，一个很大的挑战就是将应用程序从一个环境迁移到另外一个环境。数据库配置、加密算法以及外部系统的集成是跨环境部署时会发生变化的典型例子

3.1.1、配置 profile bean

Spring 为环境相关的 bean 所提供的解决方案其实与构建时的方案没有太大差别。在这个过程中需要根据环境决定该创建哪个 bean 和不创建哪个 bean
**不过spring并不是构建的时候做这个决策，而是运行时**。这样的结果就是同一个部署单元（可能会是 WAR 文件）能够适用于所有的环境，没有必要重新构建。

==》实现不同环境中的某个 bean 会有所不同。

在 Java 配置中，可以使用@Profile 注解指定某个 bean 属于哪一个 profile：

```
@Configuration
@Profile("dev")
public class DevelopmentProfileConfig {
  @Bean(destroyMethod="shutdown")
  public DataSource dataSource() {
    return new EmbeddedDatabaseBuiler()
         .setType(EmbeddedDatabaseType.H2)
         .addScript("classpath:schema.sql")
         .addScript("classpath:test-data.sql")
         .build(); 
  }  
}
```

@Profile 注解应用在了类级别上。**它会告诉Spring这个配置类中的bean只有在dev profile激活时才会创建**。同时你能还需要一个适用于生成环境的配置。

上面是在类级别上使用@Profile 注解。从 Spring3.2 开始，也可以在方法级别上使用@Profile 注解,与@Bean 注解一起使用。这样的话，就能将这两个 bean 的声明放在同一个配置类中

==》即两种方式：一种方式是按照环境划分，一种按照类来划分；

```java
@Configuration
public class DataSourceConfig{

    @Bean(destroyMethod="shutdown")
    @Profile("dev")
    public DataSource dataSource(){
        return new EmbeddedDatabaseBuilder()
               .addScript("classpath:schema.sqsl")
               .addScript("classpath:test-data.sql")
               .build();
    }

    @Bean
    @Profile("prod")
    public DataSource dataSource(){
       JndiObjectFactoryBean jndi=new JndiObjectFactoryBean();
        jndi.setJndiName("jdbc/myDS");
        jndi.setResourceRef(true);
        jndi.setProxyInterface(javax.sql.DataSource.class);
        return (DataSource) jndi.getObject();
    }
}
```

尽管每个 DataSource bean 都被声明在一个 profile 中，并且只有当规定的 profile 激活时，相应的 bean 才会被创建，但是可能会有其他的 bean 并没有声明在一个给定的 profile 范围内。没有指定 profile 的 bean 始终都会被创建，与激活那个 profile 没有关系。

### 在XML中配置profile

可以通过<beans>元素的 profile 属性，在 XML 中配置 profile bean。也是两种方式，如果全局设置，则在 xml 的根 `<beans>` 元素中指定 profile，或者设置多个子 <beans>，然后在子 <beans> 使用 profile，实现一个 XMl 中存在多种 profile。

```
//dev profile的bean
<beans profile="dev">
    <jdbc:embedded-database id="dataSource">
        <jdbc:script location="classpath:shema.sql" />
        <jdbc:script location="classpath:test-data.sql" />
    </jdbc:embedded-database>
</beans>

//qa profile的bean
<beans profile="qa">
    <bean id="dataSource" 
    class= .../>
</beans>
```

#### 3.1.2、激活profile

Spring 在确定哪个 profile 处于激活状态时，需要依赖两个独立的属性：spring.profiles.active 和 spring.profiles.default
如果设置了 spring.profiles.active 属性的话，它的值就会用来确定哪个 profile 是激活的。如果没有，Spring 将会查找 spring.profiles.default 的值
如果两者均没有设置，那就没有激活的 profile，因此只会创建那些没有定义在 profile 中的 bean

有多种方式来设置这两个属性：

- 作为 DispatcherServlet 的初始化参数
- 作为 web 应用的上下文参数
- 作为 JNDI 条目
- 作为环境变量
- 作为 JVM 的系统属性
- 在集成测试类上，使用@ActiveProfiles 注解设置

```
//在web应用的web.xml文件中设置默认的profile
//为上下文设置默认的profile
<context-param>
    <param-name>spring.profiles.default</param-name>
    <param-value>dev</param-value>
</context-param>

//为Servlet设置默认的profile
<servlet>
  <servlet-name>appServlet</servlet-name>
  <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
  <init-param>
    <param-name>spring.profiles.default</param-name>
    <param-value>dev</param-value>
  </init-param>
  <load-on-startup>1</load-on-startup>
</servlet>
```

Spring 提供了@ActiveProfiles 注解，可以用它来指定运行测试时要激活哪个 profile。在集成测试时，通常想要激活的是开发环境的 profile

```
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes={PersistenceTestConfig.class})
@ActiveProfiles("dev")
public class PersistenceTest {
}
```

### 3.2、条件化的bean

**@Condition注解，它可以用到带有@Bean注解的方法上。**
**如果给定的条件计算结果为true，就会创建这个bean，否则这个bean就会被忽略**

```
@Bean
@Conditional(MagicExistsCondition.class)
public MagicBean magicBean() {
  return new MagicBean();  
}
```

可以看到，@Conditional 中给定了一个 Class，它指明了条件——也就是 MagicExistsCondition
@Conditional 将会通过 Condition 接口进行条件对比：

```
public interface Condition {
  boolean matches(ConditionContext ctxt, AnnotatedTypeMetadata metadata);  
}
```

设置给@Conditional 的类可以是任意实现了 Condition 接口的类型。这个接口实现起来简单直接，只需提供 matches()方法的实现即可

==》条件类需要实现 Condition 接口中的 matches() 方法，当方法返回 true 则创建 @Condition 标识的 Bean；

```
public class MagicExistsCondition implements Condition {
  public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    Environment env = context.getEnvironment();
    return env.containsProperty("magic");
  }  
}
```

ConditionContext 是一个接口，大致如下：

```
public interface ConditionContext {
  BeanDefinitionRegistry getRegistry();
  ConfigurableListableBeanFactory getBeanFactory();
  Environment getEnvironment();
  ResourceLoader getResourceLoader();
  ClassLoader getClassLoader();      
}
```

通过 ConditionContext，我们可以做到如下几点：

- 借助 getRegistry()返回的 BeanDefinitionRegistry 检查 bean 定义
- 借助 getBeanFactory()返回的 ConfigurableListableBeanFactory 检查 bean 是否存在，甚至探查 bean 的属性
- 借助 getEnvironment()返回的 Environment 检查环境变量是否存在以及它的值是什么
- 读取并探查 getResourceLoader()返回的 ResourceLoader 所加载的资源
- 借助 getClassLoader()返回的 ClassLoader 加载并检查类是否存在

AnnotatedTypeMetadata 则能够让我们检查带有@Bean 注解的方法上还有什么其他注解，它也是一个接口：

```
public interface AnnotatedTypeMetadata {
  boolean isAnnotated(String annotationType);
  Map<String, Object> getAnnotationAttributes(String annotationType);
  Map<String, Object> getAnnotationAttributes(String annotationType,boolean classValuesAsString);
  MultiValueMap<String, Object> getAllAnnotationAttributes(String annotationType);
  MultiValueMap<String, Object> getAllAnnotationAttributes(String annotationType, boolean classValuesAsString);  
}
```

借助 isAnnotated()方法，能够判断带有@Bean 注解的方法是不是还有其他特定的注解。
借助其他的那些方法，能够检查@Bean 注解的方法上其他注解的属性

Spring4 开始，对@Profile 注解进行了重构，使其基于@Conditional 和 Condition 实现：

```
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
@Documented
@Conditional(ProfileCondition.class)
public @interface Profile {
  String[] value();    
}
//ProfileCondition检查某个bean profile是否可用
class ProfileCondition implements Condition {
  public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    if (context.getEnvironment() != null) {
      MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
      if (attrs != null) {
        for (Object value : atrrs.get("value")) {
          if (context.getEnvironment().acceptsProfiles(((String[])value))) {
            return true;
          }
        }
        return false;
      }
    }
    return true;    
  }
}    
```

ProfileCondition 通过 AnnotatedTypeMetadata 得到了用于@Profile 注解的所有属性。借助该信息，它会明确检查 value 属性，该属性包含了 bean 的 profile 名称
然后它根据通过 ConditionContext 得到的 Environment 来检查[借助 acceptsProfiles()方法]该 profile 是否处于激活状态

### 3.3、处理自动装配的歧义性

自动装配能够让 Spring 完全负责将 bean 引用注入到构造参数和属性中。

假如我们使用@Autowired 注解标注了 setDessert()方法

```
@Autowired
public void setDessert(Dessert dessert) {
  this.dessert = dessert;  
}
```

本例中，Dessert 是一个接口，且有三个类实现了这个接口，分别为 Cake、Cookies 和 IceCream：

```
@Component
public class Cake implements Dessert { ... }

@Component
public class Cookies implements Dessert { ... }

@Component
public class IceCream implements Dessert { ... }
```

Spring 没有办法识别应该自动装载哪一个，就会抛出 NoUniqueBeanDefinitionException

发生歧义性的时候，可以将可选 bean 中的某一个设置为首先（primary），或使用限定符（qualifier）来帮助 Spring 将可选的 bean 的范围缩小到只有一个 bean

3.3.1、标示首选的 bean——@Primary 注解：它只能标示一个优先的可选方案

```
@Component
@Primary
public class IceCream implements Dessert {...}
```

如果通过 Java 配置显式声明：

```
@Bean
@Primary
public Dessert iceCream() {
  return new IceCream();  
}
```

如果使用 XML 配置 bean：

```
<bean id="iceCream" class="com.desserteater.IceCream" primary="true" />
```

但是使用 @Primary 设置首选 Bean 的问题在于无法将可选方案的范围限定到唯一一个无歧义的选项，它只能标识一个优先的可选范围。

#### 3.3.2、限定自动装配的bean

Spring 的限定符能够在所有可选的 bean 上进行缩小范围的操作，最终能够达到只有一个 bean 满足所规定的限制条件

```
//确保要将IceCream注入到setDessert()之中：
@Autowired
@Qualifier("iceCream")
public void setDessert(Dessert dessert) {
  this.dessert = dessert;  
}
```

为@Qulifier 注解所设置的参数就是想要注入的 bean 的 ID——**基于bean ID作为限定符问题：与要注入的bean的名称是紧耦合的**

==》@Qulifier 所引用的 Bean 要具有 String 类型的 iceCream 作为限定符。但是因为如果没有指定限定符，则每个 bean 都有一个默认限定符（就是 bean 的 id）。

创建自定义的限定符——可以为 bean 设置自己的限定符，而不是依赖于将 bean ID 作为限定符
所要做的就是在 bean 声明上添加@Qualifier 注解。例如，它可以与@Component 组合使用：

```
@Component
@Qualifier("cold")
public class IceCream implements Desserts {...}
```

这种情况下，cold 限定符分配给了 IceCreambean，因为它没有耦合类名，因此可以随意重构 IceCream 的类名。
在注入的地方，只要引用 cold 限定符就可以了：

```
@Autowired
@Qualifier("cold")
public void setDessert(Dessert dessert) {
  this.dessert = dessert;  
}
```

当使用自定义的@Qualifier 值时，最佳实践是为 bean 选择特征性或描述性术语

注意：如果同一个属性提供了多种注入方式，下面就是针对同一个类提供三种实现的注入方式，同时注入的 CompactDisc 实现类也有三个（实现类里打印不同，为了判断最终注入的是那种）。

```java
package org.gjxaiou.beans;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Component;

@Component
public class CDPlayer {
    private CompactDisc compactDisc;

    // 也可以放在属性的 setter 方法上来实现自动装配
    @Autowired
    @Qualifier("compactDiscImpl2")
    public void setCompactDisc(CompactDisc cd) {
        System.out.println("impl2，setter方法");
        this.compactDisc = cd;
    }

    // 构造器上加上 @Autowired,表示当 spring 创建 CDPlayer bean 的时候，会通过这个构造器来进行实例化，并且会传入一个可设置给 CompactDisc 类型的 bean
    @Autowired
    public CDPlayer(CompactDisc cd) {
        System.out.println("impl，构造方法");
        this.compactDisc = cd;
    }

    // 实际上可以放在
    @Autowired
    @Qualifier("compactDiscImpl3")
    public void insertCompact(CompactDisc cd) {
        System.out.println("impl3，任意方法");
        this.compactDisc = cd;
    }

    public void testMethod() {
        compactDisc.play();
    }
}
```

输出为：有的时候任意方法先于 setter 方法注入，导致最终注入的是 setter 方法的实现类，输出就是 Hello2.

```java
impl，构造方法
impl2，setter方法
impl3，任意方法
hello3
Hello World!
```

所以执行顺序如下：

1. 构造注入（Constructor Injection）：Spring 首先会查找带有`@Autowired`、`@Inject`或`@Value`等注解的构造函数，并将相应的依赖项通过构造函数参数进行注入。构造注入是一种强制性的注入方式，因为它确保在 Bean 实例化之后，所有必需的依赖项都已经被注入。
2. Setter 注入（Setter Injection）：如果没有使用构造注入，Spring 将查找带有`@Autowired`、`@Inject`或`@Value`等注解的 setter 方法，并通过这些方法将依赖项注入到 Bean 中。Setter 注入是可选的，因为如果没有 setter 方法，或者没有在 setter 方法上使用相应的注解，Spring 会跳过该步骤。
3. 任意方法注入（Method Injection）：在完成构造注入和 setter 注入后，Spring 会查找带有`@Autowired`、`@Inject`或`@Value`等注解的任意方法，并将依赖项注入到这些方法中。这些方法可以是普通方法，也可以是生命周期回调方法（如`@PostConstruct`注解的方法）。任意方法注入可以用于执行一些特定的初始化逻辑或设置其他依赖项。

总结起来，Spring 在实例化和初始化 Bean 的过程中，首先执行构造注入（如果有相应的注解和构造函数），然后执行 setter 注入（如果有相应的注解和 setter 方法），最后执行任意方法注入（如果有相应的注解和方法）。

在 Spring 中，通常情况下是先执行构造注入，然后执行 setter 注入，最后执行任意方法注入。这是因为构造注入是 Bean 的实例化过程中的一部分，而 setter 注入是在 Bean 实例化之后，对依赖项进行设置的一种方式。因此，构造注入应该在 setter 注入之前完成。

然而，有时候可能会遇到任意方法注入先于 setter 注入的情况。这种情况通常发生在以下两种情形中：

1. 方法注解的执行时机：Spring 的方法注解，例如`@PostConstruct`、`@PreDestroy`等，可以标注在 Bean 的任意方法上，并在 Bean 的初始化和销毁阶段被执行。如果一个 Bean 中有这样的方法注解，并且在该方法上使用了依赖注入的注解（例如`@Autowired`），则这个方法在 Bean 实例化之后会被提前执行，而不是等待 setter 注入之后执行。
2. 循环依赖的解决：当存在循环依赖的情况时，Spring 会采用一种特殊的策略进行解决。在解决循环依赖时，Spring 可能会先通过构造注入创建 Bean 的实例，并提前将该实例暴露给其他 Bean（通过代理或提前暴露未完全初始化的 Bean）。然后，在后续的阶段中，Spring 会完成 setter 注入和任意方法注入。因此，在这种情况下，任意方法注入可能会先于 setter 注入。

需要注意的是，循环依赖是一种设计上的问题，应该尽量避免。尽管 Spring 提供了解决循环依赖的机制，但过多的循环依赖会增加代码的复杂性和维护成本。在设计和组织 Bean 之间的依赖关系时，应该尽量避免出现循环依赖，以确保依赖注入的执行顺序符合预期。



### 3.4、bean的作用域——**@Scope注解**

默认情况，Spring 应用上下文所有 bean 都是单例(singleton)的形式创建的，即不管给定的一个 bean 被注入到其他 bean 多少次，每次所注入的都是同一个实例。
Spring 定义了多种作用域：

- 单例（singleton）：在整个应用中，只创建 bean 的一个实例
- 原型（prototype）：每次注入或者通过 Spring 应用上下文获取的时候，都会创建一个新的 bean 实例
- 会话（session）：在 web 应用中，为每个会话创建一个 bean 实例
- 请求（request）：在 web 应用中，为每个请求创建一个 bean 实例

```
//也可以使用@Scope("prototype")设置原型作用域，当不那么安全
@Component //如果使用组件扫描来发现和什么bean
//@Bean：在java配置中将Notepad声明为原型bean
@Scope(ConfigurabaleBeanFactory.SCOPE_PROTOTYPE)
public class Notepad {...}
```

 同样，如果使用 XML 配置 bean 的话，可以使用<bean>元素的 scope 属性来设置作用域：

```
<bean id="notepad" class="com.myapp.Notepad" scope="prototype" />
```

#### 3.4.1、使用会话和请求作用域

在 web 应用中，如果能够实例化在会话和请求范围内共享的 bean，那将是非常有价值的事情。
如，在电子商务应用中，可能会有一个 bean 代表用户的购物车，如果购物车是单例的话，那么将导致所有的用户都会向同一个购物车中添加商品；

另一方面，如果购物车是原型作用域的，那么应用中某一个地方往购物车中添加商品，在应用的另外一个地方可能就不可用了

就购物车 bean 来说，会话作用域是最为合适的：在当前会话相关操作中，这个 bean 实际上相当于单例的

```
@Component
@Scope(value=WebApplicationContext.SCOPE_SESSION, proxyMode=ScopedProxyMode.INTERFACES)
public ShoppingCart cart() {...}
```

proxyMode=ScopedProxyMode.INTERFACES 这个属性解决了将会话或请求作用域的 bean 注入到单例中所遇到的问题

假如我们要将 ShoppingCart bean 注入到单例 StoreSercice bean 的 Setter 方法中：

```
@Component
public class StoreService {
  @Autowired
  public void setShoppingCart(ShoppingCart shoppingCart) {
    this.shoppingCart = shoppingCart;    
  }    
}
```

因为 StoreService 是一个单例的 bean，会在 Spring 应用上下文加载的时候创建。当它创建的时候，Spring 会试图将 ShoppingCart bean 注入到 setShoppingCart()方法中
但是后者是会话作用域的，此时并不存在，只有某个用户进入系统，创建会话之后，才会出现 ShoppingCart 实例。
另外，系统中将会有多个 ShoppingCart 实例：每个用户一个；我们希望当 StoreService 处理购物车功能时，它所使用的 ShoppingCart 实例恰好是当前会话所对应的那一个

Spring 并不会将实际的 ShoppingCart bean 注入到 StoreService 中，Spring 会注入一个到 ShoppingCart bean 的代理。

这个代理会暴露与 ShoppingCart 相同的方法，所以 StoreService 会认为它就是一个购物车。

但是当 StoreService 调用 ShoppingCart 的方法时，代理会对其进行懒解析并将调用委托给会话作用域内真正的 ShoppingCart bean

ScopedProxyMode.INTERFACES 这个 proxyMode 属性值表明这个代理要实现 ShoppingCart 接口，并将调用委托给实现 bean。

**如果ShoppingCart是接口而不是类的话，这是可以的（也是最理想的代理模式）**，如果它是一个具体的类的话，Spring 就没有办法创建基于接口的代理了。

此时必须使用 CGLib 来生成基于类的代理，要将 proxyMode 设置为：ScopedProxyMode.TARGET_CLASS，表明要以生成目标类扩展的方式创建代理
![img](%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D.resource/286343-20190803140734987-2042752098.png)

3.4.2、在 XML 中声明作用域代理

```
<bean id="cart" class="com.myapp.ShoppingCart" scope="session">
    <aop:scoped-proxy />
</bean>
```

<aop:scoped-proxy>告诉 Spring 为 bean 创建一个作用域代理。默认，它会使用 CGLib 创建目标类的代理，可以要求它生成基于接口的代理：

```
<aop:scoped-proxy proxy-target-class="false" />
```

 

### 3.5、运行时值注入

当讨论依赖注入的时候，通常讨论的是将一个 bean 引用注入到另一个 bean 的属性或构造器参数中。它通常来讲是指的是将一个对象与另一个对象进行关联

但 bean 装配的另外一个方面指的是将一个值注入到 bean 的属性或者构造器参数中

为避免硬编码，想让值在运行时再确定，为了实现这些功能，Spring 提供了两种在运行时求值的方式：

- 属性占位符（Property placeholder）
- Spring 表达式语言（SpEL）

硬编码就是类似：

```java
@Bean
public A dfdf(){
    return new A("dfdf","dfafd");
}
```

### 3.5.1、注入外部的值

处理外部值的最简单方式就是声明属性源并通过 Spring 的 Environment 来检索属性：

```java
//使用@PropertySource注解和Environment
@Configuration
@PropertySource("classpath:/com/soundsystem/app.properties") //声明属性源
public class ExpressiveConfig {
  @Autowired
  Environment env;
    
  @Bean
  public BlankDisc disc() {
    return new BlanDisc(env.getProperty("disc.title"), env.getProperty("disc.artist")); //检索属性值
  }        
}
```

@PropertySource 引用了类路径中一个名为 app.properties 的文件：

```
disc.title=Sgt. Peppers Lonely Hearts Club Band
disc.artist=The Beatles
```

这个属性文件会加载到 Spring 的 Environment 中。稍后可从这里检索属性。同时，在 disc()方法中，会创建一个新的 BlankDisc，它的构造器参数是从属性文件中获取的，
而这是通过调用 getProperty()实现的，它有四个重载的方法：

```
String getProperty(String key)
String getProperty(String key, String defaultValue)
T getProperty(String key, Class<T> type)
T getProperty(String key, Class<T> type, T defaultValue)
```

如果想检查一下某个属性是否存在的话，调用 containsProperty()方法

```
boolean titleExists = env.containsProperty("disc.title");
```

如果想将属性解析为类的话，可以使用 getPropertyAsClass()方法：

```
Class<CompactDisc> cdClass = env.getPropertyAsClass("disc.class", CompactDisc.class);
```

Environment 还提供了一些方法来检查哪些 profile 处于激活状态：

```
String[] getActiveProfiles() //返回激活profile名称的数组
String[] getDefaultProfiles() //返回默认profile名称的数组
boolean acceptsProfiles(String... profiles) //如果environment支持给定profile的话，就返回true
```

 

解析属性占位符

在 Spring 装配中，占位符的形式为使用 ${...} 包装的属性名称：

```
<bean id="sgtPeppers" class="soundsystem.BlankDisc" c:_title="${disc.title}" c:_artist="${disc.artist}" />
```

如果我们依赖于组件扫描和自动装配来创建和初始化应用组件的话，可以使用@Value 注解：

```
public BlankDisc(@Value("${disc.title}" String title, @Value("${disc.artist}") String artist) {
  this.title = title;
  this.artist = artist;    
}
```

为了使用占位符，要配置 PropertySourcesPlaceholderConfigurer。
如下的@Bean 方法在 Java 中配置了 PropertySourcesPlaceholderConfigurer：

```
@Bean
public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {
  return new PropertySourcesPlaceholderConfigurer();  
}
```

如果使用 XML 配置的话，Spring context 命名空间中的<context:propertyplaceholder>元素将会为你生成 PropertySourcesPlaceholderConfigurer bean

3.5.2、使用 Spring 表达式语言进行装配：强大简洁

- 使用 bean 的 ID 来引用 bean
- 调用方法和访问对象的属性
- 对值进行算术、关系和逻辑运算
- 正则表达式匹配
- 集合操作

**SpEL表达式要放到“#{...}”之中**

```
//通过systemProperties对象引用系统属性：
#{systemProperties['disc.title']}
```

注意：不要让你的表达式太智能，否则测试越只要。建议尽可能让表达式保持简洁