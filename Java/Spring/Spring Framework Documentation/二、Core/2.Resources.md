## 2. Resources

This chapter covers how Spring handles resources and how you can work with resources in Spring. It includes the following topics:

本章介绍 Spring 如何处理资源以及如何在 Spring 中使用资源。它包括以下主题：

- [Introduction](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-introduction)
- [The `Resource` Interface](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-resource)
- [Built-in `Resource` Implementations](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-implementations)
- [The `ResourceLoader` Interface](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-resourceloader)
- [The `ResourcePatternResolver` Interface](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-resourcepatternresolver)
- [The `ResourceLoaderAware` Interface](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-resourceloaderaware)
- [Resources as Dependencies](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-as-dependencies)
- [Application Contexts and Resource Paths](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-app-ctx)

### 2.1. Introduction

### 2.1. 介绍

Java’s standard `java.net.URL` class and standard handlers for various URL prefixes, unfortunately, are not quite adequate enough for all access to low-level resources. For example, there is no standardized `URL` implementation that may be used to access a resource that needs to be obtained from the classpath or relative to a `ServletContext`. While it is possible to register new handlers for specialized `URL` prefixes (similar to existing handlers for prefixes such as `http:`), this is generally quite complicated, and the `URL` interface still lacks some desirable functionality, such as a method to check for the existence of the resource being pointed to.

不幸的是，Java 的标准 `java.net.URL` 类和各种 URL 前缀的标准处理程序对于所有对低级资源的访问都不够充分。例如，没有标准的 `URL` 实现可用于访问需要从类路径或相对于 `ServletContext` 获取的资源。虽然可以为专用的 `URL` 前缀注册新的处理程序（类似于 `http:` 等前缀的现有处理程序），但这通常相当复杂，`URL` 接口仍然缺少一些需要的功能，例如检查所指向的资源是否存在的方法。

### 2.2. The `Resource` Interface

### 2.2 `Resource` 接口

Spring’s `Resource` interface located in the `org.springframework.core.io.` package is meant to be a more capable interface for abstracting access to low-level resources. The following listing provides an overview of the `Resource` interface. See the [`Resource`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/io/Resource.html) javadoc for further details.

Spring 的 `Resource` 接口位于 `org.springframework.core.io.` 包，是一个更强大的接口，用于抽象对低级资源的访问。下表概述了 `Resource` 接口。请参阅 [`Resource`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/io/Resource.html) javadoc 获取更多详细信息。

```java
public interface Resource extends InputStreamSource {

    boolean exists();

    boolean isReadable();

    boolean isOpen();

    boolean isFile();

    URL getURL() throws IOException;

    URI getURI() throws IOException;

    File getFile() throws IOException;

    ReadableByteChannel readableChannel() throws IOException;

    long contentLength() throws IOException;

    long lastModified() throws IOException;

    Resource createRelative(String relativePath) throws IOException;

    String getFilename();

    String getDescription();
}
```

As the definition of the `Resource` interface shows, it extends the `InputStreamSource` interface. The following listing shows the definition of the `InputStreamSource` interface:

正如 `Resource` 接口的定义所示，它实现了 `InputStreamSource` 接口。下表显示了 `InputStreamSource`接口的定义：

```java
public interface InputStreamSource {

    InputStream getInputStream() throws IOException;
}
```

Some of the most important methods from the `Resource` interface are:

- `getInputStream()`: Locates and opens the resource, returning an `InputStream` for reading from the resource. It is expected that each invocation returns a fresh `InputStream`. It is the responsibility of the caller to close the stream.
- `exists()`: Returns a `boolean` indicating whether this resource actually exists in physical form.
- `isOpen()`: Returns a `boolean` indicating whether this resource represents a handle with an open stream. If `true`, the `InputStream` cannot be read multiple times and must be read once only and then closed to avoid resource leaks. Returns `false` for all usual resource implementations, with the exception of `InputStreamResource`.
- `getDescription()`: Returns a description for this resource, to be used for error output when working with the resource. This is often the fully qualified file name or the actual URL of the resource.

**`Resource` 接口的一些最重要的方法是：**

- `getInputStream()`：查找并打开资源，返回一个 `InputStream` 以从资源中读取。每个调用都会返回一个新的 `InputStream`。**调用方负责关闭流**。
- `exists()`：返回一个 `boolean`，指示此资源是否实际以物理形式存在。
- `isOpen()`：返回一个 `boolean`，指示此资源是否表示具有开放流的句柄。如果 `true`，则 `InputStream` 不能被多次读取，必须只读取一次，然后关闭以避免资源泄漏。对于所有常见的资源实现返回 `false`，`InputStreamResource` 除外。
- `getDescription()`：返回此资源的描述，用于处理资源时的错误输出。这**通常是资源的完全限定文件名或实际 URL**。

Other methods let you obtain an actual `URL` or `File` object representing the resource (if the underlying implementation is compatible and supports that functionality).

Some implementations of the `Resource` interface also implement the extended [`WritableResource`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/io/WritableResource.html) interface for a resource that supports writing to it.

Spring itself uses the `Resource` abstraction extensively, as an argument type in many method signatures when a resource is needed. Other methods in some Spring APIs (such as the constructors to various `ApplicationContext` implementations) take a `String` which in unadorned or simple form is used to create a `Resource` appropriate to that context implementation or, via special prefixes on the `String` path, let the caller specify that a specific `Resource` implementation must be created and used.

While the `Resource` interface is used a lot with Spring and by Spring, it is actually very convenient to use as a general utility class by itself in your own code, for access to resources, even when your code does not know or care about any other parts of Spring. While this couples your code to Spring, it really only couples it to this small set of utility classes, which serves as a more capable replacement for `URL` and can be considered equivalent to any other library you would use for this purpose.

其他方法允许您获取表示资源的实际 `URL` 或 `File` 对象（如果底层实现兼容并支持该功能）。

`Resource` 接口的一些实现还实现了扩展的 [`writeableresource`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/io/WritableResource.html) 支持写入的资源的接口。

Spring 本身广泛使用 `Resource` 抽象，当需要资源时，它在许多方法签名中作为参数类型。某些 Spring API 中的其他方法（如各种 `ApplicationContext` 实现的构造函数）采用 `String`，它以未经修饰或简单的形式用于创建适合该上下文实现的 `Resource`，或者通过 `String` 路径上的特殊前缀，让调用方指定必须创建和使用特定的 `Resource` 实现。

虽然 Spring 和 Spring 经常使用 `Resource` 接口，但实际上，在您自己的代码中单独使用它作为一个通用实用程序类来访问资源非常方便，即使您的代码不知道或不关心 Spring 的任何其他部分。虽然这会将您的代码耦合到 Spring，但实际上它只会将代码耦合到这一小部分实用程序类，而这些实用程序类可以作为 `URL` 的更强大的替代品，并且可以被视为等同于用于此目的的任何其他库。

>  The `Resource` abstraction does not replace functionality. It wraps it where possible. For example, a `UrlResource` wraps a URL and uses the wrapped `URL` to do its work.
>
> `Resource` 抽象并不能取代功能。它尽可能地把它包起来。例如，`UrlResource` 包装一个 URL，并使用包装的 `URL` 进行工作。

### 2.3. Built-in `Resource` Implementations

### 2.3. 内置的 `Resource` 实现

Spring includes several built-in `Resource` implementations:

Spring 包括几个内置的 `Resource` 实现：

- [`UrlResource`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-implementations-urlresource)
- [`ClassPathResource`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-implementations-classpathresource)
- [`FileSystemResource`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-implementations-filesystemresource)
- [`PathResource`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-implementations-pathresource)
- [`ServletContextResource`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-implementations-servletcontextresource)
- [`InputStreamResource`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-implementations-inputstreamresource)
- [`ByteArrayResource`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-implementations-bytearrayresource)

For a complete list of `Resource` implementations available in Spring, consult the "All Known Implementing Classes" section of the [`Resource`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/io/Resource.html) javadoc.

有关 Spring 中可用的 `Resource` 实现的完整列表，请参阅[`Resource`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/io/Resource.html) 的 javadoc 中的「所有已知实现类」部分。

#### 2.3.1. `UrlResource`

`UrlResource` wraps a `java.net.URL` and can be used to access any object that is normally accessible with a URL, such as files, an HTTPS target, an FTP target, and others. All URLs have a standardized `String` representation, such that appropriate standardized prefixes are used to indicate one URL type from another. This includes `file:` for accessing filesystem paths, `https:` for accessing resources through the HTTPS protocol, `ftp:` for accessing resources through FTP, and others.

A `UrlResource` is created by Java code by explicitly using the `UrlResource` constructor but is often created implicitly when you call an API method that takes a `String` argument meant to represent a path. For the latter case, a JavaBeans `PropertyEditor` ultimately decides which type of `Resource` to create. If the path string contains a well-known (to property editor, that is) prefix (such as `classpath:`), it creates an appropriate specialized `Resource` for that prefix. However, if it does not recognize the prefix, it assumes the string is a standard URL string and creates a `UrlResource`.

`UrlResource` 包装了一个 `java.net.URL`，可用于访问通常可以通过 URL 访问的任何对象，如文件、HTTPS 目标、FTP 目标等。所有 URL 都有一个标准化的 `String` 表示，因此使用适当的标准化前缀来表示不同的 URL 类型。这包括用于访问文件系统路径的`file:`，`https:` 用于通过 https 协议访问资源的，`ftp:` 用于通过 ftp 访问资源的等。

**`UrlResource` 是由 Java 代码显式使用 `UrlResource` 构造函数创建的，但通常在调用 API 方法时隐式创建，该方法采用表示路径的 `String` 参数。对于后一种情况，JavaBeans 的 `PropertyEdit` 最终决定创建哪种类型的 `Resource`。如果路径字符串包含一个众所周知的前缀（即属性编辑器的前缀），则它会为该前缀创建一个适当的专用“资源”。但是，如果它不识别前缀，则会假定该字符串是标准 URL 字符串，并创建一个 `UrlResource`。**

#### 2.3.2. `ClassPathResource`

This class represents a resource that should be obtained from the classpath. It uses either the thread context class loader, a given class loader, or a given class for loading resources.

This `Resource` implementation supports resolution as a `java.io.File` if the class path resource resides in the file system but not for classpath resources that reside in a jar and have not been expanded (by the servlet engine or whatever the environment is) to the filesystem. To address this, the various `Resource` implementations always support resolution as a `java.net.URL`.

A `ClassPathResource` is created by Java code by explicitly using the `ClassPathResource` constructor but is often created implicitly when you call an API method that takes a `String` argument meant to represent a path. For the latter case, a JavaBeans `PropertyEditor` recognizes the special prefix, `classpath:`, on the string path and creates a `ClassPathResource` in that case.

此类表示应从类路径获取的资源。它使用线程上下文类加载器、给定类加载器或给定类来加载资源。

如果类路径资源驻留在文件系统中，而不是驻留在 jar 中且未（通过 servlet 引擎或任何环境）扩展到文件系统的类路径资源，则此 `Resource` 实现支持将其解析为 `java.io.File`。为了解决这个问题，各种 `Resource` 实现始终支持将解析作为 `java.net.URL` 的实现。

`ClassPathResource` 是由 Java 代码显式使用 `ClassPathResource` 构造函数创建的，但通常在调用 API 方法时隐式创建，该方法采用表示路径的 `String` 参数。对于后一种情况，**JavaBeans `PropertyEdit` 识别字符串路径上的特殊前缀`classpath:`，并在这种情况下创建一个 `ClassPathResource`。**

#### 2.3.3. `FileSystemResource`

This is a `Resource` implementation for `java.io.File` handles. It also supports `java.nio.file.Path` handles, applying Spring’s standard String-based path transformations but performing all operations via the `java.nio.file.Files` API. For pure `java.nio.path.Path` based support use a `PathResource` instead. `FileSystemResource` supports resolution as a `File` and as a `URL`.

这是一个 `java.io.File` 句柄的 `Resource` 实现。它还支持 `java.nio.file.Path` 句柄，应用 Spring 标准的基于字符串的路径转换，但通过 `java.nio.file.Files` API 执行所有操作。对于纯粹基于 `java.nio.path.Path` 的支持，请改用`PathResource`，`FileSystemResource` 支持解析为 `File` 和 `URL`。

#### 2.3.4. `PathResource`

This is a `Resource` implementation for `java.nio.file.Path` handles, performing all operations and transformations via the `Path` API. It supports resolution as a `File` and as a `URL` and also implements the extended `WritableResource` interface. `PathResource` is effectively a pure `java.nio.path.Path` based alternative to `FileSystemResource` with different `createRelative` behavior.

这是 `java.nio.file.Path` 句柄的 `Resource` 实现，通过 `Path` API 执行所有操作和转换。它支持解析为 `File` 和 `URL`，还实现了扩展的 `WritableResource` 接口 `PathResource` 实际上是一个纯基于 `java.nio.path.Path` 的替代品，它具有不同的 `createRelative` 行为。

#### 2.3.5. `ServletContextResource`

This is a `Resource` implementation for `ServletContext` resources that interprets relative paths within the relevant web application’s root directory.

It always supports stream access and URL access but allows `java.io.File` access only when the web application archive is expanded and the resource is physically on the filesystem. Whether or not it is expanded and on the filesystem or accessed directly from the JAR or somewhere else like a database (which is conceivable) is actually dependent on the Servlet container.

这是 `ServletContext` 资源的 `Resource` 实现，用于解释相关 web 应用程序根目录中的相对路径。

它始终支持流访问和 URL 访问，但仅当 web 应用程序存档已扩展且资源实际位于文件系统上时才允许 `java.io.File` 访问。它是否被扩展并放在文件系统上，或者直接从 JAR 或其他地方（比如数据库）访问（这是可以想象的），实际上取决于 Servlet 容器。

#### 2.3.6. `InputStreamResource`

An `InputStreamResource` is a `Resource` implementation for a given `InputStream`. It should be used only if no specific `Resource` implementation is applicable. In particular, prefer `ByteArrayResource` or any of the file-based `Resource` implementations where possible.

In contrast to other `Resource` implementations, this is a descriptor for an already-opened resource. Therefore, it returns `true` from `isOpen()`. Do not use it if you need to keep the resource descriptor somewhere or if you need to read a stream multiple times.

`InputStreamResource` 是给定 `InputStream` 的 `Resource` 实现。只有在不适用具体的 `Resource` 实施时，才应使用它。**特别是，如果可能的话，更喜欢 `ByteArrayResource` 或任何基于文件的 `Resource` 实现。**

与其他 `Resource` 实现不同，这是一个已打开资源的描述符。因此，它从 `isOpen()` 返回 `true`。如果需要将资源描述符保留在某个位置，或者需要多次读取流，请不要使用它。

#### 2.3.7. `ByteArrayResource`

This is a `Resource` implementation for a given byte array. It creates a `ByteArrayInputStream` for the given byte array.

It is useful for loading content from any given byte array without having to resort to a single-use `InputStreamResource`.

这是给定字节数组的 `Resource` 实现。它为给定的字节数组创建一个 `ByteArrayInputStream`。

它对于从任何给定的字节数组加载内容非常有用，而不必求助于单次使用 `InputStreamResource`。

### 2.4. The `ResourceLoader` Interface

### 2.4. `ResourceLoader` 接口

The `ResourceLoader` interface is meant to be implemented by objects that can return (that is, load) `Resource` instances. The following listing shows the `ResourceLoader` interface definition:

`ResourceLoader` 接口是由可以返回（即加载）`Resource` 实例的对象实现的。以下列表显示了 `ResourceLoader` 接口定义：

```java
public interface ResourceLoader {

    Resource getResource(String location);

    ClassLoader getClassLoader();
}
```

All application contexts implement the `ResourceLoader` interface. Therefore, all application contexts may be used to obtain `Resource` instances.

When you call `getResource()` on a specific application context, and the location path specified doesn’t have a specific prefix, you get back a `Resource` type that is appropriate to that particular application context. For example, assume the following snippet of code was run against a `ClassPathXmlApplicationContext` instance:

**所有应用程序上下文都实现 `ResourceLoader` 接口。因此，所有应用程序上下文都可用于获取 `Resource`实例**。

在特定的应用程序上下文上调用 `getResource()` 时，如果指定的位置路径没有特定的前缀，则会返回适合该特定应用程序上下文的 `Resource` 类型。例如，假设以下代码片段是针对 `ClassPathXmlApplicationContext` 实例运行的：

```java
Resource template = ctx.getResource("some/resource/path/myTemplate.txt");
```

Against a `ClassPathXmlApplicationContext`, that code returns a `ClassPathResource`. If the same method were run against a `FileSystemXmlApplicationContext` instance, it would return a `FileSystemResource`. For a `WebApplicationContext`, it would return a `ServletContextResource`. It would similarly return appropriate objects for each context.

As a result, you can load resources in a fashion appropriate to the particular application context.

On the other hand, you may also force `ClassPathResource` to be used, regardless of the application context type, by specifying the special `classpath:` prefix, as the following example shows:

对于 `ClassPathXmlApplicationContext`，该代码返回 `ClassPathResource`。如果对 `FileSystemXmlApplicationContext` 实例运行相同的方法，它将返回 `FileSystemResource`。对于 `WebApplicationContext`，它将返回 `ServletContextResource`。它同样会为每个上下文返回适当的对象。

因此，您可以按照适合特定应用程序上下文的方式加载资源。

另一方面，您也可以通过指定特殊的 `classpath:` 前缀 强制使用 `ClassPathResource`，而不管应用程序上下文类型如何，如下例所示：

```java
Resource template = ctx.getResource("classpath:some/resource/path/myTemplate.txt");
```

Similarly, you can force a `UrlResource` to be used by specifying any of the standard `java.net.URL` prefixes. The following examples use the `file` and `https` prefixes:

同样，您可以通过指定任何标准的 `java.net.URL` 前缀来强制使用 `UrlResource`。以下示例使用 `file` 和 `https` 前缀：

```java
Resource template = ctx.getResource("file:///some/resource/path/myTemplate.txt");
```

```java
Resource template = ctx.getResource("https://myhost.com/resource/path/myTemplate.txt");
```

The following table summarizes the strategy for converting `String` objects to `Resource` objects:

下表总结了将 `String` 对象转换为 `Resource` 对象的策略：

| Prefix     | Example                          | Explanation                                                  |
| :--------- | :------------------------------- | :----------------------------------------------------------- |
| classpath: | `classpath:com/myapp/config.xml` | Loaded from the classpath.                                   |
| file:      | `file:///data/config.xml`        | Loaded as a `URL` from the filesystem. See also [`FileSystemResource` Caveats](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-filesystemresource-caveats). |
| https:     | `https://myserver/logo.png`      | Loaded as a `URL`.                                           |
| (none)     | `/data/config.xml`               | Depends on the underlying `ApplicationContext`.              |

### 2.5. The `ResourcePatternResolver` Interface

### 2.5.5 `ResourcePatternResolver` 接口

The `ResourcePatternResolver` interface is an extension to the `ResourceLoader` interface which defines a strategy for resolving a location pattern (for example, an Ant-style path pattern) into `Resource` objects.

`ResourcePatternResolver` 接口是 `ResourceLoader` 接口的扩展，该接口定义了将位置模式（例如，Ant 样式的路径模式）解析为 `Resource` 对象的策略。

```java
public interface ResourcePatternResolver extends ResourceLoader {

    String CLASSPATH_ALL_URL_PREFIX = "classpath*:";

    Resource[] getResources(String locationPattern) throws IOException;
}
```

As can be seen above, this interface also defines a special `classpath*:` resource prefix for all matching resources from the class path. Note that the resource location is expected to be a path without placeholders in this case — for example, `classpath*:/config/beans.xml`. JAR files or different directories in the class path can contain multiple files with the same path and the same name. See [Wildcards in Application Context Constructor Resource Paths](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-app-ctx-wildcards-in-resource-paths) and its subsections for further details on wildcard support with the `classpath*:` resource prefix.

A passed-in `ResourceLoader` (for example, one supplied via [`ResourceLoaderAware`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-resourceloaderaware) semantics) can be checked whether it implements this extended interface too.

`PathMatchingResourcePatternResolver` is a standalone implementation that is usable outside an `ApplicationContext` and is also used by `ResourceArrayPropertyEditor` for populating `Resource[]` bean properties. `PathMatchingResourcePatternResolver` is able to resolve a specified resource location path into one or more matching `Resource` objects. The source path may be a simple path which has a one-to-one mapping to a target `Resource`, or alternatively may contain the special `classpath*:` prefix and/or internal Ant-style regular expressions (matched using Spring’s `org.springframework.util.AntPathMatcher` utility). Both of the latter are effectively wildcards.

如上所述，该接口还为类路径中的所有匹配资源定义了一个特殊的 `classpath*:` 资源前缀。请注意，在这种情况下，资源位置应该是没有占位符的路径 — 例如，`classpath*:/config/beans.xml`。JAR 文件或类路径中的不同目录可以包含具有相同路径和相同名称的多个文件。请参阅[应用程序上下文构造函数资源路径中的通配符](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-app-ctx-wildcards-in-resource-paths)及其子部分，以获取有关使用 `classpath*:` 资源前缀的通配符支持的更多详细信息。

传入的 `ResourceLoader`（例如，通过[`ResourceLoaderWare`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-resourceloaderaware) 提供的一个语义）可以检查它是否也实现了这个扩展接口。
`PathMatchingResourcePatternResolver`是一个独立的实现，可在 `ApplicationContext` 外部使用，也可由 `ResourceArrayPropertyEditor`用于填充 `Resource[]` bean属性。

`PathMatchingResourcePatternResolver`能够将指定的资源位置路径解析为一个或多个匹配的 `resource` 对象。源路径可以是一个简单的路径，它具有到目标 `Resource` 的一对一映射，或者可以包含特殊的 `classpath*:` 前缀和/或内部 Ant 样式的正则表达式（使用 Spring 的 `org.springframework.util.AntPathMatcher` 实用程序进行匹配）。后者实际上都是通配符。

>  The default `ResourceLoader` in any standard `ApplicationContext` is in fact an instance of `PathMatchingResourcePatternResolver` which implements the `ResourcePatternResolver` interface. The same is true for the `ApplicationContext` instance itself which also implements the `ResourcePatternResolver` interface and delegates to the default `PathMatchingResourcePatternResolver`.
>
> 任何标准 `ApplicationContext` 中的默认 `ResourceLoader` 实际上是 `PathMatchingResourcePatternResolver` 的实例，它实现了 `ResourcePatternResolver` 接口。 `ApplicationContext` 实例本身也是如此，它还实现了 `ResourcePatternResolver` 接口并委托给默认的 `PathMatchingResourcePatternResolver`。

### 2.6. The `ResourceLoaderAware` Interface

### 2.6. `ResourceLoaderAware` 接口

The `ResourceLoaderAware` interface is a special callback interface which identifies components that expect to be provided a `ResourceLoader` reference. The following listing shows the definition of the `ResourceLoaderAware` interface:

`ResourceLoaderWare` 接口是一个特殊的回调接口，用于标识希望提供 `ResourceLoader` 引用的组件。下表显示了`ResourceLoaderWare` 接口的定义：

```java
public interface ResourceLoaderAware {

    void setResourceLoader(ResourceLoader resourceLoader);
}
```

When a class implements `ResourceLoaderAware` and is deployed into an application context (as a Spring-managed bean), it is recognized as `ResourceLoaderAware` by the application context. The application context then invokes `setResourceLoader(ResourceLoader)`, supplying itself as the argument (remember, all application contexts in Spring implement the `ResourceLoader` interface).

Since an `ApplicationContext` is a `ResourceLoader`, the bean could also implement the `ApplicationContextAware` interface and use the supplied application context directly to load resources. However, in general, it is better to use the specialized `ResourceLoader` interface if that is all you need. The code would be coupled only to the resource loading interface (which can be considered a utility interface) and not to the whole Spring `ApplicationContext` interface.

In application components, you may also rely upon autowiring of the `ResourceLoader` as an alternative to implementing the `ResourceLoaderAware` interface. The *traditional* `constructor` and `byType` autowiring modes (as described in [Autowiring Collaborators](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire)) are capable of providing a `ResourceLoader` for either a constructor argument or a setter method parameter, respectively. For more flexibility (including the ability to autowire fields and multiple parameter methods), consider using the annotation-based autowiring features. In that case, the `ResourceLoader` is autowired into a field, constructor argument, or method parameter that expects the `ResourceLoader` type as long as the field, constructor, or method in question carries the `@Autowired` annotation. For more information, see [Using `@Autowired`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-autowired-annotation).

当类实现 `ResourceLoaderWare` 并部署到应用程序上下文（作为 Spring 管理的 bean）中时，应用程序上下文会将其识别为 `ResourceLoaderWare`。然后，应用程序上下文调用 `setResourceLoader(ResourceLoader)`，将自身作为参数提供（请记住，Spring 中的所有应用程序上下文都实现`ResourceLoader`接口）。

由于 `ApplicationContext` 是 `ResourceLoader`，bean 还可以实现 `ApplicationContextAware` 接口，并直接使用提供的应用程序上下文来加载资源。但是，一般来说，如果您只需要专用的 `ResourceLoader` 接口，则最好使用该接口。代码将只耦合到资源加载接口（可以认为是一个实用程序接口），而不是整个Spring `ApplicationContext`接口。

在应用程序组件中，您还可以依赖`ResourceLoader`的自动装配来替代 `ResourceLoaderWare` 接口的实现。传统`constructor`和`byType`自动关联模式（如[autowiring Collaborators](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire)中所述）能够分别为构造函数参数或 setter 方法参数提供`ResourceLoader`。为了获得更大的灵活性（包括自动关联字段和多参数方法的能力），考虑使用基于注释的自动生成特征。在这种情况下，`ResourceLoader` 自动连接到一个字段、构造函数参数或方法参数中，只要该字段、构造函数或方法带有 `@autowired` 注释，该字段、构造函数参数或方法参数就需要 `ResourceLoader` 类型。有关详细信息，请参阅[使用@Autowired](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-autowired-annotation)。

>  To load one or more `Resource` objects for a resource path that contains wildcards or makes use of the special `classpath*:` resource prefix, consider having an instance of [`ResourcePatternResolver`](https://docs.spring.io/spring-framework/docs/5.3.13-SNAPSHOT/reference/html/core.html#resources-resourcepatternresolver) autowired into your application components instead of `ResourceLoader`.
>
>  若要为包含通配符的资源路径加载一个或多个 `Resource` 对象，或使用特殊的`classpath*:`资源前缀，请考虑具有[RealCopeTrutnRelver](https://docs.spring.io/spring-framework/docs/5.3.13-SNAPSHOT/reference/html/core.html#resources-resourcepatternresolver) 的实例自动装配到应用程序组件中，而不是 `ResourceLoader`。

### 2.7. Resources as Dependencies

### 2.7. Resources 作为依赖项

If the bean itself is going to determine and supply the resource path through some sort of dynamic process, it probably makes sense for the bean to use the `ResourceLoader` or `ResourcePatternResolver` interface to load resources. For example, consider the loading of a template of some sort, where the specific resource that is needed depends on the role of the user. If the resources are static, it makes sense to eliminate the use of the `ResourceLoader` interface (or `ResourcePatternResolver` interface) completely, have the bean expose the `Resource` properties it needs, and expect them to be injected into it.

What makes it trivial to then inject these properties is that all application contexts register and use a special JavaBeans `PropertyEditor`, which can convert `String` paths to `Resource` objects. For example, the following `MyBean` class has a `template` property of type `Resource`.

如果 bean 本身要通过某种动态过程来确定和提供资源路径，那么 bean 使用 `ResourceLoader` 或 `ResourcePatternResolver`接口来加载资源可能是有意义的。例如，考虑某种类型的模板的加载，其中所需的特定资源取决于用户的角色。如果资源是静态的，那么完全取消 `ResourceLoader`接口（或 `ResourcePatternResolver` 接口）的使用是有意义的，让 bean 公开它所需要的 `Resource` 属性，并期望它们被注入其中。

然后注入这些属性的简单之处在于，所有应用程序上下文都注册并使用一个特殊的 JavaBeans `PropertyEditor`，它可以将 `String` 路径转换为 `Resource` 对象。例如，下面的 `MyBean` 类具有 `Resource` 类型的 `template`属性。

```java
package example;

public class MyBean {

    private Resource template;

    public setTemplate(Resource template) {
        this.template = template;
    }

    // ...
}
```

In an XML configuration file, the `template` property can be configured with a simple string for that resource, as the following example shows:

在 XML 配置文件中，可以使用该资源的简单字符串配置 `template` 属性，如下例所示：

```xml
<bean id="myBean" class="example.MyBean">
    <property name="template" value="some/resource/path/myTemplate.txt"/>
</bean>
```

Note that the resource path has no prefix. Consequently, because the application context itself is going to be used as the `ResourceLoader`, the resource is loaded through a `ClassPathResource`, a `FileSystemResource`, or a `ServletContextResource`, depending on the exact type of the application context.

If you need to force a specific `Resource` type to be used, you can use a prefix. The following two examples show how to force a `ClassPathResource` and a `UrlResource` (the latter being used to access a file in the filesystem):

请注意，资源路径没有前缀。因此，由于应用程序上下文本身将用作 `ResourceLoader`，因此根据应用程序上下文的确切类型，通过 `ClassPathResource`、`FileSystemResource` 或 `ServletContextResource`加载资源。

如果需要强制使用特定的 `Resource`类型，可以使用前缀。以下两个示例演示了如何强制使用 `ClassPathResource`和 `UrlResource`（后者用于访问文件系统中的文件）：

```xml
<property name="template" value="classpath:some/resource/path/myTemplate.txt">
<property name="template" value="file:///some/resource/path/myTemplate.txt"/>
```

If the `MyBean` class is refactored for use with annotation-driven configuration, the path to `myTemplate.txt` can be stored under a key named `template.path` — for example, in a properties file made available to the Spring `Environment` (see [Environment Abstraction](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-environment)). The template path can then be referenced via the `@Value` annotation using a property placeholder (see [Using `@Value`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-value-annotations)). Spring will retrieve the value of the template path as a string, and a special `PropertyEditor` will convert the string to a `Resource` object to be injected into the `MyBean` constructor. The following example demonstrates how to achieve this.

如果对 `MyBean` 类进行重构以用于注释驱动的配置，`myTemplate.txt` 的路径可以存储在名为 `template.path` 的键下 — 例如，在 Spring  `Environment` 可用的属性文件中（请参见[Environment Abstraction](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-environment)）。然后，可以使用属性占位符通过 `@Value` 注释引用模板路径（请参见[使用`@Value`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-value-annotations)）。Spring 将以字符串的形式检索模板路径的值，一个特殊的 `PropertyEditor` 将字符串转换为 `Resource` 对象，注入 `MyBean` 构造函数。下面的示例演示如何实现这一点。

```java
@Component
public class MyBean {

    private final Resource template;

    public MyBean(@Value("${template.path}") Resource template) {
        this.template = template;
    }

    // ...
}
```

If we want to support multiple templates discovered under the same path in multiple locations in the classpath — for example, in multiple jars in the classpath — we can use the special `classpath*:` prefix and wildcarding to define a `templates.path` key as `classpath*:/config/templates/*.txt`. If we redefine the `MyBean` class as follows, Spring will convert the template path pattern into an array of `Resource` objects that can be injected into the `MyBean` constructor.

如果我们想支持在类路径的多个位置的同一路径下发现的多个模板 — 例如，在类路径中的多个 JAR 中 — 我们可以使用特殊的`classpath*:` 前缀和通配符将 `templates.path` 键定义为 `classpath*:/config/templates/*.txt`。如果我们按如下方式重新定义 `MyBean` 类，Spring 将把模板路径模式转换成一个 `Resource` 对象数组，这些对象可以注入到 `MyBean` 构造函数中。

```java
@Component
public class MyBean {

    private final Resource[] templates;

    public MyBean(@Value("${templates.path}") Resource[] templates) {
        this.templates = templates;
    }

    // ...
}
```

### 2.8. Application Contexts and Resource Paths

### 2.8. 应用程序上下文和资源路径

This section covers how to create application contexts with resources, including shortcuts that work with XML, how to use wildcards, and other details.

本节介绍如何使用资源创建应用程序上下文，包括使用 XML 的快捷方式、如何使用通配符以及其他详细信息。

#### 2.8.1. Constructing Application Contexts

#### 2.8.1.构建应用程序上下文

An application context constructor (for a specific application context type) generally takes a string or array of strings as the location paths of the resources, such as XML files that make up the definition of the context.

When such a location path does not have a prefix, the specific `Resource` type built from that path and used to load the bean definitions depends on and is appropriate to the specific application context. For example, consider the following example, which creates a `ClassPathXmlApplicationContext`:

**应用程序上下文构造函数（针对特定的应用程序上下文类型）通常采用字符串或字符串数组作为资源的位置路径，例如构成上下文定义的 XML 文件。**

当这样的位置路径没有前缀时，从该路径构建并用于加载 bean 定义的特定 `Resource` 类型取决于特定的应用程序上下文，并且适合于该应用程序上下文。例如，考虑下面的示例，该示例创建一个 `ClassPathXmlApplicationContext`：

```java
ApplicationContext ctx = new ClassPathXmlApplicationContext("conf/appContext.xml");
```

The bean definitions are loaded from the classpath, because a `ClassPathResource` is used. However, consider the following example, which creates a `FileSystemXmlApplicationContext`:

bean 定义是从类路径加载的，因为使用了 `ClassPathResource`。但是，请考虑下面的示例，它创建了一个`FileSystemXmlApplicationContext`：

```java
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("conf/appContext.xml");
```

Now the bean definitions are loaded from a filesystem location (in this case, relative to the current working directory).

Note that the use of the special `classpath` prefix or a standard URL prefix on the location path overrides the default type of `Resource` created to load the bean definitions. Consider the following example:

现在，bean 定义从文件系统位置（在本例中，相对于当前工作目录）加载。

请注意，在位置路径上使用特殊的 `classpath` 前缀或标准 URL 前缀会覆盖为加载 bean 定义而创建的默认类型 `Resource`。考虑下面的例子：

```java
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("classpath:conf/appContext.xml");
```

Using `FileSystemXmlApplicationContext` loads the bean definitions from the classpath. However, it is still a `FileSystemXmlApplicationContext`. If it is subsequently used as a `ResourceLoader`, any unprefixed paths are still treated as filesystem paths.

使用 `FileSystemXmlApplicationContext` 从类路径加载 bean 定义。但是，它仍然是一个`FileSystemXmlApplicationContext`。如果随后将其用作 `ResourceLoader`，则任何未固定的路径仍将被视为文件系统路径。

##### Constructing `ClassPathXmlApplicationContext` Instances — Shortcuts

##### 构造 `ClassPathXmlApplicationContext` 实例 — 捷径

The `ClassPathXmlApplicationContext` exposes a number of constructors to enable convenient instantiation. The basic idea is that you can supply merely a string array that contains only the filenames of the XML files themselves (without the leading path information) and also supply a `Class`. The `ClassPathXmlApplicationContext` then derives the path information from the supplied class.

Consider the following directory layout:

`ClassPathXmlApplicationContext` 公开了许多构造函数以方便实例化。基本思想是，您可以只提供一个字符串数组，该数组只包含 XML 文件本身的文件名（不包含前导路径信息），还可以提供一个“类”。`ClassPathXmlApplicationContext` 然后从提供的类派生路径信息。

考虑下面的目录布局：

```
com/
  example/
    services.xml
    repositories.xml
    MessengerService.class
```

The following example shows how a `ClassPathXmlApplicationContext` instance composed of the beans defined in files named `services.xml` and `repositories.xml` (which are on the classpath) can be instantiated:

以下示例显示了如何实例化由名为 `services.xml` 和 `repositories.xml`（位于类路径上）的文件中定义的 bean 组成的 `ClassPathXmlApplicationContext` 实例：

```java
ApplicationContext ctx = new ClassPathXmlApplicationContext(
    new String[] {"services.xml", "repositories.xml"}, MessengerService.class);
```

See the [`ClassPathXmlApplicationContext`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html) javadoc for details on the various constructors.

请参阅[`ClassPathXmlApplicationContext`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html)javadoc获取有关各种构造函数的详细信息。

#### 2.8.2. Wildcards in Application Context Constructor Resource Paths

#### 2.8.2.应用程序上下文构造函数资源路径中的通配符

The resource paths in application context constructor values may be simple paths (as shown earlier), each of which has a one-to-one mapping to a target `Resource` or, alternately, may contain the special `classpath*:` prefix or internal Ant-style patterns (matched by using Spring’s `PathMatcher` utility). Both of the latter are effectively wildcards.

One use for this mechanism is when you need to do component-style application assembly. All components can *publish* context definition fragments to a well-known location path, and, when the final application context is created using the same path prefixed with `classpath*:`, all component fragments are automatically picked up.

Note that this wildcarding is specific to the use of resource paths in application context constructors (or when you use the `PathMatcher` utility class hierarchy directly) and is resolved at construction time. It has nothing to do with the `Resource` type itself. You cannot use the `classpath*:` prefix to construct an actual `Resource`, as a resource points to just one resource at a time.

应用程序上下文构造函数值中的资源路径可以是简单路径（如前所示），每个路径都有到目标 `Resource` 的一对一映射，或者也可以包含特殊的 `classpath*:` 前缀或内部 Ant 样式模式（通过使用 Spring 的 `PathMatcher` 实用程序进行匹配）。后者实际上都是通配符。

此机制的一个用途是当您需要进行组件样式的应用程序组装时。所有组件都可以发布上下文定义片段到已知的位置路径，并且，当使用前缀为`classpath*:` 的相同路径创建最终应用程序上下文时，所有组件片段都会自动拾取。

请注意，此通配符特定于在应用程序上下文构造函数中使用资源路径（或直接使用 `PathMatcher` 实用程序类层次结构时），并在构造时解析。它与 `Resource` 类型本身无关。不能使用 `classpath*:` 前缀来构造实际的 `Resource`，因为资源一次只指向一个资源。

##### Ant-style Patterns

##### Ant 样式模式

Path locations can contain Ant-style patterns, as the following example shows:

路径位置可以包含 Ant 样式的模式，如下例所示：

```xml
/WEB-INF/*-context.xml
com/mycompany/**/applicationContext.xml
file:C:/some/path/*-context.xml
classpath:com/mycompany/**/applicationContext.xml
```

When the path location contains an Ant-style pattern, the resolver follows a more complex procedure to try to resolve the wildcard. It produces a `Resource` for the path up to the last non-wildcard segment and obtains a URL from it. If this URL is not a `jar:` URL or container-specific variant (such as `zip:` in WebLogic, `wsjar` in WebSphere, and so on), a `java.io.File` is obtained from it and used to resolve the wildcard by traversing the filesystem. In the case of a jar URL, the resolver either gets a `java.net.JarURLConnection` from it or manually parses the jar URL and then traverses the contents of the jar file to resolve the wildcards.

当路径位置包含 Ant 样式的模式时，解析程序将执行更复杂的过程来尝试解析通配符。它为到最后一个非通配符段的路径生成`Resource`，并从中获取 URL。如果此 URL 不是 `jar:`URL 或特定于容器的变量（例如 WebLogic 中的 `zip:` URL、WebSphere 中的 `wsjar` 等等），则从中获取 `java.io.File` 并通过遍历文件系统来解析通配符。在 jar URL 的情况下，解析器要么得到一个`java.new.JarURLConnection` 从它开始，或者手动解析 jar URL，然后遍历 jar 文件的内容以解析通配符。

###### Implications on Portability

###### 对可移植性的影响

If the specified path is already a `file` URL (either implicitly because the base `ResourceLoader` is a filesystem one or explicitly), wildcarding is guaranteed to work in a completely portable fashion.

If the specified path is a `classpath` location, the resolver must obtain the last non-wildcard path segment URL by making a `Classloader.getResource()` call. Since this is just a node of the path (not the file at the end), it is actually undefined (in the `ClassLoader` javadoc) exactly what sort of a URL is returned in this case. In practice, it is always a `java.io.File` representing the directory (where the classpath resource resolves to a filesystem location) or a jar URL of some sort (where the classpath resource resolves to a jar location). Still, there is a portability concern on this operation.

If a jar URL is obtained for the last non-wildcard segment, the resolver must be able to get a `java.net.JarURLConnection` from it or manually parse the jar URL, to be able to walk the contents of the jar and resolve the wildcard. This does work in most environments but fails in others, and we strongly recommend that the wildcard resolution of resources coming from jars be thoroughly tested in your specific environment before you rely on it.

如果指定的路径已经是 `file` URL（因为基本 `ResourceLoader` 是文件系统 URL 而隐式地或显式地），则保证通配符以完全可移植的方式工作。

如果指定的路径是 `classpath` 位置，则解析程序必须通过生成 `Classloader.getResource()` 来获取最后一个非通配符路径段URL。由于这只是路径的一个节点（而不是最后的文件），因此实际上没有定义（在`ClassLoader`javadoc中）在本例中返回的 URL 的具体类型。实际上，它总是一个表示目录（类路径资源解析为文件系统位置）的 `java.io.File`或某种类型的jar URL（类路径资源解析为jar位置）。尽管如此，这个操作仍然存在可移植性问题。

如果为最后一个非通配符段获取了jar URL，解析程序必须能够从中获取 `java.net.JarURLConnection`，或者手动解析jar URL，才能遍历jar的内容并解析通配符。这在大多数环境中都有效，但在其他环境中却失败了，我们强烈建议在依赖JAR之前，在您的特定环境中对来自JAR的资源的通配符解析进行彻底测试。

##### The `classpath*:` Prefix

##### `classpath*:` 前缀

When constructing an XML-based application context, a location string may use the special `classpath*:` prefix, as the following example shows:

构建基于 XML 的应用程序上下文时，位置字符串可能会使用特殊的 `classpath*:` 前缀，如下例所示：

```java
ApplicationContext ctx =
    new ClassPathXmlApplicationContext("classpath*:conf/appContext.xml");
```

This special prefix specifies that all classpath resources that match the given name must be obtained (internally, this essentially happens through a call to `ClassLoader.getResources(…)`) and then merged to form the final application context definition.

此特殊前缀指定必须获取与给定名称匹配的所有类路径资源（在内部，这基本上是通过调用 `ClassLoader.getResources(…)`），然后合并以形成最终的应用程序上下文定义。

>  The wildcard classpath relies on the `getResources()` method of the underlying `ClassLoader`. As most application servers nowadays supply their own `ClassLoader` implementation, the behavior might differ, especially when dealing with jar files. A simple test to check if `classpath*` works is to use the `ClassLoader` to load a file from within a jar on the classpath: `getClass().getClassLoader().getResources("<someFileInsideTheJar>")`. Try this test with files that have the same name but reside in two different locations — for example, files with the same name and same path but in different jars on the classpath. In case an inappropriate result is returned, check the application server documentation for settings that might affect the `ClassLoader` behavior.
>
> 通配符类路径依赖于底层 `ClassLoader` 的 `getResources()`方法。由于现在大多数应用服务器都提供自己的`ClassLoader`实现，因此行为可能会有所不同，尤其是在处理jar文件时。检查 `classpath*`是否有效的一个简单测试是使用 `ClassLoader`从类路径 `getClass().getClassLoader().getResources("<someFileInsideTheJar>")` 上的jar中加载文件。使用具有相同名称但位于两个不同位置的文件尝试此测试 — 例如，具有相同名称和相同路径但位于类路径上不同JAR中的文件。如果返回了不适当的结果，请检查应用程序服务器文档中可能影响 `ClassLoader` 行为的设置。

You can also combine the `classpath*:` prefix with a `PathMatcher` pattern in the rest of the location path (for example, `classpath*:META-INF/*-beans.xml`). In this case, the resolution strategy is fairly simple: A `ClassLoader.getResources()` call is used on the last non-wildcard path segment to get all the matching resources in the class loader hierarchy and then, off each resource, the same `PathMatcher` resolution strategy described earlier is used for the wildcard subpath.

您还可以在位置路径的其余部分（例如，`classpath*：META-INF/*-beans.xml`）中将 `classpath*：`前缀与`PathMatcher` 模式组合。在本例中，解析策略相当简单：一个`ClassLoader.getResources()` 调用用于最后一个非通配符路径段，以获取类加载器层次结构中的所有匹配资源，然后，对于每个资源，前面描述的相同的 `PathMatcher` 解析策略用于通配符子路径。

##### Other Notes Relating to Wildcards

##### 与通配符有关的其他说明

Note that `classpath*:`, when combined with Ant-style patterns, only works reliably with at least one root directory before the pattern starts, unless the actual target files reside in the file system. This means that a pattern such as `classpath*:*.xml` might not retrieve files from the root of jar files but rather only from the root of expanded directories.

Spring’s ability to retrieve classpath entries originates from the JDK’s `ClassLoader.getResources()` method, which only returns file system locations for an empty string (indicating potential roots to search). Spring evaluates `URLClassLoader` runtime configuration and the `java.class.path` manifest in jar files as well, but this is not guaranteed to lead to portable behavior.

请注意，`classpath*:`，当与 Ant 样式的模式结合使用时，在模式启动之前，只能在至少一个根目录下可靠地工作，除非实际的目标文件驻留在文件系统中。这意味着像 `classpath*:*.xml` 这样的模式。可能不会从jar文件的根目录检索文件，而只能从扩展目录的根目录检索文件。

Spring 检索类路径条目的能力源于JDK的 `ClassLoader.getResources()`方法，该方法仅返回空字符串的文件系统位置（指示要搜索的潜在根）。Spring 评估 `URLClassLoader` 运行时配置和 `java.class.path` 清单也存在于 jar 文件中，但这不能保证导致可移植行为。

> The scanning of classpath packages requires the presence of corresponding directory entries in the classpath. When you build JARs with Ant, do not activate the `files-only` switch of the JAR task. Also, classpath directories may not get exposed based on security policies in some environments — for example, stand-alone applications on JDK 1.7.0_45 and higher (which requires 'Trusted-Library' to be set up in your manifests. See https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources).On JDK 9’s module path (Jigsaw), Spring’s classpath scanning generally works as expected. Putting resources into a dedicated directory is highly recommendable here as well, avoiding the aforementioned portability problems with searching the jar file root level.

Ant-style patterns with `classpath:` resources are not guaranteed to find matching resources if the root package to search is available in multiple classpath locations. Consider the following example of a resource location:

如果要搜索的根包在多个类路径位置可用，则不保证使用`classpath:`资源的Ant样式模式能够找到匹配的资源。考虑下面的资源位置示例：

```
com/mycompany/package1/service-context.xml
```

Now consider an Ant-style path that someone might use to try to find that file:

现在考虑一个 Ant 风格的路径，可能有人试图找到该文件：

```
classpath:com/mycompany/**/service-context.xml
```

Such a resource may exist in only one location in the classpath, but when a path such as the preceding example is used to try to resolve it, the resolver works off the (first) URL returned by `getResource("com/mycompany");`. If this base package node exists in multiple `ClassLoader` locations, the desired resource may not exist in the first location found. Therefore, in such cases you should prefer using `classpath*:` with the same Ant-style pattern, which searches all classpath locations that contain the `com.mycompany` base package: `classpath*:com/mycompany/**/service-context.xml`.

这样的资源可能只存在于类路径中的一个位置，但是当使用前面示例中的路径尝试解析它时，解析程序会关闭由`getResource(“com/mycompany”);`返回的（第一个）URL。如果此基本包节点存在于多个 `ClassLoader` 位置，则所需资源可能不存在于找到的第一个位置。因此，在这种情况下，您应该更喜欢使用带有相同Ant样式模式的`classpath*：`来搜索包含`com.mycompany`基本包`classpath*:com/mycompany/**/service-context.xml`的所有类路径位置。

#### 2.8.3. `FileSystemResource` Caveats

#### 2.8.3.`FileSystemResource` 注意事项

A `FileSystemResource` that is not attached to a `FileSystemApplicationContext` (that is, when a `FileSystemApplicationContext` is not the actual `ResourceLoader`) treats absolute and relative paths as you would expect. Relative paths are relative to the current working directory, while absolute paths are relative to the root of the filesystem.

For backwards compatibility (historical) reasons however, this changes when the `FileSystemApplicationContext` is the `ResourceLoader`. The `FileSystemApplicationContext` forces all attached `FileSystemResource` instances to treat all location paths as relative, whether they start with a leading slash or not. In practice, this means the following examples are equivalent:

未附加到 `FileSystemApplicationContext` 的 `FileSystemResource`（即，当 `FileSystemApplicationContext` 不是实际的 `ResourceLoader` 时）会像您所期望的那样处理绝对路径和相对路径。相对路径是相对于当前工作目录的，而绝对路径是相对于文件系统的根目录的。

但是，出于向后兼容性（历史）原因，当 `FileSystemApplicationContext` 是 `ResourceLoader` 时，这种情况会发生变化。`FileSystemApplicationContext` 强制所有附加的 `FileSystemResource` 实例将所有位置路径视为相对路径，无论它们是否以斜杠开头。实际上，这意味着以下示例是等效的：

```java
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("conf/context.xml");
```

```java
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("/conf/context.xml");
```

The following examples are also equivalent (even though it would make sense for them to be different, as one case is relative and the other absolute):

以下示例也是等效的（尽管它们不同是有意义的，因为一种情况是相对的，另一种情况是绝对的）：

```java
FileSystemXmlApplicationContext ctx = ...;
ctx.getResource("some/resource/path/myTemplate.txt");
```

```java
FileSystemXmlApplicationContext ctx = ...;
ctx.getResource("/some/resource/path/myTemplate.txt");
```

In practice, if you need true absolute filesystem paths, you should avoid using absolute paths with `FileSystemResource` or `FileSystemXmlApplicationContext` and force the use of a `UrlResource` by using the `file:` URL prefix. The following examples show how to do so:

实际上，如果需要真正的绝对文件系统路径，则应避免将绝对路径与 `FileSystemResource` 或 `FileSystemXmlApplicationContext` 一起使用，并通过使用 `file:` URL 前缀强制使用 `UrlResource`。以下示例说明了如何执行此操作：

```java
// actual context type doesn't matter, the Resource will always be UrlResource
ctx.getResource("file:///some/resource/path/myTemplate.txt");
```

```java
// force this FileSystemXmlApplicationContext to load its definition via a UrlResource
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("file:///conf/context.xml");
```
