## 3. Validation, Data Binding, and Type Conversion

## 3.验证、数据绑定和类型转换

There are pros and cons for considering validation as business logic, and Spring offers a design for validation (and data binding) that does not exclude either one of them. Specifically, validation should not be tied to the web tier and should be easy to localize, and it should be possible to plug in any available validator. Considering these concerns, Spring provides a `Validator` contract that is both basic and eminently usable in every layer of an application.

Data binding is useful for letting user input be dynamically bound to the domain model of an application (or whatever objects you use to process user input). Spring provides the aptly named `DataBinder` to do exactly that. The `Validator` and the `DataBinder` make up the `validation` package, which is primarily used in but not limited to the web layer.

The `BeanWrapper` is a fundamental concept in the Spring Framework and is used in a lot of places. However, you probably do not need to use the `BeanWrapper` directly. Because this is reference documentation, however, we felt that some explanation might be in order. We explain the `BeanWrapper` in this chapter, since, if you are going to use it at all, you are most likely do so when trying to bind data to objects.

Spring’s `DataBinder` and the lower-level `BeanWrapper` both use `PropertyEditorSupport` implementations to parse and format property values. The `PropertyEditor` and `PropertyEditorSupport` types are part of the JavaBeans specification and are also explained in this chapter. Spring 3 introduced a `core.convert` package that provides a general type conversion facility, as well as a higher-level “format” package for formatting UI field values. You can use these packages as simpler alternatives to `PropertyEditorSupport` implementations. They are also discussed in this chapter.

Spring supports Java Bean Validation through setup infrastructure and an adaptor to Spring’s own `Validator` contract. Applications can enable Bean Validation once globally, as described in [Java Bean Validation](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation-beanvalidation), and use it exclusively for all validation needs. In the web layer, applications can further register controller-local Spring `Validator` instances per `DataBinder`, as described in [Configuring a `DataBinder`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation-binder), which can be useful for plugging in custom validation logic.

将验证视为业务逻辑有其利弊，Spring 提供了一种验证（和数据绑定）设计，不排除其中任何一种。具体来说，验证不应该绑定到 web 层，应该易于本地化，并且应该可以插入任何可用的验证器。考虑到这些问题，Spring 提供了一个 `Validator`契约，它在应用程序的每一层都是基本的、非常有用的。

数据绑定对于让用户输入动态绑定到应用程序的域模型（或用于处理用户输入的任何对象）非常有用。Spring 提供了恰当命名的`DataBinder`来实现这一点。`Validator` 和 `DataBinder` 组成了 `validation` 包，主要用于但不限于 web 层。

`BeanRapper` 是 Spring 框架中的一个基本概念，在很多地方都有使用。但是，您可能不需要直接使用 `BeanRapper`。然而，因为这是参考文档，所以我们认为应该进行一些解释。我们将在本章中解释 `BeanRapper`，因为如果您打算使用它，那么在尝试将数据绑定到对象时很可能会使用它。

Spring 的 `DataBinder` 和较低级别的 `BeanRapper` 都使用 `PropertyEditorSupport`实现来解析和格式化属性值。`PropertyEditor` 和 `PropertyEditorSupport` 类型是 JavaBeans 规范的一部分，本章也对其进行了解释。Spring 3 引入了一个`core.convert` 包，它提供了一个通用的类型转换工具，以及一个用于格式化 UI 字段值的更高级别的 `format` 包。您可以将这些包用作 `PropertyEditorSupport`实现的更简单的替代方案。本章还将讨论这些问题。

Spring 通过安装基础设施和 Spring 自己的 `Validator` 契约的适配器支持 JavaBean 验证。应用程序可以全局启用 Bean 验证一次，如[JavaBeanValidation](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation-beanvalidation)中所述，并专门用于所有验证需求。在 web 层，应用程序可以按照[Configuring a`DataBinder`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation-binder)中的描述，进一步注册控制器本地 Spring`Validator`实例，这对于插入自定义验证逻辑非常有用。

### 3.1. Validation by Using Spring’s Validator Interface

### 3.1. 使用 Spring 的验证器接口进行验证

Spring features a `Validator` interface that you can use to validate objects. The `Validator` interface works by using an `Errors` object so that, while validating, validators can report validation failures to the `Errors` object.

Consider the following example of a small data object:

Spring 提供了一个 `Validator` 接口，您可以使用它来验证对象。`Validator` 接口通过使用 `Errors` 对象来工作，以便在验证时，验证器可以向 `Errors` 对象报告验证失败。

考虑下面的一个小数据对象的例子：

```java
public class Person {

    private String name;
    private int age;

    // the usual getters and setters...
}
```

The next example provides validation behavior for the `Person` class by implementing the following two methods of the `org.springframework.validation.Validator` interface:

- `supports(Class)`: Can this `Validator` validate instances of the supplied `Class`?
- `validate(Object, org.springframework.validation.Errors)`: Validates the given object and, in case of validation errors, registers those with the given `Errors` object.

Implementing a `Validator` is fairly straightforward, especially when you know of the `ValidationUtils` helper class that the Spring Framework also provides. The following example implements `Validator` for `Person` instances:

下一个示例通过**实现  `org.springframework.validation.Validator` 接口的以下两个方法**，为 `Person`类提供验证行为：

- `supports(Class)`：此 `Validator` 能否验证所提供`Class`的实例？
- `validate(Object, org.springframework.validation.Errors)`：验证给定的对象，如果出现验证错误，则向给定的`errors`对象注册这些对象。

实现 `Validator` 相当简单，尤其是当您知道 Spring 框架还提供了 `ValidationUtils` 助手类时。以下示例为 `Person` 实例实现了``Validator` ：

```java
public class PersonValidator implements Validator {

    /**
     * This Validator validates only Person instances
     */
    public boolean supports(Class clazz) {
        return Person.class.equals(clazz);
    }

    public void validate(Object obj, Errors e) {
        ValidationUtils.rejectIfEmpty(e, "name", "name.empty");
        Person p = (Person) obj;
        if (p.getAge() < 0) {
            e.rejectValue("age", "negativevalue");
        } else if (p.getAge() > 110) {
            e.rejectValue("age", "too.darn.old");
        }
    }
}
```

The `static` `rejectIfEmpty(..)` method on the `ValidationUtils` class is used to reject the `name` property if it is `null` or the empty string. Have a look at the [`ValidationUtils`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/validation/ValidationUtils.html) javadoc to see what functionality it provides besides the example shown previously.

While it is certainly possible to implement a single `Validator` class to validate each of the nested objects in a rich object, it may be better to encapsulate the validation logic for each nested class of object in its own `Validator` implementation. A simple example of a “rich” object would be a `Customer` that is composed of two `String` properties (a first and a second name) and a complex `Address` object. `Address` objects may be used independently of `Customer` objects, so a distinct `AddressValidator` has been implemented. If you want your `CustomerValidator` to reuse the logic contained within the `AddressValidator` class without resorting to copy-and-paste, you can dependency-inject or instantiate an `AddressValidator` within your `CustomerValidator`, as the following example shows:

`ValidationUtils`类上的 `static rejectIfEmpty()` 方法用于拒绝 `name`属性（如果该属性为 `null`或空字符串）。查看一下[`ValidationUtils`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/validation/ValidationUtils.html)javadoc，看看除了前面显示的示例之外，它还提供了哪些功能。

虽然可以实现单个 `Validator` 类来验证富对象中的每个嵌套对象，但最好将每个嵌套对象类的验证逻辑封装在其自己的 `Validator` 实现中。`rich` 对象的一个简单示例是 `Customer`，它由两个 `String` 属性（第一个和第二个名称）和一个复杂的 `Address` 对象组成，`Address`对象可以独立于 `Customer` 对象使用，因此实现了一个独特的 `AddressValidator`。如果希望 `CustomerValidator` 重用 `AddressValidator`类中包含的逻辑，而不必进行复制和粘贴，则可以在 `CustomerValidator `中插入或实例化 `AddressValidator`，如下例所示：

```java
public class CustomerValidator implements Validator {

    private final Validator addressValidator;

    public CustomerValidator(Validator addressValidator) {
        if (addressValidator == null) {
            throw new IllegalArgumentException("The supplied [Validator] is " +
                "required and must not be null.");
        }
        if (!addressValidator.supports(Address.class)) {
            throw new IllegalArgumentException("The supplied [Validator] must " +
                "support the validation of [Address] instances.");
        }
        this.addressValidator = addressValidator;
    }

    /**
     * This Validator validates Customer instances, and any subclasses of Customer too
     */
    public boolean supports(Class clazz) {
        return Customer.class.isAssignableFrom(clazz);
    }

    public void validate(Object target, Errors errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required");
        Customer customer = (Customer) target;
        try {
            errors.pushNestedPath("address");
            ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);
        } finally {
            errors.popNestedPath();
        }
    }
}
```

Validation errors are reported to the `Errors` object passed to the validator. In the case of Spring Web MVC, you can use the `<spring:bind/>` tag to inspect the error messages, but you can also inspect the `Errors` object yourself. More information about the methods it offers can be found in the [javadoc](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/validation/Errors.html).

验证错误报告给传递给验证器的 `errors` 对象。对于 Spring Web MVC，您可以使用`<Spring:bind/>`标记来检查错误消息，但您也可以自己检查`Errors`对象。关于它提供的方法的更多信息可以在[javadoc](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/validation/Errors.html) 中找到。

### 3.2. Resolving Codes to Error Messages

### 3.2. 将代码解析为错误消息

We covered databinding and validation. This section covers outputting messages that correspond to validation errors. In the example shown in the [preceding section](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validator), we rejected the `name` and `age` fields. If we want to output the error messages by using a `MessageSource`, we can do so using the error code we provide when rejecting the field ('name' and 'age' in this case). When you call (either directly, or indirectly, by using, for example, the `ValidationUtils` class) `rejectValue` or one of the other `reject` methods from the `Errors` interface, the underlying implementation not only registers the code you passed in but also registers a number of additional error codes. The `MessageCodesResolver` determines which error codes the `Errors` interface registers. By default, the `DefaultMessageCodesResolver` is used, which (for example) not only registers a message with the code you gave but also registers messages that include the field name you passed to the reject method. So, if you reject a field by using `rejectValue("age", "too.darn.old")`, apart from the `too.darn.old` code, Spring also registers `too.darn.old.age` and `too.darn.old.age.int` (the first includes the field name and the second includes the type of the field). This is done as a convenience to aid developers when targeting error messages.

More information on the `MessageCodesResolver` and the default strategy can be found in the javadoc of [`MessageCodesResolver`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/validation/MessageCodesResolver.html) and [`DefaultMessageCodesResolver`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.html), respectively.

我们讨论了数据绑定和验证。本节介绍输出与验证错误相对应的消息。在[上一节](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validator)所示的示例中，我们拒绝了 `name` 和 `age`字段。如果我们想使用 `MessageSource` 输出错误消息，那么可以使用拒绝字段时提供的错误代码（在本例中为 `name`和`age`）。当您从`Errors`接口调用（直接或间接地，例如，通过使用 `ValidationUtils` 类）`rejectValue` 或其他 `reject` 方法时，底层实现不仅注册传入的代码，还注册许多其他错误代码。 **`MessageCodesResolver` 确定 `Errors` 接口注册的错误代码。默认情况下，使用`DefaultMessageCodesResolver`**，它（例如）不仅使用您提供的代码注册消息，而且还注册包含您传递给 reject 方法的字段名的消息。因此，如果您使用 `rejectValue(“age”，“too.darn.old”)`拒绝一个字段，除了 `too.darn.old` 代码外，Spring 还注册 `too.darn.old.age` 和 `too.darn.old.age.int`（第一个包括字段名，第二个包括字段类型）。这样做是为了方便开发人员定位错误消息。

有关`MessageCodesResolver`和默认策略的更多信息，请分别参见[`MessageCodesResolver`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/validation/MessageCodesResolver.html)  和 [`DefaultMessageCodesResolver`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.html) 的 javadoc。

### 3.3. Bean Manipulation and the `BeanWrapper`

### 3.3. Bean 操作和 `BeanWrapper`

The `org.springframework.beans` package adheres to the JavaBeans standard. A JavaBean is a class with a default no-argument constructor and that follows a naming convention where (for example) a property named `bingoMadness` would have a setter method `setBingoMadness(..)` and a getter method `getBingoMadness()`. For more information about JavaBeans and the specification, see [javabeans](https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html).

One quite important class in the beans package is the `BeanWrapper` interface and its corresponding implementation (`BeanWrapperImpl`). As quoted from the javadoc, the `BeanWrapper` offers functionality to set and get property values (individually or in bulk), get property descriptors, and query properties to determine if they are readable or writable. Also, the `BeanWrapper` offers support for nested properties, enabling the setting of properties on sub-properties to an unlimited depth. The `BeanWrapper` also supports the ability to add standard JavaBeans `PropertyChangeListeners` and `VetoableChangeListeners`, without the need for supporting code in the target class. Last but not least, the `BeanWrapper` provides support for setting indexed properties. The `BeanWrapper` usually is not used by application code directly but is used by the `DataBinder` and the `BeanFactory`.

The way the `BeanWrapper` works is partly indicated by its name: it wraps a bean to perform actions on that bean, such as setting and retrieving properties.

`org.springframework.beans` 包遵循 JavaBeans 标准。JavaBean 是一个具有默认无参数构造函数的类，它遵循一种命名约定，其中（例如）名为`bingoMadness` 的属性将有一个 setter 方法 `setBingoMadness(...)` 还有一个 getter 方法 `getBingoMadness()`。有关 JavaBeans 和规范的更多信息，请参阅[JavaBeans](https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html)。

beans 包中一个相当重要的类是 `BeanWrapper` 接口及其相应的实现（ `BeanWrapperImpl`）。正如 javadoc 所引用的，`BeanWrapper` 提供了设置和获取属性值（单独或批量）、获取属性描述符以及查询属性以确定它们是否可读写的功能。此外，`BeanWrapper` 还支持嵌套属性，允许在子属性上设置无限深度的属性。`BeanWrapper` 还支持添加标准 JavaBeans `PropertyChangeListeners` 和 `VetoableChangeListeners` 的功能，而无需在目标类中支持代码。最后但并非最不重要的一点是，`BeanWrapper` 支持设置索引属性。**`BeanWrapper` 通常不直接由应用程序代码使用，而是由 `DataBinder` 和 `BeanFactory` 使用。**

**`BeanWrapper` 的工作方式部分由其名称表示：它包装一个 bean 以在该 bean 上执行操作，例如设置和检索属性。**

#### 3.3.1. Setting and Getting Basic and Nested Properties

#### 3.3.1. 设置和获取基本属性和嵌套属性

Setting and getting properties is done through the `setPropertyValue` and `getPropertyValue` overloaded method variants of `BeanWrapper`. See their Javadoc for details. The below table shows some examples of these conventions:

设置和获取属性是通过 `BeanWrapper` 的 `setPropertyValue` 和 `getPropertyValue` 重载方法变体完成的。有关详细信息，请参阅他们的 Javadoc。下表显示了这些约定的一些示例：

| Expression             | Explanation                                                  |
| :--------------------- | :----------------------------------------------------------- |
| `name`                 | Indicates the property `name` that corresponds to the `getName()` or `isName()` and `setName(..)` methods.<br />指示与 `getName()` 或 `isName()` 和 `setName(..)` 相对应的属性 `name` 方法。 |
| `account.name`         | Indicates the nested property `name` of the property `account` that corresponds to (for example) the `getAccount().setName()` or `getAccount().getName()` methods. |
| `account[2]`           | Indicates the *third* element of the indexed property `account`. Indexed properties can be of type `array`, `list`, or other naturally ordered collection. |
| `account[COMPANYNAME]` | Indicates the value of the map entry indexed by the `COMPANYNAME` key of the `account` `Map` property. |

(This next section is not vitally important to you if you do not plan to work with the `BeanWrapper` directly. If you use only the `DataBinder` and the `BeanFactory` and their default implementations, you should skip ahead to the [section on `PropertyEditors`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beans-conversion).)

The following two example classes use the `BeanWrapper` to get and set properties:

（如果您不打算直接使用 `BeanWrapper`，那么下一节对您来说并不重要。如果您只使用 `DataBinder` 和 `BeanFactory` 及其默认实现，您应该跳到[section on `PropertyEditors`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beans-conversion).)

以下两个示例类使用 `BeanRapper` 获取和设置属性：

```java
public class Company {

    private String name;
    private Employee managingDirector;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Employee getManagingDirector() {
        return this.managingDirector;
    }

    public void setManagingDirector(Employee managingDirector) {
        this.managingDirector = managingDirector;
    }
}
```

```java
public class Employee {

    private String name;

    private float salary;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public float getSalary() {
        return salary;
    }

    public void setSalary(float salary) {
        this.salary = salary;
    }
}
```

The following code snippets show some examples of how to retrieve and manipulate some of the properties of instantiated `Company`s and `Employee`s:

以下代码片段展示了如何检索和操作实例化的 `Company` 和 `Employee` 的某些属性的一些示例：

```java
BeanWrapper company = new BeanWrapperImpl(new Company());
// setting the company name..
company.setPropertyValue("name", "Some Company Inc.");
// ... can also be done like this:
PropertyValue value = new PropertyValue("name", "Some Company Inc.");
company.setPropertyValue(value);

// ok, let's create the director and tie it to the company:
BeanWrapper jim = new BeanWrapperImpl(new Employee());
jim.setPropertyValue("name", "Jim Stravinsky");
company.setPropertyValue("managingDirector", jim.getWrappedInstance());

// retrieving the salary of the managingDirector through the company
Float salary = (Float) company.getPropertyValue("managingDirector.salary");
```

#### 3.3.2. Built-in `PropertyEditor` Implementations

#### 3.3.2. 内置的 `PropertyEditor` 实现

Spring uses the concept of a `PropertyEditor` to effect the conversion between an `Object` and a `String`. It can be handy to represent properties in a different way than the object itself. For example, a `Date` can be represented in a human readable way (as the `String`: `'2007-14-09'`), while we can still convert the human readable form back to the original date (or, even better, convert any date entered in a human readable form back to `Date` objects). This behavior can be achieved by registering custom editors of type `java.beans.PropertyEditor`. Registering custom editors on a `BeanWrapper` or, alternatively, in a specific IoC container (as mentioned in the previous chapter), gives it the knowledge of how to convert properties to the desired type. For more about `PropertyEditor`, see [the javadoc of the `java.beans` package from Oracle](https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html).

A couple of examples where property editing is used in Spring:

- Setting properties on beans is done by using `PropertyEditor` implementations. When you use `String` as the value of a property of some bean that you declare in an XML file, Spring (if the setter of the corresponding property has a `Class` parameter) uses `ClassEditor` to try to resolve the parameter to a `Class` object.
- Parsing HTTP request parameters in Spring’s MVC framework is done by using all kinds of `PropertyEditor` implementations that you can manually bind in all subclasses of the `CommandController`.

Spring has a number of built-in `PropertyEditor` implementations to make life easy. They are all located in the `org.springframework.beans.propertyeditors` package. Most, (but not all, as indicated in the following table) are, by default, registered by `BeanWrapperImpl`. Where the property editor is configurable in some fashion, you can still register your own variant to override the default one. The following table describes the various `PropertyEditor` implementations that Spring provides:

Spring 使用 `PropertyEditor` 的概念来实现 `Object` 和 `String` 之间的转换。它可以方便地以不同于对象本身的方式表示属性。例如，`Date` 可以用人类可读的方式表示（如 `String`: `'2007-14-09'`），而我们仍然可以将人类可读的形式转换回原始日期（或者，更好的是，将人类可读形式中输入的任何日期转换回“日期”对象）。这种行为可以通过注册 `java.beans.PropertyEditor` 类型的自定义编辑器来实现。在 `BeanWrapper` 或特定 IoC 容器（如前一章所述）中注册自定义编辑器，使其了解如何将属性转换为所需类型。有关 `PropertyEditor` 的更多信息，请参阅 [the javadoc of the `java.beans` package from Oracle](https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html)。

Spring 中使用属性编辑的几个示例：

- 在 bean 上设置属性是通过使用 `PropertyEditor` 实现完成的。当使用 `String` 作为在 XML 文件中声明的某个 bean 的属性值时，Spring（如果相应属性的 setter 具有 `Class` 参数）使用 `ClassEditor` 尝试将参数解析为 `Class` 对象。
- 在 Spring 的 MVC 框架中解析 HTTP 请求参数是通过使用各种 `PropertyEditor` 实现来完成的，您可以在 `CommandController` 的所有子类中手动绑定这些实现。

Spring 有许多内置的 `PropertyEditor` 实现，让生活变得简单。它们都位于 `org.springframework.beans.propertyeditors` 包中。默认情况下，大多数（但并非全部，如下表所示）由 `BeanWrapperImpl` 注册。如果属性编辑器可以以某种方式进行配置，您仍然可以注册自己的变量来覆盖默认变量。下表描述了Spring 提供的各种 `PropertyEditor` 实现：

| Class                     | Explanation                                                  |
| :------------------------ | :----------------------------------------------------------- |
| `ByteArrayPropertyEditor` | Editor for byte arrays. Converts strings to their corresponding byte representations. Registered by default by `BeanWrapperImpl`.<br />字节数组编辑器。将字符串转换为相应的字节表示形式。默认情况下由 `BeanWrapperImpl` 注册。 |
| `ClassEditor`             | Parses Strings that represent classes to actual classes and vice-versa. When a class is not found, an `IllegalArgumentException` is thrown. By default, registered by `BeanWrapperImpl`.<br />将表示类的字符串解析为实际类，反之亦然。当找不到类时，将抛出 `IllegalArgumentException` 。默认情况下，由 `BeanWrapperImpl` 注册。 |
| `CustomBooleanEditor`     | Customizable property editor for `Boolean` properties. By default, registered by `BeanWrapperImpl` but can be overridden by registering a custom instance of it as a custom editor.<br />可自定义的 `Boolean` 属性编辑器。默认情况下，由 `BeanWrapperImpl` 注册，但可以通过将其自定义实例注册为自定义编辑器来覆盖。 |
| `CustomCollectionEditor`  | Property editor for collections, converting any source `Collection` to a given target `Collection` type.<br />集合的属性编辑器，将任何源 `Collection` 转换为给定的目标  `Collection` 类型。 |
| `CustomDateEditor`        | Customizable property editor for `java.util.Date`, supporting a custom `DateFormat`. NOT registered by default. Must be user-registered with the appropriate format as needed.<br />可自定义的 `java.util.Date` 属性编辑器，支持自定义的 `DateFormat`。默认情况下未注册。用户必须根据需要以适当的格式注册。 |
| `CustomNumberEditor`      | Customizable property editor for any `Number` subclass, such as `Integer`, `Long`, `Float`, or `Double`. By default, registered by `BeanWrapperImpl` but can be overridden by registering a custom instance of it as a custom editor.<br />可自定义的属性编辑器，用于任何 `Number` 子类，如 `Integer`、`Long`、`Float` 或 `Double`。默认情况下，由 `BeanWrapperImpl` 注册，但可以通过将其自定义实例注册为自定义编辑器来覆盖。 |
| `FileEditor`              | Resolves strings to `java.io.File` objects. By default, registered by `BeanWrapperImpl`.<br />将字符串解析为 `java.io.File` 对象。默认情况下，由 `BeanWrapperImpl` 注册。 |
| `InputStreamEditor`       | One-way property editor that can take a string and produce (through an intermediate `ResourceEditor` and `Resource`) an `InputStream` so that `InputStream` properties may be directly set as strings. Note that the default usage does not close the `InputStream` for you. By default, registered by `BeanWrapperImpl`.<br />单向属性编辑器，可以获取字符串并（通过中间的 `ResourceEditor` 和 `Resource`）生成 `InputStream`，这样就可以直接将 `InputStream` 属性设置为字符串。请注意，默认用法不会为您关闭 `InputStream`。默认情况下，由 `BeanWrapperImpl` 注册。 |
| `LocaleEditor`            | Can resolve strings to `Locale` objects and vice-versa (the string format is `[language]_[country]_[variant]`, same as the `toString()` method of `Locale`). Also accepts spaces as separators, as an alternative to underscores. By default, registered by `BeanWrapperImpl`.<br />可以将字符串解析为 `Locale` 对象，反之亦然（字符串格式为`[language]_[country]_[variant]`，与 `Locale` 的 `toString()` 方法相同）。也接受空格作为分隔符，作为下划线的替代。默认情况下，由 `BeanWrapperImpl` 注册。 |
| `PatternEditor`           | Can resolve strings to `java.util.regex.Pattern` objects and vice-versa.<br />可以将字符串解析为 `java.util.regex.Pattern` 对象，反之亦然。 |
| `PropertiesEditor`        | Can convert strings (formatted with the format defined in the javadoc of the `java.util.Properties` class) to `Properties` objects. By default, registered by `BeanWrapperImpl`.<br />可以将字符串（格式为 `java.util.Properties` 类的 javadoc 中定义的格式）转换为 `Properties` 对象。默认情况下，由 `BeanWrapperImpl` 注册。 |
| `StringTrimmerEditor`     | Property editor that trims strings. Optionally allows transforming an empty string into a `null` value. NOT registered by default — must be user-registered.<br />修剪字符串的属性编辑器。（可选）允许将空字符串转换为 `null` 值。默认情况下未注册 — 必须是用户注册的。 |
| `URLEditor`               | Can resolve a string representation of a URL to an actual `URL` object. By default, registered by `BeanWrapperImpl`.<br />可以将 URL 的字符串表示形式解析为实际的 `URL` 对象。默认情况下，由 `BeanWrapperImpl` 注册。 |

Spring uses the `java.beans.PropertyEditorManager` to set the search path for property editors that might be needed. The search path also includes `sun.bean.editors`, which includes `PropertyEditor` implementations for types such as `Font`, `Color`, and most of the primitive types. Note also that the standard JavaBeans infrastructure automatically discovers `PropertyEditor` classes (without you having to register them explicitly) if they are in the same package as the class they handle and have the same name as that class, with `Editor` appended. For example, one could have the following class and package structure, which would be sufficient for the `SomethingEditor` class to be recognized and used as the `PropertyEditor` for `Something`-typed properties.
Spring 使用 `java.beans.PropertyEditorManager` 设置可能需要的属性编辑器的搜索路径。搜索路径还包括 `sun.bean.editors`，其中包括 `Font`、`Color` 和大多数基本类型的 `PropertyEditor` 实现。还要注意的是，如果`PropertyEditor` 类与它们处理的类位于同一个包中，并且与该类具有相同的名称，则标准 JavaBeans 基础设施会自动发现这些类（无需显式注册它们），并附加 `Editor`。例如，可以有以下类和包结构，这就足以让 `SomethingEditor` 类被识别并用作`Something` 类型属性的 `PropertyEditor`。

```
com
  chank
    pop
      Something
      SomethingEditor // the PropertyEditor for the Something class
```

Note that you can also use the standard `BeanInfo` JavaBeans mechanism here as well (described to some extent [here](https://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html)). The following example uses the `BeanInfo` mechanism to explicitly register one or more `PropertyEditor` instances with the properties of an associated class:

请注意，您也可以在这里使用标准的 `BeanInfo` JavaBeans 机制（这里有一定程度的描述）。以下示例使用 `BeanInfo` 机制将一个或多个 `PropertyEditor` 实例显式注册为关联类的属性：

```
com
  chank
    pop
      Something
      SomethingBeanInfo // the BeanInfo for the Something class
```

The following Java source code for the referenced `SomethingBeanInfo` class associates a `CustomNumberEditor` with the `age` property of the `Something` class:

以下引用的 `SomethingBeanInfo` 类的 Java 源代码将 `CustomNumberEditor` 与 `Something` 类的 `age` 属性相关联：

```java
public class SomethingBeanInfo extends SimpleBeanInfo {

    public PropertyDescriptor[] getPropertyDescriptors() {
        try {
            final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true);
            PropertyDescriptor ageDescriptor = new PropertyDescriptor("age", Something.class) {
                @Override
                public PropertyEditor createPropertyEditor(Object bean) {
                    return numberPE;
                }
            };
            return new PropertyDescriptor[] { ageDescriptor };
        }
        catch (IntrospectionException ex) {
            throw new Error(ex.toString());
        }
    }
}
```

##### Registering Additional Custom `PropertyEditor` Implementations

##### 正在注册其他自定义 `PropertyEditor` 实现

When setting bean properties as string values, a Spring IoC container ultimately uses standard JavaBeans `PropertyEditor` implementations to convert these strings to the complex type of the property. Spring pre-registers a number of custom `PropertyEditor` implementations (for example, to convert a class name expressed as a string into a `Class` object). Additionally, Java’s standard JavaBeans `PropertyEditor` lookup mechanism lets a `PropertyEditor` for a class be named appropriately and placed in the same package as the class for which it provides support, so that it can be found automatically.

If there is a need to register other custom `PropertyEditors`, several mechanisms are available. The most manual approach, which is not normally convenient or recommended, is to use the `registerCustomEditor()` method of the `ConfigurableBeanFactory` interface, assuming you have a `BeanFactory` reference. Another (slightly more convenient) mechanism is to use a special bean factory post-processor called `CustomEditorConfigurer`. Although you can use bean factory post-processors with `BeanFactory` implementations, the `CustomEditorConfigurer` has a nested property setup, so we strongly recommend that you use it with the `ApplicationContext`, where you can deploy it in similar fashion to any other bean and where it can be automatically detected and applied.

Note that all bean factories and application contexts automatically use a number of built-in property editors, through their use of a `BeanWrapper` to handle property conversions. The standard property editors that the `BeanWrapper` registers are listed in the [previous section](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beans-conversion). Additionally, `ApplicationContext`s also override or add additional editors to handle resource lookups in a manner appropriate to the specific application context type.

Standard JavaBeans `PropertyEditor` instances are used to convert property values expressed as strings to the actual complex type of the property. You can use `CustomEditorConfigurer`, a bean factory post-processor, to conveniently add support for additional `PropertyEditor` instances to an `ApplicationContext`.

Consider the following example, which defines a user class called `ExoticType` and another class called `DependsOnExoticType`, which needs `ExoticType` set as a property:

当将 bean 属性设置为字符串值时，Spring IoC 容器最终使用标准 JavaBeans 的 `PropertyEditor` 实现将这些字符串转换为复杂类型的属性。Spring 预先注册了许多自定义的 `PropertyEditor` 实现（例如，将以字符串表示的类名转换为 `Class` 对象）。此外，Java 的标准 JavaBeans `PropertyEditor` 查找机制允许对类的 `PropertyEditor` 进行适当命名，并将其与它所支持的类放在同一个包中，以便自动找到它。

如果需要注册其他自定义 `PropertyEditor`，可以使用几种机制。通常不方便或不推荐的最手动的方法是使用`ConfigurableBeanFactory` 接口的 `registerCustomEditor()` 方法，假设您有一个 `BeanFactory` 引用。另一个（稍微方便一点）机制是使用一个名为 `CustomEditorConfigurer` 的特殊 bean factory 后处理器。虽然可以将 bean factory 后处理器与 `BeanFactory` 实现一起使用，但 `CustomEditorConfigurer` 有一个嵌套的属性设置，因此我们强烈建议您将其与`ApplicationContext` 一起使用，这样您就可以以与任何其他 bean 类似的方式部署它，并且可以自动检测和应用它。

请注意，所有 bean 工厂和应用程序上下文都会自动使用一些内置的属性编辑器，通过使用 `BeanWrapper` 来处理属性转换。`BeanWrapper` 注册的标准属性编辑器在 [上一节](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beans-conversion) 中列出。此外，`ApplicationContext` 还重写或添加其他编辑器，以便以适合特定应用程序上下文类型的方式处理资源查找。

标准 JavaBeans `PropertyEditor` 实例用于将以字符串表示的属性值转换为属性的实际复杂类型。您可以使用 bean factory 后处理器 `CustomEditorConfigurer`，方便地向 `ApplicationContext` 添加对其他 `PropertyEditor` 实例的支持。

考虑下面的示例，该示例定义了一个名为 `ExoticType` 的用户类和另一个名为 `ExoticType` 的类，它需要 `ExoticType` 设置为属性：

```java
package example;

public class ExoticType {

    private String name;

    public ExoticType(String name) {
        this.name = name;
    }
}

public class DependsOnExoticType {

    private ExoticType type;

    public void setType(ExoticType type) {
        this.type = type;
    }
}
```

When things are properly set up, we want to be able to assign the type property as a string, which a `PropertyEditor` converts into an actual `ExoticType` instance. The following bean definition shows how to set up this relationship:

正确设置后，我们希望能够将 type 属性指定为一个字符串， `PropertyEditor` 将其转换为实际的 `ExoticType` 实例。下面的 bean 定义显示了如何建立这种关系：

```xml
<bean id="sample" class="example.DependsOnExoticType">
    <property name="type" value="aNameForExoticType"/>
</bean>
```

The `PropertyEditor` implementation could look similar to the following:

 `PropertyEditor` 实现可能类似于以下内容：

```java
// converts string representation to ExoticType object
package example;

public class ExoticTypeEditor extends PropertyEditorSupport {

    public void setAsText(String text) {
        setValue(new ExoticType(text.toUpperCase()));
    }
}
```

Finally, the following example shows how to use `CustomEditorConfigurer` to register the new `PropertyEditor` with the `ApplicationContext`, which will then be able to use it as needed:
最后，下面的示例显示了如何使用 `CustomEditorConfigurer` 将新的 `PropertyEditor` 注册到 `ApplicationContext`中，然后它将能够根据需要使用它：

```xml
<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
    <property name="customEditors">
        <map>
            <entry key="example.ExoticType" value="example.ExoticTypeEditor"/>
        </map>
    </property>
</bean>
```

###### Using `PropertyEditorRegistrar`

###### 使用 `PropertyEditorRegistrar`

Another mechanism for registering property editors with the Spring container is to create and use a `PropertyEditorRegistrar`. This interface is particularly useful when you need to use the same set of property editors in several different situations. You can write a corresponding registrar and reuse it in each case. `PropertyEditorRegistrar` instances work in conjunction with an interface called `PropertyEditorRegistry`, an interface that is implemented by the Spring `BeanWrapper` (and `DataBinder`). `PropertyEditorRegistrar` instances are particularly convenient when used in conjunction with `CustomEditorConfigurer` (described [here](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beans-conversion-customeditor-registration)), which exposes a property called `setPropertyEditorRegistrars(..)`. `PropertyEditorRegistrar` instances added to a `CustomEditorConfigurer` in this fashion can easily be shared with `DataBinder` and Spring MVC controllers. Furthermore, it avoids the need for synchronization on custom editors: A `PropertyEditorRegistrar` is expected to create fresh `PropertyEditor` instances for each bean creation attempt.

The following example shows how to create your own `PropertyEditorRegistrar` implementation:

向 Spring 容器注册属性编辑器的另一种机制是创建并使用 `PropertyEditorRegistrar`。当您需要在几种不同的情况下使用同一组属性编辑器时，此界面尤其有用。您可以编写相应的注册器，并在每种情况下重用它 `PropertyEditorRegistrar` 实例与名为 `PropertyEditorRegistry` 的接口一起工作，该接口由 Spring `BeanWrapper`（和 `DataBinder`）实现`PropertyEditorRegistrar` 实例与 `CustomEditorConfigurer` 结合使用时特别方便（[此处](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beans-conversion-customeditor-registration)有描述），它公开了一个名为 `setPropertyEditorRegistrars(..)` 的属性，以这种方式添加到 `CustomEditorConfigurer` 的`PropertyEditorRegistrar` 实例可以很容易地与 `DataBinder` 和 Spring MVC 控制器共享。此外，它还避免了在自定义编辑器上进行同步的需要：`PropertyEditorRegistrar` 预计会为每个 bean 创建尝试创建新的 `PropertyEditor` 实例。

以下示例显示了如何创建自己的 `PropertyEditorRegistrar` 实现：

```java
package com.foo.editors.spring;

public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {

    public void registerCustomEditors(PropertyEditorRegistry registry) {

        // it is expected that new PropertyEditor instances are created
        registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());

        // you could register as many custom property editors as are required here...
    }
}
```

See also the `org.springframework.beans.support.ResourceEditorRegistrar` for an example `PropertyEditorRegistrar` implementation. Notice how in its implementation of the `registerCustomEditors(..)` method, it creates new instances of each property editor.

The next example shows how to configure a `CustomEditorConfigurer` and inject an instance of our `CustomPropertyEditorRegistrar` into it:

有关 `PropertyEditorRegistrar` 实现的示例，请参见  `org.springframework.beans.support.ResourceEditorRegistrar`。请注意它是如何实现  `registerCustomEditors(..)` 的方法创建每个属性编辑器的新实例。

下一个示例演示如何配置 `CustomEditorConfigurer` ，并将 `CustomPropertyEditorRegistrar` 的实例注入其中：

```xml
<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
    <property name="propertyEditorRegistrars">
        <list>
            <ref bean="customPropertyEditorRegistrar"/>
        </list>
    </property>
</bean>

<bean id="customPropertyEditorRegistrar"
    class="com.foo.editors.spring.CustomPropertyEditorRegistrar"/>
```

Finally (and in a bit of a departure from the focus of this chapter for those of you using [Spring’s MVC web framework](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc)), using `PropertyEditorRegistrars` in conjunction with data-binding `Controllers` (such as `SimpleFormController`) can be very convenient. The following example uses a `PropertyEditorRegistrar` in the implementation of an `initBinder(..)` method:

最后（对于那些使用 [Spring’s MVC web framework](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc) 的人来说，这与本章的重点有所不同），将 `PropertyEditorRegistrars` 与数据绑定 `Controllers`（例如 `SimpleFormController`）结合使用可能非常方便。下面的示例在 `initBinder(..)` 的实现中使用了 `PropertyEditorRegistrar` 方法：

```java
public final class RegisterUserController extends SimpleFormController {

    private final PropertyEditorRegistrar customPropertyEditorRegistrar;

    public RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {
        this.customPropertyEditorRegistrar = propertyEditorRegistrar;
    }

    protected void initBinder(HttpServletRequest request,
            ServletRequestDataBinder binder) throws Exception {
        this.customPropertyEditorRegistrar.registerCustomEditors(binder);
    }

    // other methods to do with registering a User
}
```

This style of `PropertyEditor` registration can lead to concise code (the implementation of `initBinder(..)` is only one line long) and lets common `PropertyEditor` registration code be encapsulated in a class and then shared amongst as many `Controllers` as needed.

这种风格的 `PropertyEditor` 注册可以产生简洁的代码（ `initBinder(..)` 的实现）只有一行）并允许将常见的 `PropertyEditor` 注册代码封装在一个类中，然后根据需要在多个 `Controllers` 之间共享。

### 3.4. Spring Type Conversion

### 3.4.Spring 类型转换

Spring 3 introduced a `core.convert` package that provides a general type conversion system. The system defines an SPI to implement type conversion logic and an API to perform type conversions at runtime. Within a Spring container, you can use this system as an alternative to `PropertyEditor` implementations to convert externalized bean property value strings to the required property types. You can also use the public API anywhere in your application where type conversion is needed.

Spring 3 推出了一个 `core.convert` 包，它提供了一个通用的类型转换系统。系统定义了一个 SPI 来实现类型转换逻辑，定义了一个 API 来在运行时执行类型转换。在 Spring 容器中，您可以使用该系统作为 `PropertyEditor` 实现的替代方案，将外部化的bean 属性值字符串转换为所需的属性类型。您还可以在应用程序中需要进行类型转换的任何地方使用公共 API。

#### 3.4.1. Converter SPI

#### 3.4.1. SPI 转换器

The SPI to implement type conversion logic is simple and strongly typed, as the following interface definition shows:

实现类型转换逻辑的 SPI 是简单且强类型的，如下接口定义所示：

```java
package org.springframework.core.convert.converter;

public interface Converter<S, T> {

    T convert(S source);
}
```

To create your own converter, implement the `Converter` interface and parameterize `S` as the type you are converting from and `T` as the type you are converting to. You can also transparently apply such a converter if a collection or array of `S` needs to be converted to an array or collection of `T`, provided that a delegating array or collection converter has been registered as well (which `DefaultConversionService` does by default).

For each call to `convert(S)`, the source argument is guaranteed to not be null. Your `Converter` may throw any unchecked exception if conversion fails. Specifically, it should throw an `IllegalArgumentException` to report an invalid source value. Take care to ensure that your `Converter` implementation is thread-safe.

Several converter implementations are provided in the `core.convert.support` package as a convenience. These include converters from strings to numbers and other common types. The following listing shows the `StringToInteger` class, which is a typical `Converter` implementation:

要创建自己的转换器，请实现 `Converter` 接口，并将 `S` 参数化为转换源的类型，将 `T` 参数化为转换到的类型。如果需要将 `S` 的集合或数组转换为 `T` 的数组或集合，还可以透明地应用这样的转换器，前提是还注册了委托数组或集合转换器（默认情况下，`DefaultConversionService` 会这样做）。

对于每个对 `convert(S)` 的调用，保证源参数不为 null。如果转换失败，`Converter` 可能会抛出任何未经检查的异常。具体来说，它应该抛出一个 `IllegalArgumentException` 来报告一个无效的源值。注意确保 `Converter` 实现是线程安全的。

为了方便起见， `core.convert.support` 包中提供了几种转换器实现。其中包括从字符串到数字和其他常见类型的转换器。下面的列表显示了 `StringToInteger` 类，它是一个典型的 `Converter` 实现：

```java
package org.springframework.core.convert.support;

final class StringToInteger implements Converter<String, Integer> {

    public Integer convert(String source) {
        return Integer.valueOf(source);
    }
}
```

#### 3.4.2. Using `ConverterFactory`

#### 3.4.2. 使用 `ConverterFactory`

When you need to centralize the conversion logic for an entire class hierarchy (for example, when converting from `String` to `Enum` objects), you can implement `ConverterFactory`, as the following example shows:

当需要集中整个类层次结构的转换逻辑时（例如，从 `String` 转换为 `Enum` 对象时），可以实现 `ConverterFactory`，如下例所示：

```java
package org.springframework.core.convert.converter;

public interface ConverterFactory<S, R> {

    <T extends R> Converter<S, T> getConverter(Class<T> targetType);
}
```

Parameterize S to be the type you are converting from and R to be the base type defining the *range* of classes you can convert to. Then implement `getConverter(Class<T>)`, where T is a subclass of R.

Consider the `StringToEnumConverterFactory` as an example:

将 S 参数化为要转换的类型，将R参数化为定义可转换为的类的*范围*的基类型。然后实现  `getConverter(Class<T>)`，其中 T是 R 的一个子类。

将 `StringToEnumConverterFactory` 作为一个例子：

```java
package org.springframework.core.convert.support;

final class StringToEnumConverterFactory implements ConverterFactory<String, Enum> {

    public <T extends Enum> Converter<String, T> getConverter(Class<T> targetType) {
        return new StringToEnumConverter(targetType);
    }

    private final class StringToEnumConverter<T extends Enum> implements Converter<String, T> {

        private Class<T> enumType;

        public StringToEnumConverter(Class<T> enumType) {
            this.enumType = enumType;
        }

        public T convert(String source) {
            return (T) Enum.valueOf(this.enumType, source.trim());
        }
    }
}
```

#### 3.4.3. Using `GenericConverter`

#### 3.4.3. 使用 `GenericConverter`

When you require a sophisticated `Converter` implementation, consider using the `GenericConverter` interface. With a more flexible but less strongly typed signature than `Converter`, a `GenericConverter` supports converting between multiple source and target types. In addition, a `GenericConverter` makes available source and target field context that you can use when you implement your conversion logic. Such context lets a type conversion be driven by a field annotation or by generic information declared on a field signature. The following listing shows the interface definition of `GenericConverter`:

当您需要一个复杂的 `Converter` 实现时，考虑使用 `GenericConverter` 接口。与 `Converter` 相比，`GenericConverter` 具有更灵活但不太强的类型签名，它支持在多个源类型和目标类型之间进行转换。此外，`GenericConverter` 还提供了源字段和目标字段上下文，您可以在实现转换逻辑时使用它们。这种上下文允许类型转换由字段注释或字段签名上声明的泛型信息驱动。下表显示了 `GenericConverter` 的接口定义：

```java
package org.springframework.core.convert.converter;

public interface GenericConverter {

    public Set<ConvertiblePair> getConvertibleTypes();

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}
```

To implement a `GenericConverter`, have `getConvertibleTypes()` return the supported source→target type pairs. Then implement `convert(Object, TypeDescriptor, TypeDescriptor)` to contain your conversion logic. The source `TypeDescriptor` provides access to the source field that holds the value being converted. The target `TypeDescriptor` provides access to the target field where the converted value is to be set.

A good example of a `GenericConverter` is a converter that converts between a Java array and a collection. Such an `ArrayToCollectionConverter` introspects the field that declares the target collection type to resolve the collection’s element type. This lets each element in the source array be converted to the collection element type before the collection is set on the target field.

要实现 `GenericConverter`，请让 `getConvertibleTypes()` 返回支持的源代码→目标类型对。然后实现 `convert(Object, TypeDescriptor, TypeDescriptor)` ，以包含转换逻辑。源 `TypeDescriptor` 提供对保存正在转换的值的源字段的访问。目标 `TypeDescriptor` 提供对要在其中设置转换值的目标字段的访问。

 `GenericConverter` 的一个很好的例子是在 Java 数组和集合之间进行转换的转换器。这样的 `ArrayToCollectionConverter` 会内省声明目标集合类型的字段，以解析集合的元素类型。这允许在目标字段上设置集合之前，将源数组中的每个元素转换为集合元素类型。

> Because `GenericConverter` is a more complex SPI interface, you should use it only when you need it. Favor `Converter` or `ConverterFactory` for basic type conversion needs.
>
> 因为 `GenericConverter` 是一个更复杂的 SPI 接口，所以您应该只在需要时使用它。对于基本的类型转换需求，喜欢使用 `Converter` 或 `ConverterFactory`。

##### Using `ConditionalGenericConverter`

##### 使用  `ConditionalGenericConverter`

Sometimes, you want a `Converter` to run only if a specific condition holds true. For example, you might want to run a `Converter` only if a specific annotation is present on the target field, or you might want to run a `Converter` only if a specific method (such as a `static valueOf` method) is defined on the target class. `ConditionalGenericConverter` is the union of the `GenericConverter` and `ConditionalConverter` interfaces that lets you define such custom matching criteria:

有时，您希望 `Converter` 仅在特定条件成立时运行。例如，仅当目标字段上存在特定注释时，您可能希望运行 `Converter`，或者仅当在目标类上定义了特定方法（例如 `static valueOf` 方法）时，您可能希望运行 `Converter`。`ConditionalGenericConverter` 是 `GenericConverter` 和 `ConditionalConverter` `接口的联合体，可用于定义此类自定义匹配条件：

```java
public interface ConditionalConverter {

    boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);
}

public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {
}
```

A good example of a `ConditionalGenericConverter` is an `IdToEntityConverter` that converts between a persistent entity identifier and an entity reference. Such an `IdToEntityConverter` might match only if the target entity type declares a static finder method (for example, `findAccount(Long)`). You might perform such a finder method check in the implementation of `matches(TypeDescriptor, TypeDescriptor)`.

 `ConditionalGenericConverter` 的一个很好的例子是 `IdToEntityConverter`，它在持久实体标识符和实体引用之间进行转换。只有当目标实体类型声明了一个静态 finder 方法（例如，`findAccount(Long)`）时，这样的 `IdToEntityConverter` 才可能匹配。您可以在 `matches(TypeDescriptor, TypeDescriptor)` 的实现中执行这样的finder方法检查。

#### 3.4.4. The `ConversionService` API

#### 3.4.4. `ConversionService` API 

`ConversionService` defines a unified API for executing type conversion logic at runtime. Converters are often run behind the following facade interface:

`ConversionService` 定义了一个统一的 API，用于在运行时执行类型转换逻辑。转换器通常在以下 facade 接口后面运行：

```java
package org.springframework.core.convert;

public interface ConversionService {

    boolean canConvert(Class<?> sourceType, Class<?> targetType);

    <T> T convert(Object source, Class<T> targetType);

    boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}
```

Most `ConversionService` implementations also implement `ConverterRegistry`, which provides an SPI for registering converters. Internally, a `ConversionService` implementation delegates to its registered converters to carry out type conversion logic.

A robust `ConversionService` implementation is provided in the `core.convert.support` package. `GenericConversionService` is the general-purpose implementation suitable for use in most environments. `ConversionServiceFactory` provides a convenient factory for creating common `ConversionService` configurations.

大多数 `ConversionService` 实现还实现了 `ConverterRegistry`，它为注册转换器提供了 SPI。在内部，`ConversionService` 实现委托其注册的转换器执行类型转换逻辑。

`core.convert.support` 包中提供了一个健壮的 `ConversionService` 实现 `GenericConversionService` 是一种通用实现，适用于大多数环境 `ConversionServiceFactory` 提供了一个方便的工厂，用于创建常见的 `ConversionService` 配置。

#### 3.4.5. Configuring a `ConversionService`

#### 3.4.5. 配置 `ConversionService`

A `ConversionService` is a stateless object designed to be instantiated at application startup and then shared between multiple threads. In a Spring application, you typically configure a `ConversionService` instance for each Spring container (or `ApplicationContext`). Spring picks up that `ConversionService` and uses it whenever a type conversion needs to be performed by the framework. You can also inject this `ConversionService` into any of your beans and invoke it directly.

`ConversionService` 是一个无状态对象，设计用于在应用程序启动时实例化，然后在多个线程之间共享。在 Spring 应用程序中，通常为每个 Spring 容器（或 `ApplicationContext`）配置一个 `ConversionService` 实例。Spring 会选择 `ConversionService`，并在框架需要执行类型转换时使用它。您还可以将这个 `ConversionService` 注入到任何 bean 中，并直接调用它。

> If no `ConversionService` is registered with Spring, the original `PropertyEditor`-based system is used.
>
> 如果 Spring 没有注册 `ConversionService`，则使用原始的基于 `PropertyEditor` 的系统。

To register a default `ConversionService` with Spring, add the following bean definition with an `id` of `conversionService`:

要向 Spring 注册默认的 `ConversionService`，请添加以下 bean 定义，其 `id` 为 `ConversionService`：

```xml
<bean id="conversionService"
    class="org.springframework.context.support.ConversionServiceFactoryBean"/>
```

A default `ConversionService` can convert between strings, numbers, enums, collections, maps, and other common types. To supplement or override the default converters with your own custom converters, set the `converters` property. Property values can implement any of the `Converter`, `ConverterFactory`, or `GenericConverter` interfaces.

默认的 `ConversionService` 可以在字符串、数字、枚举、集合、映射和其他常见类型之间进行转换。要使用自己的自定义转换器补充或覆盖默认转换器，请设置 `converters` 属性。属性值可以实现任何 `Converter`、`ConverterFactory` 或 `GenericConverter` 接口。

```xml
<bean id="conversionService"
        class="org.springframework.context.support.ConversionServiceFactoryBean">
    <property name="converters">
        <set>
            <bean class="example.MyCustomConverter"/>
        </set>
    </property>
</bean>
```

It is also common to use a `ConversionService` within a Spring MVC application. See [Conversion and Formatting](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-conversion) in the Spring MVC chapter.

In certain situations, you may wish to apply formatting during conversion. See [The `FormatterRegistry` SPI](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#format-FormatterRegistry-SPI) for details on using `FormattingConversionServiceFactoryBean`.

在 Spring MVC 应用程序中使用 `ConversionService` 也是很常见的。请参阅 Spring MVC 一章中的 [Conversion and Formatting](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-conversion)。

在某些情况下，您可能希望在转换期间应用格式。有关使用 `FormattingConversionServiceFactoryBean` 的详细信息，请参见 [The `FormatterRegistry` SPI](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#format-FormatterRegistry-SPI)。

#### 3.4.6. Using a `ConversionService` Programmatically

#### 3.4.6.以编程方式使用 `ConversionService`

To work with a `ConversionService` instance programmatically, you can inject a reference to it like you would for any other bean. The following example shows how to do so:

要以编程方式使用 `ConversionService` 实例，可以像对任何其他 bean 一样向其注入引用。以下示例显示了如何执行此操作：

```java
@Service
public class MyService {

    public MyService(ConversionService conversionService) {
        this.conversionService = conversionService;
    }

    public void doIt() {
        this.conversionService.convert(...)
    }
}
```

For most use cases, you can use the `convert` method that specifies the `targetType`, but it does not work with more complex types, such as a collection of a parameterized element. For example, if you want to convert a `List` of `Integer` to a `List` of `String` programmatically, you need to provide a formal definition of the source and target types.

Fortunately, `TypeDescriptor` provides various options to make doing so straightforward, as the following example shows:

对于大多数用例，可以使用指定 `targetType` 的 `convert` 方法，但它不适用于更复杂的类型，例如参数化元素的集合。例如，如果要以编程方式将 `Integer` 的 `List` 转换为 `String` 的 `List`，则需要提供源类型和目标类型的正式定义。
幸运的是，`TypeDescriptor` 提供了各种选项，使操作变得简单，如下例所示：

```java
DefaultConversionService cs = new DefaultConversionService();

List<Integer> input = ...
cs.convert(input,
    TypeDescriptor.forObject(input), // List<Integer> type descriptor
    TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));
```

Note that `DefaultConversionService` automatically registers converters that are appropriate for most environments. This includes collection converters, scalar converters, and basic `Object`-to-`String` converters. You can register the same converters with any `ConverterRegistry` by using the static `addDefaultConverters` method on the `DefaultConversionService` class.

Converters for value types are reused for arrays and collections, so there is no need to create a specific converter to convert from a `Collection` of `S` to a `Collection` of `T`, assuming that standard collection handling is appropriate.

请注意，`DefaultConversionService` 会自动注册适用于大多数环境的转换器。这包括集合转换器、标量转换器和基本的 `Object` 到 `Object` 转换器。您可以使用 `DefaultConversionService` 类上的静态 `addDefaultConverters` 方法向任何 `ConverterRegistry` 注册相同的转换器。

值类型的转换器可用于数组和集合，因此无需创建特定的转换器来从 `S` 的 `Collection` 转换为 `T` 的 `Collection`，前提是标准集合处理是适当的。

### 3.5. Spring Field Formatting

### 3.5. Spring 字段格式

As discussed in the previous section, [`core.convert`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#core-convert) is a general-purpose type conversion system. It provides a unified `ConversionService` API as well as a strongly typed `Converter` SPI for implementing conversion logic from one type to another. A Spring container uses this system to bind bean property values. In addition, both the Spring Expression Language (SpEL) and `DataBinder` use this system to bind field values. For example, when SpEL needs to coerce a `Short` to a `Long` to complete an `expression.setValue(Object bean, Object value)` attempt, the `core.convert` system performs the coercion.

Now consider the type conversion requirements of a typical client environment, such as a web or desktop application. In such environments, you typically convert from `String` to support the client postback process, as well as back to `String` to support the view rendering process. In addition, you often need to localize `String` values. The more general `core.convert` `Converter` SPI does not address such formatting requirements directly. To directly address them, Spring 3 introduced a convenient `Formatter` SPI that provides a simple and robust alternative to `PropertyEditor` implementations for client environments.

In general, you can use the `Converter` SPI when you need to implement general-purpose type conversion logic — for example, for converting between a `java.util.Date` and a `Long`. You can use the `Formatter` SPI when you work in a client environment (such as a web application) and need to parse and print localized field values. The `ConversionService` provides a unified type conversion API for both SPIs.

如前一节所述，[`core.convert`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#core-convert) 是一个通用类型转换系统。它提供了一个统一的 `ConversionService` API 以及一个强类型的 `Converter` SPI，用于实现从一种类型到另一种类型的转换逻辑。Spring 容器使用该系统绑定 bean 属性值。此外，Spring 表达式语言（SpEL）和 `DataBinder` 都使用这个系统来绑定字段值。例如，当 SpEL 需要将 `Short` 强制为 `Long` 以完成 `expression.setValue(Object bean, Object value)` 尝试时， `core.convert` 系统执行强制。

现在考虑典型的客户端环境（例如 Web 或桌面应用程序）的类型转换要求。在这样的环境中，您通常会从 `String` 转换为支持客户端回发过程，也会从 `String` 转换为 `String` 以支持视图渲染过程。此外，通常需要本地化 `String` 值。更通用的 `core.convert`。`Converter` SPI 不能直接满足这种格式要求。为了直接解决这些问题，Spring 3 引入了一个方便的 `Formatter` SPI，它为客户机环境中的 `PropertyEditor` 实现提供了一个简单而健壮的替代方案。

通常，当需要实现通用类型转换逻辑时，可以使用 `Converter` SPI — 例如，用于在 `java.util.Date` 和 `Long` 之间转换。在客户端环境（如 web 应用程序）中工作，需要解析和打印本地化字段值时，可以使用 `Formatter` SPI。`ConversionService` 为两个 SPI 提供了统一的类型转换 API。

#### 3.5.1. The `Formatter` SPI

The `Formatter` SPI to implement field formatting logic is simple and strongly typed. The following listing shows the `Formatter` interface definition:

用于实现字段格式化逻辑的 `Formatter` SPI 简单且类型强。下面的列表显示了 `Formatter` 接口定义：

```java
package org.springframework.format;

public interface Formatter<T> extends Printer<T>, Parser<T> {
}
```

`Formatter` extends from the `Printer` and `Parser` building-block interfaces. The following listing shows the definitions of those two interfaces:

`Formatter` 从 `Printer` 和 `Parser` 构建块接口扩展而来。下面的列表显示了这两个接口的定义：

```java
public interface Printer<T> {

    String print(T fieldValue, Locale locale);
}
```

```java
import java.text.ParseException;

public interface Parser<T> {

    T parse(String clientValue, Locale locale) throws ParseException;
}
```

To create your own `Formatter`, implement the `Formatter` interface shown earlier. Parameterize `T` to be the type of object you wish to format — for example, `java.util.Date`. Implement the `print()` operation to print an instance of `T` for display in the client locale. Implement the `parse()` operation to parse an instance of `T` from the formatted representation returned from the client locale. Your `Formatter` should throw a `ParseException` or an `IllegalArgumentException` if a parse attempt fails. Take care to ensure that your `Formatter` implementation is thread-safe.

The `format` subpackages provide several `Formatter` implementations as a convenience. The `number` package provides `NumberStyleFormatter`, `CurrencyStyleFormatter`, and `PercentStyleFormatter` to format `Number` objects that use a `java.text.NumberFormat`. The `datetime` package provides a `DateFormatter` to format `java.util.Date` objects with a `java.text.DateFormat`.

The following `DateFormatter` is an example `Formatter` implementation:

要创建自己的 `Formatter`，请实现前面显示的 `Formatter` 界面。将 `T` 参数化为要格式化的对象类型 — 例如，`java.util.Date`。实现 `print()` 操作来打印 `T` 的实例，以便在客户端区域设置中显示。实现 `parse()` 操作，从客户端语言环境返回的格式化表示中解析 `T` 的实例。如果解析尝试失败， `Formatter` 应该抛出 `ParseException` 或 `IllegalArgumentException`。注意确保 `Formatter` 实现是线程安全的。

`format` 子包为方便起见提供了几个 `Formatter` 实现。`number` 包提供了 `NumberStyleFormatter`、`CurrencyStyleFormatter` 和 `PercentStyleFormatter` 来格式化使用 `java.text.NumberFormat` 的 `number` 对象。`datetime` 包提供了一个 `DateFormatter`，用 `java.text.DateFormat` 来格式化 `java.util.Date` 的对象。

以下 `DateFormatter` 是 `Formatter` 实现的一个示例：

```java
package org.springframework.format.datetime;

public final class DateFormatter implements Formatter<Date> {

    private String pattern;

    public DateFormatter(String pattern) {
        this.pattern = pattern;
    }

    public String print(Date date, Locale locale) {
        if (date == null) {
            return "";
        }
        return getDateFormat(locale).format(date);
    }

    public Date parse(String formatted, Locale locale) throws ParseException {
        if (formatted.length() == 0) {
            return null;
        }
        return getDateFormat(locale).parse(formatted);
    }

    protected DateFormat getDateFormat(Locale locale) {
        DateFormat dateFormat = new SimpleDateFormat(this.pattern, locale);
        dateFormat.setLenient(false);
        return dateFormat;
    }
}
```

The Spring team welcomes community-driven `Formatter` contributions. See [GitHub Issues](https://github.com/spring-projects/spring-framework/issues) to contribute.

Spring 团队欢迎社区驱动的 `Formatter` 贡献。请参见 [GitHub Issues](https://github.com/spring-projects/spring-framework/issues) 以作出贡献。

#### 3.5.2. Annotation-driven Formatting

Field formatting can be configured by field type or annotation. To bind an annotation to a `Formatter`, implement `AnnotationFormatterFactory`. The following listing shows the definition of the `AnnotationFormatterFactory` interface:

可以按字段类型或注释配置字段格式。要将注释绑定到 `Formatter`，请实现 `AnnotationFormatterFactory`。以下列表显示了 `AnnotationFormatterFactory` 接口的定义：

```java
package org.springframework.format;

public interface AnnotationFormatterFactory<A extends Annotation> {

    Set<Class<?>> getFieldTypes();

    Printer<?> getPrinter(A annotation, Class<?> fieldType);

    Parser<?> getParser(A annotation, Class<?> fieldType);
}
```

To create an implementation:

1. Parameterize A to be the field `annotationType` with which you wish to associate formatting logic — for example `org.springframework.format.annotation.DateTimeFormat`.
2. Have `getFieldTypes()` return the types of fields on which the annotation can be used.
3. Have `getPrinter()` return a `Printer` to print the value of an annotated field.
4. Have `getParser()` return a `Parser` to parse a `clientValue` for an annotated field.

The following example `AnnotationFormatterFactory` implementation binds the `@NumberFormat` annotation to a formatter to let a number style or pattern be specified:

要创建实现，请执行以下操作：
1.将 A 参数化为 `annotationType` 字段，以便与格式逻辑关联 — 例如 `org.springframework.format.annotation.DateTimeFormat`。
2.让 `getFieldTypes()` 返回可以使用注释的字段类型。
3.让 `getPrinter()` 返回 `Printer` 来打印带注释字段的值。
4.让 `getParser()` 返回 `Parser` 来解析带注释字段的 `clientValue`。

以下示例 `AnnotationFormatterFactory` 实现将 `@NumberFormat` 注解绑定到格式化程序，以便指定数字样式或模式：

```java
public final class NumberFormatAnnotationFormatterFactory
        implements AnnotationFormatterFactory<NumberFormat> {

    public Set<Class<?>> getFieldTypes() {
        return new HashSet<Class<?>>(asList(new Class<?>[] {
            Short.class, Integer.class, Long.class, Float.class,
            Double.class, BigDecimal.class, BigInteger.class }));
    }

    public Printer<Number> getPrinter(NumberFormat annotation, Class<?> fieldType) {
        return configureFormatterFrom(annotation, fieldType);
    }

    public Parser<Number> getParser(NumberFormat annotation, Class<?> fieldType) {
        return configureFormatterFrom(annotation, fieldType);
    }

    private Formatter<Number> configureFormatterFrom(NumberFormat annotation, Class<?> fieldType) {
        if (!annotation.pattern().isEmpty()) {
            return new NumberStyleFormatter(annotation.pattern());
        } else {
            Style style = annotation.style();
            if (style == Style.PERCENT) {
                return new PercentStyleFormatter();
            } else if (style == Style.CURRENCY) {
                return new CurrencyStyleFormatter();
            } else {
                return new NumberStyleFormatter();
            }
        }
    }
}
```

To trigger formatting, you can annotate fields with @NumberFormat, as the following example shows:

要触发格式化，可以使用 @NumberFormat 注解字段，如下例所示：

```java
public class MyModel {

    @NumberFormat(style=Style.CURRENCY)
    private BigDecimal decimal;
}
```

##### Format Annotation API

A portable format annotation API exists in the `org.springframework.format.annotation` package. You can use `@NumberFormat` to format `Number` fields such as `Double` and `Long`, and `@DateTimeFormat` to format `java.util.Date`, `java.util.Calendar`, `Long` (for millisecond timestamps) as well as JSR-310 `java.time`.

The following example uses `@DateTimeFormat` to format a `java.util.Date` as an ISO Date (yyyy-MM-dd):

 `org.springframework.format.annotation` 包中存在可移植格式的注解 API。可以使用 `@NumberFormat` 格式化 `Number` 字段，如 `Double` 和 `Long`，使用 `@DateTimeFormat` 格式化 `java.util.Date`、`java.util.Calendar`、`Long`（毫秒时间戳）以及 JSR-310 `java.time`。

以下示例使用 `@DateTimeFormat` 将 `java.util.Date` 格式化为 ISO 日期（yyyy-MM-dd）：

```java
public class MyModel {

    @DateTimeFormat(iso=ISO.DATE)
    private Date date;
}
```

#### 3.5.3. The `FormatterRegistry` SPI

The `FormatterRegistry` is an SPI for registering formatters and converters. `FormattingConversionService` is an implementation of `FormatterRegistry` suitable for most environments. You can programmatically or declaratively configure this variant as a Spring bean, e.g. by using `FormattingConversionServiceFactoryBean`. Because this implementation also implements `ConversionService`, you can directly configure it for use with Spring’s `DataBinder` and the Spring Expression Language (SpEL).

The following listing shows the `FormatterRegistry` SPI:

`FormatterRegistry` 是一个 SPI，用于注册格式化程序和转换器 `FormattingConversionService` 是 `FormatterRegistry` 的一种实现，适用于大多数环境。您可以通过编程或声明方式将此变量配置为 Spring bean，例如使用 `FormattingConversionServiceFactoryBean`。由于此实现还实现了 `ConversionService`，因此可以直接将其配置为与Spring 的 `DataBinder` 和 Spring 表达式语言（SpEL）一起使用。

下面的列表显示了 `FormatterRegistry` SPI：

```java
package org.springframework.format;

public interface FormatterRegistry extends ConverterRegistry {

    void addPrinter(Printer<?> printer);

    void addParser(Parser<?> parser);

    void addFormatter(Formatter<?> formatter);

    void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter);

    void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser);

    void addFormatterForFieldAnnotation(AnnotationFormatterFactory<? extends Annotation> annotationFormatterFactory);
}
```

As shown in the preceding listing, you can register formatters by field type or by annotation.

The `FormatterRegistry` SPI lets you configure formatting rules centrally, instead of duplicating such configuration across your controllers. For example, you might want to enforce that all date fields are formatted a certain way or that fields with a specific annotation are formatted in a certain way. With a shared `FormatterRegistry`, you define these rules once, and they are applied whenever formatting is needed.

如前一清单所示，您可以按字段类型或注释注册格式化程序。

`FormatterRegistry` SPI 允许您集中配置格式化规则，而不是在控制器之间复制此类配置。例如，您可能希望强制所有日期字段以某种方式格式化，或者具有特定注释的字段以某种方式格式化。使用共享的 `FormatterRegistry`，您可以定义这些规则一次，并在需要格式化时应用它们。

#### 3.5.4. The `FormatterRegistrar` SPI

`FormatterRegistrar` is an SPI for registering formatters and converters through the FormatterRegistry. The following listing shows its interface definition:

`FormatterRegistrar`是一个 SPI，用于通过 FormatterRegistry 注册格式化程序和转换器。下面的列表显示了它的接口定义：

```java
package org.springframework.format;

public interface FormatterRegistrar {

    void registerFormatters(FormatterRegistry registry);
}
```

A `FormatterRegistrar` is useful when registering multiple related converters and formatters for a given formatting category, such as date formatting. It can also be useful where declarative registration is insufficient — for example, when a formatter needs to be indexed under a specific field type different from its own `<T>` or when registering a `Printer`/`Parser` pair. The next section provides more information on converter and formatter registration.

当为给定的格式类别（如日期格式）注册多个相关转换器和格式设置程序时，`FormatterRegistrar` 很有用。在声明性注册不足的情况下，它也很有用 — 例如，当格式化程序需要在与其自身的 `<T>` 不同的特定字段类型下编制索引时，或者当注册`Printer`/`Parser` 对时。下一节将提供有关转换器和格式化程序注册的更多信息。

#### 3.5.5. Configuring Formatting in Spring MVC

See [Conversion and Formatting](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-conversion) in the Spring MVC chapter.

请参阅 Spring MVC 一章中的[Conversion and Formatting](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-conversion)。

### 3.6. Configuring a Global Date and Time Format

### 3.6. 配置全局日期和时间格式

By default, date and time fields not annotated with `@DateTimeFormat` are converted from strings by using the `DateFormat.SHORT` style. If you prefer, you can change this by defining your own global format.

To do that, ensure that Spring does not register default formatters. Instead, register formatters manually with the help of:

- `org.springframework.format.datetime.standard.DateTimeFormatterRegistrar`
- `org.springframework.format.datetime.DateFormatterRegistrar`

For example, the following Java configuration registers a global `yyyyMMdd` format:

默认情况下，未使用 `@DateTimeFormat` 注释的日期和时间字段通过使用 `DateFormat.SHORT` 样式从字符串转换而来。如果愿意，您可以通过定义自己的全局格式来改变这一点。

为此，请确保 Spring 不注册默认格式化程序。相反，请在以下帮助下手动注册格式化程序：

- `org.springframework.format.datetime.standard.DateTimeFormatterRegistrar`
- `org.springframework.format.datetime.DateFormatterRegistrar`

例如，以下 Java 配置注册了全局 `yyyyMMdd` 格式：

```java
@Configuration
public class AppConfig {

    @Bean
    public FormattingConversionService conversionService() {

        // Use the DefaultFormattingConversionService but do not register defaults
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false);

        // Ensure @NumberFormat is still supported
        conversionService.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory());

        // Register JSR-310 date conversion with a specific global format
        DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
        registrar.setDateFormatter(DateTimeFormatter.ofPattern("yyyyMMdd"));
        registrar.registerFormatters(conversionService);

        // Register date conversion with a specific global format
        DateFormatterRegistrar registrar = new DateFormatterRegistrar();
        registrar.setFormatter(new DateFormatter("yyyyMMdd"));
        registrar.registerFormatters(conversionService);

        return conversionService;
    }
}
```

If you prefer XML-based configuration, you can use a `FormattingConversionServiceFactoryBean`. The following example shows how to do so:

如果您喜欢基于 XML 的配置，可以使用 `FormattingConversionServiceFactoryBean`。以下示例显示了如何执行此操作：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd>

    <bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
        <property name="registerDefaultFormatters" value="false" />
        <property name="formatters">
            <set>
                <bean class="org.springframework.format.number.NumberFormatAnnotationFormatterFactory" />
            </set>
        </property>
        <property name="formatterRegistrars">
            <set>
                <bean class="org.springframework.format.datetime.standard.DateTimeFormatterRegistrar">
                    <property name="dateFormatter">
                        <bean class="org.springframework.format.datetime.standard.DateTimeFormatterFactoryBean">
                            <property name="pattern" value="yyyyMMdd"/>
                        </bean>
                    </property>
                </bean>
            </set>
        </property>
    </bean>
</beans>
```

Note there are extra considerations when configuring date and time formats in web applications. Please see [WebMVC Conversion and Formatting](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-conversion) or [WebFlux Conversion and Formatting](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config-conversion).

注意：在 web 应用程序中配置日期和时间格式时，有额外的注意事项。请看  [WebMVC Conversion and Formatting](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-conversion) 或者 [WebFlux Conversion and Formatting](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config-conversion)。

### 3.7. Java Bean Validation

### 3.7. JavaBean 验证

The Spring Framework provides support for the [Java Bean Validation](https://beanvalidation.org/) API.

Spring 框架支持 [JavaBean 验证](https://beanvalidation.org/) API。

#### 3.7.1. Overview of Bean Validation

#### 3.7.1. Bean 验证概述

Bean Validation provides a common way of validation through constraint declaration and metadata for Java applications. To use it, you annotate domain model properties with declarative validation constraints which are then enforced by the runtime. There are built-in constraints, and you can also define your own custom constraints.

Consider the following example, which shows a simple `PersonForm` model with two properties:

Bean 验证为 Java 应用程序提供了一种通过约束声明和元数据进行验证的通用方法。要使用它，可以使用声明性验证约束对域模型属性进行注释，然后由运行时强制执行这些约束。有内置的约束，您也可以定义自己的自定义约束。

考虑下面的示例，它显示了一个简单的 `PersonForm` 模型，具有两个属性：

```java
public class PersonForm {
    private String name;
    private int age;
}
```

Bean Validation lets you declare constraints as the following example shows:

Bean 验证允许您声明约束，如下例所示：

```java
public class PersonForm {

    @NotNull
    @Size(max=64)
    private String name;

    @Min(0)
    private int age;
}
```

A Bean Validation validator then validates instances of this class based on the declared constraints. See [Bean Validation](https://beanvalidation.org/) for general information about the API. See the [Hibernate Validator](https://hibernate.org/validator/) documentation for specific constraints. To learn how to set up a bean validation provider as a Spring bean, keep reading.

然后，Bean 验证程序根据声明的约束验证此类的实例。有关 API 的一般信息，请参见 [Bean Validation](https://beanvalidation.org/)。请参阅 [Hibernate Validator](https://hibernate.org/validator/) 文档以了解特定约束。要了解如何将 bean 验证提供者设置为 Spring bean，请继续阅读。

#### 3.7.2. Configuring a Bean Validation Provider

#### 3.7.2. 配置 Bean 验证提供程序

Spring provides full support for the Bean Validation API including the bootstrapping of a Bean Validation provider as a Spring bean. This lets you inject a `javax.validation.ValidatorFactory` or `javax.validation.Validator` wherever validation is needed in your application.

You can use the `LocalValidatorFactoryBean` to configure a default Validator as a Spring bean, as the following example shows:

Spring 提供了对 Bean 验证 API 的全面支持，包括将 Bean 验证提供者引导为 Spring Bean。这使您可以在应用程序中需要验证的任何地方注入 `javax.validation.ValidatorFactory` 或 `javax.validation.Validator`。

可以使用 `LocalValidatorFactoryBean` 将默认验证器配置为Spring Bean，如下例所示：

```java
import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;

@Configuration
public class AppConfig {

    @Bean
    public LocalValidatorFactoryBean validator() {
        return new LocalValidatorFactoryBean();
    }
}
```

The basic configuration in the preceding example triggers bean validation to initialize by using its default bootstrap mechanism. A Bean Validation provider, such as the Hibernate Validator, is expected to be present in the classpath and is automatically detected.

上例中的基本配置使用默认引导机制触发 bean 验证进行初始化。Bean 验证提供程序（如 Hibernate 验证程序）预计会出现在类路径中，并被自动检测到。

##### Injecting a Validator

##### 注入验证器

`LocalValidatorFactoryBean` implements both `javax.validation.ValidatorFactory` and `javax.validation.Validator`, as well as Spring’s `org.springframework.validation.Validator`. You can inject a reference to either of these interfaces into beans that need to invoke validation logic.

You can inject a reference to `javax.validation.Validator` if you prefer to work with the Bean Validation API directly, as the following example shows:

`LocalValidatorFactoryBean` 实现了 `javax.validation.ValidatorFactory` 和 `javax.validation.Validator`，以及 Spring 的 `org.springframework.validation.Validator`。您可以将这些接口的引用注入需要调用验证逻辑的 bean 中。

您可以插入对 `javax.validation.Validator` 的引用如果您喜欢直接使用 Bean 验证 API，如下例所示：

```java
import javax.validation.Validator;

@Service
public class MyService {

    @Autowired
    private Validator validator;
}
```

You can inject a reference to `org.springframework.validation.Validator` if your bean requires the Spring Validation API, as the following example shows:

如果 bean 需要 Spring 验证 API，则可以插入对 `org.springframework.validation.Validator`  的引用，如下例所示：

```java
import org.springframework.validation.Validator;

@Service
public class MyService {

    @Autowired
    private Validator validator;
}
```

##### Configuring Custom Constraints

##### 配置自定义约束

Each bean validation constraint consists of two parts:

- A `@Constraint` annotation that declares the constraint and its configurable properties.
- An implementation of the `javax.validation.ConstraintValidator` interface that implements the constraint’s behavior.

To associate a declaration with an implementation, each `@Constraint` annotation references a corresponding `ConstraintValidator` implementation class. At runtime, a `ConstraintValidatorFactory` instantiates the referenced implementation when the constraint annotation is encountered in your domain model.

By default, the `LocalValidatorFactoryBean` configures a `SpringConstraintValidatorFactory` that uses Spring to create `ConstraintValidator` instances. This lets your custom `ConstraintValidators` benefit from dependency injection like any other Spring bean.

The following example shows a custom `@Constraint` declaration followed by an associated `ConstraintValidator` implementation that uses Spring for dependency injection:

每个 bean 验证约束由两部分组成：

- 声明约束及其可配置属性的 `@Constraint`  注解。
- 实现约束行为的 `javax.validation.ConstraintValidator` 接口的实现。

要将声明与实现相关联，每个 `@Constraint` 注释都会引用相应的 `ConstraintValidator` 实现类。在运行时，当在域模型中遇到约束注释时，`ConstraintValidatorFactory` 会实例化引用的实现。

默认情况下， `LocalValidatorFactoryBean`  配置一个 `SpringConstraintValidatorFactory`，它使用 Spring 创建`ConstraintValidator` 实例。这让您的自定义 `ConstraintValidators` 像其他 Spring bean 一样受益于依赖项注入。

以下示例显示了一个自定义的 `@Constraint` 声明，后面是一个关联的 `ConstraintValidator` 实现，该实现使用 Spring 进行依赖项注入：

```java
@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy=MyConstraintValidator.class)
public @interface MyConstraint {
}
```

```java
import javax.validation.ConstraintValidator;

public class MyConstraintValidator implements ConstraintValidator {

    @Autowired;
    private Foo aDependency;

    // ...
}
```

As the preceding example shows, a `ConstraintValidator` implementation can have its dependencies `@Autowired` as any other Spring bean.

正如前面的示例所示， `ConstraintValidator` 实现可以像任何其他 Spring bean 一样拥有其依赖项 `@Autowired`。

##### Spring-driven Method Validation

You can integrate the method validation feature supported by Bean Validation 1.1 (and, as a custom extension, also by Hibernate Validator 4.3) into a Spring context through a `MethodValidationPostProcessor` bean definition:

您可以通过 `MethodValidationPostProcessor` Bean 定义将 Bean validation 1.1（以及 Hibernate Validator 4.3 的自定义扩展）支持的方法验证功能集成到 Spring 上下文中：

```java
import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;

@Configuration
public class AppConfig {

    @Bean
    public MethodValidationPostProcessor validationPostProcessor() {
        return new MethodValidationPostProcessor();
    }
}
```

To be eligible for Spring-driven method validation, all target classes need to be annotated with Spring’s `@Validated` annotation, which can optionally also declare the validation groups to use. See [`MethodValidationPostProcessor`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/validation/beanvalidation/MethodValidationPostProcessor.html) for setup details with the Hibernate Validator and Bean Validation 1.1 providers.

为了符合 Spring 驱动方法验证的条件，所有目标类都需要使用 Spring 的 `@Validated` 注释进行注释，该注释还可以选择性地声明要使用的验证组。有关 Hibernate Validator 和 Bean Validation 1.1 提供程序的安装详细信息，请参阅 [`MethodValidationPostProcessor`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/validation/beanvalidation/MethodValidationPostProcessor.html)。

> Method validation relies on [AOP Proxies](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-introduction-proxies) around the target classes, either JDK dynamic proxies for methods on interfaces or CGLIB proxies. There are certain limitations with the use of proxies, some of which are described in [Understanding AOP Proxies](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-understanding-aop-proxies). In addition remember to always use methods and accessors on proxied classes; direct field access will not work.
>
> 方法验证依赖于目标类周围的 [AOP 代理](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-introduction-proxies)，或者是接口上方法的 JDK 动态代理，或者是 CGLIB 代理。代理的使用有一定的局限性，其中一些在 [了解 AOP 代理](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-understanding-aop-proxies) ]中有描述。此外，请记住始终在代理类上使用方法和访问器；直接现场访问将不起作用。

##### Additional Configuration Options

The default `LocalValidatorFactoryBean` configuration suffices for most cases. There are a number of configuration options for various Bean Validation constructs, from message interpolation to traversal resolution. See the [`LocalValidatorFactoryBean`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/validation/beanvalidation/LocalValidatorFactoryBean.html) javadoc for more information on these options.

默认的 `LocalValidatorFactoryBean` 配置在大多数情况下都足够了。对于各种 Bean 验证构造，有许多配置选项，从消息插值到遍历解析。有关这些选项的更多信息，请参阅 [`LocalValidatorFactoryBean`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/validation/beanvalidation/LocalValidatorFactoryBean.html) javadoc。

#### 3.7.3. Configuring a `DataBinder`

#### 3.7.3. 配置 `DataBinder`

Since Spring 3, you can configure a `DataBinder` instance with a `Validator`. Once configured, you can invoke the `Validator` by calling `binder.validate()`. Any validation `Errors` are automatically added to the binder’s `BindingResult`.

The following example shows how to use a `DataBinder` programmatically to invoke validation logic after binding to a target object:

从 Spring 3 开始，您可以使用 `Validator` 配置 `DataBinder` 实例。配置完成后，可以通过调用 `binder.validate()` 来调用 `Validator` 。任何验证 `Errors` 都会自动添加到 binder 的 `BindingResult` 中。

以下示例显示了如何在绑定到目标对象后以编程方式使用 `DataBinder` 来调用验证逻辑：

```java
Foo target = new Foo();
DataBinder binder = new DataBinder(target);
binder.setValidator(new FooValidator());

// bind to the target object
binder.bind(propertyValues);

// validate the target object
binder.validate();

// get BindingResult that includes any validation errors
BindingResult results = binder.getBindingResult();
```

You can also configure a `DataBinder` with multiple `Validator` instances through `dataBinder.addValidators` and `dataBinder.replaceValidators`. This is useful when combining globally configured bean validation with a Spring `Validator` configured locally on a DataBinder instance. See [Spring MVC Validation Configuration](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-validation).

您还可以通过 `dataBinder.addValidators` 和  `dataBinder.replaceValidators` 配置一个带有多个 `Validator` 实例的 `DataBinder`。这在将全局配置的 bean 验证与在 DataBinder 实例上本地配置的 Spring `Validator` 相结合时非常有用。请参阅[Spring MVC 验证配置](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-validation)。

#### 3.7.4. Spring MVC 3 Validation

See [Validation](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-validation) in the Spring MVC chapter.

请参阅 Spring MVC 一章中的 [Validation](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-validation)。