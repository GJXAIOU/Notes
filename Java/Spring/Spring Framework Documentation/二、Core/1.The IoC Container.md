

# Core Technologies

Version 5.3.13

This part of the reference documentation covers all the technologies that are absolutely integral to the Spring Framework.

Foremost amongst these is the Spring Framework’s Inversion of Control (IoC) container. A thorough treatment of the Spring Framework’s IoC container is closely followed by comprehensive coverage of Spring’s Aspect-Oriented Programming (AOP) technologies. The Spring Framework has its own AOP framework, which is conceptually easy to understand and which successfully addresses the 80% sweet spot of AOP requirements in Java enterprise programming.

Coverage of Spring’s integration with AspectJ (currently the richest — in terms of features — and certainly most mature AOP implementation in the Java enterprise space) is also provided.

参考文档的这一部分涵盖了Spring 框架中绝对不可或缺的所有技术。

其中最重要的是 Spring 框架的控制反转（Inversion of Control，IoC）容器。在对 Spring 框架的 IoC 容器进行全面介绍之后，将全面介绍 Spring 的面向切面编程（AOP）技术。Spring 框架有自己的 AOP 框架，在概念上很容易理解，它成功地解决了 Java 企业编程中 80% 的 AOP 需求。

Spring 与 AspectJ 集成的报道（目前最丰富 — 就特征而言 — 当然，也提供了 Java 企业空间中最成熟的 AOP 实现。

## 1. The IoC Container

## 1.IoC 容器

This chapter covers Spring’s Inversion of Control (IoC) container.

本章介绍 Spring 的控制反转（Inversion of Control，IoC）容器。

### 1.1. Introduction to the Spring IoC Container and Beans

### 1.1. Spring IoC 容器和 bean 简介

This chapter covers the Spring Framework implementation of the Inversion of Control (IoC) principle. IoC is also known as dependency injection (DI). It is a process whereby objects define their dependencies (that is, the other objects they work with) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes or a mechanism such as the Service Locator pattern.

The `org.springframework.beans` and `org.springframework.context` packages are the basis for Spring Framework’s IoC container. The [`BeanFactory`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/BeanFactory.html) interface provides an advanced configuration mechanism capable of managing any type of object. [`ApplicationContext`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/ApplicationContext.html) is a sub-interface of `BeanFactory`. It adds:

- Easier integration with Spring’s AOP features
- Message resource handling (for use in internationalization)
- Event publication
- Application-layer specific contexts such as the `WebApplicationContext` for use in web applications.

In short, the `BeanFactory` provides the configuration framework and basic functionality, and the `ApplicationContext` adds more enterprise-specific functionality. The `ApplicationContext` is a complete superset of the `BeanFactory` and is used exclusively in this chapter in descriptions of Spring’s IoC container. For more information on using the `BeanFactory` instead of the `ApplicationContext,` see [The `BeanFactory`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beanfactory).

In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container.

本章介绍控制反转（IoC）原则在 Spring 框架中的实现。**IoC 也称为依赖注入（DI）** 。**这是一个过程，对象仅通过构造函数参数、工厂方法的参数或在对象实例构造或从工厂方法返回后在对象实例上设置的属性来定义它们的依赖关系（即它们使用的其他对象）。然后，容器在创建 bean 时注入这些依赖项。这个过程基本上是 bean 本身的逆过程（因此称为控制反转），通过使用类的直接构造或服务定位器模式等机制来控制其依赖项的实例化或位置。**

`org.springframework.beans` 和 `org.springframework.context` 包是 Spring 框架的 IoC 容器的基础。[`BeanFactory`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/BeanFactory.html)接口提供了一种高级配置机制，能够管理任何类型的对象。**[`ApplicationContext`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/ApplicationContext.html)是「BeanFactory」的子接口**。它增加了以下功能：

- 更容易与 Spring 的 AOP 功能集成
- 消息资源处理（用于国际化）
- 事件发布
- 特定于应用层的上下文，如用于 web 应用程序的 `WebApplicationContext`。

简而言之，`BeanFactory`提供了配置框架和基本功能，`ApplicationContext`添加了更多特定于企业的功能。 **`ApplicationContext` 是 `BeanFactory` 的完整超集**，在本章中专门用于描述 Spring 的 IoC 容器。**有关使用 `BeanFactory` 而不是 `ApplicationContext` 的详细信息，请参见[BeanFactory](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beanfactory)。**

**在 Spring 中，构成应用程序主干并由 Spring IOC 容器管理的对象称为 beans。bean 是由 Spring IOC 容器实例化、组装和管理的对象**。否则，bean 只是应用程序中许多对象中的一个。**bean 以及它们之间的依赖关系反映在容器使用的配置元数据中**。

### 1.2. Container Overview

### 1.2. 容器概述

The `org.springframework.context.ApplicationContext` interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans. The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It lets you express the objects that compose your application and the rich interdependencies between those objects.

Several implementations of the `ApplicationContext` interface are supplied with Spring. In stand-alone applications, it is common to create an instance of [`ClassPathXmlApplicationContext`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html) or [`FileSystemXmlApplicationContext`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html). While XML has been the traditional format for defining configuration metadata, you can instruct the container to use Java annotations or code as the metadata format by providing a small amount of XML configuration to declaratively enable support for these additional metadata formats.

In most application scenarios, explicit user code is not required to instantiate one or more instances of a Spring IoC container. For example, in a web application scenario, a simple eight (or so) lines of boilerplate web descriptor XML in the `web.xml` file of the application typically suffices (see [Convenient ApplicationContext Instantiation for Web Applications](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-create)). If you use the [Spring Tools for Eclipse](https://spring.io/tools) (an Eclipse-powered development environment), you can easily create this  or application.

**`org.springframework.context.ApplicationContext`接口代表 Spring IOC 容器，负责实例化、配置和组装 bean。容器通过读取配置元数据获取关于实例化、配置和组装哪些对象的指令。配置元数据以 XML、Java 注解或 Java 代码表示，它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。**

Spring 提供了`ApplicationContext`接口的几种实现。在单体应用程序中，通常会创建 [ClassPathXmlApplicationContext](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html) 的实例或 [FileSystemXmlApplicationContext](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html) 的实例。虽然 XML 一直是定义配置元数据的传统格式，但您可以指示容器使用 Java 注解或代码作为元数据格式，方法是提供少量 XML 配置，以声明方式支持这些附加元数据格式。

在大多数应用程序场景中，是不需要通过显式的用户代码来实例化 Spring IOC 容器的一个或多个实例。例如，在 web 应用程序场景中，`web.xml` 中的一个简单的八行（大约）样板 web 描述符 XML。应用程序的 XML 文件通常就足够了（请参阅 [Web应用程序的便捷应用程序上下文实例化](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-create)）。如果您使用[Spring Tools for Eclipse](https://spring.io/tools)（一个支持 Eclipse 的开发环境），只需点击几下鼠标或按键，就可以轻松创建这个样板配置。

下图显示了 Spring 如何工作的高级视图。您的应用程序类与配置元数据相结合，这样，在创建并初始化  `ApplicationContext` 之后，您就拥有了一个完全配置且可执行的系统或应用程序。

![container magic](1.The IoC Container.resource/container-magic.png)

Figure 1. The Spring IoC container

#### 1.2.1. Configuration Metadata

#### 1.2.1. 配置元数据

As the preceding diagram shows, the Spring IoC container consumes a form of configuration metadata. This configuration metadata represents how you, as an application developer, tell the Spring container to instantiate, configure, and assemble the objects in your application.

Configuration metadata is traditionally supplied in a simple and intuitive XML format, which is what most of this chapter uses to convey key concepts and features of the Spring IoC container.

> XML-based metadata is not the only allowed form of configuration metadata. The Spring IoC container itself is totally decoupled from the format in which this configuration metadata is actually written. These days, many developers choose [Java-based configuration](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java) for their Spring applications.

如上图所示，Spring IOC 容器使用一种形式的配置元数据。此配置元数据表示作为应用程序开发人员，您如何告知 Spring 容器实例化、配置和组装应用程序中的对象。

配置元数据传统上是以简单直观的 XML 格式提供的，这是本章大部分内容用来传达 Spring IOC 容器的关键概念和特性的。

>基于 XML 的元数据不是唯一允许的配置元数据形式。**Spring IOC 容器本身与实际写入此配置元数据的格式完全解耦**。如今，许多开发人员选择[基于Java 的配置](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java)的 Spring 应用程序。

For information about using other forms of metadata with the Spring container, see:

- [Annotation-based configuration](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config): Spring 2.5 introduced support for annotation-based configuration metadata.
- [Java-based configuration](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java): Starting with Spring 3.0, many features provided by the Spring JavaConfig project became part of the core Spring Framework. Thus, you can define beans external to your application classes by using Java rather than XML files. To use these new features, see the [`@Configuration`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html), [`@Bean`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html), [`@Import`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html), and [`@DependsOn`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html) annotations.

Spring configuration consists of at least one and typically more than one bean definition that the container must manage. XML-based configuration metadata configures these beans as `<bean/>` elements inside a top-level `<beans/>` element. Java configuration typically uses `@Bean`-annotated methods within a `@Configuration` class.

These bean definitions correspond to the actual objects that make up your application. Typically, you define service layer objects, data access objects (DAOs), presentation objects such as Struts `Action` instances, infrastructure objects such as Hibernate `SessionFactories`, JMS `Queues`, and so forth. Typically, one does not configure fine-grained domain objects in the container, because it is usually the responsibility of DAOs and business logic to create and load domain objects. However, you can use Spring’s integration with AspectJ to configure objects that have been created outside the control of an IoC container. See [Using AspectJ to dependency-inject domain objects with Spring](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-atconfigurable).

有关在 Spring 容器中使用其他形式元数据的信息，请参阅：

- [基于注解的配置](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config)：Spring 2.5 引入了对基于注解的配置元数据的支持。

- [基于 Java 的配置](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java)：从 Spring 3.0 开始，Spring Java Config 项目提供的许多特性成为核心 Spring 框架的一部分。因此，您可以使用 Java 而不是 XML 文件来**定义应用程序类外部的 bean**。要使用这些新功能，请参阅[`@Configuration`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html)，[`@Bean`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html)，[`@Import`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html)，和[`@DependsOn`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html)注解。

Spring 配置由容器必须管理的至少一个且通常不止一个 bean 定义组成。基于 XML 的配置元数据将这些 bean 配置为顶级 `<beans/>`元素中的`<bean/>`元素。Java 配置通常在`@configuration`类中使用带 `@Bean` 注解的方法。

这些 bean 定义对应于构成应用程序的实际对象。通常，您定义服务层对象、数据访问对象（DAO）、展示对象（如Struts`Action`实例）、基础结构对象（如 Hibernate 的 `SessionFactorys`、JMS 的`Queues`）等等。通常，不在容器中配置细粒度域对象，因为创建和加载域对象通常是 DAO 和业务逻辑的责任。但是，您**可以使用 Spring 与 AspectJ 的集成来配置在 IoC 容器控制之外创建的对象**。请参阅[使用 AspectJ 向 Spring 注入依赖项域对象](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-atconfigurable)。

The following example shows the basic structure of XML-based configuration metadata:

以下示例显示了基于 XML 的配置元数据的基本结构：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="..." class="...">  <!--注解一/二-->
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <bean id="..." class="...">
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions go here -->
</beans>
```

- 注解一：The `id` attribute is a string that identifies the individual bean definition.
- 注解二：The `class` attribute defines the type of the bean and uses the fully qualified classname.

The value of the `id` attribute refers to collaborating objects. The XML for referring to collaborating objects is not shown in this example. See [Dependencies](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependencies) for more information.

- 注解一：`id` 属性是标识单个 bean 定义的字符串。

- 注解二：`class` 属性定义 bean 的类型并使用完全限定的类名。

`id` 属性的值引用协作对象。本例中未显示用于引用协作对象的 XML。参见[依赖关系](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependencies)以获取更多信息。

#### 1.2.2. Instantiating a Container 

#### 1.2.2.实例化容器

The location path or paths supplied to an `ApplicationContext` constructor are resource strings that let the container load configuration metadata from a variety of external resources, such as the local file system, the Java `CLASSPATH`, and so on.

提供给`ApplicationContext`构造函数的一个或多个位置路径是资源字符串，允许容器从各种外部资源（如本地文件系统、Java`CLASSPATH`）加载配置元数据。

```java
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
```

>After you learn about Spring’s IoC container, you may want to know more about Spring’s `Resource` abstraction (as described in [Resources](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources)), which provides a convenient mechanism for reading an InputStream from locations defined in a URI syntax. In particular, `Resource` paths are used to construct applications contexts, as described in [Application Contexts and Resource Paths](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-app-ctx).
>
>在了解了 Spring 的 IoC 容器之后，您可能想进一步了解 Spring 的`Resource`抽象（如[Resources](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources)中所述），它提供了一种方便的机制，用于从 URI 语法中定义的位置读取 InputStream。特别是，`Resource`路径用于构造应用程序上下文，如 [Application Contexts and Resource Paths](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-app-ctx)中所述。

The following example shows the service layer objects `(services.xml)` configuration file:

以下示例显示服务层对象`（services.xml）`配置文件：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- services -->

    <bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">
        <property name="accountDao" ref="accountDao"/>
        <property name="itemDao" ref="itemDao"/>
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions for services go here -->
</beans>
```

The following example shows the data access objects `daos.xml` file:

下面的示例显示了数据访问对象的`daos.xml`文件：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="accountDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions for data access objects go here -->
</beans>
```

In the preceding example, the service layer consists of the `PetStoreServiceImpl` class and two data access objects of the types `JpaAccountDao` and `JpaItemDao` (based on the JPA Object-Relational Mapping standard). The `property name` element refers to the name of the JavaBean property, and the `ref` element refers to the name of another bean definition. This linkage between `id` and `ref` elements expresses the dependency between collaborating objects. For details of configuring an object’s dependencies, see [Dependencies](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependencies).

在前面的示例中，服务层由 `PetStoreServiceImpl` 类和两个类型为 `JpaAccountDao` 和 `JpaItemDao` 的数据访问对象（基于 JPA 对象关系映射标准）组成。**`property name`元素引用 JavaBean 属性的名称，`ref` 元素引用另一个 bean 定义的名称。`id`和 `ref`元素之间的这种链接表示协作对象之间的依赖关系。有关配置对象依赖项的详细信息，**请参阅[Dependencies](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependencies)。

##### Composing XML-based Configuration Metadata

##### 组合基于 XML 的配置元数据

It can be useful to have bean definitions span multiple XML files. Often, each individual XML configuration file represents a logical layer or module in your architecture.

You can use the application context constructor to load bean definitions from all these XML fragments. This constructor takes multiple `Resource` locations, as was shown in the [previous section](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-instantiation). Alternatively, use one or more occurrences of the `<import/>` element to load bean definitions from another file or files. The following example shows how to do so:

让 bean 定义跨越多个 XML 文件可能很有用。通常，每个单独的 XML 配置文件都表示体系结构中的一个逻辑层或模块。

您**可以使用应用程序上下文构造函数从所有这些 XML 片段加载 bean 定义。此构造函数接受多个`Resource`位置，如[上一节](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-instantiation)所示。或者，使用一个或多个出现的 `<import/>`元素从另一个或多个文件加载 bean 定义**。以下示例显示了如何执行此操作：

```xml
<beans>
    <import resource="services.xml"/>
    <import resource="resources/messageSource.xml"/>
    <import resource="/resources/themeSource.xml"/>

    <bean id="bean1" class="..."/>
    <bean id="bean2" class="..."/>
</beans>
```

In the preceding example, external bean definitions are loaded from three files: `services.xml`, `messageSource.xml`, and `themeSource.xml`. All location paths are relative to the definition file doing the importing, so `services.xml` must be in the same directory or classpath location as the file doing the importing, while `messageSource.xml` and `themeSource.xml` must be in a `resources` location below the location of the importing file. As you can see, a leading slash is ignored. However, given that these paths are relative, it is better form not to use the slash at all. The contents of the files being imported, including the top level `<beans/>` element, must be valid XML bean definitions, according to the Spring Schema.

在前面的示例中，外部 bean 定义是从三个文件加载的：`services.xml`，`messageSource.xml`，和`themeSource.xml`。**所有位置路径都是相对于执行导入的定义文件的**，因此`service.xml`必须与执行导入的文件位于同一目录或类路径位置，而`messageSource.xml`和`themeSource.xml`必须位于导入文件位置下方的 `resources` 位置。如您所见，==前导斜杠被忽略==。然而，**考虑到这些路径是相对的，最好不要使用斜杠**。根据 Spring 模式，要导入的文件的内容，包括顶级的 `<beans/>` 元素，必须是有效的 XML Bean 定义。

>  It is possible, but not recommended, to reference files in parent directories using a relative "../" path. Doing so creates a dependency on a file that is outside the current application. In particular, this reference is not recommended for `classpath:` URLs (for example, `classpath:../services.xml`), where the runtime resolution process chooses the “nearest” classpath root and then looks into its parent directory. Classpath configuration changes may lead to the choice of a different, incorrect directory.You can always use fully qualified resource locations instead of relative paths: for example, `file:C:/config/services.xml` or `classpath:/config/services.xml`. However, be aware that you are coupling your application’s configuration to specific absolute locations. It is generally preferable to keep an indirection for such absolute locations — for example, through "${…}" placeholders that are resolved against JVM system properties at runtime.
>
>  可以（但不建议）使用相对`./`路径引用父目录中的文件。这样做**会创建对当前应用程序之外的文件的依赖关系**。特别是，不建议对`classpath:`URL（例如，`classpath:../services.xml`）使用此引用，其中运行时解析过程选择“最近的”类路径根，然后查找其父目录。类路径配置更改可能会导致选择不同的、不正确的目录。您始终可以使用完全限定的资源位置而不是相对路径：例如，`file:C:/config/services.xml`或`classpath:/config/services.xml`。但是，请注意，您正在将应用程序的配置耦合到特定的绝对位置。通常，最好为此类绝对位置保留一个间接方向 — 例如，通过在运行时根据 JVM 系统属性解析的“${…}”占位符。

The namespace itself provides the import directive feature. Further configuration features beyond plain bean definitions are available in a selection of XML namespaces provided by Spring — for example, the `context` and `util` namespaces.

命名空间本身提供导入指令功能。Spring 提供的一系列 XML 命名空间中提供了普通 bean 定义之外的更多配置特性，例如，`context`和`util`命名空间。

##### The Groovy Bean Definition DSL

##### Groovy bean 定义 DSL

As a further example for externalized configuration metadata, bean definitions can also be expressed in Spring’s Groovy Bean Definition DSL, as known from the Grails framework. Typically, such configuration live in a ".groovy" file with the structure shown in the following example:

作为外部化配置元数据的另一个示例，bean 定义也可以在 Spring 的 Groovy bean 定义 DSL 中表示，正如 Grails 框架所知。通常，此类配置位于 `.groovy` 文件中，其结构如以下示例所示：

```groovy
beans {
    dataSource(BasicDataSource) {
        driverClassName = "org.hsqldb.jdbcDriver"
        url = "jdbc:hsqldb:mem:grailsDB"
        username = "sa"
        password = ""
        settings = [mynew:"setting"]
    }
    sessionFactory(SessionFactory) {
        dataSource = dataSource
    }
    myService(MyService) {
        nestedBean = { AnotherBean bean ->
            dataSource = dataSource
        }
    }
}
```

This configuration style is largely equivalent to XML bean definitions and even supports Spring’s XML configuration namespaces. It also allows for importing XML bean definition files through an `importBeans` directive.

这种配置风格在很大程度上等同于 XML Bean 定义，甚至支持 Spring 的 XML 配置命名空间。它还允许通过 `import Beans` 指令导入 XML Bean 定义文件。

#### 1.2.3. Using the Container

#### 1.2.3.使用容器

The `ApplicationContext` is the interface for an advanced factory capable of maintaining a registry of different beans and their dependencies. By using the method `T getBean(String name, Class<T> requiredType)`, you can retrieve instances of your beans.

The `ApplicationContext` lets you read bean definitions and access them, as the following example shows:

`ApplicationContext`是高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。通过使用方法`T getBean(String name,Class<T> requiredType)`，您可以检索 bean 的实例。

`ApplicationContext`允许您读取 bean 定义并访问它们，如下例所示：

```java
// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

// retrieve configured instance
PetStoreService service = context.getBean("petStore", PetStoreService.class);

// use configured instance
List<String> userList = service.getUsernameList();
```

With Groovy configuration, bootstrapping looks very similar. It has a different context implementation class which is Groovy-aware (but also understands XML bean definitions). The following example shows Groovy configuration:

对于 Groovy 配置，引导看起来非常相似。它有一个不同的上下文实现类，它是 Groovy 感知的（但也理解 XML Bean 定义）。以下示例显示 Groovy 配置：

```java
ApplicationContext context = new GenericGroovyApplicationContext("services.groovy", "daos.groovy");
```

The most flexible variant is `GenericApplicationContext` in combination with reader delegates — for example, with `XmlBeanDefinitionReader` for XML files, as the following example shows:

**最灵活的变体是 `GenericApplicationContext`**，它与读者委托相结合—例如，对于 XML 文件使用 `XmlBeanDefinitionReader`，如下例所示：

```java
GenericApplicationContext context = new GenericApplicationContext();
new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
context.refresh();
```

You can also use the `GroovyBeanDefinitionReader` for Groovy files, as the following example shows:

您还可以对 Groovy 文件使用 `GroovyBeanDefinitionReader`，如下例所示：

```java
GenericApplicationContext context = new GenericApplicationContext();
new GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy");
context.refresh();
```

You can mix and match such reader delegates on the same `ApplicationContext`, reading bean definitions from diverse configuration sources.

You can then use `getBean` to retrieve instances of your beans. The `ApplicationContext` interface has a few other methods for retrieving beans, but, ideally, your application code should never use them. Indeed, your application code should have no calls to the `getBean()` method at all and thus have no dependency on Spring APIs at all. For example, Spring’s integration with web frameworks provides dependency injection for various web framework components such as controllers and JSF-managed beans, letting you declare a dependency on a specific bean through metadata (such as an autowiring annotation).

**您可以在同一个 `ApplicationContext`上混合和匹配这样的读卡器委托，从不同的配置源读取 bean 定义**。

然后可以使用 `getBean` 检索 bean 的实例。`ApplicationContext` 接口有一些其他方法用于检索 bean，但理想情况下，应用程序代码不应使用它们。==实际上，您的应用程序代码根本不应该调用`getBean()`方法，因此完全不依赖于 Spring API==。例如，Spring 与 web 框架的集成为各种 web 框架组件（如控制器和 JSF 托管 bean）提供了依赖项注入，允许您通过元数据（如自动装配注解）声明对特定 bean 的依赖项。==总结：使用get-bean 方法，说明这个bean的执行且旅赖于通过 get-bean方法获取的bean的==

### 1.3. Bean Overview

### 1.3. Bean 概述

A Spring IoC container manages one or more beans. These beans are created with the configuration metadata that you supply to the container (for example, in the form of XML `<bean/>` definitions).

Within the container itself, these bean definitions are represented as `BeanDefinition` objects, which contain (among other information) the following metadata:

- A package-qualified class name: typically, the actual implementation class of the bean being defined.
- Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth).
- References to other beans that are needed for the bean to do its work. These references are also called collaborators or dependencies.
- Other configuration settings to set in the newly created object — for example, the size limit of the pool or the number of connections to use in a bean that manages a connection pool.

This metadata translates to a set of properties that make up each bean definition. The following table describes these properties:

Spring IOC 容器管理一个或多个 bean。这些 bean 是使用您提供给容器的配置元数据创建的（例如，以 XML`<bean/>`定义的形式）。

==**在容器本身中，这些 bean 定义表示为 `BeanDefinition` 对象，其中包含（除其他信息外）以下元数据：**==

- 包限定类名：通常是定义的 bean 的实际**实现类**。

- Bean 行为配置元素，它说明 Bean 在容器中的行为（范围、生命周期回调等）。

- 引用 bean 执行其工作所需的其他 bean。这些引用也称为协作者或依赖项。

- 要在新创建的对象中设置的其他配置设置 — 例如，池的大小限制或管理连接池的 bean 中要使用的连接数。

此元数据转换为组成每个 bean 定义的一组属性。下表介绍了这些属性：

| Property                 | Explained in…                                                |
| :----------------------- | :----------------------------------------------------------- |
| Class                    | [Instantiating Beans](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class) |
| Name                     | [Naming Beans](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beanname) |
| Scope                    | [Bean Scopes](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes) |
| Constructor arguments    | [Dependency Injection](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators) |
| Properties               | [Dependency Injection](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators) |
| Autowiring mode          | [Autowiring Collaborators](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire) |
| Lazy initialization mode | [Lazy-initialized Beans](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lazy-init) |
| Initialization method    | [Initialization Callbacks](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean) |
| Destruction method       | [Destruction Callbacks](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-disposablebean) |

In addition to bean definitions that contain information on how to create a specific bean, the `ApplicationContext` implementations also permit the registration of existing objects that are created outside the container (by users). This is done by accessing the ApplicationContext’s BeanFactory through the `getBeanFactory()` method, which returns the BeanFactory `DefaultListableBeanFactory` implementation. `DefaultListableBeanFactory` supports this registration through the `registerSingleton(..)` and `registerBeanDefinition(..)` methods. However, typical applications work solely with beans defined through regular bean definition metadata.

除了包含关于如何创建特定 bean 的信息的 bean definitions 之外，`ApplicationContext`实现还允许注册（由用户）在容器外部创建的现有对象。这是通过`getBeanFactory()`方法访问 ApplicationContext 的 BeanFactory 来实现的，该方法返回 BeanFactory 的 `DefaultListableBeanFactory` 实现，`DefaultListableBeanFactory` 通过` registerSingleton(..)`  和 `registerBeanDefinition(..)` 方法支持此注册。然而，典型的应用程序只使用通过常规 bean 定义元数据定义的 bean。

>Bean metadata and manually supplied singleton instances need to be registered as early as possible, in order for the container to properly reason about them during autowiring and other introspection steps. While overriding existing metadata and existing singleton instances is supported to some degree, the registration of new beans at runtime (concurrently with live access to the factory) is not officially supported and may lead to concurrent access exceptions, inconsistent state in the bean container, or both.
>
>Bean 元数据和手动提供的单例实例需要尽早注册，以便容器在自动装配和其他自省步骤中正确地对它们进行推理。**虽然在某种程度上支持覆盖现有元数据和现有单例实例，但官方不支持在运行时注册新 bean（与对工厂的实时访问同时进行），这可能导致并发访问异常、bean容器中的状态不一致，或两者兼而有之。**

#### 1.3.1. Naming Beans

#### 1.3.1. Beans 命名

Every bean has one or more identifiers. These identifiers must be unique within the container that hosts the bean. A bean usually has only one identifier. However, if it requires more than one, the extra ones can be considered aliases.

In XML-based configuration metadata, you use the `id` attribute, the `name` attribute, or both to specify the bean identifiers. The `id` attribute lets you specify exactly one id. Conventionally, these names are alphanumeric ('myBean', 'someService', etc.), but they can contain special characters as well. If you want to introduce other aliases for the bean, you can also specify them in the `name` attribute, separated by a comma (`,`), semicolon (`;`), or white space. As a historical note, in versions prior to Spring 3.1, the `id` attribute was defined as an `xsd:ID` type, which constrained possible characters. As of 3.1, it is defined as an `xsd:string` type. Note that bean `id` uniqueness is still enforced by the container, though no longer by XML parsers.

You are not required to supply a `name` or an `id` for a bean. If you do not supply a `name` or `id` explicitly, the container generates a unique name for that bean. However, if you want to refer to that bean by name, through the use of the `ref` element or a Service Locator style lookup, you must provide a name. Motivations for not supplying a name are related to using [inner beans](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-inner-beans) and [autowiring collaborators](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire).

**每个 bean 都有一个或多个标识符。==这些标识符在承载 bean 的容器中必须是唯一的==。一个 bean 通常只有一个标识符。 但是，如果它需要多个，则可以将多余的视为别名。**

在基于 XML 的配置元数据中，可以使用 `id`属性、`name`属性或两者来指定 bean 标识符。**`id`属性允许您只指定一个 id。按照惯例，这些名称由字母数字组成（“myBean”、“someService”等），但也可以包含特殊字符。如果要为 bean 引入其他别名，还可以在`name`属性中指定它们，用逗号（`,`）、分号（`;`）或空格分隔。**历史上，在 Spring 3.1 之前的版本中，`id` 属性被定义为 `xsd:ID` 类型，它限制了可能的字符。从 3.1 开始，它被定义为 `xsd:string`类型。注意，**bean `id` 唯一性仍然由容器强制执行，但不再由 XML 解析器强制执行。** ==问之：容器在什么时侯检查唯一性==

**您不需要为 bean 提供 `name` 或 `id`。如果不显式提供 `name` 或 `id`，容器将为该 bean 生成一个唯一的名称。但是，如果希望通过使用 `ref` 元素或服务定位器样式的查找按名称引用该 bean，则必须提供名称。**不提供名称的动机与使用[内部bean](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-inner-beans)和[autowiring collaborators](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire)有关。

> Bean Naming Conventions
>
> The convention is to use the standard Java convention for instance field names when naming beans. That is, bean names start with a lowercase letter and are camel-cased from there. Examples of such names include `accountManager`, `accountService`, `userDao`, `loginController`, and so forth.
>
> Naming beans consistently makes your configuration easier to read and understand. Also, if you use Spring AOP, it helps a lot when applying advice to a set of beans related by name.
>
> Bean 命名约定
>
> 约定是在命名 bean 时使用标准 Java 约定作为实例字段名。也就是说**，bean 名称以小写字母开头，然后用驼峰大小写**。此类名称的示例包括 `accountManager`、`accountService`、`userDao`、`loginController`  等。
>
> 命名 bean 会使您的配置更易于阅读和理解。此外，如果您使用 Spring AOP，那么在将通知应用于一组按名称相关的 bean 时，它会有很大帮助。

> With component scanning in the classpath, Spring generates bean names for unnamed components, following the rules described earlier: essentially, taking the simple class name and turning its initial character to lower-case. However, in the (unusual) special case when there is more than one character and both the first and second characters are upper case, the original casing gets preserved. These are the same rules as defined by `java.beans.Introspector.decapitalize` (which Spring uses here).
>
> ==**通过类路径中的组件扫描，Spring 为未命名的组件生成 bean 名称，遵循前面描述的规则：本质上，采用简单的类名并将其初始字符转换为小写。但是，在（不常见的）特殊情况下，当有多个字符且第一个和第二个字符都是大写时，原始大小写将被保留。这些规则与 `java.beans.Introspector.decapitalize`（Spring 在这里使用）定义的规则相同。**==

##### Aliasing a Bean outside the Bean Definition

##### 在 Bean 定义之外给 Bean 添加别名

In a bean definition itself, you can supply more than one name for the bean, by using a combination of up to one name specified by the `id` attribute and any number of other names in the `name` attribute. These names can be equivalent aliases to the same bean and are useful for some situations, such as letting each component in an application refer to a common dependency by using a bean name that is specific to that component itself.

Specifying all aliases where the bean is actually defined is not always adequate, however. It is sometimes desirable to introduce an alias for a bean that is defined elsewhere. This is commonly the case in large systems where configuration is split amongst each subsystem, with each subsystem having its own set of object definitions. In XML-based configuration metadata, you can use the `<alias/>` element to accomplish this. The following example shows how to do so:

在 bean 定义本身中，您可以为 bean 提供多个名称，方法是使用 `id` 属性指定的最多一个名称和 `name`属性中任意数量的其他名称的组合。这些名称可以是同一 bean 的等效别名，在某些情况下非常有用，例如，通过使用特定于该组件本身的 bean 名称，让应用程序中的每个组件引用公共依赖项。==问题：这里没有理解 ==

但是，指定实际定义 bean 的所有别名并不总是足够的。有时需要为在别处定义的 bean 引入别名。在大型系统中，配置通常在每个子系统之间分割，每个子系统都有自己的对象定义集。在基于 XML 的配置元数据中，可以使用`<alias/>`元素来完成这一任务。以下示例显示了如何执行此操作：

```xml
<alias name="fromName" alias="toName"/>
```

In this case, a bean (in the same container) named `fromName` may also, after the use of this alias definition, be referred to as `toName`.

For example, the configuration metadata for subsystem A may refer to a DataSource by the name of `subsystemA-dataSource`. The configuration metadata for subsystem B may refer to a DataSource by the name of `subsystemB-dataSource`. When composing the main application that uses both these subsystems, the main application refers to the DataSource by the name of `myApp-dataSource`. To have all three names refer to the same object, you can add the following alias definitions to the configuration metadata:

在上述配置案例中，在使用此别名定义后，名为 `fromName` 的 bean（在同一容器中）也可以称为 `toName`。

例如，子系统 A 的配置元数据可能引用名为 `subsystemA-dataSource`的数据源。子系统 B 的配置元数据可能引用名为`subsystemB-dataSource`的数据源。在编写使用这两个子系统的主应用程序时，主应用程序以 `myApp-DataSource`的名称引用数据源。**要使所有三个名称都引用同一对象，可以将以下别名定义添加到配置元数据中**：==问题：为什么不直接在name属性中通过分隔符来配置多个值，即name和alias的区别==

```xml
<alias name="myApp-dataSource" alias="subsystemA-dataSource"/>
<alias name="myApp-dataSource" alias="subsystemB-dataSource"/>
```

Now each component and the main application can refer to the dataSource through a name that is unique and guaranteed not to clash with any other definition (effectively creating a namespace), yet they refer to the same bean.

现在，每个组件和主应用程序都可以通过一个唯一的名称引用数据源，并保证不会与任何其他定义冲突（有效地创建命名空间），但它们引用的是同一个 bean。

> Java-configuration
>
> If you use Javaconfiguration, the `@Bean` annotation can be used to provide aliases. See [Using the `@Bean` Annotation](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-bean-annotation) for details.
>
> Java 配置
>
> 如果使用 Javaconfiguration，`@Bean` 注解可用于提供别名。请参阅 [使用 `@Bean` 注解](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-bean-annotation) 获取详细信息。

#### 1.3.2. Instantiating Beans

#### 1.3.2.实例化 bean

A bean definition is essentially a recipe for creating one or more objects. The container looks at the recipe for a named bean when asked and uses the configuration metadata encapsulated by that bean definition to create (or acquire) an actual object.

If you use XML-based configuration metadata, you specify the type (or class) of object that is to be instantiated in the `class` attribute of the `<bean/>` element. This `class` attribute (which, internally, is a `Class` property on a `BeanDefinition` instance) is usually mandatory. (For exceptions, see [Instantiation by Using an Instance Factory Method](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class-instance-factory-method) and [Bean Definition Inheritance](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-child-bean-definitions).) You can use the `Class` property in one of two ways:

- Typically, to specify the bean class to be constructed in the case where the container itself directly creates the bean by calling its constructor reflectively, somewhat equivalent to Java code with the `new` operator.
- To specify the actual class containing the `static` factory method that is invoked to create the object, in the less common case where the container invokes a `static` factory method on a class to create the bean. The object type returned from the invocation of the `static` factory method may be the same class or another class entirely.

Nested class names

If you want to configure a bean definition for a nested class, you may use either the binary name or the source name of the nested class.

For example, if you have a class called `SomeThing` in the `com.example` package, and this `SomeThing` class has a `static` nested class called `OtherThing`, they can be separated by a dollar sign (`$`) or a dot (`.`). So the value of the `class` attribute in a bean definition would be `com.example.SomeThing$OtherThing` or `com.example.SomeThing.OtherThing`.

**bean 定义本质上是创建一个或多个对象的方式（配方）。容器在被询问时查看命名 bean 的配方，并使用该 bean 定义封装的配置元数据创建（或获取）实际对象。**

如果使用基于 XML 的配置元数据，则指定要在 `<bean/>` 元素的 `class` 属性中实例化的对象的类型（或类）。此 `class` 属性（在内部，它是 `BeanDefinition` 实例上的 `Class` 属性）通常是必需的。（有关例外情况，请参阅[使用实例工厂方法实例化](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class-instance-factory-method)和 [Bean 定义继承](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-child-bean-definitions)），你可以通过以下两种方式之一使用 `Class` 属性：

- **通常，在容器本身通过反射式调用其构造函数直接创建 bean 的情况下，指定要构造的 bean 类，这在某种程度上相当于带有 `new` 操作符的 Java 代码。**

- 指定包含被调用以创建对象的`static` 工厂方法的实际类，在不太常见的情况下，容器调用类上的 `static` 工厂方法以创建bean。调用 `static` 工厂方法返回的对象类型可能是同一个类，也可能是另一个类。

**嵌套类名**

如果要为嵌套类配置 bean 定义，可以使用嵌套类的二进制名称或源名称。

例如，如果在 `com.example` 包中有一个名`SomeThing`的类。而这个 `SomeThing` 类有一个名为 `OtherThing` 的 `static` 嵌套类，它们**可以用一个美元符号（`$`）或一个点（`.`）分隔**。因此，bean 定义中的 `class`属性的值应该是 `com.example.SomeThing$OtherThing` 或者  `com.example.SomeThing.OtherThing`。

##### Instantiation with a Constructor

##### 用构造函数实例化

When you create a bean by the constructor approach, all normal classes are usable by and compatible with Spring. That is, the class being developed does not need to implement any specific interfaces or to be coded in a specific fashion. Simply specifying the bean class should suffice. However, depending on what type of IoC you use for that specific bean, you may need a default (empty) constructor.

The Spring IoC container can manage virtually any class you want it to manage. It is not limited to managing true JavaBeans. Most Spring users prefer actual JavaBeans with only a default (no-argument) constructor and appropriate setters and getters modeled after the properties in the container. You can also have more exotic non-bean-style classes in your container. If, for example, you need to use a  that absolutely does not adhere to the JavaBean specification, Spring can manage it as well.

With XML-based configuration metadata you can specify your bean class as follows:

当您通过构造函数方法创建 bean 时，所有普通类都可以由 Spring 使用，并且与 Spring 兼容。也就是说，正在开发的类不需要实现任何特定的接口，也不需要以特定的方式进行编码。只需指定 bean 类就足够了。但是，根据您对特定 bean 使用的 IoC 类型，＊＊您可能需要一个默认（空）构造函数 *。

Spring IOC 容器实际上可以管理您希望它管理的任何类。它不仅限于管理真正的 JavaBeans。大多数 Spring 用户更喜欢实际的 JavaBean，它只有一个默认（无参数）构造函数，并根据容器中的属性建模适当的 setter 和 getter。您的容器中还可以有更多异国情调的非 bean 样式的类。例如，如果您需要使用一个完全不符合 JavaBean 规范的遗留连接池，Spring 也可以管理它。

使用基于 XML 的配置元数据，您可以按如下方式指定 bean 类。==问是：Name是否它求唯一性 ==

```xml
<bean id="exampleBean" class="examples.ExampleBean"/>

<bean name="anotherExample" class="examples.ExampleBeanTwo"/>
```

For details about the mechanism for supplying arguments to the constructor (if required) and setting object instance properties after the object is constructed, see [Injecting Dependencies](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators).

有关构造对象后向构造函数提供参数（如果需要）和设置对象实例属性的机制的详细信息，请参阅[注入依赖项](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators)。

##### Instantiation with a Static Factory Method

##### 使用静态工厂方法进行实例化

When defining a bean that you create with a static factory method, use the `class` attribute to specify the class that contains the `static` factory method and an attribute named `factory-method` to specify the name of the factory method itself. You should be able to call this method (with optional arguments, as described later) and return a live object, which subsequently is treated as if it had been created through a constructor. One use for such a bean definition is to call `static` factories in legacy code.

The following bean definition specifies that the bean be created by calling a factory method. The definition does not specify the type (class) of the returned object, only the class containing the factory method. In this example, the `createInstance()` method must be a static method. The following example shows how to specify a factory method:

定义使用静态工厂方法创建的 bean 时，请**使用 `class` 属性指定包含 `static` 工厂方法的类，并使用名为 `factory-method` 的属性指定工厂方法本身的名称**。您应该能够调用此方法（使用可选参数，如下文所述）并返回一个活动对象，该对象随后将被视为是通过构造函数创建的。这种 bean 定义的一个用途是在遗留代码中调用 `static`工厂。

**下面的 bean 定义指定通过调用工厂方法来创建 bean。该定义不指定返回对象的类型（类），只指定包含工厂方法的类。在本例中，`createInstance()`方法必须是静态方法。**以下示例显示如何指定工厂方法 ：==问题：静态厂和非静态工厂的区别==

```xml
<bean id="clientService"  class="examples.ClientService"  factory-method="createInstance"/>
```

The following example shows a class that would work with the preceding bean definition:

以下示例显示了一个可与前面的 bean 定义一起使用的类：

```java
public class ClientService {
    private static ClientService clientService = new ClientService();
    private ClientService() {}

    public static ClientService createInstance() {
        return clientService;
    }
}
```

For details about the mechanism for supplying (optional) arguments to the factory method and setting object instance properties after the object is returned from the factory, see [Dependencies and Configuration in Detail](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-properties-detailed).

有关在对象从工厂返回后向工厂方法提供（可选）参数和设置对象实例属性的机制的详细信息，请参阅[依赖项和配置详细信息](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-properties-detailed)。

##### Instantiation by Using an Instance Factory Method

##### 使用实例工厂方法进行实例化

Similar to instantiation through a [static factory method](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class-static-factory-method), instantiation with an instance factory method invokes a non-static method of an existing bean from the container to create a new bean. To use this mechanism, leave the `class` attribute empty and, in the `factory-bean` attribute, specify the name of a bean in the current (or parent or ancestor) container that contains the instance method that is to be invoked to create the object. Set the name of the factory method itself with the `factory-method` attribute. The following example shows how to configure such a bean:

类似于通过[静态工厂方法](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class-static-factory-method)，使用实例工厂方法实例化从容器中调用现有 bean 的非静态方法来创建新 bean。要使用此机制，**请将 `class` 属性保留为空，并在 `factory-bean` 属性中，指定当前（或父级或祖先级）容器中包含要调用以创建对象的实例方法的 bean 的名称。使用 `factory-method`属性设置工厂方法本身的名称**。下面的示例演示如何配置这样的 bean：

```xml
<!-- the factory bean, which contains a method called createInstance() -->
<bean id="serviceLocator" class="examples.DefaultServiceLocator">
    <!-- inject any dependencies required by this locator bean -->
</bean>

<!-- the bean to be created via the factory bean -->
<bean id="clientService"  factory-bean="serviceLocator"  factory-method="createClientServiceInstance"/>
```

The following example shows the corresponding class:

以下示例显示了相应的类：

```java
public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }
}
```

One factory class can also hold more than one factory method, as the following example shows:

一个工厂类还可以包含多个工厂方法，如下例所示：

```xml
<bean id="serviceLocator" class="examples.DefaultServiceLocator">
    <!-- inject any dependencies required by this locator bean -->
</bean>

<bean id="clientService"  factory-bean="serviceLocator"  factory-method="createClientServiceInstance"/>

<bean id="accountService"  factory-bean="serviceLocator" factory-method="createAccountServiceInstance"/>
```

The following example shows the corresponding class:

以下示例显示了相应的类：

```java
public class DefaultServiceLocator {
    private static ClientService clientService = new ClientServiceImpl();

    private static AccountService accountService = new AccountServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }

    public AccountService createAccountServiceInstance() {
        return accountService;
    }
}
```

This approach shows that the factory bean itself can be managed and configured through dependency injection (DI). See [Dependencies and Configuration in Detail](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-properties-detailed).

这种方法表明，工厂 bean 本身可以通过依赖注入（DI）进行管理和配置。请参阅[依赖项和配置详细信息](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-properties-detailed)。

> In Spring documentation, "factory bean" refers to a bean that is configured in the Spring container and that creates objects through an [instance](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class-instance-factory-method) or [static](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class-static-factory-method) factory method. By contrast, `FactoryBean` (notice the capitalization) refers to a Spring-specific [`FactoryBean`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-factorybean) implementation class.
>
> 在 Spring 文档中，「factory bean」指的是在 Spring 容器中配置的 bean，它通过[实例](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class-instance-factory-method)或者[静态](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class-static-factory-method) 工厂方法来创建对象。相比之下，`FactoryBean`（注意大写）指的是特定于 Spring 的 [`FactoryBean`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-factorybean) 实现类。

##### Determining a Bean’s Runtime Type

##### 确定 Bean 的运行时类型

The runtime type of a specific bean is non-trivial to determine. A specified class in the bean metadata definition is just an initial class reference, potentially combined with a declared factory method or being a `FactoryBean` class which may lead to a different runtime type of the bean, or not being set at all in case of an instance-level factory method (which is resolved via the specified `factory-bean` name instead). Additionally, AOP proxying may wrap a bean instance with an interface-based proxy with limited exposure of the target bean’s actual type (just its implemented interfaces).

The recommended way to find out about the actual runtime type of a particular bean is a `BeanFactory.getType` call for the specified bean name. This takes all of the above cases into account and returns the type of object that a `BeanFactory.getBean` call is going to return for the same bean name.

特定 bean 的运行时类型很难确定。bean 元数据定义中的指定类只是一个初始类引用，可能与声明的工厂方法组合，或者 `FactoryBean` 类，这可能导致 bean 的不同运行时类型，或者在实例级工厂方法的情况下根本不设置（这是通过指定的 `factory-bean` 名称来解决的）。此外，AOP 代理可以使用基于接口的代理来包装 bean 实例，并有限地公开目标 bean 的实际类型（仅其实现的接口）。

**查找特定 bean 的实际运行时类型的推荐方法是对指定的 bean 名称进行 `BeanFactory.getType` 调用。这将考虑上述所有情况，并返回 `BeanFactory.getBean` 调用将为相同的 bean 名称返回的对象类型。**

### 1.4. Dependencies

### 1.4. 依赖

A typical enterprise application does not consist of a single object (or bean in the Spring parlance). Even the simplest application has a few objects that work together to present what the end-user sees as a coherent application. This next section explains how you go from defining a number of bean definitions that stand alone to a fully realized application where objects collaborate to achieve a goal.

典型的企业应用程序不是由单个对象（或 Spring 术语中的 bean）组成的。即使是最简单的应用程序，也有几个对象一起工作，以呈现最终用户认为是一致的应用程序。下一节将解释如何从定义大量独立的 bean 定义过渡到一个完全实现的应用程序，在这个应用程序中，对象协作以实现一个目标。

#### 1.4.1. Dependency Injection

#### 1.4.1 依赖注入

Dependency injection (DI) is a process whereby objects define their dependencies (that is, the other objects with which they work) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies on its own by using direct construction of classes or the Service Locator pattern.

Code is cleaner with the DI principle, and decoupling is more effective when objects are provided with their dependencies. The object does not look up its dependencies and does not know the location or class of the dependencies. As a result, your classes become easier to test, particularly when the dependencies are on interfaces or abstract base classes, which allow for stub or mock implementations to be used in unit tests.

DI exists in two major variants: [Constructor-based dependency injection](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-constructor-injection) and [Setter-based dependency injection](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-setter-injection).

**依赖项注入（DI）是一个过程，对象仅通过构造函数参数、工厂方法的参数或在对象实例构造或从工厂方法返回后在对象实例上设置的属性来==定义==其依赖项（即与之一起工作的其他对象）。然后，容器在创建 bean 时 ==注入==这些依赖项。这个过程基本上是 bean 本身的逆过程（因此称为控制反转），通过使用类的直接构造或服务定位器模式来控制其依赖项的实例化或位置。**

使用 DI 原则，代码更干净，当对象具有依赖关系时，解耦更有效。对象不查找其依赖项，也不知道依赖项的位置或类别。因此，您的类变得更容易测试，特别是当依赖项位于接口或抽象基类上时，这允许在单元测试中使用存根或模拟实现。

DI 存在于两个主要变体中：[基于构造函数的依赖项注入](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-constructor-injection)和[基于 Setter 的依赖项注入](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-setter-injection)。

##### Constructor-based Dependency Injection

##### 基于构造函数的依赖注入

Constructor-based DI is accomplished by the container invoking a constructor with a number of arguments, each representing a dependency. Calling a `static` factory method with specific arguments to construct the bean is nearly equivalent, and this discussion treats arguments to a constructor and to a `static` factory method similarly. The following example shows a class that can only be dependency-injected with constructor injection:

**基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项**。调用带有特定参数的静态工厂方法来构造 bean 几乎是等效的，本讨论类似地处理构造函数和静态工厂方法的参数。以下示例显示了一个类，该类只能通过构造函数注入进行依赖项注入：

```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private final MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

Notice that there is nothing special about this class. It is a POJO that has no dependencies on container specific interfaces, base classes, or annotations.

请注意，这个类没有什么特别之处。它是一个 POJO，不依赖于特定于容器的接口、基类或注解。

###### Constructor Argument Resolution

###### 构造函数参数解析

Constructor argument resolution matching occurs by using the argument’s type. If no potential ambiguity exists in the constructor arguments of a bean definition, the order in which the constructor arguments are defined in a bean definition is the order in which those arguments are supplied to the appropriate constructor when the bean is being instantiated. Consider the following class:

**构造函数参数解析匹配通过使用参数的==类型==进行。如果 bean 定义的构造函数参数中不存在潜在的歧义，那么在 bean 定义中定义构造函数参数的顺序就是在实例化 bean 时将这些参数提供给相应构造函数的顺序。**考虑下面的类：

```java
package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}
```

Assuming that the `ThingTwo` and `ThingThree` classes are not related by inheritance, no potential ambiguity exists. Thus, the following configuration works fine, and you do not need to specify the constructor argument indexes or types explicitly in the `<constructor-arg/>` element.

假设 `ThingTwo` 和 ` ThingTree` 类没有继承关系，则不存在潜在的歧义。因此，以下配置工作正常，**您不需要在`<constructor-arg/>`元素中显式指定构造函数参数索引或类型。**

```xml
<beans>
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg ref="beanTwo"/>
        <constructor-arg ref="beanThree"/>
    </bean>

    <bean id="beanTwo" class="x.y.ThingTwo"/>

    <bean id="beanThree" class="x.y.ThingThree"/>
</beans>
```

When another bean is referenced, the type is known, and matching can occur (as was the case with the preceding example). When a simple type is used, such as `<value>true</value>`, Spring cannot determine the type of the value, and so cannot match by type without help. Consider the following class:

当引用另一个 bean 时，类型是已知的，并且可以进行匹配（如前一个示例所示）。**当使用简单类型时，例如`<value>true</value>`，Spring 无法确定值的类型，因此在没有帮助的情况下无法按类型进行匹配**。考虑下面的类：

```java
package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private final int years;

    // The Answer to Life, the Universe, and Everything
    private final String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

###### Constructor argument type matching

###### 构造函数参数类型匹配

In the preceding scenario, the container can use type matching with simple types if you explicitly specify the type of the constructor argument by using the `type` attribute, as the following example shows:

在前面的场景中，**如果使用 `type` 属性显式指定构造函数参数的类型，则容器可以使用简单类型的类型匹配**，如下例所示：

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
```

###### Constructor argument index

###### 构造函数参数索引

You can use the `index` attribute to specify explicitly the index of constructor arguments, as the following example shows:

**可以使用 `index` 属性显式指定构造函数参数的索引**，如下例所示：

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>
```

In addition to resolving the ambiguity of multiple simple values, specifying an index resolves ambiguity where a constructor has two arguments of the same type.

**除了解决多个简单值的歧义外，如果构造函数有两个相同类型的参数，则指定索引可以解决歧义。**

> The index is 0-based.
>
> 该索引以 0 为基础。

###### Constructor argument name

###### 构造函数参数名

You can also use the constructor parameter name for value disambiguation, as the following example shows:

您还可以使用构造函数参数名称来消除值歧义，如下例所示：

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg name="years" value="7500000"/>
    <constructor-arg name="ultimateAnswer" value="42"/>
</bean>
```

Keep in mind that, to make this work out of the box, your code must be compiled with the debug flag enabled so that Spring can look up the parameter name from the constructor. If you cannot or do not want to compile your code with the debug flag, you can use the [@ConstructorProperties](https://download.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html) JDK annotation to explicitly name your constructor arguments. The sample class would then have to look as follows:

请记住，要使这项工作开箱即用，必须在编译代码时启用调试标志，以便 Spring 可以从构造函数中查找参数名。如果不能或不希望使用调试标志编译代码，则可以使用 [@ConstructorProperties](https://download.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html)JDK 注解来显式命名构造函数参数。然后，示例类必须如下所示：

```java
package examples;

public class ExampleBean {

    // Fields omitted

    @ConstructorProperties({"years", "ultimateAnswer"})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

##### Setter-based Dependency Injection 

##### 基于 Setter 的依赖注入

Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or a no-argument `static` factory method to instantiate your bean.

The following example shows a class that can only be dependency-injected by using pure setter injection. This class is conventional Java. It is a POJO that has no dependencies on container specific interfaces, base classes, or annotations.

**基于 Setter 的 DI 是由容器在调用无参数构造函数或无参数静态工厂方法实例化 bean 后，在 bean 上调用 Setter 方法来完成的。**

下面的示例显示了一个只能使用纯 setter 注入进行依赖注入的类。这个类是传统的 Java。它是一个 POJO，不依赖于特定于容器的接口、基类或注解。

```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

The `ApplicationContext` supports constructor-based and setter-based DI for the beans it manages. It also supports setter-based DI after some dependencies have already been injected through the constructor approach. You configure the dependencies in the form of a `BeanDefinition`, which you use in conjunction with `PropertyEditor` instances to convert properties from one format to another. However, most Spring users do not work with these classes directly (that is, programmatically) but rather with XML `bean` definitions, annotated components (that is, classes annotated with `@Component`, `@Controller`, and so forth), or `@Bean` methods in Java-based `@Configuration` classes. These sources are then converted internally into instances of `BeanDefinition` and used to load an entire Spring IoC container instance.

`ApplicationContext` 为其管理的 bean 支持基于构造函数和基于 setter 的 DI。在通过构造函数方法注入一些依赖项之后，它还支持基于 setter 的 DI。您可以以 `BeanDefinition` 的形式配置依赖项，将其与 `PropertyEditor` 实例结合使用，以将属性从一种格式转换为另一种格式。然而，大多数 Spring 用户并不直接使用这些类（即编程），而是使用 XML `bean` 定义、带注解的组件（即，用`@Component`、`@Controller` 等注解的类）或基于 Java 的 `@Configuration` 类中的 `@Bean` 方法。然后将这些源在内部转换为 `BeanDefinition` 的实例，并用于加载整个 Spring IoC 容器实例。

> Constructor-based or setter-based DI?
>
> Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use constructors for mandatory dependencies and setter methods or configuration methods for optional dependencies. Note that use of the [@Required](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-required-annotation) annotation on a setter method can be used to make the property be a required dependency; however, constructor injection with programmatic validation of arguments is preferable.
>
> The Spring team generally advocates constructor injection, as it lets you implement application components as immutable objects and ensures that required dependencies are not `null`. Furthermore, constructor-injected components are always returned to the client (calling) code in a fully initialized state. As a side note, a large number of constructor arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns.
>
> Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. One benefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later. Management through [JMX MBeans](https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#jmx) is therefore a compelling use case for setter injection.
>
> Use the DI style that makes the most sense for a particular class. Sometimes, when dealing with third-party classes for which you do not have the source, the choice is made for you. For example, if a third-party class does not expose any setter methods, then constructor injection may be the only available form of DI.
>
> 基于构造函数还是基于 setter 的 DI？
>
> **因为您可以混合使用基于构造函数和基于 setter 的 DI，所以对于强制依赖项使用构造函数，对于可选依赖项使用 setter 方法或配置方法是一个很好的经验法则**。请注意， setter 方法上使用 [@Required](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-required-annotation) 的注解可用于使属性成为必需的依赖项；但是，构造函数注入和参数的编程验证更可取。
>
> **Spring 团队通常提倡构造函数注入**，因为它允许您将应用程序组件实现为不可变对象，并确保所需的依赖项不为“null”。此外，构造函数注入的组件总是以完全初始化的状态返回给客户机（调用）代码。作为旁注，大量构造函数参数是一种糟糕的代码味道，这意味着类可能有太多的责任，应该进行重构以更好地解决问题的适当分离。
>
> **Setter 注入应该主要用于可选的依赖项，这些依赖项可以在类中分配合理的默认值**。否则，必须在代码使用依赖项的任何地方执行非空检查。setter 注入的一个好处是 setter 方法使该类的对象易于以后重新配置或重新注入。通过 [JMX MBeans](https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#jmx) 进行管理，因此，是 setter 注入的一个引人注目的用例。
>
> 使用对特定类最有意义的 DI 样式。有时，在处理您没有源代码的第三方类时，会为您做出选择。例如，如果第三方类不公开任何 setter 方法，那么构造函数注入可能是唯一可用的 DI 形式。

##### Dependency Resolution Process

##### 依赖项解析过程

The container performs bean dependency resolution as follows:

- The `ApplicationContext` is created and initialized with configuration metadata that describes all the beans. Configuration metadata can be specified by XML, Java code, or annotations.
- For each bean, its dependencies are expressed in the form of properties, constructor arguments, or arguments to the static-factory method (if you use that instead of a normal constructor). These dependencies are provided to the bean, when the bean is actually created.
- Each property or constructor argument is an actual definition of the value to set, or a reference to another bean in the container.
- Each property or constructor argument that is a value is converted from its specified format to the actual type of that property or constructor argument. By default, Spring can convert a value supplied in string format to all built-in types, such as `int`, `long`, `String`, `boolean`, and so forth.

The Spring container validates the configuration of each bean as the container is created. However, the bean properties themselves are not set until the bean is actually created. Beans that are singleton-scoped and set to be pre-instantiated (the default) are created when the container is created. Scopes are defined in [Bean Scopes](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes). Otherwise, the bean is created only when it is requested. Creation of a bean potentially causes a graph of beans to be created, as the bean’s dependencies and its dependencies' dependencies (and so on) are created and assigned. Note that resolution mismatches among those dependencies may show up late — that is, on first creation of the affected bean.

**容器执行 bean 依赖项解析，如下所示：**

- 使用描述所有 bean 的配置元数据创建并初始化 `ApplicationContext`。配置元数据可以由 XML、Java 代码或注解指定。
- 对于每个 bean，其依赖关系都以属性、构造函数参数或静态工厂方法的参数的形式表示（如果您使用静态工厂方法而不是普通构造函数）。这些依赖关系在 bean 实际创建时提供给 bean。
- 每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个 bean 的引用。
- 作为值的每个属性或构造函数参数都将从其指定格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring 可以将以字符串格式提供的值转换为所有内置类型，如`int`、`long`、`string`、`boolean` 等。

**Spring 容器在创建容器时验证每个 bean 的配置。但是，在实际创建 bean 之前，不会设置 bean 属性本身**。**创建容器时，将创建单例作用域并设置为预实例化（默认）的 bean。作用域在 [Bean 作用域](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes) 中定义。否则，仅当请求时才创建 bean**。创建 bean 可能会导致创建 bean 图，因为 bean 的依赖项及其依赖项的依赖项（等等）是创建和分配的。请注意，这些依赖项之间的分辨率不匹配可能会延迟显示 — 也就是说，在第一次创建受影响的 bean 时。

> Circular dependencies
>
> 循环依赖
>
> If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.
>
> For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a `BeanCurrentlyInCreationException`.
>
> One possible solution is to edit the source code of some classes to be configured by setters rather than constructors. Alternatively, avoid constructor injection and use setter injection only. In other words, although it is not recommended, you can configure circular dependencies with setter injection.
>
> Unlike the typical case (with no circular dependencies), a circular dependency between bean A and bean B forces one of the beans to be injected into the other prior to being fully initialized itself (a classic chicken-and-egg scenario).
>
> **如果主要使用构造函数注入，则有可能创建无法解决的循环依赖场景**。
>
> 例如：类 A 通过构造函数注入需要类 B 的实例，类 B 通过构造函数注入需要类 A 的实例。如果为类 A 和类 B 配置 bean 以相互注入，Spring IoC 容器将在运行时检测此循环引用，并抛出 `BeanCurrentlyIncrementationException`。
>
> **一种可能的解决方案是编辑某些类的源代码，由 setter 而不是构造函数进行配置。或者，避免构造函数注入，只使用 setter 注入。换句话说，虽然不推荐，但是可以使用 setter 注入来配置循环依赖项。**
>
> 与典型情况（没有循环依赖）不同，bean A 和 bean B 之间的循环依赖迫使一个 bean 在完全初始化之前注入另一个 bean（典型的鸡和蛋场景）。

You can generally trust Spring to do the right thing. It detects configuration problems, such as references to non-existent beans and circular dependencies, at container load-time. Spring sets properties and resolves dependencies as late as possible, when the bean is actually created. This means that a Spring container that has loaded correctly can later generate an exception when you request an object if there is a problem creating that object or one of its dependencies — for example, the bean throws an exception as a result of a missing or invalid property. This potentially delayed visibility of some configuration issues is why `ApplicationContext` implementations by default pre-instantiate singleton beans. At the cost of some upfront time and memory to create these beans before they are actually needed, you discover configuration issues when the `ApplicationContext` is created, not later. You can still override this default behavior so that singleton beans initialize lazily, rather than being eagerly pre-instantiated.

If no circular dependencies exist, when one or more collaborating beans are being injected into a dependent bean, each collaborating bean is totally configured prior to being injected into the dependent bean. This means that, if bean A has a dependency on bean B, the Spring IoC container completely configures bean B prior to invoking the setter method on bean A. In other words, the bean is instantiated (if it is not a pre-instantiated singleton), its dependencies are set, and the relevant lifecycle methods (such as a [configured init method](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean) or the [InitializingBean callback method](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean)) are invoked.

您通常可以相信 Spring 会做正确的事情。它在容器加载时检测配置问题，例如对不存在的 bean 的引用和循环依赖项。Spring 在 bean 实际创建时尽可能晚地设置属性并解析依赖项。这意味着，如果创建对象或其依赖项时出现问题，则正确加载的 Spring 容器稍后可以在请求对象时生成异常 — 例如，bean 由于缺少或无效属性而引发异常。这可能会延迟某些配置问题的可见性，这就是为什么默认情况下，`ApplicationContext` 实现会预实例化单例 bean。在实际需要这些 bean 之前，您需要花费一些前期时间和内存来创建这些 bean，但在创建 `ApplicationContext` 时，您会发现配置问题，而不是在以后。您仍然可以覆盖此默认行为，以便单例 bean 可以延迟初始化，而不是急切地预实例化。

如果不存在循环依赖关系，那么当一个或多个协作 bean 被注入到依赖 bean 中时，每个协作 bean 在被注入到依赖 bean 中之前都会被完全配置。这意味着，如果 bean A 对 bean B 有依赖关系，Spring IoC 容器在调用 bean A 上的 setter 方法之前完全配置 bean B。换句话说，bean 被实例化（如果它不是预实例化的单例），它的依赖项被设置，相关的生命周期方法（例如[configured init method](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean) 或[InitializingBean callback method](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean)）被调用。

##### Examples of Dependency Injection

##### 依赖注入示例

The following example uses XML-based configuration metadata for setter-based DI. A small part of a Spring XML configuration file specifies some bean definitions as follows:

以下示例将基于 XML 的配置元数据用于**基于 setter 的 DI**。Spring XML 配置文件的一小部分指定了一些 bean 定义，如下所示：

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- setter injection using the nested ref element -->
    <property name="beanOne">
        <ref bean="anotherExampleBean"/>
    </property>

    <!-- setter injection using the neater ref attribute -->
    <property name="beanTwo" ref="yetAnotherBean"/>
    <!--注意这里的属性名称不为 i-->
    <property name="integerProperty" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

The following example shows the corresponding `ExampleBean` class:

以下示例显示了相应的 `ExampleBean` 类：

```java
public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }
}
```

In the preceding example, setters are declared to match against the properties specified in the XML file. The following example uses constructor-based DI:

在前面的示例中，setter 被声明为与 XML 文件中指定的属性相匹配。以下示例使用**基于构造函数的 DI**：

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- constructor injection using the nested ref element -->
    <constructor-arg>
        <ref bean="anotherExampleBean"/>
    </constructor-arg>

    <!-- constructor injection using the neater ref attribute -->
    <constructor-arg ref="yetAnotherBean"/>

    <constructor-arg type="int" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

The following example shows the corresponding `ExampleBean` class:

以下示例显示了相应的 `ExampleBean` 类：

```java
public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}
```

The constructor arguments specified in the bean definition are used as arguments to the constructor of the `ExampleBean`.

Now consider a variant of this example, where, instead of using a constructor, Spring is told to call a `static` factory method to return an instance of the object:

bean 定义中指定的构造函数参数用作 `ExampleBean` 构造函数的参数。
现在考虑这个例子的一个变体，在这里，Spring 不是使用构造函数，而是调用一个静态工厂方法来返回对象的实例：

```xml
<bean id="exampleBean" class="examples.ExampleBean" factory-method="createInstance">
    <constructor-arg ref="anotherExampleBean"/>
    <constructor-arg ref="yetAnotherBean"/>
    <constructor-arg value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

The following example shows the corresponding `ExampleBean` class:

以下示例显示了相应的 `ExampleBean` 类：

```java
public class ExampleBean {

    // a private constructor
    private ExampleBean(...) {
        ...
    }

    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

        ExampleBean eb = new ExampleBean (...);
        // some other operations...
        return eb;
    }
}
```

Arguments to the `static` factory method are supplied by `<constructor-arg/>` elements, exactly the same as if a constructor had actually been used. The type of the class being returned by the factory method does not have to be of the same type as the class that contains the `static` factory method (although, in this example, it is). An instance (non-static) factory method can be used in an essentially identical fashion (aside from the use of the `factory-bean` attribute instead of the `class` attribute), so we do not discuss those details here.

静态工厂方法的参数由 `<constructor-arg/>` 元素提供，与实际使用的构造函数完全相同。工厂方法返回的类的类型不必与包含静态工厂方法的类的类型相同（尽管在本例中是这样）。实例（非静态）工厂方法可以以基本相同的方式使用（除了使用 `factory-bean` 属性而不是 `class` 属性之外），因此我们在这里不讨论这些细节。

#### 1.4.2. Dependencies and Configuration in Detail

#### 1.4.2.详细的依赖关系和配置

As mentioned in the [previous section](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators), you can define bean properties and constructor arguments as references to other managed beans (collaborators) or as values defined inline. Spring’s XML-based configuration metadata supports sub-element types within its `<property/>` and `<constructor-arg/>` elements for this purpose.

如[上一节](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators)所述，您可以将 bean 属性和构造函数参数定义为对其他托管 bean（协作者）的引用或内联定义的值。为此，Spring 基于 XML 的配置元数据支持其 `<property/>` 和 `<constructor-arg/>` 元素中的子元素类型。

##### Straight Values (Primitives, Strings, and so on)

##### 直线值（基本体、字符串等）

The `value` attribute of the `<property/>` element specifies a property or constructor argument as a human-readable string representation. Spring’s [conversion service](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#core-convert-ConversionService-API) is used to convert these values from a `String` to the actual type of the property or argument. The following example shows various values being set:

`<property/>` 元素的 `value` 属性将属性或构造函数参数指定为人类可读的字符串表示形式。Spring 的[转换服务](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#core-convert-ConversionService-API)用于将这些值从 `String` 转换为属性或参数的实际类型。以下示例显示了正在设置的各种值：

```xml
<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <!-- results in a setDriverClassName(String) call -->
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
    <property name="username" value="root"/>
    <property name="password" value="misterkaoli"/>
</bean>
```

The following example uses the [p-namespace](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-p-namespace) for even more succinct XML configuration:

**下面的示例使用[p-命名空间](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-p-namespace) 更简洁的 XML 配置：**

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
        destroy-method="close"
        p:driverClassName="com.mysql.jdbc.Driver"
        p:url="jdbc:mysql://localhost:3306/mydb"
        p:username="root"
        p:password="misterkaoli"/>

</beans>
```

The preceding XML is more succinct. However, typos are discovered at runtime rather than design time, unless you use an IDE (such as [IntelliJ IDEA](https://www.jetbrains.com/idea/) or the [Spring Tools for Eclipse](https://spring.io/tools)) that supports automatic property completion when you create bean definitions. Such IDE assistance is highly recommended.

You can also configure a `java.util.Properties` instance, as follows:

前面的 XML 更简洁。但是，除非您使用 IDE（如[IntelliJ IDEA](https://www.jetbrains.com/idea/) 或 [Spring Tools for Eclipse](https://spring.io/tools)），否则打字错误是在运行时而不是在设计时发现的，它支持在创建 bean 定义时自动完成属性。强烈建议您提供此类 IDE 帮助。

您还可以配置一个`java.util.Properties`属性实例，如下所示：

```xml
<bean id="mappings"
    class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">

    <!-- typed as a java.util.Properties -->
    <property name="properties">
        <value>
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        </value>
    </property>
</bean>
```

The Spring container converts the text inside the `<value/>` element into a `java.util.Properties` instance by using the JavaBeans `PropertyEditor` mechanism. This is a nice shortcut, and is one of a few places where the Spring team do favor the use of the nested `<value/>` element over the `value` attribute style.

**Spring 容器使用 JavaBeans 的 `PropertyEdit` 机制将 `<value/>` 元素中的文本转换为 `java.util.Properties` 实例**。这是一个很好的快捷方式，也是 Spring 团队支持使用嵌套的 `<value/>` 元素而不是 `value` 属性样式的少数地方之一。

###### The `idref` element

###### `idref` 元素

The `idref` element is simply an error-proof way to pass the `id` (a string value - not a reference) of another bean in the container to a `<constructor-arg/>` or `<property/>` element. The following example shows how to use it:

**`idref` 元素只是一种防错的方法，用于将容器中另一个 bean 的 `id`（字符串值-不是引用）传递给 `<constructor-arg/>` 或 `<property/>` 元素**。以下示例显示了如何使用它：

```xml
<bean id="theTargetBean" class="..."/>

<bean id="theClientBean" class="...">
    <property name="targetName">
        <idref bean="theTargetBean"/>
    </property>
</bean>
```

The preceding bean definition snippet is exactly equivalent (at runtime) to the following snippet:

前面的 bean 定义片段（在运行时）与下面的片段完全等效：

==问题：为什么后面是value 不是 ref==

```xml
<bean id="theTargetBean" class="..." />

<bean id="client" class="...">
    <property name="targetName" value="theTargetBean"/>
</bean>
```

The first form is preferable to the second, because using the `idref` tag lets the container validate at deployment time that the referenced, named bean actually exists. In the second variation, no validation is performed on the value that is passed to the `targetName` property of the `client` bean. Typos are only discovered (with most likely fatal results) when the `client` bean is actually instantiated. If the `client` bean is a [prototype](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes) bean, this typo and the resulting exception may only be discovered long after the container is deployed.

第一种形式比第二种形式更可取，因为**使用 `idref` 标记可以让容器在部署时验证引用的命名 bean 是否确实存在**。在第二个变体中，没有对传递给 `client` bean的 `targetName` 属性的值执行任何验证。只有在实际实例化 `client` bean 时，才会发现输入错误（很可能是致命的结果）。**如果 `client` bean 是 [原型](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes) bean，只有在部署容器后很长一段时间才能发现此输入错误和由此产生的异常。**

> The `local` attribute on the `idref` element is no longer supported in the 4.0 beans XSD, since it does not provide value over a regular `bean` reference any more. Change your existing `idref local` references to `idref bean` when upgrading to the 4.0 schema.
>
> 4.0 beans XSD 中不再支持 `idref` 元素上的 `local` 属性，因为它不再提供常规 `bean` 引用上的值。升级到 4.0 架构时，将现有的 `idref local` 引用更改为 `idref bean`。

A common place (at least in versions earlier than Spring 2.0) where the `<idref/>` element brings value is in the configuration of [AOP interceptors](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pfb-1) in a `ProxyFactoryBean` bean definition. Using `<idref/>` elements when you specify the interceptor names prevents you from misspelling an interceptor ID.
`<idref/>`元素带来价值的一个常见位置（至少在 Spring 2.0 之前的版本中）是在 `ProxyFactoryBean` bean 定义中的 [AOP 拦截器](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pfb-1)配置中。在指定拦截器名称时使用`<idref/>`元素可以防止拼写错误拦截器 ID。

##### References to Other Beans (Collaborators)

##### 对其他 bean（协作者）的引用

The `ref` element is the final element inside a `<constructor-arg/>` or `<property/>` definition element. Here, you set the value of the specified property of a bean to be a reference to another bean (a collaborator) managed by the container. The referenced bean is a dependency of the bean whose property is to be set, and it is initialized on demand as needed before the property is set. (If the collaborator is a singleton bean, it may already be initialized by the container.) All references are ultimately a reference to another object. Scoping and validation depend on whether you specify the ID or name of the other object through the `bean` or `parent` attribute.

Specifying the target bean through the `bean` attribute of the `<ref/>` tag is the most general form and allows creation of a reference to any bean in the same container or parent container, regardless of whether it is in the same XML file. The value of the `bean` attribute may be the same as the `id` attribute of the target bean or be the same as one of the values in the `name` attribute of the target bean. The following example shows how to use a `ref` element:

`ref` 元素是 `<constructor-arg/>` 或 `<property/>` 定义元素中的最后一个元素。这里，您将 bean 的指定属性的值设置为对容器管理的另一个 bean（协作者）的引用。被引用的 bean 是要设置其属性的 bean 的依赖项**，并且在设置属性之前根据需要对其进行初始化**。（如果协作者是单例 bean，那么它可能已经被容器初始化了。）所有引用最终都是对另一个对象的引用。作用域和验证取决于是否通过 `bean` 或 `parent` 属性指定其他对象的 ID 或名称。

通过 `<ref/>` 标记的 `bean` 属性指定目标 bean 是最通用的形式，它**允许创建对同一容器或父容器中任何 bean 的引用**，而不管它是否在同一 XML 文件中。`bean` 属性的值可能与目标 bean 的 `id` 属性相同，或者与目标 bean 的 `name`属性中的一个值相同。以下示例显示如何使用 `ref`  元素：

```xml
<ref bean="someBean"/>
```

Specifying the target bean through the `parent` attribute creates a reference to a bean that is in a parent container of the current container. The value of the `parent` attribute may be the same as either the `id` attribute of the target bean or one of the values in the `name` attribute of the target bean. The target bean must be in a parent container of the current one. You should use this bean reference variant mainly when you have a hierarchy of containers and you want to wrap an existing bean in a parent container with a proxy that has the same name as the parent bean. The following pair of listings shows how to use the `parent` attribute:

**通过 `parent` 属性指定目标 bean 将创建对当前容器的父容器中的 bean 的引用**。`parent` 属性的值可以与目标 bean 的 `id` 属性相同，也可以与目标 bean 的 `name` 属性中的一个值相同。目标 bean 必须位于当前 bean 的父容器中。当您有容器的层次结构，并且希望使用与父 bean 同名的代理将现有 bean 包装到父容器中时，应该主要使用这个 bean 引用变量。以下两个清单显示了如何使用 `parent`属性：

```xml
<!-- in the parent context -->
<bean id="accountService" class="com.something.SimpleAccountService">
    <!-- insert dependencies as required here -->
</bean>

<!-- in the child (descendant) context -->
<bean id="accountService" <!-- bean name is the same as the parent bean -->
    class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="target">
        <ref parent="accountService"/> <!-- notice how we refer to the parent bean -->
    </property>
    <!-- insert other configuration and dependencies as required here -->
</bean>
```

> The `local` attribute on the `ref` element is no longer supported in the 4.0 beans XSD, since it does not provide value over a regular `bean` reference any more. Change your existing `ref local` references to `ref bean` when upgrading to the 4.0 schema.
>
> 4.0 beans XSD 不再支持 `ref` 元素上的 `local` 属性，因为它不再提供常规 `bean` 引用上的值。升级到 4.0 架构时，将现有的 `ref local` 引用更改为 `ref bean`。

##### Inner Beans

##### 内部 Bean

A `<bean/>` element inside the `<property/>` or `<constructor-arg/>` elements defines an inner bean, as the following example shows:

`<property/>` 或 `<constructor-arg/>` 元素中的 `<bean/>` 元素定义了一个内部 bean，如下例所示：

```xml
<bean id="outer" class="...">
    <!-- instead of using a reference to a target bean, simply define the target bean inline -->
    <property name="target">
        <bean class="com.example.Person"> <!-- this is the inner bean -->
            <property name="name" value="Fiona Apple"/>
            <property name="age" value="25"/>
        </bean>
    </property>
</bean>
```

An inner bean definition does not require a defined ID or name. If specified, the container does not use such a value as an identifier. The container also ignores the `scope` flag on creation, because inner beans are always anonymous and are always created with the outer bean. It is not possible to access inner beans independently or to inject them into collaborating beans other than into the enclosing bean.

As a corner case, it is possible to receive destruction callbacks from a custom scope — for example, for a request-scoped inner bean contained within a singleton bean. The creation of the inner bean instance is tied to its containing bean, but destruction callbacks let it participate in the request scope’s lifecycle. This is not a common scenario. Inner beans typically simply share their containing bean’s scope.

**内部 bean 定义不需要定义的 ID 或名称**。如果指定，则容器不使用此类值作为标识符。容器在创建时也会忽略 `scope` 标志，因为内部 bean 总是匿名的，并且总是使用外部 bean 创建的。不可能单独访问内部 bean，也不可能将它们注入到协作 bean 中，而不是封闭 bean 中。

作为一种特殊情况，可以从自定义范围接收销毁回调 — 例如，对于单例 bean 中包含的请求范围的内部 bean。内部 bean 实例的创建与其包含的 bean 相关联，但销毁回调允许它参与请求范围的生命周期。这不是常见的情况。内部 bean 通常只是共享其包含bean 的范围。

##### Collections

##### 集合

The `<list/>`, `<set/>`, `<map/>`, and `<props/>` elements set the properties and arguments of the Java `Collection` types `List`, `Set`, `Map`, and `Properties`, respectively. The following example shows how to use them:

`<list/>`、`<set/>`、`<map/>` 和 `<props/>` 元素分别设置 Java `Collection` 类型 `list`、`set`、`map` 和 `properties` 的属性和参数。以下示例显示了如何使用它们：

```xml
<bean id="moreComplexObject" class="example.ComplexObject">
    <!-- results in a setAdminEmails(java.util.Properties) call -->
    <property name="adminEmails">
        <props>
            <prop key="administrator">administrator@example.org</prop>
            <prop key="support">support@example.org</prop>
            <prop key="development">development@example.org</prop>
        </props>
    </property>
    <!-- results in a setSomeList(java.util.List) call -->
    <property name="someList">
        <list>
            <value>a list element followed by a reference</value>
            <ref bean="myDataSource" />
        </list>
    </property>
    <!-- results in a setSomeMap(java.util.Map) call -->
    <property name="someMap">
        <map>
            <entry key="an entry" value="just some string"/>
            <entry key="a ref" value-ref="myDataSource"/>
        </map>
    </property>
    <!-- results in a setSomeSet(java.util.Set) call -->
    <property name="someSet">
        <set>
            <value>just some string</value>
            <ref bean="myDataSource" />
        </set>
    </property>
</bean>
```

The value of a map key or value, or a set value, can also be any of the following elements:

映射键或值或集合值的值也可以是以下任意元素：

```xml
bean | ref | idref | list | set | map | props | value | null
```

###### Collection Merging

###### 集合合并

The Spring container also supports merging collections. An application developer can define a parent <list/>, <map/>, <set/> or <props/> element and have child <list/>, <map/>, <set/> or <props/> elements inherit and override values from the parent collection. That is, the child collection’s values are the result of merging the elements of the parent and child collections, with the child’s collection elements overriding values specified in the parent collection.

This section on merging discusses the parent-child bean mechanism. Readers unfamiliar with parent and child bean definitions may wish to read the [relevant section](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-child-bean-definitions) before continuing.

The following example demonstrates collection merging:

Spring 容器还支持合并集合。应用程序开发人员可以定义父级 `<list/>`、`<map/>`、`<set/>` 或 `<props/>` 元素，并让子级`<list/>`、`<map/>`、`<set/>` 或 `<props/>` 元素继承和重写父集合中的值。也就是说，**子集合的值是合并父集合和子集合的元素的结果，子集合的元素覆盖父集合中指定的值。**

关于合并的这一节讨论父子 bean 机制。不熟悉父 bean 和子 bean 定义的读者可能希望阅读[相关部分](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-child-bean-definitions) ，然后继续。

以下示例演示集合合并：

```xml
<beans>
    <bean id="parent" abstract="true" class="example.ComplexObject">
        <property name="adminEmails">
            <props>
                <prop key="administrator">administrator@example.com</prop>
                <prop key="support">support@example.com</prop>
            </props>
        </property>
    </bean>
    
    <bean id="child" parent="parent">
        <property name="adminEmails">
            <!-- the merge is specified on the child collection definition -->
            <props merge="true">
                <prop key="sales">sales@example.com</prop>
                <prop key="support">support@example.co.uk</prop>
            </props>
        </property>
    </bean>
<beans>
```

Notice the use of the `merge=true` attribute on the `<props/>` element of the `adminEmails` property of the `child` bean definition. When the `child` bean is resolved and instantiated by the container, the resulting instance has an `adminEmails` `Properties` collection that contains the result of merging the child’s `adminEmails` collection with the parent’s `adminEmails` collection. The following listing shows the result:

注意，在 `child` bean 定义的 `adminEmails` 属性的 `<props/>` 元素上使用了 `merge=true` 属性。当容器解析并实例化 `child` bean 时，生成的实例具有一个 `adminEmails Properties` 集合，**该集合包含将子级的 `adminEmails` 集合与父级的 `adminEmails` 集合合并的结果**。下面的列表显示了结果：

```properties
administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk
```

The child `Properties` collection’s value set inherits all property elements from the parent `<props/>`, and the child’s value for the `support` value overrides the value in the parent collection.

This merging behavior applies similarly to the `<list/>`, `<map/>`, and `<set/>` collection types. In the specific case of the `<list/>` element, the semantics associated with the `List` collection type (that is, the notion of an `ordered` collection of values) is maintained. The parent’s values precede all of the child list’s values. In the case of the `Map`, `Set`, and `Properties` collection types, no ordering exists. Hence, no ordering semantics are in effect for the collection types that underlie the associated `Map`, `Set`, and `Properties` implementation types that the container uses internally.

**子 `Properties` 集合的值集继承父 `<props/>` 集合中的所有属性元素，`support` 值的子值覆盖父集合中的值。**

此合并行为类似于 `<list/>`、`<map/>` 和 `<set/>` 集合类型。在 `<list/>` 元素的特定情况下，与 `List` 集合类型相关联的语义（即值的「有序」集合的概念）将得到维护。**父列表的值位于子列表的所有值之前**。对于 `Map`、`Set` 和 `Properties` 集合类型，不存在排序。因此，对于容器内部使用的关联 `Map`、`Set` 和 `Properties` 实现类型下的集合类型，没有有效的排序语义。

###### Limitations of Collection Merging

###### 集合合并的局限性

You cannot merge different collection types (such as a `Map` and a `List`). If you do attempt to do so, an appropriate `Exception` is thrown. The `merge` attribute must be specified on the lower, inherited, child definition. Specifying the `merge` attribute on a parent collection definition is redundant and does not result in the desired merging.

不能合并不同的集合类型（例如 `Map`和 `List`）。如果您确实尝试这样做，将抛出一个适当的异常。**必须在较低的继承子定义上指定 `merge` 属性。在父集合定义上指定 `merge` 属性是多余的，不会导致所需的合并**。

###### Strongly-typed collection

###### 强类型集合

With the introduction of generic types in Java 5, you can use strongly typed collections. That is, it is possible to declare a `Collection` type such that it can only contain (for example) `String` elements. If you use Spring to dependency-inject a strongly-typed `Collection` into a bean, you can take advantage of Spring’s type-conversion support such that the elements of your strongly-typed `Collection` instances are converted to the appropriate type prior to being added to the `Collection`. The following Java class and bean definition show how to do so:

随着 Java 5 中泛型类型的引入，您可以使用强类型集合。也就是说，可以声明一个 `Collection` 类型，使其只能包含（例如）`String` 元素。如果使用 Spring 将强类型的 `Collection` 依赖项注入 bean 中，那么可以利用 Spring 的类型转换支持，以便在将强类型的 `Collection` 实例的元素添加到 `Collection` 之前将其转换为适当的类型。以下 Java 类和 bean 定义说明了如何执行此操作：

```java
public class SomeClass {

    private Map<String, Float> accounts;

    public void setAccounts(Map<String, Float> accounts) {
        this.accounts = accounts;
    }
}
```

```xml
<beans>
    <bean id="something" class="x.y.SomeClass">
        <property name="accounts">
            <map>
                <entry key="one" value="9.99"/>
                <entry key="two" value="2.75"/>
                <entry key="six" value="3.99"/>
            </map>
        </property>
    </bean>
</beans>
```

When the `accounts` property of the `something` bean is prepared for injection, the generics information about the element type of the strongly-typed `Map<String, Float>` is available by reflection. Thus, Spring’s type conversion infrastructure recognizes the various value elements as being of type `Float`, and the string values (`9.99`, `2.75`, and `3.99`) are converted into an actual `Float` type.

当 `something` bean 的 `accounts` 属性准备好注入时，关于强类型 `Map<String, Float>` 的元素类型的泛型信息可以通过反射获得。因此，Spring 的类型转换基础结构将各种值元素识别为 `Float` 类型，字符串值（`9.99`、`2.75`、`3.99`）被转换为实际的 `Float` 类型。

##### Null and Empty String Values

##### Null 值和空字符串值

Spring treats empty arguments for properties and the like as empty `Strings`. The following XML-based configuration metadata snippet sets the `email` property to the empty `String` value ("").

Spring 将属性等的空参数视为空的「字符串」。以下基于 XML 的配置元数据片段将 `email` 属性设置为空的 `String` 值("")。

```xml
<bean class="ExampleBean">
    <property name="email" value=""/>
</bean>
```

The preceding example is equivalent to the following Java code:

前面的示例相当于以下 Java 代码：

```java
exampleBean.setEmail("");
```

The `<null/>` element handles `null` values. The following listing shows an example:

**`<null/>` 元素处理 `null` 值。**下面的列表显示了一个示例：

```xml
<bean class="ExampleBean">
    <property name="email">
        <null/>
    </property>
</bean>
```

The preceding configuration is equivalent to the following Java code:

上述配置相当于以下 Java 代码：

```java
exampleBean.setEmail(null);
```

##### XML Shortcut with the p-namespace

##### 带有 p-命名空间的 XML 快捷方式

The p-namespace lets you use the `bean` element’s attributes (instead of nested `<property/>` elements) to describe your property values collaborating beans, or both.

Spring supports extensible configuration formats [with namespaces](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#xsd-schemas), which are based on an XML Schema definition. The `beans` configuration format discussed in this chapter is defined in an XML Schema document. However, the p-namespace is not defined in an XSD file and exists only in the core of Spring.

The following example shows two XML snippets (the first uses standard XML format and the second uses the p-namespace) that resolve to the same result:

p-命名空间 允许您使用 `bean` 元素的属性（而不是嵌套的`<property/>`元素）来描述您的属性值，或者**同时使用这两种属性**。

Spring 支持可扩展配置格式[使用命名空间](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#xsd-schemas)，它们基于 XML 模式定义。本章讨论的 `beans` 配置格式是在 XML 模式文档中定义的。但是，**p-命名空间没有在 XSD 文件中定义，只存在于 Spring 的核心中**。

以下示例显示了两个解析为相同结果的 XML 片段（第一个使用标准 XML 格式，第二个使用 p-命名空间）：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean name="classic" class="com.example.ExampleBean">
        <property name="email" value="someone@somewhere.com"/>
    </bean>

    <bean name="p-namespace" class="com.example.ExampleBean"
        p:email="someone@somewhere.com"/>
</beans>
```

The example shows an attribute in the p-namespace called `email` in the bean definition. This tells Spring to include a property declaration. As previously mentioned, the p-namespace does not have a schema definition, so you can set the name of the attribute to the property name.

This next example includes two more bean definitions that both have a reference to another bean:

该示例显示了 bean 定义中名为 `email` 的 p-命名空间中的一个属性。这告诉 Spring 包含一个属性声明。如前所述，p-namespace没有模式定义，因此可以将属性名设置为属性名。

下一个示例包括另外两个 bean 定义，它们都引用了另一个 bean：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean name="john-classic" class="com.example.Person">
        <property name="name" value="John Doe"/>
        <property name="spouse" ref="jane"/>
    </bean>

    <bean name="john-modern"
        class="com.example.Person"
        p:name="John Doe"
        p:spouse-ref="jane"/>

    <bean name="jane" class="com.example.Person">
        <property name="name" value="Jane Doe"/>
    </bean>
</beans>
```

This example includes not only a property value using the p-namespace but also uses a special format to declare property references. Whereas the first bean definition uses `<property name="spouse" ref="jane"/>` to create a reference from bean `john` to bean `jane`, the second bean definition uses `p:spouse-ref="jane"` as an attribute to do the exact same thing. In this case, `spouse` is the property name, whereas the `-ref` part indicates that this is not a straight value but rather a reference to another bean.

此示例不仅包括**使用 p-命名空间的属性值，还使用特殊格式声明属性引用**。第一个 bean 定义使用 `<property name="spouse" ref="jane"/>`  来创建从 bean`john` 到 bean`jane` 的引用，而第二个 bean 定义使用 `p:spouse-ref="jane"` 作为属性来完成完全相同的操作。在本例中，`party` 是属性名，`-ref` 部分表示这不是一个直接值，而是对另一个 bean 的引用。

> The p-namespace is not as flexible as the standard XML format. For example, the format for declaring property references clashes with properties that end in `Ref`, whereas the standard XML format does not. We recommend that you choose your approach carefully and communicate this to your team members to avoid producing XML documents that use all three approaches at the same time.
>
> **p 命名空间不如标准 XML 格式灵活。例如，用于声明属性引用的格式与以 `Ref` 结尾的属性冲突，而标准 XML 格式则不冲突。我们建议您仔细选择您的方法，并将此告知您的团队成员，以避免生成同时使用这三种方法的 XML 文档。**

##### XML Shortcut with the c-namespace

##### 带有 c-命名空间的 XML 快捷方式

Similar to the [XML Shortcut with the p-namespace](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-p-namespace), the c-namespace, introduced in Spring 3.1, allows inlined attributes for configuring the constructor arguments rather then nested `constructor-arg` elements.

The following example uses the `c:` namespace to do the same thing as the from [Constructor-based Dependency Injection](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-constructor-injection):

类似于[p-命名空间的 XML 快捷方式](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-p-namespace)，Spring 3.1 中引入的 c-命名空间 允许内联属性来配置构造函数参数，而不是嵌套的 `constructor-arg` 元素。
下面的示例使用 `c:` 命名空间执行与 [Constructor-based-Dependency-Injection](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-constructor-injection)相同的操作：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:c="http://www.springframework.org/schema/c"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="beanTwo" class="x.y.ThingTwo"/>
    <bean id="beanThree" class="x.y.ThingThree"/>

    <!-- traditional declaration with optional argument names -->
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg name="thingTwo" ref="beanTwo"/>
        <constructor-arg name="thingThree" ref="beanThree"/>
        <constructor-arg name="email" value="something@somewhere.com"/>
    </bean>

    <!-- c-namespace declaration with argument names -->
    <bean id="beanOne" class="x.y.ThingOne" 
        c:thingTwo-ref="beanTwo"
        c:thingThree-ref="beanThree" 
        c:email="something@somewhere.com"
    />

</beans>
```

The `c:` namespace uses the same conventions as the `p:` one (a trailing `-ref` for bean references) for setting the constructor arguments by their names. Similarly, it needs to be declared in the XML file even though it is not defined in an XSD schema (it exists inside the Spring core).

For the rare cases where the constructor argument names are not available (usually if the bytecode was compiled without debugging information), you can use fallback to the argument indexes, as follows:

`c:`命名空间使用与`p:`one（bean 引用的尾部 `-ref`）相同的约定来按名称设置构造函数参数。类似地，它需要在 XML 文件中声明，即使它没有在 XSD 模式中定义（它存在于 Spring 内核中）。

**对于构造函数参数名称不可用的罕见情况（通常是在字节码编译时没有调试信息），可以使用参数索引的回退**，如下所示：

```xml
<!-- c-namespace index declaration -->
<bean id="beanOne" class="x.y.ThingOne" 
      c:_0-ref="beanTwo" 
      c:_1-ref="beanThree"
      `c:_2="something@somewhere.com"/>
```

> Due to the XML grammar, the index notation requires the presence of the leading `_`, as XML attribute names cannot start with a number (even though some IDEs allow it). A corresponding index notation is also available for `<constructor-arg>` elements but not commonly used since the plain order of declaration is usually sufficient there.
>
> 由于 XML 语法的原因，索引表示法要求出现前导的`_`，因为 XML 属性名不能以数字开头（即使某些 IDE 允许）。对于`<constructor-arg>`元素也有相应的索引表示法，但并不常用，因为声明的简单顺序通常就足够了。

In practice, the constructor resolution [mechanism](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-ctor-arguments-resolution) is quite efficient in matching arguments, so unless you really need to, we recommend using the name notation throughout your configuration.

实际上，构造函数解析[机制](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-ctor-arguments-resolution)在匹配参数方面非常有效，因此除非您确实需要，否则我们建议在整个配置中使用名称表示法。

##### Compound Property Names

##### 复合属性名

You can use compound or nested property names when you set bean properties, as long as all components of the path except the final property name are not `null`. Consider the following bean definition:

设置 bean 属性时，可以使用复合属性名或嵌套属性名，**只要路径的所有组件（最终属性名除外）都不为 `null`**。考虑下面的bean 定义：

```xml
<bean id="something" class="things.ThingOne">
    <property name="fred.bob.sammy" value="123" />
</bean>
```

The `something` bean has a `fred` property, which has a `bob` property, which has a `sammy` property, and that final `sammy` property is being set to a value of `123`. In order for this to work, the `fred` property of `something` and the `bob` property of `fred` must not be `null` after the bean is constructed. Otherwise, a `NullPointerException` is thrown.

`something` bean 有一个 `fred` 属性，它有一个 `bob` 属性，它有一个`sammy` 属性，最后的 `sammy` 属性被设置为值 `123`。为了使其工作，`something` 的 `fred` 属性和 `fred` 的 `bob` 属性在构造 bean 后不能为 `null`。否则，将抛出 `NullPointerException`。

#### 1.4.3. Using `depends-on`

#### 1.4.3 使用 `depends-on`

If a bean is a dependency of another bean, that usually means that one bean is set as a property of another. Typically you accomplish this with the [`<ref/> element`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-ref-element) in XML-based configuration metadata. However, sometimes dependencies between beans are less direct. An example is when a static initializer in a class needs to be triggered, such as for database driver registration. The `depends-on` attribute can explicitly force one or more beans to be initialized before the bean using this element is initialized. The following example uses the `depends-on` attribute to express a dependency on a single bean:

如果一个 bean 是另一个 bean 的依赖项，这通常意味着一个 bean 被设置为另一个 bean 的属性。通常在基于 XML 的配置元数据中使用 [`<ref/> element`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-ref-element) 来完成此操作，。然而，有时候 bean 之间的依赖关系不那么直接。例如，需要触发类中的静态初始值设定项，例如数据库驱动程序注册。**`depends-on` 属性可以显式地强制在初始化使用此元素的 bean 之前初始化一个或多个bean**。以下示例使用 `depends-on` 属性表示对单个 bean 的依赖关系：

```xml
<bean id="beanOne" class="ExampleBean" depends-on="manager"/>
<bean id="manager" class="ManagerBean" />
```

To express a dependency on multiple beans, supply a list of bean names as the value of the `depends-on` attribute (commas, whitespace, and semicolons are valid delimiters):

**要表示对多个 bean 的依赖关系，请提供一个 bean 名称列表，作为 `depends-on` 属性的值（逗号、空格和分号是有效的分隔符）**：

```xml
<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
    <property name="manager" ref="manager" />
</bean>

<bean id="manager" class="ManagerBean" />
<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />
```

> The `depends-on` attribute can specify both an initialization-time dependency and, in the case of [singleton](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton) beans only, a corresponding destruction-time dependency. Dependent beans that define a `depends-on` relationship with a given bean are destroyed first, prior to the given bean itself being destroyed. Thus, `depends-on` can also control shutdown order.
>
> `depends-on` 属性既可以指定初始化时间依赖，也可以指定对应的销毁时间依赖（仅在[singleton](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton) bean 的情况下）。在销毁给定 bean 之前，首先销毁定义与给定 bean 的 `dependen-on` 关系的依赖 bean。因此，`dependen`也可以控制关机顺序。

#### 1.4.4. Lazy-initialized Beans

#### 1.4.4. 延迟初始化 Bean

By default, `ApplicationContext` implementations eagerly create and configure all [singleton](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton) beans as part of the initialization process. Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later. When this behavior is not desirable, you can prevent pre-instantiation of a singleton bean by marking the bean definition as being lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup.

In XML, this behavior is controlled by the `lazy-init` attribute on the `<bean/>` element, as the following example shows:

默认情况下，`ApplicationContext` 实现在初始化过程中急切地创建和配置所有 [singleton](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton) bean。通常，这种预实例化是可取的，因为配置或周围环境中的错误会立即被发现，而不是数小时甚至数天之后。当这种行为不可取时，可以通过将 bean 定义标记为延迟初始化来防止单例 bean 的预实例化。**延迟初始化 bean 告诉 IoC 容器在第一次请求时而不是在启动时创建 bean 实例**。

在 XML 中，此行为由 `<bean/>` 元素上的 `lazy-init` 属性控制，如下例所示：

```xml
<bean id="lazy" class="com.something.ExpensiveToCreateBean" lazy-init="true"/>
<bean name="not.lazy" class="com.something.AnotherBean"/>
```

When the preceding configuration is consumed by an `ApplicationContext`, the `lazy` bean is not eagerly pre-instantiated when the `ApplicationContext` starts, whereas the `not.lazy` bean is eagerly pre-instantiated.

However, when a lazy-initialized bean is a dependency of a singleton bean that is not lazy-initialized, the `ApplicationContext` creates the lazy-initialized bean at startup, because it must satisfy the singleton’s dependencies. The lazy-initialized bean is injected into a singleton bean elsewhere that is not lazy-initialized.

You can also control lazy-initialization at the container level by using the `default-lazy-init` attribute on the `<beans/>` element, as the following example shows:

当前面的配置被 `ApplicationContext` 使用时，`lazy` bean 不会在 `ApplicationContext` 启动时被急切地预实例化，而`not.lazy` bean 会急切地被预先实例化。

**但是，当延迟初始化 bean 是未延迟初始化的单例 bean 的依赖项时，`ApplicationContext` 在启动时会创建延迟初始化 bean，因为它必须满足单例的依赖项。延迟初始化 bean 被注入到非延迟初始化的其他地方的单例 bean 中。**

您还可以在 `<beans/>` 元素上使用 `default-lazy-init` 属性在容器级别控制延迟初始化，如下例所示：

```xml
<beans default-lazy-init="true">
    <!-- no beans will be pre-instantiated... -->
</beans>
```

#### 1.4.5. Autowiring Collaborators

#### 1.4.5 自动装配集合

The Spring container can autowire relationships between collaborating beans. You can let Spring resolve collaborators (other beans) automatically for your bean by inspecting the contents of the `ApplicationContext`. Autowiring has the following advantages:

- Autowiring can significantly reduce the need to specify properties or constructor arguments. (Other mechanisms such as a bean template [discussed elsewhere in this chapter](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-child-bean-definitions) are also valuable in this regard.)
- Autowiring can update a configuration as your objects evolve. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable.

When using XML-based configuration metadata (see [Dependency Injection](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators)), you can specify the autowire mode for a bean definition with the `autowire` attribute of the `<bean/>` element. The autowiring functionality has four modes. You specify autowiring per bean and can thus choose which ones to autowire. The following table describes the four autowiring modes:

Spring 容器可以自动装配协作 bean 之间的关系。通过检查 `ApplicationContext` 的内容，您可以让 Spring 为您的 bean 自动解析协作者（其他 bean）。自动装配具有以下优点：

- 自动装配可以显著减少指定属性或构造函数参数的需要。（在这方面，其他机制（如 bean 模板[在本章其他部分讨论](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-child-bean-definitions)也很有价值。）
- **自动装配可以随着对象的发展而更新配置**。例如，如果您需要向类添加依赖项，则可以自动满足该依赖项，而无需修改配置。因此，在开发过程中，自动装配特别有用，而不会在代码库变得更稳定时取消切换到显式连接的选项。

使用基于 XML 的配置元数据时（请参阅[依赖项注入](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators)），您可以使用 `<bean/>` 元素的 `autowire` 属性为 bean 定义指定 autowire 模式。自动装配功能有四种模式。您可以为每个 bean 指定自动装配，从而可以选择要自动装配的 bean。下表介绍了四种自动装配模式：

| Mode          | Explanation                                                  |
| :------------ | :----------------------------------------------------------- |
| `no`          | (Default) No autowiring. Bean references must be defined by `ref` elements. Changing the default setting is not recommended for larger deployments, because specifying collaborators explicitly gives greater control and clarity. To some extent, it documents the structure of a system.<br />（默认）无自动装配。Bean 引用必须由 `ref` 元素定义。**对于较大的部署，不建议更改默认设置，因为明确指定协作者可以提供更大的控制和清晰度。在某种程度上，它记录了一个系统的结构。** |
| `byName`      | Autowiring by property name. Spring looks for a bean with the same name as the property that needs to be autowired. For example, if a bean definition is set to autowire by name and it contains a `master` property (that is, it has a `setMaster(..)` method), Spring looks for a bean definition named `master` and uses it to set the property.<br />按属性**名称**自动装配。Spring 查找与需要自动装配的**属性同名的** bean。例如，如果一个 bean 定义按名称设置为 autowire，并且它包含一个 `master` 属性（即，它有一个`setMaster(..)`方法），Spring  查找名为 `master` 的 bean 定义并使用它设置属性。 |
| `byType`      | Lets a property be autowired if exactly one bean of the property type exists in the container. If more than one exists, a fatal exception is thrown, which indicates that you may not use `byType` autowiring for that bean. If there are no matching beans, nothing happens (the property is not set).<br />如果容器中正好存在一个属性类型的 bean，则允许自动装配属性。**如果存在多个，将抛出一个致命异常**，这表示您可能不会对该 bean 使用 `byType` 自动装配。**如果没有匹配的 bean，则不会发生任何事情（未设置属性）。** |
| `constructor` | Analogous to `byType` but applies to constructor arguments. If there is not exactly one bean of the constructor argument type in the container, a fatal error is raised.<br />类似于 `byType`，但适用于构造函数参数。如果容器中没有一个构造函数参数类型的 bean，则会引发致命错误。 |

With `byType` or `constructor` autowiring mode, you can wire arrays and typed collections. In such cases, all autowire candidates within the container that match the expected type are provided to satisfy the dependency. You can autowire strongly-typed `Map` instances if the expected key type is `String`. An autowired `Map` instance’s values consist of all bean instances that match the expected type, and the `Map` instance’s keys contain the corresponding bean names.

使用 `byType` 或 `constructor` 自动配置模式，可以连接数组和类型化集合。在这种情况下，将提供容器中与预期类型匹配的所有 autowire 候选项以满足依赖关系。如果所需的键类型为 `String`，则可以自动装配强类型的 `Map` 实例。自动装配的 `Map` 实例的值由与预期类型匹配的所有 bean 实例组成，`Map` 实例的键包含相应的 bean 名称。

##### Limitations and Disadvantages of Autowiring

##### 自动装配的局限性和缺点

Autowiring works best when it is used consistently across a project. If autowiring is not used in general, it might be confusing to developers to use it to wire only one or two bean definitions.

Consider the limitations and disadvantages of autowiring:

- Explicit dependencies in `property` and `constructor-arg` settings always override autowiring. You cannot autowire simple properties such as primitives, `Strings`, and `Classes` (and arrays of such simple properties). This limitation is by-design.
- Autowiring is less exact than explicit wiring. Although, as noted in the earlier table, Spring is careful to avoid guessing in case of ambiguity that might have unexpected results. The relationships between your Spring-managed objects are no longer documented explicitly.
- Wiring information may not be available to tools that may generate documentation from a Spring container.
- Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired. For arrays, collections, or `Map` instances, this is not necessarily a problem. However, for dependencies that expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.

In the latter scenario, you have several options:

- Abandon autowiring in favor of explicit wiring.
- Avoid autowiring for a bean definition by setting its `autowire-candidate` attributes to `false`, as described in the [next section](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire-candidate).
- Designate a single bean definition as the primary candidate by setting the `primary` attribute of its `<bean/>` element to `true`.
- Implement the more fine-grained control available with annotation-based configuration, as described in [Annotation-based Container Configuration](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config).

自动装配在整个项目中一致使用时效果最佳。如果通常不使用自动装配，那么使用它仅连接一个或两个 bean 定义可能会让开发人员感到困惑。

**考虑自动装配的局限性和缺点：**

- `property` 和 `constructor-arg` 设置中的显式依赖项**始终覆盖自动装配**。**您不能自动装配简单属性**，如基本数据类型、`Strings` 和 `Classes`（以及此类简单属性的数组）。这一限制是故意造成的。
- 自动装配不如显式装配精确。尽管如此，如前表所述，Spring 小心避免在可能产生意外结果的歧义情况下进行猜测。Spring 托管对象之间的关系不再明确记录。
- 装配信息可能不适用于可能从 Spring 容器生成文档的工具。
- 容器中的多个 bean 定义可能与要自动装配的 setter 方法或构造函数参数指定的类型匹配。对于数组、集合或 `Map` 实例，这不一定是问题。然而，对于期望单个值的依赖项，这种模糊性并不是任意解决的。如果没有唯一的 bean 定义可用，将引发异常。

在后一种情况下，您有几个选项：

- 放弃自动装配，支持显式装配。
- 如[下一节](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire-candidate)中所述，通过将 bean 定义的 `autowire-candidate` 属性设置为 `false`，避免 bean 定义的自动装配。
- 通过将其 `<bean/>` 元素的 `primary` 属性设置为 `true`，将单个 bean 定义指定为主要候选项。
- 如[annotation-based Container configuration](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config)中所述，使用基于注解的配置实现更细粒度的控制。

##### Excluding a Bean from Autowiring

##### 从自动装配中排除 Bean

On a per-bean basis, you can exclude a bean from autowiring. In Spring’s XML format, set the `autowire-candidate` attribute of the `<bean/>` element to `false`. The container makes that specific bean definition unavailable to the autowiring infrastructure (including annotation style configurations such as [`@Autowired`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-autowired-annotation)).

在每个 bean 的基础上，您可以将 bean 从自动装配中排除。在 Spring 的 XML 格式中，将 `<bean/>`元素的 `autowire-candidate` 属性设置为 `false`。该容器使特定的 bean 定义对自动装配基础结构不可用（包括注解样式配置，如[`@Autowired`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-autowired-annotation)）。

> The `autowire-candidate` attribute is designed to only affect type-based autowiring. It does not affect explicit references by name, which get resolved even if the specified bean is not marked as an autowire candidate. As a consequence, autowiring by name nevertheless injects a bean if the name matches.
>
> **`autowire-candidate`  属性设计为仅影响基于类型的自动装配。它不会按名称影响显式引用**，即使指定的 bean 未标记为autowire 候选，也会解析显式引用。因此，如果名称匹配，按名称自动匹配将注入 bean。

You can also limit autowire candidates based on pattern-matching against bean names. The top-level `<beans/>` element accepts one or more patterns within its `default-autowire-candidates` attribute. For example, to limit autowire candidate status to any bean whose name ends with `Repository`, provide a value of `*Repository`. To provide multiple patterns, define them in a comma-separated list. An explicit value of `true` or `false` for a bean definition’s `autowire-candidate` attribute always takes precedence. For such beans, the pattern matching rules do not apply.

These techniques are useful for beans that you never want to be injected into other beans by autowiring. It does not mean that an excluded bean cannot itself be configured by using autowiring. Rather, the bean itself is not a candidate for autowiring other beans.

**您还可以基于对 bean 名称的模式匹配来限制自动装配候选项**。顶级 `<beans/>` 元素在其 `default-autowire-candidates`属性中接受一个或多个模式。例如，要将 autowire 候选状态限制为名称以 `Repository` 结尾的任何 bean，请提供值 `*Repository`。要提供多个模式，请在逗号分隔的列表中定义它们。bean 定义的 `autowire-candidate` 属性的显式值 `true` 或 `false`始终优先。对于这样的 bean，模式匹配规则不适用。

这些技术对于您永远不希望通过自动装配注入其他 bean 的 bean 非常有用。这并不意味着排除的 bean 本身不能通过使用自动装配进行配置。相反，bean 本身不是自动装配其他 bean 的候选对象。

#### 1.4.6. Method Injection

#### 1.4.6.方法注入

In most application scenarios, most beans in the container are [singletons](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton). When a singleton bean needs to collaborate with another singleton bean or a non-singleton bean needs to collaborate with another non-singleton bean, you typically handle the dependency by defining one bean as a property of the other. A problem arises when the bean lifecycles are different. Suppose singleton bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A. The container creates the singleton bean A only once, and thus only gets one opportunity to set the properties. The container cannot provide bean A with a new instance of bean B every time one is needed.

A solution is to forego some inversion of control. You can [make bean A aware of the container](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware) by implementing the `ApplicationContextAware` interface, and by [making a `getBean("B")` call to the container](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-client) ask for (a typically new) bean B instance every time bean A needs it. The following example shows this approach:

在大多数应用程序场景中，容器中的大多数 bean 都是单例的。当一个单例 bean 需要与另一个单例 bean 协作，或者一个非单例 bean 需要与另一个非单例 bean 协作时，通常通过将一个 bean 定义为另一个 bean 的属性来处理依赖关系。**当 bean 的生命周期不同时，就会出现问题**。假设单例 bean A 需要使用非单例（原型）bean B，可能是在 A 上的每个方法调用上。容器只创建单例bean A 一次，因此只有一次机会设置属性。容器不能在每次需要时为 bean A 提供 bean B 的新实例。

一个解决办法是放弃一些控制反转。您可以通过实现 `ApplicationContextAware` 接口[使 bean A 意识到容器](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware)，并通过 [使用`getBean(“B”)` 调用容器](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-client)在每次 bean A 需要时请求（通常是新的）bean B 实例。以下示例显示了此方法：

```java
// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean("command", Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
```

The preceding is not desirable, because the business code is aware of and coupled to the Spring Framework. Method Injection, a somewhat advanced feature of the Spring IoC container, lets you handle this use case cleanly.

You can read more about the motivation for Method Injection in [this blog entry](https://spring.io/blog/2004/08/06/method-injection/).

**前面的内容是不可取的，因为业务代码知道 Spring 框架并与之耦合。方法注入是 Spring IoC 容器的一个稍微高级的特性，它允许您干净地处理这个用例。**

你可以在[这篇博客文章](https://spring.io/blog/2004/08/06/method-injection/)中阅读更多关于方法注入动机的信息.

##### Lookup Method Injection

##### 查找方法注入

Lookup method injection is the ability of the container to override methods on container-managed beans and return the lookup result for another named bean in the container. The lookup typically involves a prototype bean, as in the scenario described in [the preceding section](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-method-injection). The Spring Framework implements this method injection by using bytecode generation from the CGLIB library to dynamically generate a subclass that overrides the method.

查找方法注入是容器重写容器管理 bean 上的方法并返回容器中另一个命名 bean 的查找结果的能力。查找通常涉及一个原型bean，如[上一节](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-method-injection)中描述的场景**。Spring 框架通过使用 CGLIB 库中的字节码生成来动态生成重写该方法的子类，从而实现这种方法注入。**

> - For this dynamic subclassing to work, the class that the Spring bean container subclasses cannot be `final`, and the method to be overridden cannot be `final`, either.
> - Unit-testing a class that has an `abstract` method requires you to subclass the class yourself and to supply a stub implementation of the `abstract` method.
> - Concrete methods are also necessary for component scanning, which requires concrete classes to pick up.
> - A further key limitation is that lookup methods do not work with factory methods and in particular not with `@Bean` methods in configuration classes, since, in that case, the container is not in charge of creating the instance and therefore cannot create a runtime-generated subclass on the fly.
>
> - 为了使这个动态子类能够工作，spring bean 容器子类的类不能 `final`，要重写的方法也不能是 `final`。
> - 对具有 `abstract` 方法的类进行单元测试需要您自己对该类进行子类化，并提供 `abstract` 方法的存根实现。
> - 组件扫描还需要具体的方法，这需要具体的类来拾取。
> - 另一个关键限制是，查找方法不适用于工厂方法，特别是配置类中的 `@Bean` 方法，因为在这种情况下，容器不负责创建实例，因此无法动态创建运行时生成的子类。

In the case of the `CommandManager` class in the previous code snippet, the Spring container dynamically overrides the implementation of the `createCommand()` method. The `CommandManager` class does not have any Spring dependencies, as the reworked example shows:

对于前面代码段中的 `CommandManager` 类，Spring 容器动态重写 `createCommand()` 方法的实现。`CommandManager` 类没有任何 Spring 依赖项，如修改后的示例所示：

```java
package fiona.apple;

// no more Spring imports!

public abstract class CommandManager {

    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}
```

In the client class that contains the method to be injected (the `CommandManager` in this case), the method to be injected requires a signature of the following form:

在包含要注入的方法的客户端类（本例中为 `CommandManager` ）中，要注入的方法需要以下形式的签名：

```xml
<public|protected> [abstract] <return-type> theMethodName(no-arguments);
```

If the method is `abstract`, the dynamically-generated subclass implements the method. Otherwise, the dynamically-generated subclass overrides the concrete method defined in the original class. Consider the following example:

如果方法为 `abstract`，则动态生成的子类将实现该方法。否则，动态生成的子类将重写在原始类中定义的具体方法。考虑下面的例子：

```xml
<!-- a stateful bean deployed as a prototype (non-singleton) -->
<bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype">
    <!-- inject dependencies here as required -->
</bean>

<!-- commandProcessor uses statefulCommandHelper -->
<bean id="commandManager" class="fiona.apple.CommandManager">
    <lookup-method name="createCommand" bean="myCommand"/>
</bean>
```

The bean identified as `commandManager` calls its own `createCommand()` method whenever it needs a new instance of the `myCommand` bean. You must be careful to deploy the `myCommand` bean as a prototype if that is actually what is needed. If it is a [singleton](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton), the same instance of the `myCommand` bean is returned each time.

Alternatively, within the annotation-based component model, you can declare a lookup method through the `@Lookup` annotation, as the following example shows:

标识为 `commandManager` 的 bean 在需要 `myCommand` bean 的新实例时调用自己的 `createCommand()` 方法。如果实际需要的话，您必须小心地将 `myCommand` bean 部署为原型。如果它是一个[单例](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton)，每次都返回相同的 `myCommand` bean实例。
或者，在基于注解的组件模型中，可以通过 `@lookup` 注解声明查找方法，如下例所示：

```java
public abstract class CommandManager {

    public Object process(Object commandState) {
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup("myCommand")
    protected abstract Command createCommand();
}
```

Or, more idiomatically, you can rely on the target bean getting resolved against the declared return type of the lookup method:

或者，更习惯地说，您可以依靠目标 bean 根据查找方法的声明返回类型进行解析：

```java
public abstract class CommandManager {

    public Object process(Object commandState) {
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup
    protected abstract Command createCommand();
}
```

Note that you should typically declare such annotated lookup methods with a concrete stub implementation, in order for them to be compatible with Spring’s component scanning rules where abstract classes get ignored by default. This limitation does not apply to explicitly registered or explicitly imported bean classes.

请注意，您通常应该使用具体的存根实现声明此类带注解的查找方法，以便它们与Spring的组件扫描规则兼容，默认情况下抽象类会被忽略。此限制不适用于显式注册或显式导入的bean类。

>   Another way of accessing differently scoped target beans is an `ObjectFactory`/ `Provider` injection point. See [Scoped Beans as Dependencies](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection).You may also find the `ServiceLocatorFactoryBean` (in the `org.springframework.beans.factory.config` package) to be useful.
>
>   访问不同范围的目标 bean 的另一种方法是 `ObjectFactory`/`Provider` 注入点。请参阅[作用域bean作为依赖项](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection)。您可能还会发现 `ServiceLocatoryFactoryBean`（在 `org.springframework.beans.factory.config` 包中）很有用。

##### Arbitrary Method Replacement

##### 任意方法替换

A less useful form of method injection than lookup method injection is the ability to replace arbitrary methods in a managed bean with another method implementation. You can safely skip the rest of this section until you actually need this functionality.

With XML-based configuration metadata, you can use the `replaced-method` element to replace an existing method implementation with another, for a deployed bean. Consider the following class, which has a method called `computeValue` that we want to override:

与查找方法注入相比，方法注入的一种不太有用的形式是能够用另一种方法实现替换托管 bean 中的任意方法。在实际需要此功能之前，您可以安全地跳过本节的其余部分。

对于基于 XML 的配置元数据，您可以使用 `replaced-method`元素将已部署 bean 的现有方法实现替换为另一个方法实现。考虑下面的类，它有一个我们想重写的叫做 `computeValue` 的方法：

```java
public class MyValueCalculator {

    public String computeValue(String input) {
        // some real code...
    }

    // some other methods...
}
```

A class that implements the `org.springframework.beans.factory.support.MethodReplacer` interface provides the new method definition, as the following example shows:

实现 `org.springframework.beans.factory.support.MethodReplacer`接口的类提供了新的方法定义，如下例所示：

```java
/**
 * meant to be used to override the existing computeValue(String)
 * implementation in MyValueCalculator
 */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ...
        return ...;
    }
}
```

The bean definition to deploy the original class and specify the method override would resemble the following example:

部署原始类并指定方法重写的 bean 定义类似于以下示例：

```xml
<bean id="myValueCalculator" class="x.y.z.MyValueCalculator">
    <!-- arbitrary method replacement -->
    <replaced-method name="computeValue" replacer="replacementComputeValue">
        <arg-type>String</arg-type>
    </replaced-method>
</bean>

<bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/>
```

You can use one or more `<arg-type/>` elements within the `<replaced-method/>` element to indicate the method signature of the method being overridden. The signature for the arguments is necessary only if the method is overloaded and multiple variants exist within the class. For convenience, the type string for an argument may be a substring of the fully qualified type name. For example, the following all match `java.lang.String`:

您可以在`<replaced-method/>`元素中使用一个或多个`<arg-type/>`元素来指示要重写的方法的方法签名。只有当方法重载且类中存在多个变量时，才需要参数的签名。为方便起见，参数的类型字符串可以是完全限定类型名称的子字符串。例如，下面的所有匹配项都是`java.lang.String`:

```java
java.lang.String
String
Str
```

Because the number of arguments is often enough to distinguish between each possible choice, this shortcut can save a lot of typing, by letting you type only the shortest string that matches an argument type.

由于参数的数量通常足以区分每个可能的选择，因此此快捷方式可以通过只允许键入与参数类型匹配的最短字符串来节省大量键入。

### 1.5. Bean Scopes

### 1.5 Bean 作用域

When you create a bean definition, you create a recipe for creating actual instances of the class defined by that bean definition. The idea that a bean definition is a recipe is important, because it means that, as with a class, you can create many object instances from a single recipe.

You can control not only the various dependencies and configuration values that are to be plugged into an object that is created from a particular bean definition but also control the scope of the objects created from a particular bean definition. This approach is powerful and flexible, because you can choose the scope of the objects you create through configuration instead of having to bake in the scope of an object at the Java class level. Beans can be defined to be deployed in one of a number of scopes. The Spring Framework supports six scopes, four of which are available only if you use a web-aware `ApplicationContext`. You can also create [a custom scope.](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-custom)

The following table describes the supported scopes:

当您创建一个 bean 定义时，您创建了一个菜谱（方法），用于创建由该 bean 定义定义的类的实际实例。bean 定义是一个菜谱的想法很重要，因为这意味着，与类一样，可以从一个菜谱创建多个对象实例。

您不仅可以控制要插入到从特定 bean 定义创建的对象中的各种依赖项和配置值，还可以控制从特定 bean 定义创建的对象的范围。这种方法功能强大且灵活，因为您可以选择通过配置创建的对象的范围，而不必在 Java 类级别烘焙对象的范围。可以将bean 定义为部署在多个作用域中的一个。Spring 框架支持六个作用域，其中四个只有在使用 web 感知的 `ApplicationContext` 时才可用。您还可以创建[自定义范围。](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-custom)

下表描述了支持的作用域：

| Scope                                                        | Description                                                  |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [singleton](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton) | (Default) Scopes a single bean definition to a single object instance for each Spring IoC container.<br />（默认）为每个 Spring IOC 容器将单个 bean 定义的范围限定为单个对象实例。 |
| [prototype](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-prototype) | Scopes a single bean definition to any number of object instances.<br />将单个 bean 定义的范围限定为任意数量的对象实例。 |
| [request](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-request) | Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring `ApplicationContext`.<br />将单个 bean 定义限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有自己的 bean 实例，该实例是在单个 bean 定义的后面创建的。仅在支持 web 的 Spring `ApplicationContext`上下文中有效。 |
| [session](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-session) | Scopes a single bean definition to the lifecycle of an HTTP `Session`. Only valid in the context of a web-aware Spring `ApplicationContext`.<br />将单个 bean 定义的范围限定到 HTTP  `Session` 的生命周期。仅在支持 web 的 Spring `ApplicationContext`上下文中有效。 |
| [application](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-application) | Scopes a single bean definition to the lifecycle of a `ServletContext`. Only valid in the context of a web-aware Spring `ApplicationContext`.<br />将单个 bean 定义限定为 `ServletContext` 的生命周期。仅在支持 web 的 Spring `ApplicationContext` 上下文中有效。 |
| [websocket](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-websocket-scope) | Scopes a single bean definition to the lifecycle of a `WebSocket`. Only valid in the context of a web-aware Spring `ApplicationContext`.<br />将单个 bean 定义限定为 `WebSocket` 的生命周期。仅在支持 web 的 Spring `ApplicationContext`上下文中有效。 |

> As of Spring 3.0, a thread scope is available but is not registered by default. For more information, see the documentation for [`SimpleThreadScope`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/support/SimpleThreadScope.html). For instructions on how to register this or any other custom scope, see [Using a Custom Scope](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-custom-using).
>
> **从 Spring 3.0 开始，线程作用域可用，但默认情况下未注册。有关详细信息，请参阅 [`SimpleThreadScope`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/support/SimpleThreadScope.html) 的文档**。有关如何注册此自定义作用域或任何其他自定义作用域的说明，请参阅[使用自定义作用域](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-custom-using)。

#### 1.5.1. The Singleton Scope

#### 1.5.1 单例作用域

Only one shared instance of a singleton bean is managed, and all requests for beans with an ID or IDs that match that bean definition result in that one specific bean instance being returned by the Spring container.

To put it another way, when you define a bean definition and it is scoped as a singleton, the Spring IoC container creates exactly one instance of the object defined by that bean definition. This single instance is stored in a cache of such singleton beans, and all subsequent requests and references for that named bean return the cached object. The following image shows how the singleton scope works:

只管理一个单例 bean 的一个共享实例，对 ID 与该 bean 定义匹配的 bean 的所有请求都会导致 Spring 容器返回该特定 bean 实例。

换句话说，当您定义一个 bean 定义并将其范围限定为一个单例时，Spring IOC 容器只创建该 bean 定义定义的对象的一个实例。**这个实例存储在这样的单例 bean 的缓存中，该命名 bean 的所有后续请求和引用都返回缓存对象**。下图显示了 singleton 作用域的工作原理：

![singleton](1.The IoC Container.resource/singleton.png)

Spring’s concept of a singleton bean differs from the singleton pattern as defined in the Gang of Four (GoF) patterns book. The GoF singleton hard-codes the scope of an object such that one and only one instance of a particular class is created per ClassLoader. The scope of the Spring singleton is best described as being per-container and per-bean. This means that, if you define one bean for a particular class in a single Spring container, the Spring container creates one and only one instance of the class defined by that bean definition. The singleton scope is the default scope in Spring. To define a bean as a singleton in XML, you can define a bean as shown in the following example:

Spring 的单例 bean 概念不同于四人组（Gang of Four，GoF）模式书中定义的单例模式。==**GoF 单例硬编码对象的作用域，这样每个类加载器只创建一个特定类的实例**。**Spring 单例的范围最好描述为每个容器和每个 bean。这意味着，如果在单个 Spring 容器中为特定类定义一个 bean，Spring 容器将创建该 bean 定义的类的一个且仅一个实例。单例作用域是 Spring 中的默认作用域。**==要将 bean 定义为 XML 中的单例，可以定义 bean，如下例所示：

```xml
<bean id="accountService" class="com.something.DefaultAccountService"/>

<!-- the following is equivalent, though redundant (singleton scope is the default) -->
<bean id="accountService" class="com.something.DefaultAccountService" scope="singleton"/>
```

#### 1.5.2. The Prototype Scope

#### 1.5.2.原型作用域

The non-singleton prototype scope of bean deployment results in the creation of a new bean instance every time a request for that specific bean is made. That is, the bean is injected into another bean or you request it through a `getBean()` method call on the container. As a rule, you should use the prototype scope for all stateful beans and the singleton scope for stateless beans.

The following diagram illustrates the Spring prototype scope:

bean 部署的非单例原型范围导致每次对特定 bean 发出请求时都创建一个新的 bean 实例。也就是说，该 bean 被注入到另一个bean 中，或者通过容器上的`getBean()`方法调用来请求它。通常，**所有有状态 bean 都应该使用 prototype 作用域，无状态 bean 应该使用 singleton 作用域。**

下图说明了 Spring 原型的范围：

![prototype](1.The IoC Container.resource/prototype.png)

(A data access object (DAO) is not typically configured as a prototype, because a typical DAO does not hold any conversational state. It was easier for us to reuse the core of the singleton diagram.)

The following example defines a bean as a prototype in XML:

（数据访问对象（DAO）通常不配置为原型，因为典型的 DAO 不包含任何会话状态。我们更容易重用单例图的核心。）

以下示例将 bean 定义为 XML 中的原型：

```xml
<bean id="accountService" class="com.something.DefaultAccountService" scope="prototype"/>
```

In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean. The container instantiates, configures, and otherwise assembles a prototype object and hands it to the client, with no further record of that prototype instance. Thus, although initialization lifecycle callback methods are called on all objects regardless of scope, in the case of prototypes, configured destruction lifecycle callbacks are not called. The client code must clean up prototype-scoped objects and release expensive resources that the prototype beans hold. To get the Spring container to release resources held by prototype-scoped beans, try using a custom [bean post-processor](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-bpp), which holds a reference to beans that need to be cleaned up.

In some respects, the Spring container’s role in regard to a prototype-scoped bean is a replacement for the Java `new` operator. All lifecycle management past that point must be handled by the client. (For details on the lifecycle of a bean in the Spring container, see [Lifecycle Callbacks](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle).)

与其他作用域不同，**Spring 并不管理原型 bean 的整个生命周期。容器实例化、配置和以其他方式组装原型对象并将其交给客户机，而不再记录该原型实例**。因此，尽管对所有对象调用初始化生命周期回调方法，而不考虑范围，但对于原型，不会调用配置的销毁生命周期回调。**客户机代码必须清理原型范围的对象，并释放原型 bean 所持有的昂贵资源。为了让 Spring 容器释放原型范围的 bean 所持有的资源，请尝试使用自定义的 [bean post-processor](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-bpp)，它持有对需要清理的 bean 的引用。**

在某些方面，Spring 容器在原型作用域 bean 中的角色是 Java `new ` 操作符的替代品。所有超过该点的生命周期管理都必须由客户机处理。（有关 Spring 容器中 bean 生命周期的详细信息，请参阅[生命周期回调](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle)。）

#### 1.5.3. Singleton Beans with Prototype-bean Dependencies

#### 1.5.3.具有原型 bean 依赖关系的单例 bean

When you use singleton-scoped beans with dependencies on prototype beans, be aware that dependencies are resolved at instantiation time. Thus, if you dependency-inject a prototype-scoped bean into a singleton-scoped bean, a new prototype bean is instantiated and then dependency-injected into the singleton bean. The prototype instance is the sole instance that is ever supplied to the singleton-scoped bean.

However, suppose you want the singleton-scoped bean to acquire a new instance of the prototype-scoped bean repeatedly at runtime. You cannot dependency-inject a prototype-scoped bean into your singleton bean, because that injection occurs only once, when the Spring container instantiates the singleton bean and resolves and injects its dependencies. If you need a new instance of a prototype bean at runtime more than once, see [Method Injection](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-method-injection).

**当您将单例范围的 bean 与原型 bean 的依赖项一起使用时，请注意，==依赖项是在实例化时解析的==。因此，如果依赖项将原型范围的 bean 注入到单例范围的 bean 中，那么将实例化一个新的原型 bean，然后将依赖项注入到单例 bean 中。原型实例是唯一一个提供给单例作用域 bean 的实例。**

但是，假设您希望单例作用域 bean 在运行时重复获取原型作用域 bean 的新实例。您不能将依赖项原型范围的 bean 注入到您的单例 bean 中，因为当 Spring 容器实例化单例 bean 并解析和注入其依赖项时，注入只发生一次。如果您在运行时多次需要原型 bean 的新实例，请参阅[方法注入](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-method-injection)。

#### 1.5.4. Request, Session, Application, and WebSocket Scopes

#### 1.5.4 Request,Session,Application 和 WebSocket 作用域

The `request`, `session`, `application`, and `websocket` scopes are available only if you use a web-aware Spring `ApplicationContext` implementation (such as `XmlWebApplicationContext`). If you use these scopes with regular Spring IoC containers, such as the `ClassPathXmlApplicationContext`, an `IllegalStateException` that complains about an unknown bean scope is thrown.

`request`,`session`,`application` 和 `webSocket` 作用域只有在使用支持 web 的 Spring  `ApplicationContext` 实现（例如 `XmlWebApplicationContext`）时才可用。**如果将这些作用域与常规 Spring IoC 容器（如 `ClassPathXmlApplicationContext`）一起使用，则会抛出一个 `IllegalStateException`**，该异常抱怨未知的 bean 作用域。

==问题：几个之间的区别==

##### Initial Web Configuration

##### 初始化 web 配置

To support the scoping of beans at the `request`, `session`, `application`, and `websocket` levels (web-scoped beans), some minor initial configuration is required before you define your beans. (This initial setup is not required for the standard scopes: `singleton` and `prototype`.)

How you accomplish this initial setup depends on your particular Servlet environment.

If you access scoped beans within Spring Web MVC, in effect, within a request that is processed by the Spring `DispatcherServlet`, no special setup is necessary. `DispatcherServlet` already exposes all relevant state.

If you use a Servlet 2.5 web container, with requests processed outside of Spring’s `DispatcherServlet` (for example, when using JSF or Struts), you need to register the `org.springframework.web.context.request.RequestContextListener` `ServletRequestListener`. For Servlet 3.0+, this can be done programmatically by using the `WebApplicationInitializer` interface. Alternatively, or for older containers, add the following declaration to your web application’s `web.xml` file:

为了支持在 `request`、`session`、`application` 和 `websocket` 级别（web 范围的 bean）对 bean 进行范围界定，在定义 bean 之前需要进行一些较小的初始配置。（标准作用域 `singleton` 和 `prototype` 不需要此初始设置。）

如何完成初始设置取决于特定的 Servlet 环境。

**如果您在 Spring Web MVC 中访问作用域 bean，实际上是在由 Spring `DispatcherServlet` 处理的请求中，则无需特殊设置`DispatcherServlet` 已公开所有相关状态。**

如果使用 Servlet 2.5 Web 容器，并且请求在 Spring 的 `DispatcherServlet` 之外处理（例如，在使用 JSF 或 Struts 时），则需要注册 `org.springframework.web.context.request.RequestContextListener/ServletRequestListener`。对于 Servlet 3.0+，这可以通过使用 `WebApplicationInitializer` 接口以编程方式完成。或者，对于较旧的容器，将以下声明添加到 web 应用程序的 `web.xml` 文件：

```xml
<web-app>
    ...
    <listener>
        <listener-class>
            org.springframework.web.context.request.RequestContextListener
        </listener-class>
    </listener>
    ...
</web-app>
```

Alternatively, if there are issues with your listener setup, consider using Spring’s `RequestContextFilter`. The filter mapping depends on the surrounding web application configuration, so you have to change it as appropriate. The following listing shows the filter part of a web application:

或者，如果您的 listener 设置存在问题，请考虑使用 Spring 的 `RequestContextFilter`。过滤器映射取决于周围的 web 应用程序配置，因此必须根据需要进行更改。以下列表显示了 web 应用程序的筛选器部分：

```xml
<web-app>
    ...
    <filter>
        <filter-name>requestContextFilter</filter-name>
        <filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>requestContextFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
    ...
</web-app>
```

`DispatcherServlet`, `RequestContextListener`, and `RequestContextFilter` all do exactly the same thing, namely bind the HTTP request object to the `Thread` that is servicing that request. This makes beans that are request- and session-scoped available further down the call chain.

**`DispatcherServlet`、`RequestContextListener` 和 `RequestContextFilter` 都执行完全相同的操作，即将 HTTP 请求对象绑定到为该请求提供服务的 `Thread`。这使得请求和会话作用域的 bean 在调用链的更下游可用。**

##### Request scope

##### Request 作用域

Consider the following XML configuration for a bean definition:

为 bean 定义考虑以下 XML 配置：

```xml
<bean id="loginAction" class="com.something.LoginAction" scope="request"/>
```

The Spring container creates a new instance of the `LoginAction` bean by using the `loginAction` bean definition for each and every HTTP request. That is, the `loginAction` bean is scoped at the HTTP request level. You can change the internal state of the instance that is created as much as you want, because other instances created from the same `loginAction` bean definition do not see these changes in state. They are particular to an individual request. When the request completes processing, the bean that is scoped to the request is discarded.

When using annotation-driven components or Java configuration, the `@RequestScope` annotation can be used to assign a component to the `request` scope. The following example shows how to do so:

Spring 容器通过为每个 HTTP 请求使用 `LoginAction` bean 定义来创建 `LoginAction` bean 的新实例。也就是说，`loginAction` bean 的作用域是 HTTP 请求级别。您可以随意更改创建的实例的内部状态，因为从同一 `loginAction` bean 定义创建的其他实例在状态中看不到这些更改。它们是特定于个人请求的。当请求完成处理时，作用域为请求的 bean 将被丢弃。

使用注解驱动的组件或 Java 配置时，`@RequestScope` 注解可用于将组件分配给 `request` 范围。以下示例显示了如何执行此操作：

```java
@RequestScope
@Component
public class LoginAction {
    // ...
}
```

##### Session Scope

##### Session 作用域

Consider the following XML configuration for a bean definition:

为 bean 定义考虑以下 XML 配置：

```xml
<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>
```

The Spring container creates a new instance of the `UserPreferences` bean by using the `userPreferences` bean definition for the lifetime of a single HTTP `Session`. In other words, the `userPreferences` bean is effectively scoped at the HTTP `Session` level. As with request-scoped beans, you can change the internal state of the instance that is created as much as you want, knowing that other HTTP `Session` instances that are also using instances created from the same `userPreferences` bean definition do not see these changes in state, because they are particular to an individual HTTP `Session`. When the HTTP `Session` is eventually discarded, the bean that is scoped to that particular HTTP `Session` is also discarded.

When using annotation-driven components or Java configuration, you can use the `@SessionScope` annotation to assign a component to the `session` scope.

Spring 容器通过在单个 HTTP `Session` 的生存期内使用 `UserPreferences` bean 定义来创建 `UserPreferences` bean 的新实例。换句话说，`userPreferences` bean 有效地限定了 HTTP `Session` 级别的作用域。与 request 范围的 bean 一样，您可以随意更改创建的实例的内部状态，因为您知道其他 HTTP `Session` 实例也使用从同一 `userPreferences` bean 定义创建的实例，它们在状态中看不到这些更改，因为它们是特定于单个 HTTP `Session` 的。当 HTTP `Session` 最终被丢弃时，作用于该特定 HTTP `Session` 的 bean 也被丢弃。

使用注解驱动的组件或 Java 配置时，可以使用 `@SessionScope` 注解将组件分配给 `session` 范围。

```java
@SessionScope
@Component
public class UserPreferences {
    // ...
}
```

##### Application Scope

##### Application 作用域

Consider the following XML configuration for a bean definition:

为 bean 定义考虑以下 XML 配置：

```xml
<bean id="appPreferences" class="com.something.AppPreferences" scope="application"/>
```

The Spring container creates a new instance of the `AppPreferences` bean by using the `appPreferences` bean definition once for the entire web application. That is, the `appPreferences` bean is scoped at the `ServletContext` level and stored as a regular `ServletContext` attribute. This is somewhat similar to a Spring singleton bean but differs in two important ways: It is a singleton per `ServletContext`, not per Spring `ApplicationContext` (for which there may be several in any given web application), and it is actually exposed and therefore visible as a `ServletContext` attribute.

When using annotation-driven components or Java configuration, you can use the `@ApplicationScope` annotation to assign a component to the `application` scope. The following example shows how to do so:

Spring 容器通过为整个 web 应用程序使用一次 `AppPreferences` bean 定义来创建 `AppPreferences` bean 的新实例。也就是说，**`appPreferences` bean 的作用域为 `ServletContext` 级别，并存储为常规的 `ServletContext` 属性。这有点类似于 Spring 单例 bean，但在两个重要方面有所不同：它是每个 `ServletContext` 的单例 bean，而不是每个 Spring `ApplicationContext`（在任何给定的 web 应用程序中可能有多个），它实际上是公开的，因此作为 `ServletContext` 属性可见**。

使用注解驱动的组件或 Java 配置时，可以使用 `@ApplicationScope` 注解将组件分配给 `application` 范围。以下示例显示了如何执行此操作：

```java
@ApplicationScope
@Component
public class AppPreferences {
    // ...
}
```

##### Scoped Beans as Dependencies

##### 作用域 bean 作为依赖项

The Spring IoC container manages not only the instantiation of your objects (beans), but also the wiring up of collaborators (or dependencies). If you want to inject (for example) an HTTP request-scoped bean into another bean of a longer-lived scope, you may choose to inject an AOP proxy in place of the scoped bean. That is, you need to inject a proxy object that exposes the same public interface as the scoped object but that can also retrieve the real target object from the relevant scope (such as an HTTP request) and delegate method calls onto the real object.

Spring IOC 容器不仅管理对象（bean）的实例化，还管理协作者（或依赖项）的连接。如果您想要（例如）将 HTTP 请求范围的 bean 注入到另一个更长周期范围的 bean 中，您可以选择注入 AOP 代理来代替作用域 bean。也就是说，您需要注入一个代理对象，该代理对象公开与作用域对象相同的公共接口，但也可以从相关作用域（如 HTTP 请求）检索真实目标对象，并将方法调用委托给真实对象。

> You may also use `<aop:scoped-proxy/>` between beans that are scoped as `singleton`, with the reference then going through an intermediate proxy that is serializable and therefore able to re-obtain the target singleton bean on deserialization.When declaring `<aop:scoped-proxy/>` against a bean of scope `prototype`, every method call on the shared proxy leads to the creation of a new target instance to which the call is then being forwarded.Also, scoped proxies are not the only way to access beans from shorter scopes in a lifecycle-safe fashion. You may also declare your injection point (that is, the constructor or setter argument or autowired field) as `ObjectFactory<MyTargetBean>`, allowing for a `getObject()` call to retrieve the current instance on demand every time it is needed — without holding on to the instance or storing it separately.As an extended variant, you may declare `ObjectProvider<MyTargetBean>` which delivers several additional access variants, including `getIfAvailable` and `getIfUnique`.The JSR-330 variant of this is called `Provider` and is used with a `Provider<MyTargetBean>` declaration and a corresponding `get()` call for every retrieval attempt. See [here](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-standard-annotations) for more details on JSR-330 overall.
>
> 您还可以在作用域为 `singleton` 的 bean 之间使用`<aop:scoped-proxy/>`，然后引用将通过可序列化的中间代理，从而能够在反序列化时重新获取目标 singleton bean。当针对作用域 `prototype` 的 bean 声明 `<aop:scoped-proxy/>` 时，对共享代理的每个方法调用都会导致创建一个新的目标实例，然后将调用转发到该实例。此外，作用域代理并不是以生命周期安全的方式从较短作用域访问 bean 的唯一方法。您还可以将注入点（即构造函数或setter参数或 autowired 字段）声明为`ObjectFactory<MyTargetBean>`，从而允许每次需要时通过`getObject()`调用按需检索当前实例 — 无需保留实例或单独存储它。作为扩展变量，您可以声明 `ObjectProvider<MyTargetBean>`，它提供了几个额外的访问变量，包括 `getIfAvailable` 和 `getIfUnique`。它的 JSR-330 变体称为 `Provider`，并与 `Provider<MyTargetBean>` 声明以及每次检索尝试的相应 `get()` 调用一起使用。有关 JSR-330 的更多详细信息，请参见[此处](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-standard-annotations)。

The configuration in the following example is only one line, but it is important to understand the “why” as well as the “how” behind it:

以下示例中的配置仅为一行，但了解其背后的「为什么」和「如何」很重要：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- an HTTP Session-scoped bean exposed as a proxy -->
    <bean id="userPreferences" class="com.something.UserPreferences" scope="session">
        <!-- instructs the container to proxy the surrounding bean -->
        <aop:scoped-proxy/>   <!--注释一-->
    </bean>

    <!-- a singleton-scoped bean injected with a proxy to the above bean -->
    <bean id="userService" class="com.something.SimpleUserService">
        <!-- a reference to the proxied userPreferences bean -->
        <property name="userPreferences" ref="userPreferences"/>
    </bean>
</beans>
```

注释一：The line that defines the proxy.定义代理的行。

To create such a proxy, you insert a child `<aop:scoped-proxy/>` element into a scoped bean definition (see [Choosing the Type of Proxy to Create](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection-proxies) and [XML Schema-based configuration](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#xsd-schemas)). Why do definitions of beans scoped at the `request`, `session` and custom-scope levels require the `<aop:scoped-proxy/>` element? Consider the following singleton bean definition and contrast it with what you need to define for the aforementioned scopes (note that the following `userPreferences` bean definition as it stands is incomplete):

要创建这样一个代理，您需要将子 `<aop:scoped-proxy/>` 元素插入到作用域 bean 定义中（请参见[选择要创建的代理类型](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection-proxies) 和[基于XML模式的配置](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#xsd-schemas)）。为什么在 `request`、`session` 和自定义作用域级别定义作用域的 bean 需要`<aop:scoped-proxy/>`元素？考虑下面的单点 bean 定义并将其与前面所定义的范围进行比较（注意，下面的 `userPreperences` bean定义是不完整的）：

```xml
<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>

<bean id="userManager" class="com.something.UserManager">
    <property name="userPreferences" ref="userPreferences"/>
</bean>
```

In the preceding example, the singleton bean (`userManager`) is injected with a reference to the HTTP `Session`-scoped bean (`userPreferences`). The salient point here is that the `userManager` bean is a singleton: it is instantiated exactly once per container, and its dependencies (in this case only one, the `userPreferences` bean) are also injected only once. This means that the `userManager` bean operates only on the exact same `userPreferences` object (that is, the one with which it was originally injected).

This is not the behavior you want when injecting a shorter-lived scoped bean into a longer-lived scoped bean (for example, injecting an HTTP `Session`-scoped collaborating bean as a dependency into singleton bean). Rather, you need a single `userManager` object, and, for the lifetime of an HTTP `Session`, you need a `userPreferences` object that is specific to the HTTP `Session`. Thus, the container creates an object that exposes the exact same public interface as the `UserPreferences` class (ideally an object that is a `UserPreferences` instance), which can fetch the real `UserPreferences` object from the scoping mechanism (HTTP request, `Session`, and so forth). The container injects this proxy object into the `userManager` bean, which is unaware that this `UserPreferences` reference is a proxy. In this example, when a `UserManager` instance invokes a method on the dependency-injected `UserPreferences` object, it is actually invoking a method on the proxy. The proxy then fetches the real `UserPreferences` object from (in this case) the HTTP `Session` and delegates the method invocation onto the retrieved real `UserPreferences` object.

Thus, you need the following (correct and complete) configuration when injecting `request-` and `session-scoped` beans into collaborating objects, as the following example shows:

在前面的示例中，单例 bean（`userManager`）以引用的方式被注入了对HTTP`Session`-作用域 bean（`userPreferences`）。这里最突出的一点是，`userManager` bean是一个单例：每个容器只实例化一次，它的依赖项（在本例中只有一个，`userPreferences` bean）也只注入一次。这意味着 `userManager` bean 只对完全相同的 `userPreferences` 对象（即最初注入它的对象）进行操作。

这不是您在将一个生存周期较短的作用域 bean 注入一个生存周期较长的作用域 bean 时想要的行为（例如，将一个HTTP`Session`-作用域的协作 bean 作为依赖项注入到单例 bean 中）。相反，您需要一个`userManager` 对象，并且在 HTTP `Session`的生存期内，您需要一个特定于 HTTP `Session` 的 `userPreferences` 对象。因此，容器创建了一个对象，该对象公开了与 `UserPreferences` 类完全相同的公共接口（理想情况下是一个 `UserPreferences` 实例的对象），该对象可以从作用域机制（HTTP 请求、`Session` 等）获取真正的`UserPreferences` 对象。容器将此代理对象注入到 `userManager` bean 中，该 bean 不知道此 `UserPreferences`  引用是代理。在本例中，`UserManager`实例调用依赖注入的`UserPreferences` 对象上的方法时，实际上是在调用代理上的方法。然后，代理从HTTP`Session`获取真实的`UserPreferences`对象（在本例中为该对象），并将方法调用委托给检索到的真实`UserPreferences`对象。

**因此，在将`request-`和 `session scoped`  bean 注入协作对象时，需要以下（正确且完整的）配置，如下例所示：**

```xml
<bean id="userPreferences" class="com.something.UserPreferences" scope="session">
    <aop:scoped-proxy/>
</bean>

<bean id="userManager" class="com.something.UserManager">
    <property name="userPreferences" ref="userPreferences"/>
</bean>
```

###### Choosing the Type of Proxy to Create

###### 选择要创建的代理的类型

By default, when the Spring container creates a proxy for a bean that is marked up with the `<aop:scoped-proxy/>` element, a CGLIB-based class proxy is created.

默认情况下，当 Spring 容器为标记有 `<aop:scoped-proxy/>` 元素的 bean 创建代理时，将创建基于 CGLIB 的类代理。

> CGLIB proxies intercept only public method calls! Do not call non-public methods on such a proxy. They are not delegated to the actual scoped target object.
>
> CGLIB 代理只截获公共方法调用！不要在这样的代理上调用非公共方法。它们不会委托给实际的作用域目标对象。

Alternatively, you can configure the Spring container to create standard JDK interface-based proxies for such scoped beans, by specifying `false` for the value of the `proxy-target-class` attribute of the `<aop:scoped-proxy/>` element. Using JDK interface-based proxies means that you do not need additional libraries in your application classpath to affect such proxying. However, it also means that the class of the scoped bean must implement at least one interface and that all collaborators into which the scoped bean is injected must reference the bean through one of its interfaces. The following example shows a proxy based on an interface:

或者，您可以配置Spring 容器，通过为`<aop:scoped-proxy/>`元素的 `proxy-target-class` 属性的值指定 `false`，为此类作用域 bean 创建基于 JDK 接口的标准代理。使用基于 JDK 接口的代理意味着您不需要在应用程序类路径中使用额外的库来影响这种代理。然而，这也意味着**作用域 bean 的类必须实现至少一个接口，并且所有注入作用域 bean 的协作者必须通过其接口之一引用 bean。**以下示例显示了基于接口的代理：

```xml
<!-- DefaultUserPreferences implements the UserPreferences interface -->
<bean id="userPreferences" class="com.stuff.DefaultUserPreferences" scope="session">
    <aop:scoped-proxy proxy-target-class="false"/>
</bean>

<bean id="userManager" class="com.stuff.UserManager">
    <property name="userPreferences" ref="userPreferences"/>
</bean>
```

For more detailed information about choosing class-based or interface-based proxying, see [Proxying Mechanisms](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-proxying).

有关选择基于类或基于接口的代理的更多详细信息，请参阅[代理机制](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-proxying)。

#### 1.5.5. Custom Scopes

The bean scoping mechanism is extensible. You can define your own scopes or even redefine existing scopes, although the latter is considered bad practice and you cannot override the built-in `singleton` and `prototype` scopes.

bean 作用域机制是可扩展的。您可以定义自己的作用域，甚至可以重新定义现有的作用域，尽管后者被认为是不好的做法，并且您不能覆盖内置的 `singleton` 和 `prototype` 作用域。

##### Creating a Custom Scope

##### 创建自定义作用域

To integrate your custom scopes into the Spring container, you need to implement the `org.springframework.beans.factory.config.Scope` interface, which is described in this section. For an idea of how to implement your own scopes, see the `Scope` implementations that are supplied with the Spring Framework itself and the [`Scope`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/config/Scope.html) javadoc, which explains the methods you need to implement in more detail.

The `Scope` interface has four methods to get objects from the scope, remove them from the scope, and let them be destroyed.

The session scope implementation, for example, returns the session-scoped bean (if it does not exist, the method returns a new instance of the bean, after having bound it to the session for future reference). The following method returns the object from the underlying scope:

要将自定义作用域集成到 Spring 容器中，您需要实现`org.springframework.beans.factory.config.Scope` 接口，本节将对此进行描述。要了解如何实现自己的作用域，请参阅 Spring 框架本身提供的 `Scope` 实现和[Scope](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/config/Scope.html)的 javadoc，其中更详细地解释了需要实现的方法。

`Scope` 接口有四种方法可用于从作用域中获取对象、从作用域中删除对象以及销毁对象。

例如，会话作用域实现返回会话作用域 bean（如果它不存在，则在将 bean 绑定到会话以供将来引用后，该方法返回 bean 的新实例）。以下方法从基础作用域返回对象：

```java
Object get(String name, ObjectFactory<?> objectFactory)
```

The session scope implementation, for example, removes the session-scoped bean from the underlying session. The object should be returned, but you can return `null` if the object with the specified name is not found. The following method removes the object from the underlying scope:

例如，会话作用域实现从底层会话中删除会话作用域 bean。应该返回该对象，但如果找不到具有指定名称的对象，则可以返回`null`。以下方法从基础作用域中删除对象：

```java
Object remove(String name)
```

The following method registers a callback that the scope should invoke when it is destroyed or when the specified object in the scope is destroyed:

以下方法注册一个回调，当作用域被销毁或作用域中的指定对象被销毁时，该回调应被调用：

```java
void registerDestructionCallback(String name, Runnable destructionCallback)
```

See the [javadoc](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/config/Scope.html#registerDestructionCallback) or a Spring scope implementation for more information on destruction callbacks.

The following method obtains the conversation identifier for the underlying scope:

参见[javadoc](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/config/Scope.html#registerDestructionCallback)或 Spring 作用域实现，以获取有关销毁回调的更多信息。

以下方法获取基础作用域的对话标识符：

```java
String getConversationId()
```

This identifier is different for each scope. For a session scoped implementation, this identifier can be the session identifier.

此标识符对于每个作用域都是不同的。对于会话范围的实现，此标识符可以是会话标识符。

##### Using a Custom Scope

##### 使用自定义作用域

After you write and test one or more custom `Scope` implementations, you need to make the Spring container aware of your new scopes. The following method is the central method to register a new `Scope` with the Spring container:

在编写和测试一个或多个自定义 `Scope` 实现之后，您需要让 Spring 容器知道您的新作用域。以下方法是向 Spring 容器注册新 `Scope` 的中心方法：

```java
void registerScope(String scopeName, Scope scope);
```

This method is declared on the `ConfigurableBeanFactory` interface, which is available through the `BeanFactory` property on most of the concrete `ApplicationContext` implementations that ship with Spring.

The first argument to the `registerScope(..)` method is the unique name associated with a scope. Examples of such names in the Spring container itself are `singleton` and `prototype`. The second argument to the `registerScope(..)` method is an actual instance of the custom `Scope` implementation that you wish to register and use.

Suppose that you write your custom `Scope` implementation, and then register it as shown in the next example.

此方法在`ConfigurableBeanFactory`接口上声明，该接口可通过 Spring 附带的大多数具体`ApplicationContext`实现的`BeanFactory`属性获得。

`registerScope(..)` 的第一个参数方法是与作用域关联的唯一名称。Spring 容器本身中此类名称的示例有 `singleton` 和 `prototype`。`registerScope(...)` 的第二个参数方法是要注册和使用的自定义 `Scope` 实现的实际实例。

假设您编写自定义的 `Scope` 实现，然后注册它，如下一个示例所示。

> The next example uses `SimpleThreadScope`, which is included with Spring but is not registered by default. The instructions would be the same for your own custom `Scope` implementations.
>
> 下一个示例使用 `SimpleThreadScope`，它包含在 Spring 中，但默认情况下未注册。对于您自己的自定义 `Scope` 实现，说明将是相同的。

```java
Scope threadScope = new SimpleThreadScope();
beanFactory.registerScope("thread", threadScope);
```

You can then create bean definitions that adhere to the scoping rules of your custom `Scope`, as follows:

然后，您可以创建符合自定义 `Scope` 的作用域规则的 bean 定义，如下所示：

```xml
<bean id="..." class="..." scope="thread">
```

With a custom `Scope` implementation, you are not limited to programmatic registration of the scope. You can also do the `Scope` registration declaratively, by using the `CustomScopeConfigurer` class, as the following example shows:

使用自定义的 `Scope` 实现，您不仅限于对作用域进行编程注册。您还可以使用 `CustomScopeConfigurer` 类声明性地进行 `Scope` 注册，如下例所示：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">
        <property name="scopes">
            <map>
                <entry key="thread">
                    <bean class="org.springframework.context.support.SimpleThreadScope"/>
                </entry>
            </map>
        </property>
    </bean>

    <bean id="thing2" class="x.y.Thing2" scope="thread">
        <property name="name" value="Rick"/>
        <aop:scoped-proxy/>
    </bean>

    <bean id="thing1" class="x.y.Thing1">
        <property name="thing2" ref="thing2"/>
    </bean>

</beans>
```

> When you place `<aop:scoped-proxy/>` within a `<bean>` declaration for a `FactoryBean` implementation, it is the factory bean itself that is scoped, not the object returned from `getObject()`.
>
> 当您将`<aop:scoped-proxy/>` 放在`FactoryBean`实现的`<bean>`声明中时，作用域是工厂 bean 本身，而不是从`getObject()`返回的对象。

### 1.6. Customizing the Nature of a Bean

### 1.6. 自定义 Bean 的性质

The Spring Framework provides a number of interfaces you can use to customize the nature of a bean. This section groups them as follows:

- [Lifecycle Callbacks](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle)
- [`ApplicationContextAware` and `BeanNameAware`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware)
- [Other `Aware` Interfaces](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aware-list)

Spring 框架提供了许多接口，您可以使用这些接口来定制 bean 的性质。本节将其分组如下：

- [生命周期回调](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle)
- [`ApplicationContextAware`和`BeanNameWare`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware)
- [其他`Aware` 接口](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aware-list)

#### 1.6.1. Lifecycle Callbacks

#### 1.6.1.生命周期回调

To interact with the container’s management of the bean lifecycle, you can implement the Spring `InitializingBean` and `DisposableBean` interfaces. The container calls `afterPropertiesSet()` for the former and `destroy()` for the latter to let the bean perform certain actions upon initialization and destruction of your beans.

为了与容器对 bean 生命周期的管理进行交互，可以实现 Spring `Initializebean` 和 `DisposableBean` 接口。容器对前者调用 `AfterPropertieSet()`，对后者调用 `destroy()`，以便 bean 在初始化和销毁 bean 时执行某些操作。

> The JSR-250 `@PostConstruct` and `@PreDestroy` annotations are generally considered best practice for receiving lifecycle callbacks in a modern Spring application. Using these annotations means that your beans are not coupled to Spring-specific interfaces. For details, see [Using `@PostConstruct` and `@PreDestroy`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations).If you do not want to use the JSR-250 annotations but you still want to remove coupling, consider `init-method` and `destroy-method` bean definition metadata.
>
> JSR-250 `@PostConstruct` 和 `@PreDestroy` 注解通常被认为是在现代 Spring 应用程序中接收生命周期回调的最佳实践。使用这些注解意味着您的 bean 没有耦合到特定于 Spring 的接口。有关详细信息，请参见[使用`@PostConstruct`和 `@PreDestroy`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations)。如果您不想使用 JSR-250 注解，但仍希望删除耦合，请考虑 `init-method` 和 `destory-method` bean 定义元数据。

Internally, the Spring Framework uses `BeanPostProcessor` implementations to process any callback interfaces it can find and call the appropriate methods. If you need custom features or other lifecycle behavior Spring does not by default offer, you can implement a `BeanPostProcessor` yourself. For more information, see [Container Extension Points](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension).

In addition to the initialization and destruction callbacks, Spring-managed objects may also implement the `Lifecycle` interface so that those objects can participate in the startup and shutdown process, as driven by the container’s own lifecycle.

The lifecycle callback interfaces are described in this section.

在内部，Spring 框架使用 `BeanPostProcessor`实现来处理它可以找到的任何回调接口，并调用适当的方法。如果您需要定制功能或 Spring 默认不提供的其他生命周期行为，您可以自己实现一个`BeanPostProcessor`。有关详细信息，请参见[容器扩展点](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension)。

除了初始化和销毁回调之外，Spring 托管对象还可以实现 `Lifecycle` 接口，以便这些对象可以参与启动和关闭过程，这是由容器自身的生命周期驱动的。

本节介绍了生命周期回调接口。

##### Initialization Callbacks

The `org.springframework.beans.factory.InitializingBean` interface lets a bean perform initialization work after the container has set all necessary properties on the bean. The `InitializingBean` interface specifies a single method:

`org.springframework.beans.factory.InitializingBean` 接口允许 bean 在容器对 bean 设置了所有必要的属性之后执行初始化工作。`InitializingBean` 接口指定一个方法：

```java
void afterPropertiesSet() throws Exception;
```

We recommend that you do not use the `InitializingBean` interface, because it unnecessarily couples the code to Spring. Alternatively, we suggest using the [`@PostConstruct`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations) annotation or specifying a POJO initialization method. In the case of XML-based configuration metadata, you can use the `init-method` attribute to specify the name of the method that has a void no-argument signature. With Java configuration, you can use the `initMethod` attribute of `@Bean`. See [Receiving Lifecycle Callbacks](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-lifecycle-callbacks). Consider the following example:

**我们建议您不要使用 `InitializingBean` 接口，因为它不必要地将代码耦合到 Spring。或者，我们建议使用[`@PostConstruct`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations)注解或指定 POJO 初始化方法**。对于基于 XML 的配置元数据，可以使用 `init-method` 属性指定具有无效无参数签名的方法的名称。通过 Java 配置，您可以使用 `@Bean` 的 `initMethod` 属性。请参阅[接收生命周期回调](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-lifecycle-callbacks)。考虑下面的例子：

```xml
<bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/>
```

```java
public class ExampleBean {

    public void init() {
        // do some initialization work
    }
}
```

The preceding example has almost exactly the same effect as the following example (which consists of two listings):

前面的示例与下面的示例（由两个列表组成）具有几乎完全相同的效果：

```xml
<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
```

```java
public class AnotherExampleBean implements InitializingBean {

    @Override
    public void afterPropertiesSet() {
        // do some initialization work
    }
}
```

However, the first of the two preceding examples does not couple the code to Spring.

然而，前面两个示例中的第一个并没有将代码耦合到 Spring。

##### Destruction Callbacks

##### 销毁回调

Implementing the `org.springframework.beans.factory.DisposableBean` interface lets a bean get a callback when the container that contains it is destroyed. The `DisposableBean` interface specifies a single method:

实现 `org.springframework.beans.factory.DisposableBean` 接口可以让 bean 在包含它的容器被销毁时获得回调。`DisposableBean` 接口指定一个方法：

```java
void destroy() throws Exception;
```

We recommend that you do not use the `DisposableBean` callback interface, because it unnecessarily couples the code to Spring. Alternatively, we suggest using the [`@PreDestroy`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations) annotation or specifying a generic method that is supported by bean definitions. With XML-based configuration metadata, you can use the `destroy-method` attribute on the `<bean/>`. With Java configuration, you can use the `destroyMethod` attribute of `@Bean`. See [Receiving Lifecycle Callbacks](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-lifecycle-callbacks). Consider the following definition:

我们建议您不要使用 `DisposableBean` 回调接口，因为它不必要地将代码耦合到 Spring。或者，我们建议使用[`@PreDestroy`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations)  注解或指定 bean 定义支持的通用方法。使用基于XML的配置元数据，您可以在`<bean/>`上使用` destroy-method`属性。通过 Java 配置，您可以使用 `@Bean` 的 `destroyMethod` 属性。请参阅[接收生命周期回调](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-lifecycle-callbacks)。考虑下面的定义：

```xml
<bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/>
```

```java
public class ExampleBean {

    public void cleanup() {
        // do some destruction work (like releasing pooled connections)
    }
}
```

The preceding definition has almost exactly the same effect as the following definition:

上述定义与以下定义具有几乎完全相同的效果：

```xml
<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
```

```java
public class AnotherExampleBean implements DisposableBean {

    @Override
    public void destroy() {
        // do some destruction work (like releasing pooled connections)
    }
}
```

However, the first of the two preceding definitions does not couple the code to Spring.

但是，前面两个定义中的第一个并没有将代码耦合到 Spring。

> You can assign the `destroy-method` attribute of a `<bean>` element a special `(inferred)` value, which instructs Spring to automatically detect a public `close` or `shutdown` method on the specific bean class. (Any class that implements `java.lang.AutoCloseable` or `java.io.Closeable` would therefore match.) You can also set this special `(inferred)` value on the `default-destroy-method` attribute of a `<beans>` element to apply this behavior to an entire set of beans (see [Default Initialization and Destroy Methods](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-default-init-destroy-methods)). Note that this is the default behavior with Java configuration.
>
> 您可以为`<bean>`元素的 `destroy-method` 属性指定一个特殊的`（推断）`值，该值指示 Spring 自动检测特定 bean 类上的公共 `close` 或 `shutdown` 方法。（因此，实现 `java.lang.AutoCloseable` 或 `java.io.Closeable` 的任何类都将匹配。）您还可以在 `<beans>` 元素的 `default-destroy-method` 属性上设置这个特殊的`（推断的）`值，以将此行为应用于整个 bean 集（请参见[默认初始化和销毁方法](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-default-init-destroy-methods)）。请注意，这是 Java 配置的默认行为。

##### Default Initialization and Destroy Methods

##### 默认初始化和销毁方法

When you write initialization and destroy method callbacks that do not use the Spring-specific `InitializingBean` and `DisposableBean` callback interfaces, you typically write methods with names such as `init()`, `initialize()`, `dispose()`, and so on. Ideally, the names of such lifecycle callback methods are standardized across a project so that all developers use the same method names and ensure consistency.

You can configure the Spring container to “look” for named initialization and destroy callback method names on every bean. This means that you, as an application developer, can write your application classes and use an initialization callback called `init()`, without having to configure an `init-method="init"` attribute with each bean definition. The Spring IoC container calls that method when the bean is created (and in accordance with the standard lifecycle callback contract [described previously](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle)). This feature also enforces a consistent naming convention for initialization and destroy method callbacks.

Suppose that your initialization callback methods are named `init()` and your destroy callback methods are named `destroy()`. Your class then resembles the class in the following example:

当您编写不使用 Spring 特定的 `InitializingBean` 和 `DisposableBean` 回调接口的初始化和销毁方法回调时，您通常使用`init()`、`initialize()`、`dispose()` 等名称编写方法。理想情况下，这样的生命周期回调方法的名称在整个项目中是标准化的，以便所有开发人员使用相同的方法名称并确保一致性。

您可以将 Spring 容器配置为“查找”命名初始化，并销毁每个 bean 上的回调方法名称。这意味着，作为应用程序开发人员，您可以编写应用程序类并使用名为 `init()` 的初始化回调，而无需为每个 bean 定义配置 `init-method="init"` 属性。Spring IOC 容器在创建 bean 时调用该方法（并且根据[前面描述的](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle) 标准生命周期回调契约）。此功能还强制执行初始化和销毁方法回调的一致命名约定。

假设您的初始化回调方法名为 `init()` 并且销毁回调方法名为 `destroy()`。然后，您的类与以下示例中的类相似：

```java
public class DefaultBlogService implements BlogService {

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) {
        this.blogDao = blogDao;
    }

    // this is (unsurprisingly) the initialization callback method
    public void init() {
        if (this.blogDao == null) {
            throw new IllegalStateException("The [blogDao] property must be set.");
        }
    }
}
```

You could then use that class in a bean resembling the following:

然后，您可以在类似以下内容的 bean 中使用该类：

```xml
<beans default-init-method="init">

    <bean id="blogService" class="com.something.DefaultBlogService">
        <property name="blogDao" ref="blogDao" />
    </bean>

</beans>
```

The presence of the `default-init-method` attribute on the top-level `<beans/>` element attribute causes the Spring IoC container to recognize a method called `init` on the bean class as the initialization method callback. When a bean is created and assembled, if the bean class has such a method, it is invoked at the appropriate time.

You can configure destroy method callbacks similarly (in XML, that is) by using the `default-destroy-method` attribute on the top-level `<beans/>` element.

Where existing bean classes already have callback methods that are named at variance with the convention, you can override the default by specifying (in XML, that is) the method name by using the `init-method` and `destroy-method` attributes of the `<bean/>` itself.

The Spring container guarantees that a configured initialization callback is called immediately after a bean is supplied with all dependencies. Thus, the initialization callback is called on the raw bean reference, which means that AOP interceptors and so forth are not yet applied to the bean. A target bean is fully created first and then an AOP proxy (for example) with its interceptor chain is applied. If the target bean and the proxy are defined separately, your code can even interact with the raw target bean, bypassing the proxy. Hence, it would be inconsistent to apply the interceptors to the `init` method, because doing so would couple the lifecycle of the target bean to its proxy or interceptors and leave strange semantics when your code interacts directly with the raw target bean.

顶级`<beans/>`元素属性上存在 `default-init-method` 属性会导致 Spring IoC 容器将 bean 类上名为 `init` 的方法识别为初始化方法回调。当创建和组装 bean 时，如果 bean 类有这样一个方法，则会在适当的时间调用它。

您可以通过在顶级 `<beans/>` 元素上使用 `default-destroy-method` 属性，以类似的方式配置 destroy 方法回调（即 XML）。

如果现有的 bean 类已经有了命名与约定不同的回调方法，那么可以通过使用 `<bean/>` 本身的 `init-method` 和 `destroy-method` 属性指定（在 XML 中，即）方法名来覆盖默认方法。

**Spring 容器保证在为 bean 提供所有依赖项后立即调用配置的初始化回调**。因此，对原始 bean 引用调用初始化回调，这意味着 AOP 拦截器等尚未应用于 bean。首先完全创建一个目标 bean，然后应用一个 AOP 代理（例如）及其拦截器链。如果目标 bean 和代理是单独定义的，那么代码甚至可以绕过代理与原始目标 bean 交互。因此，将拦截器应用于 `init` 方法是不一致的，因为这样做会将目标 bean 的生命周期与其代理拦截器耦合起来，并在代码直接与原始目标 bean 交互时留下奇怪的语义。

##### Combining Lifecycle Mechanisms

##### 组合生命周期机制

As of Spring 2.5, you have three options for controlling bean lifecycle behavior:

- The [`InitializingBean`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean) and [`DisposableBean`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-disposablebean) callback interfaces
- Custom `init()` and `destroy()` methods
- The [`@PostConstruct` and `@PreDestroy` annotations](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations). You can combine these mechanisms to control a given bean.

从 Spring 2.5 开始，您有三个控制 bean 生命周期行为的选项：

- [`InitializingBean`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean) 和[`DisposableBean`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-disposablebean) 回调接口
- 自定义`init()`和`destroy()`方法
- [`@PostConstruct`和`@PreDestroy`注解](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations)。您可以组合这些机制来控制给定的 bean。

> If multiple lifecycle mechanisms are configured for a bean and each mechanism is configured with a different method name, then each configured method is run in the order listed after this note. However, if the same method name is configured — for example, `init()` for an initialization method — for more than one of these lifecycle mechanisms, that method is run once, as explained in the [preceding section](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-default-init-destroy-methods).
>
> 如果为一个 bean 配置了多个生命周期机制，并且每个机制都配置了不同的方法名称，那么每个配置的方法都将按照本说明后面列出的顺序运行。但是，如果配置了相同的方法名称 — 例如，`init()`用于初始化方法 — 对于这些生命周期机制中的多个，该方法只运行一次，如[上一节](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-default-init-destroy-methods)中所述。

Multiple lifecycle mechanisms configured for the same bean, with different initialization methods, are called as follows:

1. Methods annotated with `@PostConstruct`
2. `afterPropertiesSet()` as defined by the `InitializingBean` callback interface
3. A custom configured `init()` method

Destroy methods are called in the same order:

1. Methods annotated with `@PreDestroy`
2. `destroy()` as defined by the `DisposableBean` callback interface
3. A custom configured `destroy()` method

使用不同的初始化方法为同一 bean 配置的多个生命周期机制调用如下：

- 用 `@PostConstruct`注解的方法
- `InitializingBean` 回调接口定义的 `afterPropertiesSet()` 方法
- 自定义配置的 `init()`方法

销毁方法的调用顺序相同：

- 用 `@PreDestroy` 注解的方法
- 由 `DisposableBean`回调接口定义的 `destory()` 方法
- 自定义配置的 `destroy()` 方法

##### Startup and Shutdown Callbacks

##### 启动和关闭回调

The `Lifecycle` interface defines the essential methods for any object that has its own lifecycle requirements (such as starting and stopping some background process):

`Lifecycle` 接口定义了具有自身生命周期需求（例如启动和停止某些后台进程）的任何对象的基本方法：

```java
public interface Lifecycle {

    void start();

    void stop();

    boolean isRunning();
}
```

Any Spring-managed object may implement the `Lifecycle` interface. Then, when the `ApplicationContext` itself receives start and stop signals (for example, for a stop/restart scenario at runtime), it cascades those calls to all `Lifecycle` implementations defined within that context. It does this by delegating to a `LifecycleProcessor`, shown in the following listing:

任何 Spring 管理的对象都可以实现 `Lifecycle` 接口。然后，当 `ApplicationContext` 本身接收到启动和停止信号时（例如，对于运行时的停止/重新启动场景），它将这些调用级联到该上下文中定义的所有 `Lifecycle` 实现。它通过委托给 `LifecycleProcessor` 来实现这一点，如下清单所示：

```java
public interface LifecycleProcessor extends Lifecycle {

    void onRefresh();

    void onClose();
}
```

Notice that the `LifecycleProcessor` is itself an extension of the `Lifecycle` interface. It also adds two other methods for reacting to the context being refreshed and closed.

请注意，`LifecycleProcessor`本身就是`Lifecycle`接口的扩展。它还添加了另外两种方法，用于响应刷新和关闭的上下文。

> Note that the regular `org.springframework.context.Lifecycle` interface is a plain contract for explicit start and stop notifications and does not imply auto-startup at context refresh time. For fine-grained control over auto-startup of a specific bean (including startup phases), consider implementing `org.springframework.context.SmartLifecycle` instead.Also, please note that stop notifications are not guaranteed to come before destruction. On regular shutdown, all `Lifecycle` beans first receive a stop notification before the general destruction callbacks are being propagated. However, on hot refresh during a context’s lifetime or on stopped refresh attempts, only destroy methods are called.
>
> 请注意，常规的  `org.springframework.context.Lifecycle` 接口是用于显式启动和停止通知的简单约定，并不意味着在上下文刷新时自动启动。对于细粒度控制特定的 bean（包括启动阶段）的自动启动，请考虑执行 `org.springframework.context.SmartLifecycle`。此外，请注意，停止通知不保证在销毁前发出。在定期关闭时，所有 `Lifecycle` bean 在传播常规销毁回调之前首先收到停止通知。但是，在上下文的生存期内进行热刷新或停止刷新尝试时，只调用 destroy 方法。

The order of startup and shutdown invocations can be important. If a “depends-on” relationship exists between any two objects, the dependent side starts after its dependency, and it stops before its dependency. However, at times, the direct dependencies are unknown. You may only know that objects of a certain type should start prior to objects of another type. In those cases, the `SmartLifecycle` interface defines another option, namely the `getPhase()` method as defined on its super-interface, `Phased`. The following listing shows the definition of the `Phased` interface:

启动和关闭调用的顺序可能很重要。如果任意两个对象之间存在“依赖”关系，则依赖方在其依赖项之后开始，在其依赖项之前停止。然而，有时，直接依赖关系是未知的。您可能只知道某一类型的对象应该在另一类型的对象之前启动。在这些情况下，`SmartLifecycle` 接口定义了另一个选项，即在其超级接口 `Phased` 上定义的 `getPhase()` 方法。下表显示了 `Phased` 接口的定义：

```java
public interface Phased {

    int getPhase();
}
```

The following listing shows the definition of the `SmartLifecycle` interface:

下表显示了 `SmartLifecycle` 接口的定义：

```java
public interface SmartLifecycle extends Lifecycle, Phased {

    boolean isAutoStartup();

    void stop(Runnable callback);
}
```

When starting, the objects with the lowest phase start first. When stopping, the reverse order is followed. Therefore, an object that implements `SmartLifecycle` and whose `getPhase()` method returns `Integer.MIN_VALUE` would be among the first to start and the last to stop. At the other end of the spectrum, a phase value of `Integer.MAX_VALUE` would indicate that the object should be started last and stopped first (likely because it depends on other processes to be running). When considering the phase value, it is also important to know that the default phase for any “normal” `Lifecycle` object that does not implement `SmartLifecycle` is `0`. Therefore, any negative phase value indicates that an object should start before those standard components (and stop after them). The reverse is true for any positive phase value.

The stop method defined by `SmartLifecycle` accepts a callback. Any implementation must invoke that callback’s `run()` method after that implementation’s shutdown process is complete. That enables asynchronous shutdown where necessary, since the default implementation of the `LifecycleProcessor` interface, `DefaultLifecycleProcessor`, waits up to its timeout value for the group of objects within each phase to invoke that callback. The default per-phase timeout is 30 seconds. You can override the default lifecycle processor instance by defining a bean named `lifecycleProcessor` within the context. If you want only to modify the timeout, defining the following would suffice:

启动时，具有最低相位的对象首先启动。停止时，按相反的顺序进行。因此，实现 `SmartLifecycle` 且其 `getPhase()` 方法返回 `Integer.MIN_VALUE` 的对象将是最先启动和最后停止的对象之一。在频谱的另一端，`Integer.MAX_VALUE` 的相位值表示对象应该最后启动，首先停止（可能是因为它取决于要运行的其他进程）。在考虑阶段值时，还必须知道，任何未实现`SmartLifecycle`的“正常”`Lifecycle`对象的默认阶段为`0`。因此，任何负相位值都表示对象应在这些标准组件之前启动（并在它们之后停止）。对于任何正相位值，情况正好相反。

`SmartLifecycle` 定义的停止方法接受回调。任何实现都必须在该实现的关闭过程完成后调用该回调的 `run()` 方法。这将在必要时启用异步关闭，因为 `LifecycleProcessor` 接口的默认实现 `DefaultLifecycleProcessor` 将等待每个阶段中的对象组调用该回调，直到其超时值。默认每相超时为 30 秒。您可以通过在上下文中定义名为 `lifecycleProcessor` 的 bean 来覆盖默认的生命周期处理器实例。如果只想修改超时，定义以下内容就足够了：

```xml
<bean id="lifecycleProcessor" class="org.springframework.context.support.DefaultLifecycleProcessor">
    <!-- timeout value in milliseconds -->
    <property name="timeoutPerShutdownPhase" value="10000"/>
</bean>
```

As mentioned earlier, the `LifecycleProcessor` interface defines callback methods for the refreshing and closing of the context as well. The latter drives the shutdown process as if `stop()` had been called explicitly, but it happens when the context is closing. The 'refresh' callback, on the other hand, enables another feature of `SmartLifecycle` beans. When the context is refreshed (after all objects have been instantiated and initialized), that callback is invoked. At that point, the default lifecycle processor checks the boolean value returned by each `SmartLifecycle` object’s `isAutoStartup()` method. If `true`, that object is started at that point rather than waiting for an explicit invocation of the context’s or its own `start()` method (unlike the context refresh, the context start does not happen automatically for a standard context implementation). The `phase` value and any “depends-on” relationships determine the startup order as described earlier.

如前所述，`LifecycleProcessor`接口定义了用于刷新和关闭上下文的回调方法。后者驱动关闭过程，就好像 `stop()`已被显式调用，但它发生在上下文关闭时。另一方面，“刷新” 回调启用了 `SmartLifecycle` bean 的另一项功能。当上下文被刷新时（在所有对象被实例化和初始化之后），该回调被调用。此时，默认生命周期处理器将检查每个`SmartLifecycle`对象的`isAutoStartup()` 方法返回的布尔值。如果为 `true`，则该对象将在该点启动，而不是等待显式调用上下文或其自己的 `start()` 方法（与上下文刷新不同，对于标准上下文实现，上下文启动不会自动发生）。如前所述，`phase` 值和任何“依赖”关系决定启动顺序。

##### Shutting Down the Spring IoC Container Gracefully in Non-Web Applications

##### 在非 Web 应用程序中优雅地关闭 Spring IoC 容器

> This section applies only to non-web applications. Spring’s web-based `ApplicationContext` implementations already have code in place to gracefully shut down the Spring IoC container when the relevant web application is shut down.
>
> 本节仅适用于非 web 应用程序。Spring 基于 web 的 `ApplicationContext` 实现已经有代码，可以在相关 web 应用程序关闭时优雅地关闭 Spring IoC 容器。

If you use Spring’s IoC container in a non-web application environment (for example, in a rich client desktop environment), register a shutdown hook with the JVM. Doing so ensures a graceful shutdown and calls the relevant destroy methods on your singleton beans so that all resources are released. You must still configure and implement these destroy callbacks correctly.

To register a shutdown hook, call the `registerShutdownHook()` method that is declared on the `ConfigurableApplicationContext` interface, as the following example shows:

如果在非 web 应用程序环境中（例如，在富客户端桌面环境中）使用 Spring 的 IoC 容器，请向 JVM 注册一个关闭钩子。这样做可以确保正常关机，并在单例 bean 上调用相关的 destroy 方法，从而释放所有资源。您仍然必须正确配置和实现这些销毁回调。

要注册关闭挂钩，请调用在 `ConfigurableApplicationContext` 接口上声明的 `RegisterShoutDownhook()` 方法，如下例所示：

```java
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");

        // add a shutdown hook for the above context...
        ctx.registerShutdownHook();

        // app runs here...

        // main method exits, hook is called prior to the app shutting down...
    }
}
```

#### 1.6.2. `ApplicationContextAware` and `BeanNameAware`

#### 1.6.2. `ApplicationContextAware`和`BeanNameware`

When an `ApplicationContext` creates an object instance that implements the `org.springframework.context.ApplicationContextAware` interface, the instance is provided with a reference to that `ApplicationContext`. The following listing shows the definition of the `ApplicationContextAware` interface:

当一个 `ApplicationContext` 创建一个实现 `org.springframework.context.ApplicationContextAware` 接口的对象实例时，会向该实例提供对该 `ApplicationContext` 的引用。下表显示了 `ApplicationContextAware` 接口的定义：

```java
public interface ApplicationContextAware {

    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
}
```

Thus, beans can programmatically manipulate the `ApplicationContext` that created them, through the `ApplicationContext` interface or by casting the reference to a known subclass of this interface (such as `ConfigurableApplicationContext`, which exposes additional functionality). One use would be the programmatic retrieval of other beans. Sometimes this capability is useful. However, in general, you should avoid it, because it couples the code to Spring and does not follow the Inversion of Control style, where collaborators are provided to beans as properties. Other methods of the `ApplicationContext` provide access to file resources, publishing application events, and accessing a `MessageSource`. These additional features are described in [Additional Capabilities of the `ApplicationContext`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-introduction).

Autowiring is another alternative to obtain a reference to the `ApplicationContext`. The *traditional* `constructor` and `byType` autowiring modes (as described in [Autowiring Collaborators](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire)) can provide a dependency of type `ApplicationContext` for a constructor argument or a setter method parameter, respectively. For more flexibility, including the ability to autowire fields and multiple parameter methods, use the annotation-based autowiring features. If you do, the `ApplicationContext` is autowired into a field, constructor argument, or method parameter that expects the `ApplicationContext` type if the field, constructor, or method in question carries the `@Autowired` annotation. For more information, see [Using `@Autowired`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-autowired-annotation).

When an `ApplicationContext` creates a class that implements the `org.springframework.beans.factory.BeanNameAware` interface, the class is provided with a reference to the name defined in its associated object definition. The following listing shows the definition of the BeanNameAware interface:

因此，bean 可以通过 `ApplicationContext` 接口或通过强制引用该接口的已知子类（如`ConfigurableApplicationContext` ，它公开了其他功能），以编程方式操纵创建它们的`ApplicationContext`。一个用途是对其他 bean 进行编程检索。有时这种能力是有用的。但是，一般来说，您应该避免使用它，因为它将代码耦合到 Spring，并且不遵循控件反转样式，即协作者作为属性提供给 bean。`ApplicationContext` 的其他方法提供对文件资源的访问、发布应用程序事件和访问 `MessageSource`。这些附加功能在 [ApplicationContext的附加功能](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-introduction) 中有描述。

自动装配是获取对 `ApplicationContext` 的引用的另一种替代方法。传统 `constructor` 和 `byType` 自动装配模式（如[autowiring Collaborators](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire)中所述）可以分别为构造函数参数或 setter 方法参数提供 `ApplicationContext` 类型的依赖关系。要获得更大的灵活性，包括自动装配字段和多参数方法的能力，请使用基于注解的自动装配功能。如果这样做，`ApplicationContext` 将自动装配到字段、构造函数参数或方法参数中，如果所讨论的字段、构造函数或方法带有 `@autowired` 注解，则该字段、构造函数参数或方法参数应为 `ApplicationContext` 类型。有关详细信息，请参阅[使用 `@Autowired`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-autowired-annotation)。

当 `ApplicationContext` 创建一个实现 `org.springframework.beans.factory.BeanNameAware` 的类时。该类提供了对其关联对象定义中定义的名称的引用。下面的列表显示了 BeanNameWare 接口的定义：

```java
public interface BeanNameAware {

    void setBeanName(String name) throws BeansException;
}
```

The callback is invoked after population of normal bean properties but before an initialization callback such as `InitializingBean.afterPropertiesSet()` or a custom init-method.

在填充普通 bean 属性之后，但在初始化回调（如 `InitializingBean.afterPropertiesSet()` 或自定义 init 方法）之前调用回调。

#### 1.6.3. Other `Aware` Interfaces

#### 1.6.3.其它 `Aware` 接口

Besides `ApplicationContextAware` and `BeanNameAware` (discussed [earlier](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware)), Spring offers a wide range of `Aware` callback interfaces that let beans indicate to the container that they require a certain infrastructure dependency. As a general rule, the name indicates the dependency type. The following table summarizes the most important `Aware` interfaces:

除了 `ApplicationContextAware` 和 `BeanNameAware`（[前面讨论过](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware)）之外，Spring 还提供了一系列 `Aware` 回调接口，让bean 向容器指示它们需要某种基础结构依赖性。一般来说，名称表示依赖项类型。下表总结了最重要的 `Aware` 接口：

| Name                             | Injected Dependency                                          | Explained in…                                                |
| :------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `ApplicationContextAware`        | Declaring `ApplicationContext`.<br />声明 `ApplicationContext`。 | [`ApplicationContextAware` and `BeanNameAware`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware) |
| `ApplicationEventPublisherAware` | Event publisher of the enclosing `ApplicationContext`.<br />包含 `ApplicationContext` 的事件发布者。 | [Additional Capabilities of the `ApplicationContext`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-introduction) |
| `BeanClassLoaderAware`           | Class loader used to load the bean classes.<br />用于加载 bean 类的类装入器。 | [Instantiating Beans](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class) |
| `BeanFactoryAware`               | Declaring `BeanFactory`.<br />声明 `BeanFactory`。           | [The `BeanFactory`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beanfactory) |
| `BeanNameAware`                  | Name of the declaring bean.<br />声明 bean 的名称。          | [`ApplicationContextAware` and `BeanNameAware`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware) |
| `LoadTimeWeaverAware`            | Defined weaver for processing class definition at load time.<br />已定义用于在加载时处理类定义的编织器。 | [Load-time Weaving with AspectJ in the Spring Framework](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw) |
| `MessageSourceAware`             | Configured strategy for resolving messages (with support for parametrization and internationalization).<br />配置用于解析消息的策略（支持参数化和国际化）。 | [Additional Capabilities of the `ApplicationContext`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-introduction) |
| `NotificationPublisherAware`     | Spring JMX notification publisher.<br />Spring JMX 通知发布者。 | [Notifications](https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#jmx-notifications) |
| `ResourceLoaderAware`            | Configured loader for low-level access to resources.<br /> 已配置用于低级别访问资源的加载程序。 | [Resources](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources) |
| `ServletConfigAware`             | Current `ServletConfig` the container runs in. Valid only in a web-aware Spring `ApplicationContext`.<br />容器在其中运行的当前 `ServletConfig`。仅在支持 web 的 Spring  `ApplicationContext` 中有效。 | [Spring MVC](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc) |
| `ServletContextAware`            | Current `ServletContext` the container runs in. Valid only in a web-aware Spring `ApplicationContext`.<br />容器运行所在的当前 `ServletContext`。仅在支持 web 的 Spring  `ApplicationContext` 中有效。 | [Spring MVC](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc) |

Note again that using these interfaces ties your code to the Spring API and does not follow the Inversion of Control style. As a result, we recommend them for infrastructure beans that require programmatic access to the container.

再次注意，使用这些接口会将代码绑定到 Spring API，而不会遵循控制风格的反转。因此，对于需要对容器进行编程访问的基础结构 bean，我们建议使用它们。

### 1.7. Bean Definition Inheritance

### 1.7. Bean 定义继承

A bean definition can contain a lot of configuration information, including constructor arguments, property values, and container-specific information, such as the initialization method, a static factory method name, and so on. A child bean definition inherits configuration data from a parent definition. The child definition can override some values or add others as needed. Using parent and child bean definitions can save a lot of typing. Effectively, this is a form of templating.

If you work with an `ApplicationContext` interface programmatically, child bean definitions are represented by the `ChildBeanDefinition` class. Most users do not work with them on this level. Instead, they configure bean definitions declaratively in a class such as the `ClassPathXmlApplicationContext`. When you use XML-based configuration metadata, you can indicate a child bean definition by using the `parent` attribute, specifying the parent bean as the value of this attribute. The following example shows how to do so:

bean 定义可以包含许多配置信息，包括构造函数参数、属性值和特定于容器的信息，如初始化方法、静态工厂方法名称等。子bean 定义从父定义继承配置数据。子定义可以根据需要覆盖某些值或添加其他值。使用父 bean 和子 bean 定义可以节省大量输入。实际上，这是一种模板形式。

如果以编程方式使用 `ApplicationContext` 接口，则子 bean 定义由 `ChildBeanDefinition` 类表示。大多数用户在这个级别上不使用它们。相反，它们在类（如 `ClassPathXmlApplicationContext`）中以声明方式配置 bean 定义。使用基于 XML 的配置元数据时，可以通过使用 `parent` 属性来指示子bean定义，并将父 bean 指定为该属性的值。以下示例显示了如何执行此操作：

```xml
<bean id="inheritedTestBean" abstract="true"
        class="org.springframework.beans.TestBean">
    <property name="name" value="parent"/>
    <property name="age" value="1"/>
</bean>

<bean id="inheritsWithDifferentClass"
        class="org.springframework.beans.DerivedTestBean"
        parent="inheritedTestBean" init-method="initialize">  <!--注释-->
    <property name="name" value="override"/>
    <!-- the age property value of 1 will be inherited from parent -->
</bean>
```

注释一：Note the `parent` attribute. 注意 `parent` 属性。

A child bean definition uses the bean class from the parent definition if none is specified but can also override it. In the latter case, the child bean class must be compatible with the parent (that is, it must accept the parent’s property values).

A child bean definition inherits scope, constructor argument values, property values, and method overrides from the parent, with the option to add new values. Any scope, initialization method, destroy method, or `static` factory method settings that you specify override the corresponding parent settings.

The remaining settings are always taken from the child definition: depends on, autowire mode, dependency check, singleton, and lazy init.

The preceding example explicitly marks the parent bean definition as abstract by using the `abstract` attribute. If the parent definition does not specify a class, explicitly marking the parent bean definition as `abstract` is required, as the following example shows:

如果没有指定，子 bean 定义将使用父定义中的 bean 类，但也可以重写它。在后一种情况下，子 bean 类必须与父类兼容（也就是说，它必须接受父类的属性值）。

子 bean 定义继承父 bean 的作用域、构造函数参数值、属性值和方法重写，并具有添加新值的选项。指定的任何作用域、初始化方法、销毁方法或“静态”工厂方法设置都将覆盖相应的父级设置。

其余设置始终取自子定义：依赖项、自动装配模式、依赖项检查、单例和惰性初始化。

前面的示例使用  `abstract` 属性将父 bean 定义显式标记为抽象。如果父定义没有指定类，则需要显式地将父 bean 定义标记为 `abstract`，如下例所示：

```xml
<bean id="inheritedTestBeanWithoutClass" abstract="true">
    <property name="name" value="parent"/>
    <property name="age" value="1"/>
</bean>

<bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
        parent="inheritedTestBeanWithoutClass" init-method="initialize">
    <property name="name" value="override"/>
    <!-- age will inherit the value of 1 from the parent bean definition-->
</bean>
```

The parent bean cannot be instantiated on its own because it is incomplete, and it is also explicitly marked as `abstract`. When a definition is `abstract`, it is usable only as a pure template bean definition that serves as a parent definition for child definitions. Trying to use such an `abstract` parent bean on its own, by referring to it as a ref property of another bean or doing an explicit `getBean()` call with the parent bean ID returns an error. Similarly, the container’s internal `preInstantiateSingletons()` method ignores bean definitions that are defined as abstract.

父 bean 无法单独实例化，因为它不完整，并且还显式标记为 `abstract`。当定义为 `abstract` 时，它只能用作纯模板 bean 定义，作为子定义的父定义。尝试单独使用这样一个 `abstract` 父 bean，将其引用为另一个 bean 的 ref 属性，或者使用父 bean ID执行一个显式的 `getBean()` 调用，将返回一个错误。类似地，容器的内部 `preInstantiateSingletons()`方法忽略定义为抽象的 bean 定义。

>   `ApplicationContext` pre-instantiates all singletons by default. Therefore, it is important (at least for singleton beans) that if you have a (parent) bean definition which you intend to use only as a template, and this definition specifies a class, you must make sure to set the *abstract* attribute to *true*, otherwise the application context will actually (attempt to) pre-instantiate the `abstract` bean.
>
>   `ApplicationContext`默认情况下预先实例化所有单例。因此，重要的是（至少对于单例bean而言），如果您有一个仅打算用作模板的（父）bean定义，并且该定义指定了一个类，则必须确保将*abstract*属性设置为*true*，否则应用程序上下文将实际（尝试）预实例化`abstract` bean。

### 1.8. Container Extension Points

### 1.8 容器拓展点

Typically, an application developer does not need to subclass `ApplicationContext` implementation classes. Instead, the Spring IoC container can be extended by plugging in implementations of special integration interfaces. The next few sections describe these integration interfaces.

通常，应用程序开发人员不需要为 `ApplicationContext` 实现类创建子类。相反，Spring IOC 容器可以通过插入特殊集成接口的实现来扩展。接下来的几节将介绍这些集成接口。

#### 1.8.1. Customizing Beans by Using a `BeanPostProcessor`

#### 1.8.1. 使用 `BeanPostProcessor` 自定义 Bean

The `BeanPostProcessor` interface defines callback methods that you can implement to provide your own (or override the container’s default) instantiation logic, dependency resolution logic, and so forth. If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more custom `BeanPostProcessor` implementations.

You can configure multiple `BeanPostProcessor` instances, and you can control the order in which these `BeanPostProcessor` instances run by setting the `order` property. You can set this property only if the `BeanPostProcessor` implements the `Ordered` interface. If you write your own `BeanPostProcessor`, you should consider implementing the `Ordered` interface, too. For further details, see the javadoc of the [`BeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html) and [`Ordered`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/Ordered.html) interfaces. See also the note on [programmatic registration of `BeanPostProcessor` instances](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-programmatically-registering-beanpostprocessors).

`BeanPostProcessor` 接口定义了回调方法，您可以实现这些方法来提供自己的（或覆盖容器的默认）实例化逻辑、依赖项解析逻辑等。如果您想在 Spring 容器完成 bean 的实例化、配置和初始化之后实现一些自定义逻辑，那么可以插入一个或多个自定义的 `BeanPostProcessor` 实现。

您可以配置多个 `BeanPostProcessor` 实例，并且可以通过设置 `order` 属性来控制这些 `BeanPostProcessor` 实例的运行顺序。仅当 `BeanPostProcessor` 实现 `Ordered` 接口时，才能设置此属性。如果您编写自己的 `BeanPostProcessor`，也应该考虑实现 `Ordered` 接口。有关更多详细信息，请参阅 [`BeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html) 和 [`Ordered`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/Ordered.html) 接口的 javadoc。另见 [对`BeanPostProcessor`实例进行程序注册](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-programmatically-registering-beanpostprocessors) 的说明。

> `BeanPostProcessor` instances operate on bean (or object) instances. That is, the Spring IoC container instantiates a bean instance and then `BeanPostProcessor` instances do their work.`BeanPostProcessor` instances are scoped per-container. This is relevant only if you use container hierarchies. If you define a `BeanPostProcessor` in one container, it post-processes only the beans in that container. In other words, beans that are defined in one container are not post-processed by a `BeanPostProcessor` defined in another container, even if both containers are part of the same hierarchy.To change the actual bean definition (that is, the blueprint that defines the bean), you instead need to use a `BeanFactoryPostProcessor`, as described in [Customizing Configuration Metadata with a `BeanFactoryPostProcessor`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-factory-postprocessors).
>
> `BeanPostProcessor`实例对 bean（或对象）实例进行操作。也就是说，Spring IOC 容器实例化一个 bean 实例，然后 `BeanPostProcessor` 实例执行它们的工作 `BeanPostProcessor` 实例的作用域为每个容器。这仅在使用容器层次结构时才相关。如果在一个容器中定义 `BeanPostProcessor`，则它只对该容器中的 bean 进行后期处理。换句话说，一个容器中定义的 bean 不会被另一个容器中定义的 `BeanPostProcessor` 后处理，即使两个容器都是同一层次结构的一部分。要更改实际的 bean 定义（即定义 bean 的蓝图），您需要使用 `BeanFactoryPostProcessor`，如[使用 `BeanFactoryPostProcessor`自定义配置元数据](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-factory-postprocessors) 中所述。

The `org.springframework.beans.factory.config.BeanPostProcessor` interface consists of exactly two callback methods. When such a class is registered as a post-processor with the container, for each bean instance that is created by the container, the post-processor gets a callback from the container both before container initialization methods (such as `InitializingBean.afterPropertiesSet()` or any declared `init` method) are called, and after any bean initialization callbacks. The post-processor can take any action with the bean instance, including ignoring the callback completely. A bean post-processor typically checks for callback interfaces, or it may wrap a bean with a proxy. Some Spring AOP infrastructure classes are implemented as bean post-processors in order to provide proxy-wrapping logic.

An `ApplicationContext` automatically detects any beans that are defined in the configuration metadata that implement the `BeanPostProcessor` interface. The `ApplicationContext` registers these beans as post-processors so that they can be called later, upon bean creation. Bean post-processors can be deployed in the container in the same fashion as any other beans.

Note that, when declaring a `BeanPostProcessor` by using an `@Bean` factory method on a configuration class, the return type of the factory method should be the implementation class itself or at least the `org.springframework.beans.factory.config.BeanPostProcessor` interface, clearly indicating the post-processor nature of that bean. Otherwise, the `ApplicationContext` cannot autodetect it by type before fully creating it. Since a `BeanPostProcessor` needs to be instantiated early in order to apply to the initialization of other beans in the context, this early type detection is critical.

`org.springframework.beans.factory.config.BeanPostProcessor` 接口正好由两个回调方法组成。当这样一个类在容器中注册为后处理器时，对于容器创建的每个 bean 实例，后处理器在调用容器初始化方法（例如 `InitializingBean.afterPropertiesSet()` 或任何声明的 `init `方法）之前以及在任何 bean 初始化回调之后从容器中获取回调。后处理器可以对 bean 实例执行任何操作，包括完全忽略回调。bean 后处理器通常检查回调接口，或者用代理包装 bean。一些 Spring AOP 基础设施类被实现为 bean 后处理器，以提供代理包装逻辑。

`ApplicationContext` 自动检测在实现 `BeanPostProcessor` 接口的配置元数据中定义的任何 bean。`ApplicationContext` 将这些 bean 注册为后处理器，以便稍后在创建 bean 时调用它们。Bean 后处理器可以像其他 Bean一样部署在容器中。

请注意，当在配置类上使用 `@Bean` 工厂方法声明 ` BeanPostProcessor` 时，工厂方法的返回类型应该是实现类本身或至少是 `org.springframework.beans.factory.config.BeanPostProcessor` 接口，清楚地指示该 Bean 的后处理器性质。否则，`ApplicationContext` 在完全创建之前无法按类型自动检测它。由于 `BeanPostProcessor` 需要尽早实例化，以便应用于上下文中其他 bean 的初始化，因此这种早期类型检测至关重要。

> Programmatically registering `BeanPostProcessor` instances<br />While the recommended approach for `BeanPostProcessor` registration is through `ApplicationContext` auto-detection (as described earlier), you can register them programmatically against a `ConfigurableBeanFactory` by using the `addBeanPostProcessor` method. This can be useful when you need to evaluate conditional logic before registration or even for copying bean post processors across contexts in a hierarchy. Note, however, that `BeanPostProcessor` instances added programmatically do not respect the `Ordered` interface. Here, it is the order of registration that dictates the order of execution. Note also that `BeanPostProcessor` instances registered programmatically are always processed before those registered through auto-detection, regardless of any explicit ordering.
>
> 以编程方式注册 `BeanPostProcessor`实例<br/>虽然建议的 `BeanPostProcessor` 注册方法是通过 `ApplicationContext` 自动检测（如前所述），但您可以使用 `addBeanPostProcessor` 方法以编程方式针对 `ConfigurableBeanFactory` 注册它们。当您需要在注册之前评估条件逻辑，甚至在层次结构中跨上下文复制 bean 后处理器时，这非常有用。但是，请注意，以编程方式添加的 `BeanPostProcessor` 实例不符合 `Ordered` 接口。在这里，登记的顺序决定了执行的顺序。还请注意，以编程方式注册的 `BeanPostProcessor` 实例总是在通过自动检测注册的实例之前进行处理，而不考虑任何显式顺序。

>   `BeanPostProcessor` instances and AOP auto-proxying<br />Classes that implement the `BeanPostProcessor` interface are special and are treated differently by the container. All `BeanPostProcessor` instances and beans that they directly reference are instantiated on startup, as part of the special startup phase of the `ApplicationContext`. Next, all `BeanPostProcessor` instances are registered in a sorted fashion and applied to all further beans in the container. Because AOP auto-proxying is implemented as a `BeanPostProcessor` itself, neither `BeanPostProcessor` instances nor the beans they directly reference are eligible for auto-proxying and, thus, do not have aspects woven into them.For any such bean, you should see an informational log message: `Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)`.If you have beans wired into your `BeanPostProcessor` by using autowiring or `@Resource` (which may fall back to autowiring), Spring might access unexpected beans when searching for type-matching dependency candidates and, therefore, make them ineligible for auto-proxying or other kinds of bean post-processing. For example, if you have a dependency annotated with `@Resource` where the field or setter name does not directly correspond to the declared name of a bean and no name attribute is used, Spring accesses other beans for matching them by type.
>
>   `BeanPostProcessor`实例和 AOP 自动代理<br/>
>
>   实现 `BeanPostProcessor` 接口的类是特殊的，容器对它们的处理方式不同。作为 `ApplicationContext` 特殊启动阶段的一部分，所有直接引用的 `BeanPostProcessor` 实例和 bean 都会在启动时实例化。接下来，以排序方式注册所有 `BeanPostProcessor` 实例，并将其应用于容器中的所有其他 bean。因为 AOP 自动代理是作为 `BeanPostProcessor` 本身实现的，所以无论是 `BeanPostProcessor` 实例还是它们直接引用的 bean 都不符合自动代理的条件，因此，它们没有编织方面。对于任何这样的 bean，您都应该看到一条信息日志消息： `Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)`。如果您使用自动装配或 `@Resource`（可能会返回到自动装配）将 bean 连接到您的 ` BeanPostProcessor` 中，Spring 在搜索类型匹配的依赖候选项时可能会访问意外的 bean，因此，使它们不符合自动代理或其他类型的 bean 后处理的条件。例如，如果您有一个用 `@Resource` 注解的依赖项，其中字段或 setter 名称与 bean 的声明名称不直接对应，并且没有使用 name 属性，那么 Spring 将访问其他 bean 以按类型进行匹配。

The following examples show how to write, register, and use `BeanPostProcessor` instances in an `ApplicationContext`.

以下示例演示如何在 `ApplicationContext` 中写入、注册和使用 `BeanPostProcessor` 实例。

##### Example: Hello World, `BeanPostProcessor`-style

This first example illustrates basic usage. The example shows a custom `BeanPostProcessor` implementation that invokes the `toString()` method of each bean as it is created by the container and prints the resulting string to the system console.

The following listing shows the custom `BeanPostProcessor` implementation class definition:

第一个示例说明了基本用法。该示例显示了一个自定义的 `BeanPostProcessor` 实现，该实现在容器创建每个 bean 时调用该bean 的 `toString()` 方法，并将结果字符串打印到系统控制台。

以下列表显示了自定义 `BeanPostProcessor`  实现类定义：

```java
package scripting;

import org.springframework.beans.factory.config.BeanPostProcessor;

public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {

    // simply return the instantiated bean as-is
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        return bean; // we could potentially return any object reference here...
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) {
        System.out.println("Bean '" + beanName + "' created : " + bean.toString());
        return bean;
    }
}
```

The following `beans` element uses the `InstantiationTracingBeanPostProcessor`:

以下 `beans` 元素使用 `InstantiationTracingBeanPostProcessor`：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:lang="http://www.springframework.org/schema/lang"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/lang
        https://www.springframework.org/schema/lang/spring-lang.xsd">

    <lang:groovy id="messenger"
            script-source="classpath:org/springframework/scripting/groovy/Messenger.groovy">
        <lang:property name="message" value="Fiona Apple Is Just So Dreamy."/>
    </lang:groovy>

    <!--
    when the above bean (messenger) is instantiated, this custom
    BeanPostProcessor implementation will output the fact to the system console
    -->
    <bean class="scripting.InstantiationTracingBeanPostProcessor"/>

</beans>
```

Notice how the `InstantiationTracingBeanPostProcessor` is merely defined. It does not even have a name, and, because it is a bean, it can be dependency-injected as you would any other bean. (The preceding configuration also defines a bean that is backed by a Groovy script. The Spring dynamic language support is detailed in the chapter entitled [Dynamic Language Support](https://docs.spring.io/spring-framework/docs/current/reference/html/languages.html#dynamic-language).)

The following Java application runs the preceding code and configuration:

请注意，`InstantiationTracingBeanPostProcessor` 仅仅是如何定义的。它甚至没有名字，而且，因为它是一个 bean，所以可以像其他 bean 一样注入依赖项。（前面的配置还定义了一个由 Groovy 脚本支持的 bean。Spring 动态语言支持在标题为[dynamic language support](https://docs.spring.io/spring-framework/docs/current/reference/html/languages.html#dynamic-language) 的一章中有详细介绍。）

以下 Java 应用程序运行前面的代码和配置：

```java
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.scripting.Messenger;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("scripting/beans.xml");
        Messenger messenger = ctx.getBean("messenger", Messenger.class);
        System.out.println(messenger);
    }
}
```

The output of the preceding application resembles the following:

上述应用程序的输出类似于以下内容：

```
Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961
org.springframework.scripting.groovy.GroovyMessenger@272961
```

##### Example: The `AutowiredAnnotationBeanPostProcessor`

示例：`AutowiredAnnotationBeanPostProcessor`

Using callback interfaces or annotations in conjunction with a custom `BeanPostProcessor` implementation is a common means of extending the Spring IoC container. An example is Spring’s `AutowiredAnnotationBeanPostProcessor` — a `BeanPostProcessor` implementation that ships with the Spring distribution and autowires annotated fields, setter methods, and arbitrary config methods.

将回调接口或注解与自定义的 `BeanPostProcessor` 实现结合使用是扩展 Spring IoC 容器的常用方法。Spring 的  `AutowiredAnnotationBeanPostProcessor` 就是一个例子 — `BeanPostProcessor` 实现，附带 Spring 发行版和 autowires 注解字段、setter 方法和任意配置方法。

#### 1.8.2. Customizing Configuration Metadata with a `BeanFactoryPostProcessor`

#### 1.8.2. 使用 `BeanFactoryPostProcessor` 自定义配置元数据

The next extension point that we look at is the `org.springframework.beans.factory.config.BeanFactoryPostProcessor`. The semantics of this interface are similar to those of the `BeanPostProcessor`, with one major difference: `BeanFactoryPostProcessor` operates on the bean configuration metadata. That is, the Spring IoC container lets a `BeanFactoryPostProcessor` read the configuration metadata and potentially change it *before* the container instantiates any beans other than `BeanFactoryPostProcessor` instances.

You can configure multiple `BeanFactoryPostProcessor` instances, and you can control the order in which these `BeanFactoryPostProcessor` instances run by setting the `order` property. However, you can only set this property if the `BeanFactoryPostProcessor` implements the `Ordered` interface. If you write your own `BeanFactoryPostProcessor`, you should consider implementing the `Ordered` interface, too. See the javadoc of the [`BeanFactoryPostProcessor`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html) and [`Ordered`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/Ordered.html) interfaces for more details.

我们看的下一个扩展点是 `org.springframework.beans.factory.config.BeanFactoryPostProcessor`。此接口的语义类似于 `BeanPostProcessor`，但有一个主要区别：`BeanFactoryPostProcessor` 操作 bean 配置元数据。也就是说，Spring IoC容器允许 `BeanFactoryPostProcessor`读取配置元数据，并在容器实例化除 `BeanFactoryPostProcessor` 实例以外的任何bean 之前潜在地更改它。

您可以配置多个 `BeanFactoryPostProcessor` 实例，并且可以通过设置 `order` 属性来控制这些 `BeanFactoryPostProcessor` 实例的运行顺序。但是，仅当 `BeanFactoryPostProcessor` 实现 `Ordered` 接口时，才能设置此属性。如果编写自己的 `BeanFactoryPostProcessor` ，也应该考虑实现 `Ordered` 接口。有关更多详细信息，请参阅[`BeanFactoryPostProcessor`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html) 和[`Ordered`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/Ordered.html)  接口的 javadoc。

> If you want to change the actual bean instances (that is, the objects that are created from the configuration metadata), then you instead need to use a `BeanPostProcessor` (described earlier in [Customizing Beans by Using a `BeanPostProcessor`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-bpp)). While it is technically possible to work with bean instances within a `BeanFactoryPostProcessor` (for example, by using `BeanFactory.getBean()`), doing so causes premature bean instantiation, violating the standard container lifecycle. This may cause negative side effects, such as bypassing bean post processing.Also, `BeanFactoryPostProcessor` instances are scoped per-container. This is only relevant if you use container hierarchies. If you define a `BeanFactoryPostProcessor` in one container, it is applied only to the bean definitions in that container. Bean definitions in one container are not post-processed by `BeanFactoryPostProcessor` instances in another container, even if both containers are part of the same hierarchy.
>
> 如果要更改实际的 bean 实例（即从配置元数据创建的对象），则需要使用 `BeanPostProcessor`（前面在[使用 `BeanPostProcessor` 自定义 bean](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-bpp)中介绍）。虽然在技术上可以在 `BeanFactoryPostProcessor` 中使用 bean 实例（例如，通过使用 `BeanFactory.getBean()`），但这样做会导致过早的 bean 实例化，违反标准容器生命周期。这可能会导致负面的副作用，例如绕过 bean 后处理。此外，`BeanFactoryPostProcessor` 实例的作用域为每个容器。这仅在使用容器层次结构时才相关。如果在一个容器中定义 `BeanFactoryPostProcessor`，则它仅应用于该容器中的 bean 定义。一个容器中的 Bean 定义不会由另一个容器中的 `BeanFactoryPostProcessor` 实例进行后处理，即使两个容器是同一层次结构的一部分。

A bean factory post-processor is automatically run when it is declared inside an `ApplicationContext`, in order to apply changes to the configuration metadata that define the container. Spring includes a number of predefined bean factory post-processors, such as `PropertyOverrideConfigurer` and `PropertySourcesPlaceholderConfigurer`. You can also use a custom `BeanFactoryPostProcessor` — for example, to register custom property editors.

An `ApplicationContext` automatically detects any beans that are deployed into it that implement the `BeanFactoryPostProcessor` interface. It uses these beans as bean factory post-processors, at the appropriate time. You can deploy these post-processor beans as you would any other bean.

bean 工厂后处理器在 `ApplicationContext` 中声明时自动运行，以便将更改应用于定义容器的配置元数据。Spring 包括许多预定义的 bean factory 后处理器，如 `PropertyOverrideConfiguler` 和 `PropertySourcesPlaceholderConfigurer`。您还可以使用自定义的 `BeanFactoryPostProcessor` — 例如，注册自定义属性编辑器。

`ApplicationContext`自动检测部署到其中的实现`BeanFactoryPostProcessor`接口的任何 bean。它在适当的时候将这些 bean 用作 bean 工厂的后处理器。您可以像部署任何其他 bean 一样部署这些后处理器 bean。

> As with `BeanPostProcessor`s , you typically do not want to configure `BeanFactoryPostProcessor`s for lazy initialization. If no other bean references a `Bean(Factory)PostProcessor`, that post-processor will not get instantiated at all. Thus, marking it for lazy initialization will be ignored, and the `Bean(Factory)PostProcessor` will be instantiated eagerly even if you set the `default-lazy-init` attribute to `true` on the declaration of your `<beans />` element.
>
> 与 `BeanPostProcessor` 一样，您通常不希望为延迟初始化配置 `BeanFactoryPostProcessor`。如果没有其他 bean 引用`Bean(Factory)PostProcessor`，则该后处理器将根本不会被实例化。因此，将其标记为延迟初始化将被忽略，并且即使在`<beans/>`元素的声明中将` default-lazy-init`属性设置为`true`时， `Bean(Factory)PostProcessor` 也将被急切地实例化。

##### Example: The Class Name Substitution `PropertySourcesPlaceholderConfigurer`

##### 示例：类名称替换  `PropertySourcesPlaceholderConfigurer`

You can use the `PropertySourcesPlaceholderConfigurer` to externalize property values from a bean definition in a separate file by using the standard Java `Properties` format. Doing so enables the person deploying an application to customize environment-specific properties, such as database URLs and passwords, without the complexity or risk of modifying the main XML definition file or files for the container.

Consider the following XML-based configuration metadata fragment, where a `DataSource` with placeholder values is defined:

您可以使用 `PropertySourcesPlaceholderConfigurer` 通过使用标准 Java `Properties` 格式将 bean 定义中的属性值外部化到单独的文件中。这样做使部署应用程序的人员能够自定义特定于环境的属性，例如数据库 URL 和密码，而无需修改容器的主 XML 定义文件的复杂性或风险。

考虑下面的基于 XML 的配置元数据片段，其中定义了具有占位符值的 `DataSource`：

```xml
<bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">
    <property name="locations" value="classpath:com/something/jdbc.properties"/>
</bean>

<bean id="dataSource" destroy-method="close"
        class="org.apache.commons.dbcp.BasicDataSource">
    <property name="driverClassName" value="${jdbc.driverClassName}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>
```

The example shows properties configured from an external `Properties` file. At runtime, a `PropertySourcesPlaceholderConfigurer` is applied to the metadata that replaces some properties of the DataSource. The values to replace are specified as placeholders of the form `${property-name}`, which follows the Ant and log4j and JSP EL style.

The actual values come from another file in the standard Java `Properties` format:

该示例显示了从外部 `Properties` 文件配置的属性。在运行时，`PropertySourcesPlaceholderConfigurer` 将应用于替换数据源某些属性的元数据。要替换的值被指定为 `${property-name}` 形式的占位符，它遵循 Ant、log4j 和 JSP EL 样式。

实际值来自标准 Java `Properties` 格式的另一个文件：

```properties
jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root
```

Therefore, the `${jdbc.username}` string is replaced at runtime with the value, 'sa', and the same applies for other placeholder values that match keys in the properties file. The `PropertySourcesPlaceholderConfigurer` checks for placeholders in most properties and attributes of a bean definition. Furthermore, you can customize the placeholder prefix and suffix.

With the `context` namespace introduced in Spring 2.5, you can configure property placeholders with a dedicated configuration element. You can provide one or more locations as a comma-separated list in the `location` attribute, as the following example shows:

因此，`${jdbc.username}`字符串在运行时被替换为值 `sa`，这同样适用于与属性文件中的键匹配的其他占位符值。`PropertySourcesPlaceholderConfigurer` 检查 bean 定义的大多数属性和属性中的占位符。此外，还可以自定义占位符前缀和后缀。

通过 Spring 2.5 中引入的 `context` 名称空间，您可以使用专用的配置元素配置属性占位符。您可以在 `location` 属性中以逗号分隔的列表形式提供一个或多个位置，如下例所示：

```xml
<context:property-placeholder location="classpath:com/something/jdbc.properties"/>
```

The `PropertySourcesPlaceholderConfigurer` not only looks for properties in the `Properties` file you specify. By default, if it cannot find a property in the specified properties files, it checks against Spring `Environment` properties and regular Java `System` properties.

`PropertySourcesPlaceholderConfigurer`不仅在指定的 `Properties` 文件中查找属性。默认情况下，如果在指定的属性文件中找不到属性，它会检查 Spring 的 `Environment` 属性和常规 Java 的 `System` 属性。

>   You can use the `PropertySourcesPlaceholderConfigurer` to substitute class names, which is sometimes useful when you have to pick a particular implementation class at runtime. The following example shows how to do so:
>
>   您可以使用 `PropertySourcesPlaceholderConfigurer` 来替换类名，这在运行时必须选择特定的实现类时有时很有用。以下示例显示了如何执行此操作：
>
>   ```xml
>   <bean class="org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer">
>      <property name="locations">
>          <value>classpath:com/something/strategy.properties</value>
>      </property>
>      <property name="properties">
>          <value>custom.strategy.class=com.something.DefaultStrategy</value>
>      </property>
>   </bean>
>   
>   <bean id="serviceStrategy" class="${custom.strategy.class}"/>
>   ```
>
>   If the class cannot be resolved at runtime to a valid class, resolution of the bean fails when it is about to be created, which is during the `preInstantiateSingletons()` phase of an `ApplicationContext` for a non-lazy-init bean.
>
>   如果在运行时无法将该类解析为有效类，则在即将创建该 bean 时，该 bean 的解析将失败，这是在非惰性初始化 bean的 `ApplicationContext` 的  `preInstantiateSingletons()` 阶段。

##### Example: The `PropertyOverrideConfigurer`

The `PropertyOverrideConfigurer`, another bean factory post-processor, resembles the `PropertySourcesPlaceholderConfigurer`, but unlike the latter, the original definitions can have default values or no values at all for bean properties. If an overriding `Properties` file does not have an entry for a certain bean property, the default context definition is used.

Note that the bean definition is not aware of being overridden, so it is not immediately obvious from the XML definition file that the override configurer is being used. In case of multiple `PropertyOverrideConfigurer` instances that define different values for the same bean property, the last one wins, due to the overriding mechanism.

Properties file configuration lines take the following format:

另一个 bean 工厂后处理器  `PropertyOverrideConfigurer` 类似于 `PropertySourcesPlaceholderConfigurer`，但与后者不同的是，原始定义可以有默认值，也可以没有 bean 属性的值。如果重写的 `Properties` 文件没有特定 bean 属性的条目，则使用默认上下文定义。

请注意，bean 定义不知道被重写，因此从 XML 定义文件中看不出正在使用重写配置器。如果有多个 `PropertyOverrideConfigurer`  实例为同一个 bean 属性定义了不同的值，则由于覆盖机制，最后一个实例获胜。

属性文件配置行采用以下格式：

```properties
beanName.property=value
```

The following listing shows an example of the format:

以下列表显示了该格式的一个示例：

```properties
dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb
```

This example file can be used with a container definition that contains a bean called `dataSource` that has `driver` and `url` properties.

Compound property names are also supported, as long as every component of the path except the final property being overridden is already non-null (presumably initialized by the constructors). In the following example, the `sammy` property of the `bob` property of the `fred` property of the `tom` bean is set to the scalar value `123`:

此示例文件可与容器定义一起使用，该容器定义包含名为 `dataSource` 的 bean，该 bean 具有 `driver` 和  `url` 属性。

也支持复合属性名，只要路径的每个组件（被重写的最终属性除外）都已非 null（可能由构造函数初始化）。在下面的示例中，`tom` bean 的 `fred` 属性的 `bob` 属性的 `sammy` 属性设置为标量值 `123` ：

```properties
tom.fred.bob.sammy=123
```

> Specified override values are always literal values. They are not translated into bean references. This convention also applies when the original value in the XML bean definition specifies a bean reference.
>
> 指定的替代值始终为文字值。它们不会被翻译成 bean 引用。当 XML Bean 定义中的原始值指定 bean 引用时，此约定也适用。

With the `context` namespace introduced in Spring 2.5, it is possible to configure property overriding with a dedicated configuration element, as the following example shows:

通过 Spring 2.5 中引入的 `context` 命名空间，可以使用专用配置元素配置属性重写，如下例所示：

```xml
<context:property-override location="classpath:override.properties"/>
```

#### 1.8.3. Customizing Instantiation Logic with a `FactoryBean`

#### 1.8.3. 使用 `FactoryBean` 自定义实例化逻辑

You can implement the `org.springframework.beans.factory.FactoryBean` interface for objects that are themselves factories.

The `FactoryBean` interface is a point of pluggability into the Spring IoC container’s instantiation logic. If you have complex initialization code that is better expressed in Java as opposed to a (potentially) verbose amount of XML, you can create your own `FactoryBean`, write the complex initialization inside that class, and then plug your custom `FactoryBean` into the container.

The `FactoryBean<T>` interface provides three methods:

- `T getObject()`: Returns an instance of the object this factory creates. The instance can possibly be shared, depending on whether this factory returns singletons or prototypes.
- `boolean isSingleton()`: Returns `true` if this `FactoryBean` returns singletons or `false` otherwise. The default implementation of this method returns `true`.
- `Class<?> getObjectType()`: Returns the object type returned by the `getObject()` method or `null` if the type is not known in advance.

The `FactoryBean` concept and interface are used in a number of places within the Spring Framework. More than 50 implementations of the `FactoryBean` interface ship with Spring itself.

When you need to ask a container for an actual `FactoryBean` instance itself instead of the bean it produces, prefix the bean’s `id` with the ampersand symbol (`&`) when calling the `getBean()` method of the `ApplicationContext`. So, for a given `FactoryBean` with an `id` of `myBean`, invoking `getBean("myBean")` on the container returns the product of the `FactoryBean`, whereas invoking `getBean("&myBean")` returns the `FactoryBean` instance itself.

您可以为本身就是工厂的对象实现 `org.springframework.beans.factory.FactoryBean` 接口。

`FactoryBean` 接口是一个可插入 Spring IOC 容器实例化逻辑的点。如果您的复杂初始化代码更好地用 Java 表示，而不是（可能）冗长的 XML，那么您可以创建自己的 `FactoryBean`，在该类中编写复杂的初始化，然后将自定义的 `FactoryBean` 插入容器中。

`FactoryBean<T>` 接口提供了三种方法：

- `T getObject()`：返回此工厂创建的对象的实例。实例可能是共享的，这取决于此工厂返回的是单例还是原型。
- `boolean isSingleton()`：如果此 `FactoryBean` 返回 Singleton，则返回 `true`，否则返回`false`。此方法的默认实现返回 `true`。
- `Class<?> getObjectType()`：返回由 `getObject()` 方法返回的对象类型，如果事先不知道该类型，则返回`null`。

`FactoryBean` 概念和接口在 Spring 框架中的许多地方都有使用。`FactoryBean` 接口的 50 多个实现与 Spring 本身一起发布。

当需要向容器请求实际的 `FactoryBean` 实例本身而不是它生成的 bean 时，在调用 `ApplicationContext` 的 `getBean()` 方法时，在 bean 的 `id` 前面加上符号（`&`）。因此，对于一个 id 为 myBean 的给定 `FactoryBean`，在容器上调用 `getBean("myBean")` 将返回 `FactoryBean` 的产品，而调用 `getBean("&myBean")` 将返回 `FactoryBean` 实例本身。

### 1.9. Annotation-based Container Configuration

### 1.9. 基于注解的容器配置

> Are annotations better than XML for configuring Spring?
>
> The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. The short answer is “it depends.” The long answer is that each approach has its pros and cons, and, usually, it is up to the developer to decide which strategy suits them better. Due to the way they are defined, annotations provide a lot of context in their declaration, leading to shorter and more concise configuration. However, XML excels at wiring up components without touching their source code or recompiling them. Some developers prefer having the wiring close to the source while others argue that annotated classes are no longer POJOs and, furthermore, that the configuration becomes decentralized and harder to control.
>
> No matter the choice, Spring can accommodate both styles and even mix them together. It is worth pointing out that through its [JavaConfig](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java) option, Spring lets annotations be used in a non-invasive way, without touching the target components source code and that, in terms of tooling, all configuration styles are supported by the [Spring Tools for Eclipse](https://spring.io/tools).
>
> 在配置 Spring 时，注解比 XML 好吗？
> 基于注解的配置的引入提出了这样一个问题：这种方法是否比 XML “更好”。简单的回答是“视情况而定”长话短说，每种方法都有其优缺点，通常由开发人员决定哪种策略更适合他们。由于它们的定义方式，注解在其声明中提供了大量的上下文，从而使配置更短、更简洁。然而，XML 擅长在不接触源代码或重新编译的情况下连接组件。一些开发人员更喜欢让连接靠近源代码，而其他人则认为带注解的类不再是 POJO，而且配置变得分散，更难控制。
>
> 无论选择哪种，Spring 都可以容纳这两种风格，甚至可以将它们混合在一起。值得指出的是，通过其 [JavaConfig](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java) 选项，Spring 允许以非侵入性的方式使用注解，而无需触及目标组件源代码，而且就工具而言，[Spring Tools for Eclipse](https://spring.io/tools) 支持所有配置样式。

An alternative to XML setup is provided by annotation-based configuration, which relies on the bytecode metadata for wiring up components instead of angle-bracket declarations. Instead of using XML to describe a bean wiring, the developer moves the configuration into the component class itself by using annotations on the relevant class, method, or field declaration. As mentioned in [Example: The `AutowiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-bpp-examples-aabpp), using a `BeanPostProcessor` in conjunction with annotations is a common means of extending the Spring IoC container. For example, Spring 2.0 introduced the possibility of enforcing required properties with the [`@Required`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-required-annotation) annotation. Spring 2.5 made it possible to follow that same general approach to drive Spring’s dependency injection. Essentially, the `@Autowired` annotation provides the same capabilities as described in [Autowiring Collaborators](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire) but with more fine-grained control and wider applicability. Spring 2.5 also added support for JSR-250 annotations, such as `@PostConstruct` and `@PreDestroy`. Spring 3.0 added support for JSR-330 (Dependency Injection for Java) annotations contained in the `javax.inject` package such as `@Inject` and `@Named`. Details about those annotations can be found in the [relevant section](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-standard-annotations).

XML 设置的另一种选择是基于注解的配置，它依赖字节码元数据来连接组件，而不是尖括号声明。开发人员不是使用 XML 来描述 bean 连接，而是通过使用相关类、方法或字段声明上的注解将配置移动到组件类本身。如[示例：`AutowiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-bpp-examples-aabpp) 中所述，将 `BeanPostProcessor` 与注解结合使用是扩展 Spring IoC 容器的常用方法。例如，Spring 2.0 引入了使用 [`@Required`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-required-annotation)  注解强制执行必需属性的可能性。Spring 2.5 使得遵循相同的通用方法来驱动 Spring 的依赖注入成为可能。实际上，`@Autowired`  注解提供了与 [Autowired Collaborators](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire) 中所述相同的功能，但具有更细粒度的控制和更广泛的适用性。Spring 2.5 还增加了对 JSR-250 注解的支持，如 `@PostConstruct` 和 `@PreDestroy`。Spring 3.0 增加了对 `javax.inject` 包中包含的 JSR-330（Java 依赖注入）注解的支持。如 `@Inject` 和 `@Named`。有关这些注解的详细信息，请参见[相关章节](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-standard-annotations)。

> Annotation injection is performed before XML injection. Thus, the XML configuration overrides the annotations for properties wired through both approaches.
>
> 注解注入在 XML 注入之前执行。因此，XML 配置覆盖通过这两种方法连接的属性的注解。

As always, you can register the post-processors as individual bean definitions, but they can also be implicitly registered by including the following tag in an XML-based Spring configuration (notice the inclusion of the `context` namespace):

与往常一样，您可以将后处理器注册为单个 bean 定义，但也可以通过在基于 XML 的 Spring 配置中包含以下标记来隐式注册它们（请注意包含了`context`名称空间）：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

</beans>
```

The `<context:annotation-config/>` element implicitly registers the following post-processors:

`<context:annotation-config/>` 元素隐式注册以下后处理器：

- [`ConfigurationClassPostProcessor`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/annotation/ConfigurationClassPostProcessor.html)
- [`AutowiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html)
- [`CommonAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html)
- [`PersistenceAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html)
- [`EventListenerMethodProcessor`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/event/EventListenerMethodProcessor.html)

>   `<context:annotation-config/>` only looks for annotations on beans in the same application context in which it is defined. This means that, if you put `<context:annotation-config/>` in a `WebApplicationContext` for a `DispatcherServlet`, it only checks for `@Autowired` beans in your controllers, and not your services. See [The DispatcherServlet](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-servlet) for more information.
>
>   `<context:annotation-config/>` 只在定义 bean 的同一应用程序上下文中查找 bean 上的注解。这意味着，如果将 `<context:annotation-config/>` 放在 `DispatcherServlet` 的 `WebApplicationContext` 中，它只检查控制器中的 `@Autowired` bean，而不检查服务。有关更多信息，请参见[DispatcherServlet](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-servlet) 。

#### 1.9.1. @Required

The `@Required` annotation applies to bean property setter methods, as in the following example:

`@Required` 注解适用于 bean 属性 setter 方法，如下例所示：

```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

This annotation indicates that the affected bean property must be populated at configuration time, through an explicit property value in a bean definition or through autowiring. The container throws an exception if the affected bean property has not been populated. This allows for eager and explicit failure, avoiding `NullPointerException` instances or the like later on. We still recommend that you put assertions into the bean class itself (for example, into an init method). Doing so enforces those required references and values even when you use the class outside of a container.

此注解指示必须在配置时通过 bean 定义中的显式属性值或自动装配填充受影响的 bean 属性。如果未填充受影响的 bean 属性，容器将引发异常。这允许即时和显式失败，避免以后出现 `NullPointerException` 实例或类似情况。我们仍然建议您将断言放入 bean 类本身（例如，放入 init 方法）。即使在容器外部使用该类，这样做也会强制执行这些必需的引用和值。

>   The [`RequiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html) must be registered as a bean to enable support for the `@Required` annotation.
>
>   必须将[`RequiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html) 注册为 bean，才能支持 `@Required` 注解。

> The `@Required` annotation and `RequiredAnnotationBeanPostProcessor` are formally deprecated as of Spring Framework 5.1, in favor of using constructor injection for required settings (or a custom implementation of `InitializingBean.afterPropertiesSet()` or a custom `@PostConstruct` method along with bean property setter methods).
>
> 从 Spring Framework 5.1 开始，`@Required` 注解和 `RequiredAnnotationBeanPostProcessor` 就被正式弃用，取而代之的是对所需设置使用构造函数注入（或自定义实现`InitializingBean.afterPropertiesSet()` 或自定义的`@PostConstruct` 方法以及 bean 属性 setter 方法）。

#### 1.9.2. Using `@Autowired`

#### 1.9.2.使用 `@Autowired`

> JSR 330’s `@Inject` annotation can be used in place of Spring’s `@Autowired` annotation in the examples included in this section. See [here](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-standard-annotations) for more details.
>
> 在本节所包含的示例中，可以使用 JSR330 的 `@Inject` 注解代替 Spring 的 `@Autowired` 注解。有关更多详细信息，请参见[此处](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-standard-annotations) 。

You can apply the `@Autowired` annotation to constructors, as the following example shows:

您可以将 `@Autowired` 注解应用于构造函数，如下例所示：

```java
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

> As of Spring Framework 4.3, an `@Autowired` annotation on such a constructor is no longer necessary if the target bean defines only one constructor to begin with. However, if several constructors are available and there is no primary/default constructor, at least one of the constructors must be annotated with `@Autowired` in order to instruct the container which one to use. See the discussion on [constructor resolution](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-autowired-annotation-constructor-resolution) for details.
>
> 从 SpringFramework 4.3 开始，如果目标 bean 只定义了一个构造函数，则不再需要在这样的构造函数上添加 `@Autowired` 注解。但是，如果有多个构造函数可用，并且没有主/默认构造函数，则必须使用 `@Autowired` 注解至少一个构造函数，以便指示容器使用哪个构造函数。有关详细信息，请参阅关于[constructor resolution](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-autowired-annotation-constructor-resolution) 的讨论。

You can also apply the `@Autowired` annotation to *traditional* setter methods, as the following example shows:

您还可以将 `@Autowired` 注解应用于传统 setter 方法，如下例所示：

```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

You can also apply the annotation to methods with arbitrary names and multiple arguments, as the following example shows:

还可以将注解应用于具有任意名称和多个参数的方法，如下例所示：

```java
public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

You can apply `@Autowired` to fields as well and even mix it with constructors, as the following example shows:

您也可以将 `@Autowired` 应用于字段，甚至可以将其与构造函数混合使用，如下例所示：

```java
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    private MovieCatalog movieCatalog;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

>   Make sure that your target components (for example, `MovieCatalog` or `CustomerPreferenceDao`) are consistently declared by the type that you use for your `@Autowired`-annotated injection points. Otherwise, injection may fail due to a "no type match found" error at runtime.For XML-defined beans or component classes found via classpath scanning, the container usually knows the concrete type up front. However, for `@Bean` factory methods, you need to make sure that the declared return type is sufficiently expressive. For components that implement several interfaces or for components potentially referred to by their implementation type, consider declaring the most specific return type on your factory method (at least as specific as required by the injection points referring to your bean).
>
>   确保您的目标组件（例如，`MovieCatalog` 或 `CustomerReferenceDAO`）由您用于带`@Autowired`-注解的注入点的类型一致地声明。否则，注入可能会由于运行时出现「找不到类型匹配」错误而失败。对于通过类路径扫描找到的 XML 定义的 bean 或组件类，容器通常预先知道具体类型。但是，对于 `@Bean` 工厂方法，您需要确保声明的返回类型具有足够的表达能力。对于实现多个接口的组件或由其实现类型潜在引用的组件，考虑在工厂方法上声明最特定的返回类型（至少与注入 bean 所指的注入点所需的特定）。

You can also instruct Spring to provide all beans of a particular type from the `ApplicationContext` by adding the `@Autowired` annotation to a field or method that expects an array of that type, as the following example shows:

您还可以通过向需要该类型数组的字段或方法添加 `@Autowired` 注解，指示 Spring 从 `ApplicationContext` 提供特定类型的所有 bean，如下例所示：

```java
public class MovieRecommender {

    @Autowired
    private MovieCatalog[] movieCatalogs;

    // ...
}
```

The same applies for typed collections, as the following example shows:

这同样适用于类型化集合，如下例所示：

```java
public class MovieRecommender {

    private Set<MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}
```

> Your target beans can implement the `org.springframework.core.Ordered` interface or use the `@Order` or standard `@Priority` annotation if you want items in the array or list to be sorted in a specific order. Otherwise, their order follows the registration order of the corresponding target bean definitions in the container.You can declare the `@Order` annotation at the target class level and on `@Bean` methods, potentially for individual bean definitions (in case of multiple definitions that use the same bean class). `@Order` values may influence priorities at injection points, but be aware that they do not influence singleton startup order, which is an orthogonal concern determined by dependency relationships and `@DependsOn` declarations.Note that the standard `javax.annotation.Priority` annotation is not available at the `@Bean` level, since it cannot be declared on methods. Its semantics can be modeled through `@Order` values in combination with `@Primary` on a single bean for each type.
>
> 如果希望数组或列表中的项按特定顺序排序，则目标bean可以实现 `org.springframework.core.Ordered` 接口或使用 `@Order` 或标准的 `@Priority` 注解。否则，它们的顺序遵循容器中相应目标 bean 定义的注册顺序。您可以在目标类级别和`@Bean`方法上声明`@Order`注解，可能是针对单个 Bean 定义（如果多个定义使用同一 Bean 类）`@Order` 值可能会影响注入点的优先级，但请注意它们不会影响单例启动顺序，这是由依赖关系和 `@DependsOn` 声明确定的正交关注点。注意，标准的 `javax.annotation.Priority` 注解在 `@Bean` 级别不可用，因为它不能在方法上声明。它的语义可以通过每个类型的单个 bean 上的 `@Order` 值与 `@Primary` 组合来建模。

Even typed `Map` instances can be autowired as long as the expected key type is `String`. The map values contain all beans of the expected type, and the keys contain the corresponding bean names, as the following example shows:

即使键入的 `Map` 实例也可以自动装配，只要所需的键类型是 `String`。映射值包含预期类型的所有 bean，键包含相应的 bean 名称，如下例所示：

```java
public class MovieRecommender {

    private Map<String, MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}
```

By default, autowiring fails when no matching candidate beans are available for a given injection point. In the case of a declared array, collection, or map, at least one matching element is expected.

The default behavior is to treat annotated methods and fields as indicating required dependencies. You can change this behavior as demonstrated in the following example, enabling the framework to skip a non-satisfiable injection point through marking it as non-required (i.e., by setting the `required` attribute in `@Autowired` to `false`):

默认情况下，当给定注入点没有匹配的候选 bean 可用时，自动装配失败。对于声明的数组、集合或映射，至少需要一个匹配元素。

默认行为是将带注解的方法和字段视为指示所需的依赖项。您可以更改此行为，如以下示例所示，通过将不可满足的注入点标记为非必需（即，通过将 `@Autowired` 中的 `required` 属性设置为 `false`），使框架能够跳过该注入点：

```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired(required = false)
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

A non-required method will not be called at all if its dependency (or one of its dependencies, in case of multiple arguments) is not available. A non-required field will not get populated at all in such cases, leaving its default value in place.

Injected constructor and factory method arguments are a special case since the `required` attribute in `@Autowired` has a somewhat different meaning due to Spring’s constructor resolution algorithm that may potentially deal with multiple constructors. Constructor and factory method arguments are effectively required by default but with a few special rules in a single-constructor scenario, such as multi-element injection points (arrays, collections, maps) resolving to empty instances if no matching beans are available. This allows for a common implementation pattern where all dependencies can be declared in a unique multi-argument constructor — for example, declared as a single public constructor without an `@Autowired` annotation.

如果一个非必需的方法的依赖项（或者它的一个依赖项，在多个参数的情况下）不可用，则根本不会调用该方法。在这种情况下，将根本不会填充非必填字段，保留其默认值。

注入的构造函数和工厂方法参数是一种特殊情况，因为 `@Autowired` 中的 `required` 属性的含义有所不同，因为 Spring 的构造函数解析算法可能会处理多个构造函数。默认情况下，构造函数和工厂方法参数实际上是必需的，但在单个构造函数场景中有一些特殊规则，例如，如果没有匹配的 bean 可用，多元素注入点（数组、集合、映射）将解析为空实例。这允许使用一种通用的实现模式，其中所有依赖项都可以在一个唯一的多参数构造函数中声明—例如，声明为一个公共构造函数，而无需 `@Autowired` 注解。

>   Only one constructor of any given bean class may declare `@Autowired` with the `required` attribute set to `true`, indicating *the* constructor to autowire when used as a Spring bean. As a consequence, if the `required` attribute is left at its default value `true`, only a single constructor may be annotated with `@Autowired`. If multiple constructors declare the annotation, they will all have to declare `required=false` in order to be considered as candidates for autowiring (analogous to `autowire=constructor` in XML). The constructor with the greatest number of dependencies that can be satisfied by matching beans in the Spring container will be chosen. If none of the candidates can be satisfied, then a primary/default constructor (if present) will be used. Similarly, if a class declares multiple constructors but none of them is annotated with `@Autowired`, then a primary/default constructor (if present) will be used. If a class only declares a single constructor to begin with, it will always be used, even if not annotated. Note that an annotated constructor does not have to be public.The `required` attribute of `@Autowired` is recommended over the deprecated `@Required` annotation on setter methods. Setting the `required` attribute to `false` indicates that the property is not required for autowiring purposes, and the property is ignored if it cannot be autowired. `@Required`, on the other hand, is stronger in that it enforces the property to be set by any means supported by the container, and if no value is defined, a corresponding exception is raised.
>
>   任何给定 bean 类中只有一个构造函数可以声明 `@Autowired`，并将 `required` 属性设置为 `true`，表示用作 Spring bean 时要自动装配的构造函数。因此，如果 `required` 属性保留为其默认值 `true`，则只有一个构造函数可以用 `@Autowired` 注解。如果多个构造函数声明注解，它们都必须声明 `required=false`，才能被视为自动装配的候选对象（类似于 XML 中的 `autowire=constructor`。将选择具有通过在 Spring 容器中匹配 bean 所能满足的最大数量依赖项的构造函数。如果没有一个候选者能够满足要求，那么将使用主/默认构造函数（如果存在）。类似地，如果一个类声明了多个构造函数，但没有一个用 `@Autowired` 注解，那么将使用主/默认构造函数（如果存在）。如果一个类一开始只声明一个构造函数，那么它将始终被使用，即使没有注解。请注意，带注解的构造函数不必是公共的。建议使用 `@Autowired`的 `required` 属性，而不是 setter 方法上不推荐使用的 `@Required` 注解。将 `required` 属性设置为 `false` 表示自动装配不需要该属性，如果无法自动装配，则忽略该属性，另一方面，`@Required`更强大，因为它强制通过容器支持的任何方式设置属性，如果没有定义值，则会引发相应的异常。

Alternatively, you can express the non-required nature of a particular dependency through Java 8’s `java.util.Optional`, as the following example shows:

或者，您可以通过 Java 8 的 `java.util.Optional` 来表示特定依赖项的非必需性质，如下例所示：

```java
public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(Optional<MovieFinder> movieFinder) {
        ...
    }
}
```

As of Spring Framework 5.0, you can also use a `@Nullable` annotation (of any kind in any package — for example, `javax.annotation.Nullable` from JSR-305) or just leverage Kotlin builtin null-safety support:

从 Spring Framework 5.0 开始，您还可以使用 `@Nullable` 注解（任何包中的任何类型） — 例如，JSR-305 中的 `javax.annotation.Nullable` 或仅仅利用 Kotlin 内置的空安全支持：

```java
public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        ...
    }
}
```

You can also use `@Autowired` for interfaces that are well-known resolvable dependencies: `BeanFactory`, `ApplicationContext`, `Environment`, `ResourceLoader`, `ApplicationEventPublisher`, and `MessageSource`. These interfaces and their extended interfaces, such as `ConfigurableApplicationContext` or `ResourcePatternResolver`, are automatically resolved, with no special setup necessary. The following example autowires an `ApplicationContext` object:

您还可以将 `@Autowired` 用于众所周知的可解析依赖项接口： `BeanFactory`、`ApplicationContext`、`Environment`、`ResourceLoader`、`ApplicationEventPublisher` 和 `MessageSource`。这些接口及其扩展接口（如 `ConfigurableApplicationContext` 或 `ResourcePatternResolver`）是自动解析的，无需特殊设置。以下示例自动装配 `ApplicationContext` 对象：

```java
public class MovieRecommender {

    @Autowired
    private ApplicationContext context;

    public MovieRecommender() {
    }

    // ...
}
```

> The `@Autowired`, `@Inject`, `@Value`, and `@Resource` annotations are handled by Spring `BeanPostProcessor` implementations. This means that you cannot apply these annotations within your own `BeanPostProcessor` or `BeanFactoryPostProcessor` types (if any). These types must be 'wired up' explicitly by using XML or a Spring `@Bean` method.
>
> `@Autowired`, `@Inject`, `@Value`, 和 `@Resource` 注解由 Spring `BeanPostProcessor` 实现处理。这意味着您不能在自己的 `BeanPostProcessor` 或 `BeanPactoryPostProcessor` 类型（如果有）中应用这些注解。这些类型必须使用 XML 或Spring `@Bean` 方法显式地「连接」。

#### 1.9.3. Fine-tuning Annotation-based Autowiring with `@Primary`

#### 1.9.3. 使用 `@Primary` 微调基于注解的自动装配

Because autowiring by type may lead to multiple candidates, it is often necessary to have more control over the selection process. One way to accomplish this is with Spring’s `@Primary` annotation. `@Primary` indicates that a particular bean should be given preference when multiple beans are candidates to be autowired to a single-valued dependency. If exactly one primary bean exists among the candidates, it becomes the autowired value.

Consider the following configuration that defines `firstMovieCatalog` as the primary `MovieCatalog`:

由于按类型自动装配可能导致多个候选项，因此通常需要对选择过程进行更多控制。实现这一点的一种方法是使用 Spring 的`@Primary` 注解，`@Primary` 表示当多个 bean 是自动装配到单值依赖项的候选 bean 时，应优先考虑特定 bean。如果候选者中只存在一个主 bean，那么它将成为自动装配的值。

考虑下面的配置，将`firstMovieCatalog` 定义为主要的 `MovieCatalog`：

```java
@Configuration
public class MovieConfiguration {

    @Bean
    @Primary
    public MovieCatalog firstMovieCatalog() { ... }

    @Bean
    public MovieCatalog secondMovieCatalog() { ... }

    // ...
}
```

With the preceding configuration, the following `MovieRecommender` is autowired with the `firstMovieCatalog`:

在前面的配置中，以下 `MovieRecommender` 与 `firstMovieCatalog` 自动装配：

```java
public class MovieRecommender {

    @Autowired
    private MovieCatalog movieCatalog;

    // ...
}
```

The corresponding bean definitions follow:

相应的 bean 定义如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <bean class="example.SimpleMovieCatalog" primary="true">
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean id="movieRecommender" class="example.MovieRecommender"/>

</beans>
```

#### 1.9.4. Fine-tuning Annotation-based Autowiring with Qualifiers

#### 1.9.4. 使用限定符微调基于注解的自动装配

`@Primary` is an effective way to use autowiring by type with several instances when one primary candidate can be determined. When you need more control over the selection process, you can use Spring’s `@Qualifier` annotation. You can associate qualifier values with specific arguments, narrowing the set of type matches so that a specific bean is chosen for each argument. In the simplest case, this can be a plain descriptive value, as shown in the following example:

`@Primary`是一种有效的方法，可以在多个实例中使用按类型自动装配，同时可以确定一个主要候选对象。当您需要更多地控制选择过程时，可以使用 Spring 的 `@Qualifier` 注解。您可以将限定符值与特定参数相关联，从而缩小类型匹配集，以便为每个参数选择特定的 bean。在最简单的情况下，这可以是一个简单的描述性值，如以下示例所示：

```java
public class MovieRecommender {

    @Autowired
    @Qualifier("main")
    private MovieCatalog movieCatalog;

    // ...
}
```

You can also specify the `@Qualifier` annotation on individual constructor arguments or method parameters, as shown in the following example:

您还可以在单个构造函数参数或方法参数上指定 `@Qualifier` 注解，如以下示例所示：

```java
public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(@Qualifier("main") MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

The following example shows corresponding bean definitions.

下面的示例显示了相应的 bean 定义。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <bean class="example.SimpleMovieCatalog">
        <qualifier value="main"/>  <!--注释一-->

        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <qualifier value="action"/>   <!--注释二-->

        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean id="movieRecommender" class="example.MovieRecommender"/>

</beans>
```

注释一：The bean with the `main` qualifier value is wired with the constructor argument that is qualified with the same value.

注释二：The bean with the action qualifier value is wired with the constructor argument that is qualified with the same value.

注释一：具有 `main` 限定符值的 bean 与使用相同值限定的构造函数参数连接。
注释二：具有 `action` 限定符值的 bean 与使用相同值限定的构造函数参数连接。

For a fallback match, the bean name is considered a default qualifier value. Thus, you can define the bean with an `id` of `main` instead of the nested qualifier element, leading to the same matching result. However, although you can use this convention to refer to specific beans by name, `@Autowired` is fundamentally about type-driven injection with optional semantic qualifiers. This means that qualifier values, even with the bean name fallback, always have narrowing semantics within the set of type matches. They do not semantically express a reference to a unique bean `id`. Good qualifier values are `main` or `EMEA` or `persistent`, expressing characteristics of a specific component that are independent from the bean `id`, which may be auto-generated in case of an anonymous bean definition such as the one in the preceding example.

Qualifiers also apply to typed collections, as discussed earlier — for example, to `Set<MovieCatalog>`. In this case, all matching beans, according to the declared qualifiers, are injected as a collection. This implies that qualifiers do not have to be unique. Rather, they constitute filtering criteria. For example, you can define multiple `MovieCatalog` beans with the same qualifier value “action”, all of which are injected into a `Set<MovieCatalog>` annotated with `@Qualifier("action")`.

对于回退匹配，bean 名称被视为默认限定符值。因此，您可以使用 `id` 为 `main` 而不是嵌套的限定符元素来定义 bean，从而得到相同的匹配结果。然而，尽管您可以使用此约定按名称引用特定bean，`@Autowired`基本上是关于带有可选语义限定符的类型驱动注入的。这意味着，即使有 bean 名称回退，限定符值在类型匹配集合中也总是具有狭义语义。它们不在语义上表示对唯一bean `id` 的引用。好的限定符值是 `main` 或 `EMEA` 或 `persistent`，表示独立于 bean `id`的特定组件的特征，在匿名 bean 定义（如上例中的定义）的情况下，可以自动生成这些特征。

限定符也适用于类型化集合，如前所述 — 例如，设置为 `Set<MovieCatalog>`。在本例中，根据声明的限定符，所有匹配的bean都作为一个集合注入。这意味着限定符不必是唯一的。相反，它们构成了过滤标准。例如，您可以使用相同的限定符值 `action` 定义多个 `MovieCatalog ` bean，所有这些 bean 都被注入到带有 `@Qualifier("action")` 注解的 `Set<MovieCatalog>` 中。

>   Letting qualifier values select against target bean names, within the type-matching candidates, does not require a `@Qualifier` annotation at the injection point. If there is no other resolution indicator (such as a qualifier or a primary marker), for a non-unique dependency situation, Spring matches the injection point name (that is, the field name or parameter name) against the target bean names and chooses the same-named candidate, if any.
>
>   让限定符值在类型匹配候选者中根据目标 bean 名称进行选择，不需要在注入点处使用 `@Qualifier` 注解。如果没有其他解析指示符（如限定符或主标记），对于非唯一依赖项情况，Spring 将注入点名称（即字段名或参数名）与目标 bean 名称匹配，并选择相同的命名候选项（如果有）。

That said, if you intend to express annotation-driven injection by name, do not primarily use `@Autowired`, even if it is capable of selecting by bean name among type-matching candidates. Instead, use the JSR-250 `@Resource` annotation, which is semantically defined to identify a specific target component by its unique name, with the declared type being irrelevant for the matching process. `@Autowired` has rather different semantics: After selecting candidate beans by type, the specified `String` qualifier value is considered within those type-selected candidates only (for example, matching an `account` qualifier against beans marked with the same qualifier label).

For beans that are themselves defined as a collection, `Map`, or array type, `@Resource` is a fine solution, referring to the specific collection or array bean by unique name. That said, as of 4.3, you can match collection, `Map`, and array types through Spring’s `@Autowired` type matching algorithm as well, as long as the element type information is preserved in `@Bean` return type signatures or collection inheritance hierarchies. In this case, you can use qualifier values to select among same-typed collections, as outlined in the previous paragraph.

As of 4.3, `@Autowired` also considers self references for injection (that is, references back to the bean that is currently injected). Note that self injection is a fallback. Regular dependencies on other components always have precedence. In that sense, self references do not participate in regular candidate selection and are therefore in particular never primary. On the contrary, they always end up as lowest precedence. In practice, you should use self references as a last resort only (for example, for calling other methods on the same instance through the bean’s transactional proxy). Consider factoring out the affected methods to a separate delegate bean in such a scenario. Alternatively, you can use `@Resource`, which may obtain a proxy back to the current bean by its unique name.

这就是说，如果您打算通过名称来表示注解驱动的注入，那么不要主要使用 `@Autowired`，即使它能够通过 bean 名称在类型匹配候选者中进行选择。相反，使用JSR-250`@Resource`注解，该注解在语义上定义为通过其唯一名称标识特定的目标组件，声明的类型与匹配过程无关`@Autowired`具有完全不同的语义：在按类型选择候选 bean 之后，指定的 `String` 限定符值仅在那些类型选择的候选 bean 中考虑（例如，将 `account` 限定符与标记有相同限定符标签的 bean 相匹配）。

对于本身定义为集合、`Map` 或数组类型的 bean，`@Resource` 是一个很好的解决方案，通过唯一的名称引用特定的集合或数组 bean。也就是说，从 4.3 开始，您还可以通过 Spring 的 `@Autowired` 类型匹配算法匹配集合、`Map` 和数组类型，只要元素类型信息保留在 `@Bean` 返回类型签名或集合继承层次结构中。在这种情况下，您可以使用限定符值在相同类型的集合中进行选择，如前一段所述。

从 4.3 开始，`@Autowired` 还考虑注入的自引用（即，引用回当前注入的 bean）。请注意，自注入是一种退路。对其他组件的常规依赖始终具有优先权。从这个意义上说，自我推荐不参与常规的候选人选择，因此，特别是从来不是主要的。相反，它们总是以最低优先级结束。实际上，您应该使用自引用作为最后手段（例如，通过 bean 的事务代理在同一实例上调用其他方法）。考虑在这种情况下将受影响的方法分解为单独的委托bean。或者，您可以使用 `@Resource`，它可以通过其唯一的名称获取一个返回到当前 bean 的代理。

> Trying to inject the results from `@Bean` methods on the same configuration class is effectively a self-reference scenario as well. Either lazily resolve such references in the method signature where it is actually needed (as opposed to an autowired field in the configuration class) or declare the affected `@Bean` methods as `static`, decoupling them from the containing configuration class instance and its lifecycle. Otherwise, such beans are only considered in the fallback phase, with matching beans on other configuration classes selected as primary candidates instead (if available).
>
> 尝试在同一配置类上注入来自 `@Bean` 方法的结果实际上也是一种自引用场景。要么在实际需要的方法签名中惰性地解析此类引用（与配置类中的自动装配字段相反），要么将受影响的 `@Bean` 方法声明为 `static`，将它们与包含的配置类实例及其生命周期分离。否则，只有在回退阶段才会考虑这些 bean，而选择其他配置类上的匹配 bean 作为主要候选项（如果可用）。

`@Autowired` applies to fields, constructors, and multi-argument methods, allowing for narrowing through qualifier annotations at the parameter level. In contrast, `@Resource` is supported only for fields and bean property setter methods with a single argument. As a consequence, you should stick with qualifiers if your injection target is a constructor or a multi-argument method.

You can create your own custom qualifier annotations. To do so, define an annotation and provide the `@Qualifier` annotation within your definition, as the following example shows:

`@Autowired` 适用于字段、构造函数和多参数方法，允许在参数级别通过限定符注解缩小范围。相比之下， `@Resource` 只支持带有单个参数的字段和 bean 属性 setter 方法。因此，如果注入目标是构造函数或多参数方法，则应该使用限定符。

您可以创建自己的自定义限定符注解。为此，请定义一个注解，并在定义中提供 `@Qualifier` 注解，如下例所示：

```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Genre {

    String value();
}
```

Then you can provide the custom qualifier on autowired fields and parameters, as the following example shows:

然后，您可以提供自动装配字段和参数的自定义限定符，如下例所示：

```java
public class MovieRecommender {

    @Autowired
    @Genre("Action")
    private MovieCatalog actionCatalog;

    private MovieCatalog comedyCatalog;

    @Autowired
    public void setComedyCatalog(@Genre("Comedy") MovieCatalog comedyCatalog) {
        this.comedyCatalog = comedyCatalog;
    }

    // ...
}
```

Next, you can provide the information for the candidate bean definitions. You can add `<qualifier/>` tags as sub-elements of the `<bean/>` tag and then specify the `type` and `value` to match your custom qualifier annotations. The type is matched against the fully-qualified class name of the annotation. Alternately, as a convenience if no risk of conflicting names exists, you can use the short class name. The following example demonstrates both approaches:

接下来，您可以提供候选 bean 定义的信息。您可以添加 `<qualifier/>` 标记作为 `<bean/>` 标记的子元素，然后指定 `type` 和 `value` 以匹配您的自定义限定符注解。类型与注解的完全限定类名匹配。或者，为了方便起见，如果不存在名称冲突的风险，可以使用短类名。以下示例演示了这两种方法：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <bean class="example.SimpleMovieCatalog">
        <qualifier type="Genre" value="Action"/>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <qualifier type="example.Genre" value="Comedy"/>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean id="movieRecommender" class="example.MovieRecommender"/>

</beans>
```

In [Classpath Scanning and Managed Components](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-classpath-scanning), you can see an annotation-based alternative to providing the qualifier metadata in XML. Specifically, see [Providing Qualifier Metadata with Annotations](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-scanning-qualifiers).

In some cases, using an annotation without a value may suffice. This can be useful when the annotation serves a more generic purpose and can be applied across several different types of dependencies. For example, you may provide an offline catalog that can be searched when no Internet connection is available. First, define the simple annotation, as the following example shows:

在 [Classpath Scanning and Managed Components](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-classpath-scanning) 中，您可以看到一个基于注解的替代方案，以 XML 形式提供限定符元数据。具体请参见[提供带注解的限定符元数据](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-scanning-qualifiers)。

在某些情况下，使用不带值的注解可能就足够了。当注解用于更一般的目的，并且可以应用于多种不同类型的依赖项时，这可能很有用。例如，您可以提供一个脱机目录，在没有可用的 Internet 连接时可以对其进行搜索。首先，定义简单注解，如下例所示：

```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Offline {

}
```

Then add the annotation to the field or property to be autowired, as shown in the following example:

然后将注解添加到要自动装配的字段或属性，如以下示例所示：

```java
public class MovieRecommender {

    @Autowired
    @Offline  // This line adds the `@Offline` annotation.
    private MovieCatalog offlineCatalog;

    // ...
}
```

Now the bean definition only needs a qualifier `type`, as shown in the following example:

现在，bean 定义只需要一个限定符 `type`，如下例所示：

```xml
<bean class="example.SimpleMovieCatalog">
    <qualifier type="Offline"/>     <!--This element specifies the qualifier.-->
    <!-- inject any dependencies required by this bean -->
</bean>
```

You can also define custom qualifier annotations that accept named attributes in addition to or instead of the simple `value` attribute. If multiple attribute values are then specified on a field or parameter to be autowired, a bean definition must match all such attribute values to be considered an autowire candidate. As an example, consider the following annotation definition:

您还可以定义自定义限定符注解，这些注解除了或代替简单的 `value` 属性之外，还接受命名属性。如果在要自动装配的字段或参数上指定了多个属性值，则 bean 定义必须匹配所有此类属性值，才能被视为自动装配候选。作为一个例子，考虑下面的注解定义：

```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface MovieQualifier {

    String genre();

    Format format();
}
```

In this case `Format` is an enum, defined as follows:

在本例中，`Format` 是一个枚举，定义如下：

```java
public enum Format {
    VHS, DVD, BLURAY
}
```

The fields to be autowired are annotated with the custom qualifier and include values for both attributes: `genre` and `format`, as the following example shows:

要自动装配的字段使用自定义限定符进行注解，并包含两个属性的值：`genre`和`format`，如下例所示：

```java
public class MovieRecommender {

    @Autowired
    @MovieQualifier(format=Format.VHS, genre="Action")
    private MovieCatalog actionVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.VHS, genre="Comedy")
    private MovieCatalog comedyVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.DVD, genre="Action")
    private MovieCatalog actionDvdCatalog;

    @Autowired
    @MovieQualifier(format=Format.BLURAY, genre="Comedy")
    private MovieCatalog comedyBluRayCatalog;

    // ...
}
```

Finally, the bean definitions should contain matching qualifier values. This example also demonstrates that you can use bean meta attributes instead of the `<qualifier/>` elements. If available, the `<qualifier/>` element and its attributes take precedence, but the autowiring mechanism falls back on the values provided within the `<meta/>` tags if no such qualifier is present, as in the last two bean definitions in the following example:

最后，bean 定义应该包含匹配的限定符值。这个例子还演示了可以使用 bean 元属性而不是 `<qualifier/>` 元素。如果可用， `<qualifier/>` 元素及其属性优先，但如果不存在这样的限定符，则自动装配机制依赖于 `<meta/>` 标记中提供的值，如以下示例中的最后两个 bean 定义：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <bean class="example.SimpleMovieCatalog">
        <qualifier type="MovieQualifier">
            <attribute key="format" value="VHS"/>
            <attribute key="genre" value="Action"/>
        </qualifier>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <qualifier type="MovieQualifier">
            <attribute key="format" value="VHS"/>
            <attribute key="genre" value="Comedy"/>
        </qualifier>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <meta key="format" value="DVD"/>
        <meta key="genre" value="Action"/>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <meta key="format" value="BLURAY"/>
        <meta key="genre" value="Comedy"/>
        <!-- inject any dependencies required by this bean -->
    </bean>

</beans>
```

#### 1.9.5. Using Generics as Autowiring Qualifiers

#### 1.9.5. 使用泛型作为自动装配限定符

In addition to the `@Qualifier` annotation, you can use Java generic types as an implicit form of qualification. For example, suppose you have the following configuration:

除了 `@Qualifier` 注解外，还可以使用 Java 泛型类型作为隐式限定形式。例如，假设您有以下配置：

```java
@Configuration
public class MyConfiguration {

    @Bean
    public StringStore stringStore() {
        return new StringStore();
    }

    @Bean
    public IntegerStore integerStore() {
        return new IntegerStore();
    }
}
```

Assuming that the preceding beans implement a generic interface, (that is, `Store<String>` and `Store<Integer>`), you can `@Autowire` the `Store` interface and the generic is used as a qualifier, as the following example shows:

假设前面的 bean 实现了一个泛型接口（即，`Store<String>`和`Store<Integer>`），您可以 `@Autowire` `Store`接口，泛型用作限定符，如下例所示：

```java
@Autowired
private Store<String> s1; // <String> qualifier, injects the stringStore bean

@Autowired
private Store<Integer> s2; // <Integer> qualifier, injects the integerStore bean
```

Generic qualifiers also apply when autowiring lists, `Map` instances and arrays. The following example autowires a generic `List`:

当自动关联列表、`Map` 实例和数组时，通用限定符也适用。以下示例自动装配一个通用的 `List`：

```java
// Inject all Store beans as long as they have an <Integer> generic
// Store<String> beans will not appear in this list
@Autowired
private List<Store<Integer>> s;
```

#### 1.9.6. Using `CustomAutowireConfigurer`

#### 1.9.6. 使用 `CustomAutowireConfigurer`

[`CustomAutowireConfigurer`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html) is a `BeanFactoryPostProcessor` that lets you register your own custom qualifier annotation types, even if they are not annotated with Spring’s `@Qualifier` annotation. The following example shows how to use `CustomAutowireConfigurer`:

[`CustomAutowireConfigurer`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html) 是一个 `BeanFactoryPostProcessor`，允许您注册自己的自定义限定符注解类型，即使它们没有使用 Spring 的 `@Qualifier` 注解进行注解。以下示例显示了如何使用 `CustomAutowireConfigurer`：

```xml
<bean id="customAutowireConfigurer"
        class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer">
    <property name="customQualifierTypes">
        <set>
            <value>example.CustomQualifier</value>
        </set>
    </property>
</bean>
```

The `AutowireCandidateResolver` determines autowire candidates by:

- The `autowire-candidate` value of each bean definition
- Any `default-autowire-candidates` patterns available on the `<beans/>` element
- The presence of `@Qualifier` annotations and any custom annotations registered with the `CustomAutowireConfigurer`

When multiple beans qualify as autowire candidates, the determination of a “primary” is as follows: If exactly one bean definition among the candidates has a `primary` attribute set to `true`, it is selected.

`AutowireCandidateResolver` 通过以下方式确定 autowire 候选对象：

- 每个 bean 定义的 `autowire-candidate` 值
- `<beans/>` 元素上提供的任何 `default-autowire-candidates`  模式
- `@Qualifier` 注解和任何在 `CustomAutowireConfigurer` 注册的自定义注解的存在

当多个 bean 符合 autowire 候选条件时，对  primary  的确定如下：如果候选项中恰好有一个 bean 定义的 `primary` 属性设置为 `true` ，则选择它。

#### 1.9.7. Injection with `@Resource`

#### 1.9.7. 使用 `@Resource` 注入

Spring also supports injection by using the JSR-250 `@Resource` annotation (`javax.annotation.Resource`) on fields or bean property setter methods. This is a common pattern in Java EE: for example, in JSF-managed beans and JAX-WS endpoints. Spring supports this pattern for Spring-managed objects as well.

`@Resource` takes a name attribute. By default, Spring interprets that value as the bean name to be injected. In other words, it follows by-name semantics, as demonstrated in the following example:

Spring 还通过在字段或 bean 属性 setter 方法上使用 JSR-250 `@Resource` 注解（`javax.annotation.Resource`）来支持注入。这是 JavaEE 中的一种常见模式：例如，在 JSF 管理的 bean 和 JAX-WS 端点中。Spring 也支持 Spring 管理的对象的这种模式。

`@Resource` 具有 name 属性。默认情况下，Spring 将该值解释为要注入的 bean 名称。换句话说，它遵循名称语义，如下例所示：

```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource(name="myMovieFinder")  // This line injects a `@Resource`.
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
```

If no name is explicitly specified, the default name is derived from the field name or setter method. In case of a field, it takes the field name. In case of a setter method, it takes the bean property name. The following example is going to have the bean named `movieFinder` injected into its setter method:

如果没有明确指定名称，则默认名称是从字段名或 setter 方法派生的。如果是字段，则使用字段名。对于 setter 方法，它采用bean 属性名。下面的示例将把名为 `movieFinder` 的 bean 注入其 setter 方法：

```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
```

> The name provided with the annotation is resolved as a bean name by the `ApplicationContext` of which the `CommonAnnotationBeanPostProcessor` is aware. The names can be resolved through JNDI if you configure Spring’s [`SimpleJndiBeanFactory`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/jndi/support/SimpleJndiBeanFactory.html) explicitly. However, we recommend that you rely on the default behavior and use Spring’s JNDI lookup capabilities to preserve the level of indirection.
>
> 注解提供的名称由 `CommonAnnotationBeanPostProcessor` 知道的 `ApplicationContext` 解析为 bean 名称。如果显式配置 Spring 的 [`SimpleJndiBeanFactory`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/jndi/support/SimpleJndiBeanFactory.html)，则可以通过 JNDI 解析这些名称。但是，我们建议您依赖默认行为，并使用Spring 的 JNDI 查找功能来保持间接寻址级别。

In the exclusive case of `@Resource` usage with no explicit name specified, and similar to `@Autowired`, `@Resource` finds a primary type match instead of a specific named bean and resolves well known resolvable dependencies: the `BeanFactory`, `ApplicationContext`, `ResourceLoader`, `ApplicationEventPublisher`, and `MessageSource` interfaces.

Thus, in the following example, the `customerPreferenceDao` field first looks for a bean named "customerPreferenceDao" and then falls back to a primary type match for the type `CustomerPreferenceDao`:

在没有指定显式名称的 `@Resource` 用法的排他性情况下，与 `@Autowired` 类似，`@Resource` 找到一个主要类型匹配，而不是一个特定的命名 bean，并解析众所周知的可解析依赖项： `BeanFactory`、`ApplicationContext`、`ResourceLoader`、`ApplicationEventPublisher` 和 `MessageSource` 接口。

因此，在下面的示例中，`customerPreferenceDao` 字段首先查找名为 「customerPreferenceDao」的 bean，然后返回到与类型 `CustomerPreferenceDao` 匹配的主类型：==这里还要验证 Bean 类型？不仅仅为 name 吗？==

```java
public class MovieRecommender {

    @Resource
    private CustomerPreferenceDao customerPreferenceDao;

    // The `context` field is injected based on the known resolvable dependency type: `ApplicationContext`.
    @Resource
    private ApplicationContext context; 

    public MovieRecommender() {
    }

    // ...
}
```

#### 1.9.8. Using `@Value`

#### 1.9.8 使用 `@Value`

`@Value` is typically used to inject externalized properties:

`@Value`通常用于注入外部化属性：

```java
@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name}") String catalog) {
        this.catalog = catalog;
    }
}
```

With the following configuration:

使用以下配置：

```java
@Configuration
@PropertySource("classpath:application.properties")
public class AppConfig { }
```

And the following `application.properties` file:

以及以下  `application.properties` 文件：

```java
catalog.name=MovieCatalog
```

In that case, the `catalog` parameter and field will be equal to the `MovieCatalog` value.

A default lenient embedded value resolver is provided by Spring. It will try to resolve the property value and if it cannot be resolved, the property name (for example `${catalog.name}`) will be injected as the value. If you want to maintain strict control over nonexistent values, you should declare a `PropertySourcesPlaceholderConfigurer` bean, as the following example shows:

在这种情况下，`catalog` 参数和字段将等于`MovieCatalog` 值。

Spring 提供了默认的宽松嵌入值解析器。它将尝试解析属性值，如果无法解析，则会将属性名称（例如`${catalog.name}`）作为值注入。如果希望对不存在的值保持严格控制，应该声明一个 `PropertySourcesPlaceholderConfigurer`bean，如下例所示：

```java
@Configuration
public class AppConfig {

    @Bean
    public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {
        return new PropertySourcesPlaceholderConfigurer();
    }
}
```

> When configuring a `PropertySourcesPlaceholderConfigurer` using JavaConfig, the `@Bean` method must be `static`.
>
> 当使用 JavaConfig 配置 `PropertySourcesPlaceholderConfigurer` 时，`@Bean` 方法必须是“静态”的。

Using the above configuration ensures Spring initialization failure if any `${}` placeholder could not be resolved. It is also possible to use methods like `setPlaceholderPrefix`, `setPlaceholderSuffix`, or `setValueSeparator` to customize placeholders.

如果无法解析任何 `${}` 占位符，使用上述配置将确保 Spring 初始化失败。还可以使用诸如 `setPlaceholderPrefix`、`setPlaceholderSuffix` 或 `setValueSeparator` 之类的方法来自定义占位符。

> Spring Boot configures by default a `PropertySourcesPlaceholderConfigurer` bean that will get properties from `application.properties` and `application.yml` files.
>
> Spring Boot 默认配置一个 `PropertySourcesplaceConfigurer` bean，该 bean 将从 `application.properties` 和 `application.yml` 文件中获取属性。

Built-in converter support provided by Spring allows simple type conversion (to `Integer` or `int` for example) to be automatically handled. Multiple comma-separated values can be automatically converted to `String` array without extra effort.

It is possible to provide a default value as following:

Spring 提供的内置转换器支持允许自动处理简单的类型转换（例如到 `Integer` 或 `int`。多个逗号分隔的值可以自动转换为 `String` 数组，无需额外努力。

可以提供如下默认值：

```java
@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name:defaultCatalog}") String catalog) {
        this.catalog = catalog;
    }
}
```

A Spring `BeanPostProcessor` uses a `ConversionService` behind the scenes to handle the process for converting the `String` value in `@Value` to the target type. If you want to provide conversion support for your own custom type, you can provide your own `ConversionService` bean instance as the following example shows:

Spring 的 `BeanPostProcessor` 在后台使用 `ConversionService` 来处理将 `@value` 中的 `String` 值转换为目标类型的过程。如果您想为自己的自定义类型提供转换支持，可以提供自己的 `ConversionService` bean 实例，如下例所示：

```java
@Configuration
public class AppConfig {

    @Bean
    public ConversionService conversionService() {
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
        conversionService.addConverter(new MyCustomConverter());
        return conversionService;
    }
}
```

When `@Value` contains a [`SpEL` expression](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions) the value will be dynamically computed at runtime as the following example shows:

当 `@Value` 包含[`SpEL`表达式](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions) 时，将在运行时动态计算该值，如下例所示：

```java
@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("#{systemProperties['user.catalog'] + 'Catalog' }") String catalog) {
        this.catalog = catalog;
    }
}
```

SpEL also enables the use of more complex data structures:

SpEL 还支持使用更复杂的数据结构：

```java
@Component
public class MovieRecommender {

    private final Map<String, Integer> countOfMoviesPerCatalog;

    public MovieRecommender(
            @Value("#{{'Thriller': 100, 'Comedy': 300}}") Map<String, Integer> countOfMoviesPerCatalog) {
        this.countOfMoviesPerCatalog = countOfMoviesPerCatalog;
    }
}
```

#### 1.9.9. Using `@PostConstruct` and `@PreDestroy`

#### 1.9.9. 使用 `@PostConstruct` 和 `@PreDestroy`

The `CommonAnnotationBeanPostProcessor` not only recognizes the `@Resource` annotation but also the JSR-250 lifecycle annotations: `javax.annotation.PostConstruct` and `javax.annotation.PreDestroy`. Introduced in Spring 2.5, the support for these annotations offers an alternative to the lifecycle callback mechanism described in [initialization callbacks](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean) and [destruction callbacks](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-disposablebean). Provided that the `CommonAnnotationBeanPostProcessor` is registered within the Spring `ApplicationContext`, a method carrying one of these annotations is invoked at the same point in the lifecycle as the corresponding Spring lifecycle interface method or explicitly declared callback method. In the following example, the cache is pre-populated upon initialization and cleared upon destruction:

`CommonAnnotationBeanPostProcessor`不仅可以识别 `@Resource` 注解，还可以识别 JSR-250 生命周期注解：`javax.annotation.PostConstruct` 和`javax.annotation.PreDestroy`。Spring 2.5 中引入了对这些注解的支持，为[初始化回调](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean) 和[销毁回调](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-disposablebean) 中描述的生命周期回调机制提供了一种替代方案。如果在 Spring `ApplicationContext` 中注册了 `CommonAnnotationBeanPostProcessor`，则在生命周期中的同一点调用带有这些注解之一的方法，作为相应的 Spring 生命周期接口方法或显式声明的回调方法。在以下示例中，缓存在初始化时预填充，在销毁时清除：

```java
public class CachingMovieLister {

    @PostConstruct
    public void populateMovieCache() {
        // populates the movie cache upon initialization...
    }

    @PreDestroy
    public void clearMovieCache() {
        // clears the movie cache upon destruction...
    }
}
```

For details about the effects of combining various lifecycle mechanisms, see [Combining Lifecycle Mechanisms](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-combined-effects).

有关组合各种生命周期机制的影响的详细信息，请参阅[组合生命周期机制](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-combined-effects)。

> Like `@Resource`, the `@PostConstruct` and `@PreDestroy` annotation types were a part of the standard Java libraries from JDK 6 to 8. However, the entire `javax.annotation` package got separated from the core Java modules in JDK 9 and eventually removed in JDK 11. If needed, the `javax.annotation-api` artifact needs to be obtained via Maven Central now, simply to be added to the application’s classpath like any other library.
>
> 与 `@Resource` 一样，`@PostConstruct` 和 `@PreDestroy` 注解类型也是 JDK 6 到 8 标准 Java 库的一部分。然而，整个 `javax.annotation` 包与 JDK 9 中的核心 Java 模块分离，并最终在 JDK 11 中删除。如果需要，可以使用  `javax.annotation-api`。现在需要通过 Maven Central 获得，只需像其他库一样添加到应用程序的类路径中即可。

### 1.10. Classpath Scanning and Managed Components

### 1.10. 类路径扫描和管理组件

Most examples in this chapter use XML to specify the configuration metadata that produces each `BeanDefinition` within the Spring container. The previous section ([Annotation-based Container Configuration](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config)) demonstrates how to provide a lot of the configuration metadata through source-level annotations. Even in those examples, however, the “base” bean definitions are explicitly defined in the XML file, while the annotations drive only the dependency injection. This section describes an option for implicitly detecting the candidate components by scanning the classpath. Candidate components are classes that match against a filter criteria and have a corresponding bean definition registered with the container. This removes the need to use XML to perform bean registration. Instead, you can use annotations (for example, `@Component`), AspectJ type expressions, or your own custom filter criteria to select which classes have bean definitions registered with the container.

本章中的大多数示例都使用 XML 来指定在 Spring 容器中生成每个 `BeanDefinition` 的配置元数据。上一节（[Annotation-based Container Configuration](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config)）演示了如何通过源代码级注解提供大量配置元数据。然而，即使在这些示例中，「基本」 bean 定义也在 XML 文件中显式定义，而注解只驱动依赖项注入。本节描述了通过扫描类路径隐式检测候选组件的选项。候选组件是与筛选条件匹配的类，并在容器中注册了相应的 bean 定义。删除执行此注册所需的 XML bean。相反，您可以使用注解（例如，`@Component`）、AspectJ 类型表达式或您自己的自定义筛选条件来选择哪些类在容器中注册了 bean 定义。

> Starting with Spring 3.0, many features provided by the Spring JavaConfig project are part of the core Spring Framework. This allows you to define beans using Java rather than using the traditional XML files. Take a look at the `@Configuration`, `@Bean`, `@Import`, and `@DependsOn` annotations for examples of how to use these new features.
>
> 从 Spring 3.0 开始，Spring Java Config 项目提供的许多功能都是核心 Spring 框架的一部分。这允许您使用 Java 定义 bean，而不是使用传统的 XML 文件。请查看 `@Configuration`、`@Bean`、`@Import` 和 `@DependsOn` 注解，了解如何使用这些新功能的示例。

#### 1.10.1. `@Component` and Further Stereotype Annotations

#### 1.10.1.  `@Component` 和进一步的原型注解

The `@Repository` annotation is a marker for any class that fulfills the role or stereotype of a repository (also known as Data Access Object or DAO). Among the uses of this marker is the automatic translation of exceptions, as described in [Exception Translation](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#orm-exception-translation).

Spring provides further stereotype annotations: `@Component`, `@Service`, and `@Controller`. `@Component` is a generic stereotype for any Spring-managed component. `@Repository`, `@Service`, and `@Controller` are specializations of `@Component` for more specific use cases (in the persistence, service, and presentation layers, respectively). Therefore, you can annotate your component classes with `@Component`, but, by annotating them with `@Repository`, `@Service`, or `@Controller` instead, your classes are more properly suited for processing by tools or associating with aspects. For example, these stereotype annotations make ideal targets for pointcuts. `@Repository`, `@Service`, and `@Controller` can also carry additional semantics in future releases of the Spring Framework. Thus, if you are choosing between using `@Component` or `@Service` for your service layer, `@Service` is clearly the better choice. Similarly, as stated earlier, `@Repository` is already supported as a marker for automatic exception translation in your persistence layer.

`@Repository` 注解是满足存储库角色或原型（也称为数据访问对象或 DAO）的任何类的标记。该标记的用途之一是自动翻译异常，如[Exception translation](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#orm-exception-translation)所述。

Spring 提供了进一步的原型注解：`@Component`、`@Service` 和 `@Controller`。**`@Component` 是任何 Spring 托管组件的通用原型， `@Repository`、`@Service` 和 `@Controller` 是 `@Component` 的专门化，用于更具体的用例（分别在持久层、服务层和表示层）**。因此，您可以使用 `@Component` 来注解组件类，但是，通过使用 `@Repository`、`@Service` 或 `@Controller` 来注解它们，您的类更适合通过工具处理或与方面关联。例如，这些原型注解是切入点的理想目标。`@Repository`、`@Service` 和 `@Controller` 也可以在 Spring 框架的未来版本中提供额外的语义。因此，如果要在服务层使用 `@Component` 或 `@Service` 之间做出选择，`@Service` 显然是更好的选择。类似地，如前所述，`@Repository` 已经被支持作为持久层中自动异常转换的标记。

#### 1.10.2. Using Meta-annotations and Composed Annotations

#### 1.10.2. 使用元注解和组合注解

Many of the annotations provided by Spring can be used as meta-annotations in your own code. A meta-annotation is an annotation that can be applied to another annotation. For example, the `@Service` annotation mentioned [earlier](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-stereotype-annotations) is meta-annotated with `@Component`, as the following example shows:

Spring 提供的许多注解可以在您自己的代码中用作元注解。**元注解是可以应用于其他注解的注解**。例如，前面提到的 `@Service` 注解是用 `@Component` 进行元注解的，如下例所示：

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component 
public @interface Service {

    // ...
}
```

> The `@Component` causes `@Service` to be treated in the same way as `@Component`.
>
> `@Component` 使 `@Service` 的处理方式与 `@Component` 相同。

You can also combine meta-annotations to create “composed annotations”. For example, the `@RestController` annotation from Spring MVC is composed of `@Controller` and `@ResponseBody`.

In addition, composed annotations can optionally redeclare attributes from meta-annotations to allow customization. This can be particularly useful when you want to only expose a subset of the meta-annotation’s attributes. For example, Spring’s `@SessionScope` annotation hardcodes the scope name to `session` but still allows customization of the `proxyMode`. The following listing shows the definition of the `SessionScope` annotation:

您还可以组合元注解来创建「组合注解」。例如，Spring MVC 中的 `@RestController` 注解由 `@Controller` 和 `@ResponseBody` 组成。

此外，组合注解可以选择性地从元注解重新声明属性，以**允许定制**。当您只想公开元注解属性的子集时，这可能特别有用。例如，Spring 的 `@SessionScope` 注解将作用域名称硬编码为 `session`，但仍然允许自定义 `proxyMode`。下面的列表显示了 `SessionScope` 注解的定义：

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Scope(WebApplicationContext.SCOPE_SESSION)
public @interface SessionScope {

    /**
     * Alias for {@link Scope#proxyMode}.
     * <p>Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
     */
    @AliasFor(annotation = Scope.class)
    ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;

}
```

You can then use `@SessionScope` without declaring the `proxyMode` as follows:

然后，您可以使用 `@SessionScope`，而不声明 `proxyMode`，如下所示：

```java
@Service
@SessionScope
public class SessionScopedService {
    // ...
}
```

You can also override the value for the `proxyMode`, as the following example shows:

您还可以覆盖 `proxyMode` 的值，如下例所示：

```java
@Service
@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
public class SessionScopedUserService implements UserService {
    // ...
}
```

For further details, see the [Spring Annotation Programming Model](https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model) wiki page.

有关更多详细信息，请参阅 [Spring Annotation Programming Model](https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model) wiki 页面。

#### 1.10.3. Automatically Detecting Classes and Registering Bean Definitions

#### 1.10.3. 自动检测类并注册 Bean 定义

Spring can automatically detect stereotyped classes and register corresponding `BeanDefinition` instances with the `ApplicationContext`. For example, the following two classes are eligible for such autodetection:

Spring 可以自动检测构造型类，并用 `ApplicationContext` 注册相应的 `BeanDefinition` 实例。例如，以下两类可用于此类自动检测：

```java
@Service
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
```

```java
@Repository
public class JpaMovieFinder implements MovieFinder {
    // implementation elided for clarity
}
```

To autodetect these classes and register the corresponding beans, you need to add `@ComponentScan` to your `@Configuration` class, where the `basePackages` attribute is a common parent package for the two classes. (Alternatively, you can specify a comma- or semicolon- or space-separated list that includes the parent package of each class.)

**要自动检测这些类并注册相应的 bean，需要将 `@ComponentScan` 添加到 `@Configuration` 类中，其中 `basePackages` 属性是这两个类的公共父包。（或者，您可以指定一个逗号、分号或空格分隔的列表，其中包含每个类的父包。）**

```java
@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig  {
    // ...
}
```

> For brevity, the preceding example could have used the `value` attribute of the annotation (that is, `@ComponentScan("org.example")`).
>
> 为了简洁起见，前面的示例可以使用注解的 `value` 属性（即，`@ComponentScan("org.example")`）。

The following alternative uses XML:

以下替代方案使用 XML：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="org.example"/>

</beans>
```

> The use of `<context:component-scan>` implicitly enables the functionality of `<context:annotation-config>`. There is usually no need to include the `<context:annotation-config>` element when using `<context:component-scan>`.
>
> **`<context:component-scan>` 的使用隐式地启用了 `<context:annotation-config>` 的功能**。使用`<context:component-scan>`时，通常不需要包含 `<context:annotation-config>`元素。

> The scanning of classpath packages requires the presence of corresponding directory entries in the classpath. When you build JARs with Ant, make sure that you do not activate the files-only switch of the JAR task. Also, classpath directories may not be exposed based on security policies in some environments — for example, standalone apps on JDK 1.7.0_45 and higher (which requires 'Trusted-Library' setup in your manifests — see https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources).On JDK 9’s module path (Jigsaw), Spring’s classpath scanning generally works as expected. However, make sure that your component classes are exported in your `module-info` descriptors. If you expect Spring to invoke non-public members of your classes, make sure that they are 'opened' (that is, that they use an `opens` declaration instead of an `exports` declaration in your `module-info` descriptor).
>
> 扫描类路径包需要类路径中存在相应的目录项。使用 Ant 构建 JAR 时，请确保没有激活 JAR 任务的“仅文件”开关。此外，在某些环境中，基于安全策略，类路径目录可能不会公开 — 例如，JDK 1.7.0_45 及更高版本上的独立应用程序（需要在清单中设置“可信库”） — 看见https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources).在 JDK 9 的模块路径（Jigsaw）上，Spring 的类路径扫描通常按预期工作。但是，请确保在 `module-info` 描述符中导出组件类。如果您希望 Spring 调用类的非公共成员，请确保它们是 `opened`（也就是说，它们在 `module-info` 描述符中使用 `opens` 声明，而不是 `exports` 声明）。

Furthermore, the `AutowiredAnnotationBeanPostProcessor` and `CommonAnnotationBeanPostProcessor` are both implicitly included when you use the component-scan element. That means that the two components are autodetected and wired together — all without any bean configuration metadata provided in XML.

此外，在使用组件扫描元素时，`AutowiredAnnotationBeanPostProcessor` 和 `CommonAnnotationBeanPostProcessor` 都会隐式包含在内。这意味着这两个组件被自动检测并连接在一起 — 所有这些都没有 XML 中提供的任何 bean 配置元数据。

>   You can disable the registration of `AutowiredAnnotationBeanPostProcessor` and `CommonAnnotationBeanPostProcessor` by including the `annotation-config` attribute with a value of `false`.
>
>   通过包含值为 `false` 的 `annotation-config` 属性，可以禁用 `AutoWiredNotationBeanPostProcessor` 和 `CommonAnnotationBeanPostProcessor` 的注册。

#### 1.10.4. Using Filters to Customize Scanning

#### 1.10.4. 使用过滤器自定义扫描

By default, classes annotated with `@Component`, `@Repository`, `@Service`, `@Controller`, `@Configuration`, or a custom annotation that itself is annotated with `@Component` are the only detected candidate components. However, you can modify and extend this behavior by applying custom filters. Add them as `includeFilters` or `excludeFilters` attributes of the `@ComponentScan` annotation (or as `<context:include-filter />` or `<context:exclude-filter />` child elements of the `<context:component-scan>` element in XML configuration). Each filter element requires the `type` and `expression` attributes. The following table describes the filtering options:

默认情况下，仅检测到带有 `@Component`、`@Repository`、`@Service`、`@Controller`、`@Configuration` 注解的类，或带有 `@Component` 注解的自定义注解。但是，可以通过应用自定义过滤器来修改和扩展此行为。将它们添加为`@ComponentScan` 注解的 `includeFilters` 或 `excludeFilters` 属性（或作为 XML 配置中 `<context:include-filter/>` 或 `<context:exclude-filter/>` 元素的子元素）。每个过滤器元素都需要 `type` 和 `expression` 属性。下表介绍了过滤选项：

| Filter Type          | Example Expression           | Description                                                  |
| :------------------- | :--------------------------- | :----------------------------------------------------------- |
| annotation (default) | `org.example.SomeAnnotation` | An annotation to be *present* or *meta-present* at the type level in target components.<br />在目标组件的类型级别上是“存在”或“元存在”的注解。 |
| assignable           | `org.example.SomeClass`      | A class (or interface) that the target components are assignable to (extend or implement).<br />目标组件可分配（扩展或实现）的类（或接口）。 |
| aspectj              | `org.example..*Service+`     | An AspectJ type expression to be matched by the target components.<br />目标组件要匹配的 AspectJ 类型表达式。 |
| regex                | `org\.example\.Default.*`    | A regex expression to be matched by the target components' class names.<br />由目标组件的类名匹配的正则表达式。 |
| custom               | `org.example.MyTypeFilter`   | `org.springframework.core.type.TypeFilter`  接口的自定义实现。 |

The following example shows the configuration ignoring all `@Repository` annotations and using “stub” repositories instead:

以下示例显示了忽略所有`@Repository`注解并使用「stub」存储库的配置：

```java
@Configuration
@ComponentScan(basePackages = "org.example",
        includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),
        excludeFilters = @Filter(Repository.class))
public class AppConfig {
    // ...
}
```

The following listing shows the equivalent XML:
下面的列表显示了等效的 XML：

```xml
<beans>
    <context:component-scan base-package="org.example">
        <context:include-filter type="regex"
                expression=".*Stub.*Repository"/>
        <context:exclude-filter type="annotation"
                expression="org.springframework.stereotype.Repository"/>
    </context:component-scan>
</beans>
```

> You can also disable the default filters by setting `useDefaultFilters=false` on the annotation or by providing `use-default-filters="false"` as an attribute of the `<component-scan/>` element. This effectively disables automatic detection of classes annotated or meta-annotated with `@Component`, `@Repository`, `@Service`, `@Controller`, `@RestController`, or `@Configuration`.
> 您还可以通过在注解上设置 `useDefaultFilters=false`，或者将 `use-default-filters="false"`作为 `<component-scan/>` 元素的属性来禁用默认过滤器。这实际上禁用了自动检测用 `@Component` 、 `@Repository` 、 `@Service`、 `Controller`、`RestController` 或 `@Configuration` 注解或元注解的类。

#### 1.10.5. Defining Bean Metadata within Components

#### 1.10.5. 在组件中定义 Bean 元数据

Spring components can also contribute bean definition metadata to the container. You can do this with the same `@Bean` annotation used to define bean metadata within `@Configuration` annotated classes. The following example shows how to do so:

Spring 组件还可以向容器提供 bean 定义元数据。可以使用与在 `@Configuration` 注解类中定义 Bean 元数据相同的 `@Bean` 注解来实现这一点。以下示例显示了如何执行此操作：

```java
@Component
public class FactoryMethodComponent {

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    public void doWork() {
        // Component method implementation omitted
    }
}
```

The preceding class is a Spring component that has application-specific code in its `doWork()` method. However, it also contributes a bean definition that has a factory method referring to the method `publicInstance()`. The `@Bean` annotation identifies the factory method and other bean definition properties, such as a qualifier value through the `@Qualifier` annotation. Other method-level annotations that can be specified are `@Scope`, `@Lazy`, and custom qualifier annotations.

前面的类是一个 Spring 组件，它的 `doWork()` 方法中有特定于应用程序的代码。然而，它也提供了一个 bean 定义，其中有一个工厂方法引用方法 `publicInstance()`。`@Bean` 注解标识工厂方法和其他 Bean 定义属性，例如通过 `@Qualifier` 注解的限定符值。可以指定的其他方法级注解包括 `@Scope`、`@Lazy` 和自定义限定符注解。

> In addition to its role for component initialization, you can also place the `@Lazy` annotation on injection points marked with `@Autowired` or `@Inject`. In this context, it leads to the injection of a lazy-resolution proxy. However, such a proxy approach is rather limited. For sophisticated lazy interactions, in particular in combination with optional dependencies, we recommend `ObjectProvider<MyTargetBean>` instead.
> 除了用于组件初始化外，还可以将 `@Lazy` 注解放置在标有 `@Autowired` 或 `@Inject` 的注入点上。在这种情况下，它会引入一个懒惰的解析代理。然而，这种代理方法相当有限。对于复杂的惰性交互，尤其是与可选依赖项结合使用时，我们建议改为 `ObjectProvider<MyTargetBean>` 。

Autowired fields and methods are supported, as previously discussed, with additional support for autowiring of `@Bean` methods. The following example shows how to do so:
如前所述，支持自动连接字段和方法，并对 `@Bean` 方法的自动连接提供了额外的支持。以下示例显示了如何执行此操作：

```java
@Component
public class FactoryMethodComponent {

    private static int i;

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    // use of a custom qualifier and autowiring of method parameters
    @Bean
    protected TestBean protectedInstance(
            @Qualifier("public") TestBean spouse,
            @Value("#{privateInstance.age}") String country) {
        TestBean tb = new TestBean("protectedInstance", 1);
        tb.setSpouse(spouse);
        tb.setCountry(country);
        return tb;
    }

    @Bean
    private TestBean privateInstance() {
        return new TestBean("privateInstance", i++);
    }

    @Bean
    @RequestScope
    public TestBean requestScopedInstance() {
        return new TestBean("requestScopedInstance", 3);
    }
}
```

The example autowires the `String` method parameter `country` to the value of the `age` property on another bean named `privateInstance`. A Spring Expression Language element defines the value of the property through the notation `#{ <expression> }`. For `@Value` annotations, an expression resolver is preconfigured to look for bean names when resolving expression text.

As of Spring Framework 4.3, you may also declare a factory method parameter of type `InjectionPoint` (or its more specific subclass: `DependencyDescriptor`) to access the requesting injection point that triggers the creation of the current bean. Note that this applies only to the actual creation of bean instances, not to the injection of existing instances. As a consequence, this feature makes most sense for beans of prototype scope. For other scopes, the factory method only ever sees the injection point that triggered the creation of a new bean instance in the given scope (for example, the dependency that triggered the creation of a lazy singleton bean). You can use the provided injection point metadata with semantic care in such scenarios. The following example shows how to use `InjectionPoint`:

该示例将 `String` 方法参数 `country` 自动关联到另一个名为 `privateInstance` 的 bean 的 `age` 属性的值。Spring 表达式语言元素通过符号 `#{<expression>}` 定义属性的值。对于 `@Value` 注解，表达式解析器被预先配置为在解析表达式文本时查找 bean 名称。

从 Spring Framework 4.3 开始，您还可以声明一个类型为 `InjectionPoint`（或其更具体的子类： `DependencyDescriptor`）的工厂方法参数，以访问触发当前 bean 创建的请求注入点。注意，这只适用于 bean 实例的实际创建，而不适用于现有实例的注入。因此，这个特性对于原型范围的 bean 最有意义。对于其他作用域，factory 方法只会看到在给定作用域中触发创建新 bean 实例的注入点（例如，触发创建惰性单例 bean 的依赖项）。在这种情况下，您可以在语义上谨慎地使用提供的注入点元数据。以下示例显示了如何使用 `InjectionPoint`：

```java
@Component
public class FactoryMethodComponent {

    @Bean @Scope("prototype")
    public TestBean prototypeInstance(InjectionPoint injectionPoint) {
        return new TestBean("prototypeInstance for " + injectionPoint.getMember());
    }
}
```

The `@Bean` methods in a regular Spring component are processed differently than their counterparts inside a Spring `@Configuration` class. The difference is that `@Component` classes are not enhanced with CGLIB to intercept the invocation of methods and fields. CGLIB proxying is the means by which invoking methods or fields within `@Bean` methods in `@Configuration` classes creates bean metadata references to collaborating objects. Such methods are not invoked with normal Java semantics but rather go through the container in order to provide the usual lifecycle management and proxying of Spring beans, even when referring to other beans through programmatic calls to `@Bean` methods. In contrast, invoking a method or field in a `@Bean` method within a plain `@Component` class has standard Java semantics, with no special CGLIB processing or other constraints applying.

常规 Spring 组件中的 `@Bean` 方法的处理方式与 Spring `@Configuration` 类中的对应方法不同。不同之处在于， `@Component` 类没有使用 CGLIB 来拦截方法和字段的调用。CGLIB 代理是在 `@Configuration` 类中调用 `@Bean` 方法内的方法或字段来创建对协作对象的 Bean 元数据引用的方法。这些方法不是用普通的 Java 语义调用的，而是通过容器来提供 Spring Bean 的常规生命周期管理和代理，即使是通过对 `@Bean` 方法的编程调用引用其他 Bean 时也是如此。相比之下，在普通的 `@Component` 类中调用 `@Bean` 方法中的方法或字段具有标准的 Java 语义，没有应用特殊的 CGLIB 处理或其他约束。

> You may declare `@Bean` methods as `static`, allowing for them to be called without creating their containing configuration class as an instance. This makes particular sense when defining post-processor beans (for example, of type `BeanFactoryPostProcessor` or `BeanPostProcessor`), since such beans get initialized early in the container lifecycle and should avoid triggering other parts of the configuration at that point.Calls to static `@Bean` methods never get intercepted by the container, not even within `@Configuration` classes (as described earlier in this section), due to technical limitations: CGLIB subclassing can override only non-static methods. As a consequence, a direct call to another `@Bean` method has standard Java semantics, resulting in an independent instance being returned straight from the factory method itself.The Java language visibility of `@Bean` methods does not have an immediate impact on the resulting bean definition in Spring’s container. You can freely declare your factory methods as you see fit in non-`@Configuration` classes and also for static methods anywhere. However, regular `@Bean` methods in `@Configuration` classes need to be overridable — that is, they must not be declared as `private` or `final`.`@Bean` methods are also discovered on base classes of a given component or configuration class, as well as on Java 8 default methods declared in interfaces implemented by the component or configuration class. This allows for a lot of flexibility in composing complex configuration arrangements, with even multiple inheritance being possible through Java 8 default methods as of Spring 4.2.Finally, a single class may hold multiple `@Bean` methods for the same bean, as an arrangement of multiple factory methods to use depending on available dependencies at runtime. This is the same algorithm as for choosing the “greediest” constructor or factory method in other configuration scenarios: The variant with the largest number of satisfiable dependencies is picked at construction time, analogous to how the container selects between multiple `@Autowired` constructors.
>
> 您可以将“@Bean”方法声明为“static”，这样就可以在不创建包含它们的配置类作为实例的情况下调用它们。这在定义后处理器bean（例如，“BeanFactoryPostProcessor”或“BeanPostProcessor”类型）时特别有意义，因为这样的bean会在容器生命周期的早期初始化，并且应该避免在此时触发配置的其他部分。由于技术限制，对静态`@Bean`方法的调用永远不会被容器拦截，即使是在`@Configuration`类中（如本节前面所述），也不会被拦截：CGLIB子类化只能覆盖非静态方法。因此，对另一个“@Bean”方法的直接调用具有标准Java语义，从而直接从工厂方法本身返回一个独立实例。“@Bean”方法的Java语言可见性不会立即影响Spring容器中生成的Bean定义。您可以在非`@Configuration`类中自由声明工厂方法，也可以在任何地方声明静态方法。但是，“@Configuration”类中的常规“@Bean”方法需要是可重写的 — 也就是说，它们不能被宣布为“私有”或“最终”`@Bean方法也可以在给定组件或配置类的基类上找到，也可以在组件或配置类实现的接口中声明的Java8默认方法上找到。这使得在组合复杂的配置安排时具有很大的灵活性，从Spring 4.2开始，通过Java8默认方法甚至可以实现多重继承。最后，一个类可以为同一个Bean保存多个`@Bean`方法，作为多个工厂方法的一种安排，根据运行时可用的依赖关系来使用。这与在其他配置场景中选择“最贪婪”构造函数或工厂方法的算法相同：在构造时选择可满足依赖项最多的变量，类似于容器如何在多个`@Autowired`构造函数之间进行选择。

#### 1.10.6. Naming Autodetected Components

#### 1.10.6. 命名自动检测到的组件

When a component is autodetected as part of the scanning process, its bean name is generated by the `BeanNameGenerator` strategy known to that scanner. By default, any Spring stereotype annotation (`@Component`, `@Repository`, `@Service`, and `@Controller`) that contains a name `value` thereby provides that name to the corresponding bean definition.

If such an annotation contains no name `value` or for any other detected component (such as those discovered by custom filters), the default bean name generator returns the uncapitalized non-qualified class name. For example, if the following component classes were detected, the names would be `myMovieLister` and `movieFinderImpl`:

当一个组件在扫描过程中被自动检测到时，它的 bean 名由该扫描程序已知的 `BeanNameGenerator` 策略生成。默认情况下，任何包含名称 `value` 的 Spring 原型注解（`@Component`、`@Repository`、`@Service` 和 `@Controller`）都会将该名称提供给相应的 bean 定义。

如果这样的注解不包含名称 `value` 或任何其他检测到的组件（如自定义过滤器发现的组件），默认 bean 名称生成器将返回未大写的非限定类名。例如，如果检测到以下组件类，则名称将为 `myMovieLister` 和 `movieFinderImpl`：

```java
@Service("myMovieLister")
public class SimpleMovieLister {
    // ...
}
```

```java
@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
```

If you do not want to rely on the default bean-naming strategy, you can provide a custom bean-naming strategy. First, implement the [`BeanNameGenerator`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html) interface, and be sure to include a default no-arg constructor. Then, provide the fully qualified class name when configuring the scanner, as the following example annotation and bean definition show.

如果不想依赖默认的 bean 命名策略，可以提供自定义 bean 命名策略。首先，实现 [`BeannamGenerator`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html) 接口，并确保包含默认的无参数构造函数。然后，在配置扫描器时提供完全限定的类名，如下例注解和 bean 定义所示。

> If you run into naming conflicts due to multiple autodetected components having the same non-qualified class name (i.e., classes with identical names but residing in different packages), you may need to configure a `BeanNameGenerator` that defaults to the fully qualified class name for the generated bean name. As of Spring Framework 5.2.3, the `FullyQualifiedAnnotationBeanNameGenerator` located in package `org.springframework.context.annotation` can be used for such purposes.
>
> 如果由于多个自动检测组件具有相同的非限定类名（即名称相同但驻留在不同包中的类）而导致命名冲突，则可能需要配置默认为生成的 bean 名称的完全限定类名的 `BeanNameGenerator`。从 Spring Framework 5.2.3 开始，包 `org.springframework.context.annotation` 中的 `FullyQualifiedAnnotationBeannamGenerator` 就可以用于这些目的。

```java
@Configuration
@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)
public class AppConfig {
    // ...
}

<beans>
    <context:component-scan base-package="org.example"
        name-generator="org.example.MyNameGenerator" />
</beans>
```

As a general rule, consider specifying the name with the annotation whenever other components may be making explicit references to it. On the other hand, the auto-generated names are adequate whenever the container is responsible for wiring.

作为一般规则，考虑在任何其他组件可能对其进行明确引用时，用注解指定名称。另一方面，只要容器负责布线，自动生成的名称就足够了。

#### 1.10.7. Providing a Scope for Autodetected Components

#### 1.10.7. 为自动检测到的组件提供范围

As with Spring-managed components in general, the default and most common scope for autodetected components is `singleton`. However, sometimes you need a different scope that can be specified by the `@Scope` annotation. You can provide the name of the scope within the annotation, as the following example shows:

与 Spring 管理的组件一样，自动检测组件的默认和最常见范围是 `singleton`。但是，有时您需要一个不同的作用域，可以由`@Scope` 注解指定。可以在注解中提供作用域的名称，如下例所示：

```java
@Scope("prototype")
@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
```

> `@Scope` annotations are only introspected on the concrete bean class (for annotated components) or the factory method (for `@Bean` methods). In contrast to XML bean definitions, there is no notion of bean definition inheritance, and inheritance hierarchies at the class level are irrelevant for metadata purposes.
>
> `@Scope`注解只在具体 bean 类（用于带注解的组件）或工厂方法（用于`@bean`方法）上进行内省。与 XMLBean 定义相比，没有 bean 定义继承的概念，类级别的继承层次结构与元数据目的无关。

For details on web-specific scopes such as “request” or “session” in a Spring context, see [Request, Session, Application, and WebSocket Scopes](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other). As with the pre-built annotations for those scopes, you may also compose your own scoping annotations by using Spring’s meta-annotation approach: for example, a custom annotation meta-annotated with `@Scope("prototype")`, possibly also declaring a custom scoped-proxy mode.

有关特定于 web 的作用域（如 Spring 上下文中的「request」 或 「session」 ）的详细信息，请参阅[Request, Session, Application, and WebSocket Scopes](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other)。与这些作用域的预构建注解一样，您也可以使用 Spring 的元注解方法来编写自己的作用域注解：例如，使用 `@Scope("prototype")` 注解的自定义注解元，可能还声明了自定义作用域代理模式。

> To provide a custom strategy for scope resolution rather than relying on the annotation-based approach, you can implement the [`ScopeMetadataResolver`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/annotation/ScopeMetadataResolver.html) interface. Be sure to include a default no-arg constructor. Then you can provide the fully qualified class name when configuring the scanner, as the following example of both an annotation and a bean definition shows:
>
> 要为范围解析提供自定义策略，而不是依赖基于注解的方法，可以实现[`ScopeMetadataResolver`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/annotation/ScopeMetadataResolver.html)）接口。确保包含默认的无参数构造函数。然后，您可以在配置扫描程序时提供完全限定的类名，如下注解和 bean 定义的示例所示：

```java
@Configuration
@ComponentScan(basePackages = "org.example", scopeResolver = MyScopeResolver.class)
public class AppConfig {
    // ...
}
<beans>
    <context:component-scan base-package="org.example" scope-resolver="org.example.MyScopeResolver"/>
</beans>
```

When using certain non-singleton scopes, it may be necessary to generate proxies for the scoped objects. The reasoning is described in [Scoped Beans as Dependencies](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection). For this purpose, a scoped-proxy attribute is available on the component-scan element. The three possible values are: `no`, `interfaces`, and `targetClass`. For example, the following configuration results in standard JDK dynamic proxies:

当使用某些非单例作用域时，可能需要为作用域对象生成代理。推理在 [Scoped Beans as Dependencies](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection) 中描述。为此，component-scan 元素上有一个作用域代理属性。这三个可能的值是：`no`、`interfaces` 和 `targetClass`。例如，以下配置会产生标准的 JDK 动态代理：

```java
@Configuration
@ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)
public class AppConfig {
    // ...
}
<beans>
    <context:component-scan base-package="org.example" scoped-proxy="interfaces"/>
</beans>
```

#### 1.10.8. Providing Qualifier Metadata with Annotations

#### 1.10.8. 提供带有注解的限定符元数据

The `@Qualifier` annotation is discussed in [Fine-tuning Annotation-based Autowiring with Qualifiers](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-autowired-annotation-qualifiers). The examples in that section demonstrate the use of the `@Qualifier` annotation and custom qualifier annotations to provide fine-grained control when you resolve autowire candidates. Because those examples were based on XML bean definitions, the qualifier metadata was provided on the candidate bean definitions by using the `qualifier` or `meta` child elements of the `bean` element in the XML. When relying upon classpath scanning for auto-detection of components, you can provide the qualifier metadata with type-level annotations on the candidate class. The following three examples demonstrate this technique:

`@Qualifier` 注解在 [Fine-tuning Annotation-based Autowiring with Qualifiers](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-autowired-annotation-qualifiers)中讨论。该部分中的示例演示了在解析 autowire 候选对象时使用 `@Qualifier` 注解和自定义限定符注解来提供细粒度控制。因为这些示例基于 XML bean 定义，所以通过使用XML 中 `bean` 元素的 `qualifier` 或 `meta` 子元素，在候选 bean 定义上提供了限定符元数据。当依靠类路径扫描来自动检测组件时，可以为限定符元数据提供候选类上的类型级注解。以下三个示例演示了这种技术：

```java
@Component
@Qualifier("Action")
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}
```

```java
@Component
@Genre("Action")
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}
```

```java
@Component
@Offline
public class CachingMovieCatalog implements MovieCatalog {
    // ...
}
```

> As with most annotation-based alternatives, keep in mind that the annotation metadata is bound to the class definition itself, while the use of XML allows for multiple beans of the same type to provide variations in their qualifier metadata, because that metadata is provided per-instance rather than per-class.
>
> 与大多数基于注解的替代方案一样，请记住注解元数据绑定到类定义本身，而 XML 的使用允许相同类型的多个 bean 在其限定符元数据中提供变化，因为元数据是按实例而不是按类提供的。

#### 1.10.9. Generating an Index of Candidate Components

#### 1.10.9. 生成候选组件的索引

While classpath scanning is very fast, it is possible to improve the startup performance of large applications by creating a static list of candidates at compilation time. In this mode, all modules that are targets of component scanning must use this mechanism.

虽然类路径扫描非常快，但通过在编译时创建静态候选列表，可以提高大型应用程序的启动性能。在此模式下，作为组件扫描目标的所有模块都必须使用此机制。

> Your existing `@ComponentScan` or `<context:component-scan/>` directives must remain unchanged to request the context to scan candidates in certain packages. When the `ApplicationContext` detects such an index, it automatically uses it rather than scanning the classpath.
>
> 现有的 `@ComponentScan` 或 `<context:component-scan/>` 指令必须保持不变，才能请求上下文扫描某些包中的候选程序。当 ApplicationContext 检测到这样一个索引时，它会自动使用它，而不是扫描类路径。

To generate the index, add an additional dependency to each module that contains components that are targets for component scan directives. The following example shows how to do so with Maven:

要生成索引，请向包含组件扫描指令目标组件的每个模块添加额外的依赖项。以下示例显示了如何使用 Maven 执行此操作：

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context-indexer</artifactId>
        <version>5.3.13</version>
        <optional>true</optional>
    </dependency>
</dependencies>
```

With Gradle 4.5 and earlier, the dependency should be declared in the `compileOnly` configuration, as shown in the following example:

对于 Gradle 4.5 及更早版本，依赖关系应该在 `compileOnly` 配置中声明，如下例所示：

```groovy
dependencies {
    compileOnly "org.springframework:spring-context-indexer:5.3.13"
}
```

With Gradle 4.6 and later, the dependency should be declared in the `annotationProcessor` configuration, as shown in the following example:

对于 Gradle 4.6 及更高版本，依赖关系应该在 `annotationProcessor` 配置中声明，如下例所示：

```groovy
dependencies {
    annotationProcessor "org.springframework:spring-context-indexer:5.3.13"
}
```

The `spring-context-indexer` artifact generates a `META-INF/spring.components` file that is included in the jar file.

 `spring-context-indexer` 工件生成一个包含在 jar 文件中的`META-INF/spring.components`文件。

>   When working with this mode in your IDE, the `spring-context-indexer` must be registered as an annotation processor to make sure the index is up-to-date when candidate components are updated.
>
>   在 IDE 中使用此模式时， `spring-context-indexer` 必须注册为注解处理器，以确保在更新候选组件时索引是最新的。

> The index is enabled automatically when a `META-INF/spring.components` file is found on the classpath. If an index is partially available for some libraries (or use cases) but could not be built for the whole application, you can fall back to a regular classpath arrangement (as though no index were present at all) by setting `spring.index.ignore` to `true`, either as a JVM system property or via the [`SpringProperties`](https://docs.spring.io/spring-framework/docs/current/reference/html/appendix.html#appendix-spring-properties) mechanism.
>
> 当在类路径上找到`META-INF/spring.components` 文件时，会自动启用索引。如果索引对某些库（或用例）部分可用，但无法为整个应用程序构建，则可以通过将 `spring.index.ignore` 设置为`true`，将其作为JVM系统属性或通过 [`SpringProperties`](https://docs.spring.io/spring-framework/docs/current/reference/html/appendix.html#appendix-spring-properties) 机制，退回到常规类路径安排（就好像根本不存在索引一样）。

### 1.11. Using JSR 330 Standard Annotations

### 1.11. 使用 JSR330 标准注解

Starting with Spring 3.0, Spring offers support for JSR-330 standard annotations (Dependency Injection). Those annotations are scanned in the same way as the Spring annotations. To use them, you need to have the relevant jars in your classpath.

从 Spring 3.0 开始，Spring 支持 JSR-330 标准注解（依赖项注入）。这些注解的扫描方式与 Spring 注解相同。要使用它们，需要在类路径中有相关的 JAR。

> If you use Maven, the `javax.inject` artifact is available in the standard Maven repository ( https://repo1.maven.org/maven2/javax/inject/javax.inject/1/). You can add the following dependency to your file pom.xml:
>
> 如果您使用 Maven，`javax.inject`工件可在标准 Maven 存储库（https://repo1.maven.org/maven2/javax/inject/javax.inject/1/)。您可以将以下依赖项添加到文件 pom 中：
>
> ```xml
> <dependency>    
> <groupId>javax.inject</groupId>    
> <artifactId>javax.inject</artifactId>    
> <version>1</version>
> </dependency>
> ```

#### 1.11.1. Dependency Injection with `@Inject` and `@Named`

#### 1.11.1. 带有 `@Inject` 和 `@Named` 的依赖项注入

Instead of `@Autowired`, you can use `@javax.inject.Inject` as follows:

您可以按如下方式使用`@javax.inject.Inject`，而不是 `@Autowired`：

```java
import javax.inject.Inject;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.findMovies(...);
        // ...
    }
}
```

As with `@Autowired`, you can use `@Inject` at the field level, method level and constructor-argument level. Furthermore, you may declare your injection point as a `Provider`, allowing for on-demand access to beans of shorter scopes or lazy access to other beans through a `Provider.get()` call. The following example offers a variant of the preceding example:

与 `@Autowired` 一样，您可以在字段级、方法级和构造函数参数级使用 `@Inject`。此外，您可以将注入点声明为 `Provider`，允许按需访问范围较短的 bean，或者通过`Provider.get()` 调用延迟访问其他 bean。以下示例提供了前一示例的变体：

```java
import javax.inject.Inject;
import javax.inject.Provider;

public class SimpleMovieLister {

    private Provider<MovieFinder> movieFinder;

    @Inject
    public void setMovieFinder(Provider<MovieFinder> movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.get().findMovies(...);
        // ...
    }
}
```

If you would like to use a qualified name for the dependency that should be injected, you should use the `@Named` annotation, as the following example shows:

如果要为应注入的依赖项使用限定名，则应使用 `@Named` 注解，如下例所示：

```java
import javax.inject.Inject;
import javax.inject.Named;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(@Named("main") MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

As with `@Autowired`, `@Inject` can also be used with `java.util.Optional` or  `@Nullable`. This is even more applicable here, since `@Inject` does not have a `required` attribute. The following pair of examples show how to use `@Inject` and `@Nullable`:

与 `@Autowired` 一样，`@Inject` 也可以与 `java.util.Optional` 或 `@Nullable`一起使用。这在这里更适用，因为 `@Inject` 没有 `required` 属性。以下两个示例演示了如何使用 `@Inject` 和 `@Nullable`：

```java
public class SimpleMovieLister {

    @Inject
    public void setMovieFinder(Optional<MovieFinder> movieFinder) {
        // ...
    }
}
```

```java
public class SimpleMovieLister {

    @Inject
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        // ...
    }
}
```

#### 1.11.2. `@Named` and `@ManagedBean`: Standard Equivalents to the `@Component` Annotation

#### 1.11.2. `@Named`and`@ManagedBean`:`@Component`注解的标准等价物

Instead of `@Component`, you can use `@javax.inject.Named` or `javax.annotation.ManagedBean`, as the following example shows:

可以使用 `@javax.inject.Named` 或 `javax.annotation.ManagedBean`代替 `@Component`，如下例所示：

```java
import javax.inject.Inject;
import javax.inject.Named;

@Named("movieListener")  // @ManagedBean("movieListener") could be used as well
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

It is very common to use `@Component` without specifying a name for the component. `@Named` can be used in a similar fashion, as the following example shows:

使用 `@Component` 而不指定组件的名称是很常见的 `@Named` 可以以类似的方式使用，如下例所示：

```java
import javax.inject.Inject;
import javax.inject.Named;

@Named
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

When you use `@Named` or `@ManagedBean`, you can use component scanning in the exact same way as when you use Spring annotations, as the following example shows:

当使用 `@Named` 或 `@ManagedBean` 时，可以使用与使用 Spring 注解完全相同的组件扫描方式，如下例所示：

```java
@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig  {
    // ...
}
```

> In contrast to `@Component`, the JSR-330 `@Named` and the JSR-250 `ManagedBean` annotations are not composable. You should use Spring’s stereotype model for building custom component annotations.
>
> 与 `@Component` 不同，JSR-330 `@Named` 和 JSR-250 `ManagedBean` 注解是不可组合的。您应该使用 Spring 的原型模型来构建自定义组件注解。

#### 1.11.3. Limitations of JSR-330 Standard Annotations

#### 1.11.3. JSR-330 标准注解的局限性

When you work with standard annotations, you should know that some significant features are not available, as the following table shows:

使用标准注解时，您应该知道一些重要功能不可用，如下表所示：

| Spring              | javax.inject.*        | javax.inject restrictions / comments                         |
| :------------------ | :-------------------- | :----------------------------------------------------------- |
| @Autowired          | @Inject               | `@Inject` has no 'required' attribute. Can be used with Java 8’s `Optional` instead. |
| @Component          | @Named / @ManagedBean | JSR-330 does not provide a composable model, only a way to identify named components. |
| @Scope("singleton") | @Singleton            | The JSR-330 default scope is like Spring’s `prototype`. However, in order to keep it consistent with Spring’s general defaults, a JSR-330 bean declared in the Spring container is a `singleton` by default. In order to use a scope other than `singleton`, you should use Spring’s `@Scope` annotation. `javax.inject` also provides a [@Scope](https://download.oracle.com/javaee/6/api/javax/inject/Scope.html) annotation. Nevertheless, this one is only intended to be used for creating your own annotations. |
| @Qualifier          | @Qualifier / @Named   | `javax.inject.Qualifier` is just a meta-annotation for building custom qualifiers. Concrete `String` qualifiers (like Spring’s `@Qualifier` with a value) can be associated through `javax.inject.Named`. |
| @Value              | -                     | no equivalent                                                |
| @Required           | -                     | no equivalent                                                |
| @Lazy               | -                     | no equivalent                                                |
| ObjectFactory       | Provider              | `javax.inject.Provider` is a direct alternative to Spring’s `ObjectFactory`, only with a shorter `get()` method name. It can also be used in combination with Spring’s `@Autowired` or with non-annotated constructors and setter methods. |

### 1.12. Java-based Container Configuration

### 1.12. 基于 Java 的容器配置

This section covers how to use annotations in your Java code to configure the Spring container. It includes the following topics:

本节介绍如何在 Java 代码中使用注解来配置 Spring 容器。它包括以下主题：

- [Basic Concepts: `@Bean` and `@Configuration`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-basic-concepts)
- [Instantiating the Spring Container by Using `AnnotationConfigApplicationContext`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-instantiating-container)
- [Using the `@Bean` Annotation](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-bean-annotation)
- [Using the `@Configuration` annotation](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-configuration-annotation)
- [Composing Java-based Configurations](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-composing-configuration-classes)
- [Bean Definition Profiles](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-definition-profiles)
- [`PropertySource` Abstraction](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-property-source-abstraction)
- [Using `@PropertySource`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-using-propertysource)
- [Placeholder Resolution in Statements](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-placeholder-resolution-in-statements)

#### 1.12.1. Basic Concepts: `@Bean` and `@Configuration`

#### 1.12.1. 基本概念：`@Bean` 和 `@Configuration`

The central artifacts in Spring’s new Java-configuration support are `@Configuration`-annotated classes and `@Bean`-annotated methods.

The `@Bean` annotation is used to indicate that a method instantiates, configures, and initializes a new object to be managed by the Spring IoC container. For those familiar with Spring’s `<beans/>` XML configuration, the `@Bean` annotation plays the same role as the `<bean/>` element. You can use `@Bean`-annotated methods with any Spring `@Component`. However, they are most often used with `@Configuration` beans.

Annotating a class with `@Configuration` indicates that its primary purpose is as a source of bean definitions. Furthermore, `@Configuration` classes let inter-bean dependencies be defined by calling other `@Bean` methods in the same class. The simplest possible `@Configuration` class reads as follows:

**Spring 新的 Java 配置支持的核心构件是带有 `@Configuration` 注解的类和带有 `@Bean` 注解的方法。**

`@Bean` 注解用于指示一个方法实例化、配置和初始化一个要由 Spring IoC 容器管理的新对象。对于那些熟悉 Spring 的`<beans/>` XML 配置的人来说，**`@Bean` 注解扮演着与 `<Bean/>` 元素相同的角色**。您可以对任何 Spring 组件使用带 `@Bean` 注解的方法。然而，它们最常用于 `@Configuration` bean。

用 `@Configuration` 注解一个类表明它的主要用途是作为 bean 定义的源。此外，`@Configuration` 类允许通过调用同一类中的其他 `@Bean` 方法来定义 bean 之间的依赖关系。最简单的 `@Configuration` 类如下所示：

```java
@Configuration
public class AppConfig {

    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
```

The preceding `AppConfig` class is equivalent to the following Spring `<beans/>` XML:

前面的 `AppConfig` 类相当于下面的 Spring `<beans/>` XML：

```xml
<beans>
    <bean id="myService" class="com.acme.services.MyServiceImpl"/>
</beans>
```

> ​                                                            Full @Configuration vs “lite” @Bean mode?
>
> ​                                                           完整 @Configuration vs “lite” @Bean 模式？
>
> When `@Bean` methods are declared within classes that are not annotated with `@Configuration`, they are referred to as being processed in a “lite” mode. Bean methods declared in a `@Component` or even in a plain old class are considered to be “lite”, with a different primary purpose of the containing class and a `@Bean` method being a sort of bonus there. For example, service components may expose management views to the container through an additional `@Bean` method on each applicable component class. In such scenarios, `@Bean` methods are a general-purpose factory method mechanism.
>
> Unlike full `@Configuration`, lite `@Bean` methods cannot declare inter-bean dependencies. Instead, they operate on their containing component’s internal state and, optionally, on arguments that they may declare. Such a `@Bean` method should therefore not invoke other `@Bean` methods. Each such method is literally only a factory method for a particular bean reference, without any special runtime semantics. The positive side-effect here is that no CGLIB subclassing has to be applied at runtime, so there are no limitations in terms of class design (that is, the containing class may be `final` and so forth).
>
> In common scenarios, `@Bean` methods are to be declared within `@Configuration` classes, ensuring that “full” mode is always used and that cross-method references therefore get redirected to the container’s lifecycle management. This prevents the same `@Bean` method from accidentally being invoked through a regular Java call, which helps to reduce subtle bugs that can be hard to track down when operating in “lite” mode.
>
> 当在未使用 `@Configuration` 注解的类中声明 `@Bean` 方法时，它们被称为正在以 “lite” 模式处理。在 `@Component` 中甚至在普通的旧类中声明的 Bean 方法被认为是 “lite”，包含类的主要用途不同，`@Bean` 方法是一种额外的功能。例如，服务组件可以通过每个适用组件类上的附加 `@Bean` 方法向容器公开管理视图。在这种情况下，`@Bean` 方法是一种通用的工厂方法机制。
>
> **与完整的 `@Configuration` 不同，lite `@Bean` 方法不能声明 Bean 之间的依赖关系**。相反，它们对其包含组件的内部状态进行操作，并且可以选择对它们可能声明的参数进行操作。因此，这样的 `@Bean` 方法不应调用其他 `@Bean` 方法。每个这样的方法实际上只是特定 bean 引用的工厂方法，没有任何特殊的运行时语义。这里的积极副作用是，在运行时不必应用 CGLIB 子类，因此在类设计方面没有限制（也就是说，包含的类可能是 `final` 等）。
>
> 在常见场景中，`@Bean` 方法将在 `@Configuration` 类中声明，以确保始终使用 「full」模式，并且跨方法引用因此被重定向到容器的生命周期管理。这可以防止通过常规 Java 调用意外调用同一个`@Bean`方法，这有助于减少在 “lite” 模式下操作时难以追踪的细微错误。

The `@Bean` and `@Configuration` annotations are discussed in depth in the following sections. First, however, we cover the various ways of creating a spring container by using Java-based configuration.

下面几节将深入讨论 `@Bean` 和 `@Configuration` 注解。然而，首先，我们将介绍使用基于 Java 的配置创建 spring 容器的各种方法。

#### 1.12.2. Instantiating the Spring Container by Using `AnnotationConfigApplicationContext`

#### 1.12.2. 使用 `AnnotationConfigApplicationContext` 实例化 Spring 容器

The following sections document Spring’s `AnnotationConfigApplicationContext`, introduced in Spring 3.0. This versatile `ApplicationContext` implementation is capable of accepting not only `@Configuration` classes as input but also plain `@Component` classes and classes annotated with JSR-330 metadata.

When `@Configuration` classes are provided as input, the `@Configuration` class itself is registered as a bean definition and all declared `@Bean` methods within the class are also registered as bean definitions.

When `@Component` and JSR-330 classes are provided, they are registered as bean definitions, and it is assumed that DI metadata such as `@Autowired` or `@Inject` are used within those classes where necessary.

以下几节记录了 Spring 在 Spring 3.0 中引入的 `AnnotationConfigApplicationContext`。这个多功能的 `ApplicationContext` 实现不仅能够接受作为输入的 `@Configuration` 类，还能够接受普通的 `@Component` 类和用 JSR-330 元数据注解的类。

当提供 `@Configuration` 类作为输入时，`@Configuration` 类本身被注册为 bean 定义，类中所有声明的 `@Bean` 方法也被注册为 bean 定义。

当提供了 `@Component` 和 JSR-330 类时，它们被注册为 bean 定义，并且假设在必要时，在这些类中使用诸如 `@Autowired` 或 `@Inject` 之类的 DI 元数据。

##### Simple Construction

##### 结构简单

In much the same way that Spring XML files are used as input when instantiating a `ClassPathXmlApplicationContext`, you can use `@Configuration` classes as input when instantiating an `AnnotationConfigApplicationContext`. This allows for completely XML-free usage of the Spring container, as the following example shows:

与 Spring XML 文件在实例化 `ClassPathXmlApplicationContext` 时用作输入的方式大致相同，在实例化 `AnnotationConfigApplicationContext` 时，可以使用 `@Configuration` 类作为输入。这允许 Spring 容器完全不使用 XML，如下例所示：

```java
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
```

As mentioned earlier, `AnnotationConfigApplicationContext` is not limited to working only with `@Configuration` classes. Any `@Component` or JSR-330 annotated class may be supplied as input to the constructor, as the following example shows:

如前所述，`AnnotationConfigApplicationContext` 不仅限于使用 `@Configuration` 类。任何 `@Component` 或 JSR-330 注解类都可以作为构造函数的输入提供，如下例所示：

```java
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
```

The preceding example assumes that `MyServiceImpl`, `Dependency1`, and `Dependency2` use Spring dependency injection annotations such as `@Autowired`.

前面的示例假设 `MyServiceImpl`、`Dependency1` 和 `Dependency2` 使用 Spring 依赖项注入注解，例如 `@Autowired`。

##### Building the Container Programmatically by Using `register(Class<?>…)`

##### 使用 `register(Class<?>…)` 以编程方式构建容器

You can instantiate an `AnnotationConfigApplicationContext` by using a no-arg constructor and then configure it by using the `register()` method. This approach is particularly useful when programmatically building an `AnnotationConfigApplicationContext`. The following example shows how to do so:

可以使用无参数构造函数实例化 `AnnotationConfigApplicationContext`，然后使用 `register()` 方法对其进行配置。当以编程方式构建 `AnnotationConfigApplicationContext` 时，这种方法尤其有用。以下示例显示了如何执行此操作：

```java
public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.register(AppConfig.class, OtherConfig.class);
    ctx.register(AdditionalConfig.class);
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
```

##### Enabling Component Scanning with `scan(String…)`

##### 使用 `scan(String…)`启用组件扫描

To enable component scanning, you can annotate your `@Configuration` class as follows:

```java
@Configuration
@ComponentScan(basePackages = "com.acme")  // 注解一
public class AppConfig  {
    // ...
}
```

注解一：This annotation enables component scanning.此注解支持组件扫描。

>  Experienced Spring users may be familiar with the XML declaration equivalent from Spring’s `context:` namespace, shown in the following example:
>
>  经验丰富的 Spring 用户可能熟悉 Spring 的 `context:` 名称空间中的 XML 声明等价物，如下例所示：
>
>  ```xml
>  <beans>
>   	<context:component-scan base-package="com.acme"/>
>  </beans>
>  ```

In the preceding example, the `com.acme` package is scanned to look for any `@Component`-annotated classes, and those classes are registered as Spring bean definitions within the container. `AnnotationConfigApplicationContext` exposes the `scan(String…)` method to allow for the same component-scanning functionality, as the following example shows:

在前面的示例中，`com.acme` 包被扫描以查找任何带有 `@Component` 注解的类，这些类在容器中注册为 Spring bean 定义`AnnotationConfigApplicationContext` 公开了 `scan(String…)`方法，以允许使用相同的组件扫描功能，如下例所示：

```java
public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.scan("com.acme");
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
}
```

> Remember that `@Configuration` classes are [meta-annotated](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-meta-annotations) with `@Component`, so they are candidates for component-scanning. In the preceding example, assuming that `AppConfig` is declared within the `com.acme` package (or any package underneath), it is picked up during the call to `scan()`. Upon `refresh()`, all its `@Bean` methods are processed and registered as bean definitions within the container.
>
> 记住，`@Configuration` 类是带有 `@Component` 的  [meta-annotated](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-meta-annotations)，所以它们是组件扫描的候选对象。在前面的示例中，假设 `AppConfig` 是在 `com.acme` 中声明的（或下面的任何包），它是在调用 `scan()` 时提取的。在 `refresh()` 时，它的所有 `@Bean` 方法都会被处理并注册为容器中的 Bean 定义。

##### Support for Web Applications with `AnnotationConfigWebApplicationContext`

##### 支持具有 `AnnotationConfigWebApplicationContext` 的 Web 应用程序

A `WebApplicationContext` variant of `AnnotationConfigApplicationContext` is available with `AnnotationConfigWebApplicationContext`. You can use this implementation when configuring the Spring `ContextLoaderListener` servlet listener, Spring MVC `DispatcherServlet`, and so forth. The following `web.xml` snippet configures a typical Spring MVC web application (note the use of the `contextClass` context-param and init-param):

`AnnotationConfigApplicationContext` 的 `WebApplicationContext` 变量可与 `AnnotationConfigWebApplicationContext` 一起使用。您可以在配置 spring `ContextLoaderListener ` servlet 侦听器、spring mvc ` DispatcherServlet` 等时使用此实现。以下 `web.xml` 片段配置了一个典型的 SpringMVC Web 应用程序（注意使用 `contextClass` context-param 和 init-param）：

```xml
<web-app>
    <!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
        instead of the default XmlWebApplicationContext -->
    <context-param>
        <param-name>contextClass</param-name>
        <param-value>
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        </param-value>
    </context-param>

    <!-- Configuration locations must consist of one or more comma- or space-delimited
        fully-qualified @Configuration classes. Fully-qualified packages may also be
        specified for component-scanning -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>com.acme.AppConfig</param-value>
    </context-param>

    <!-- Bootstrap the root application context as usual using ContextLoaderListener -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <!-- Declare a Spring MVC DispatcherServlet as usual -->
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
            instead of the default XmlWebApplicationContext -->
        <init-param>
            <param-name>contextClass</param-name>
            <param-value>
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            </param-value>
        </init-param>
        <!-- Again, config locations must consist of one or more comma- or space-delimited
            and fully-qualified @Configuration classes -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>com.acme.web.MvcConfig</param-value>
        </init-param>
    </servlet>

    <!-- map all requests for /app/* to the dispatcher servlet -->
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/app/*</url-pattern>
    </servlet-mapping>
</web-app>
```

#### 1.12.3. Using the `@Bean` Annotation

#### 1.12.3. 使用 `@Bean` 注解

`@Bean` is a method-level annotation and a direct analog of the XML `<bean/>` element. The annotation supports some of the attributes offered by `<bean/>`, such as:

`@Bean` 是一个方法级注解，是 XML `<bean/>` 元素的直接模拟。注解支持 `<bean/>` 提供的一些属性，例如：

- [init-method](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean)
- [destroy-method](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-disposablebean)
- [autowiring](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire)
- `name`.

You can use the `@Bean` annotation in a `@Configuration`-annotated or in a `@Component`-annotated class.

**您可以在带有 `@Configuration` 注解或带有 `@Component` 注解的类中使用 `@Bean` 注解。**

##### Declaring a Bean

To declare a bean, you can annotate a method with the `@Bean` annotation. You use this method to register a bean definition within an `ApplicationContext` of the type specified as the method’s return value. By default, the bean name is the same as the method name. The following example shows a `@Bean` method declaration:

要声明 bean，可以使用 `@Bean` 注解对方法进行注解。使用此方法可以在指定为方法返回值的类型的 `ApplicationContext` 中注册 bean 定义。默认情况下，bean 名称与方法名称相同。以下示例显示了一个 `@Bean` 方法声明：

```java
@Configuration
public class AppConfig {

    @Bean
    public TransferServiceImpl transferService() {
        return new TransferServiceImpl();
    }
}
```

The preceding configuration is exactly equivalent to the following Spring XML:

前面的配置与下面的 Spring XML 完全等效：

```xml
<beans>
    <bean id="transferService" class="com.acme.TransferServiceImpl"/>
</beans>
```

Both declarations make a bean named `transferService` available in the `ApplicationContext`, bound to an object instance of type `TransferServiceImpl`, as the following text image shows:

这两个声明都使名为 `transferService` 的 bean 在 `ApplicationContext` 中可用，绑定到 `TransferServiceImpl` 类型的对象实例，如下图所示：

```
transferService -> com.acme.TransferServiceImpl
```

You can also declare your `@Bean` method with an interface (or base class) return type, as the following example shows:

还可以用接口（或基类）返回类型声明 `@Bean` 方法，如下例所示：

```java
@Configuration
public class AppConfig {

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }
}
```

However, this limits the visibility for advance type prediction to the specified interface type (`TransferService`). Then, with the full type (`TransferServiceImpl`) known to the container only once the affected singleton bean has been instantiated. Non-lazy singleton beans get instantiated according to their declaration order, so you may see different type matching results depending on when another component tries to match by a non-declared type (such as `@Autowired TransferServiceImpl`, which resolves only once the `transferService` bean has been instantiated).

但是，这将高级类型预测的可见性限制为指定的接口类型（`TransferService`）。然后，容器只在实例化了受影响的单例 bean之后才知道完整类型（`TransferServiceImpl`）。非惰性单例 bean 根据其声明顺序进行实例化，因此您可能会看到不同的类型匹配结果，这取决于另一个组件尝试通过非声明类型进行匹配的时间（例如 `@Autowired TransferServiceImpl`，它只在 `transferService` bean 被实例化后解析）。

> If you consistently refer to your types by a declared service interface, your `@Bean` return types may safely join that design decision. However, for components that implement several interfaces or for components potentially referred to by their implementation type, it is safer to declare the most specific return type possible (at least as specific as required by the injection points that refer to your bean).
>
> 如果您始终通过声明的服务接口引用您的类型，`@Bean` 返回类型可以安全地加入该设计决策。然而，对于实现多个接口的组件或可能由其实现类型引用的组件，更安全的做法是声明可能的最具体的返回类型（至少按照引用 bean 的注入点的要求）。

##### Bean Dependencies

A `@Bean`-annotated method can have an arbitrary number of parameters that describe the dependencies required to build that bean. For instance, if our `TransferService` requires an `AccountRepository`, we can materialize that dependency with a method parameter, as the following example shows:

带 `@Bean` 注解的方法可以有任意数量的参数来描述构建该 Bean 所需的依赖关系。例如，如果我们的 `TransferService` 需要一个 `AccountRepository`，我们可以用一个方法参数具体化该依赖关系，如下例所示：

```java
@Configuration
public class AppConfig {

    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }
}
```

The resolution mechanism is pretty much identical to constructor-based dependency injection. See [the relevant section](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-constructor-injection) for more details.

解析机制与基于构造函数的依赖项注入几乎相同。见 [相关章节](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-constructor-injection) 以获取更多详细信息。

##### Receiving Lifecycle Callbacks

##### 接收生命周期回调

Any classes defined with the `@Bean` annotation support the regular lifecycle callbacks and can use the `@PostConstruct` and `@PreDestroy` annotations from JSR-250. See [JSR-250 annotations](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations) for further details.

The regular Spring [lifecycle](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-nature) callbacks are fully supported as well. If a bean implements `InitializingBean`, `DisposableBean`, or `Lifecycle`, their respective methods are called by the container.

The standard set of `*Aware` interfaces (such as [BeanFactoryAware](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beanfactory), [BeanNameAware](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware), [MessageSourceAware](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-messagesource), [ApplicationContextAware](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware), and so on) are also fully supported.

The `@Bean` annotation supports specifying arbitrary initialization and destruction callback methods, much like Spring XML’s `init-method` and `destroy-method` attributes on the `bean` element, as the following example shows:

使用 `@Bean` 注解定义的任何类都支持常规的生命周期回调，并且可以使用 JSR-250 中的 `@PostConstruct` 和 `@PreDestroy`注解。参见 [JSR-250 注解](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations)以获取更多详细信息。

普通的 Spring [生命周期](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-nature) 回调也得到了充分支持。如果 bean 实现了 `InitializingBean`、`DisposableBean` 或 `Lifecycle`，则容器将调用它们各自的方法。

`*Aware` 接口的标准集（例如[BeanFactoryAware](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beanfactory)，[BeanNameAware](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware), [MessageSourceAware](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-messagesource), [ApplicationContextAware](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware)），还完全支持等。

`@Bean` 注解支持指定任意初始化和销毁回调方法，就像 Spring XML 在 `bean` 元素上的 `init-method` 和 `destroy-method` 属性一样，如下例所示：

```java
public class BeanOne {

    public void init() {
        // initialization logic
    }
}

public class BeanTwo {

    public void cleanup() {
        // destruction logic
    }
}

@Configuration
public class AppConfig {

    @Bean(initMethod = "init")
    public BeanOne beanOne() {
        return new BeanOne();
    }

    @Bean(destroyMethod = "cleanup")
    public BeanTwo beanTwo() {
        return new BeanTwo();
    }
}
```

> By default, beans defined with Java configuration that have a public `close` or `shutdown` method are automatically enlisted with a destruction callback. If you have a public `close` or `shutdown` method and you do not wish for it to be called when the container shuts down, you can add `@Bean(destroyMethod="")` to your bean definition to disable the default `(inferred)` mode.
>
> You may want to do that by default for a resource that you acquire with JNDI, as its lifecycle is managed outside the application. In particular, make sure to always do it for a `DataSource`, as it is known to be problematic on Java EE application servers.
>
> The following example shows how to prevent an automatic destruction callback for a `DataSource`:
>
> 默认情况下，使用 Java 配置定义的具有公共 `close` 或 `shutdown` 方法的 bean 会自动登记为销毁回调。如果您有一个公共的 `close` 或 `shutdown` 方法，并且不希望在容器关闭时调用它，那么您可以向 Bean 定义中添加 `@Bean(destroyMethod="")`，以禁用默认的 `(inferred)` 模式。
>
> 对于使用 JNDI 获取的资源，默认情况下可能需要这样做，因为它的生命周期是在应用程序之外管理的。尤其要确保总是为 `DataSource` 这样做，因为众所周知，在 JavaEE 应用程序服务器上这是有问题的。
>
> 以下示例显示了如何防止 `DataSource` 的自动销毁回调：
>
> ```java
> @Bean(destroyMethod="")
> public DataSource dataSource() throws NamingException {
> return (DataSource) jndiTemplate.lookup("MyDS");
> }
> ```
>
> Also, with `@Bean` methods, you typically use programmatic JNDI lookups, either by using Spring’s `JndiTemplate` or `JndiLocatorDelegate` helpers or straight JNDI `InitialContext` usage but not the `JndiObjectFactoryBean` variant (which would force you to declare the return type as the `FactoryBean` type instead of the actual target type, making it harder to use for cross-reference calls in other `@Bean` methods that intend to refer to the provided resource here).
>
> 此外，对于 `@Bean` 方法，通常使用编程 JNDI 查找，通过使用 Spring 的 `JndiTemplate` 或 `JndiLocatorDelegate` 帮助程序，或者直接使用 JNDI  `InitialContext`，而不是 `JndiObjectFactoryBean` 变体（这将迫使您将返回类型声明为 `FactoryBean` 类型，而不是实际的目标类型，这使得在其他打算在此处引用所提供资源的 `@Bean` 方法中进行交叉引用调用更加困难）。

In the case of `BeanOne` from the example above the preceding note, it would be equally valid to call the `init()` method directly during construction, as the following example shows:

对于上述示例中的 `BeanOne`，在构造过程中直接调用 `init()` 方法同样有效，如下例所示：

```java
@Configuration
public class AppConfig {

    @Bean
    public BeanOne beanOne() {
        BeanOne beanOne = new BeanOne();
        beanOne.init();
        return beanOne;
    }

    // ...
}
```

> When you work directly in Java, you can do anything you like with your objects and do not always need to rely on the container lifecycle.
>
> 当您直接在 Java 中工作时，您可以对对象做任何您喜欢的事情，而不必总是依赖于容器生命周期。

##### Specifying Bean Scope

##### 指定 Bean 范围

Spring includes the `@Scope` annotation so that you can specify the scope of a bean.

Spring 包含了 `@Scope` 注解，因此您可以指定 bean 的作用域。

###### Using the `@Scope` Annotation

使用 `@Scope` 注解

You can specify that your beans defined with the `@Bean` annotation should have a specific scope. You can use any of the standard scopes specified in the [Bean Scopes](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes) section.

The default scope is `singleton`, but you can override this with the `@Scope` annotation, as the following example shows:

您可以指定使用 `@Bean` 注解定义的 Bean 应该具有特定的作用域。您可以使用[Bean scopes](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes) 中指定的任何标准作用域部分。
默认作用域为 `singleton`，但您可以使用 `@Scope` 注解覆盖它，如下例所示：

```java
@Configuration
public class MyConfiguration {

    @Bean
    @Scope("prototype")
    public Encryptor encryptor() {
        // ...
    }
}
```

###### `@Scope` and `scoped-proxy`

Spring offers a convenient way of working with scoped dependencies through [scoped proxies](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection). The easiest way to create such a proxy when using the XML configuration is the `<aop:scoped-proxy/>` element. Configuring your beans in Java with a `@Scope` annotation offers equivalent support with the `proxyMode` attribute. The default is `ScopedProxyMode.DEFAULT`, which typically indicates that no scoped proxy should be created unless a different default has been configured at the component-scan instruction level. You can specify `ScopedProxyMode.TARGET_CLASS`, `ScopedProxyMode.INTERFACES` or `ScopedProxyMode.NO`.

If you port the scoped proxy example from the XML reference documentation (see [scoped proxies](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection)) to our `@Bean` using Java, it resembles the following:

Spring 提供了一种通过  [scoped proxies](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection) 处理作用域依赖关系的便捷方法。在使用 XML 配置时，创建这样一个代理的最简单方法是 `<aop:scoped-proxy/>` 元素。在 Java 中配置带有 `@Scope` 注解的 bean 提供了与 `proxyMode` 属性同等的支持。默认设置为 `ScopedProxyMode.DEFAULT`，通常表示不应创建作用域代理，除非在组件扫描指令级别配置了不同的默认值。您可以指定 `ScopedProxyMode.TARGET_CLASS`, `ScopedProxyMode.INTERFACES` 或 `ScopedProxyMode.NO`。

如果使用 Java 将 XML 参考文档中的作用域代理示例（请参见[scoped proxies](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection)）移植到我们的 `@Bean`，它类似于以下内容：

```java
// an HTTP Session-scoped bean exposed as a proxy
@Bean
@SessionScope
public UserPreferences userPreferences() {
    return new UserPreferences();
}

@Bean
public Service userService() {
    UserService service = new SimpleUserService();
    // a reference to the proxied userPreferences bean
    service.setUserPreferences(userPreferences());
    return service;
}
```

##### Customizing Bean Naming

By default, configuration classes use a `@Bean` method’s name as the name of the resulting bean. This functionality can be overridden, however, with the `name` attribute, as the following example shows:

默认情况下，配置类使用 `@Bean` 方法的名称作为结果 bean 的名称。但是，可以使用 `name` 属性覆盖此功能，如下例所示：

```java
@Configuration
public class AppConfig {

    @Bean("myThing")
    public Thing thing() {
        return new Thing();
    }
}
```

##### Bean Aliasing

As discussed in [Naming Beans](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beanname), it is sometimes desirable to give a single bean multiple names, otherwise known as bean aliasing. The `name` attribute of the `@Bean` annotation accepts a String array for this purpose. The following example shows how to set a number of aliases for a bean:

正如在 [Naming Beans](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beanname) 中所讨论的，有时需要为一个 bean 指定多个名称，否则称为 bean 别名。为此，`@Bean` 注解的 `name` 属性接受字符串数组。以下示例显示了如何为 bean 设置多个别名：

```java
@Configuration
public class AppConfig {

    @Bean({"dataSource", "subsystemA-dataSource", "subsystemB-dataSource"})
    public DataSource dataSource() {
        // instantiate, configure and return DataSource bean...
    }
}
```

##### Bean Description

Sometimes, it is helpful to provide a more detailed textual description of a bean. This can be particularly useful when beans are exposed (perhaps through JMX) for monitoring purposes.

To add a description to a `@Bean`, you can use the [`@Description`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/annotation/Description.html) annotation, as the following example shows:

有时，对 bean 提供更详细的文本描述是有帮助的。当 bean 被暴露（可能通过 JMX）以进行监视时，这可能特别有用。

要向 `@Bean` 添加描述，可以使用 [`@Description`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/annotation/Description.html) 注解，如下例所示：

```java
@Configuration
public class AppConfig {

    @Bean
    @Description("Provides a basic example of a bean")
    public Thing thing() {
        return new Thing();
    }
}
```

#### 1.12.4. Using the `@Configuration` annotation

`@Configuration` is a class-level annotation indicating that an object is a source of bean definitions. `@Configuration` classes declare beans through `@Bean`-annotated methods. Calls to `@Bean` methods on `@Configuration` classes can also be used to define inter-bean dependencies. See [Basic Concepts: `@Bean` and `@Configuration`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-basic-concepts) for a general introduction.

`@Configuration` 是一个类级注解，指示对象是 bean 定义的源 `@Configuration` 类通过 `@Bean` 注解的方法声明 Bean。对 `@Configuration` 类上的 `@Bean` 方法的调用也可用于定义 Bean 之间的依赖关系。请参阅[基本概念：`@Bean` 和`@Configuration`](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-basic-concepts)，了解一般介绍。

##### Injecting Inter-bean Dependencies

##### 注入 bean 间依赖

When beans have dependencies on one another, expressing that dependency is as simple as having one bean method call another, as the following example shows:

当 bean 彼此有依赖关系时，表达这种依赖关系就像让一个 bean 方法调用另一个 bean 方法一样简单，如下例所示：

```java
@Configuration
public class AppConfig {

    @Bean
    public BeanOne beanOne() {
        return new BeanOne(beanTwo());
    }

    @Bean
    public BeanTwo beanTwo() {
        return new BeanTwo();
    }
}
```

In the preceding example, `beanOne` receives a reference to `beanTwo` through constructor injection.

在前面的示例中，`beanOne` 通过构造函数注入接收对 `beanTwo` 的引用。

>   This method of declaring inter-bean dependencies works only when the `@Bean` method is declared within a `@Configuration` class. You cannot declare inter-bean dependencies by using plain `@Component` classes.
>
>   只有在 `@Configuration` 类中声明了 `@Bean` 方法时，这种声明 bean 间依赖关系的方法才有效。不能使用普通的`@Component` 类来声明 bean 之间的依赖关系。

##### Lookup Method Injection

##### 查找方法注入

As noted earlier, [lookup method injection](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-method-injection) is an advanced feature that you should use rarely. It is useful in cases where a singleton-scoped bean has a dependency on a prototype-scoped bean. Using Java for this type of configuration provides a natural means for implementing this pattern. The following example shows how to use lookup method injection:

如前所述，[lookup method injection](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-method-injection) 是一种高级功能，您应该很少使用。在单例作用域 bean 依赖于原型作用域 bean 的情况下，它很有用。使用 Java 进行这种类型的配置为实现这种模式提供了一种自然的方法。以下示例显示了如何使用查找方法注入：

```java
public abstract class CommandManager {
    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}
```

By using Java configuration, you can create a subclass of `CommandManager` where the abstract `createCommand()` method is overridden in such a way that it looks up a new (prototype) command object. The following example shows how to do so:

通过使用 Java 配置，您可以创建 `CommandManager` 的子类，其中抽象的 `createCommand()` 方法被重写，以便它查找新的（原型）命令对象。以下示例显示了如何执行此操作：

```java
@Bean
@Scope("prototype")
public AsyncCommand asyncCommand() {
    AsyncCommand command = new AsyncCommand();
    // inject dependencies here as required
    return command;
}

@Bean
public CommandManager commandManager() {
    // return new anonymous implementation of CommandManager with createCommand()
    // overridden to return a new prototype Command object
    return new CommandManager() {
        protected Command createCommand() {
            return asyncCommand();
        }
    }
}
```

##### Further Information About How Java-based Configuration Works Internally

##### 关于基于 Java 的配置如何在内部工作的更多信息

Consider the following example, which shows a `@Bean` annotated method being called twice:

考虑下面的例子，它显示了一个 `@Bean` 注解方法被调用两次：

```java
@Configuration
public class AppConfig {

    @Bean
    public ClientService clientService1() {
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    }

    @Bean
    public ClientService clientService2() {
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    }

    @Bean
    public ClientDao clientDao() {
        return new ClientDaoImpl();
    }
}
```

`clientDao()` has been called once in `clientService1()` and once in `clientService2()`. Since this method creates a new instance of `ClientDaoImpl` and returns it, you would normally expect to have two instances (one for each service). That definitely would be problematic: In Spring, instantiated beans have a `singleton` scope by default. This is where the magic comes in: All `@Configuration` classes are subclassed at startup-time with `CGLIB`. In the subclass, the child method checks the container first for any cached (scoped) beans before it calls the parent method and creates a new instance.

`clientDao()` 在 `clientService1()` 和 `clientService2()` 中分别被调用了一次。因为这个方法创建了一个新的 `ClientDaoImpl` 实例并返回它，所以通常需要两个实例（每个服务一个）。这肯定会有问题：在 Spring 中，实例化的 bean 默认有一个 `singleton` 作用域。这就是神奇之处：所有的 `@Configuration` 类在启动时都是用 ` CGLIB` 子类化的。在子类中，子方法在调用父方法并创建新实例之前，首先检查容器中是否有任何缓存（作用域）bean。

>   The behavior could be different according to the scope of your bean. We are talking about singletons here.
>
>   根据 bean 的范围，行为可能会有所不同。我们这里说的是单身人士。

> As of Spring 3.2, it is no longer necessary to add CGLIB to your classpath because CGLIB classes have been repackaged under `org.springframework.cglib` and included directly within the spring-core JAR.
>
> 从 Spring 3.2 开始，不再需要将 CGLIB 添加到类路径中，因为 CGLIB 类已在 `org.springframework.cglib` 下重新打包，并直接包含在 spring-core JAR 中。

> There are a few restrictions due to the fact that CGLIB dynamically adds features at startup-time. In particular, configuration classes must not be final. However, as of 4.3, any constructors are allowed on configuration classes, including the use of `@Autowired` or a single non-default constructor declaration for default injection.If you prefer to avoid any CGLIB-imposed limitations, consider declaring your `@Bean` methods on non-`@Configuration` classes (for example, on plain `@Component` classes instead). Cross-method calls between `@Bean` methods are not then intercepted, so you have to exclusively rely on dependency injection at the constructor or method level there.
>
> 由于 CGLIB 在启动时动态添加特性，因此有一些限制。特别是，配置类不能是最终的。但是，从 4.3 开始，配置类中允许使用任何构造函数，包括使用 `@Autowired` 或单个非默认构造函数声明进行默认注入。如果您希望避免任何对 CGLIB 施加的限制，请考虑在非 `@Configuration` 类上声明您的 `@Bean` 方法（例如，在普通的 `@Component`类上）。`@Bean` 方法之间的跨方法调用不会被拦截，因此您必须完全依赖于构造函数或方法级别的依赖项注入。

#### 1.12.5. Composing Java-based Configurations

#### 1.12.5. 组合基于 Java 的配置

Spring’s Java-based configuration feature lets you compose annotations, which can reduce the complexity of your configuration.

Spring 基于 Java 的配置功能允许您编写注解，这可以降低配置的复杂性。

##### Using the `@Import` Annotation

##### 使用 `@Import` 注解

Much as the `<import/>` element is used within Spring XML files to aid in modularizing configurations, the `@Import` annotation allows for loading `@Bean` definitions from another configuration class, as the following example shows:

就像 Spring XML 文件中使用 `<import/>` 元素来帮助模块化配置一样，`@Import` 注解允许从另一个配置类加载 `@Bean` 定义，如下例所示：

```java
@Configuration
public class ConfigA {

    @Bean
    public A a() {
        return new A();
    }
}

@Configuration
@Import(ConfigA.class)
public class ConfigB {

    @Bean
    public B b() {
        return new B();
    }
}
```

Now, rather than needing to specify both `ConfigA.class` and `ConfigB.class` when instantiating the context, only `ConfigB` needs to be supplied explicitly, as the following example shows:

现在，在实例化上下文时，不需要同时指定 `ConfigA.class` 和 `ConfigB.class` ，只需要显式提供 `ConfigB`，如下例所示：

```java
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);

    // now both beans A and B will be available...
    A a = ctx.getBean(A.class);
    B b = ctx.getBean(B.class);
}
```

This approach simplifies container instantiation, as only one class needs to be dealt with, rather than requiring you to remember a potentially large number of `@Configuration` classes during construction.

这种方法简化了容器实例化，因为只需要处理一个类，而不需要在构造过程中记住大量潜在的 `@Configuration` 类。

> As of Spring Framework 4.2, `@Import` also supports references to regular component classes, analogous to the `AnnotationConfigApplicationContext.register` method. This is particularly useful if you want to avoid component scanning, by using a few configuration classes as entry points to explicitly define all your components.

###### Injecting Dependencies on Imported `@Bean` Definitions

###### 注入对导入的 `@Bean` 定义的依赖关系

The preceding example works but is simplistic. In most practical scenarios, beans have dependencies on one another across configuration classes. When using XML, this is not an issue, because no compiler is involved, and you can declare `ref="someBean"` and trust Spring to work it out during container initialization. When using `@Configuration` classes, the Java compiler places constraints on the configuration model, in that references to other beans must be valid Java syntax.

Fortunately, solving this problem is simple. As [we already discussed](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-dependencies), a `@Bean` method can have an arbitrary number of parameters that describe the bean dependencies. Consider the following more real-world scenario with several `@Configuration` classes, each depending on beans declared in the others:

前面的例子虽然有效，但过于简单。在大多数实际场景中，bean 在配置类之间相互依赖。在使用 XML 时，这不是一个问题，因为不涉及编译器，您可以声明 `ref="someBean"` 并信任 Spring 在容器初始化期间解决它。当使用 `@Configuration` 类时，Java 编译器会对配置模型进行约束，因为对其他 bean 的引用必须是有效的 Java 语法。

幸运的是，解决这个问题很简单。正如[我们已经讨论过的](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-dependencies)，`@Bean` 方法可以有任意数量的参数来描述 bean 依赖关系。考虑下面几个更真实的场景，其中有几个`@Configuration` 类，每个类都依赖于其他声明的 bean：

```java
@Configuration
public class ServiceConfig {

    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }
}

@Configuration
public class RepositoryConfig {

    @Bean
    public AccountRepository accountRepository(DataSource dataSource) {
        return new JdbcAccountRepository(dataSource);
    }
}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return new DataSource
    }
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}
```

There is another way to achieve the same result. Remember that `@Configuration` classes are ultimately only another bean in the container: This means that they can take advantage of `@Autowired` and `@Value` injection and other features the same as any other bean.

还有另一种方法可以达到同样的效果。记住，`@Configuration` 类最终只是容器中的另一个 bean：这意味着它们可以利用 `@Autowired` 和 `@Value` 注入以及其他与任何其他 bean 相同的功能。

> Make sure that the dependencies you inject that way are of the simplest kind only. `@Configuration` classes are processed quite early during the initialization of the context, and forcing a dependency to be injected this way may lead to unexpected early initialization. Whenever possible, resort to parameter-based injection, as in the preceding example.Also, be particularly careful with `BeanPostProcessor` and `BeanFactoryPostProcessor` definitions through `@Bean`. Those should usually be declared as `static @Bean` methods, not triggering the instantiation of their containing configuration class. Otherwise, `@Autowired` and `@Value` may not work on the configuration class itself, since it is possible to create it as a bean instance earlier than [`AutowiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html).
>
> 确保以这种方式注入的依赖项只是最简单的一种 `@Configuration` 类在上下文的初始化过程中很早就被处理，强制以这种方式注入依赖项可能会导致意外的早期初始化。只要有可能，就采用基于参数的注入，如前一个例子所示。另外，通过 `@Bean` 对 `BeanPostProcessor` 和 `BeanFactoryPostProcessor` 的定义要特别小心。这些方法通常应该声明为 `static @Bean` 方法，而不是触发其包含的配置类的实例化。否则，`@Autowired` 和 `@Value` 可能无法在配置类本身上工作，因为可以将其创建为早于 [`AutowiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html)的 bean 实例。

The following example shows how one bean can be autowired to another bean:

以下示例显示了如何将一个 bean 自动连接到另一个 bean：

```java
@Configuration
public class ServiceConfig {

    @Autowired
    private AccountRepository accountRepository;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(accountRepository);
    }
}

@Configuration
public class RepositoryConfig {

    private final DataSource dataSource;

    public RepositoryConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }
}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return new DataSource
    }
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}
```

> Constructor injection in `@Configuration` classes is only supported as of Spring Framework 4.3. Note also that there is no need to specify `@Autowired` if the target bean defines only one constructor.
>
> `@Configuration` 类中的构造函数注入仅在 Spring Framework 4.3 中受支持。还请注意，如果目标 bean 只定义一个构造函数，则无需指定 `@Autowired`。

Fully-qualifying imported beans for ease of navigation

完全限定导入的 bean 以便于导航

In the preceding scenario, using `@Autowired` works well and provides the desired modularity, but determining exactly where the autowired bean definitions are declared is still somewhat ambiguous. For example, as a developer looking at `ServiceConfig`, how do you know exactly where the `@Autowired AccountRepository` bean is declared? It is not explicit in the code, and this may be just fine. Remember that the [Spring Tools for Eclipse](https://spring.io/tools) provides tooling that can render graphs showing how everything is wired, which may be all you need. Also, your Java IDE can easily find all declarations and uses of the `AccountRepository` type and quickly show you the location of `@Bean` methods that return that type.

In cases where this ambiguity is not acceptable and you wish to have direct navigation from within your IDE from one `@Configuration` class to another, consider autowiring the configuration classes themselves. The following example shows how to do so:

在前面的场景中，使用 `@Autowired` 可以很好地工作，并提供所需的模块化，但确定 autowired bean 定义的确切声明位置仍然有些模糊。例如，作为一名查看 `ServiceConfig` 的开发人员，您如何确切地知道 `@Autowired AccountRepository` bean 的声明位置？这在代码中并不明确，这可能很好。请记住， [Spring Tools for Eclipse](https://spring.io/tools) 提供的工具可以呈现图形，显示一切是如何连接的，这可能就是您所需要的。此外，Java IDE 可以轻松找到 `AccountRepository` 类型的所有声明和用法，并快速显示返回该类型的 `@Bean` 方法的位置。

在这种歧义是不可接受的情况下，并且希望从 IDE 中从一个 `@Configuration` 类中直接导航到另一个 configuration  类时，请考虑自动配置配置本身。以下示例显示了如何执行此操作：

```java
@Configuration
public class ServiceConfig {

    @Autowired
    private RepositoryConfig repositoryConfig;

    @Bean
    public TransferService transferService() {
        // navigate 'through' the config class to the @Bean method!
        return new TransferServiceImpl(repositoryConfig.accountRepository());
    }
}
```

In the preceding situation, where `AccountRepository` is defined is completely explicit. However, `ServiceConfig` is now tightly coupled to `RepositoryConfig`. That is the tradeoff. This tight coupling can be somewhat mitigated by using interface-based or abstract class-based `@Configuration` classes. Consider the following example:

在前面的情况中，定义 `AccountRepository` 的地方是完全明确的。然而，`ServiceConfig` 现在与 `RepositoryConfig` 紧密耦合。这就是折衷。通过使用基于接口或基于抽象类的 `@Configuration` 类，可以在一定程度上缓解这种紧密耦合。考虑下面的例子：

```java
@Configuration
public class ServiceConfig {

    @Autowired
    private RepositoryConfig repositoryConfig;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(repositoryConfig.accountRepository());
    }
}

@Configuration
public interface RepositoryConfig {

    @Bean
    AccountRepository accountRepository();
}

@Configuration
public class DefaultRepositoryConfig implements RepositoryConfig {

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(...);
    }
}

@Configuration
@Import({ServiceConfig.class, DefaultRepositoryConfig.class})  // import the concrete config!
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return DataSource
    }

}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}
```

Now `ServiceConfig` is loosely coupled with respect to the concrete `DefaultRepositoryConfig`, and built-in IDE tooling is still useful: You can easily get a type hierarchy of `RepositoryConfig` implementations. In this way, navigating `@Configuration` classes and their dependencies becomes no different than the usual process of navigating interface-based code.

现在，`ServiceConfig` 与具体的 `DefaultRepositoryConfig` 松散耦合，内置的 IDE 工具仍然很有用：您可以轻松获得`RepositoryConfig` 实现的类型层次结构。通过这种方式，导航 `@Configuration` 类及其依赖项与导航基于接口的代码的常规过程没有什么不同。

> If you want to influence the startup creation order of certain beans, consider declaring some of them as `@Lazy` (for creation on first access instead of on startup) or as `@DependsOn` certain other beans (making sure that specific other beans are created before the current bean, beyond what the latter’s direct dependencies imply).
>
> 如果您想影响某些 bean 的启动创建顺序，请考虑将它们中的一些声明为 `@Lazy`（用于创建第一个访问而不是启动）或 `@DependsOn` 某些其他 bean（确保在当前 bean 之前创建特定的其他 bean，而不是后者的直接依赖性暗示）。

##### Conditionally Include `@Configuration` Classes or `@Bean` Methods

##### 有条件地包括 `@Configuration` 类或 `@Bean` 方法

It is often useful to conditionally enable or disable a complete `@Configuration` class or even individual `@Bean` methods, based on some arbitrary system state. One common example of this is to use the `@Profile` annotation to activate beans only when a specific profile has been enabled in the Spring `Environment` (see [Bean Definition Profiles](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-definition-profiles) for details).

The `@Profile` annotation is actually implemented by using a much more flexible annotation called [`@Conditional`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/annotation/Conditional.html). The `@Conditional` annotation indicates specific `org.springframework.context.annotation.Condition` implementations that should be consulted before a `@Bean` is registered.

Implementations of the `Condition` interface provide a `matches(…)` method that returns `true` or `false`. For example, the following listing shows the actual `Condition` implementation used for `@Profile`:

根据一些任意的系统状态，有条件地启用或禁用完整的 `@Configuration` 类，甚至单个 `@Bean` 方法通常很有用。一个常见的例子是，只有在 Spring  `Environment` 中启用了特定的配置文件时，才使用 `@Profile` 注解激活 Bean（有关详细信息，请参阅 [Bean Definition Profiles](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-definition-profiles)）。

`@Profile` 注解实际上是通过使用一个更灵活的名为 [`@Conditional`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/annotation/Conditional.html)的注解来实现的。`@Conditional` 注解表示在注册 `@Bean` 之前应该参考的特定 `org.springframework.context.annotation.Condition` 实现。

`Condition` 接口的实现提供了一个返回 `true` 或 `false` 的 `matches(…)` 方法。例如，下面的列表显示了用于 `@Profile` 的实际 `Condition` 实现：

```java
@Override
public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    // Read the @Profile annotation attributes
    MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
    if (attrs != null) {
        for (Object value : attrs.get("value")) {
            if (context.getEnvironment().acceptsProfiles(((String[]) value))) {
                return true;
            }
        }
        return false;
    }
    return true;
}
```

See the [`@Conditional`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/annotation/Conditional.html) javadoc for more detail.

参见[`@Conditional`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/annotation/Conditional.html)javadoc 获取更多详细信息。

##### Combining Java and XML Configuration

##### 结合 Java 和 XML 配置

Spring’s `@Configuration` class support does not aim to be a 100% complete replacement for Spring XML. Some facilities, such as Spring XML namespaces, remain an ideal way to configure the container. In cases where XML is convenient or necessary, you have a choice: either instantiate the container in an “XML-centric” way by using, for example, `ClassPathXmlApplicationContext`, or instantiate it in a “Java-centric” way by using `AnnotationConfigApplicationContext` and the `@ImportResource` annotation to import XML as needed.

Spring 的 `@Configuration` 类支持的目标并不是 100% 完全替代 Spring XML。一些工具，比如 Spring XML 名称空间，仍然是配置容器的理想方式。在 XML 方便或必要的情况下，您可以选择：或者使用“以 XML 为中心”的方式实例化容器，例如使用 `ClassPathXmlApplicationContext`，或者使用 `AnnotationConfigApplicationContext` 和 `@ImportResource` 注解以“以 Java 为中心”的方式实例化容器，以便根据需要导入 XML。

###### XML-centric Use of `@Configuration` Classes

###### 以 XML 为中心使用 `@Configuration` 类

It may be preferable to bootstrap the Spring container from XML and include `@Configuration` classes in an ad-hoc fashion. For example, in a large existing codebase that uses Spring XML, it is easier to create `@Configuration` classes on an as-needed basis and include them from the existing XML files. Later in this section, we cover the options for using `@Configuration` classes in this kind of “XML-centric” situation.

Declaring `@Configuration` classes as plain Spring `<bean/>` elements

Remember that `@Configuration` classes are ultimately bean definitions in the container. In this series examples, we create a `@Configuration` class named `AppConfig` and include it within `system-test-config.xml` as a `<bean/>` definition. Because `<context:annotation-config/>` is switched on, the container recognizes the `@Configuration` annotation and processes the `@Bean` methods declared in `AppConfig` properly.

The following example shows an ordinary configuration class in Java:

最好从 XML 引导 Spring 容器，并以特殊方式包含 `@Configuration` 类。例如，在使用 Spring XML 的现有大型代码库中，根据需要创建 `@Configuration` 类并从现有 XML 文件中包含它们更容易。在本节后面，我们将介绍在这种“以 XML 为中心”的情况下使用 `@Configuration` 类的选项。

将 `@Configuration` 类声明为纯 Spring `<bean/>` 元素

记住，`@Configuration` 类最终是容器中的 bean 定义。在本系列示例中，我们创建了一个名为 `AppConfig` 的`@Configuration` 类，并将其作为 `<bean/>` 定义包含在 `system-test-config.xml` 中。因为 `<context:annotation-config/>` 已打开，所以容器会识别 `@Configuration` 注解，并正确处理在 `AppConfig` 中声明的 `@Bean` 方法。

以下示例显示了 Java 中的一个普通配置类：

```java
@Configuration
public class AppConfig {

    @Autowired
    private DataSource dataSource;

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }

    @Bean
    public TransferService transferService() {
        return new TransferService(accountRepository());
    }
}
```

The following example shows part of a sample `system-test-config.xml` file:

以下示例显示了示例 `system-test-config.xml` 文件的一部分：

```xml
<beans>
    <!-- enable processing of annotations such as @Autowired and @Configuration -->
    <context:annotation-config/>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>

    <bean class="com.acme.AppConfig"/>

    <bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
</beans>
```

The following example shows a possible `jdbc.properties` file:

以下示例显示了一个可能的 `jdbc.properties` 文件：

```
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=
```

```java
public static void main(String[] args) {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml");
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}
```

> In `system-test-config.xml` file, the `AppConfig` `<bean/>` does not declare an `id` element. While it would be acceptable to do so, it is unnecessary, given that no other bean ever refers to it, and it is unlikely to be explicitly fetched from the container by name. Similarly, the `DataSource` bean is only ever autowired by type, so an explicit bean `id` is not strictly required.
>
> 在 `system-test-config.xml` 文件中，`AppConfig` `<bean/>` 不声明 `id` 元素。虽然这样做是可以接受的，但这是不必要的，因为没有其他 bean 引用它，而且不太可能通过名称从容器显式获取它。类似地，`DataSource` bean 也只是按类型自动连接的，因此不严格要求显式 bean `id`。

Using `<context:component-scan/>` to pick up `@Configuration` classes

Because `@Configuration` is meta-annotated with `@Component`, `@Configuration`-annotated classes are automatically candidates for component scanning. Using the same scenario as describe in the previous example, we can redefine `system-test-config.xml` to take advantage of component-scanning. Note that, in this case, we need not explicitly declare `<context:annotation-config/>`, because `<context:component-scan/>` enables the same functionality.

The following example shows the modified `system-test-config.xml` file:

使用 `<context:component-scan/>` 获取 `@Configuration` 类

因为 `@Configuration` 是用 `@Component` 进行元注解的，所以带 `@Configuration` 注解的类自动成为组件扫描的候选对象。使用上一个示例中描述的相同场景，我们可以重新定义 `system-test-config.xml`，以利用组件扫描。请注意，在本例中，我们不需要显式声明 `<context:annotation-config/>`，因为 `<context:component-scan/>` 启用了相同的功能。

以下示例显示了修改后的 `system-test-config.xml` 文件：

```xml
<beans>
    <!-- picks up and registers AppConfig as a bean definition -->
    <context:component-scan base-package="com.acme"/>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>

    <bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
</beans>
```

###### `@Configuration` Class-centric Use of XML with `@ImportResource`

###### `@Configuration` 以类为中心使用带有`@ImportResource` 的 XML

In applications where `@Configuration` classes are the primary mechanism for configuring the container, it is still likely necessary to use at least some XML. In these scenarios, you can use `@ImportResource` and define only as much XML as you need. Doing so achieves a “Java-centric” approach to configuring the container and keeps XML to a bare minimum. The following example (which includes a configuration class, an XML file that defines a bean, a properties file, and the `main` class) shows how to use the `@ImportResource` annotation to achieve “Java-centric” configuration that uses XML as needed:

在 `@Configuration` 类是配置容器的主要机制的应用程序中，可能仍然需要至少使用一些 XML。在这些场景中，您可以使用 `@ImportResource`，只定义所需的 XML。这样做可以实现一种「以 Java 为中心」的方法来配置容器，并将 XML 保持在最低限度。以下示例（包括一个配置类、一个定义 bean 的 XML 文件、一个属性文件和 `main` 类）展示了如何使用 `@ImportResource` 注解来实现「以 Java 为中心」的配置，该配置根据需要使用 XML：

```java
@Configuration
@ImportResource("classpath:/com/acme/properties-config.xml")
public class AppConfig {

    @Value("${jdbc.url}")
    private String url;

    @Value("${jdbc.username}")
    private String username;

    @Value("${jdbc.password}")
    private String password;

    @Bean
    public DataSource dataSource() {
        return new DriverManagerDataSource(url, username, password);
    }
}
```

```xml
properties-config.xml
<beans>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>
</beans>
```

```properties
jdbc.properties
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=
```

```java
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}
```

### 1.13. Environment Abstraction

### 1.13. 环境抽象

The [`Environment`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/env/Environment.html) interface is an abstraction integrated in the container that models two key aspects of the application environment: [profiles](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-definition-profiles) and [properties](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-property-source-abstraction).

A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or with annotations. The role of the `Environment` object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default.

Properties play an important role in almost all applications and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc `Properties` objects, `Map` objects, and so on. The role of the `Environment` object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them.

**[`Environment`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/env/Environment.html) 接口是集成在容器中的抽象，它对应用程序环境的两个关键方面建模：[profiles](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-definition-profiles) 和 [properties](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-property-source-abstraction)。**

配置文件是一个命名的、逻辑的 bean 定义组，只有在给定的配置文件处于活动状态时，才会向容器注册。bean 可以被分配给一个概要文件，无论是用 XML 定义的还是带有注解的。与配置文件相关的 `Environment` 对象的作用是确定哪些配置文件（如果有的话）当前处于活动状态，以及哪些配置文件（如果有的话）在默认情况下应该处于活动状态。

属性在几乎所有的应用程序中都扮演着重要的角色，可能来自各种来源：属性文件、JVM 系统属性、系统环境变量、JNDI、servlet 上下文参数、即席的 `Properties` 对象、`Map` 对象等等。与属性相关的 `Environment` 对象的作用是为用户提供一个方便的服务界面，用于配置属性源和解析属性。

#### 1.13.1. Bean Definition Profiles

#### 1.13.1. Bean定义配置文件

Bean definition profiles provide a mechanism in the core container that allows for registration of different beans in different environments. The word, “environment,” can mean different things to different users, and this feature can help with many use cases, including:

- Working against an in-memory datasource in development versus looking up that same datasource from JNDI when in QA or production.
- Registering monitoring infrastructure only when deploying an application into a performance environment.
- Registering customized implementations of beans for customer A versus customer B deployments.

Consider the first use case in a practical application that requires a `DataSource`. In a test environment, the configuration might resemble the following:

Bean 定义概要文件在核心容器中提供了一种机制，允许在不同环境中注册不同的 Bean。“environment”这个词对不同的用户来说意味着不同的东西，这个特性可以帮助处理许多用例，包括：

- 在开发中使用内存中的数据源，而不是在 QA 或生产中从 JNDI 中查找相同的数据源。
- 仅在将应用程序部署到性能环境中时注册监控基础架构。
- 为客户 A 和客户 B 部署注册定制的 bean 实现。

考虑实际应用中需要 `DataSource` 的第一个用例。在测试环境中，配置可能类似于以下内容：

```java
@Bean
public DataSource dataSource() {
    return new EmbeddedDatabaseBuilder()
        .setType(EmbeddedDatabaseType.HSQL)
        .addScript("my-schema.sql")
        .addScript("my-test-data.sql")
        .build();
}
```

Now consider how this application can be deployed into a QA or production environment, assuming that the datasource for the application is registered with the production application server’s JNDI directory. Our `dataSource` bean now looks like the following listing:

现在考虑如何将这个应用程序部署到 QA 或生产环境中，假设应用程序的数据源已注册到生产应用服务器的 JNDI 目录。我们的 `dataSource` bean 现在看起来如下所示：

```java
@Bean(destroyMethod="")
public DataSource dataSource() throws Exception {
    Context ctx = new InitialContext();
    return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
}
```

The problem is how to switch between using these two variations based on the current environment. Over time, Spring users have devised a number of ways to get this done, usually relying on a combination of system environment variables and XML `<import/>` statements containing `${placeholder}` tokens that resolve to the correct configuration file path depending on the value of an environment variable. Bean definition profiles is a core container feature that provides a solution to this problem.

If we generalize the use case shown in the preceding example of environment-specific bean definitions, we end up with the need to register certain bean definitions in certain contexts but not in others. You could say that you want to register a certain profile of bean definitions in situation A and a different profile in situation B. We start by updating our configuration to reflect this need.

问题是如何根据当前环境在使用这两种变体之间切换。随着时间的推移，Spring 用户已经设计了许多方法来实现这一点，通常依赖于系统环境变量和包含 `${placeholder}` 标记的 XML `<import/>` 语句的组合，这些标记根据环境变量的值解析为正确的配置文件路径。Bean 定义概要文件是一个核心容器特性，它为这个问题提供了解决方案。

如果我们概括前面的特定于环境的 bean 定义示例中所示的用例，我们最终需要在某些上下文中注册某些 bean 定义，而不是在其他上下文中注册。您可以说，您希望在情况 A 中注册 bean 定义的某个配置文件，在情况 B 中注册另一个配置文件。我们首先更新配置以反映这一需求。

##### Using `@Profile`

##### 使用 `@Profile`

The [`@Profile`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/annotation/Profile.html) annotation lets you indicate that a component is eligible for registration when one or more specified profiles are active. Using our preceding example, we can rewrite the `dataSource` configuration as follows:

 [`@Profile`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/annotation/Profile.html) 注解允许您在一个或多个指定的配置文件处于活动状态时指示组件符合注册条件。使用前面的示例，我们可以按如下方式重写 `dataSource` 配置：

```java
@Configuration
@Profile("development")
public class StandaloneDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }
}
```

```java
@Configuration
@Profile("production")
public class JndiDataConfig {

    @Bean(destroyMethod="")
    public DataSource dataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}
```

> As mentioned earlier, with `@Bean` methods, you typically choose to use programmatic JNDI lookups, by using either Spring’s `JndiTemplate`/`JndiLocatorDelegate` helpers or the straight JNDI `InitialContext` usage shown earlier but not the `JndiObjectFactoryBean` variant, which would force you to declare the return type as the `FactoryBean` type.
>
> 如前所述，对于 `@Bean` 方法，您通常选择使用编程 JNDI 查找，方法是使用 Spring 的 `JndiTemplate` /`JndiLocatorDelegate` 帮助程序或前面所示的直接 JNDI `InitialContext` 用法，而不是使用 `JndiObjectFactoryBean` 变量，这将迫使您将返回类型声明为 `FactoryBean` 类型。

The profile string may contain a simple profile name (for example, `production`) or a profile expression. A profile expression allows for more complicated profile logic to be expressed (for example, `production & us-east`). The following operators are supported in profile expressions:

- `!`: A logical “not” of the profile
- `&`: A logical “and” of the profiles
- `|`: A logical “or” of the profiles

配置文件字符串可能包含一个简单的配置文件名称（例如，`production`）或配置文件表达式。配置文件表达式允许表达更复杂的配置文件逻辑（例如，`production & us-east`）。配置文件表达式中支持以下运算符：

- `!`: 配置文件的逻辑“非”
- `&`：配置文件的逻辑“和”
- `|`：配置文件的逻辑“或”

> You cannot mix the `&` and `|` operators without using parentheses. For example, `production & us-east | eu-central` is not a valid expression. It must be expressed as `production & (us-east | eu-central)`.
>
> 如果不使用括号，就不能混合使用 `&` 和 `|` 运算符。例如，`production & us-east | eu-central`不是有效的表达式。它必须表示为 `production & (us-east | eu-central)`。

You can use `@Profile` as a [meta-annotation](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-meta-annotations) for the purpose of creating a custom composed annotation. The following example defines a custom `@Production` annotation that you can use as a drop-in replacement for `@Profile("production")`:

您可以将 `@Profile` 用作 [meta-annotation](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-meta-annotations)，以创建自定义的组合注解。下面的示例定义了一个自定义的 `@Production` 注解，您可以将其用作 `@Profile("production")` 的插入式替换：

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Profile("production")
public @interface Production {
}
```

>   If a `@Configuration` class is marked with `@Profile`, all of the `@Bean` methods and `@Import` annotations associated with that class are bypassed unless one or more of the specified profiles are active. If a `@Component` or `@Configuration` class is marked with `@Profile({"p1", "p2"})`, that class is not registered or processed unless profiles 'p1' or 'p2' have been activated. If a given profile is prefixed with the NOT operator (`!`), the annotated element is registered only if the profile is not active. For example, given `@Profile({"p1", "!p2"})`, registration will occur if profile 'p1' is active or if profile 'p2' is not active.
>
>   如果一个 `@Configuration` 类被标记为 `@Profile`，那么所有与该类关联的 `@Bean` 方法和 `@Import` 注解都将被绕过，除非一个或多个指定的概要文件处于活动状态。如果一个 `@Component` 或 `@Configuration` 类被标记为 `@Profile({"p1","p2"})`，则除非激活了 Profile “p1” 或 “p2”，否则不会注册或处理该类。如果给定的配置文件以 NOT 运算符（`!`）作为前缀，则仅当配置文件未处于活动状态时，才会注册带注解的元素。例如，给定 `@Profile({"p1", "!p2"})`，如果配置文件 “p1” 处于活动状态或配置文件 “p2” 处于非活动状态，则会发生注册。

`@Profile` can also be declared at the method level to include only one particular bean of a configuration class (for example, for alternative variants of a particular bean), as the following example shows:

`@Profile` 也可以在方法级别声明为只包含配置类的一个特定 bean（例如，对于特定 bean 的替代变量），如下例所示：

```java
@Configuration
public class AppConfig {

    @Bean("dataSource")
    @Profile("development")  // 注释一
    public DataSource standaloneDataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }

    @Bean("dataSource")
    @Profile("production")  // 注释二
    public DataSource jndiDataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}
```

- 注释一：The `standaloneDataSource` method is available only in the `development` profile.

    `standaloneDataSource` 方法仅在 `development` 配置文件中可用。

- 注释二：The `jndiDataSource` method is available only in the `production` profile.

    `jndiDataSource` 方法仅在 `production` 配置文件中可用。

> With `@Profile` on `@Bean` methods, a special scenario may apply: In the case of overloaded `@Bean` methods of the same Java method name (analogous to constructor overloading), a `@Profile` condition needs to be consistently declared on all overloaded methods. If the conditions are inconsistent, only the condition on the first declaration among the overloaded methods matters. Therefore, `@Profile` can not be used to select an overloaded method with a particular argument signature over another. Resolution between all factory methods for the same bean follows Spring’s constructor resolution algorithm at creation time.If you want to define alternative beans with different profile conditions, use distinct Java method names that point to the same bean name by using the `@Bean` name attribute, as shown in the preceding example. If the argument signatures are all the same (for example, all of the variants have no-arg factory methods), this is the only way to represent such an arrangement in a valid Java class in the first place (since there can only be one method of a particular name and argument signature).
>
> 在 `@Bean` 方法上使用 `@Profile` 时，可能会出现一种特殊的情况：如果重载了具有相同 Java 方法名称的 `@Bean` 方法（类似于构造函数重载），则需要在所有重载方法上一致地声明 `@Profile` 条件。如果条件不一致，则只有重载方法中第一个声明上的条件才重要。因此，`@Profile`不能用于选择具有特定参数签名的重载方法。同一 bean 的所有工厂方法之间的解析在创建时遵循 Spring 的构造函数解析算法。如果要定义具有不同配置文件条件的替代 bean，请使用 `@Bean` name属性，使用指向同一 bean 名称的不同 Java 方法名称，如前一示例所示。如果参数签名都是相同的（例如，所有变体都没有 arg 工厂方法），这是在有效的 Java 类中首先表示这种安排的唯一方法（因为特定名称和参数签名只能有一个方法）。

##### XML Bean Definition Profiles

##### XML Bean 定义配置文件

The XML counterpart is the `profile` attribute of the `<beans>` element. Our preceding sample configuration can be rewritten in two XML files, as follows:

XML 对应项是 `<beans>` 元素的 `profile` 属性。我们前面的示例配置可以在两个 XML 文件中重写，如下所示：

```xml
<beans profile="development"
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc"
    xsi:schemaLocation="...">

    <jdbc:embedded-database id="dataSource">
        <jdbc:script location="classpath:com/bank/config/sql/schema.sql"/>
        <jdbc:script location="classpath:com/bank/config/sql/test-data.sql"/>
    </jdbc:embedded-database>
</beans>
```

```xml
<beans profile="production"
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="...">

    <jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
</beans>
```

It is also possible to avoid that split and nest `<beans/>` elements within the same file, as the following example shows:

也可以避免在同一个文件中拆分和嵌套 `<beans/>` 元素，如下例所示：

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="...">

    <!-- other bean definitions -->

    <beans profile="development">
        <jdbc:embedded-database id="dataSource">
            <jdbc:script location="classpath:com/bank/config/sql/schema.sql"/>
            <jdbc:script location="classpath:com/bank/config/sql/test-data.sql"/>
        </jdbc:embedded-database>
    </beans>

    <beans profile="production">
        <jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
    </beans>
</beans>
```

The `spring-bean.xsd` has been constrained to allow such elements only as the last ones in the file. This should help provide flexibility without incurring clutter in the XML files.

 `spring-bean.xsd` 被限制为只允许文件中最后一个元素。这将有助于提供灵活性，而不会导致 XML 文件混乱。

>    The XML counterpart does not support the profile expressions described earlier. It is possible, however, to negate a profile by using the `!` operator. It is also possible to apply a logical “and” by nesting the profiles, as the following example shows:
>
>    XML 对应项不支持前面描述的配置文件表达式。但是，可以使用 `!` 来否定配置文件操作人员也可以通过嵌套配置文件来应用逻辑“和”，如下例所示：
>
>    ```xml
>    <beans xmlns="http://www.springframework.org/schema/beans"
>       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
>       xmlns:jdbc="http://www.springframework.org/schema/jdbc"
>       xmlns:jee="http://www.springframework.org/schema/jee"
>       xsi:schemaLocation="...">
>    
>       <!-- other bean definitions -->
>    
>       <beans profile="production">
>           <beans profile="us-east">
>               <jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
>           </beans>
>       </beans>
>    </beans>
>    ```
>
>    In the preceding example, the `dataSource` bean is exposed if both the `production` and `us-east` profiles are active.
>
>    在前面的示例中，如果 `production` 和 `us-east` 配置文件都处于活动状态， `dataSource` bean 就会被公开。

##### Activating a Profile

Now that we have updated our configuration, we still need to instruct Spring which profile is active. If we started our sample application right now, we would see a `NoSuchBeanDefinitionException` thrown, because the container could not find the Spring bean named `dataSource`.

Activating a profile can be done in several ways, but the most straightforward is to do it programmatically against the `Environment` API which is available through an `ApplicationContext`. The following example shows how to do so:

既然我们已经更新了配置，我们仍然需要指示 Spring 哪个配置文件处于活动状态。如果我们现在启动示例应用程序，就会看到抛出一个 `NoSuchBeanDefinitionException`，因为容器找不到名为 `dataSource` 的 Spring bean。

激活配置文件可以通过多种方式完成，但最简单的方法是通过 `ApplicationContext` 通过 `Environment` API 以编程方式完成。以下示例显示了如何执行此操作：

```java
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles("development");
ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
ctx.refresh();
```

In addition, you can also declaratively activate profiles through the `spring.profiles.active` property, which may be specified through system environment variables, JVM system properties, servlet context parameters in `web.xml`, or even as an entry in JNDI (see [`PropertySource` Abstraction](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-property-source-abstraction)). In integration tests, active profiles can be declared by using the `@ActiveProfiles` annotation in the `spring-test` module (see [context configuration with environment profiles](https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management-env-profiles)).

Note that profiles are not an “either-or” proposition. You can activate multiple profiles at once. Programmatically, you can provide multiple profile names to the `setActiveProfiles()` method, which accepts `String…` varargs. The following example activates multiple profiles:

**此外，您还可以通过 `spring.profiles.active` 属性声明性地激活概要文件**，该属性可以通过 `web.xml` 中的系统环境变量、JVM 系统属性、servlet 上下文参数指定，甚至可以作为 JNDI 中的一个条目指定（请参见 [`PropertySource` 抽象](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-property-source-abstraction)）。在集成测试中，可以通过使用 `spring-test` 模块中的 `@ActiveProfiles` 注解来声明活动概要文件（请参见[环境概要文件的上下文配置](https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html#testcontext-ctx-management-env-profiles)）。

请注意，配置文件不是「非此即彼」的命题。您可以一次激活多个配置文件。通过编程，您可以为 `setActiveProfiles()` 方法提供多个配置文件名，该方法接受 `String…` varargs。以下示例激活多个配置文件：

```java
ctx.getEnvironment().setActiveProfiles("profile1", "profile2");
```

Declaratively, `spring.profiles.active` may accept a comma-separated list of profile names, as the following example shows:

声明性地，`spring.profiles.active` 可以接受以逗号分隔的配置文件名称列表，如下例所示：

```xml
-Dspring.profiles.active="profile1,profile2"
```

##### Default Profile

The default profile represents the profile that is enabled by default. Consider the following example:

默认配置文件表示默认启用的配置文件。考虑下面的例子：

```java
@Configuration
@Profile("default")
public class DefaultDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .build();
    }
}
```

If no profile is active, the `dataSource` is created. You can see this as a way to provide a default definition for one or more beans. If any profile is enabled, the default profile does not apply.

You can change the name of the default profile by using `setDefaultProfiles()` on the `Environment` or, declaratively, by using the `spring.profiles.default` property.

如果没有激活的配置文件，则会创建 `dataSource`。您可以将此视为为为一个或多个 bean 提供默认定义的一种方式。如果启用了任何配置文件，则默认配置文件不适用。

您可以通过在 `Environment` 中使用 `setDefaultProfiles()` ，或者通过声明性地使用 `spring.profiles.default` 属性来更改默认配置文件的名称。

#### 1.13.2. `PropertySource` Abstraction

#### 1.13.2. `PropertySource` 的抽象

Spring’s `Environment` abstraction provides search operations over a configurable hierarchy of property sources. Consider the following listing:

Spring 的 `Environment` 抽象在可配置的属性源层次结构上提供搜索操作。考虑下面的列表：

```java
ApplicationContext ctx = new GenericApplicationContext();
Environment env = ctx.getEnvironment();
boolean containsMyProperty = env.containsProperty("my-property");
System.out.println("Does my environment contain the 'my-property' property? " + containsMyProperty);
```

In the preceding snippet, we see a high-level way of asking Spring whether the `my-property` property is defined for the current environment. To answer this question, the `Environment` object performs a search over a set of [`PropertySource`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/env/PropertySource.html) objects. A `PropertySource` is a simple abstraction over any source of key-value pairs, and Spring’s [`StandardEnvironment`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/env/StandardEnvironment.html) is configured with two PropertySource objects — one representing the set of JVM system properties (`System.getProperties()`) and one representing the set of system environment variables (`System.getenv()`).

在前面的代码片段中，我们看到了一种询问 Spring 是否为当前环境定义了 `my-property` 属性的高级方法。为了回答这个问题，`Environment` 对象对一组 [`PropertySource`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/env/PropertySource.html) 对象执行搜索。`PropertySource` 是对任何键值对源的简单抽象，Spring 的 [`StandardEnvironment`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/env/StandardEnvironment.html) 配置了两个 PropertySource 对象 — 一个表示 JVM 系统属性集（`System.getProperties()`），另一个表示系统环境变量集（`System.getenv()`）。

> These default property sources are present for `StandardEnvironment`, for use in standalone applications. [`StandardServletEnvironment`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/web/context/support/StandardServletEnvironment.html) is populated with additional default property sources including servlet config and servlet context parameters. It can optionally enable a [`JndiPropertySource`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/jndi/JndiPropertySource.html). See the javadoc for details.
>
> 这些默认属性源用于 `StandardEnvironment`，用于独立应用程序。[`StandardServletEnvironment`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/web/context/support/StandardServletEnvironment.html) 填充了其他默认属性源，包括 servlet 配置和 servlet 上下文参数。它可以选择启用  [`JndiPropertySource`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/jndi/JndiPropertySource.html)。有关详细信息，请参阅 javadoc。

Concretely, when you use the `StandardEnvironment`, the call to `env.containsProperty("my-property")` returns true if a `my-property` system property or `my-property` environment variable is present at runtime.

具体地说，当使用 `StandardEnvironment` 时，如果运行时存在 `my-property` 系统属性或 `my-property` 环境变量，则对 `env.containsProperty("my-property")` 的调用将返回 true。

>   The search performed is hierarchical. By default, system properties have precedence over environment variables. So, if the `my-property` property happens to be set in both places during a call to `env.getProperty("my-property")`, the system property value “wins” and is returned. Note that property values are not merged but rather completely overridden by a preceding entry.For a common `StandardServletEnvironment`, the full hierarchy is as follows, with the highest-precedence entries at the top:ServletConfig parameters (if applicable — for example, in case of a `DispatcherServlet` context)ServletContext parameters (web.xml context-param entries)JNDI environment variables (`java:comp/env/` entries)JVM system properties (`-D` command-line arguments)JVM system environment (operating system environment variables)
>
>   执行的搜索是分层的。默认情况下，系统属性优先于环境变量。因此，如果在调用 `env.getProperty("my-property")` 期间碰巧在两个位置都设置了 `my-property` 属性，则系统属性值「wins」将被返回。请注意，属性值不会合并，而是完全被前面的条目覆盖。对于常见的 `StandardServletEnvironment`，完整的层次结构如下所示，优先级最高的条目位于 top:ServletConfig 参数（如果适用） — 例如，对于 `DispatcherServlet` 上下文）ServletContext 参数（web.xml 上下文参数条目）JNDI 环境变量（`java:comp/env/` 条目）JVM 系统属性（`-D`命令行参数）JVM 系统环境（操作系统环境变量）

Most importantly, the entire mechanism is configurable. Perhaps you have a custom source of properties that you want to integrate into this search. To do so, implement and instantiate your own `PropertySource` and add it to the set of `PropertySources` for the current `Environment`. The following example shows how to do so:

最重要的是，整个机制是可配置的。也许您有一个自定义的属性源，希望将其集成到此搜索中。为此，请实现并实例化您自己的`PropertySource` ，并将其添加到当前 `Environment` 的 `PropertySource` 集合中。以下示例显示了如何执行此操作：

```java
ConfigurableApplicationContext ctx = new GenericApplicationContext();
MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
sources.addFirst(new MyPropertySource());
```

In the preceding code, `MyPropertySource` has been added with highest precedence in the search. If it contains a `my-property` property, the property is detected and returned, in favor of any `my-property` property in any other `PropertySource`. The [`MutablePropertySources`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/env/MutablePropertySources.html) API exposes a number of methods that allow for precise manipulation of the set of property sources.

在前面的代码中，`MyPropertySource` 在搜索中以最高优先级添加。如果它包含 `my-property` 属性，则会检测并返回该属性，以支持任何其他 `PropertySource` 中的任何 `my-property` 属性。[`MutablePropertySources`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/core/env/MutablePropertySources.html) API 公开了许多方法，这些方法允许对属性源集进行精确操作。

#### 1.13.3. Using `@PropertySource`

#### 1.13.3.使用 `@PropertySource`

The [`@PropertySource`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/annotation/PropertySource.html) annotation provides a convenient and declarative mechanism for adding a `PropertySource` to Spring’s `Environment`.

Given a file called `app.properties` that contains the key-value pair `testbean.name=myTestBean`, the following `@Configuration` class uses `@PropertySource` in such a way that a call to `testBean.getName()` returns `myTestBean`:

 [`@PropertySource`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/annotation/PropertySource.html) 注解提供了一种方便的声明性机制，用于向 Spring 的 `Environment` 中添加 `PropertySource` 。

给定一个名为 `app.properties` 的文件，其中包含键值对 `testbean.name=myTestBean`，下面的 `@Configuration` 类使用`@PropertySource`，调用 `testBean.getName()` 返回 `myTestBean`：

```java
@Configuration
@PropertySource("classpath:/com/myco/app.properties")
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty("testbean.name"));
        return testBean;
    }
}
```

Any `${…}` placeholders present in a `@PropertySource` resource location are resolved against the set of property sources already registered against the environment, as the following example shows:

`@PropertySource` 资源位置中存在的任何 `${…}` 占位符都将根据已针对环境注册的属性源集进行解析，如下例所示：

```java
@Configuration
@PropertySource("classpath:/com/${my.placeholder:default/path}/app.properties")
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty("testbean.name"));
        return testBean;
    }
}
```

Assuming that `my.placeholder` is present in one of the property sources already registered (for example, system properties or environment variables), the placeholder is resolved to the corresponding value. If not, then `default/path` is used as a default. If no default is specified and a property cannot be resolved, an `IllegalArgumentException` is thrown.

假设 `my.placeholder` 出现在已注册的某个属性源（例如，系统属性或环境变量）中，占位符将解析为相应的值。如果不是，则使用 `default/path` 作为默认值。如果未指定默认值且无法解析属性，则会引发 `IllegalArgumentException`。

> The `@PropertySource` annotation is repeatable, according to Java 8 conventions. However, all such `@PropertySource` annotations need to be declared at the same level, either directly on the configuration class or as meta-annotations within the same custom annotation. Mixing direct annotations and meta-annotations is not recommended, since direct annotations effectively override meta-annotations.
>
> 根据 Java 8 约定，`@PropertySource` 注解是可重复的。但是，所有此类 `@PropertySource` 注解都需要在同一级别上声明，可以直接在配置类上声明，也可以在同一自定义注解中声明为元注解。不建议混合使用直接注解和元注解，因为直接注解可以有效地覆盖元注解。

#### 1.13.4. Placeholder Resolution in Statements

#### 1.13.4. 语句中的占位符解析

Historically, the value of placeholders in elements could be resolved only against JVM system properties or environment variables. This is no longer the case. Because the `Environment` abstraction is integrated throughout the container, it is easy to route resolution of placeholders through it. This means that you may configure the resolution process in any way you like. You can change the precedence of searching through system properties and environment variables or remove them entirely. You can also add your own property sources to the mix, as appropriate.

Concretely, the following statement works regardless of where the `customer` property is defined, as long as it is available in the `Environment`:

历史上，元素中占位符的值只能根据 JVM 系统属性或环境变量来解析。现在已经不是这样了。由于 `Environment` 抽象集成在整个容器中，因此很容易通过它传递占位符的解析。这意味着您可以以任何方式配置解析过程。可以更改搜索系统属性和环境变量的优先级，也可以完全删除它们。您还可以根据需要将自己的房产资源添加到组合中。

具体来说，以下语句适用于 `customer`属性的定义位置，只要它在 `Environment` 中可用：

```xml
<beans>
    <import resource="com/bank/service/${customer}-config.xml"/>
</beans>
```

### 1.14. Registering a `LoadTimeWeaver`

### 1.14.注册 `LoadTimeWeaver`

The `LoadTimeWeaver` is used by Spring to dynamically transform classes as they are loaded into the Java virtual machine (JVM).

To enable load-time weaving, you can add the `@EnableLoadTimeWeaving` to one of your `@Configuration` classes, as the following example shows:

Spring 使用 `LoadTimeWeaver` 在类加载到 Java 虚拟机（JVM）时动态转换类。

要启用加载时编织，可以将 `@EnableLoadTimeWeaving` 添加到其中一个 `@Configuration` 类中，如下例所示：

```java
@Configuration
@EnableLoadTimeWeaving
public class AppConfig {
}
```

Alternatively, for XML configuration, you can use the `context:load-time-weaver` element:

或者，对于 XML 配置，可以使用 `context:load-time-weaver` 元素：

```xml
<beans>
    <context:load-time-weaver/>
</beans>
```

Once configured for the `ApplicationContext`, any bean within that `ApplicationContext` may implement `LoadTimeWeaverAware`, thereby receiving a reference to the load-time weaver instance. This is particularly useful in combination with [Spring’s JPA support](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#orm-jpa) where load-time weaving may be necessary for JPA class transformation. Consult the [`LocalContainerEntityManagerFactoryBean`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html) javadoc for more detail. For more on AspectJ load-time weaving, see [Load-time Weaving with AspectJ in the Spring Framework](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw).

为 `ApplicationContext` 配置后，`ApplicationContext` 中的任何 bean 都可以实现 `LoadTimeWeaverAware`，从而接收对加载时 weaver 实例的引用。这在结合 [Spring的JPA支持](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#orm-jpa) 时尤其有用，因为 JPA 类转换可能需要加载时编织。有关更多详细信息，请参阅 [`LocalContainerEntityManagerFactoryBean`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html) javadoc。有关 AspectJ 加载时编织的更多信息，请参阅 [Spring 框架中使用 AspectJ 进行加载时编织](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw)。

### 1.15. Additional Capabilities of the `ApplicationContext`

### 1.15. `ApplicationContext` 的其他功能

As discussed in the [chapter introduction](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans), the `org.springframework.beans.factory` package provides basic functionality for managing and manipulating beans, including in a programmatic way. The `org.springframework.context` package adds the [`ApplicationContext`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/ApplicationContext.html) interface, which extends the `BeanFactory` interface, in addition to extending other interfaces to provide additional functionality in a more application framework-oriented style. Many people use the `ApplicationContext` in a completely declarative fashion, not even creating it programmatically, but instead relying on support classes such as `ContextLoader` to automatically instantiate an `ApplicationContext` as part of the normal startup process of a Java EE web application.

To enhance `BeanFactory` functionality in a more framework-oriented style, the context package also provides the following functionality:

- Access to messages in i18n-style, through the `MessageSource` interface.
- Access to resources, such as URLs and files, through the `ResourceLoader` interface.
- Event publication, namely to beans that implement the `ApplicationListener` interface, through the use of the `ApplicationEventPublisher` interface.
- Loading of multiple (hierarchical) contexts, letting each be focused on one particular layer, such as the web layer of an application, through the `HierarchicalBeanFactory` interface.

**如 [导言](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans)一章所述，`org.springframework.beans.factory` 包提供了管理和操作 bean 的基本功能，包括以编程方式。 `org.springframework.context` 包添加了 [`ApplicationContext`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/ApplicationContext.html) 接口，该接口扩展了 `BeanFactory` 接口，此外还扩展了其他接口，以更面向应用程序框架的方式提供附加功能**。许多人以完全声明式的方式使用 `ApplicationContext`，甚至不以编程方式创建它，而是依赖 `ContextLoader` 等支持类自动实例化 `ApplicationContext`，作为 Java EE web 应用程序正常启动过程的一部分。

为了以更面向框架的风格增强 `BeanFactory` 功能，上下文包还提供以下功能：

- 通过 `MessageSource` 接口访问 i18n 风格的消息。
- 通过 `ResourceLoader` 界面访问 URL 和文件等资源。
- 事件发布，即通过使用 `ApplicationEventPublisher` 接口向实现 `ApplicationListener` 接口的 bean 发布。
- 加载多个（分层）上下文，通过 `HierarchicalBeanFactory` 界面将每个上下文集中在一个特定的层上，例如应用程序的web 层。

#### 1.15.1. Internationalization using `MessageSource`

#### 1.15.1. 使用 `MessageSource` 实现国际化

The `ApplicationContext` interface extends an interface called `MessageSource` and, therefore, provides internationalization (“i18n”) functionality. Spring also provides the `HierarchicalMessageSource` interface, which can resolve messages hierarchically. Together, these interfaces provide the foundation upon which Spring effects message resolution. The methods defined on these interfaces include:

- `String getMessage(String code, Object[] args, String default, Locale loc)`: The basic method used to retrieve a message from the `MessageSource`. When no message is found for the specified locale, the default message is used. Any arguments passed in become replacement values, using the `MessageFormat` functionality provided by the standard library.
- `String getMessage(String code, Object[] args, Locale loc)`: Essentially the same as the previous method but with one difference: No default message can be specified. If the message cannot be found, a `NoSuchMessageException` is thrown.
- `String getMessage(MessageSourceResolvable resolvable, Locale locale)`: All properties used in the preceding methods are also wrapped in a class named `MessageSourceResolvable`, which you can use with this method.

When an `ApplicationContext` is loaded, it automatically searches for a `MessageSource` bean defined in the context. The bean must have the name `messageSource`. If such a bean is found, all calls to the preceding methods are delegated to the message source. If no message source is found, the `ApplicationContext` attempts to find a parent containing a bean with the same name. If it does, it uses that bean as the `MessageSource`. If the `ApplicationContext` cannot find any source for messages, an empty `DelegatingMessageSource` is instantiated in order to be able to accept calls to the methods defined above.

Spring provides three `MessageSource` implementations, `ResourceBundleMessageSource`, `ReloadableResourceBundleMessageSource` and `StaticMessageSource`. All of them implement `HierarchicalMessageSource` in order to do nested messaging. The `StaticMessageSource` is rarely used but provides programmatic ways to add messages to the source. The following example shows `ResourceBundleMessageSource`:

`ApplicationContext` 接口扩展了一个名为 `MessageSource` 的接口，因此提供了国际化（“i18n”）功能。Spring 还提供了`HierarchicalMessageSource` 接口，可以按层次解析消息。这些接口共同提供了弹簧效应消息解决的基础。在这些接口上定义的方法包括：

- `String getMessage(String code, Object[] args, String default, Locale loc)`：用于从 `MessageSource`检索消息的基本方法。当找不到指定区域设置的消息时，将使用默认消息。使用标准库提供的 `MessageFormat` 功能，传入的任何参数都将成为替换值。
- `String getMessage(String code, Object[] args, Locale loc)`：基本上与前面的方法相同，但有一个区别：不能指定默认消息。如果找不到该消息，将抛出 `NoSuchMessageException`。
- `String getMessage(MessageSourceResolvable resolvable, Locale locale)`：前面方法中使用的所有属性也被包装在一个名为 `MessageSourceResolvable` 的类中，您可以在这个方法中使用这个类。

加载 `ApplicationContext` 时，它会自动搜索上下文中定义的 `MessageSource` bean。bean 的名称必须为 `messageSource`。如果找到这样一个 bean，那么对前面方法的所有调用都将委托给消息源。如果找不到消息源，`ApplicationContext` 将尝试查找包含同名 bean 的父级。如果是的话，它会使用这个 bean 作为 `MessageSource`。如果 `ApplicationContext` 找不到任何消息源，则会实例化一个空的 `DelegatingMessageSource`，以便能够接受对上面定义的方法的调用。

Spring 提供了三种 `MessageSource` 实现，`ResourceBundleMessageSource`、`ReloadableResourceBundleMessageSource` 和 `StaticMessageSource` 。它们都实现了 `HierarchicalMessageSource`，以便进行嵌套消息传递。`StaticMessageSource` 很少使用，但提供了向源添加消息的编程方式。以下示例显示了 `ResourceBundleMessageSource`：

```xml
<beans>
    <bean id="messageSource"
            class="org.springframework.context.support.ResourceBundleMessageSource">
        <property name="basenames">
            <list>
                <value>format</value>
                <value>exceptions</value>
                <value>windows</value>
            </list>
        </property>
    </bean>
</beans>
```

The example assumes that you have three resource bundles called `format`, `exceptions` and `windows` defined in your classpath. Any request to resolve a message is handled in the JDK-standard way of resolving messages through `ResourceBundle` objects. For the purposes of the example, assume the contents of two of the above resource bundle files are as follows:

本例假设在类路径中定义了三个名为 `format`, `exceptions` 和 `windows` 的资源包。解析消息的任何请求都是通过 `ResourceBundle` 对象以 JDK 解析消息的标准方式处理的。在本例中，假设上述两个资源包文件的内容如下：

```
    # in format.properties
    message=Alligators rock!
    # in exceptions.properties
    argument.required=The {0} argument is required.
```

The next example shows a program to run the `MessageSource` functionality. Remember that all `ApplicationContext` implementations are also `MessageSource` implementations and so can be cast to the `MessageSource` interface.

下一个示例显示了运行 `MessageSource` 功能的程序。请记住，所有的 `ApplicationContext` 实现也是 `MessageSource` 实现，因此可以转换到 `MessageSource` 接口。

```java
public static void main(String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("message", null, "Default", Locale.ENGLISH);
    System.out.println(message);
}
```

The resulting output from the above program is as follows:

上述程序的结果输出如下：

```
Alligators rock!
```

To summarize, the `MessageSource` is defined in a file called `beans.xml`, which exists at the root of your classpath. The `messageSource` bean definition refers to a number of resource bundles through its `basenames` property. The three files that are passed in the list to the `basenames` property exist as files at the root of your classpath and are called `format.properties`, `exceptions.properties`, and `windows.properties`, respectively.

The next example shows arguments passed to the message lookup. These arguments are converted into `String` objects and inserted into placeholders in the lookup message.

总之，`MessageSource` 是在一个名为 `beans.xml` 的文件中定义的，该文件位于类路径的根目录下。`messageSource` bean 定义通过其 `basenames` 属性引用了许多资源束。在列表中传递给 `basenames` 属性的三个文件作为文件存在于类路径的根目录下，称为 `format.properties` 分别是 `exceptions.properties` 和 `windows.properties`。

下一个示例显示传递给消息查找的参数。这些参数被转换为 `String` 对象，并插入到查找消息中的占位符中。

```xml
<beans>
    <!-- this MessageSource is being used in a web application -->
    <bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
        <property name="basename" value="exceptions"/>
    </bean>

    <!-- lets inject the above MessageSource into this POJO -->
    <bean id="example" class="com.something.Example">
        <property name="messages" ref="messageSource"/>
    </bean>

</beans>
```

```java
public class Example {

    private MessageSource messages;

    public void setMessages(MessageSource messages) {
        this.messages = messages;
    }

    public void execute() {
        String message = this.messages.getMessage("argument.required",
            new Object [] {"userDao"}, "Required", Locale.ENGLISH);
        System.out.println(message);
    }
}
```

The resulting output from the invocation of the `execute()` method is as follows:

调用 `execute()` 方法的结果如下：

```
The userDao argument is required.
```

With regard to internationalization (“i18n”), Spring’s various `MessageSource` implementations follow the same locale resolution and fallback rules as the standard JDK `ResourceBundle`. In short, and continuing with the example `messageSource` defined previously, if you want to resolve messages against the British (`en-GB`) locale, you would create files called `format_en_GB.properties`, `exceptions_en_GB.properties`, and `windows_en_GB.properties`, respectively.

Typically, locale resolution is managed by the surrounding environment of the application. In the following example, the locale against which (British) messages are resolved is specified manually:

关于国际化（“i18n”），Spring 的各种 `MessageSource` 实现遵循与标准 JDK `ResourceBundle` 相同的语言环境解析和回退规则。简而言之，继续前面定义的示例 `messageSource`，如果要根据英国（`en-GB`）语言环境解析消息，可以分别创建名为`format_en_GB.properties`、`exceptions_en_GB.properties` 和 `windows_en_GB.properties` 的文件。

通常，区域设置解析由应用程序的周围环境管理。在以下示例中，将手动指定解析（英国）消息所依据的区域设置：

```
# in exceptions_en_GB.properties
argument.required=Ebagum lad, the ''{0}'' argument is required, I say, required.
```

```java
public static void main(final String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("argument.required",
        new Object [] {"userDao"}, "Required", Locale.UK);
    System.out.println(message);
}
```

The resulting output from the running of the above program is as follows:

运行上述程序的结果输出如下：

```
Ebagum lad, the 'userDao' argument is required, I say, required.
```

You can also use the `MessageSourceAware` interface to acquire a reference to any `MessageSource` that has been defined. Any bean that is defined in an `ApplicationContext` that implements the `MessageSourceAware` interface is injected with the application context’s `MessageSource` when the bean is created and configured.

还可以使用 `MessageSourceAware` 接口获取对已定义的任何 `MessageSource` 的引用。当创建和配置 bean 时，在实现 `MessageSourceAware` 接口的 `ApplicationContext` 中定义的任何 bean 都会被注入应用程序上下文的 `MessageSource`。

> Because Spring’s `MessageSource` is based on Java’s `ResourceBundle`, it does not merge bundles with the same base name, but will only use the first bundle found. Subsequent message bundles with the same base name are ignored.
>
> 因为 Spring 的 `MessageSource` 基于 Java 的 `ResourceBundle`，所以它不会合并具有相同基本名称的捆绑包，而是只使用找到的第一个捆绑包。具有相同基本名称的后续消息包将被忽略。

> As an alternative to `ResourceBundleMessageSource`, Spring provides a `ReloadableResourceBundleMessageSource` class. This variant supports the same bundle file format but is more flexible than the standard JDK based `ResourceBundleMessageSource` implementation. In particular, it allows for reading files from any Spring resource location (not only from the classpath) and supports hot reloading of bundle property files (while efficiently caching them in between). See the [`ReloadableResourceBundleMessageSource`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/support/ReloadableResourceBundleMessageSource.html) javadoc for details.
>
> 作为`ResourceBundleMessageSource`的替代方案，Spring 提供了一个 `ReloadableResourceBundleMessageSource` 类。此变体支持相同的捆绑文件格式，但比标准的基于 JDK 的 `ResourceBundleMessageSource` 实现更灵活。特别是，它允许从任何 Spring 资源位置读取文件（不仅仅是从类路径），并支持热重新加载捆绑包属性文件（同时在两者之间高效地缓存它们）。有关详细信息，请参阅 [`ReloadableResourceBundleMessageSource`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/support/ReloadableResourceBundleMessageSource.html) javadoc。

#### 1.15.2. Standard and Custom Events

Event handling in the `ApplicationContext` is provided through the `ApplicationEvent` class and the `ApplicationListener` interface. If a bean that implements the `ApplicationListener` interface is deployed into the context, every time an `ApplicationEvent` gets published to the `ApplicationContext`, that bean is notified. Essentially, this is the standard Observer design pattern.

`ApplicationContext` 中的事件处理是通过 `ApplicationEvent` 类和 `ApplicationListener` 接口提供的。如果将实现 `ApplicationListener` 接口的 bean 部署到上下文中，则每次将 `ApplicationEvent` 发布到 `ApplicationContext` 时，都会通知该 bean。本质上，这是标准的观察者设计模式。

> As of Spring 4.2, the event infrastructure has been significantly improved and offers an [annotation-based model](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-events-annotation) as well as the ability to publish any arbitrary event (that is, an object that does not necessarily extend from `ApplicationEvent`). When such an object is published, we wrap it in an event for you.
>
> 从 Spring 4.2 开始，事件基础设施得到了显著改进，并提供了一个[基于注解的模型](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-events-annotation) 以及发布任意事件的能力（即，不一定从 `ApplicationEvent` 扩展的对象）。发布此类对象时，我们会将其包装在事件中。

The following table describes the standard events that Spring provides:

下表描述了 Spring 提供的标准事件：

| Event                        | Explanation                                                  |
| :--------------------------- | :----------------------------------------------------------- |
| `ContextRefreshedEvent`      | Published when the `ApplicationContext` is initialized or refreshed (for example, by using the `refresh()` method on the `ConfigurableApplicationContext` interface). Here, “initialized” means that all beans are loaded, post-processor beans are detected and activated, singletons are pre-instantiated, and the `ApplicationContext` object is ready for use. As long as the context has not been closed, a refresh can be triggered multiple times, provided that the chosen `ApplicationContext` actually supports such “hot” refreshes. For example, `XmlWebApplicationContext` supports hot refreshes, but `GenericApplicationContext` does not.<br />在初始化或刷新 `ApplicationContext` 时发布（例如，通过在 `ConfigurableApplicationContext` 界面上使用 `refresh()` 方法）。这里，「initialized」意味着加载所有 bean，检测并激活后处理器 bean，预实例化单例，并且 `ApplicationContext` 对象已准备好使用。只要上下文尚未关闭，刷新可以多次触发，前提是所选的 `ApplicationContext` 实际上支持这种“热”刷新。例如，`XmlWebApplicationContext` 支持热刷新，但`GenericApplicationContext`不支持。 |
| `ContextStartedEvent`        | Published when the `ApplicationContext` is started by using the `start()` method on the `ConfigurableApplicationContext` interface. Here, “started” means that all `Lifecycle` beans receive an explicit start signal. Typically, this signal is used to restart beans after an explicit stop, but it may also be used to start components that have not been configured for autostart (for example, components that have not already started on initialization).<br />在 `ConfigurableApplicationContext` 界面上使用 `start()`方法启动 `ApplicationContext` 时发布。在这里，“started” 意味着所有的 `Lifecycle` bean 都会收到一个明确的启动信号。通常，此信号用于在显式停止后重新启动 bean，但也可用于启动尚未配置为 autostart 的组件（例如，初始化时尚未启动的组件）。 |
| `ContextStoppedEvent`        | Published when the `ApplicationContext` is stopped by using the `stop()` method on the `ConfigurableApplicationContext` interface. Here, “stopped” means that all `Lifecycle` beans receive an explicit stop signal. A stopped context may be restarted through a `start()` call.<br />在 `ConfigurableApplicationContext` 界面上使用 `stop()` 方法停止 `ApplicationContext` 时发布。这里，“stopped” 意味着所有的 `Lifecycle` bean 都会收到一个明确的停止信号。可以通过 `start()` 调用重新启动已停止的上下文。 |
| `ContextClosedEvent`         | Published when the `ApplicationContext` is being closed by using the `close()` method on the `ConfigurableApplicationContext` interface or via a JVM shutdown hook. Here, "closed" means that all singleton beans will be destroyed. Once the context is closed, it reaches its end of life and cannot be refreshed or restarted.<br />在使用 `ConfigurableApplicationContext` 接口上的 `close()` 方法或通过 JVM 关闭挂钩关闭 `ApplicationContext` 时发布。在这里，“关闭”意味着所有的单体 bean 都将被销毁。一旦上下文关闭，它将达到其生命周期的终点，无法刷新或重新启动。 |
| `RequestHandledEvent`        | A web-specific event telling all beans that an HTTP request has been serviced. This event is published after the request is complete. This event is only applicable to web applications that use Spring’s `DispatcherServlet`.<br />一个特定于 web 的事件，告诉所有 bean HTTP 请求已得到服务。此事件在请求完成后发布。此事件仅适用于使用 Spring 的 `DispatcherServlet` 的 web 应用程序。 |
| `ServletRequestHandledEvent` | A subclass of `RequestHandledEvent` that adds Servlet-specific context information.<br />`RequestHandledEvent` 的一个子类，用于添加特定于 Servlet 的上下文信息。 |

You can also create and publish your own custom events. The following example shows a simple class that extends Spring’s `ApplicationEvent` base class:
您还可以创建和发布自己的自定义事件。下面的示例显示了一个扩展 Spring `ApplicationEvent` 基类的简单类：

```java
public class BlockedListEvent extends ApplicationEvent {

    private final String address;
    private final String content;

    public BlockedListEvent(Object source, String address, String content) {
        super(source);
        this.address = address;
        this.content = content;
    }

    // accessor and other methods...
}
```

To publish a custom `ApplicationEvent`, call the `publishEvent()` method on an `ApplicationEventPublisher`. Typically, this is done by creating a class that implements `ApplicationEventPublisherAware` and registering it as a Spring bean. The following example shows such a class:

要发布自定义的 `ApplicationEvent`，请在 `ApplicationEventPublisher` 上调用 `publishEvent()` 方法。通常，这是通过创建一个实现 `ApplicationEventPublisherAware` 的类并将其注册为 Spring bean 来实现的。以下示例显示了这样一个类：

```java
public class EmailService implements ApplicationEventPublisherAware {

    private List<String> blockedList;
    private ApplicationEventPublisher publisher;

    public void setBlockedList(List<String> blockedList) {
        this.blockedList = blockedList;
    }

    public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    public void sendEmail(String address, String content) {
        if (blockedList.contains(address)) {
            publisher.publishEvent(new BlockedListEvent(this, address, content));
            return;
        }
        // send email...
    }
}
```

At configuration time, the Spring container detects that `EmailService` implements `ApplicationEventPublisherAware` and automatically calls `setApplicationEventPublisher()`. In reality, the parameter passed in is the Spring container itself. You are interacting with the application context through its `ApplicationEventPublisher` interface.

To receive the custom `ApplicationEvent`, you can create a class that implements `ApplicationListener` and register it as a Spring bean. The following example shows such a class:

在配置时，Spring 容器检测到 `EmailService` 实现了 `ApplicationEventPublisherAware`，并自动调用 `setApplicationEventPublisher()`。实际上，传入的参数是 Spring 容器本身。您正在通过其 `ApplicationEventPublisher` 接口与应用程序上下文交互。

要接收自定义的 `ApplicationEvent`，可以创建一个实现 `ApplicationListener` 的类，并将其注册为 Spring bean。以下示例显示了这样一个类：

```java
public class BlockedListNotifier implements ApplicationListener<BlockedListEvent> {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(BlockedListEvent event) {
        // notify appropriate parties via notificationAddress...
    }
}
```

Notice that `ApplicationListener` is generically parameterized with the type of your custom event (`BlockedListEvent` in the preceding example). This means that the `onApplicationEvent()` method can remain type-safe, avoiding any need for downcasting. You can register as many event listeners as you wish, but note that, by default, event listeners receive events synchronously. This means that the `publishEvent()` method blocks until all listeners have finished processing the event. One advantage of this synchronous and single-threaded approach is that, when a listener receives an event, it operates inside the transaction context of the publisher if a transaction context is available. If another strategy for event publication becomes necessary, see the javadoc for Spring’s [`ApplicationEventMulticaster`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/event/ApplicationEventMulticaster.html) interface and [`SimpleApplicationEventMulticaster`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/event/SimpleApplicationEventMulticaster.html) implementation for configuration options.

The following example shows the bean definitions used to register and configure each of the classes above:

请注意，`ApplicationListener` 一般是用自定义事件的类型参数化的（在上一个示例中为`BlockedListEvent`）。这意味着`onApplicationEvent()`方法可以保持类型安全，避免任何向下转换的需要。您可以注册任意数量的事件侦听器，但请注意，默认情况下，事件侦听器同步接收事件。这意味着 `publishEvent()` 方法会一直阻塞，直到所有侦听器都处理完事件。这种同步单线程方法的一个优点是，当侦听器接收到事件时，如果事务上下文可用，它将在发布服务器的事务上下文中操作。如果需要另一种事件发布策略，请参阅 javadoc for Spring 的  [`ApplicationEventMulticaster`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/event/ApplicationEventMulticaster.html) 接口和 [`SimpleApplicationEventMulticaster`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/event/SimpleApplicationEventMulticaster.html) 实现以获取配置选项。

以下示例显示了用于注册和配置上述每个类的 bean 定义：

```xml
<bean id="emailService" class="example.EmailService">
    <property name="blockedList">
        <list>
            <value>known.spammer@example.org</value>
            <value>known.hacker@example.org</value>
            <value>john.doe@example.org</value>
        </list>
    </property>
</bean>

<bean id="blockedListNotifier" class="example.BlockedListNotifier">
    <property name="notificationAddress" value="blockedlist@example.org"/>
</bean>
```

Putting it all together, when the `sendEmail()` method of the `emailService` bean is called, if there are any email messages that should be blocked, a custom event of type `BlockedListEvent` is published. The `blockedListNotifier` bean is registered as an `ApplicationListener` and receives the `BlockedListEvent`, at which point it can notify appropriate parties.

综上所述，当调用 `emailService` bean 的 `sendEmail()` 方法时，如果有任何电子邮件消息应该被阻止，则会发布一个 `BlockedListEvent` 类型的自定义事件。`blockedListNotifier` bean 注册为 `ApplicationListener`，并接收 `BlockedListEvent`，此时它可以通知适当的各方。

> Spring’s eventing mechanism is designed for simple communication between Spring beans within the same application context. However, for more sophisticated enterprise integration needs, the separately maintained [Spring Integration](https://projects.spring.io/spring-integration/) project provides complete support for building lightweight, [pattern-oriented](https://www.enterpriseintegrationpatterns.com/), event-driven architectures that build upon the well-known Spring programming model.
>
> Spring 的事件机制是为同一应用程序上下文中 Spring bean 之间的简单通信而设计的。然而，对于更复杂的企业集成需求，单独维护的 [Spring Integration](https://projects.spring.io/spring-integration/) 项目为构建基于众所周知的 Spring 编程模型的轻量级 [pattern-oriented](https://www.enterpriseintegrationpatterns.com/)事件驱动架构提供了完整的支持。

##### Annotation-based Event Listeners

##### 基于注解的事件侦听器

You can register an event listener on any method of a managed bean by using the `@EventListener` annotation. The `BlockedListNotifier` can be rewritten as follows:

通过使用 `@EventListener` 注解，可以在托管bean的任何方法上注册事件侦听器。`BlockedListNotifier` 可以重写如下：

```java
public class BlockedListNotifier {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    @EventListener
    public void processBlockedListEvent(BlockedListEvent event) {
        // notify appropriate parties via notificationAddress...
    }
}
```

The method signature once again declares the event type to which it listens, but, this time, with a flexible name and without implementing a specific listener interface. The event type can also be narrowed through generics as long as the actual event type resolves your generic parameter in its implementation hierarchy.

If your method should listen to several events or if you want to define it with no parameter at all, the event types can also be specified on the annotation itself. The following example shows how to do so:

方法签名再次声明了它侦听的事件类型，但这次使用了灵活的名称，并且没有实现特定的侦听器接口。只要实际的事件类型解析其实现层次结构中的泛型参数，就可以通过泛型缩小事件类型的范围。

如果您的方法应该侦听多个事件，或者如果您想定义它而不使用任何参数，那么还可以在注解本身上指定事件类型。以下示例显示了如何执行此操作：

```java
@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})
public void handleContextStart() {
    // ...
}
```

It is also possible to add additional runtime filtering by using the `condition` attribute of the annotation that defines a [`SpEL` expression](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions), which should match to actually invoke the method for a particular event.

The following example shows how our notifier can be rewritten to be invoked only if the `content` attribute of the event is equal to `my-event`:

还可以通过使用定义 [`SpEL` expression](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions) 的注解的 `condition` 属性来添加额外的运行时筛选，该属性应该匹配以实际调用特定事件的方法。

下面的示例显示了如何重写通知程序，使其仅在事件的 `content` 属性等于 `my-event` 时被调用：

```java
@EventListener(condition = "#blEvent.content == 'my-event'")
public void processBlockedListEvent(BlockedListEvent blEvent) {
    // notify appropriate parties via notificationAddress...
}
```

Each `SpEL` expression evaluates against a dedicated context. The following table lists the items made available to the context so that you can use them for conditional event processing:

每个 `SpEL` 表达式都根据特定的上下文进行计算。下表列出了上下文可用的项，以便您可以将其用于条件事件处理：

| Name            | Location           | Description                                                  | Example                                                      |
| :-------------- | :----------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| Event           | root object        | The actual `ApplicationEvent`.                               | `#root.event` or `event`                                     |
| Arguments array | root object        | The arguments (as an object array) used to invoke the method.<br />用于调用方法的参数（作为对象数组）。 | `#root.args` or `args`; `args[0]` to access the first argument, etc. |
| *Argument name* | evaluation context | The name of any of the method arguments. If, for some reason, the names are not available (for example, because there is no debug information in the compiled byte code), individual arguments are also available using the `#a<#arg>` syntax where `<#arg>` stands for the argument index (starting from 0).<br />任何方法参数的名称。如果由于某种原因，名称不可用（例如，因为编译后的字节码中没有调试信息），那么也可以使用 `#a<#arg>` 语法使用单个参数，其中 `<#arg>` 代表参数索引（从 0 开始）。 | `#blEvent` or `#a0` (you can also use `#p0` or `#p<#arg>` parameter notation as an alias) |

Note that `#root.event` gives you access to the underlying event, even if your method signature actually refers to an arbitrary object that was published.

If you need to publish an event as the result of processing another event, you can change the method signature to return the event that should be published, as the following example shows:

请注意 `#root.event` 允许您访问基础事件，即使您的方法签名实际上引用了已发布的任意对象。

如果需要发布一个事件作为处理另一个事件的结果，可以更改方法签名以返回应发布的事件，如下例所示：

```java
@EventListener
public ListUpdateEvent handleBlockedListEvent(BlockedListEvent event) {
    // notify appropriate parties via notificationAddress and
    // then publish a ListUpdateEvent...
}
```

>   This feature is not supported for [asynchronous listeners](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-events-async).
>
>   [asynchronous listeners](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-events-async) 不支持此功能。

The `handleBlockedListEvent()` method publishes a new `ListUpdateEvent` for every `BlockedListEvent` that it handles. If you need to publish several events, you can return a `Collection` or an array of events instead.

 `handleBlockedListEvent()` 方法为它处理的每个 `BlockedListEvent` 发布一个新的 `ListUpdateEvent` 。如果需要发布多个事件，可以返回 `Collection` 或事件数组。

##### Asynchronous Listeners

##### 异步侦听器

If you want a particular listener to process events asynchronously, you can reuse the [regular `@Async` support](https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#scheduling-annotation-support-async). The following example shows how to do so:

如果希望某个特定的侦听器异步处理事件，可以重用 [regular `@Async` support](https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#scheduling-annotation-support-async)。以下示例显示了如何执行此操作：

```java
@EventListener
@Async
public void processBlockedListEvent(BlockedListEvent event) {
    // BlockedListEvent is processed in a separate thread
}
```

Be aware of the following limitations when using asynchronous events:

- If an asynchronous event listener throws an `Exception`, it is not propagated to the caller. See [`AsyncUncaughtExceptionHandler`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html) for more details.
- Asynchronous event listener methods cannot publish a subsequent event by returning a value. If you need to publish another event as the result of the processing, inject an [`ApplicationEventPublisher`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/ApplicationEventPublisher.html) to publish the event manually.

使用异步事件时，请注意以下限制：

- 如果异步事件侦听器抛出 `Exception`，则不会将其传播到调用方。有关详细信息，请参见[`AsyncUncaughtExceptionHandler`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html)。
- 异步事件侦听器方法无法通过返回值来发布后续事件。如果需要发布另一个事件作为处理的结果，请注入 [`ApplicationEventPublisher`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/context/ApplicationEventPublisher.html) 以手动发布该事件。

##### Ordering Listeners

If you need one listener to be invoked before another one, you can add the `@Order` annotation to the method declaration, as the following example shows:

如果需要先调用一个侦听器，然后再调用另一个侦听器，则可以将 `@Order` 注解添加到方法声明中，如下例所示：

```java
@EventListener
@Order(42)
public void processBlockedListEvent(BlockedListEvent event) {
    // notify appropriate parties via notificationAddress...
}
```

##### Generic Events

You can also use generics to further define the structure of your event. Consider using an `EntityCreatedEvent<T>` where `T` is the type of the actual entity that got created. For example, you can create the following listener definition to receive only `EntityCreatedEvent` for a `Person`:

您还可以使用泛型来进一步定义事件的结构。考虑使用`EntityCreatedEvent<T>` ，其中 T 是所创建的实际实体的类型。例如，您可以创建以下侦听器定义，以便只接收 `Person` 的 `EntityCreateEvent`：

```java
@EventListener
public void onPersonCreated(EntityCreatedEvent<Person> event) {
    // ...
}
```

Due to type erasure, this works only if the event that is fired resolves the generic parameters on which the event listener filters (that is, something like `class PersonCreatedEvent extends EntityCreatedEvent<Person> { … }`).

In certain circumstances, this may become quite tedious if all events follow the same structure (as should be the case for the event in the preceding example). In such a case, you can implement `ResolvableTypeProvider` to guide the framework beyond what the runtime environment provides. The following event shows how to do so:

由于类型擦除，只有当触发的事件解析了事件侦听器筛选的泛型参数（即类似于 `class PersonCreateEvent extendes EntityCreateEvent<Person>{…}` 的参数）时，这才有效。

在某些情况下，如果所有事件都遵循相同的结构，这可能会变得非常乏味（上例中的事件就是这种情况）。在这种情况下，您可以实现 `ResolvableTypeProvider`，以指导框架超越运行时环境提供的功能。以下事件显示了如何执行此操作：

```java
public class EntityCreatedEvent<T> extends ApplicationEvent implements ResolvableTypeProvider {

    public EntityCreatedEvent(T entity) {
        super(entity);
    }

    @Override
    public ResolvableType getResolvableType() {
        return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));
    }
}
```

>   This works not only for `ApplicationEvent` but any arbitrary object that you send as an event.
>
>   这不仅适用于 `ApplicationEvent`，还适用于任何作为事件发送的任意对象。

#### 1.15.3. Convenient Access to Low-level Resources

#### 1.15.3. 方便地获取低级资源

For optimal usage and understanding of application contexts, you should familiarize yourself with Spring’s `Resource` abstraction, as described in [Resources](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources).

An application context is a `ResourceLoader`, which can be used to load `Resource` objects. A `Resource` is essentially a more feature rich version of the JDK `java.net.URL` class. In fact, the implementations of the `Resource` wrap an instance of `java.net.URL`, where appropriate. A `Resource` can obtain low-level resources from almost any location in a transparent fashion, including from the classpath, a filesystem location, anywhere describable with a standard URL, and some other variations. If the resource location string is a simple path without any special prefixes, where those resources come from is specific and appropriate to the actual application context type.

You can configure a bean deployed into the application context to implement the special callback interface, `ResourceLoaderAware`, to be automatically called back at initialization time with the application context itself passed in as the `ResourceLoader`. You can also expose properties of type `Resource`, to be used to access static resources. They are injected into it like any other properties. You can specify those `Resource` properties as simple `String` paths and rely on automatic conversion from those text strings to actual `Resource` objects when the bean is deployed.

The location path or paths supplied to an `ApplicationContext` constructor are actually resource strings and, in simple form, are treated appropriately according to the specific context implementation. For example `ClassPathXmlApplicationContext` treats a simple location path as a classpath location. You can also use location paths (resource strings) with special prefixes to force loading of definitions from the classpath or a URL, regardless of the actual context type.

为了更好地使用和理解应用程序上下文，您应该熟悉 Spring 的 `Resource` 抽象，如 [Resources](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources)中所述。

应用程序上下文是 `ResourceLoader`，可用于加载 `Resource` 对象。`Resource` 本质上是 JDK `java.net.URL` 类的一个功能更丰富的版本。事实上，`Resource`的实现在适当的地方包装了一个 `java.net.URL`的实例。 `Resource` 可以以透明的方式从几乎任何位置获取低级资源，包括从类路径、文件系统位置、可以用标准 URL 描述的任何位置，以及其他一些变体。如果资源位置字符串是没有任何特殊前缀的简单路径，那么这些资源的来源是特定的，并且适合于实际的应用程序上下文类型。

您可以将部署到应用程序上下文中的 bean 配置为实现特殊的回调接口 `ResourceLoaderWare`，以便在初始化时自动回调，并将应用程序上下文本身作为 `ResourceLoader` 传入。还可以公开 `Resource` 类型的属性，用于访问静态资源。它们像其他属性一样被注入其中。您可以将这些 `Resource` 属性指定为简单的 `String` 路径，并依赖于在部署 bean 时将这些文本字符串自动转换为实际的 `Resource` 对象。

提供给`ApplicationContext`构造函数的一个或多个位置路径实际上是资源字符串，并且以简单的形式根据特定的上下文实现进行适当处理。例如，`ClassPathXmlApplicationContext` 将简单位置路径视为类路径位置。还可以使用带有特殊前缀的位置路径（资源字符串）强制从类路径或URL加载定义，而不管实际的上下文类型如何。

#### 1.15.4. Application Startup Tracking

#### 1.15.4. 应用程序启动跟踪

The `ApplicationContext` manages the lifecycle of Spring applications and provides a rich programming model around components. As a result, complex applications can have equally complex component graphs and startup phases.

Tracking the application startup steps with specific metrics can help understand where time is being spent during the startup phase, but it can also be used as a way to better understand the context lifecycle as a whole.

The `AbstractApplicationContext` (and its subclasses) is instrumented with an `ApplicationStartup`, which collects `StartupStep` data about various startup phases:

- application context lifecycle (base packages scanning, config classes management)
- beans lifecycle (instantiation, smart initialization, post processing)
- application events processing

Here is an example of instrumentation in the `AnnotationConfigApplicationContext`:

ApplicationContext 管理 Spring 应用程序的生命周期，并围绕组件提供丰富的编程模型。因此，复杂的应用程序可以有同样复杂的组件图和启动阶段。

使用特定指标跟踪应用程序启动步骤有助于了解启动阶段花费的时间，但也可以作为更好地了解整个上下文生命周期的一种方式。

`AbstractApplicationContext`（及其子类）使用 `ApplicationStartup` 进行检测，它收集关于各个启动阶段的 `StartupStep` 数据：

- 应用程序上下文生命周期（基本包扫描、配置类管理）
- bean 生命周期（实例化、智能初始化、后处理）
- 应用程序事件处理

以下是 `AnnotationConfigApplicationContext` 中的插入示例：

```java
// create a startup step and start recording
StartupStep scanPackages = this.getApplicationStartup().start("spring.context.base-packages.scan");
// add tagging information to the current step
scanPackages.tag("packages", () -> Arrays.toString(basePackages));
// perform the actual phase we're instrumenting
this.scanner.scan(basePackages);
// end the current step
scanPackages.end();
```

The application context is already instrumented with multiple steps. Once recorded, these startup steps can be collected, displayed and analyzed with specific tools. For a complete list of existing startup steps, you can check out the [dedicated appendix section](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#application-startup-steps).

The default `ApplicationStartup` implementation is a no-op variant, for minimal overhead. This means no metrics will be collected during application startup by default. Spring Framework ships with an implementation for tracking startup steps with Java Flight Recorder: `FlightRecorderApplicationStartup`. To use this variant, you must configure an instance of it to the `ApplicationContext` as soon as it’s been created.

Developers can also use the `ApplicationStartup` infrastructure if they’re providing their own `AbstractApplicationContext` subclass, or if they wish to collect more precise data.

应用程序上下文已通过多个步骤进行检测。一旦记录下来，这些启动步骤就可以用特定的工具进行收集、显示和分析。有关现有启动步骤的完整列表，请查看 [dedicated appendix section](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#application-startup-steps)。

默认的 `ApplicationStartup` 实现是一个无操作变量，以最小化开销。这意味着默认情况下，在应用程序启动期间不会收集任何指标。Spring 框架附带了一个用于跟踪 Java Flight Recorder 启动步骤的实现：`FlightRecorderApplicationStartup`。要使用此变体，必须在创建后立即将其实例配置为 `ApplicationContext`。

如果开发人员提供自己的 `AbstractApplicationContext` 子类，或者希望收集更精确的数据，他们也可以使用 `ApplicationStartup` 基础结构。

> `ApplicationStartup` is meant to be only used during application startup and for the core container; this is by no means a replacement for Java profilers or metrics libraries like [Micrometer](https://micrometer.io/).
>
> `ApplicationStartup` 仅用于应用程序启动期间和核心容器；这绝不是 Java 探查器或 [Micrometer](https://micrometer.io/) 等度量库的替代品.

To start collecting custom `StartupStep`, components can either get the `ApplicationStartup` instance from the application context directly, make their component implement `ApplicationStartupAware`, or ask for the `ApplicationStartup` type on any injection point.

要开始收集自定义的 `StartupStep`，组件可以直接从应用程序上下文获取 `ApplicationStartup` 实例，使其组件实现 `ApplicationStartupAware`，或者在任何注入点上请求 `ApplicationStartup` 类型。

> Developers should not use the `"spring.*"` namespace when creating custom startup steps. This namespace is reserved for internal Spring usage and is subject to change.
>
> 开发人员在创建自定义启动步骤时不应使用`"spring.*"`名称空间。此名称空间保留供 Spring 内部使用，可能会发生更改。

#### 1.15.5. Convenient ApplicationContext Instantiation for Web Applications

#### 1.15.5. 方便的 Web 应用程序上下文实例化

You can create `ApplicationContext` instances declaratively by using, for example, a `ContextLoader`. Of course, you can also create `ApplicationContext` instances programmatically by using one of the `ApplicationContext` implementations.

You can register an `ApplicationContext` by using the `ContextLoaderListener`, as the following example shows:

例如，可以使用 `ContextLoader` 以声明方式创建 `ApplicationContext` 实例。当然，您也可以通过使用 `ApplicationContext` 实现之一以编程方式创建 `ApplicationContext` 实例。

您可以使用 `ContextLoaderListener` 注册 `ApplicationContext`，如下例所示：

```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml</param-value>
</context-param>

<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
```

The listener inspects the `contextConfigLocation` parameter. If the parameter does not exist, the listener uses `/WEB-INF/applicationContext.xml` as a default. When the parameter does exist, the listener separates the `String` by using predefined delimiters (comma, semicolon, and whitespace) and uses the values as locations where application contexts are searched. Ant-style path patterns are supported as well. Examples are `/WEB-INF/*Context.xml` (for all files with names that end with `Context.xml` and that reside in the `WEB-INF` directory) and `/WEB-INF/**/*Context.xml` (for all such files in any subdirectory of `WEB-INF`).

侦听器检查 `contextConfigLocation` 参数。如果参数不存在，侦听器将使用 `/WEB-INF/applicationContext.xml` 作为默认值。当参数确实存在时，侦听器使用预定义的分隔符（逗号、分号和空格）分隔 `String`，并将这些值用作搜索应用程序上下文的位置。也支持Ant样式的路径模式。例如`/WEB-INF/*Context.xml`（用于名称以 `Context.xml` 结尾并位于 `WEB-INF` 目录中的所有文件）和`/WEB-INF/**/*Context.xml`（用于 `WEB-INF`的任何子目录中的所有此类文件）。

#### 1.15.6. Deploying a Spring `ApplicationContext` as a Java EE RAR File

#### 1.15.6. 将 Spring `ApplicationContext` 部署为 Java EE RAR 文件

It is possible to deploy a Spring `ApplicationContext` as a RAR file, encapsulating the context and all of its required bean classes and library JARs in a Java EE RAR deployment unit. This is the equivalent of bootstrapping a stand-alone `ApplicationContext` (only hosted in Java EE environment) being able to access the Java EE servers facilities. RAR deployment is a more natural alternative to a scenario of deploying a headless WAR file — in effect, a WAR file without any HTTP entry points that is used only for bootstrapping a Spring `ApplicationContext` in a Java EE environment.

RAR deployment is ideal for application contexts that do not need HTTP entry points but rather consist only of message endpoints and scheduled jobs. Beans in such a context can use application server resources such as the JTA transaction manager and JNDI-bound JDBC `DataSource` instances and JMS `ConnectionFactory` instances and can also register with the platform’s JMX server — all through Spring’s standard transaction management and JNDI and JMX support facilities. Application components can also interact with the application server’s JCA `WorkManager` through Spring’s `TaskExecutor` abstraction.

See the javadoc of the [`SpringContextResourceAdapter`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html) class for the configuration details involved in RAR deployment.

For a simple deployment of a Spring ApplicationContext as a Java EE RAR file:

1. Package all application classes into a RAR file (which is a standard JAR file with a different file extension).
2. Add all required library JARs into the root of the RAR archive.
3. Add a `META-INF/ra.xml` deployment descriptor (as shown in the [javadoc for `SpringContextResourceAdapter`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html)) and the corresponding Spring XML bean definition file(s) (typically `META-INF/applicationContext.xml`).
4. Drop the resulting RAR file into your application server’s deployment directory.

可以将 Spring `ApplicationContext` 部署为 RAR 文件，将上下文及其所有必需的 bean 类和库 jar 封装在 Java EE RAR 部署单元中。这相当于引导一个独立的 `ApplicationContext`（仅托管在 JavaEE 环境中），以便能够访问 JavaEE 服务器设施。RAR 部署是部署无头 WAR 文件的更自然的替代方案 — 实际上，一个没有任何 HTTP 入口点的 WAR 文件，只用于在 JavaEE 环境中引导Spring  `ApplicationContext`。

RAR 部署非常适合不需要 HTTP 入口点，而只包含消息端点和计划作业的应用程序上下文。这种上下文中的 bean 可以使用应用程序服务器资源，比如 JTA 事务管理器和绑定 JNDI 的 JDBC `DataSource` 实例和 JMS `ConnectionFactory` 实例，还可以向平台的 JMX 服务器注册 — 通过 Spring 的标准事务管理、JNDI 和 JMX 支持设施。应用程序组件还可以通过 Spring 的 `TaskExecutor` 抽象与应用服务器的 JCA  `WorkManager` 交互。

有关 RAR 部署中涉及的配置细节，请参阅 [`SpringContextResourceAdapter`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html) 类的 javadoc。

要将 Spring ApplicationContext 作为 Java EE RAR 文件进行简单部署，请执行以下操作：

1.将所有应用程序类打包到一个 RAR 文件中（这是一个具有不同文件扩展名的标准 JAR 文件）。

2.将所有必需的库 jar 添加到 RAR 归档的根目录中。

3.添加 `META-INF/ra.xml`部署描述符（如 [javadoc for `SpringContextResourceAdapter`](https://docs.spring.io/spring-framework/docs/5.3.13/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html)中所示）和相应的 Spring XML Bean定义文件（通常为 `META-INF/applicationContext.xml`）。

4.将生成的 RAR 文件放到应用服务器的部署目录中。

> Such RAR deployment units are usually self-contained. They do not expose components to the outside world, not even to other modules of the same application. Interaction with a RAR-based `ApplicationContext` usually occurs through JMS destinations that it shares with other modules. A RAR-based `ApplicationContext` may also, for example, schedule some jobs or react to new files in the file system (or the like). If it needs to allow synchronous access from the outside, it could (for example) export RMI endpoints, which may be used by other application modules on the same machine.
>
> 这种 RAR 部署单元通常是独立的。它们不会将组件暴露给外部世界，甚至不会暴露给同一应用程序的其他模块。与基于 RAR的 `ApplicationContext` 的交互通常通过与其他模块共享的 JMS 目的地进行。例如，基于 RAR 的 `ApplicationContext` 还可以调度一些作业或对文件系统中的新文件（或类似文件）做出反应。如果需要允许从外部进行同步访问，它可以（例如）导出 RMI 端点，同一台机器上的其他应用程序模块可能会使用这些端点。

### 1.16. The `BeanFactory`

The `BeanFactory` API provides the underlying basis for Spring’s IoC functionality. Its specific contracts are mostly used in integration with other parts of Spring and related third-party frameworks, and its `DefaultListableBeanFactory` implementation is a key delegate within the higher-level `GenericApplicationContext` container.

`BeanFactory` and related interfaces (such as `BeanFactoryAware`, `InitializingBean`, `DisposableBean`) are important integration points for other framework components. By not requiring any annotations or even reflection, they allow for very efficient interaction between the container and its components. Application-level beans may use the same callback interfaces but typically prefer declarative dependency injection instead, either through annotations or through programmatic configuration.

Note that the core `BeanFactory` API level and its `DefaultListableBeanFactory` implementation do not make assumptions about the configuration format or any component annotations to be used. All of these flavors come in through extensions (such as `XmlBeanDefinitionReader` and `AutowiredAnnotationBeanPostProcessor`) and operate on shared `BeanDefinition` objects as a core metadata representation. This is the essence of what makes Spring’s container so flexible and extensible.

`BeanFactory` API 为 Spring 的 IoC 功能提供了基础。它的特定契约主要用于与 Spring 和相关第三方框架的其他部分集成，其 `DefaultListableBeanFactory` 实现是更高级别的 `GenericApplicationContext` 容器中的一个关键委托。

`BeanFactory` 和相关接口（如 `BeanFactoryAware`、`InitializingBean`、`DisposableBean`）是其他框架组件的重要集成点。通过不需要任何注解甚至反射，它们允许容器及其组件之间进行非常有效的交互。应用程序级 bean 可以使用相同的回调接口，但通常更喜欢通过注解或编程配置进行声明性依赖注入。

请注意，核心 `BeanFactory` API 级别及其 `DefaultListableBeanFactory` 实现没有对要使用的配置格式或任何组件注解进行假设。所有这些风格都是通过扩展（比如 `XmlBeanDefinitionReader` 和 `AutowiredAnnotationBeanPostProcessor`）引入的，并将共享的 `BeanDefinition` 对象作为核心元数据表示进行操作。这就是为什么  Spring 的容器如此灵活和可扩展的本质。

#### 1.16.1. `BeanFactory` or `ApplicationContext`?

This section explains the differences between the `BeanFactory` and `ApplicationContext` container levels and the implications on bootstrapping.

You should use an `ApplicationContext` unless you have a good reason for not doing so, with `GenericApplicationContext` and its subclass `AnnotationConfigApplicationContext` as the common implementations for custom bootstrapping. These are the primary entry points to Spring’s core container for all common purposes: loading of configuration files, triggering a classpath scan, programmatically registering bean definitions and annotated classes, and (as of 5.0) registering functional bean definitions.

Because an `ApplicationContext` includes all the functionality of a `BeanFactory`, it is generally recommended over a plain `BeanFactory`, except for scenarios where full control over bean processing is needed. Within an `ApplicationContext` (such as the `GenericApplicationContext` implementation), several kinds of beans are detected by convention (that is, by bean name or by bean type — in particular, post-processors), while a plain `DefaultListableBeanFactory` is agnostic about any special beans.

For many extended container features, such as annotation processing and AOP proxying, the [`BeanPostProcessor` extension point](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-bpp) is essential. If you use only a plain `DefaultListableBeanFactory`, such post-processors do not get detected and activated by default. This situation could be confusing, because nothing is actually wrong with your bean configuration. Rather, in such a scenario, the container needs to be fully bootstrapped through additional setup.

The following table lists features provided by the `BeanFactory` and `ApplicationContext` interfaces and implementations.

本节解释了 `BeanFactory` 和 `ApplicationContext` 容器级别之间的差异，以及对引导的影响。

除非有充分的理由不这样做，否则应该使用 `ApplicationContext`，将 `GenericaApplicationContext` 及其子类 `AnnotationConfigApplicationContext` 作为自定义引导的常见实现。这些是 Spring 核心容器的主要入口点，用于所有常见目的：加载配置文件、触发类路径扫描、以编程方式注册 bean 定义和注解类，以及（从 5.0 开始）注册函数 bean 定义。

由于 `ApplicationContext` 包含 `BeanFactory` 的所有功能，因此通常建议不要使用普通的 `BeanFactory`，除非需要对 bean处理进行完全控制。在 `ApplicationContext`（例如 `GenericApplicationContext` 实现）中，根据约定（即，根据 bean 名称或 bean 类型）检测几种 bean — 特别是后处理器），而普通的 `DefaultListableBeanFactory` 对任何特殊的 bean 都是不可知的。

对于许多扩展容器功能，例如注解处理和 AOP 代理， [`BeanPostProcessor` extension point](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-bpp) 是必不可少的。如果只使用普通的 `DefaultListableBeanFactory`，则默认情况下不会检测和激活此类后处理器。这种情况可能会令人困惑，因为 bean 配置实际上没有任何问题。相反，在这种情况下，需要通过额外的设置来完全引导容器。

下表列出了 `BeanFactory` 和 `ApplicationContext` 接口和实现提供的功能。

| Feature                                                      | `BeanFactory` | `ApplicationContext` |
| :----------------------------------------------------------- | :------------ | :------------------- |
| Bean instantiation/wiring                                          Bean实例化/连接 | Yes           | Yes                  |
| Integrated lifecycle management       集成生命周期管理       | No            | Yes                  |
| Automatic `BeanPostProcessor` registration       自动 `BeanPostProcessor`注册 | No            | Yes                  |
| Automatic `BeanFactoryPostProcessor` registration   自动 `BeanFactoryPostProcessor` 注册 | No            | Yes                  |
| Convenient `MessageSource` access (for internationalization) 方便的 `MessageSource` 访问（用于国际化） | No            | Yes                  |
| Built-in `ApplicationEvent` publication mechanism       内置的 `ApplicationEvent` 发布机制 | No            | Yes                  |

To explicitly register a bean post-processor with a `DefaultListableBeanFactory`, you need to programmatically call `addBeanPostProcessor`, as the following example shows:

要向 `DefaultListableBeanFactory` 显式注册 bean 后处理器，需要以编程方式调用 `addBeanPostProcessor` ，如下例所示：

```java
DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
// populate the factory with bean definitions

// now register any needed BeanPostProcessor instances
factory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());
factory.addBeanPostProcessor(new MyBeanPostProcessor());

// now start using the factory
```

To apply a `BeanFactoryPostProcessor` to a plain `DefaultListableBeanFactory`, you need to call its `postProcessBeanFactory` method, as the following example shows:

要将 `BeanFactoryPostProcessor` 应用于普通的 `DefaultListableBeanFactory`，需要调用其 `postProcessBeanFactory` 方法，如下例所示：

```java
DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions(new FileSystemResource("beans.xml"));

// bring in some property values from a Properties file
PropertySourcesPlaceholderConfigurer cfg = new PropertySourcesPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));

// now actually do the replacement
cfg.postProcessBeanFactory(factory);
```

In both cases, the explicit registration steps are inconvenient, which is why the various `ApplicationContext` variants are preferred over a plain `DefaultListableBeanFactory` in Spring-backed applications, especially when relying on `BeanFactoryPostProcessor` and `BeanPostProcessor` instances for extended container functionality in a typical enterprise setup.

在这两种情况下，显式注册步骤都不方便，这就是为什么在 Spring 支持的应用程序中，各种 `ApplicationContext` 变体比普通的 `DefaultListableBeanFactory` 更受欢迎的原因，尤其是在典型的企业设置中，依赖 `BeanFactoryPostProcessor` 和 `BeanPostProcessor` 实例实现扩展容器功能时。

>   An `AnnotationConfigApplicationContext` has all common annotation post-processors registered and may bring in additional processors underneath the covers through configuration annotations, such as `@EnableTransactionManagement`. At the abstraction level of Spring’s annotation-based configuration model, the notion of bean post-processors becomes a mere internal container detail.
>
>   `AnnotationConfigApplicationContext` 注册了所有常见的批注后处理器，并可能通过配置批注（如 `@EnableTransactionManagement`）在封面下引入其他处理器。在 Spring 基于注解的配置模型的抽象级别上，bean 后处理器的概念仅仅是一个内部容器细节。
