{"compress":true,"commitItems":[["7c88b694-8f14-441d-bf66-ae48e080c7c9",1567509394772,"第4讲：类加载器深入解析与阶段分解",[[1567509338739,["GJX@GJXAIOU",[[1,0,"# "]],[0,0],[19,19]]],[1567509349108,["GJX@GJXAIOU",[[1,19,"\n\n"]],[19,19],[20,20]]],[1567509349227,["GJX@GJXAIOU",[[1,21,"\n"]],[20,20],[21,21]]]],null,"GJX@GJXAIOU"],["593f8aa7-7bdd-4389-86d1-4d103fb9b328",1567571339136,"# 第4讲：类加载器深入解析与阶段分解\n\n\n",[[1567571308981,["GJX@GJXAIOU",[[1,21,"### 类加载\n\nclass loading\n\n*   在java代码中，类的加载、连接和初始化过程都是在程序运行期间完成的。（类从磁盘加载到内存中经历的三个阶段）\n*   提供了更大的灵活性，增加了更多的可能性。\n\n###### 类加载器深入剖析：\n\n*   Java虚拟机与程序的生命周期\n*   在如下几种情况下，java虚拟机将结束生命周期\n    （1）执行了System.exit()方法\n    （2）程序正常执行结束\n    （3）程序在执行过程中遇到了异常或错误而异常终止\n    （4）由于操作系统出现错误而导致虚拟机进程终止\n\n###### 类的加载、连接与初始化：\n\n*   加载：查找并加载类的二进制数据到java虚拟机中\n*   连接：\n    验证 : 确保被加载的类的正确性\n    准备：为类的**静态变量**分配内存，并将其初始化为**默认值**，但是到达初始化之前类变量都没有初始化为真正的初始值\n    解析：**把类中的符号引用转换为直接引用**，就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程\n*   初始化：为类的静态变量赋予正确的初始值\n\n###### 类从磁盘上加载到内存中要经历五个阶段：加载、连接、初始化、使用、卸载\n\n*   Java程序对类的使用方式可分为两种\n    （1）主动使用\n    （2）被动使用\n*   所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才能初始化他们\n*   主动使用（七种）\n    （1）创建类的实例\n    （2）访问某个类或接口的静态变量 getstatic（助记符），或者对该静态变量赋值 putstatic\n    （3）调用类的静态方法 invokestatic\n    （4）反射（Class.forName(“com.test.Test”)）\n    （5）初始化一个类的子类\n    （6）Java虚拟机启动时被标明启动类的类\n    （7）JDK1.7开始提供的动态语言支持（了解）\n*   被动使用\n    除了上面七种情况外，其他使用java类的方式都被看做是对类的被动使用，都不会导致类的初始化\n\n###### 类的加载详解：\n\n*   类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在**方法区**中）用来封装内在方法区内的数据结构。\n*   加载.calss文件的方式\n    （1）从本地系统中直接加载\n    （2）通过网络下载.class文件\n    （3）从zip，jar等归档文件中加载.class文件\n    （4）从专用数据库中提取.class文件\n    （5）将java源文件动态编译为.class文件\n*   测试1：\n\n```\n/**\n        对于静态字段来说，只有直接定义了该字段的类才会被初始化\n        当一个类在初始化时，要求父类全部都已经初始化完毕\n        -XX:+TraceClassLoading，用于追踪类的加载信息并打印出来\n\n        -XX:+<option>，表示开启option选项\n        -XX:-<option>，表示关闭option选项\n        -XX:<option>=value，表示将option的值设置为value\n*/\npublic class MyTest{\n    public static void main(String[] args){\n        System.out.println(MyChild.str);    //输出：MyParent static block 、 hello world   （因为对MyChild不是主动使用）\n        System.out.println(MyChild.str2);  //输出：MyParent static block  、MyChild static block、welcome\n    }\n}\nclass MyParent{\n    public static String str=\"hello world\";\n    static {\n        System.out.println(\"MyParent static block\");\n    }\n}\nclass MyChild extends MyParent{\n    public static String str2=\"welcome\";\n    static {\n        System.out.println(\"MyChild static block\");\n    }\n}\n\n```\n\n*   测试2：\n\n```\n/**\n        常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中\n        本质上，调用类并没有直接调用到定义常量的类，因此并不会触发定义常量的类的初始化\n        注意：这里指的是将常量存到MyTest2的常量池中，之后MyTest2和MyParent就没有任何关系了。\n        甚至我们可以将MyParent2的class文件删除\n\n        助记符 ldc：表示将int、float或者String类型的常量值从常量池中推送至栈顶\n        助记符 bipush：表示将单字节（-128-127）的常量值推送到栈顶\n        助记符 sipush：表示将一个短整型值（-32768-32369）推送至栈顶\n        助记符 iconst_1：表示将int型的1推送至栈顶（iconst_m1到iconst_5）\n*/\npublic class MyTest2{\n    public static void main(String[] args){\n        System.out.println(MyParent2.str);    //输出 hello world\n        System.out.println(MyParent2.s);  \n        System.out.println(MyParent2.i);  \n        System.out.println(MyParent2.j);  \n    }\n}\nclass MyParent2{\n    public static final String str=\"hello world\";\n    public static final short s=7;\n    public static final int i=129;\n    public static final int j=1;\n    static {\n        System.out.println(\"MyParent static block\");\n    }\n}\n\n```\n\n*   测试3\n\n```\n/**\n        当一个常量的值并非编译期间可以确定的，那么其值就不会放到调用类的常量池中\n        这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化\n*/\npublic class MyTest3{\n    public static void main(String[] args){\n        System.out.println(MyParent3.str);  //输出MyParent static block、kjqhdun-baoje21w-jxqioj1-2jwejc9029\n    }\n}\nclass MyParent3{\n    public static final String str=UUID.randomUUID().toString();\n    static {\n        System.out.println(\"MyParent static block\");\n    }\n}\n\n```\n\n*   测试4\n\n```\n/**\n        对于数组实例来说，其类型是由JVM在运行期动态生成的，表示为 [L com.hisense.classloader.MyParent4 这种形式。\n        对于数组来说，JavaDoc经构成数据的元素成为Component，实际上是将数组降低一个维度后的类型。\n\n        助记符：anewarray：表示创建一个引用类型（如类、接口）的数组，并将其引用值压入栈顶\n        助记符：newarray：表示创建一个指定原始类型（int boolean float double）d的数组，并将其引用值压入栈顶\n*/\npublic class MyTest4{\n    public static void main(String[] args){\n        MyParent4 myParent4=new MyParent4();        //创建类的实例，属于主动使用，会导致类的初始化\n        MyParent4[] myParent4s=new MyParent4[1];    //不是主动使用\n        System.out.println(myParent4s.getClass());          //输出 [L com.hisense.classloader.MyParent4\n        System.out.println(myParent4s.getClass().getSuperClass());    //输出Object\n\n        int[] i=new int[1];\n        System.out.println(i.getClass());          //输出 [ I\n        System.out.println(i.getClass().getSuperClass());    //输出Object\n    }\n}\nclass MyParent4{\n    static {\n        System.out.println(\"MyParent static block\");\n    }\n}\n\n```\n\n*   测试5\n\n```\n/**\n        当一个接口在初始化时，并不要求其父接口都完成了初始化\n        只有在真正使用到父接口的时候（如引用接口中定义的常量），才会初始化\n*/\npublic class MyTest5{\n    public static void main(String[] args){\n         public static void main(String[] args){\n            System.out.println(MyChild5.b)\n         }\n    }\n}\ninterfacce MParent5{\n    public static Thread thread=new thread(){\n        System.out.println(\" MParent5 invoke\")\n    };\n}\ninterface MyChild5 extends MParent5{     //接口属性默认是 public static final\n    public static int b=6;\n}\n\n```\n\n*   测试6\n\n```\n/**\n        准备阶段和初始化的顺序问题\n*/\npublic class MyTest6{\n    public static void main(String[] args){\n         public static void main(String[] args){\n            Singleton Singleton=Singleton.getInstance();\n            System.out.println(Singleton.counter1);     //输出1，1\n            System.out.println(Singleton.counter2);\n         }\n    }\n}\nclass Singleton{\n    public static int counter1;\n    public static int counter2=0;               /\n    private static Singleton singleton=new Singleton();\n\n    private Singleton(){\n        counter1++;\n        counter2++;\n    }\n\n    // public static int counter2=0;       //   若改变此赋值语句的位置，输出  1，0\n    public static Singleton getInstance(){\n        return singleton;\n    }\n}\n\n```\n\n加载\n连接（验证、准备、解析）\n初始化\n类初始化：为新的对象分配内存，为实例变量赋默认值，为实例变量赋正确的初始值\n\njava编译器在它编译的每一个类都至少生成一个实例化的方法，在java的class文件中，这个实例化方法被称为“”。针对源代码中每一个类的构造方法，java编译器都会产生一个“”方法。\n\n###### 有两种类型的类加载器\n\n1.  Java虚拟机自带的加载器\n\n*   **根类加载器**（Bootstrap）：该加载器没有父加载器，它负责加载虚拟机中的核心类库。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有集成java.lang.ClassLoader类。\n*   **扩展类加载器**（Extension）：它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的jre\\lib\\ext子目录（扩展目录）下加载类库，如果把用户创建的jar文件放在这个目录下，也会自动由扩展类加载器加载，扩展类加载器是纯java类，是java.lang.ClassLoader的子类。\n*   **系统应用类加载器**（System）：也称为应用类加载器，它的父加载器为扩展类加载器，它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，他是用户自定义的类加载器的默认父加载器。系统类加载器时纯java类，是java.lang.ClassLoader的子类。\n\n1.  用户自定义的类加载器\n\n*   java.lang.ClassLoader的子类\n*   用户可以定制类的加载方式\n\n根类加载器–>扩展类加载器–>系统应用类加载器–>自定义类加载器\n类加载器并不需要等到某个类被“首次主动使用”时再加载它\n\nJVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在**程序首次主动**使用该类才报告错误（LinkageError错误），如果这个类没有被程序主动使用，那么类加载器就不会报告错误。\n\n类加载器用来把类加载到java虚拟机中。从JDK1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好地保证Java平台的安全。在此委托机制中，除了java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。当java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则有父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。\n\n类被加载后，就进入连接阶段。连接阶段就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。\n\n*   类的连接-验证\n    1）类文件的结构检查\n    2）语义检查\n    3）字节码验证\n    4）二进制兼容性的验证\n*   类的连接-准备\n    在准备阶段，java虚拟机为类的静态变量分配内存，并设置默认的初始值。例如对于以下Sample类，在准备阶段，将为int类型的静态变量a分配4个字节的内存空间，并且赋予默认值0，为long类型的静态变量b分配8个字节的内存空间，并且赋予默认值0；\n\n```\n    public class Sample{\n        private static int a=1;\n        public  static long b;\n        public  static long c;\n        static {\n            b=2;\n        }\n    }\n\n```\n\n*   初始化\n    在初始化阶段，Java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。在程序中，静态变量的初始化有两种途径：（1）在静态变量的声明处进行初始化；（2）在静态代码块中进行初始化。\n    类的初始化步骤：\n    （1）假如这个类还没有被加载和连接，那就先进行加载和连接\n    （2）假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类\n    （3）假如类中存在初始化语句，那就依次执行这些初始化语句\n    ·当java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则不适用于接口。因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定的接口的静态变量时，才会导致该接口的初始化。\n    ·调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。\n\n###### 类加载器的父亲委托机制\n\n在父亲委托机制中，各个加载器按照父子关系形成了树形结构，除了根加载器之外，其余的类加载器都有一个父加载器\n\n*   若有一个类能够成功加载Test类，那么这个类加载器被称为**定义类加载器**，所有能成功返回Class对象引用的类加载器（包括定义类加载器）称为**初始类加载器**。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190823165459877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQwNTM1NA==,size_16,color_FFFFFF,t_70)\n\n*   测试7\n\n```\n/**\n        java.lang.String是由根加载器加载，在rt.jar包下\n*/\npublic class MyTest7{\n    public static void main(String[] args){\n         public static void main(String[] args){\n            Class<?> clazz=Class.forName(\"java.lang.String\");\n            System.out.println(clazz.getClassLoader());  //返回null\n\n            Class<?> clazz2=Class.forName(\"C\");\n           System.out.println(clazz2.getClassLoader());  //输出sun.misc.Launcher$AppClassLoader@18b4aac2  其中AppClassLoader:系统应用类加载器\n         }\n    }\n}\nclass C{\n}\n\n```\n\n*   测试8\n\n```\n/**\n        调用ClassLoader的loaderClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化\n*/\npublic class MyTest8{\n    public static void main(String[] args){\n         public static void main(String[] args){\n            ClassLoader loader=ClassLoader.getSystemClassLoader();\n            Class<?> clazz1=loader.loadClass(\"CL\"); //不会初始化\n            System.out.println(clazz1);\n            System.out.println(\"-------------------\");\n\n            Class<?> clazz=Class.forName(\"CL\");\n            System.out.println(clazz);  //反射初始化\n         }\n    }\n}\nclass CL{\n    static {\n        System.out.println(\"FinalTest static block);\n    }\n}\n\n```\n\n*   测试9-12忽略\n*   测试13\n\n```\n/**\n    输出AppClassLoader、ExtClassLoader、null\n*/\npublic class MyTest13{\n    public static void main(String[] args){\n         public static void main(String[] args){\n            ClassLoader loader=ClassLoader.getSystemClassLoader();\n            System.out.println(loader);\n\n            while(loader!=null){\n                loader=loader.getParent();\n                 System.out.println(loader);\n            }\n         }\n    }\n}\n\n```\n\n*   测试14\n\n```\npublic class MyTest14{\n    public static void main(String[] args){\n         public static void main(String[] args){\n            ClassLoader loader=Thread.currentThread().getContextClassLoader();\n            System.out.println(loader);         //输出AppClassLoader\n            //下面这段没整明白什么用，先记录下来\n            String resourceName=\"com/hisense/MyTest13.class\";\n            Enumeration<URL> urls=loader.getResources(resourceName);\n            whilr(urls.hasMoreElements()){\n                URL url=urls.nextElement();\n                System.out.println(url);\n            }\n         }\n    }\n}\n\n```\n\n*   获取类加载器的途径：\n    （1）clazz.getClassLoader(); --获取当前类的加载器\n    （2）Thread.currentThread().getContextClassLoader(); --获取当前线程上下文的加载器\n    （3）ClassLoader.getSystemClassLoader(); --获取系统的加载器\n    （4）DriverManager.getCallerClassLoader(); --获取调用者的加载器\n*   ClassLoader源码分析与实例剖析–\n    ClassLoader是一个负责加载class的对象，ClassLoader类是一个抽象类，需要给出类的二进制名称，ClassLoader尝试定位或者产生一个class的数据，一个典型的策略是把二进制名字转换成文件名然后到文件系统中找到该文件。\n*   测试15\n\n```\n/**\n    对于数组，它对应的class对象不是由类加载器加载，而是由JVM在运行期动态的创建。然而对于数组类的类加载器来说，它返回的类加载器和数组内元素的类加载器是一样的。如果数组类元素是原生类，那么数组是没有类加载器的。\n*/\npublic class MyTest15{\n    public static void main(String[] args){\n            String[] strings=new String[2];\n            System.out.println(strings.getClass());\n            System.out.println(strings.getClass().getClassLoader());    //输出null\n\n            MyTest15[] mytest15=new MyTest15[2];\n            System.out.println(mytest15.getClass().getClassLoader());   //输出应用类加载器\n\n            int[] arr=new int[2];\n            System.out.println(arr.getClass().getClassLoader());        //输出null，此null非彼null\n    }\n}\n\n```\n\n并行类加载器可支持并发加载，需要在类初始化期间调用ClassLoader.registerAaParallelCapable()方法进行注册。ClassLoader类默认支持并发加载，但是其子类必须在初始化期间进行注册。\n\n*   测试16\n\n```\n/**\n    创建自定义加载器，继承ClassLoader\n*/\npublic class MyTest16 extends ClassLoader{\n    private String classLoaderName;\n    private String path；\n    private final String fileExtension=\".class\";\n\n    public MyTest16(String classLoaderName){\n        super();        //将系统类当做该类的父加载器\n        this.classLoaderName=classLoaderName;\n    }\n    public MyTest16(ClassLoader parent,String classLoaderName){\n        super(parent);      //显式指定该类的父加载器\n        this.classLoaderName=classLoaderName;\n    }\n\n   public MyTest16(ClassLoader parent){\n        super(parent);      //显式指定该类的父加载器\n    }\n\n    public void setPath(String path){\n        this.path=path;\n    }\n    @Override\n    protect Class<?> findClass(String className){\n        System.out.println(\"calssName=\"+className);\n        className=className.replace(\".\",File.separator);\n        byte[] data=loadClassData(className);\n        return defineClass(className,data,0,data.length); //define方法为父类方法\n    }\n\n    private byte[] loadClassData(String name){\n        InputStream is=null;\n        byte[] data=null;\n        ByteArrayOutputStream baos=null;\n        try{\n            is=new FileInputStream(new File(this.path+name+this.fileExtension));\n            baos=new ByteArrayOutputStream();\n            int ch;\n            while(-1!=(ch=is.read())){\n                baos.write(ch);\n            }\n            data=baos.toByteArray();\n\n        }catch(Exception e){\n        }finally{\n            is.close();\n            baos.close();\n             return data;\n        }\n    }\n    public static void test(ClassLoader classLoader){\n        Class<?> clazz=classLoader.loadClass(\"com.hisense.MyTest1\");  \n        //loadClass是父类方法，在方法内部调用findClass\n        System.out.println(clazz.hashCode());\n        Object  object=clazz.newInstance();\n        System.out.println(object);\n    }\n    public static void main(String[] args){\n        //父亲是系统类加载器，根据父类委托机制，MyTest1由系统类加载器加载了\n        MyTest16 loader1=new MyTest16(\"loader1\");       \n        test(loader1);\n\n        //仍然是系统类加载器进行加载的，因为路径正好是classpath\n        MyTest16 loader2=new MyTest16(\"loader2\");  \n        loader2.path=\"D:\\Eclipse\\workspace\\HiATMP-DDMS\\target\\classes\\\";\n        test(loader2);\n\n         //自定义的类加载器被执行，findClass方法下的输出被打印。前提是当前calsspath下不存在MyTest1.class，MyTest16的父加载器-系统类加载器会尝试从classpath中寻找MyTest1。\n        MyTest16 loader3=new MyTest16(\"loader3\");  \n        loader3.path=\"C:\\Users\\weichengjie\\Desktop\\\";\n        test(loader3);\n\n        //与3同时存在，输出两个class的hash不一致，findClass方法下的输出均被打印，原因是类加载器的命名空间问题。\n        MyTest16 loader4=new MyTest16(\"loader4\");  \n        loader4.path=\"C:\\Users\\weichengjie\\Desktop\\\";\n        test(loader4);\n\n        //将loader3作为父加载器\n        MyTest16 loader5=new MyTest16(loader3,\"loader3\");  \n        loader3.path=\"C:\\Users\\weichengjie\\Desktop\\\";\n        test(loader5);\n    }\n}\n\n```\n\n###### 命名空间\n\n*   每个类加载器都有自己的命名空间，**命名空间由该加载器及所有父加载器所加载的类构成**；\n*   在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；\n*   在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类；\n*   同一命名空间内的类是互相可见的，**非同一命名空间内的类是不可见的**；\n*   子加载器可以见到父加载器加载的类，**父加载器也不能见到子加载器加载的类**。\n\n###### 类的卸载\n\n*   当一个类被加载、连接和初始化之后，它的生命周期就开始了。当此类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，类在方法区内的数据也会被卸载。\n*   一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。\n*   由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机本身会始终引用这些加载器，而这些类加载器则会始终引用他们所加载的类的Class对象，因此这些Class对象是可触及的。\n*   由用户自定义的类加载器所加载的类是可以被卸载的。\n\n```\n/**\n    自定义类加载器加载类的卸载\n    -XX：+TraceClassUnloading\n*/\n   public static void main(String[] args){\n        MyTest16 loader2=new MyTest16(\"loader2\");  \n        loader2.path=\"D:\\Eclipse\\workspace\\HiATMP-DDMS\\target\\classes\\\";\n        test(loader2);\n        loader2=null;\n        System.gc();   //让系统去显式执行垃圾回收\n\n        输出的两个对象hashcode值不同，因为前面加载的已经被卸载了\n        loader2=new MyTest16(\"loader6\"); //  \n        test(loader2);\n   }\n\n```\n\n###### gvisualvm命令 查看当前java进程，在jdk/bin下面\n\n*   测试17\n\n```\n/**\n    创建自定义加载器，继承ClassLoader\n*/\nclass MyCat{\n    public MyCat(){\n        System.out.println(\"MyCat is loaded...\"+this.getClass().getClassLoader());\n    }\n}\n\nclass MySample{\n    public MySample(){\n        System.out.println(\"MySample is loaded...\"+this.getClass().getClassLoader());\n        new MyCat();\n    }\n}\n\npublic class MyTest17 extends ClassLoader{\n    private String classLoaderName;\n    private String path；\n    private final String fileExtension=\".class\";\n\n    public MyTest17(String classLoaderName){\n        super();        //将系统类当做该类的父加载器\n        this.classLoaderName=classLoaderName;\n    }\n    public MyTest17(ClassLoader parent,String classLoaderName){\n        super(parent);      //显式指定该类的父加载器\n        this.classLoaderName=classLoaderName;\n    }\n\n    public void setPath(String path){\n        this.path=path;\n    }\n    @Override\n    protect Class<?> findClass(String className){\n        System.out.println(\"calssName=\"+className);\n        className=className.replace(\".\",File.separator);\n        byte[] data=loadClassData(className);\n        return defineClass(className,data,0,data.length); //define方法为父类方法\n    }\n\n    private byte[] loadClassData(String name){\n        InputStream is=null;\n        byte[] data=null;\n        ByteArrayOutputStream baos=null;\n        try{\n            is=new FileInputStream(new File(this.path+name+this.fileExtension));\n            baos=new ByteArrayOutputStream();\n            int ch;\n            while(-1!=(ch=is.read())){\n                baos.write(ch);\n            }\n            data=baos.toByteArray();\n        }catch(Exception e){\n        }finally{\n            is.close();\n            baos.close();\n             return data;\n        }\n    }\n    public static void main(String[] args){\n        MyTest17 loader1=new MyTest17(\"loader1\");\n        Class<?> clazz=loader1.loadClass(\"com.hisense.MySample\");  \n        System.out.println(clazz.hashCode());\n        //如果注释掉该行，就并不会实例化MySample对象，不会加载MyCat（可能预先加载）\n        Object  object=clazz.newInstance(); //加载和实例化了MySample和MyCat\n    }\n}\n\n```\n\n测试17_1\n\n```\npublic class MyTest17_1 extends ClassLoader{\n    private String classLoaderName;\n    private String path；\n    private final String fileExtension=\".class\";\n\n    public MyTest17_1(String classLoaderName){\n        super();        //将系统类当做该类的父加载器\n        this.classLoaderName=classLoaderName;\n    }\n    public MyTest17_1(ClassLoader parent,String classLoaderName){\n        super(parent);      //显式指定该类的父加载器\n        this.classLoaderName=classLoaderName;\n    }\n\n    public void setPath(String path){\n        this.path=path;\n    }\n    @Override\n    protect Class<?> findClass(String className){\n        System.out.println(\"calssName=\"+className);\n        className=className.replace(\".\",File.separator);\n        byte[] data=loadClassData(className);\n        return defineClass(className,data,0,data.length); //define方法为父类方法\n    }\n\n    private byte[] loadClassData(String name){\n        InputStream is=null;\n        byte[] data=null;\n        ByteArrayOutputStream baos=null;\n        try{\n            is=new FileInputStream(new File(this.path+name+this.fileExtension));\n            baos=new ByteArrayOutputStream();\n            int ch;\n            while(-1!=(ch=is.read())){\n                baos.write(ch);\n            }\n            data=baos.toByteArray();\n        }catch(Exception e){\n        }finally{\n            is.close();\n            baos.close();\n             return data;\n        }\n    }\n    public static void main(String[] args){\n        MyTest17_1 loader1=new MyTest17_1(\"loader1\");\n        loader1.path=\"C:\\Users\\weichengjie\\Desktop\";\n        Class<?> clazz=loader1.loadClass(\"com.hisense.MySample\");  \n        System.out.println(clazz.hashCode());\n        //MyCat是由加载MySample的加载器去加载的：\n        如果只删除classpath下的MyCat，则会报错，NoClassDefFoundError；\n        如果只删除calsspath下的MySample，则由自定义加载器加载桌面上的MySample，由系统应用加载器加载MyCat。\n        Object  object=clazz.newInstance(); \n    }\n\n}\n\n```\n\n测试17_1_1\n\n```\n\n//修改MyCat和MySample\nclass MyCat{\n    public MyCat(){\n        System.out.println(\"MyCat is loaded...\"+this.getClass().getClassLoader());\n        System.out.println(\"from MyCat: \"+MySample.class);\n    }\n}\n\nclass MySample{\n    public MySample(){\n        System.out.println(\"MySample is loaded...\"+this.getClass().getClassLoader());\n        new MyCat();\n        System.out.println(\"from MySample :\"+ MyCat.class);\n    }\n}\n\npublic class MyTest17_1 {\n        public static void main(String[] args){\n        //修改MyCat后，仍然删除classpath下的MySample，留下MyCat，程序报错\n        //因为命名空间，父加载器找不到子加载器所加载的类，因此MyCat找不到        \n        //MySample。\n        MyTest17_1 loader1=new MyTest17_1(\"loader1\");\n        loader1.path=\"C:\\Users\\weichengjie\\Desktop\";\n        Class<?> clazz=loader1.loadClass(\"com.hisense.MySample\");  \n        System.out.println(clazz.hashCode());\n        Object  object=clazz.newInstance(); \n    }\n}\n\n```\n\n*   ```\n    关于命名空间重要说明：\n\n    ```\n\n    1.  子加载器所加载的类能够访问父加载器所加载的类；\n    2.  而父加载器所加载的类无法访问子加载器所加载的类。\n*   测试18\n\n```\npublic class MyTest18{\n    public static void main(String[] args){\n        System.out.println(System.getProperty(\"sun.boot.class.path\"));//根加载器路径\n        System.out.println(System.getProperty(\"java.ext.dirs\"));//扩展类加载器路径\n        System.out.println(System.getProperty(\"java.calss.path\"));//应用类加载器路径\n    }\n}\n\n```\n\n*   测试18_1\n\n```\npublic class MyTest18_1{\n    public static void main(String[] args){\n        MyTest16 loader1=new MyTest16(\"loader1\");\n        loader1.setPath(\"C:\\Users\\weichengjie\\Desktop\");\n\n        //把MyTest1.class文件放入到根类加载器路径中，则由根类加载器加载MyTest1\n        Class<?> clazz= loader1.loadClass(\"MyTest1\");\n\n        System.out.println(\"clazz:\"+clazz.hashCode());\n        System.out.println(\"class loader:\"+clazz.getClassLoader());\n\n    }\n}\n\n```\n\n*   测试19\n\n```\n/**\n    各加载器的路径是可以修改的，修改后会导致运行失败，ClassNotFoundExeception\n*/\npublic class MyTest19{\n    public static void main(String[] args){\n        AESKeyGenerator aesKeyGenerator=new AESKeyGenerator();\n        System.out.println(aesKeyGenerator.getClass().getClassLoader());//输出扩展类加载器\n        System.out.println(MyTest19.class.getClassLoader());//输出应用类加载器\n    }\n}\n\n```\n\n*   测试20\n\n```\n class Person{\n    private Person person;\n    public setPerson(Object object){\n        this.person=(Person)object;\n    }\n }\n\n public class MyTest20{\n    public static void main(String[] args){\n        MyTest16 loader1=new MyTest16(\"loader1\");\n        MyTest16 loader2=new MyTest16(\"loader2\");\n\n        Class<?> clazz1=load1.loadClass(\"Person\");\n        Class<?> clazz2=load1.loadClass(\"Person\");\n        //clazz1和clazz均由应用类加载器加载的，第二次不会重新加载，结果为true\n        System.out.println(clazz1==clazz2);\n\n        Object object1=clazz1.getInstance();\n        Object object2=clazz2.getInstance();\n\n        Method method=clazz1.getMethod(\"setPerson\",Object.class);\n        method.invoke(object1,object2);\n\n    }\n }\n\n```\n\n*   测试21\n\n```\n public class MyTest21{\n    public static void main(String[] args){\n        MyTest16 loader1=new MyTest16(\"loader1\");\n        MyTest16 loader2=new MyTest16(\"loader2\");\n        loader1.setPath(\"C:\\Users\\weichengjie\\Desktop\");\n        loader2.setPath(\"C:\\Users\\weichengjie\\Desktop\");\n        //删掉classpath下的Person类\n        Class<?> clazz1=load1.loadClass(\"Person\");\n        Class<?> clazz2=load1.loadClass(\"Person\");\n        //clazz1和clazz由loader1和loader2加载，结果为false\n        System.out.println(clazz1==clazz2);\n\n        Object object1=clazz1.getInstance();\n        Object object2=clazz2.getInstance();\n\n        Method method=clazz1.getMethod(\"setPerson\",Object.class);\n        //此处报错，loader1和loader2所处不用的命名空间\n        method.invoke(object1,object2);\n    }\n }\n\n```\n\n*   类加载器双亲委托模型的好处：\n    （1）可以确保Java和核心库的安全：所有的Java应用都会引用java.lang中的类，也就是说在运行期java.lang中的类会被加载到虚拟机中，如果这个加载过程如果是由自己的类加载器所加载，那么很可能就会在JVM中存在多个版本的java.lang中的类，而且这些类是相互不可见的（命名空间的作用）。借助于双亲委托机制，Java核心类库中的类的加载工作都是由启动根加载器去加载，从而确保了Java应用所使用的的都是同一个版本的Java核心类库，他们之间是相互兼容的；\n    （2）确保Java核心类库中的类不会被自定义的类所替代；\n    （3）不同的类加载器可以为相同名称的类（binary name）创建额外的命名空间。相同名称的类可以并存在Java虚拟机中，只需要用不同的类加载器去加载即可。相当于在Java虚拟机内部建立了一个又一个相互隔离的Java类空间。\n*   父亲委托机制的优点是能够提高软件系统的安全性。因此在此机制下，用户自定义的类加载器不可能加载应该由父类加载器加载的可靠类，从而防止不可靠甚至恶意的代码代替由父类加载器加载的可靠代码。例如，java.lang.Object类是由跟类加载器加载，其他任何用哪个户自定义的类加载器都不可能加载含有恶意代码的java.lang.Object类。\n*   测试22\n\n```\n public class MyTest22{\n    static{\n        System.out.println(\"MyTest22 init...\");\n    }\n    public static void main(String[] args){\n        System.out.println(MyTest22.class.getClassLoader());\n\n        System.out.println(MyTest1.class.getClassLoader());\n    }\n }\n\n```\n\n扩展类加载器只加载jar包，需要把class文件打成jar\n\n*   测试23\n\n```\n/*\n    在运行期，一个Java类是由该类的完全限定名（binary name）和用于加载该类的定义类加载器所共同决定的。如果同样名字（完全相同限定名）是由两个不同的加载器所加载，那么这些类就是不同的，即便.class文件字节码相同，并且从相同的位置加载亦如此。\n    在oracle的hotspot，系统属性sun.boot.class.path如果修改错了，则运行会出错：\n    Error occurred during initialization of VM\n    java/lang/NoClassDeFoundError: java/lang/Object\n*/\n public class MyTest23{\n    public static void main(String[] args){\n        System.out.println(System.getProperty(\"sun.boot.class.path\"));\n        System.out.println(System.getProperty(\"java.ext.dirs\"));\n        System.out.println(System.getProperty(\"java.calss.path\"));\n\n        System.out.println(ClassLoader.class.getClassLoader);\n        System.out.println(Launcher.class.getClassLoader);\n\n        //下面的系统属性指定系统类加载器，默认是AppClassLoader\n        System.out.println(System.getProperty(\"java.system.class.loader\"));\n    }\n }\n\n```\n\n*   类加载器本身也是类加载器，类加载器又是谁加载的呢？？（先有鸡还是现有蛋）\n    类加载器是由启动类加载器去加载的，启动类加载器是C++写的，内嵌在JVM中。\n*   内嵌于JVM中的启动类加载器会加载java.lang.ClassLoader以及其他的Java平台类。当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器以及系统类加载器，这块特殊的机器码叫做启动类加载器。\n*   启动类加载器并不是java类，其他的加载器都是java类。\n*   启动类加载器是特定于平台的机器指令，它负责开启整个加载过程。\n\n###### OpenJDK\n\ngrepcode.com\n源码分析\nLauncher类\nClass.forName();\n\n###### Thread.getContextClassLoader()\n\n```\n/*\n    当前类加载器(Current ClassLoader)\n        每个类都会尝试使用自己的类加载器去加载依赖的类。\n\n    线程上下文类加载器(Context ClassLoader)\n     线程上下文加载器 @ jdk1.2\n    线程类中的 getContextClassLoader() 与 setContextClassLoader(ClassLoader c)\n    如果没有通过setContextClassLoader()方法设置，线程将继承父线程的上下文类加载器，java应用运行时的初始线程的上下文类加载器是系统类加载器。该线程中运行的代码可以通过该类加载器加载类和资源。\n\n    线程上下文类加载器的作用：\n    SPI：Service Provide Interface\n    父ClassLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所制定的ClassLoader加载的类，这就改变了父加载器加载的类无法使用子加载器或是其他没有父子关系的ClassLoader加载的类的情况，即改变了双亲委托模型。\n\n    在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托父加载器进行加载。但是对于SPI来说，有些接口是Java核心库所提供的的（如JDBC），Java核心库是由启动类记载器去加载的，而这些接口的实现却来自不同的jar包（厂商提供），Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求。通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。\n*\n public class MyTest24{\n    public static void main(String[] args){\n        System.out.println(Thread.currentThread().getContextClassLoader());\n        //\n        System.out.println(Thread.class.getClassLoader());\n    }\n }\n\n```\n\n*   测试25\n\n```\n public class MyTest25 implement Runable{\n    private Thread thread；\n    public MyTest25(){\n        thread =new Thread(this);\n        thread.start();\n    }\n\n    public void run(){\n        ClassLoader classLoader=this.thread.getContextLoader();\n        this.setContextLoader(classLoader);\n\n        System.out.println(\"Class:\"+classLoader.getClass());\n        System.out.println(\"Parent:\"+classLoader.getParent().getClass());\n    }\n\n    public static void main(String[] args){\n        new MyTest25();\n    }\n }\n\n```\n\n*   测试26\n\n```\n/*\n    线程上下文类加载器的一般使用模式：（获取-使用-还原）\n        伪代码：\n        ClassLoader classLoader=Thread.currentThread().getContextLoader();\n        try{\n            Thread.currentThread().setContextLoader(targetTccl);\n            myMethod();\n        }finally{\n            Thread.currentThread().setContextLoader(classLoader);\n        }\n        在myMethod中调用Thread.currentThread().getContextLoader()做某些事情\n        ContextClassLoader的目的就是为了破坏类加载委托机制\n\n        在SPI接口的代码中，使用线程上下文类加载器就可以成功的加载到SPI的实现类。\n\n        当高层提供了统一的接口让底层去实现，同时又要在高层加载（或实例化）底层的类时，就必须通过上下文类加载器来帮助高层的ClassLoader找到并加载该类。\n\n public class MyTest26{\n    public static void main(String[] args){\n\n    //一旦加入下面此行，将使用ExtClassLoader去加载Driver.class， ExtClassLoader不会去加载classpath，因此无法找到MySql的相关驱动。\n //Thread.getCurrentThread().setContextClassLoader(MyTest26.class.getClassLoader().parent());    \n\n        ServiceLoader服务提供者，加载实现的服务\n        ServiceLoader<Driver> loader=ServiceLoader.load(Driver.class);\n        Iterator<Driver> iterator=loader.iterator();\n        while(iterator.hasNext()){\n            Driver driver=iterator.next();\n            System.out.println(\"driver:\"+driver.class+\n                                \",loader\"+driver.class.getClassLoader());\n        }\n        System.out.println(\"当前上下文加载器\"\n                    +Thread.currentThread().getContextClassLoader());\n        System.out.println(\"ServiceLoader的加载器\"\n                    +ServiceLoader.class.getClassLoader());\n    }\n }     \n*/\n\n```\n\n*   测试27\n\n```\n//跟踪代码\n public class MyTest27{\n    public static void main(String[] args){\n        Class.forName(\"com.mysql.jdbc.Driver\");\n        Connection connection=DriverManager.getConnection(\n  \"jdbc:mysql://localhost:3306//mydb\",\"user\",\"password\");\n    }\n }\n\n```\n\n*   jar hell问题以及解决办法\n    当一个类或者一个资源文件存在多个jar中，就会存在jar hell问题。\n    可通过以下代码解决问题：\n    ClassLoader calssLoader=Thread.currnetThread().getContextClassLoader();\n    String resource-“java/lang/String.class”;\n    Enumeration urls=calssLoader.getResources(resource);\n    while(urls.hasMoreElements()){\n    – URL url=urls.nextElement();\n    – System.out.prinln(url);\n    }"]],[21,21],[28464,28464]]],[1567571325954,["GJX@GJXAIOU",[[-1,134,"##"]],[135,135],[133,133]]],[1567571329540,["GJX@GJXAIOU",[[-1,298,"##"]],[298,298],[296,296]]],[1567571331908,["GJX@GJXAIOU",[[-1,537,"##"]],[536,536],[534,534]]],[1567571333518,["GJX@GJXAIOU",[[-1,961,"##"]],[962,962],[960,960]]],[1567571429283,["GJX@GJXAIOU",[[-1,23,"#"]],[24,24],[23,23]]],[1567571433439,["GJX@GJXAIOU",[[1,24,"（）"]],[24,24],[26,26]]],[1567571437773,["GJX@GJXAIOU",[[-1,24,"（）"]],[26,26],[24,24]]],[1567571439920,["GJX@GJXAIOU",[[1,24,"一、"]],[24,24],[26,26]]],[1567571454038,["GJX@GJXAIOU",[[1,59,"**"],[1,84,"**"]],[59,84],[59,88]]],[1567571487473,["GJX@GJXAIOU",[[1,134,"- 这里的类"]],[134,134],[140,140]]],[1567571489380,["GJX@GJXAIOU",[[-1,139,"类"]],[140,140],[139,139]]],[1567571504449,["GJX@GJXAIOU",[[1,139,"类就是指类本省"]],[139,139],[146,146]]],[1567571506220,["GJX@GJXAIOU",[[-1,144,"本省"]],[146,146],[144,144]]],[1567571517208,["GJX@GJXAIOU",[[1,144,"本身，而不是指类的"]],[144,144],[153,153]]],[1567571518479,["GJX@GJXAIOU",[[1,153,"对象；"]],[153,153],[156,156]]],[1567571521159,["GJX@GJXAIOU",[[1,157,"- \n"]],[156,156],[159,159]]],[1567571521297,["GJX@GJXAIOU",[[-1,157,"- "]],[159,159],[158,158]]],[1567571521434,["GJX@GJXAIOU",[[1,158,"\n"]],[158,158],[159,159]]],[1567571592349,["GJX@GJXAIOU",[[1,157,"- \n"]],[156,156],[159,159]]],[1567571600663,["GJX@GJXAIOU",[[1,159,"类的加载方式"]],[159,159],[165,165]]],[1567571603380,["GJX@GJXAIOU",[[-1,163,"方式"]],[165,165],[163,163]]],[1567571634928,["GJX@GJXAIOU",[[1,163,"常见方式是：将已经编译或者存在的字节码文件从磁盘加载到内存中；"]],[163,163],[194,194]]],[1567571641205,["GJX@GJXAIOU",[[1,195,"- \n"]],[194,194],[197,197]]],[1567571658970,["GJX@GJXAIOU",[[1,197,"连接：主要是将类与类之间的关系去定好"]],[197,197],[215,215]]],[1567571660300,["GJX@GJXAIOU",[[-1,212,"去定好"]],[215,215],[212,212]]],[1567571675411,["GJX@GJXAIOU",[[1,212,"确定好，同时对字节码文件进行校验等处理；"]],[212,212],[232,232]]],[1567571702542,["GJX@GJXAIOU",[[-1,237,"##"]],[239,239],[237,237]]],[1567571704535,["GJX@GJXAIOU",[[1,237,"#"]],[237,237],[248,248]]],[1567571708422,["GJX@GJXAIOU",[[1,239,"（）"]],[239,239],[241,241]]],[1567571709922,["GJX@GJXAIOU",[[1,240,"一"]],[240,240],[241,241]]],[1567571718892,["GJX@GJXAIOU",[[1,272,"（）"]],[272,272],[274,274]]],[1567571726200,["GJX@GJXAIOU",[[1,273,"JVM本身"]],[273,273],[278,278]]],[1567571726259,["GJX@GJXAIOU",[[1,276," "]],[278,278],[279,279]]],[1567571733320,["GJX@GJXAIOU",[[1,279,"就是一个进程"]],[279,279],[285,285]]],[1567571741646,["GJX@GJXAIOU",[[1,252,"每一个类都是由啦"]],[252,252],[260,260]]],[1567571742692,["GJX@GJXAIOU",[[-1,259,"啦"]],[260,260],[259,259]]],[1567571757080,["GJX@GJXAIOU",[[1,259,"类加载器加载进入内存中；"]],[259,259],[271,271]]],[1567571774292,["GJX@GJXAIOU",[[-1,437,"#"]],[438,438],[437,437]]],[1567571776434,["GJX@GJXAIOU",[[1,438,"（）"]],[438,438],[440,440]]],[1567571778048,["GJX@GJXAIOU",[[1,439,"二"]],[439,439],[440,440]]],[1567571788480,["GJX@GJXAIOU",[[1,475," "]],[475,475],[476,476]]],[1567571789720,["GJX@GJXAIOU",[[1,480," "]],[480,480],[481,481]]],[1567571816934,["GJX@GJXAIOU",[[-1,494,"   "],[1,497,"*"],[-1,515,"   "],[1,518,"*"],[-1,579,"   "],[1,582,"*"]],[498,618],[496,612]]],[1567571818175,["GJX@GJXAIOU",[[1,494,"  "],[1,513,"  "],[1,575,"  "]],[496,612],[498,618]]],[1567571832864,["GJX@GJXAIOU",[[1,578,"，通安徽"]],[578,578],[582,582]]],[1567571833949,["GJX@GJXAIOU",[[-1,579,"通安徽"]],[582,582],[579,579]]],[1567571843104,["GJX@GJXAIOU",[[1,579,"同时这时候还没有创建对象；"]],[579,579],[592,592]]],[1567571844365,["GJX@GJXAIOU",[[1,597,"\n  * "]],[592,592],[597,597]]],[1567571845845,["GJX@GJXAIOU",[[-1,593,"  * "]],[597,597],[593,593]]],[1567571849311,["GJX@GJXAIOU",[[1,593,"```java"]],[593,593],[600,600]]],[1567571849551,["GJX@GJXAIOU",[[1,601,"\n"]],[600,600],[601,601]]],[1567571850439,["GJX@GJXAIOU",[[1,601,"```"]],[601,601],[604,604]]],[1567571855376,["GJX@GJXAIOU",[[1,601,"\n"]],[600,600],[601,601]]],[1567571857837,["GJX@GJXAIOU",[[-1,489," "]],[489,489],[488,488]]],[1567571859925,["GJX@GJXAIOU",[[-1,458," "]],[458,458],[457,457]]],[1567571861597,["GJX@GJXAIOU",[[1,494,"  "]],[494,494],[496,496]]],[1567571862293,["GJX@GJXAIOU",[[1,517,"  "]],[516,516],[518,518]]],[1567571864117,["GJX@GJXAIOU",[[1,610,"  "]],[610,610],[612,612]]],[1567571866734,["GJX@GJXAIOU",[[-1,611," "]],[611,611],[610,610]]],[1567571913453,["GJX@GJXAIOU",[[-1,595,"```java\n\n```"]],[595,607],[595,595]]],[1567571915687,["GJX@GJXAIOU",[[1,694,"```java\n\n```"]],[694,694],[706,706]]],[1567571920523,["GJX@GJXAIOU",[[1,594,"shili"]],[594,594],[599,599]]],[1567571922333,["GJX@GJXAIOU",[[-1,594,"shili"]],[599,599],[594,594]]],[1567571927663,["GJX@GJXAIOU",[[1,594,"示例见下："]],[594,594],[599,599]]],[1567571931805,["GJX@GJXAIOU",[[-1,600,"\n"]],[600,600],[599,599]]],[1567571943162,["GJX@GJXAIOU",[[1,706,"static int a = 1;"]],[706,706],[723,723]]],[1567571944973,["GJX@GJXAIOU",[[1,724,"\n"]],[723,723],[724,724]]],[1567571998901,["GJX@GJXAIOU",[[-1,724,"\n"]],[724,724],[723,723]]],[1567572001406,["GJX@GJXAIOU",[[1,706,"\n"]],[705,705],[706,706]]],[1567572004214,["GJX@GJXAIOU",[[1,706,"// xia"]],[706,706],[712,712]]],[1567572005405,["GJX@GJXAIOU",[[-1,709,"xia"]],[712,712],[709,709]]],[1567572040872,["GJX@GJXAIOU",[[1,709,"下面语句在准备阶段对变量进行初始复制"]],[709,709],[727,727]]],[1567572041594,["GJX@GJXAIOU",[[-1,725,"复制"]],[727,727],[725,725]]],[1567572055689,["GJX@GJXAIOU",[[1,725,"赋值，因为为整型，因此初始复制为"]],[725,725],[741,741]]],[1567572057756,["GJX@GJXAIOU",[[-1,736,"初始复制为"]],[741,741],[736,736]]],[1567572063081,["GJX@GJXAIOU",[[1,736,"初始赋值为 0 "]],[736,736],[744,744]]],[1567572064069,["GJX@GJXAIOU",[[-1,743," "]],[744,744],[743,743]]],[1567572090441,["GJX@GJXAIOU",[[1,743,"，然后在初始化阶段重新复制"]],[743,743],[756,756]]],[1567572092046,["GJX@GJXAIOU",[[-1,754,"复制"]],[756,756],[754,754]]],[1567572095377,["GJX@GJXAIOU",[[1,754,"赋值为1；"]],[754,754],[759,759]]],[1567572098240,["GJX@GJXAIOU",[[1,757," "]],[757,757],[758,758]]],[1567572127876,["GJX@GJXAIOU",[[1,783,"\n"]],[782,782],[783,783]]],[1567572128017,["GJX@GJXAIOU",[[1,784,"\n"]],[783,783],[784,784]]],[1567572128175,["GJX@GJXAIOU",[[1,785,"\n"]],[784,784],[785,785]]],[1567572130492,["GJX@GJXAIOU",[[1,786,"\n"]],[783,783],[784,784]]],[1567572132690,["GJX@GJXAIOU",[[1,784,"### （）"]],[784,784],[790,790]]],[1567572134707,["GJX@GJXAIOU",[[1,789,"三"]],[789,789],[790,790]]],[1567572142174,["GJX@GJXAIOU",[[1,791,"类的使用和卸载"]],[791,791],[798,798]]],[1567572142437,["GJX@GJXAIOU",[[1,801,"\n"]],[798,798],[799,799]]],[1567572153549,["GJX@GJXAIOU",[[1,799,"包括类的使用和卸载，其中卸载一般不使用；"]],[799,799],[819,819]]],[1567572193406,["GJX@GJXAIOU",[[1,784,"\n"]],[782,782],[783,783]]],[1567572194245,["GJX@GJXAIOU",[[1,785,"\n"]],[783,783],[784,784]]],[1567572494852,["GJX@GJXAIOU",[[1,786,"\n"]],[783,783],[784,784]]],[1567572501095,["GJX@GJXAIOU",[[1,784,"![类的加载连接以及初始化]($resource/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%9E%E6%8E%A5%E4%BB%A5%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96.png)"]],[784,784],[914,914]]],[1567572557268,["GJX@GJXAIOU",[[-1,954,"#### "]],[954,958],[954,954]]],[1567572560533,["GJX@GJXAIOU",[[1,954,"**"],[1,988,"**"]],[954,988],[954,992]]],[1567572562604,["GJX@GJXAIOU",[[-1,953,"\n"]],[953,953],[952,952]]],[1567572591284,["GJX@GJXAIOU",[[1,993,"\n"]],[992,992],[993,993]]],[1567572591438,["GJX@GJXAIOU",[[1,994,"\n"]],[993,993],[994,994]]],[1567572593061,["GJX@GJXAIOU",[[1,993,"### （二）类的加载、连接与初始化："]],[993,993],[1012,1012]]],[1567572595213,["GJX@GJXAIOU",[[-1,1011,"："]],[1012,1012],[1011,1011]]],[1567572596239,["GJX@GJXAIOU",[[1,1011,"具体"]],[1011,1011],[1013,1013]]],[1567572626605,["GJX@GJXAIOU",[[1,1095,"**"],[1,1101,"**"]],[1095,1101],[1095,1105]]],[1567572660432,["GJX@GJXAIOU",[[1,1312," ：即包含 mian"]],[1312,1312],[1322,1322]]],[1567572661369,["GJX@GJXAIOU",[[-1,1319,"ian"]],[1322,1322],[1319,1319]]],[1567572665598,["GJX@GJXAIOU",[[1,1319,"ain 方法的类"]],[1319,1319],[1327,1327]]],[1567572688949,["GJX@GJXAIOU",[[1,1415,"（）"]],[1415,1415],[1417,1417]]],[1567572700736,["GJX@GJXAIOU",[[1,1416,"但是连接和加载的操作可能发生"]],[1416,1416],[1430,1430]]],[1567572703853,["GJX@GJXAIOU",[[1,1431,"。"]],[1431,1431],[1432,1432]]],[1567572738094,["GJX@GJXAIOU",[[-1,1437,"#"]],[1438,1438],[1437,1437]]],[1567572740986,["GJX@GJXAIOU",[[1,1437,"#"]],[1437,1437],[1446,1446]]],[1567572760751,["GJX@GJXAIOU",[[1,1528,"jvm "]],[1528,1528],[1531,1531]]],[1567572785764,["GJX@GJXAIOU",[[1,1589,"****"]],[1589,1589],[1591,1591]]],[1567572791870,["GJX@GJXAIOU",[[1,1591,"一个类不管 "]],[1591,1591],[1597,1597]]],[1567572792548,["GJX@GJXAIOU",[[-1,1596," "]],[1597,1597],[1596,1596]]],[1567572804879,["GJX@GJXAIOU",[[1,1596,"生成多少实例，所有实例水印"]],[1596,1596],[1609,1609]]],[1567572805439,["GJX@GJXAIOU",[[-1,1607,"水印"]],[1609,1609],[1607,1607]]],[1567572811136,["GJX@GJXAIOU",[[1,1607,"对应的Class"]],[1607,1607],[1615,1615]]],[1567572811195,["GJX@GJXAIOU",[[1,1610," "]],[1615,1615],[1616,1616]]],[1567572813704,["GJX@GJXAIOU",[[1,1616,"对象"]],[1616,1616],[1618,1618]]],[1567572813764,["GJX@GJXAIOU",[[1,1616," "]],[1618,1618],[1619,1619]]],[1567572816001,["GJX@GJXAIOU",[[1,1619,"只有一根"]],[1619,1619],[1623,1623]]],[1567572816639,["GJX@GJXAIOU",[[-1,1621,"一根"]],[1623,1623],[1621,1621]]],[1567572821639,["GJX@GJXAIOU",[[1,1621,"一份。"]],[1621,1621],[1624,1624]]],[1567572851236,["GJX@GJXAIOU",[[1,1741,"（）"]],[1741,1741],[1743,1743]]],[1567572854808,["GJX@GJXAIOU",[[1,1742,"很少使用"]],[1742,1742],[1746,1746]]],[1567572864834,["GJX@GJXAIOU",[[1,1776,"（）"]],[1776,1776],[1778,1778]]],[1567572900975,["GJX@GJXAIOU",[[1,1777,"一般存在于动态代理，因为动态代理的类是运行时候才产生，编译的时候是"]],[1777,1777],[1810,1810]]],[1567572902463,["GJX@GJXAIOU",[[1,1810,"没有的"]],[1810,1810],[1813,1813]]],[1567572916413,["GJX@GJXAIOU",[[1,1815,"\n"]],[1815,1815],[1816,1816]]],[1567572926814,["GJX@GJXAIOU",[[-1,1825,"\n"]],[1825,1825],[1824,1824]]],[1567572943151,["GJX@GJXAIOU",[[1,1824,"分析主动使用和被动使用的区别"]],[1824,1824],[1838,1838]]],[1567572984004,["GJX@GJXAIOU",[[-1,2193,"//输出：MyParent static block 、 hello world   （因为对MyChild不是主动使用）"]],[2193,2254],[2193,2193]]],[1567572986407,["GJX@GJXAIOU",[[1,2153,"\n    "]],[2148,2148],[2153,2153]]],[1567572986860,["GJX@GJXAIOU",[[1,2153,"//输出：MyParent static block 、 hello world   （因为对MyChild不是主动使用）"]],[2153,2153],[2214,2214]]],[1567572993903,["GJX@GJXAIOU",[[1,2155," "]],[2155,2155],[2156,2156]]],[1567572999580,["GJX@GJXAIOU",[[-1,2304,"//输出：MyParent static block  、MyChild static block、welcome"]],[2304,2361],[2304,2304]]],[1567573002133,["GJX@GJXAIOU",[[1,2258,"\n        //输出：MyParent static block  、MyChild static block、welcome"]],[2258,2258],[2324,2324]]],[1567573017852,["GJX@GJXAIOU",[[-1,2293,"  "]],[2295,2295],[2293,2293]]],[1567573041678,["GJX@GJXAIOU",[[1,2156,"下面语句"]],[2156,2156],[2160,2160]]],[1567573045877,["GJX@GJXAIOU",[[1,2153,"    "]],[2153,2153],[2157,2157]]],[1567573050768,["GJX@GJXAIOU",[[1,2205,"\n        、"]],[2205,2205],[2215,2215]]],[1567573051579,["GJX@GJXAIOU",[[-1,2214,"、"]],[2215,2215],[2214,2214]]],[1567573052318,["GJX@GJXAIOU",[[1,2214,"//"]],[2214,2214],[2216,2216]]],[1567573058756,["GJX@GJXAIOU",[[-1,2188," "]],[2189,2189],[2188,2188]]],[1567573060733,["GJX@GJXAIOU",[[-1,2189," "]],[2190,2190],[2189,2189]]],[1567573094265,["GJX@GJXAIOU",[[1,2214," zheli d"]],[2214,2214],[2222,2222]]],[1567573096876,["GJX@GJXAIOU",[[-1,2215,"zheli d"]],[2222,2222],[2215,2215]]],[1567573141097,["GJX@GJXAIOU",[[1,2215,"这里的 str 是父类进行定义的，这里主动使用了父类，但是没有主动使用子类，因此"]],[2215,2215],[2255,2255]]],[1567573144017,["GJX@GJXAIOU",[[1,2255,"子类没有别"]],[2255,2255],[2260,2260]]],[1567573146029,["GJX@GJXAIOU",[[-1,2259,"别"]],[2260,2260],[2259,2259]]],[1567573169799,["GJX@GJXAIOU",[[1,2259,"被初始化，最终不会执行子类中的静态代码块；"]],[2259,2259],[2280,2280]]],[1567573176110,["GJX@GJXAIOU",[[-1,2280,"（因为对MyChild不是主动使用）"]],[2280,2298],[2280,2280]]],[1567573237438,["GJX@GJXAIOU",[[1,2332,"\n        "]],[2323,2323],[2332,2332]]],[1567573238621,["GJX@GJXAIOU",[[-1,2324,"        "],[1,2332,"\n"]],[2332,2332],[2325,2325]]],[1567573240836,["GJX@GJXAIOU",[[-1,2325,"\n"]],[2325,2325],[2324,2324]]],[1567573243540,["GJX@GJXAIOU",[[1,2399,"\n        "]],[2390,2390],[2399,2399]]],[1567573245022,["GJX@GJXAIOU",[[1,2399,"、"]],[2399,2399],[2400,2400]]],[1567573245596,["GJX@GJXAIOU",[[-1,2399,"、"]],[2400,2400],[2399,2399]]],[1567573246314,["GJX@GJXAIOU",[[1,2399,"//"]],[2399,2399],[2401,2401]]],[1567573247968,["GJX@GJXAIOU",[[1,2335," "]],[2335,2335],[2336,2336]]],[1567573258198,["GJX@GJXAIOU",[[1,2402," 因为str3"]],[2402,2402],[2409,2409]]],[1567573258627,["GJX@GJXAIOU",[[-1,2408,"3"]],[2409,2409],[2408,2408]]],[1567573258773,["GJX@GJXAIOU",[[1,2408,"2"]],[2408,2408],[2409,2409]]],[1567573261085,["GJX@GJXAIOU",[[1,2405," "]],[2405,2405],[2406,2406]]],[1567573278127,["GJX@GJXAIOU",[[1,2410," 是子类定义的，这里调用这句话即是"]],[2410,2410],[2427,2427]]],[1567573279105,["GJX@GJXAIOU",[[-1,2425,"即是"]],[2427,2427],[2425,2425]]],[1567573314022,["GJX@GJXAIOU",[[1,2425,"就是对子类的主动调用，所以子类的静态代码块一定会执行，同时"]],[2425,2425],[2454,2454]]],[1567573368066,["GJX@GJXAIOU",[[1,2454,"主动使用的时候，初始化子类的同时也会初始化父类；（）"]],[2454,2454],[2480,2480]]],[1567573378408,["GJX@GJXAIOU",[[1,2479,"初始化父类的子类，本质上随"]],[2479,2479],[2492,2492]]],[1567573378766,["GJX@GJXAIOU",[[-1,2491,"随"]],[2492,2492],[2491,2491]]],[1567573381047,["GJX@GJXAIOU",[[1,2491,"对父类的"]],[2491,2491],[2495,2495]]],[1567573381923,["GJX@GJXAIOU",[[-1,2494,"的"]],[2495,2495],[2494,2494]]],[1567573440726,["GJX@GJXAIOU",[[1,2494,"也是主动调用，而子类调用子类的静态变量，也是"]],[2494,2494],[2516,2516]]],[1567573445494,["GJX@GJXAIOU",[[1,2516,"主动使用。"]],[2516,2516],[2521,2521]]],[1567573460131,["GJX@GJXAIOU",[[-1,2870,"\n"]],[2870,2870],[2869,2869]]],[1567574864413,["GJX@GJXAIOU",[[1,1962,"（）"]],[1962,1962],[1964,1964]]],[1567574866134,["GJX@GJXAIOU",[[1,1963,"侄儿"]],[1963,1963],[1965,1965]]],[1567574867234,["GJX@GJXAIOU",[[-1,1963,"侄儿"]],[1965,1965],[1963,1963]]],[1567574871757,["GJX@GJXAIOU",[[1,1963,"在类的Vm p"]],[1963,1963],[1970,1970]]],[1567574872625,["GJX@GJXAIOU",[[-1,1969,"p"]],[1970,1970],[1969,1969]]],[1567574877831,["GJX@GJXAIOU",[[1,1969,"option 中进行配置"]],[1969,1969],[1981,1981]]],[1567574881516,["GJX@GJXAIOU",[[-1,1967,"m"]],[1968,1968],[1967,1967]]],[1567574882477,["GJX@GJXAIOU",[[1,1967,"M"]],[1967,1967],[1968,1968]]],[1567574951724,["GJX@GJXAIOU",[[1,1951,"当前"]],[1951,1951],[1953,1953]]],[1567574952175,["GJX@GJXAIOU",[[1,1954,"类"]],[1953,1953],[1954,1954]]],[1567574953452,["GJX@GJXAIOU",[[-1,1954,"类"]],[1954,1954],[1953,1953]]],[1567574956903,["GJX@GJXAIOU",[[1,1951,"运行"]],[1951,1951],[1953,1953]]],[1567575037598,["GJX@GJXAIOU",[[1,1987,"        JVM尝试的"]],[1987,1987],[2001,2001]]],[1567575038845,["GJX@GJXAIOU",[[-1,1997,"M尝试的"]],[2001,2001],[1997,1997]]],[1567575045509,["GJX@GJXAIOU",[[1,1997,"M参数的格式："]],[1997,1997],[2004,2004]]],[1567575049026,["GJX@GJXAIOU",[[1,1995,"\n        "]],[1995,1995],[2004,2004]]],[1567575185913,["GJX@GJXAIOU",[[-1,3429,"//输出 hello world"]],[3429,3445],[3429,3429]]],[1567575187387,["GJX@GJXAIOU",[[1,3387,"\n    "]],[3382,3382],[3387,3387]]],[1567575188190,["GJX@GJXAIOU",[[1,3387,"、、"]],[3387,3387],[3389,3389]]],[1567575189201,["GJX@GJXAIOU",[[-1,3387,"、、"]],[3389,3389],[3387,3387]]],[1567575191175,["GJX@GJXAIOU",[[1,3387,"    、、"]],[3387,3387],[3393,3393]]],[1567575191947,["GJX@GJXAIOU",[[-1,3391,"、、"]],[3393,3393],[3391,3391]]],[1567575203701,["GJX@GJXAIOU",[[1,3391,"// 输出： "]],[3391,3391],[3398,3398]]],[1567575204985,["GJX@GJXAIOU",[[-1,3397," "]],[3398,3398],[3397,3397]]],[1567575208615,["GJX@GJXAIOU",[[1,3397,"MyParent static block  //输出 hello world"]],[3397,3397],[3436,3436]]],[1567575211386,["GJX@GJXAIOU",[[-1,3420,"//输出 "]],[3424,3424],[3419,3419]]],[1567575214062,["GJX@GJXAIOU",[[1,3418,"；"]],[3418,3418],[3419,3419]]],[1567575214770,["GJX@GJXAIOU",[[-1,3418,"；"]],[3419,3419],[3418,3418]]],[1567575215301,["GJX@GJXAIOU",[[1,3418,"、"]],[3418,3418],[3419,3419]]],[1567575216715,["GJX@GJXAIOU",[[-1,3420," "]],[3421,3421],[3420,3420]]],[1567575246770,["GJX@GJXAIOU",[[1,3633,"\n"]],[3632,3632],[3633,3633]]],[1567575247306,["GJX@GJXAIOU",[[1,3633," public static final String str=\"hello world\";"]],[3633,3633],[3679,3679]]],[1567575250007,["GJX@GJXAIOU",[[1,3634,"   "]],[3634,3634],[3637,3637]]],[1567575254506,["GJX@GJXAIOU",[[-1,3651,"final "]],[3656,3656],[3650,3650]]],[1567575258068,["GJX@GJXAIOU",[[1,3661,"1"]],[3661,3661],[3662,3662]]],[1567575264355,["GJX@GJXAIOU",[[1,3477,"\n        "]],[3477,3477],[3486,3486]]],[1567575264650,["GJX@GJXAIOU",[[-1,3478,"         "],[1,3487,"\n"]],[3486,3486],[3479,3479]]],[1567575265081,["GJX@GJXAIOU",[[1,3479,"System.out.println(MyParent2.str);  "]],[3479,3479],[3515,3515]]],[1567575269222,["GJX@GJXAIOU",[[1,3479,"        "]],[3479,3479],[3487,3487]]],[1567575271453,["GJX@GJXAIOU",[[1,3472,"1"]],[3472,3472],[3473,3473]]],[1567575282956,["GJX@GJXAIOU",[[1,2919,"常量"]],[2919,2919],[2921,2921]]],[1567575317904,["GJX@GJXAIOU",[[1,3481,"        、、"]],[3481,3481],[3491,3491]]],[1567575318675,["GJX@GJXAIOU",[[-1,3489,"、、"]],[3491,3491],[3489,3489]]],[1567575320739,["GJX@GJXAIOU",[[1,3489,"// shu"]],[3489,3489],[3495,3495]]],[1567575321762,["GJX@GJXAIOU",[[-1,3492,"shu"]],[3495,3495],[3492,3492]]],[1567575323519,["GJX@GJXAIOU",[[1,3492,"输出 "]],[3492,3492],[3495,3495]]],[1567575325314,["GJX@GJXAIOU",[[-1,3494," "]],[3495,3495],[3494,3494]]],[1567575331949,["GJX@GJXAIOU",[[1,3494,"：hello world"]],[3494,3494],[3506,3506]]],[1567575421129,["GJX@GJXAIOU",[[-1,2988,"调"]],[2989,2989],[2988,2988]]],[1567575422959,["GJX@GJXAIOU",[[1,2988,"引用"]],[2988,2988],[2990,2990]]],[1567575423289,["GJX@GJXAIOU",[[-1,2990,"用"]],[2990,2990],[2989,2989]]],[1567575465852,["GJX@GJXAIOU",[[1,3068,"2 "]],[3068,3068],[3070,3070]]],[1567575477250,["GJX@GJXAIOU",[[1,3015,"（）"]],[3015,3015],[3017,3017]]],[1567575480439,["GJX@GJXAIOU",[[1,3016,"所以不会"]],[3016,3016],[3020,3020]]],[1567575494551,["GJX@GJXAIOU",[[1,3120,"（）"]],[3120,3120],[3122,3122]]],[1567575499549,["GJX@GJXAIOU",[[1,3121,"编译完之后"]],[3121,3121],[3126,3126]]],[1567575509599,["GJX@GJXAIOU",[[1,3020,"执行静态代码块"]],[3020,3020],[3027,3027]]],[1567575552469,["GJX@GJXAIOU",[[1,3134,"，程序还可以执行。"]],[3134,3134],[3143,3143]]],[1567577948210,["GJX@GJXAIOU",[[1,3144,"          "]],[3144,3144],[3154,3154]]],[1567577949622,["GJX@GJXAIOU",[[-1,3152,"  "]],[3154,3154],[3152,3152]]],[1567577961571,["GJX@GJXAIOU",[[1,3152,"助记符：反编译之后在"]],[3152,3152],[3162,3162]]],[1567577965519,["GJX@GJXAIOU",[[-1,3161,"在"]],[3162,3162],[3161,3161]]],[1567577982651,["GJX@GJXAIOU",[[1,3161,"可以看到"]],[3161,3161],[3165,3165]]],[1567578019191,["GJX@GJXAIOU",[[-1,3355,"m"]],[3356,3356],[3355,3355]]],[1567578041185,["GJX@GJXAIOU",[[1,3365,"，值为6之后使用 bil"]],[3365,3365],[3377,3377]]],[1567578041968,["GJX@GJXAIOU",[[-1,3376,"l"]],[3377,3377],[3376,3376]]],[1567578043047,["GJX@GJXAIOU",[[1,3376,"push"]],[3376,3376],[3380,3380]]],[1567578047944,["GJX@GJXAIOU",[[-1,4044,"\n"]],[4044,4044],[4043,4043]]],[1567578089912,["GJX@GJXAIOU",[[1,4049,"\n"]],[4048,4048],[4049,4049]]],[1567578093024,["GJX@GJXAIOU",[[-1,4058,"\n"]],[4058,4058],[4057,4057]]],[1567578427384,["GJX@GJXAIOU",[[1,3355,"m"]],[3355,3355],[3356,3356]]],[1567578431566,["GJX@GJXAIOU",[[1,3367,"()"]],[3367,3367],[3369,3369]]],[1567578434274,["GJX@GJXAIOU",[[1,3368,"-1dao"]],[3368,3368],[3373,3373]]],[1567578435630,["GJX@GJXAIOU",[[-1,3370,"dao"]],[3373,3373],[3370,3370]]],[1567578438780,["GJX@GJXAIOU",[[1,3370,"到5"]],[3370,3370],[3372,3372]]],[1567578651415,["GJX@GJXAIOU",[[-1,4277,"//输出MyParent static block、kjqhdun-baoje21w-jxqioj1-2jwejc9029"]],[4277,4338],[4277,4277]]],[1567578652831,["GJX@GJXAIOU",[[1,4237,"\n    "]],[4232,4232],[4237,4237]]],[1567578653207,["GJX@GJXAIOU",[[1,4237,"//输出MyParent static block、kjqhdun-baoje21w-jxqioj1-2jwejc9029"]],[4237,4237],[4298,4298]]],[1567578806945,["GJX@GJXAIOU",[[1,4064," "]],[4064,4064],[4065,4065]]],[1567578807886,["GJX@GJXAIOU",[[-1,4064," "]],[4065,4065],[4064,4064]]],[1567578809073,["GJX@GJXAIOU",[[1,4063," "]],[4063,4063],[4064,4064]]],[1567578817387,["GJX@GJXAIOU",[[1,4065,"：常量的值不确定的时候"]],[4065,4065],[4076,4076]]],[1567579027391,["GJX@GJXAIOU",[[-1,4937,"//创建类的实例，属于主动使用，会导致类的初始化"]],[4937,4961],[4937,4937]]],[1567579028942,["GJX@GJXAIOU",[[1,4889,"\n    "]],[4884,4884],[4889,4889]]],[1567579029408,["GJX@GJXAIOU",[[1,4889,"//创建类的实例，属于主动使用，会导致类的初始化"]],[4889,4889],[4913,4913]]],[1567579036319,["GJX@GJXAIOU",[[-1,5019,"//不是主动使用"]],[5019,5027],[5019,5019]]],[1567579037694,["GJX@GJXAIOU",[[1,4960,"\n        "]],[4960,4960],[4969,4969]]],[1567579037915,["GJX@GJXAIOU",[[-1,4961,"              "],[1,4975,"\n"]],[4969,4969],[4962,4962]]],[1567579041807,["GJX@GJXAIOU",[[1,4962,"        //不是主动使用"]],[4962,4962],[4978,4978]]],[1567579109366,["GJX@GJXAIOU",[[-1,5092,"//输出 [L com.hisense.classloader.MyParent4"]],[5092,5133],[5092,5092]]],[1567579112110,["GJX@GJXAIOU",[[1,5028,"\n        //输出 [L com.hisense.classloader.MyParent4"]],[5028,5028],[5078,5078]]],[1567579115743,["GJX@GJXAIOU",[[-1,5213,"//输出Object"]],[5213,5223],[5213,5213]]],[1567579117989,["GJX@GJXAIOU",[[1,5138,"\n        //输出Object"]],[5138,5138],[5157,5157]]],[1567579299955,["GJX@GJXAIOU",[[1,4624,"动态生成的类型，其父类型就是Object"]],[4624,4624],[4644,4644]]],[1567579315102,["GJX@GJXAIOU",[[1,4982,"\n"]],[4981,4981],[4982,4982]]],[1567579315962,["GJX@GJXAIOU",[[1,4982,"、、"]],[4982,4982],[4984,4984]]],[1567579316976,["GJX@GJXAIOU",[[-1,4982,"、、"]],[4984,4984],[4982,4982]]],[1567579323466,["GJX@GJXAIOU",[[1,4982,"// 引用类型数组"]],[4982,4982],[4991,4991]]],[1567579327335,["GJX@GJXAIOU",[[1,5263,"、、"]],[5263,5263],[5265,5265]]],[1567579328173,["GJX@GJXAIOU",[[-1,5263,"、、"]],[5265,5265],[5263,5263]]],[1567579328694,["GJX@GJXAIOU",[[1,5264,"\n"]],[5263,5263],[5264,5264]]],[1567579331491,["GJX@GJXAIOU",[[1,5264,"// 元素"]],[5264,5264],[5269,5269]]],[1567579332149,["GJX@GJXAIOU",[[-1,5267,"元素"]],[5269,5269],[5267,5267]]],[1567579337041,["GJX@GJXAIOU",[[1,5267,"原生类型的数组"]],[5267,5267],[5274,5274]]],[1567579368587,["GJX@GJXAIOU",[[1,5181," ava"]],[5181,5181],[5185,5185]]],[1567579369664,["GJX@GJXAIOU",[[-1,5182,"ava"]],[5185,5185],[5182,5182]]],[1567579372330,["GJX@GJXAIOU",[[1,5182,"java.lang."]],[5182,5182],[5192,5192]]],[1567579378240,["GJX@GJXAIOU",[[1,5439,"java.lang."]],[5439,5439],[5449,5449]]],[1567579424819,["GJX@GJXAIOU",[[1,4533,":sh"]],[4533,4533],[4536,4536]]],[1567579425776,["GJX@GJXAIOU",[[-1,4533,":sh"]],[4536,4536],[4533,4533]]],[1567579426530,["GJX@GJXAIOU",[[1,4533,"："]],[4533,4533],[4534,4534]]],[1567579427946,["GJX@GJXAIOU",[[1,4534,"数组"]],[4534,4534],[4536,4536]]],[1567579462858,["GJX@GJXAIOU",[[1,4798,"如"]],[4798,4798],[4799,4799]]],[1567579470721,["GJX@GJXAIOU",[[-1,4824,"d"]],[4825,4825],[4824,4824]]],[1567579479123,["GJX@GJXAIOU",[[1,4823," char"]],[4823,4823],[4828,4828]]],[1567579511457,["GJX@GJXAIOU",[[1,4989,"、、"]],[4989,4989],[4991,4991]]],[1567579512409,["GJX@GJXAIOU",[[-1,4989,"、、"]],[4991,4991],[4989,4989]]],[1567579514550,["GJX@GJXAIOU",[[1,4989,"// dang"]],[4989,4989],[4996,4996]]],[1567579516821,["GJX@GJXAIOU",[[-1,4992,"dang"]],[4996,4996],[4992,4992]]],[1567579517439,["GJX@GJXAIOU",[[1,4992,"s"]],[4992,4992],[4993,4993]]],[1567579518044,["GJX@GJXAIOU",[[-1,4992,"s"]],[4993,4993],[4992,4992]]],[1567579538496,["GJX@GJXAIOU",[[1,4992,"当创建数组类型的实例，并不表示随"]],[4992,4992],[5008,5008]]],[1567579539312,["GJX@GJXAIOU",[[-1,5007,"随"]],[5008,5008],[5007,5007]]],[1567579544584,["GJX@GJXAIOU",[[1,5007,"对数组中的元素的主动"]],[5007,5007],[5017,5017]]],[1567579556711,["GJX@GJXAIOU",[[1,5017,"使用，二"]],[5017,5017],[5021,5021]]],[1567579557159,["GJX@GJXAIOU",[[-1,5020,"二"]],[5021,5021],[5020,5020]]],[1567579584695,["GJX@GJXAIOU",[[1,5020,"而仅仅表示创建了这个数组的实例而已，数组newe"]],[5020,5020],[5044,5044]]],[1567579585558,["GJX@GJXAIOU",[[-1,5043,"e"]],[5044,5044],[5043,5043]]],[1567579606693,["GJX@GJXAIOU",[[1,5043," 出来的实例类型有由JVM在运行期动态生成的"]],[5043,5043],[5065,5065]]],[1567579611706,["GJX@GJXAIOU",[[1,5065,"，"]],[5065,5065],[5066,5066]]],[1567579613968,["GJX@GJXAIOU",[[-1,5065,"，"]],[5066,5066],[5065,5065]]],[1567579614715,["GJX@GJXAIOU",[[1,5065,"。"]],[5065,5065],[5066,5066]]],[1567579662141,["GJX@GJXAIOU",[[1,5067,"\n"]],[5066,5066],[5067,5067]]],[1567579662968,["GJX@GJXAIOU",[[1,5068,"\n"]],[5067,5067],[5068,5068]]],[1567579663119,["GJX@GJXAIOU",[[1,5069,"\n"]],[5068,5068],[5069,5069]]],[1567579666649,["GJX@GJXAIOU",[[1,5067,"具体的"]],[5067,5067],[5070,5070]]],[1567579683571,["GJX@GJXAIOU",[[1,5070,"类型以原始类型为例： int - "]],[5070,5070],[5087,5087]]],[1567579684277,["GJX@GJXAIOU",[[-1,5086," "]],[5087,5087],[5086,5086]]],[1567579686921,["GJX@GJXAIOU",[[1,5086,"> I"]],[5086,5086],[5089,5089]]],[1567579690464,["GJX@GJXAIOU",[[1,5088,"["]],[5088,5088],[5089,5089]]],[1567579695867,["GJX@GJXAIOU",[[1,5079,"()"]],[5079,5079],[5081,5081]]],[1567579697944,["GJX@GJXAIOU",[[1,5080,"yiwei"]],[5080,5080],[5085,5085]]],[1567579699141,["GJX@GJXAIOU",[[-1,5080,"yiwei"]],[5085,5085],[5080,5080]]],[1567579700841,["GJX@GJXAIOU",[[1,5080,"以为"]],[5080,5080],[5082,5082]]],[1567579701570,["GJX@GJXAIOU",[[-1,5080,"以为"]],[5082,5082],[5080,5080]]],[1567579706281,["GJX@GJXAIOU",[[1,5080,"一维是 ;"]],[5080,5080],[5085,5085]]],[1567579707125,["GJX@GJXAIOU",[[-1,5084,";"]],[5085,5085],[5084,5084]]],[1567579710682,["GJX@GJXAIOU",[[1,5084,"[,er"]],[5084,5084],[5088,5088]]],[1567579711444,["GJX@GJXAIOU",[[-1,5086,"er"]],[5088,5088],[5086,5086]]],[1567579711921,["GJX@GJXAIOU",[[1,5086,"= "]],[5086,5086],[5088,5088]]],[1567579713280,["GJX@GJXAIOU",[[-1,5086,"= "]],[5088,5088],[5086,5086]]],[1567579717486,["GJX@GJXAIOU",[[1,5086,"二维是[["]],[5086,5086],[5091,5091]]],[1567579719256,["GJX@GJXAIOU",[[1,5089," "]],[5089,5089],[5090,5090]]],[1567579727648,["GJX@GJXAIOU",[[1,5074,"iwie"]],[5074,5074],[5078,5078]]],[1567579729053,["GJX@GJXAIOU",[[-1,5073,"yiwie"]],[5078,5078],[5073,5073]]],[1567579730738,["GJX@GJXAIOU",[[1,5073,"一维"]],[5073,5073],[5075,5075]]],[1567579733738,["GJX@GJXAIOU",[[1,5106," ；"]],[5106,5106],[5108,5108]]],[1567579735414,["GJX@GJXAIOU",[[-1,5107,"；"]],[5108,5108],[5107,5107]]],[1567579742235,["GJX@GJXAIOU",[[1,5107,"chatr"]],[5107,5107],[5112,5112]]],[1567579744214,["GJX@GJXAIOU",[[-1,5110,"tr"]],[5112,5112],[5110,5110]]],[1567579756822,["GJX@GJXAIOU",[[1,5110,"r ->[C booleasn"]],[5110,5110],[5125,5125]]],[1567579757883,["GJX@GJXAIOU",[[-1,5123,"sn"]],[5125,5125],[5123,5123]]],[1567579769864,["GJX@GJXAIOU",[[1,5123,"n -> [Z shot"]],[5123,5123],[5135,5135]]],[1567579770398,["GJX@GJXAIOU",[[-1,5134,"t"]],[5135,5135],[5134,5134]]],[1567579786145,["GJX@GJXAIOU",[[1,5134,"rt -> [S   byte -> B"]],[5134,5134],[5154,5154]]],[1567579846953,[null,[[1,5075,"原"],[-1,5105,"\n"],[1,5154,"\n"]],[5075,5075],[5155,5155]]],[1567579846953,[null,[[-1,5075,"原"],[1,5106,"\n"],[-1,5154,"\n"]],[5155,5155],[5075,5075]]],[1567579844413,["GJX@GJXAIOU",[[-1,5744,"\n"]],[5744,5744],[5743,5743]]],[1567579906952,[null,[[1,5075,"原"],[-1,5105,"\n"],[1,5154,"\n"],[-1,5743,"\n"],[1,5744,"`"]],[5075,5075],[5745,5745]]],[1567579906952,[null,[[-1,5075,"原"],[1,5106,"\n"],[-1,5154,"\n"],[1,5744,"\n"],[-1,5744,"`"]],[5745,5745],[5075,5075]]],[1567579851123,["GJX@GJXAIOU",[[1,5743," :guanyu"]],[5743,5743],[5751,5751]]],[1567579853075,["GJX@GJXAIOU",[[-1,5742,"5 :guanyu"]],[5751,5751],[5742,5742]]],[1567579854729,["GJX@GJXAIOU",[[1,5742,"5"]],[5742,5742],[5743,5743]]],[1567579854794,["GJX@GJXAIOU",[[1,5742," "]],[5743,5743],[5744,5744]]],[1567579858627,["GJX@GJXAIOU",[[1,5744," ：关于接口"]],[5744,5744],[5750,5750]]],[1567579897216,["GJX@GJXAIOU",[[1,6180,"\n"]],[6180,6180],[6181,6181]]],[1567580746960,[null,[[1,5075,"原"],[-1,5105,"\n"],[1,5154,"\n"],[-1,5741,"5"],[1,5751,"`"],[-1,6179,"/"],[1,6181,"/"]],[5075,5075],[6182,6182]]],[1567580746960,[null,[[-1,5075,"原"],[1,5106,"\n"],[-1,5154,"\n"],[1,5742,"5"],[-1,5751,"`"],[1,6180,"/"],[-1,6181,"/"]],[6182,6182],[5075,5075]]],[1567580734450,["GJX@GJXAIOU",[[1,6181," "]],[6181,6181],[6182,6182]]],[1567580807110,[null,[[1,5075,"原"],[-1,5105,"\n"],[1,5154,"\n"],[-1,5741,"5"],[1,5751,"`"],[-1,6179,"/"],[1,6182,"/"]],[5075,5075],[6183,6183]]],[1567580807110,[null,[[-1,5075,"原"],[1,5106,"\n"],[-1,5154,"\n"],[1,5742,"5"],[-1,5751,"`"],[1,6180,"/"],[-1,6182,"/"]],[6183,6183],[5075,5075]]],[1567580748766,["GJX@GJXAIOU",[[1,6413,"\n         "]],[6403,6403],[6413,6413]]],[1567580749991,["GJX@GJXAIOU",[[1,6413,"、"]],[6413,6413],[6414,6414]]],[1567580751020,["GJX@GJXAIOU",[[-1,6413,"、"]],[6414,6414],[6413,6413]]],[1567580751788,["GJX@GJXAIOU",[[1,6413,"、、"]],[6413,6413],[6415,6415]]],[1567580752397,["GJX@GJXAIOU",[[-1,6413,"、、"]],[6415,6415],[6413,6413]]],[1567580754367,["GJX@GJXAIOU",[[1,6413,"// shou"]],[6413,6413],[6420,6420]]],[1567580756451,["GJX@GJXAIOU",[[-1,6416,"shou"]],[6420,6420],[6416,6416]]],[1567580773528,["GJX@GJXAIOU",[[1,6416,"首先调用 Singleton的"]],[6416,6416],[6431,6431]]],[1567580775759,["GJX@GJXAIOU",[[1,6430," "]],[6430,6430],[6431,6431]]],[1567580780192,["GJX@GJXAIOU",[[1,6421,"类"]],[6421,6421],[6422,6422]]],[1567580793332,["GJX@GJXAIOU",[[-1,6420," "]],[6421,6421],[6420,6420]]],[1567580794351,["GJX@GJXAIOU",[[1,6421," "]],[6421,6421],[6422,6422]]],[1567580806888,["GJX@GJXAIOU",[[1,6433,"静态方法，表示对该类的"]],[6433,6433],[6444,6444]]],[1567580867108,[null,[[1,5075,"原"],[-1,5105,"\n"],[1,5155,"\n"],[-1,5741,"5"],[1,5751,"`"],[-1,6179,"/"],[1,6182,"/"],[-1,6403," "],[1,6445," "]],[5075,5075],[6446,6446]]],[1567580867108,[null,[[-1,5075,"原"],[1,5106,"\n"],[-1,5155,"\n"],[1,5742,"5"],[-1,5751,"`"],[1,6180,"/"],[-1,6182,"/"],[1,6404," "],[-1,6445," "]],[6446,6446],[5075,5075]]],[1567580809017,["GJX@GJXAIOU",[[1,6444,"主动使用"]],[6444,6444],[6448,6448]]]],null,"GJX@GJXAIOU"],["3f82e31a-3264-42c2-85cb-0018f6c66844",1568551812042,"# 第4讲：类加载器深入解析与阶段分解\n\n## 一、类加载\n\nclass loading\n\n*   在java代码中，**类的加载、连接和初始化过程都是在程序运行期间完成的**。（类从磁盘加载到内存中经历的三个阶段）\n*   提供了更大的灵活性，增加了更多的可能性。\n- 这里的类就是指类本身，而不是指类的对象；\n- 类的加载常见方式是：将已经编译或者存在的字节码文件从磁盘加载到内存中；\n- 连接：主要是将类与类之间的关系确定好，同时对字节码文件进行校验等处理；\n\n\n### （一）类加载器深入剖析：\n每一个类都是由类加载器加载进入内存中；\n*   Java虚拟机与程序的生命周期（JVM 本身就是一个进程）\n*   在如下几种情况下，java虚拟机将结束生命周期\n    （1）执行了System.exit()方法\n    （2）程序正常执行结束\n    （3）程序在执行过程中遇到了异常或错误而异常终止\n    （4）由于操作系统出现错误而导致虚拟机进程终止\n\n### （二）类的加载、连接与初始化：\n\n*  加载：查找并加载类的二进制数据到 java 虚拟机中\n*  连接：\n    * 验证 : 确保被加载的类的正确性\n    * 准备：为类的**静态变量**分配内存，并将其初始化为**默认值**，但是到达初始化之前类变量都没有初始化为真正的初始值，同时这时候还没有创建对象；示例见下：\n   * 解析：**把类中的符号引用转换为直接引用**，就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程\n*   初始化：为类的静态变量赋予正确的初始值\n```java\n// 下面语句在准备阶段对变量进行初始赋值，因为为整型，因此初始赋值为 0，然后在初始化阶段重新赋值为 1；\nstatic int a = 1;\n```\n\n![类的加载连接以及初始化]($resource/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%9E%E6%8E%A5%E4%BB%A5%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96.png)\n\n\n### （三）类的使用和卸载\n包括类的使用和卸载，其中卸载一般不使用；\n\n**类从磁盘上加载到内存中要经历五个阶段：加载、连接、初始化、使用、卸载**\n\n### （二）类的加载、连接与初始化具体\n\n*   Java程序对类的使用方式可分为两种\n    （1）主动使用\n    （2）被动使用\n*   所有的Java虚拟机实现必须在每个类或接口被Java程序“**首次主动使用**”时才能初始化他们\n*   主动使用（七种）\n    （1）创建类的实例\n    （2）访问某个类或接口的静态变量 getstatic（助记符），或者对该静态变量赋值 putstatic\n    （3）调用类的静态方法 invokestatic\n    （4）反射（Class.forName(“com.test.Test”)）\n    （5）初始化一个类的子类\n    （6）Java虚拟机启动时被标明启动类的类 ：即包含 main 方法的类\n    （7）JDK1.7开始提供的动态语言支持（了解）\n*   被动使用\n    除了上面七种情况外，其他使用java类的方式都被看做是对类的被动使用，都不会导致类的初始化（但是连接和加载的操作可能发生）。\n\n#### 类的加载详解：\n\n*   类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（jvm 规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在**方法区**中）用来封装内在方法区内的数据结构。**一个类不管生成多少实例，所有实例对应的 Class 对象只有一份。**\n*   加载.calss文件的方式\n    （1）从本地系统中直接加载\n    （2）通过网络下载.class文件\n    （3）从zip，jar等归档文件中加载.class文件\n    （4）从专用数据库中提取.class文件（很少使用）\n    （5）将java源文件动态编译为.class文件（一般存在于动态代理，因为动态代理的类是运行时候才产生，编译的时候是没有的）\n\n*   测试1：分析主动使用和被动使用的区别\n```\n/**\n        对于静态字段来说，只有直接定义了该字段的类才会被初始化\n        当一个类在初始化时，要求父类全部都已经初始化完毕\n        -XX:+TraceClassLoading，用于追踪运行当前类的加载信息并打印出来（在类的VM option 中进行配置）\n        \n        JVM参数的格式：\n        -XX:+<option>，表示开启option选项\n        -XX:-<option>，表示关闭option选项\n        -XX:<option>=value，表示将option的值设置为value\n*/\npublic class MyTest{\n    public static void main(String[] args){\n        // 下面语句输出：MyParent static block、hello world   \n        // 这里的 str 是父类进行定义的，这里主动使用了父类，但是没有主动使用子类，因此子类没有被初始化，最终不会执行子类中的静态代码块；\n        System.out.println(MyChild.str);  \n\n        // 输出：MyParent static block、MyChild static block、welcome  \n        // 因为 str2 是子类定义的，这里调用这句话就是对子类的主动调用，所以子类的静态代码块一定会执行，同时主动使用的时候，初始化子类的同时也会初始化父类；（初始化父类的子类，本质上对父类也是主动调用，而子类调用子类的静态变量，也是主动使用。）\n        System.out.println(MyChild.str2);  \n    }\n}\nclass MyParent{\n    public static String str=\"hello world\";\n    static {\n        System.out.println(\"MyParent static block\");\n    }\n}\nclass MyChild extends MyParent{\n    public static String str2=\"welcome\";\n    static {\n        System.out.println(\"MyChild static block\");\n    }\n}\n\n```\n\n*   测试2：常量\n```\n/**\n        常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中\n        本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化（所以不会执行静态代码块）\n        注意：这里指的是将常量存到MyTest2的常量池中，之后MyTest2和MyParent2 就没有任何关系了。\n        甚至我们可以将MyParent2的class文件删除（编译完之后），程序还可以执行。\n        助记符：反编译之后可以看到\n        助记符 ldc：表示将int、float或者String类型的常量值从常量池中推送至栈顶\n        助记符 bipush：表示将单字节（-128-127）的常量值推送到栈顶\n        助记符 sipush：表示将一个短整型值（-32768-32369）推送至栈顶\n        助记符 iconst_1：表示将int型的1推送至栈顶（iconst_m1到iconst_5，(-1到5)值为6之后使用 bipush）\n*/\npublic class MyTest2{\n    public static void main(String[] args){\n        // 输出：MyParent static block、 hello world\n        System.out.println(MyParent2.str1);   \n        // 输出：hello world\n        System.out.println(MyParent2.str);  \n        System.out.println(MyParent2.s);  \n        System.out.println(MyParent2.i);  \n        System.out.println(MyParent2.j);  \n    }\n}\nclass MyParent2{\n    public static String str1=\"hello world\";\n    public static final String str=\"hello world\";\n    public static final short s=7;\n    public static final int i=129;\n    public static final int j=1;\n    static {\n        System.out.println(\"MyParent static block\");\n    }\n}\n```\n\n\n*   测试 3：常量的值不确定的时候\n```\n/**\n        当一个常量的值并非编译期间可以确定的，那么其值就不会放到调用类的常量池中\n        这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化\n*/\npublic class MyTest3{\n    public static void main(String[] args){\n    //输出MyParent static block、kjqhdun-baoje21w-jxqioj1-2jwejc9029\n        System.out.println(MyParent3.str);  \n    }\n}\nclass MyParent3{\n    public static final String str=UUID.randomUUID().toString();\n    static {\n        System.out.println(\"MyParent static block\");\n    }\n}\n\n```\n\n*   测试4：数组\n\n```\n/**\n        对于数组实例来说，其类型是由JVM在运行期动态生成的，表示为 [L com.hisense.classloader.MyParent4 这种形式。动态生成的类型，其父类型就是Object\n        对于数组来说，JavaDoc经构成数据的元素成为Component，实际上是将数组降低一个维度后的类型。\n\n        助记符：anewarray：表示创建一个引用类型（如类、接口）的数组，并将其引用值压入栈顶\n        助记符：newarray：表示创建一个指定原始类型（如int boolean float double char）的数组，并将其引用值压入栈顶\n*/\npublic class MyTest4{\n    public static void main(String[] args){\n    //创建类的实例，属于主动使用，会导致类的初始化\n        MyParent4 myParent4=new MyParent4();  \n// 当创建数组类型的实例，并不表示对数组中的元素的主动使用，而仅仅表示创建了这个数组的实例而已，数组new 出来的实例类型有由JVM在运行期动态生成的。\n具体的类型以一维原始类型为例(一维是 [,二维是 [[)： int -> [I char ->[C boolean -> [Z short -> [S   byte -> B\n\n\n// 引用类型数组\n        //不是主动使用\n        MyParent4[] myParent4s=new MyParent4[1]; \n        //输出 [L com.hisense.classloader.MyParent4   \n        System.out.println(myParent4s.getClass());      \n        //输出 java.lang.Object    \n        System.out.println(myParent4s.getClass().getSuperClass());    \n\n// 原生类型的数组\n        int[] i=new int[1];\n        System.out.println(i.getClass());          //输出 [ I\n        System.out.println(i.getClass().getSuperClass());    //输出java.lang.Object\n    }\n}\nclass MyParent4{\n    static {\n        System.out.println(\"MyParent static block\");\n    }\n}\n\n```\n\n*   测试 5 ：关于接口\n```\n/**\n        当一个接口在初始化时，并不要求其父接口都完成了初始化\n        只有在真正使用到父接口的时候（如引用接口中定义的常量），才会初始化\n*/\npublic class MyTest5{\n    public static void main(String[] args){\n         public static void main(String[] args){\n            System.out.println(MyChild5.b)\n         }\n    }\n}\ninterfacce MParent5{\n    public static Thread thread=new thread(){\n        System.out.println(\" MParent5 invoke\")\n    };\n}\ninterface MyChild5 extends MParent5{     \n //接口属性默认是 public static final\n    public static int b=6;\n}\n\n```\n\n*   测试6\n\n```\n/**\n        准备阶段和初始化的顺序问题\n*/\npublic class MyTest6{\n    public static void main(String[] args){\n         public static void main(String[] args){\n         // 首先调用类 Singleton 的静态方法，表示对该类的主动使用\n            Singleton Singleton=Singleton.getInstance();\n            System.out.println(Singleton.counter1);     //输出1，1\n            System.out.println(Singleton.counter2);\n         }\n    }\n}\nclass Singleton{\n    public static int counter1;\n    public static int counter2=0;               /\n    private static Singleton singleton=new Singleton();\n\n    private Singleton(){\n        counter1++;\n        counter2++;\n    }\n\n    // public static int counter2=0;       //   若改变此赋值语句的位置，输出  1，0\n    public static Singleton getInstance(){\n        return singleton;\n    }\n}\n\n```\n\n加载\n连接（验证、准备、解析）\n初始化\n类初始化：为新的对象分配内存，为实例变量赋默认值，为实例变量赋正确的初始值\n\njava编译器在它编译的每一个类都至少生成一个实例化的方法，在java的class文件中，这个实例化方法被称为“”。针对源代码中每一个类的构造方法，java编译器都会产生一个“”方法。\n\n###### 有两种类型的类加载器\n\n1.  Java虚拟机自带的加载器\n\n*   **根类加载器**（Bootstrap）：该加载器没有父加载器，它负责加载虚拟机中的核心类库。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有集成java.lang.ClassLoader类。\n*   **扩展类加载器**（Extension）：它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的jre\\lib\\ext子目录（扩展目录）下加载类库，如果把用户创建的jar文件放在这个目录下，也会自动由扩展类加载器加载，扩展类加载器是纯java类，是java.lang.ClassLoader的子类。\n*   **系统应用类加载器**（System）：也称为应用类加载器，它的父加载器为扩展类加载器，它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，他是用户自定义的类加载器的默认父加载器。系统类加载器时纯java类，是java.lang.ClassLoader的子类。\n\n1.  用户自定义的类加载器\n\n*   java.lang.ClassLoader的子类\n*   用户可以定制类的加载方式\n\n根类加载器–>扩展类加载器–>系统应用类加载器–>自定义类加载器\n类加载器并不需要等到某个类被“首次主动使用”时再加载它\n\nJVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在**程序首次主动**使用该类才报告错误（LinkageError错误），如果这个类没有被程序主动使用，那么类加载器就不会报告错误。\n\n类加载器用来把类加载到java虚拟机中。从JDK1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好地保证Java平台的安全。在此委托机制中，除了java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。当java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则有父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。\n\n类被加载后，就进入连接阶段。连接阶段就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。\n\n*   类的连接-验证\n    1）类文件的结构检查\n    2）语义检查\n    3）字节码验证\n    4）二进制兼容性的验证\n*   类的连接-准备\n    在准备阶段，java虚拟机为类的静态变量分配内存，并设置默认的初始值。例如对于以下Sample类，在准备阶段，将为int类型的静态变量a分配4个字节的内存空间，并且赋予默认值0，为long类型的静态变量b分配8个字节的内存空间，并且赋予默认值0；\n\n```\n    public class Sample{\n        private static int a=1;\n        public  static long b;\n        public  static long c;\n        static {\n            b=2;\n        }\n    }\n\n```\n\n*   初始化\n    在初始化阶段，Java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。在程序中，静态变量的初始化有两种途径：（1）在静态变量的声明处进行初始化；（2）在静态代码块中进行初始化。\n    类的初始化步骤：\n    （1）假如这个类还没有被加载和连接，那就先进行加载和连接\n    （2）假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类\n    （3）假如类中存在初始化语句，那就依次执行这些初始化语句\n    ·当java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则不适用于接口。因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定的接口的静态变量时，才会导致该接口的初始化。\n    ·调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。\n\n###### 类加载器的父亲委托机制\n\n在父亲委托机制中，各个加载器按照父子关系形成了树形结构，除了根加载器之外，其余的类加载器都有一个父加载器\n\n*   若有一个类能够成功加载Test类，那么这个类加载器被称为**定义类加载器**，所有能成功返回Class对象引用的类加载器（包括定义类加载器）称为**初始类加载器**。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190823165459877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQwNTM1NA==,size_16,color_FFFFFF,t_70)\n\n*   测试7\n\n```\n/**\n        java.lang.String是由根加载器加载，在rt.jar包下\n*/\npublic class MyTest7{\n    public static void main(String[] args){\n         public static void main(String[] args){\n            Class<?> clazz=Class.forName(\"java.lang.String\");\n            System.out.println(clazz.getClassLoader());  //返回null\n\n            Class<?> clazz2=Class.forName(\"C\");\n           System.out.println(clazz2.getClassLoader());  //输出sun.misc.Launcher$AppClassLoader@18b4aac2  其中AppClassLoader:系统应用类加载器\n         }\n    }\n}\nclass C{\n}\n\n```\n\n*   测试8\n\n```\n/**\n        调用ClassLoader的loaderClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化\n*/\npublic class MyTest8{\n    public static void main(String[] args){\n         public static void main(String[] args){\n            ClassLoader loader=ClassLoader.getSystemClassLoader();\n            Class<?> clazz1=loader.loadClass(\"CL\"); //不会初始化\n            System.out.println(clazz1);\n            System.out.println(\"-------------------\");\n\n            Class<?> clazz=Class.forName(\"CL\");\n            System.out.println(clazz);  //反射初始化\n         }\n    }\n}\nclass CL{\n    static {\n        System.out.println(\"FinalTest static block);\n    }\n}\n\n```\n\n*   测试9-12忽略\n*   测试13\n\n```\n/**\n    输出AppClassLoader、ExtClassLoader、null\n*/\npublic class MyTest13{\n    public static void main(String[] args){\n         public static void main(String[] args){\n            ClassLoader loader=ClassLoader.getSystemClassLoader();\n            System.out.println(loader);\n\n            while(loader!=null){\n                loader=loader.getParent();\n                 System.out.println(loader);\n            }\n         }\n    }\n}\n\n```\n\n*   测试14\n\n```\npublic class MyTest14{\n    public static void main(String[] args){\n         public static void main(String[] args){\n            ClassLoader loader=Thread.currentThread().getContextClassLoader();\n            System.out.println(loader);         //输出AppClassLoader\n            //下面这段没整明白什么用，先记录下来\n            String resourceName=\"com/hisense/MyTest13.class\";\n            Enumeration<URL> urls=loader.getResources(resourceName);\n            whilr(urls.hasMoreElements()){\n                URL url=urls.nextElement();\n                System.out.println(url);\n            }\n         }\n    }\n}\n\n```\n\n*   获取类加载器的途径：\n    （1）clazz.getClassLoader(); --获取当前类的加载器\n    （2）Thread.currentThread().getContextClassLoader(); --获取当前线程上下文的加载器\n    （3）ClassLoader.getSystemClassLoader(); --获取系统的加载器\n    （4）DriverManager.getCallerClassLoader(); --获取调用者的加载器\n*   ClassLoader源码分析与实例剖析–\n    ClassLoader是一个负责加载class的对象，ClassLoader类是一个抽象类，需要给出类的二进制名称，ClassLoader尝试定位或者产生一个class的数据，一个典型的策略是把二进制名字转换成文件名然后到文件系统中找到该文件。\n*   测试15\n\n```\n/**\n    对于数组，它对应的class对象不是由类加载器加载，而是由JVM在运行期动态的创建。然而对于数组类的类加载器来说，它返回的类加载器和数组内元素的类加载器是一样的。如果数组类元素是原生类，那么数组是没有类加载器的。\n*/\npublic class MyTest15{\n    public static void main(String[] args){\n            String[] strings=new String[2];\n            System.out.println(strings.getClass());\n            System.out.println(strings.getClass().getClassLoader());    //输出null\n\n            MyTest15[] mytest15=new MyTest15[2];\n            System.out.println(mytest15.getClass().getClassLoader());   //输出应用类加载器\n\n            int[] arr=new int[2];\n            System.out.println(arr.getClass().getClassLoader());        //输出null，此null非彼null\n    }\n}\n\n```\n\n并行类加载器可支持并发加载，需要在类初始化期间调用ClassLoader.registerAaParallelCapable()方法进行注册。ClassLoader类默认支持并发加载，但是其子类必须在初始化期间进行注册。\n\n*   测试16\n\n```\n/**\n    创建自定义加载器，继承ClassLoader\n*/\npublic class MyTest16 extends ClassLoader{\n    private String classLoaderName;\n    private String path；\n    private final String fileExtension=\".class\";\n\n    public MyTest16(String classLoaderName){\n        super();        //将系统类当做该类的父加载器\n        this.classLoaderName=classLoaderName;\n    }\n    public MyTest16(ClassLoader parent,String classLoaderName){\n        super(parent);      //显式指定该类的父加载器\n        this.classLoaderName=classLoaderName;\n    }\n\n   public MyTest16(ClassLoader parent){\n        super(parent);      //显式指定该类的父加载器\n    }\n\n    public void setPath(String path){\n        this.path=path;\n    }\n    @Override\n    protect Class<?> findClass(String className){\n        System.out.println(\"calssName=\"+className);\n        className=className.replace(\".\",File.separator);\n        byte[] data=loadClassData(className);\n        return defineClass(className,data,0,data.length); //define方法为父类方法\n    }\n\n    private byte[] loadClassData(String name){\n        InputStream is=null;\n        byte[] data=null;\n        ByteArrayOutputStream baos=null;\n        try{\n            is=new FileInputStream(new File(this.path+name+this.fileExtension));\n            baos=new ByteArrayOutputStream();\n            int ch;\n            while(-1!=(ch=is.read())){\n                baos.write(ch);\n            }\n            data=baos.toByteArray();\n\n        }catch(Exception e){\n        }finally{\n            is.close();\n            baos.close();\n             return data;\n        }\n    }\n    public static void test(ClassLoader classLoader){\n        Class<?> clazz=classLoader.loadClass(\"com.hisense.MyTest1\");  \n        //loadClass是父类方法，在方法内部调用findClass\n        System.out.println(clazz.hashCode());\n        Object  object=clazz.newInstance();\n        System.out.println(object);\n    }\n    public static void main(String[] args){\n        //父亲是系统类加载器，根据父类委托机制，MyTest1由系统类加载器加载了\n        MyTest16 loader1=new MyTest16(\"loader1\");       \n        test(loader1);\n\n        //仍然是系统类加载器进行加载的，因为路径正好是classpath\n        MyTest16 loader2=new MyTest16(\"loader2\");  \n        loader2.path=\"D:\\Eclipse\\workspace\\HiATMP-DDMS\\target\\classes\\\";\n        test(loader2);\n\n         //自定义的类加载器被执行，findClass方法下的输出被打印。前提是当前calsspath下不存在MyTest1.class，MyTest16的父加载器-系统类加载器会尝试从classpath中寻找MyTest1。\n        MyTest16 loader3=new MyTest16(\"loader3\");  \n        loader3.path=\"C:\\Users\\weichengjie\\Desktop\\\";\n        test(loader3);\n\n        //与3同时存在，输出两个class的hash不一致，findClass方法下的输出均被打印，原因是类加载器的命名空间问题。\n        MyTest16 loader4=new MyTest16(\"loader4\");  \n        loader4.path=\"C:\\Users\\weichengjie\\Desktop\\\";\n        test(loader4);\n\n        //将loader3作为父加载器\n        MyTest16 loader5=new MyTest16(loader3,\"loader3\");  \n        loader3.path=\"C:\\Users\\weichengjie\\Desktop\\\";\n        test(loader5);\n    }\n}\n\n```\n\n###### 命名空间\n\n*   每个类加载器都有自己的命名空间，**命名空间由该加载器及所有父加载器所加载的类构成**；\n*   在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；\n*   在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类；\n*   同一命名空间内的类是互相可见的，**非同一命名空间内的类是不可见的**；\n*   子加载器可以见到父加载器加载的类，**父加载器也不能见到子加载器加载的类**。\n\n###### 类的卸载\n\n*   当一个类被加载、连接和初始化之后，它的生命周期就开始了。当此类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，类在方法区内的数据也会被卸载。\n*   一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。\n*   由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机本身会始终引用这些加载器，而这些类加载器则会始终引用他们所加载的类的Class对象，因此这些Class对象是可触及的。\n*   由用户自定义的类加载器所加载的类是可以被卸载的。\n\n```\n/**\n    自定义类加载器加载类的卸载\n    -XX：+TraceClassUnloading\n*/\n   public static void main(String[] args){\n        MyTest16 loader2=new MyTest16(\"loader2\");  \n        loader2.path=\"D:\\Eclipse\\workspace\\HiATMP-DDMS\\target\\classes\\\";\n        test(loader2);\n        loader2=null;\n        System.gc();   //让系统去显式执行垃圾回收\n\n        输出的两个对象hashcode值不同，因为前面加载的已经被卸载了\n        loader2=new MyTest16(\"loader6\"); //  \n        test(loader2);\n   }\n\n```\n\n###### gvisualvm命令 查看当前java进程，在jdk/bin下面\n\n*   测试17\n\n```\n/**\n    创建自定义加载器，继承ClassLoader\n*/\nclass MyCat{\n    public MyCat(){\n        System.out.println(\"MyCat is loaded...\"+this.getClass().getClassLoader());\n    }\n}\n\nclass MySample{\n    public MySample(){\n        System.out.println(\"MySample is loaded...\"+this.getClass().getClassLoader());\n        new MyCat();\n    }\n}\n\npublic class MyTest17 extends ClassLoader{\n    private String classLoaderName;\n    private String path；\n    private final String fileExtension=\".class\";\n\n    public MyTest17(String classLoaderName){\n        super();        //将系统类当做该类的父加载器\n        this.classLoaderName=classLoaderName;\n    }\n    public MyTest17(ClassLoader parent,String classLoaderName){\n        super(parent);      //显式指定该类的父加载器\n        this.classLoaderName=classLoaderName;\n    }\n\n    public void setPath(String path){\n        this.path=path;\n    }\n    @Override\n    protect Class<?> findClass(String className){\n        System.out.println(\"calssName=\"+className);\n        className=className.replace(\".\",File.separator);\n        byte[] data=loadClassData(className);\n        return defineClass(className,data,0,data.length); //define方法为父类方法\n    }\n\n    private byte[] loadClassData(String name){\n        InputStream is=null;\n        byte[] data=null;\n        ByteArrayOutputStream baos=null;\n        try{\n            is=new FileInputStream(new File(this.path+name+this.fileExtension));\n            baos=new ByteArrayOutputStream();\n            int ch;\n            while(-1!=(ch=is.read())){\n                baos.write(ch);\n            }\n            data=baos.toByteArray();\n        }catch(Exception e){\n        }finally{\n            is.close();\n            baos.close();\n             return data;\n        }\n    }\n    public static void main(String[] args){\n        MyTest17 loader1=new MyTest17(\"loader1\");\n        Class<?> clazz=loader1.loadClass(\"com.hisense.MySample\");  \n        System.out.println(clazz.hashCode());\n        //如果注释掉该行，就并不会实例化MySample对象，不会加载MyCat（可能预先加载）\n        Object  object=clazz.newInstance(); //加载和实例化了MySample和MyCat\n    }\n}\n\n```\n\n测试17_1\n\n```\npublic class MyTest17_1 extends ClassLoader{\n    private String classLoaderName;\n    private String path；\n    private final String fileExtension=\".class\";\n\n    public MyTest17_1(String classLoaderName){\n        super();        //将系统类当做该类的父加载器\n        this.classLoaderName=classLoaderName;\n    }\n    public MyTest17_1(ClassLoader parent,String classLoaderName){\n        super(parent);      //显式指定该类的父加载器\n        this.classLoaderName=classLoaderName;\n    }\n\n    public void setPath(String path){\n        this.path=path;\n    }\n    @Override\n    protect Class<?> findClass(String className){\n        System.out.println(\"calssName=\"+className);\n        className=className.replace(\".\",File.separator);\n        byte[] data=loadClassData(className);\n        return defineClass(className,data,0,data.length); //define方法为父类方法\n    }\n\n    private byte[] loadClassData(String name){\n        InputStream is=null;\n        byte[] data=null;\n        ByteArrayOutputStream baos=null;\n        try{\n            is=new FileInputStream(new File(this.path+name+this.fileExtension));\n            baos=new ByteArrayOutputStream();\n            int ch;\n            while(-1!=(ch=is.read())){\n                baos.write(ch);\n            }\n            data=baos.toByteArray();\n        }catch(Exception e){\n        }finally{\n            is.close();\n            baos.close();\n             return data;\n        }\n    }\n    public static void main(String[] args){\n        MyTest17_1 loader1=new MyTest17_1(\"loader1\");\n        loader1.path=\"C:\\Users\\weichengjie\\Desktop\";\n        Class<?> clazz=loader1.loadClass(\"com.hisense.MySample\");  \n        System.out.println(clazz.hashCode());\n        //MyCat是由加载MySample的加载器去加载的：\n        如果只删除classpath下的MyCat，则会报错，NoClassDefFoundError；\n        如果只删除calsspath下的MySample，则由自定义加载器加载桌面上的MySample，由系统应用加载器加载MyCat。\n        Object  object=clazz.newInstance(); \n    }\n\n}\n\n```\n\n测试17_1_1\n\n```\n\n//修改MyCat和MySample\nclass MyCat{\n    public MyCat(){\n        System.out.println(\"MyCat is loaded...\"+this.getClass().getClassLoader());\n        System.out.println(\"from MyCat: \"+MySample.class);\n    }\n}\n\nclass MySample{\n    public MySample(){\n        System.out.println(\"MySample is loaded...\"+this.getClass().getClassLoader());\n        new MyCat();\n        System.out.println(\"from MySample :\"+ MyCat.class);\n    }\n}\n\npublic class MyTest17_1 {\n        public static void main(String[] args){\n        //修改MyCat后，仍然删除classpath下的MySample，留下MyCat，程序报错\n        //因为命名空间，父加载器找不到子加载器所加载的类，因此MyCat找不到        \n        //MySample。\n        MyTest17_1 loader1=new MyTest17_1(\"loader1\");\n        loader1.path=\"C:\\Users\\weichengjie\\Desktop\";\n        Class<?> clazz=loader1.loadClass(\"com.hisense.MySample\");  \n        System.out.println(clazz.hashCode());\n        Object  object=clazz.newInstance(); \n    }\n}\n\n```\n\n*   ```\n    关于命名空间重要说明：\n\n    ```\n\n    1.  子加载器所加载的类能够访问父加载器所加载的类；\n    2.  而父加载器所加载的类无法访问子加载器所加载的类。\n*   测试18\n\n```\npublic class MyTest18{\n    public static void main(String[] args){\n        System.out.println(System.getProperty(\"sun.boot.class.path\"));//根加载器路径\n        System.out.println(System.getProperty(\"java.ext.dirs\"));//扩展类加载器路径\n        System.out.println(System.getProperty(\"java.calss.path\"));//应用类加载器路径\n    }\n}\n\n```\n\n*   测试18_1\n\n```\npublic class MyTest18_1{\n    public static void main(String[] args){\n        MyTest16 loader1=new MyTest16(\"loader1\");\n        loader1.setPath(\"C:\\Users\\weichengjie\\Desktop\");\n\n        //把MyTest1.class文件放入到根类加载器路径中，则由根类加载器加载MyTest1\n        Class<?> clazz= loader1.loadClass(\"MyTest1\");\n\n        System.out.println(\"clazz:\"+clazz.hashCode());\n        System.out.println(\"class loader:\"+clazz.getClassLoader());\n\n    }\n}\n\n```\n\n*   测试19\n\n```\n/**\n    各加载器的路径是可以修改的，修改后会导致运行失败，ClassNotFoundExeception\n*/\npublic class MyTest19{\n    public static void main(String[] args){\n        AESKeyGenerator aesKeyGenerator=new AESKeyGenerator();\n        System.out.println(aesKeyGenerator.getClass().getClassLoader());//输出扩展类加载器\n        System.out.println(MyTest19.class.getClassLoader());//输出应用类加载器\n    }\n}\n\n```\n\n*   测试20\n\n```\n class Person{\n    private Person person;\n    public setPerson(Object object){\n        this.person=(Person)object;\n    }\n }\n\n public class MyTest20{\n    public static void main(String[] args){\n        MyTest16 loader1=new MyTest16(\"loader1\");\n        MyTest16 loader2=new MyTest16(\"loader2\");\n\n        Class<?> clazz1=load1.loadClass(\"Person\");\n        Class<?> clazz2=load1.loadClass(\"Person\");\n        //clazz1和clazz均由应用类加载器加载的，第二次不会重新加载，结果为true\n        System.out.println(clazz1==clazz2);\n\n        Object object1=clazz1.getInstance();\n        Object object2=clazz2.getInstance();\n\n        Method method=clazz1.getMethod(\"setPerson\",Object.class);\n        method.invoke(object1,object2);\n\n    }\n }\n\n```\n\n*   测试21\n\n```\n public class MyTest21{\n    public static void main(String[] args){\n        MyTest16 loader1=new MyTest16(\"loader1\");\n        MyTest16 loader2=new MyTest16(\"loader2\");\n        loader1.setPath(\"C:\\Users\\weichengjie\\Desktop\");\n        loader2.setPath(\"C:\\Users\\weichengjie\\Desktop\");\n        //删掉classpath下的Person类\n        Class<?> clazz1=load1.loadClass(\"Person\");\n        Class<?> clazz2=load1.loadClass(\"Person\");\n        //clazz1和clazz由loader1和loader2加载，结果为false\n        System.out.println(clazz1==clazz2);\n\n        Object object1=clazz1.getInstance();\n        Object object2=clazz2.getInstance();\n\n        Method method=clazz1.getMethod(\"setPerson\",Object.class);\n        //此处报错，loader1和loader2所处不用的命名空间\n        method.invoke(object1,object2);\n    }\n }\n\n```\n\n*   类加载器双亲委托模型的好处：\n    （1）可以确保Java和核心库的安全：所有的Java应用都会引用java.lang中的类，也就是说在运行期java.lang中的类会被加载到虚拟机中，如果这个加载过程如果是由自己的类加载器所加载，那么很可能就会在JVM中存在多个版本的java.lang中的类，而且这些类是相互不可见的（命名空间的作用）。借助于双亲委托机制，Java核心类库中的类的加载工作都是由启动根加载器去加载，从而确保了Java应用所使用的的都是同一个版本的Java核心类库，他们之间是相互兼容的；\n    （2）确保Java核心类库中的类不会被自定义的类所替代；\n    （3）不同的类加载器可以为相同名称的类（binary name）创建额外的命名空间。相同名称的类可以并存在Java虚拟机中，只需要用不同的类加载器去加载即可。相当于在Java虚拟机内部建立了一个又一个相互隔离的Java类空间。\n*   父亲委托机制的优点是能够提高软件系统的安全性。因此在此机制下，用户自定义的类加载器不可能加载应该由父类加载器加载的可靠类，从而防止不可靠甚至恶意的代码代替由父类加载器加载的可靠代码。例如，java.lang.Object类是由跟类加载器加载，其他任何用哪个户自定义的类加载器都不可能加载含有恶意代码的java.lang.Object类。\n*   测试22\n\n```\n public class MyTest22{\n    static{\n        System.out.println(\"MyTest22 init...\");\n    }\n    public static void main(String[] args){\n        System.out.println(MyTest22.class.getClassLoader());\n\n        System.out.println(MyTest1.class.getClassLoader());\n    }\n }\n\n```\n\n扩展类加载器只加载jar包，需要把class文件打成jar\n\n*   测试23\n\n```\n/*\n    在运行期，一个Java类是由该类的完全限定名（binary name）和用于加载该类的定义类加载器所共同决定的。如果同样名字（完全相同限定名）是由两个不同的加载器所加载，那么这些类就是不同的，即便.class文件字节码相同，并且从相同的位置加载亦如此。\n    在oracle的hotspot，系统属性sun.boot.class.path如果修改错了，则运行会出错：\n    Error occurred during initialization of VM\n    java/lang/NoClassDeFoundError: java/lang/Object\n*/\n public class MyTest23{\n    public static void main(String[] args){\n        System.out.println(System.getProperty(\"sun.boot.class.path\"));\n        System.out.println(System.getProperty(\"java.ext.dirs\"));\n        System.out.println(System.getProperty(\"java.calss.path\"));\n\n        System.out.println(ClassLoader.class.getClassLoader);\n        System.out.println(Launcher.class.getClassLoader);\n\n        //下面的系统属性指定系统类加载器，默认是AppClassLoader\n        System.out.println(System.getProperty(\"java.system.class.loader\"));\n    }\n }\n\n```\n\n*   类加载器本身也是类加载器，类加载器又是谁加载的呢？？（先有鸡还是现有蛋）\n    类加载器是由启动类加载器去加载的，启动类加载器是C++写的，内嵌在JVM中。\n*   内嵌于JVM中的启动类加载器会加载java.lang.ClassLoader以及其他的Java平台类。当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器以及系统类加载器，这块特殊的机器码叫做启动类加载器。\n*   启动类加载器并不是java类，其他的加载器都是java类。\n*   启动类加载器是特定于平台的机器指令，它负责开启整个加载过程。\n\n###### OpenJDK\n\ngrepcode.com\n源码分析\nLauncher类\nClass.forName();\n\n###### Thread.getContextClassLoader()\n\n```\n/*\n    当前类加载器(Current ClassLoader)\n        每个类都会尝试使用自己的类加载器去加载依赖的类。\n\n    线程上下文类加载器(Context ClassLoader)\n     线程上下文加载器 @ jdk1.2\n    线程类中的 getContextClassLoader() 与 setContextClassLoader(ClassLoader c)\n    如果没有通过setContextClassLoader()方法设置，线程将继承父线程的上下文类加载器，java应用运行时的初始线程的上下文类加载器是系统类加载器。该线程中运行的代码可以通过该类加载器加载类和资源。\n\n    线程上下文类加载器的作用：\n    SPI：Service Provide Interface\n    父ClassLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所制定的ClassLoader加载的类，这就改变了父加载器加载的类无法使用子加载器或是其他没有父子关系的ClassLoader加载的类的情况，即改变了双亲委托模型。\n\n    在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托父加载器进行加载。但是对于SPI来说，有些接口是Java核心库所提供的的（如JDBC），Java核心库是由启动类记载器去加载的，而这些接口的实现却来自不同的jar包（厂商提供），Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求。通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。\n*\n public class MyTest24{\n    public static void main(String[] args){\n        System.out.println(Thread.currentThread().getContextClassLoader());\n        //\n        System.out.println(Thread.class.getClassLoader());\n    }\n }\n\n```\n\n*   测试25\n\n```\n public class MyTest25 implement Runable{\n    private Thread thread；\n    public MyTest25(){\n        thread =new Thread(this);\n        thread.start();\n    }\n\n    public void run(){\n        ClassLoader classLoader=this.thread.getContextLoader();\n        this.setContextLoader(classLoader);\n\n        System.out.println(\"Class:\"+classLoader.getClass());\n        System.out.println(\"Parent:\"+classLoader.getParent().getClass());\n    }\n\n    public static void main(String[] args){\n        new MyTest25();\n    }\n }\n\n```\n\n*   测试26\n\n```\n/*\n    线程上下文类加载器的一般使用模式：（获取-使用-还原）\n        伪代码：\n        ClassLoader classLoader=Thread.currentThread().getContextLoader();\n        try{\n            Thread.currentThread().setContextLoader(targetTccl);\n            myMethod();\n        }finally{\n            Thread.currentThread().setContextLoader(classLoader);\n        }\n        在myMethod中调用Thread.currentThread().getContextLoader()做某些事情\n        ContextClassLoader的目的就是为了破坏类加载委托机制\n\n        在SPI接口的代码中，使用线程上下文类加载器就可以成功的加载到SPI的实现类。\n\n        当高层提供了统一的接口让底层去实现，同时又要在高层加载（或实例化）底层的类时，就必须通过上下文类加载器来帮助高层的ClassLoader找到并加载该类。\n\n public class MyTest26{\n    public static void main(String[] args){\n\n    //一旦加入下面此行，将使用ExtClassLoader去加载Driver.class， ExtClassLoader不会去加载classpath，因此无法找到MySql的相关驱动。\n //Thread.getCurrentThread().setContextClassLoader(MyTest26.class.getClassLoader().parent());    \n\n        ServiceLoader服务提供者，加载实现的服务\n        ServiceLoader<Driver> loader=ServiceLoader.load(Driver.class);\n        Iterator<Driver> iterator=loader.iterator();\n        while(iterator.hasNext()){\n            Driver driver=iterator.next();\n            System.out.println(\"driver:\"+driver.class+\n                                \",loader\"+driver.class.getClassLoader());\n        }\n        System.out.println(\"当前上下文加载器\"\n                    +Thread.currentThread().getContextClassLoader());\n        System.out.println(\"ServiceLoader的加载器\"\n                    +ServiceLoader.class.getClassLoader());\n    }\n }     \n*/\n\n```\n\n*   测试27\n\n```\n//跟踪代码\n public class MyTest27{\n    public static void main(String[] args){\n        Class.forName(\"com.mysql.jdbc.Driver\");\n        Connection connection=DriverManager.getConnection(\n  \"jdbc:mysql://localhost:3306//mydb\",\"user\",\"password\");\n    }\n }\n\n```\n\n*   jar hell问题以及解决办法\n    当一个类或者一个资源文件存在多个jar中，就会存在jar hell问题。\n    可通过以下代码解决问题：\n    ClassLoader calssLoader=Thread.currnetThread().getContextClassLoader();\n    String resource-“java/lang/String.class”;\n    Enumeration urls=calssLoader.getResources(resource);\n    while(urls.hasMoreElements()){\n    – URL url=urls.nextElement();\n    – System.out.prinln(url);\n    }\n",[[1568551758290,["GJX@GJXAIOU",[[1,139,"**"],[1,146,"**"]],[139,146],[139,150]]],[1568551767540,["GJX@GJXAIOU",[[1,163,"**"],[1,172,"**"]],[163,172],[163,176]]],[1568551852428,["GJX@GJXAIOU",[[1,205,"**"],[1,207,"**"]],[205,207],[205,211]]],[1568551863086,["GJX@GJXAIOU",[[1,29,"（）"]],[29,29],[31,31]]],[1568551869943,["GJX@GJXAIOU",[[1,30,"Class Lo"]],[30,30],[38,38]]],[1568551871811,["GJX@GJXAIOU",[[1,39,"ding"]],[39,39],[43,43]]],[1568551878171,["GJX@GJXAIOU",[[-1,46,"class loading"]],[59,59],[46,46]]],[1568551878707,["GJX@GJXAIOU",[[-1,47,"\n"]],[46,46],[45,45]]],[1568551879932,["GJX@GJXAIOU",[[-1,46,"\n"]],[45,45],[44,44]]],[1568551915372,["GJX@GJXAIOU",[[1,264,"**"],[1,282,"**"]],[264,282],[264,286]]],[1568552050985,[null,[[-1,38,"）"],[1,39,"a"],[1,43,"）"],[-1,45,"c"],[1,46,"*"],[-1,263,"每"],[1,266,"每"],[-1,283,"；"],[1,286,"；"]],[38,38],[287,287]]],[1568552050985,[null,[[1,38,"）"],[-1,38,"a"],[-1,43,"）"],[1,46,"c"],[-1,46,"*"],[1,264,"每"],[-1,266,"每"],[1,284,"；"],[-1,286,"；"]],[287,287],[38,38]]],[1568552026848,["GJX@GJXAIOU",[[-1,51,"j"],[1,52,"J"]],[51,55],[51,55]]],[1568552028148,["GJX@GJXAIOU",[[-1,335,"j"],[1,336,"J"]],[335,339],[335,339]]],[1568552029116,["GJX@GJXAIOU",[[-1,491,"j"],[1,492,"J"]],[491,495],[491,495]]],[1568552036132,["GJX@GJXAIOU",[[-1,1400,"j"],[1,1401,"J"]],[1400,1404],[1400,1404]]],[1568552040144,["GJX@GJXAIOU",[[-1,1772,"j"],[1,1773,"J"]],[1772,1776],[1772,1776]]],[1568552044176,["GJX@GJXAIOU",[[-1,7095,"j"],[1,7096,"J"]],[7095,7099],[7095,7099]]],[1568552045058,["GJX@GJXAIOU",[[-1,7126,"j"],[1,7127,"J"]],[7126,7130],[7126,7130]]],[1568552046025,["GJX@GJXAIOU",[[-1,7169,"j"],[1,7170,"J"]],[7169,7173],[7169,7173]]],[1568552049752,["GJX@GJXAIOU",[[-1,7530,"j"],[1,7531,"J"]],[7530,7534],[7530,7534]]],[1568552110985,[null,[[-1,38,"）"],[1,39,"a"],[1,43,"）"],[-1,45,"c"],[1,46,"*"],[-1,50,"j"],[1,52,"a"],[-1,263,"每"],[1,266,"每"],[-1,283,"；"],[1,286,"；"],[-1,334,"j"],[1,336,"a"],[-1,490,"j"],[1,492,"a"],[-1,1399,"j"],[1,1401,"a"],[-1,1771,"j"],[1,1773,"a"],[-1,7094,"j"],[1,7096,"a"],[-1,7125,"j"],[1,7127,"a"],[-1,7168,"j"],[1,7170,"a"],[-1,7529,"j"],[1,7531,"a"]],[38,38],[7532,7532]]],[1568552110985,[null,[[1,38,"）"],[-1,38,"a"],[-1,43,"）"],[1,46,"c"],[-1,46,"*"],[1,51,"j"],[-1,52,"a"],[1,264,"每"],[-1,266,"每"],[1,284,"；"],[-1,286,"；"],[1,335,"j"],[-1,336,"a"],[1,491,"j"],[-1,492,"a"],[1,1400,"j"],[-1,1401,"a"],[1,1772,"j"],[-1,1773,"a"],[1,7095,"j"],[-1,7096,"a"],[1,7126,"j"],[-1,7127,"a"],[1,7169,"j"],[-1,7170,"a"],[1,7530,"j"],[-1,7531,"a"]],[7532,7532],[38,38]]],[1568552053972,["GJX@GJXAIOU",[[-1,7687,"j"],[1,7688,"J"]],[7687,7691],[7687,7691]]],[1568552058148,["GJX@GJXAIOU",[[-1,7991,"j"],[1,7992,"J"]],[7991,7995],[7991,7995]]],[1568552060052,["GJX@GJXAIOU",[[-1,8057,"j"],[1,8058,"J"]],[8057,8061],[8057,8061]]],[1568552060735,["GJX@GJXAIOU",[[-1,8095,"j"],[1,8096,"J"]],[8095,8099],[8095,8099]]],[1568552061906,["GJX@GJXAIOU",[[-1,8344,"j"],[1,8345,"J"]],[8344,8348],[8344,8348]]],[1568552063110,["GJX@GJXAIOU",[[-1,8872,"j"],[1,8873,"J"]],[8872,8876],[8872,8876]]],[1568552170985,[null,[[-1,38,"）"],[1,39,"a"],[1,43,"）"],[-1,45,"c"],[1,46,"*"],[-1,50,"j"],[1,52,"a"],[-1,263,"每"],[1,266,"每"],[-1,283,"；"],[1,286,"；"],[-1,334,"j"],[1,336,"a"],[-1,490,"j"],[1,492,"a"],[-1,1399,"j"],[1,1401,"a"],[-1,1771,"j"],[1,1773,"a"],[-1,7094,"j"],[1,7096,"a"],[-1,7125,"j"],[1,7127,"a"],[-1,7168,"j"],[1,7170,"a"],[-1,7529,"j"],[1,7531,"a"],[-1,7686,"j"],[1,7688,"a"],[-1,7990,"j"],[1,7992,"a"],[-1,8056,"j"],[1,8058,"a"],[-1,8094,"j"],[1,8096,"a"],[-1,8343,"j"],[1,8345,"a"],[-1,8871,"j"],[1,8873,"a"]],[38,38],[8874,8874]]],[1568552170985,[null,[[1,38,"）"],[-1,38,"a"],[-1,43,"）"],[1,46,"c"],[-1,46,"*"],[1,51,"j"],[-1,52,"a"],[1,264,"每"],[-1,266,"每"],[1,284,"；"],[-1,286,"；"],[1,335,"j"],[-1,336,"a"],[1,491,"j"],[-1,492,"a"],[1,1400,"j"],[-1,1401,"a"],[1,1772,"j"],[-1,1773,"a"],[1,7095,"j"],[-1,7096,"a"],[1,7126,"j"],[-1,7127,"a"],[1,7169,"j"],[-1,7170,"a"],[1,7530,"j"],[-1,7531,"a"],[1,7687,"j"],[-1,7688,"a"],[1,7991,"j"],[-1,7992,"a"],[1,8057,"j"],[-1,8058,"a"],[1,8095,"j"],[-1,8096,"a"],[1,8344,"j"],[-1,8345,"a"],[1,8872,"j"],[-1,8873,"a"]],[8874,8874],[38,38]]],[1568552111765,["GJX@GJXAIOU",[[1,360,"`"]],[360,360],[361,361]]],[1568552114390,["GJX@GJXAIOU",[[1,374,"` "]],[374,374],[376,376]]],[1568552115877,["GJX@GJXAIOU",[[1,360," "]],[360,360],[361,361]]],[1568552154182,["GJX@GJXAIOU",[[1,504,";"]],[504,504],[505,505]]],[1568552155450,["GJX@GJXAIOU",[[-1,504,";"]],[505,505],[504,504]]],[1568552156140,["GJX@GJXAIOU",[[1,504,"；"]],[504,504],[505,505]]],[1568552230991,[null,[[-1,38,"）"],[1,39,"a"],[1,43,"）"],[-1,45,"c"],[1,46,"*"],[-1,50,"j"],[1,52,"a"],[-1,263,"每"],[1,266,"每"],[-1,283,"；"],[1,286,"；"],[-1,334,"j"],[1,336,"a"],[-1,359,"S"],[1,362,"S"],[-1,374,"方"],[1,377,"方"],[-1,494,"j"],[1,496,"a"],[-1,503,"\n"],[1,505,"\n"],[-1,1404,"j"],[1,1406,"a"],[-1,1776,"j"],[1,1778,"a"],[-1,7099,"j"],[1,7101,"a"],[-1,7130,"j"],[1,7132,"a"],[-1,7173,"j"],[1,7175,"a"],[-1,7534,"j"],[1,7536,"a"],[-1,7691,"j"],[1,7693,"a"],[-1,7995,"j"],[1,7997,"a"],[-1,8061,"j"],[1,8063,"a"],[-1,8099,"j"],[1,8101,"a"],[-1,8348,"j"],[1,8350,"a"],[-1,8876,"j"],[1,8878,"a"]],[38,38],[8879,8879]]],[1568552230991,[null,[[1,38,"）"],[-1,38,"a"],[-1,43,"）"],[1,46,"c"],[-1,46,"*"],[1,51,"j"],[-1,52,"a"],[1,264,"每"],[-1,266,"每"],[1,284,"；"],[-1,286,"；"],[1,335,"j"],[-1,336,"a"],[1,360,"S"],[-1,362,"S"],[1,375,"方"],[-1,377,"方"],[1,495,"j"],[-1,496,"a"],[1,504,"\n"],[-1,505,"\n"],[1,1405,"j"],[-1,1406,"a"],[1,1777,"j"],[-1,1778,"a"],[1,7100,"j"],[-1,7101,"a"],[1,7131,"j"],[-1,7132,"a"],[1,7174,"j"],[-1,7175,"a"],[1,7535,"j"],[-1,7536,"a"],[1,7692,"j"],[-1,7693,"a"],[1,7996,"j"],[-1,7997,"a"],[1,8062,"j"],[-1,8063,"a"],[1,8100,"j"],[-1,8101,"a"],[1,8349,"j"],[-1,8350,"a"],[1,8877,"j"],[-1,8878,"a"]],[8879,8879],[38,38]]],[1568552181181,["GJX@GJXAIOU",[[1,535,"；"]],[535,535],[536,536]]],[1568552187003,["GJX@GJXAIOU",[[-1,521," "]],[522,522],[521,521]]],[1568552191474,["GJX@GJXAIOU",[[-1,544,"："]],[545,545],[544,544]]],[1568552193390,["GJX@GJXAIOU",[[1,544,"："]],[544,544],[545,545]]],[1568552196308,["GJX@GJXAIOU",[[-1,521,": "]],[523,523],[521,521]]],[1568552197421,["GJX@GJXAIOU",[[1,521,"："]],[521,521],[522,522]]],[1568552470989,[null,[[-1,38,"）"],[1,39,"a"],[1,43,"）"],[-1,45,"c"],[1,46,"*"],[-1,50,"j"],[1,52,"a"],[-1,263,"每"],[1,266,"每"],[-1,283,"；"],[1,286,"；"],[-1,334,"j"],[1,336,"a"],[-1,359,"S"],[1,362,"S"],[-1,374,"方"],[1,377,"方"],[-1,494,"j"],[1,496,"a"],[-1,503,"\n"],[1,505,"\n"],[-1,520," "],[1,522,"确"],[-1,532,"\n"],[1,534,"\n"],[-1,543,"："],[1,544,"为"],[-1,1403,"j"],[1,1405,"a"],[-1,1775,"j"],[1,1777,"a"],[-1,7098,"j"],[1,7100,"a"],[-1,7129,"j"],[1,7131,"a"],[-1,7172,"j"],[1,7174,"a"],[-1,7533,"j"],[1,7535,"a"],[-1,7690,"j"],[1,7692,"a"],[-1,7994,"j"],[1,7996,"a"],[-1,8060,"j"],[1,8062,"a"],[-1,8098,"j"],[1,8100,"a"],[-1,8347,"j"],[1,8349,"a"],[-1,8875,"j"],[1,8877,"a"]],[38,38],[8878,8878]]],[1568552470989,[null,[[1,38,"）"],[-1,38,"a"],[-1,43,"）"],[1,46,"c"],[-1,46,"*"],[1,51,"j"],[-1,52,"a"],[1,264,"每"],[-1,266,"每"],[1,284,"；"],[-1,286,"；"],[1,335,"j"],[-1,336,"a"],[1,360,"S"],[-1,362,"S"],[1,375,"方"],[-1,377,"方"],[1,495,"j"],[-1,496,"a"],[1,504,"\n"],[-1,505,"\n"],[1,521," "],[-1,522,"确"],[1,533,"\n"],[-1,534,"\n"],[1,544,"："],[-1,544,"为"],[1,1404,"j"],[-1,1405,"a"],[1,1776,"j"],[-1,1777,"a"],[1,7099,"j"],[-1,7100,"a"],[1,7130,"j"],[-1,7131,"a"],[1,7173,"j"],[-1,7174,"a"],[1,7534,"j"],[-1,7535,"a"],[1,7691,"j"],[-1,7692,"a"],[1,7995,"j"],[-1,7996,"a"],[1,8061,"j"],[-1,8062,"a"],[1,8099,"j"],[-1,8100,"a"],[1,8348,"j"],[-1,8349,"a"],[1,8876,"j"],[-1,8877,"a"]],[8878,8878],[38,38]]],[1568552457446,["GJX@GJXAIOU",[[1,693,";"]],[693,693],[694,694]]],[1568552458834,["GJX@GJXAIOU",[[-1,693,";"]],[694,694],[693,693]]],[1568552459477,["GJX@GJXAIOU",[[1,693,";"]],[693,693],[694,694]]],[1568552460706,["GJX@GJXAIOU",[[-1,693,";"]],[694,694],[693,693]]],[1568552461343,["GJX@GJXAIOU",[[1,693,"；"]],[693,693],[694,694]]],[1568552465084,["GJX@GJXAIOU",[[1,718,"；"]],[718,718],[719,719]]],[1568553253172,[null,[[-1,38,"）"],[1,39,"a"],[1,43,"）"],[-1,45,"c"],[1,46,"*"],[-1,50,"j"],[1,52,"a"],[-1,263,"每"],[1,266,"每"],[-1,283,"；"],[1,286,"；"],[-1,334,"j"],[1,336,"a"],[-1,359,"S"],[1,362,"S"],[-1,374,"方"],[1,377,"方"],[-1,494,"j"],[1,496,"a"],[-1,503,"\n"],[1,505,"\n"],[-1,520," "],[1,522,"确"],[-1,532,"\n"],[1,534,"\n"],[-1,543,"："],[1,544,"为"],[-1,692,"\n"],[1,694,"\n"],[-1,717,"\n"],[1,719,"\n"],[-1,1405,"j"],[1,1407,"a"],[-1,1777,"j"],[1,1779,"a"],[-1,7100,"j"],[1,7102,"a"],[-1,7131,"j"],[1,7133,"a"],[-1,7174,"j"],[1,7176,"a"],[-1,7535,"j"],[1,7537,"a"],[-1,7692,"j"],[1,7694,"a"],[-1,7996,"j"],[1,7998,"a"],[-1,8062,"j"],[1,8064,"a"],[-1,8100,"j"],[1,8102,"a"],[-1,8349,"j"],[1,8351,"a"],[-1,8877,"j"],[1,8879,"a"]],[38,38],[8880,8880]]],[1568553253172,[null,[[1,38,"）"],[-1,38,"a"],[-1,43,"）"],[1,46,"c"],[-1,46,"*"],[1,51,"j"],[-1,52,"a"],[1,264,"每"],[-1,266,"每"],[1,284,"；"],[-1,286,"；"],[1,335,"j"],[-1,336,"a"],[1,360,"S"],[-1,362,"S"],[1,375,"方"],[-1,377,"方"],[1,495,"j"],[-1,496,"a"],[1,504,"\n"],[-1,505,"\n"],[1,521," "],[-1,522,"确"],[1,533,"\n"],[-1,534,"\n"],[1,544,"："],[-1,544,"为"],[1,693,"\n"],[-1,694,"\n"],[1,718,"\n"],[-1,719,"\n"],[1,1406,"j"],[-1,1407,"a"],[1,1778,"j"],[-1,1779,"a"],[1,7101,"j"],[-1,7102,"a"],[1,7132,"j"],[-1,7133,"a"],[1,7175,"j"],[-1,7176,"a"],[1,7536,"j"],[-1,7537,"a"],[1,7693,"j"],[-1,7694,"a"],[1,7997,"j"],[-1,7998,"a"],[1,8063,"j"],[-1,8064,"a"],[1,8101,"j"],[-1,8102,"a"],[1,8350,"j"],[-1,8351,"a"],[1,8878,"j"],[-1,8879,"a"]],[8880,8880],[38,38]]],[1568553214137,["GJX@GJXAIOU",[[1,1137,"\n"]],[1137,1137],[1138,1138]]],[1568553218120,["GJX@GJXAIOU",[[1,1380,"\n"]],[1380,1380],[1381,1381]]],[1568553373176,[null,[[-1,38,"）"],[1,39,"a"],[1,43,"）"],[-1,45,"c"],[1,46,"*"],[-1,50,"j"],[1,52,"a"],[-1,263,"每"],[1,266,"每"],[-1,283,"；"],[1,286,"；"],[-1,334,"j"],[1,336,"a"],[-1,359,"S"],[1,362,"S"],[-1,374,"方"],[1,377,"方"],[-1,494,"j"],[1,496,"a"],[-1,503,"\n"],[1,505,"\n"],[-1,520," "],[1,522,"确"],[-1,532,"\n"],[1,534,"\n"],[-1,543,"："],[1,544,"为"],[-1,692,"\n"],[1,694,"\n"],[-1,717,"\n"],[1,719,"\n"],[-1,1136,"*"],[1,1138,"*"],[-1,1379,"*"],[1,1381,"*"],[-1,1407,"j"],[1,1409,"a"],[-1,1779,"j"],[1,1781,"a"],[-1,7102,"j"],[1,7104,"a"],[-1,7133,"j"],[1,7135,"a"],[-1,7176,"j"],[1,7178,"a"],[-1,7537,"j"],[1,7539,"a"],[-1,7694,"j"],[1,7696,"a"],[-1,7998,"j"],[1,8000,"a"],[-1,8064,"j"],[1,8066,"a"],[-1,8102,"j"],[1,8104,"a"],[-1,8351,"j"],[1,8353,"a"],[-1,8879,"j"],[1,8881,"a"]],[38,38],[8882,8882]]],[1568553373176,[null,[[1,38,"）"],[-1,38,"a"],[-1,43,"）"],[1,46,"c"],[-1,46,"*"],[1,51,"j"],[-1,52,"a"],[1,264,"每"],[-1,266,"每"],[1,284,"；"],[-1,286,"；"],[1,335,"j"],[-1,336,"a"],[1,360,"S"],[-1,362,"S"],[1,375,"方"],[-1,377,"方"],[1,495,"j"],[-1,496,"a"],[1,504,"\n"],[-1,505,"\n"],[1,521," "],[-1,522,"确"],[1,533,"\n"],[-1,534,"\n"],[1,544,"："],[-1,544,"为"],[1,693,"\n"],[-1,694,"\n"],[1,718,"\n"],[-1,719,"\n"],[1,1137,"*"],[-1,1138,"*"],[1,1380,"*"],[-1,1381,"*"],[1,1408,"j"],[-1,1409,"a"],[1,1780,"j"],[-1,1781,"a"],[1,7103,"j"],[-1,7104,"a"],[1,7134,"j"],[-1,7135,"a"],[1,7177,"j"],[-1,7178,"a"],[1,7538,"j"],[-1,7539,"a"],[1,7695,"j"],[-1,7696,"a"],[1,7999,"j"],[-1,8000,"a"],[1,8065,"j"],[-1,8066,"a"],[1,8103,"j"],[-1,8104,"a"],[1,8352,"j"],[-1,8353,"a"],[1,8880,"j"],[-1,8881,"a"]],[8882,8882],[38,38]]],[1568553345993,["GJX@GJXAIOU",[[1,1142,"**"],[1,1146,"**"]],[1142,1146],[1142,1150]]],[1568553351258,["GJX@GJXAIOU",[[1,1389,"**"],[1,1393,"**"]],[1389,1393],[1389,1397]]],[1568553363606,["GJX@GJXAIOU",[[1,1265,"`"]],[1265,1265],[1266,1266]]],[1568553365940,["GJX@GJXAIOU",[[1,1296,"`"]],[1296,1296],[1297,1297]]]],null,"GJX@GJXAIOU"]]}