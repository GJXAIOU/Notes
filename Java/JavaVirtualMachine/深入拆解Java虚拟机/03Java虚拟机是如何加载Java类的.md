# 03 \| Java虚拟机是如何加载Java类的?

作者: 郑雨迪

完成时间:

总结时间:



<audio><source src="https://static001.geekbang.org/resource/audio/fa/76/fa41d2233af9f067cba722170d36f976.mp3" type="audio/mpeg"></audio>

听我的意大利同事说，他们那边有个习俗，就是父亲要帮儿子盖栋房子。

这事要放在以前还挺简单，亲朋好友搭把手，盖个小砖房就可以住人了。现在呢，整个过程要耗费好久的时间。首先你要请建筑师出个方案，然后去市政部门报备、验证，通过后才可以开始盖房子。盖好房子还要装修，之后才能住人。

盖房子这个事，和Java虚拟机中的类加载还是挺像的。从class文件到内存中的类，按先后顺序需要经过加载、链接以及初始化三大步骤。其中，链接过程中同样需要验证；而内存中的类没有经过初始化，同样不能使用。那么，是否所有的Java类都需要经过这几步呢？

我们知道Java语言的类型可以分为两大类：基本类型（primitive types）和引用类型（reference types）。在上一篇中，我已经详细介绍过了Java的基本类型，它们是由Java虚拟机预先定义好的。

至于另一大类引用类型，Java将其细分为四种：类、接口、数组类和泛型参数。由于泛型参数会在编译过程中被擦除（我会在专栏的第二部分详细介绍），因此Java虚拟机实际上只有前三种。在类、接口和数组类中，数组类是由Java虚拟机直接生成的，其他两种则有对应的字节流。

说到字节流，最常见的形式要属由Java编译器生成的class文件。除此之外，我们也可以在程序内部直接生成，或者从网络中获取（例如网页中内嵌的小程序Java applet）字节流。这些不同形式的字节流，都会被加载到Java虚拟机中，成为类或接口。为了叙述方便，下面我就用“类”来统称它们。

无论是直接生成的数组类，还是加载的类，Java虚拟机都需要对其进行链接和初始化。接下来，我会详细给你介绍一下每个步骤具体都在干些什么。

## 加载

加载，是指查找字节流，并且据此创建类的过程。前面提到，对于数组类来说，它并没有对应的字节流，而是由Java虚拟机直接生成的。对于其他的类来说，Java虚拟机则需要借助类加载器来完成查找字节流的过程。

以盖房子为例，村里的Tony要盖个房子，那么按照流程他得先找个建筑师，跟他说想要设计一个房型，比如说“一房、一厅、四卫”。你或许已经听出来了，这里的房型相当于类，而建筑师，就相当于类加载器。

村里有许多建筑师，他们等级森严，但有着共同的祖师爷，叫启动类加载器（bootstrap class loader）。启动类加载器是由C++实现的，没有对应的Java对象，因此在Java中只能用null来指代。换句话说，祖师爷不喜欢像Tony这样的小角色来打扰他，所以谁也没有祖师爷的联系方式。

除了启动类加载器之外，其他的类加载器都是java.lang.ClassLoader的子类，因此有对应的Java对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至Java虚拟机中，方能执行类加载。

村里的建筑师有一个潜规则，就是接到单子自己不能着手干，得先给师傅过过目。师傅不接手的情况下，才能自己来。在Java虚拟机中，这个潜规则有个特别的名字，叫双亲委派模型。每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。

在Java 9之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在JRE的lib目录下jar包中的类（以及由虚拟机参数-Xbootclasspath指定的类）。除了启动类加载器之外，另外两个重要的类加载器是扩展类加载器（extension class loader）和应用类加载器（application class loader），均由Java核心类库提供。

扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如存放在JRE的lib/ext目录下jar包中的类（以及由系统变量java.ext.dirs指定的类）。

应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数-cp/-classpath、系统变量java.class.path或环境变量CLASSPATH所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。

Java 9引入了模块系统，并且略微更改了上述的类加载器[1](<https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-A868D0B9-026F-4D46-B979-901834343F9E>)。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE中除了少数几个关键模块，比如说java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。

除了由Java核心类库提供的类加载器外，我们还可以加入自定义的类加载器，来实现特殊的加载方式。举例来说，我们可以对class文件进行加密，加载时再利用自定义的类加载器对其解密。

除了加载功能之外，类加载器还提供了命名空间的作用。这个很好理解，打个比方，咱们这个村不讲究版权，如果你剽窃了另一个建筑师的设计作品，那么只要你标上自己的名字，这两个房型就是不同的。

在Java虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。

## 链接

链接，是指将创建成的类合并至Java虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。

验证阶段的目的，在于确保被加载类能够满足Java虚拟机的约束条件。这就好比Tony需要将设计好的房型提交给市政部门审核。只有当审核通过，才能继续下面的建造工作。

通常而言，Java编译器生成的类文件必然满足Java虚拟机的约束条件。因此，这部分我留到讲解字节码注入时再详细介绍。

准备阶段的目的，则是为被加载类的静态字段分配内存。Java代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。过了这个阶段，咱们算是盖好了毛坯房。虽然结构已经完整，但是在没有装修之前是不能住人的。

除了分配内存外，部分Java虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。

在class文件被加载至Java虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。

举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。

解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）

如果将这段话放在盖房子的语境下，那么符号引用就好比“Tony的房子”这种说法，不管它存在不存在，我们都可以用这种说法来指代Tony的房子。实际引用则好比实际的通讯地址，如果我们想要与Tony通信，则需要启动盖房子的过程。

Java虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。

## 初始化

在Java代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。

如果直接赋值的静态字段被final所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被Java编译器标记成常量值（ConstantValue），其初始化直接由Java虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被Java编译器置于同一方法中，并把它命名为< clinit >。

类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行< clinit >方法的过程。Java虚拟机会通过加锁来确保类的< clinit >方法仅被执行一次。

只有当初始化完成之后，类才正式成为可执行的状态。这放在我们盖房子的例子中就是，只有当房子装修过后，Tony才能真正地住进去。

那么，类的初始化何时会被触发呢？JVM规范枚举了下述多种触发情况：

1. 当虚拟机启动时，初始化用户指定的主类；
2. 当遇到用以新建目标类实例的new指令时，初始化new指令的目标类；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7. 使用反射API对某个类进行反射调用时，初始化这个类；
8. 当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。

```java
public class Singleton {
  private Singleton() {}
  private static class LazyHolder {
    static final Singleton INSTANCE = new Singleton();
  }
  public static Singleton getInstance() {
    return LazyHolder.INSTANCE;
  }
}
```

我在文章中贴了一段代码，这段代码是在著名的单例延迟初始化例子中[2](<https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom>)，只有当调用Singleton.getInstance时，程序才会访问LazyHolder.INSTANCE，才会触发对LazyHolder的初始化（对应第4种情况），继而新建一个Singleton的实例。

由于类初始化是线程安全的，并且仅被执行一次，因此程序可以确保多线程环境下有且仅有一个Singleton实例。

## 总结与实践

今天我介绍了Java虚拟机将字节流转化为Java类的过程。这个过程可分为加载、链接以及初始化三大步骤。

加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在Java虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。

链接，是指将创建成的类合并至Java虚拟机中，使之能够执行的过程。链接还分验证、准备和解析三个阶段。其中，解析阶段为非必须的。

初始化，则是为标记为常量值的字段赋值，以及执行< clinit >方法的过程。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。

今天的实践环节，你可以来验证一下本篇中的理论知识。

通过JVM参数-verbose:class来打印类加载的先后顺序，并且在LazyHolder的初始化方法中打印特定字样。在命令行中运行下述指令（不包含提示符$）：

```
$ echo '
public class Singleton {
  private Singleton() {}
  private static class LazyHolder {
    static final Singleton INSTANCE = new Singleton();
    static {
      System.out.println("LazyHolder.<clinit>");
    }
  }
  public static Object getInstance(boolean flag) {
    if (flag) return new LazyHolder[2];
    return LazyHolder.INSTANCE;
  }
  public static void main(String[] args) {
    getInstance(true);
    System.out.println("----");
    getInstance(false);
  }
}' > Singleton.java
$ javac Singleton.java
$ java -verbose:class Singleton
```

问题1：新建数组（第11行）会导致LazyHolder的加载吗？会导致它的初始化吗？

在命令行中运行下述指令（不包含提示符$）：

```
$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Singleton\$LazyHolder.class > Singleton\$LazyHolder.jasm.1
$ awk 'NR==1,/stack 1/{sub(/stack 1/, "stack 0")} 1' Singleton\$LazyHolder.jasm.1 > Singleton\$LazyHolder.jasm
$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Singleton\$LazyHolder.jasm
$ java -verbose:class Singleton
```

问题2：新建数组会导致LazyHolder的链接吗？



精选留言(159)

笨鸟
1.虚拟机必须知道（加载）有这个类，才能创建这个类的数组（容器），但是这个类并没有被使用到（没有达到初始化的条件），所以不会初始化。
2.新建数组的时候并不是要使用这个类（只是定义了放这个类的容器），所以不会被链接，调用getInstance(false)的时候约等于告诉虚拟机，我要使用这个类了，你把这个类造好（链接），然后把static修饰的字符赋予变量（初始化）。
老师看看理解对不对，指点一下。
作者回复: 对的！

2018-10-18

曲东方
1. 新建数组会加载元素类LazyHolder；不会初始化元素类

2. 新建数组不会链接元素类LazyHolder；在getInstance(false)时才真正链接和初始化
-----------------
链接的第一步：验证字节码，awk把字节码改为不符合jvm规范
初始化调用<clinit>(即class init)



PS:好像二个问题包含了第一个问题的答案
作者回复: 多谢指出！

2018-07-25

迈克擂
学习了！可以的话希望老师能附上一些图解，便于更理解
2018-07-29

akka
-XX：+TraceClassLoading 可以看到类加载过程
2018-07-27

mover
到目前为止，讲解的内容没有超出周志明老师的 深入理解JAVA虚拟机这本书的内容，老师可以讲解的更深入一点吗？可以介绍一下类加载后在meta区的大概布局吗？class类对象与meta区的类数据结构是什么关系？当我们创建类，使用类时，类实例，类对象，meta区类数据结构是如何交互的？
作者回复: 谢谢你的建议！前几章不好搞太难，希望后面能够满足你的需求

2018-07-25

佑儿
总结：
jvm加载java类就是将字节流(如.class文件，网络传输的字节流)文件加入到内存中的过程，分为以下三步：加载、链接、初始化

加载：查找字节流并且据此创建类的过程，每一种类加载器加载一部分类
        加载规则：双亲委派机制
        类的唯一性：类加载器名称+类全限定名称
        类加载器：
        启动类加载器：无对应的java对象，负责加载最基础的类。如jre/lib下的类以及有虚拟机参数-Xbootclasspath指定的类，
        扩展类加载器：有对应的java对象，父类启动类加载器,负责加载jre/ext下类以及系统变量java.ext.dirs指定的类
                              该类加载器被启动类加载器加载之后方能加载其他类，
                               
        应用类加载器：有对应的java对象，父类是扩展类加载器，负责加载应用程序路径下的类/classpath、系统变量java.class.path或者环境变量classpath指定的类。

链接：验证、准备、解析
        验证：在于确定被加载类满足jvm的约束条件。
       准备：为被加载类的静态字段分配内存。
       解析：将符号引用解析为实际引用，
                符号引用是在编译阶段由编译器生成，包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型

初始化：为标记为常量值的字段(基本类型或字符串且被修饰为final)赋值，以及执行<clinit>方法(其他赋值操作和静态代码块)
             类的初始化过程是线程安全的，并且只能被初始化一次。jvm会通过加锁来保证<clinit>方法仅被执行一次
             初始化的时机（对一个类的主动引用）
               

被动引用并不会引发类的初始化，如引用类的静态常量，引用父类的静态字段不会初始化子类，数组定义来引用类不会导致初始化。
2019-05-16

韩恩同
忍着瞌睡把内容看完了。
全是复习了一遍。
作者对 类加载中的 链接(验证、准备、解析)讲解不太到位吧？
另外，对一个的初始化发生在第一次主动使用该类时，作者列出的几种情况都属于主动使用类。感觉应该有被动使用的举例，并告知大家这样做是不会执行初始化的。
作者回复: 多谢建议！

2018-07-27

conce2018
为什么叫双亲委派呀，明明只给了父类加载应该是单亲呀
作者回复: 其实我也有这个疑问，英文中为parent不带s，照理应该翻译为单亲。但既然约定俗成翻译为双亲，就只好这样叫啦

2018-09-25

熊猫酒仙
有几个疑问，请老师指点迷津。
1.扩展类加载器的父类，是启动类加载器，而后者是C++实现的，java继承C++的类？不大能理解。
2.虚方法的概念在C++中有了解过，java中的虚方法该如何定义呢？以前没接触过java虚方法的概念
3.我以前的理解是，有一个零值(0/null)初始化，针对于类的静态成员变量，如果是final修饰的静态成员变量，也就是常量，是初始化为代码中指定的值比如10。非final修饰的静态成员变量，在clint执行过程中赋值为代码中指定的值，请问老师是这样的吗？
作者回复: 1. 可能我翻译得有点瑕疵，导致了你的误解。这里我指的是扩展器类的 父-类加载器，而不是父类-(加载器)。
2. Java中所有的非私有实例方法，都算是虚方法。调用这些方法的指令，也区分直接调用和虚调用。下一篇我会讲到。
3. 赞一个。被final修饰的静态成员变量，如果不是基本类型或者字符串，也会放在clinit 来做。

2018-07-25

Skysper
每次new一个类都是一次初始化吧？加载和链接以后生成的是什么样的数据结构？存储在什么地方？
作者回复: 类的初始化只会发生一次，你可能指的是实例的初始化？

JVM并不会直接使用.class文件，类加载链接的目的就是在JVM中创建相应的类结构，会存储在元空间(我之前用的老说法”方法区”，感谢某同学指出)。

2018-07-25

Geek_dde3ac
请问有什么办法或者工具可以看到类加载的这些过程呢？
2018-07-25

Super丶X
老师，你说可以通过不同的类加载器加载同一个类得到类的不同版本，我有个疑问，类是通过包名加类名来使用的，那怎么样区分不同的类加载器加载的类呢？
作者回复: 你指的是在写代码的时候如何区分对吧？我认为没法区分。如果你有一个类的两个不同版本，而且它们不兼容，那么编译时指向哪个，就按哪个来编译。也就是说，如果要同时使用两个版本，那么你需要分开编译。

2018-07-25

小蛋壳
加载阶段都加载哪些类呢，那么多类，全部加载吗？
作者回复: 加载阶段是针对单个类的，一般用到的类才会被加载。大部分情况下，不同类的加载阶段是不同的。

2018-07-26

L.B.Q.Y
从大的方面讲，类加载的结果是把一段字节流变换成Class结构并写方法区，实际写方法区具体是发生在加载、链接、初始化的哪个环节呢？
作者回复: 在加载阶段就已经生成class结构了，所以我认为应该已经写入了方法区，只是被标记为未链接而暂不能使用。

2018-07-25

Geek_436873
看完了整篇文章，其实我还是没搞明白，加载-链接-初始化 这三个步骤的关系。首先我理解加载就是把编译好的.class文件读如jvm内存，存放至方法区。至于链接，我觉得暂时不用去深究。初始化则是比较常见的，我们去new操作或者访问静态变量时会触发类的初始化操作。我的问题是：1.什么时候触发类加载？2:加载-链接-初始化一定是三者都发生的吗，会存在某个累只加载，不链接，不初始化的情况吗
2018-12-22

scutware
您在评论回复说.class在加载后已经写入方法区（元空间），但是我理解在方法区里类代码的方法调用应该是实际的调用地址吧？而取得实际调用地址不是在链接阶段吗？这里不太理解，求解答～
作者回复: 链接时取得的不是被加载类的地址，而且被加载类所调用的其它方法的地址

2018-07-26

airfly
没明白java虚拟机和类加载器的关系,
2019-02-28

刹那间的永恒
老师，您好！关于classLoader有点疑问，在看源码时发现AppClassLoader和ExtClassLoader都继承自URLClassLoader，这个URLClassLoader是做什么的？另外“委派”是如何实现的了？在AppClassLoader中也没看到ExtClassLoader。
2018-10-23

Hero
你该加油了，期待接下来精彩……
2018-07-26

志远
请问，关于双亲委派类加载器的情况，与周志明的深入理解java虚拟机矛盾啊，到底听哪个呢？周志明书籍中lib/ext是由扩展类加载器加载，你这里是启动类加载器加载，到底哪个是正确的呢？
作者回复: lib/ext是由扩展类加载器加载的，我文中应该也是这样讲的。

2018-07-25

funnyx
有两个问题想问一下老师，在类加载的过程中，有一个委派模式，这里严格来说应该不是使用的继承方式，应该是组合。另一个就是类中的静态字段，如果没有被jvm标记为常量，那么这部分内存是如何分配的？
作者回复: 前面那个问题，你说的没错。这么说的原因是它委派的那个对象名字叫parent。可能翻译为双亲比较不容易混淆。

后面那个问题，JVM都会分配内存的，只是初始化的过程不一样，一个是JVM直接赋值，一个是在clinit方法中赋值

2018-07-25

陈树义
新建数组不会导致初始化，但是否会链接不清楚。不知道有什么方式可以验证？
作者回复: 第二个实践有介绍验证的方法。简单的说就是通过生成一个不能通过链接的验证阶段的类。

2018-07-25

Eric
关于新建数组是否会链接，第二个实践生成一个不能通过链接的验证阶段的类，但是我不明白怎么确定它是在new LazyHolder[2]时验证还是在return LazyHolder.INSTANCE时验证的？运行了指令后得到：
Error: A JNI error has occurred, please check your installation and try again
Exception in thread "main" java.lang.VerifyError: Operand stack overflow
Exception Details:
  Location:
    Singleton.<init>()V @0: aload_0
可不可以这样理解：新建数组new LazyHolder[2]不需要初始化，只有return LazyHolder.INSTANCE才会导致初始化。而验证不通过的地方为初始化部分，所以，可以认为新建数组不会链接元素类LazyHolder；在getInstance(false)时才真正链接和初始化。
2018-09-24

Nu11PointerEx
老师，根据《深入理解Java虚拟机》一书的描述，被static final修饰的常量字段的赋值行为应该发生在"准备"阶段，但文中说是在初始化阶段赋值，与我理解的有出入，麻烦老师解答下
作者回复: 我参照的是Java 10虚拟机规范5.5讲初始化的那一小节，按道理虚拟机实现都应该遵守这个的。有可能是规范变动了？

从工程实现上讲，在准备阶段赋值常量字段和在初始化阶段赋值没有太大影响。

2018-07-25

大熊
老师你好，

问题1的命令修改的是<init>里面的操作数栈大小为0，执行java -verbose:class Singleton <init>里抛出Exceeded max stack size的异常；

我的疑问是，LazyHolder.INSTANCE应该是触发内部类LazyHolder的加载（其中的初始化步骤会执行<clinit>）；因为没有new LazyHolder()应该不会执行它的构造方法<init>啊，怎么会抛出异常呢？
2020-11-20

liuyitao
clinit执行时的锁，是什么锁，跟synchronized一样吗？
作者回复: 虚拟机内部的锁，和synchronized 不一样

2018-10-23

hiwon
你好，请问一下单例模式的double check变量一定要加volatile来确保指令重排问题？在类的创建到初始化是原子操作？
2021-01-17

xmeng

总结：
jvm加载java类就是将字节流(如.class文件，网络传输的字节流)文件加入到内存中的过程，分为以下三步：加载、链接、初始化

加载：查找字节流并且据此创建类的过程，每一种类加载器加载一部分类
        加载规则：双亲委派机制
        类的唯一性：类加载器名称+类全限定名称
        类加载器：
        启动类加载器：无对应的java对象，负责加载最基础的类。如jre/lib下的类以及有虚拟机参数-Xbootclasspath指定的类，
        扩展类加载器：有对应的java对象，父类启动类加载器,负责加载jre/ext下类以及系统变量java.ext.dirs指定的类
                              该类加载器被启动类加载器加载之后方能加载其他类，
                               
        应用类加载器：有对应的java对象，父类是扩展类加载器，负责加载应用程序路径下的类/classpath、系统变量java.class.path或者环境变量classpath指定的类。

链接：验证、准备、解析
        验证：在于确定被加载类满足jvm的约束条件。
       准备：为被加载类的静态字段分配内存。
       解析：将符号引用解析为实际引用，
                符号引用是在编译阶段由编译器生成，包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型

初始化：为标记为常量值的字段(基本类型或字符串且被修饰为final)赋值，以及执行<clinit>方法(其他赋值操作和静态代码块)
             类的初始化过程是线程安全的，并且只能被初始化一次。jvm会通过加锁来保证<clinit>方法仅被执行一次
             初始化的时机（对一个类的主动引用）
               

被动引用并不会引发类的初始化，如引用类的静态常量，引用父类的静态字段不会初始化子类，数组定义来引用类不会导致初始化。
2020-08-18

天天向上
文中说：类加载的最后一步是初始化，便是为标记为常量值的字段赋值...
我在《深入理解java虚拟机 第2版》中的第220页，看到的是，常量在准备阶段就被赋上了它所指定的值。
2020-05-03

麦香小瑜儿
有个疑问，按照周志明的《深入理解Java虚拟机》的类加载一章提到的“被final修饰，已在编译期把结果放入常量池的静态字段除外”，类或者接口的静态常量不会触发类加载，作者介绍初始化阶段却说“类加载的最后一步是初始化，便是为标记为常量值的字段赋值“，这里意思是为常量字段赋值这个动作是cinit方法进行的，两个观点似乎有冲突。
2019-02-17

郁柏
不同类加载器加载的类，不影响它们之前互相调用吧？ 同一类存在不同的版本，这个有啥实际应用？
2018-09-30

一个坏人
老师好，请教一个问题。"在加载阶段就已经生成class结构了，所以我认为应该已经写入了方法区，只是被标记为未链接而暂不能使用。" 如果验证失败怎么办？
作者回复: 验证失败虚拟机会报错退出。

2018-08-09

Geek_135148
老师 你好，你说的这些是一个类的加载流程，那什么样的类会经过这套流程呢？什么样的类会被加载呢？
2018-07-31

沉淀的梦想
触发类初始化条件的第八条(“当初次调用MethodHandle”实例时)，这里的MethodHandle是什么意思呢？
作者回复: 是Java8引入的一个新概念，相当于方法指针，后面我会有一篇专门解释

2018-07-27

L.B.Q.Y
如果class结构是加载阶段写入方法区的，那么如果后面的链接阶段验证失败的话，还需要把已经写入方法区的class擦除是吗
2018-07-25

NEO🍋
老师
疑问1.大型应用中利用 不同的类加载器加载的类不同 的特性，可否具体举例是如何应用？在什么场景下应用
疑问2.双亲委派交给父类先查找 但是父类具体是怎么查找的？用的什么算法还是什么设定找到的？
2018-07-25

L.B.Q.Y
应该是链接阶段是吗？
2018-07-25

郑杰
”除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为”   这一句是不是没写完啊，应该加上 cinit方法吧
作者回复: 把它命名为 小于号clinit大于号。
应该是显示问题，猜测某些浏览器给识别成标签了。

2018-07-25

左岸🌸开
“除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为”。请问一下这里是命名是什么？
作者回复: 小于号 clinit 大于号

我手机上看没问题，会不会哪个浏览器给识别成标签了？

2018-07-25

以我之姓贯你之名
延迟初始化单例那个是因为LazyHolder是静态私有内部类的关系吗 如果我把LazyHolder作为一个public class是不是就不一样了
作者回复: 还是一样的。你可以改下课后实践的代码，自己试一试。

2018-07-25

herish
感兴趣的朋友可以阅读一下我整理的文章笔记：https://juejin.cn/post/7066261471381946382
2022-03-23

山海
老师，有几个问题还是不太清楚，请老师指点。 
新建数组会导致 类加载吗？如果加载，会导致它的链接，会导致它的初始化吗。 加载、链接、初始化他们没有严格的上下文关系么，也就是加载不一定链接，链接不一定初始化，他们都会在满足特定条件才会执行么？

在链接过程的“准备阶段”是给静态变量分配内存，静态字段并没有初始化，分配的内存到底有什么作用？

验证类所需要满足的约束条件到底是哪些？
2021-09-29

技术无止境
学习了，老师讲的很好。
2021-09-11

Lin
 想问一下cms垃圾回收器处理漏标用的为什么是增量更新g1用的却是satb 一直没有得到特别标准的答案
2021-09-04

zhmacn
郑老师，您好，我想了解下Classloader中的defineClass和resolveClass方法分别在处理类加载的那个阶段
看jdk的注释，感觉resolveClass是用来链接的
我自定义2个包含错误的类字节码，
一个包含两个完全相同的方法，
一个包含子类覆写父类final方法的类
两个类加载报错都在defineClass阶段，请问defineClass方法会对类进行链接吗
2021-08-15

Geek_0f2617
加载器的类型，SPI 这些怎么都没涉及
2021-08-01

八九
老师您好，我做了三次试验，发现结果和您说的都不一致，麻烦您帮我看下。
1.按示例代码，查看类加载顺序，打印结果：
[Loaded Singleton$LazyHolder from file:/E:/dev_src/playjvm/src/]
----
LazyHolder.

将源代码改为不符合jvm规范后，打印结果：
[Loaded java.util.IdentityHashMap$KeySet from D:\worktools\jdk\jdk1.8.0_131\jre\lib\rt.jar]
java.lang.VerifyError: Operand stack overflow
Exception Details:
  Location:
    Singleton.<init>()V @0: aload_0
  Reason:
    Exceeded max stack size.
  Current Frame:
    bci: @0
    flags: { flagThisUninit }
    locals: { uninitializedThis }
    stack: { }
  Bytecode:
    0x0000000: 2ab7 0008 b1

        at java.lang.Class.getDeclaredMethods0(Native Method)
        at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)
        at java.lang.Class.privateGetMethodRecursive(Class.java:3048)
        at java.lang.Class.getMethod0(Class.java:3018)
        at java.lang.Class.getMethod(Class.java:1784)
        at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544)
        at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)
[Loaded java.lang.Shutdown from D:\worktools\jdk\jdk1.8.0_131\jre\lib\rt.jar]


2.注释 getInstance(true); 查看类加载顺序，打印结果：
----
[Loaded Singleton$LazyHolder from file:/E:/dev_src/playjvm/src/]
LazyHolder.

将源代码改为不符合jvm规范后，打印结果：【与示例代码的相同】
[Loaded java.util.IdentityHashMap$KeySet from D:\worktools\jdk\jdk1.8.0_131\jre\lib\rt.jar]
java.lang.VerifyError: Operand stack overflow


3.注释 getInstance(false); 查看类加载顺序，打印结果：
[Loaded Singleton$LazyHolder from file:/E:/dev_src/playjvm/src/]
----

将源代码改为不符合jvm规范后，打印结果：【与示例代码的相同】
[Loaded java.util.IdentityHashMap$KeySet from D:\worktools\jdk\jdk1.8.0_131\jre\lib\rt.jar]
java.lang.VerifyError: Operand stack overflow


总结就是：getInstance(true); 和 getInstance(false); 都会链接元素类。 
2021-01-27

八九
老师您好，实践环节我有个问题。根据东方大佬的评论，总结是下面这样：
getInstance(true)只会加载元素类，不会链接和初始化。
getInstance(false)会加载、链接和初始化元素类。
可是我实际操作，发现将字节码改成不符合jvm规范后，打印加载顺序，结果为：java.lang.VerifyError:operand stack overflow，但是没有看到“----"。
我理解是 如果链接中的验证是getInstance(false);触发的，那么应该打印“----”，麻烦老师帮我看一下，是我弄错了吗？
2021-01-27

coderkeep
类加载过程：加载，链接，初始化

构建数组只会触发类加载过程，即JVM只需要知道这个类是什么。

初始化某个类的时候会触发加载链接初始化全过程，因为此时需要调用该类的数据
2020-12-21

~~
类加载器是通过类的全限定名（或者说绝对路径）来找到一个class文件的:
1. 启动类加载器加载的是jre和jre/lib目录下的核心库
2.扩展类加载器加载的是jre/lib/ext目录下的扩展包
3.AppClassLoader加载器加载当前java工程的bin目录下的class文件

运行Java程序, sun.misc.Launcher类就是虚拟机执行的第一段Java代码.
在这个类里,拓展类加载器和应用类加载器通过调用自己的静态方法拿到自己的实例.

自定义加载器的的默认父加载器是应用类加载器
应用类加载器的父加载器是拓展类加载器
拓展类加载器的父类是启动类加载器

实际加载类时,类加载器会通过类的绝对路径尝试从缓存里查找,如果没有找到,会交给父加载器去查找,一直找到启动类加载器.如果父加载器没有,则会返回给下一级的类加载器加载,如果底层的类加载器也没有找到,就会抛出异常.
这样(双亲委派模型)可以保证在你写了和Java核心类重名的类时,你这个类不会被加载,只有真正的核心类会被加载,保证了类的全局唯一性.
2020-11-12

Geek_03a866
问题：数组类为什么由java虚拟机直接生成，好处是什么
2020-11-05

大龙
自定义类加载器能解决多版本jar的问题吗，内部会不会存在类加载器混乱的情况。类加载器加载了两个不同版本的类，但是我们知道我们加载类也有自己的继承关系，继承关系中的类也有其继承关系。并且我们加载的这两个不同版本的类，实用到的类版本也不是相同的。针对上述问题，在类和对象的正常操作中能不能保证其不会越出自己的版本。
最后再提两个猜想，一是引入得jar中存在Thread.currentThread.classloader的问题，通过在发调用前/后进行线程持有的classloader进行修改/恢复，应该可以解决问题。二是我们知道类加载器加载类会询问父级，那么类的相关类或父类也存在版本冲突的情况下，会出问题吗
2020-10-22

水果刀
“加载，是指查找字节流，并且据此创建类的过程” 问：有点迷惑，这个创建类具体是指什么呢？将class文件放入java内存的方法区吗？
2020-08-16

NullPointer
单例模式那里有点疑问，class非基本类型与string理论上应该在同步方法cinit执行，有且执行一次，为什么还要加final？
2020-07-29

行道有德
请问一下老师，双亲委派模式的作用是什么？
2020-07-16

鼠里鼠气
⭐️JAVA虚拟机对于程序员来说就是一台真正的机器，我们不需要管程序在真实机器上到底是怎么运行的，我们只需要关注程序在java虚拟机上是怎么运行的就行了。
不知道对不对？
2020-07-01

Andot
1，会加载，因为要找到那个类，没有使用，所以不会初始化
2，当flag为false的是，创建这个类对象，所以要使用这个类，所以进行了链接
2020-07-01

li_geekbang
C语言源代码生成可执行文件的过程中会有链接这一步。在后面执行程序的时候，也会有加载和链接这一步。
2020-06-29

Geek_85fa88
老师请教个问题，元数据区的class结构和java中的Class对象是什么关系，Class对象何时初始化你总结得很清楚，那我想问的是，Class对象初始化后的存储位置在哪呢，有的说在堆，有的说在方法区，望能指点迷津。
在此先谢谢。
2020-06-26

SDZ
老师，我有个知识点上的疑问，这里的解析阶段的符号引用替换为实际引用，是将字节码中的符号引用指向运行时常量池的实际地址信息吗？
2020-06-07

宿臾洛城
加载类数组的时候，因为数组是个容器，仅仅是存放了对象，JVM会去寻找这个类，所以需要先初始化。
但是在加载后并没有使用这个类，所以不会去链接这个类，因为链接的定义是需要执行这个类。
而如果需要初始化的话是需要满足JVM的初始化8条规范里面的一条，只有调用其静态方法才是满足了JVM的第三条，所以那个时候才会初始化
2020-06-07

半夏

老师，有个问题一直没弄明白，类加载过程生成的Class对象是在方法区中还是在堆中呢？网上有的说在方法区，有的说在堆，有点糊涂。
2020-05-18

keygrocery
>类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。Java 虚>拟机会通过加锁来确保类的 < clinit > 方法仅被执行一次。

调用常量值，不会触发初始化，因为没有执行 <clinit> 方法
```java
public class Test {
	
	
	public static void main(String[] args) throws Exception {
		System.out.println(TestInit.i);
	}
}

class TestInit {
	
	public static final String i = "do not trigger init";
	
	static {
		System.out.println("TestInit, inited");
	}
}
```
2020-05-15

wesley
请教一下，这里Jvm加载类最后得到的是什么东西？是Spring里的BeanDefinition嘛？
2020-05-12

见南山
加载类的触发条件有一条是new对象时，因此，数组的创建会触发加载lazy这个类，但是此时并没有使用这个类，只有真正使用时才会链接和初始化lazy类。
2020-04-29

梦倚栏杆
java -verbose:怎么看出是否链接
链接，是指将创建成的类合并至 Java 虚拟机中 没理解，这步操作有什么可视化的方式吗？
2020-04-04

梦倚栏杆
问题1有Singleton$LazyHolder 没有LazyHolder.<clinit> 会加载不会初始化
2020-04-04

梦倚栏杆
老师里面说统一放在<Cinit> 是因为java版本不一样吗？是不是就是如下代码？
public Method "<init>":"()V"
	stack 1 locals 1
{
		aload_0;
		invokespecial	Method java/lang/Object."<init>":"()V";
		return;
}
2020-04-04

靠人品去赢
沉浸到例子讲的是一室一厅四卫的设计里，该怎么设计这个房子呢？
2020-04-02

幸福就在不远处
如果这里面加上一张形象的类加载的图，在理解问题上，会少很多麻烦，而且老师都没什么总结，就是从开始说到结束.
2020-04-02

花花young
新建数组会导致 LazyHolder 的链接吗？
这个问题不知道怎么判断
2020-04-01

delu
多谢老师！
2020-03-08

delu
老师，您好！看了下触发类的初始化条件，我这边测试发现关于4，5条，并不能真正触发类的初始化，可以看下面的简单示例：
public class Test {
    private static final String st1 = "test";
    public static final int[] arr = new int[3];

    {
        System.out.println(arr[0]);
        System.out.println(arr[2]);
        arr[0] = 1;
        arr[1] = 2;
    }
    
    public static int[] getArr() {
        return arr;
    }
    
    public static void main(String[] args) {
        //Test test = new Test();
        System.out.println(Test.arr[0]);
        System.out.println(Test.getArr()[1]);
    }

}

可以看到，打印输出结果都为0，也就是说调用类的静态方法或者静态字段，并不能触发类的初始化。
如果我这边示例有问题的话，也请帮忙指出，多谢了！
2020-03-08

wakaka
宏观上讲得还是比较清楚的。
2020-01-28

晨间新闻
1、加载阶段，就是将Class结构写入方法区，只是被标记为未链接而暂不能使用，验证失败虚拟机会报错退出。
2、实例的初始化和类的初始化是两码事：
2.1: 实例初始化在堆中；类初始化在方法区（元空间）中。
2.2: 实例可被初始化很多次，单次的称为单例模式；而类只能被初始化一次；
2.3: 加载类也不是全部加载，是按需的。实际使用 -XX:+TraceClassLoading打印发现，启动UPM时，加载了很多很多jdk基础类，后来都是访问一个页面，加载当前页面需要用到的，未被加载的类。
2019-12-09

NullPointer
第三次听，终于理解了整个类加载的过程了。感谢
2019-11-28

码农Kevin亮
请问老师，程序是如何控制用哪个ClassLoader的呢？还有假如我自定义了一个ClassLoader，我怎么确定我要加载的类是还没有被上层的ClassLoader加载呢
2019-11-17

Mr.Brooks

老师能否说一下匿名类jvm是如何处理的呢
2019-11-12

黑色毛衣
如果没猜错的话，新建数组的的时候，数组元素的类型实际上是一个符号引用，所以这个地方一定会发生转换为直接引用，触发类加载

否则不能解释为什么会类加载不是吗？因为虚拟机也没有规定类加载的具体场景～～
2019-10-30

黑色毛衣
- flags 为 false 的情况：

调用了 Singleton.main 显然会导致 Singleton 类的类加载，在其解析过程中会将所有方法的符号引用转为直接引用，然后通过直接引用执行 main 方法；

通过直接引用调用了 Singleton.getInstance 方法，访问了 LazyHolder 的静态常量，那么会触发 LazyHolder 的初始化，有初始化，肯定有类加载；

LazyHolder 的类加载的初始化阶段，会执行 clinit 方法，由于 INSTANCE 是一个类实例（不是基本类型或者 String），所以会在这个阶段初始化，这里会创建 Singleton 实例；

最后 getInstance 返回该实例；

- flags 为 true 的情况：

前面是一样的，依然会导致 LazyHolder 的加载，作为数组的类型元素，但是不满足初始化的条件；
2019-10-30

黑色毛衣
**符号引用**：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可；

举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。



**直接引用**：就是程序运行时可以定位到引用的东西（类, 对象, 变量或者方法等）的地址.

1. **直接指向目标的指针**。（个人理解为：指向方法区中类对象，类变量和类方法的指针）
2. **相对偏移量**。（指向实例的变量, 方法的指针）
3. **一个间接定位到对象的句柄**。



- **为什么要解析？**

在 class 文件被加载至 Java 虚拟机之前（或者说编译期间），这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。

因此只能使用符号引用来代替。

而在运行阶段，这个符号引用需要转为直接饮用，才能定位到具体目标上。
2019-10-30

黑色毛衣
链接：是指**将创建成的类合并至 Java 虚拟机中，使之能够执行的过程**。

这个合并到底是什么操作？该如何理解？？
2019-10-30

黑色毛衣
那几个是类加载的触发条件吧？ 
2019-10-29

黑色毛衣
"在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。"

这句话的意思感觉像是，在加载至虚拟机之前，class 通过符号引用来访问方法。
这是什么时候回去访问呢？

2019-10-29

技术骨干
加载什么，链接什么，初始化什么？
2019-10-24

Starry
坐在公交上，硬着头皮看了两遍，加深了点印象。唉，堵车上班要迟到了
2019-10-14

随心而至
[Loaded lecture3.Singleton from file:/D:/IdeaProject/deepinjvm/src/main/java/]
[Loaded java.lang.Class$MethodArray from D:\Java\jre1.8.0_91\lib\rt.jar]
[Loaded java.lang.Void from D:\Java\jre1.8.0_91\lib\rt.jar]
[Loaded lecture3.Singleton$LazyHolder from file:/D:/IdeaProject/deepinjvm/src/main/java/]
-----
LazyHolder.<clinit>
可以通过上面的加载顺序来看出一和二的答案。
false的时候，即新建数组，加载是java.lang.Class$MethodArray，不会加载LazyHolder，也就更不会初始化LazyHolder了。
true的时候，才会加载LazyHolder和执行初始化，也就是上面的lecture3.Singleton$LazyHolder和LazyHolder.<clinit>两行
2019-09-25

丁乐洪
双亲委派模型，能具体讲讲
2019-09-16

街角
老师，我想问下有个说法是"字节码加载进内存后，会有字节码执行心引擎来执行字节码"。我的问题是  类加载不是有 加载，校验，准备，解析，初始化 阶段嘛，  字节码执行引擎会参与上述其中哪些阶段？对于各阶段的的作用是啥？
2019-09-11

拯救地球好累
---总结---
Java类型：基本类型、引用类型
引用类型：类、接口、数组类、泛型参数
具有字节流的引用类型：类、接口

加载：查找字节流并由该字节流创建类的过程
加载类的加载器选择：双亲委派模型
确定一个类：加载器实例+类全名

链接：验证、准备、解析
验证：确保class符合JVM约束条件
准备：静态字段内存分配、JVM层一些数据结构的构建
解析：符号引用->实际引用

初始化：为标记为常量的字段赋值并执行<clinit>方法
初始化的场景：虚拟机启动时的主类、new的目标类、静态方法调用或静态字段访问的所在类、子类初始化触发其父类、实现类调用接口的default触发其接口、反射、MethodHandle
2019-09-08

水
加载类时，类加载器会先给父类加载器过目，对于应用的类来说，加载应用里的类的传递过程，是不是最终只传递到应用类加载器，还是会一路传递到启动类加载器
2019-08-18

花花young
解析阶段的目的，正是将这些符号引用解析成为实际引用。但是后续在总结中说到解析为非必须的该怎么理解呢？那初始化阶段也是以符号引用来存在吗？
2019-06-26

Vincent
加载：查找字节流，并据此创建类的过程；（问题1：这里的创建类，是指把类创建到哪里了？）
链接：将创建成的类合并至Java虚拟机中，使之能够执行的过程。（问题2：这里所说的合并至Java虚拟机中是什么意思？）
2019-06-02

辉仔lovers
老师，这些用文字描述出来能看明白，但是还是感觉不透彻，能通过什么方式具体的看到这个类加载的过程码
2019-06-02

calljson
请问，为何类加载优先使用父加载器？谢谢
2019-05-31

狂风骤雨
老师，我想问下，就是我们实际项目开发当中，tomcat启动了项目，是不是所有spring生成的bean都已经被初始化过了呢
2019-05-14

过去、今日
有个疑问就是双亲委派模型，先是由父类加载器加载，父类加载器没找到请求类，才有子类加载器加载。怎么判断类加载器找到请求的类？还有就是符号引用和实际引用怎么理解？
2019-05-11

ning~
加载，是指查找字节流，并且据此创建类的过程。

-----------
参考其他文章如下
将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口，这个过程需要类加载器参与。

2019-05-06

jack Wong
老师想问问，这段代码public class Singleton {
  private Singleton() {}
  private static class LazyHolder {
    static final Singleton INSTANCE = new Singleton();
  }
  public static Singleton getInstance() {
    return LazyHolder.INSTANCE;
  }
}
就是里面那个INSTANCE常量，在初始化的时候jvm会不会加载Singleton这个类？如果触发了加载这个类那么我调用了Singleton这个类的getInstance静态方法还会不会再触发加载Singleton这个类呢？
2019-05-06

Hizkijah
我觉得那个单例的讲的有问题，那个static的他只执行一次，为什么说他调用那个getInstance方法才会被初始化，才会创建对象，这样怎么保证单例。
2019-04-25

小雷哥
准备阶段，会初始化常量即final static修饰的变量吧
2019-04-23

换个名字
当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类

这句话不太明白什么意思
2019-04-04

longslee
“准备阶段的目的，则是为被加载类的静态字段分配内存”

老师请问，这句话该如何理解呢？因为看到最后的初始化阶段，无论是否“常量值”，还是< clinit >，都在初始化阶段才赋值，那么“准备阶段”如何得知需要分配多大的空间呢？
2019-03-25

WL
请教一下能不能把如何实现对class文件加密又再自定义类加载器对文件解密具体怎么操作, 有没有相关资料的连接?
2019-03-24

恒
老师，假如有这么一个类叫Test，在初始化阶段时，有这么一句，static Test test = new Test();  
那么为什么结果会显示出这么一种现象，实例变量的初始化反而先于静态变量的初始化呢？
2019-03-17

Geek_ebda96
老师，请教一个问题，就是常量的静态变量不会触发类的初始化动作，但我实际测试遇到一个问题，如下代码：public class ConstDemo { static final int A = 10; static { System.out.println("Const init"); } }，调用ConstDemo.A,不会输出 Const init，是正确的,现在把程序的A变量final修饰去掉，会输出Const init，这也是正确的，现在再把A变量加上final修饰，这次还是会输出Const init，这个就不正确，但如果把变量A的值修改一下，又不会输出Const init，请问这是什么原因呢
2019-03-10

得瑟男神
前面说，除了启动类加载器外的其他类加载器都是 classloader 的子类。   后面又说扩展类加载器的父类是启动类加载器。  这两句我感觉有点矛盾，能否帮解释一下？
2019-03-05

bad kid
老师及各位大佬：请问下在链接阶段就已经给类变量初始化了；初始化阶段也是对类变量进行初始化，这不是重复了吗？
2019-02-20

休息一下马上回来
老师，问一下什么是虚方法的动态绑定
2019-01-29

金龟
请教一下，通过不同的classloader能多次加载相同的类到jvm，这样的母的是什么，能举个应用场景吗
2019-01-22

余渡
public class Singleton {
    //著名的单例延迟初始化例子
    private Singleton(){};
    private static class LazyHolder{
        static final Singleton INSTANCE = new Singleton();
        static {
            System.out.println("LazyHolder .<clinit>");
        }
    }
    public static Object getInstance(){
         return new LazyHolder[2];
    }
    public static void main(String[] args) {
        System.out.println("------");
        getInstance();
    }
1：先不更改字节码运行结果是

因此可以看出来是没有初始化的，不然的话就应该出现了LazyHolder .<clinit>
第一个问题：会导致LazyHolder的加载么？
根据得出的日志来看，是加载了的。
第二个问题：新建数组会导致LazyHolder的链接么？
在我更改了stack 0 之后，继续运行的代码是没有报错的。
链接的三个阶段：验证 准备 解析 解析不是在这个阶段必备的。
当更改了字节码之后，如果导致链接那么第一件事儿就是验证，当类加载器检测到字节码不错误时，就会报错，程序没有报错，则说明新建数组不会导致LazyHolder的链接。
还有些同学可能在windos上边无法运行asmtools，网上的教程也不是很全面，起码我自己就失败了，只好自己想其他办法解决了这个问题，有同学感兴趣可以email我MonkeyNull@163.com
2019-01-17

张钊
老师，能讲一下单例的恶汉模式为什么在加载时会完成初始化吗
2019-01-17

hughieyu
链接，初始化这些动作是在堆中的Class对象中进行的吗，还是在方法区中？
2019-01-08

亮出
对比打印的不同点

修改前:
LazyHolder.<clinit>

修改后:
[Loaded java.lang.VerifyError from /Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home/jre/lib/rt.jar]
[Loaded java.lang.Throwable$PrintStreamOrWriter from /Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home/jre/lib/rt.jar]
[Loaded java.lang.Throwable$WrappedPrintStream from /Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home/jre/lib/rt.jar]
[Loaded java.util.IdentityHashMap from /Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home/jre/lib/rt.jar]
[Loaded java.util.IdentityHashMap$KeySet from /Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home/jre/lib/rt.jar]

不知道是否正确

2019-01-03

尔东
Class文件到内存中的类，加载、链接、初始化
加载，查找字节流，通过类加载器创建类，使用双亲委托模型。加载后类的唯一性由类的全名和加载类实例共同决定。
链接，将创建成的类合并至java虚拟机，使之可以被执行。链接分为验证、准备和解析。验证判断加载的字节流合法性，准备是为静态字段分配内存及创建方法字段的符号引用。解析是将符号引用解析为实际引用。
初始化，就是初始化静态字段和静态代码块，类的初始化只会被执行一次，是线程安全的，所以可以被用于实现单例的延迟初始化。

新建数组会加载LazyHolder类，但不会触发初始化
新建数组不会链接元素，也不会初始化
2018-12-31

木头疙瘩
郑博士好，
“如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue）”，对于这段描述有个问题，如下代码:static final String a = System.currentTimeMillis()+""，这里面的变量a也会被视为常量值吗？谢谢
2018-12-19

小泷哥
常量难道不应该是字面量吗？还要需要赋值？
2018-12-11

橙生北国
老师，您好。我想问一下关于双亲委派模型的问题，为什么双亲委派模型是用组合而不用继承？这个问题是我在面试的时候面试官问我的，我当时说的是继承与组合的好处与坏处，面试官说不对。
2018-11-22

小和尚笨南北
深入理解Java虚拟机中描述到常量值在准备阶段就会被赋值，老师所讲也是在初始化阶段。
哪位大佬解惑一下。
2018-11-19

是我
老师代码是直接用工具编写运行？还是用cmd或者是linux下运行？
2018-11-13

茫农
叫双亲委派应该是为了遵从男女平等,貌似以前在哪看过
作者回复: 有道理！

2018-11-07

雨木
加载链接初始化三个步骤是一起执行的吗？还是说存在加载链接了，但是还没有初始化的情况？
2018-11-02

杨春鹏
关于热部署实现:自定义了一个类加载器，然后在测试类一直运行过程中修改了class文件，结果输出信息还是没有发生变化(对象使用new创建，然后调用toString())
2018-10-29

北纬30⁰
双亲委派模式，因该是指的爸爸辈分和爷爷辈分这两个亲人吧
作者回复: 英文parent翻译过来的，不含爷爷辈分。

另你自定义的class loader，会委派给爸爸，爷爷，太爷爷的 :)

2018-10-23

小白粥粥
看不懂啊，半道出家太难，像天书一样，我还得多读几遍理解理解
2018-10-11

赵纬龙
老师，工作当中经常遇到编译没有问题，但是在部署的时候出现class not found的报错，不需要重新编译，只要重新部署就不报会报错且可以正常启动了，这种情况是什么原因呢，有没有可能是类加载器的问题呢？
2018-10-07

gogo
老师您好，关于类在什么时候加载还是没搞清楚，请问是由应用类加载器一下子加载classpath下的所有类吗？还是有什么规则呢
2018-10-04

动稽不纯
数组类是啥 list?
2018-10-03

wessonwang
郑老师，有个问题不解，为什么验证在加载之前？如果验证不合法，加载这一步不是白做了嘛？
2018-10-02

培
感觉好深奥呀……是我的水平太低了吗😯
2018-09-27

杨春鹏
类的加载过程中的 “初始化”为类的静态变量赋值，那么没有被static修饰的字段，有没有被赋值呢。
比如：
public Test{
  public String name;
  public void fun(){
      System.out.println(name);
}
}
依然可以输出null;那么这个name是在哪个阶段赋值的
2018-09-19

遥远的旅程
请问new指令执行的时候，是根据class对象来创建对象开辟内存和吗
2018-09-18

hpfish
有个问题，常量不是在准备阶段就直接赋值的吗？
2018-09-17

hailowell
老师 您讲的延迟单例那里
如果先通过反射触发初始化，再触发LayzyHolder的初始化 会不会导致LazyHolder的父类初始化两次？
2018-09-13

darling
new LazyHolder[2] 是什么意思啊???没这么用过
作者回复: 新建长度为2的数组

2018-09-11

bhfjf
老师你好，我有个问题，既然初始化是线程安全的，那为什么我当时学的时候老师要让我们这么写单例模式来保证安全呢？这样再加锁是不是就多余了呀？
public class Single{
     private Single(){}
     private Single single;
     public static Single getInstance(){
          if(single==null){
              synchronized(Single.class){
                   if(single==null){
                      single = new Single();
                   }
              }
          }
          return single;
     }
}
作者回复: 之所以用初始化，就是为了解决你列出来的这段代码的潜在问题。你可以搜一下double checked locking的wiki

2018-08-28

Leon Wong
老师你好，有个问题特来请教，《深入理解Java虚拟机》一书中提到ConstantValue是在准备阶段赋值（不仅仅是初始化为0值），而您这边说ConstantValue是在类加载的最后一步即初始化阶段中赋值，请问哪一个说法是正确的呢？
作者回复: 这一篇的留言中我已经回答过一样的问题了。我是按照最新版的Java虚拟机规范来写的。不过从实现的角度来看，我觉得都可以。

2018-08-25

javaadu
您好，文中提到类初始化是线程安全的，请我虚拟机是如何实现这一点的呢
作者回复: 通过加锁实现的。所以稍有不慎这一部分很容易造成死锁。

2018-08-25

dingwood
java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class > Foo.jasm.1，执行这句报错：java.lang.UnsupportedClassVersionError: org/openjdk/asmtools/jdis/Main : Unsupported major.minor version 52.0。。支持什么版本的jdk啊。
作者回复: Java 8

2018-08-22

猿工匠
学习了，由浅入深
2018-08-16

一个坏人
老师好，请假一个问题。“Java 虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。” 这个 解析符合引用的具体过程是？当前阶段还是没法知道方法具体的信息 ，感觉还是只能是符号引用？谢谢老师。
2018-08-09

王刚
你好，老师，我想问一个问题～类加载的过程可以总结为：
1、加载class字节码文件到虚拟机中
2、验证
3、准备
4、解析
5、初始化

我想问的是在加载class文件时，在没有到达虚拟机方法区中时，是不是已经完成了验证？只有验证通过的class字节码文件才会加载到方法区中？
2018-08-04

I
最近碰到一个问题，想请教下作者
tomcat是自定义类加载器加载应用类的，我用的是8.5版本，但是使用并行流的时候，获取并行流中的类加载器返回的是null，这个是为什么啊
2018-08-03

张大彪
对于字节码不了解，不知道改字节码到底改了啥。只要只改字节码后面的东西都不知道怎么回事了。
2018-07-31

Mk
类加载时候加锁 如果在里面进行多线程回出现死锁 请老师具体讲解下。
2018-07-31

倪有才
这些内容确实没有离开深入了解jvm那本书的内容，希望老师能够加深讲解
2018-07-31

xuanyuan
mover说了我想说的话
2018-07-30

silver-lrs
类加载时如果引用另外一个类，那么这个类会先加载，那么请教一下，如果循环引用呢，会发生什么事？
2018-07-28

赌神很低调
老师说了初始化发生的时间，请问老师类加载和链接是在什么时候发生的
2018-07-28

、
操作字节码文件还挺有成就感 谢谢老师  虽然大部分看不懂字节码
2018-07-28

Bmo
静态内部类(或者内部类？)在外部类初始化的时候不会被加载，然后当调用getInstance的时候，才会加载内部类，然后因为内部那个初始化是同步的，所以这个单例实现了懒加载线程安全，我这么理解有问题吗
2018-07-26

Kenneth
老师你好，awk……这些在哪里可以学习呢？指令看不懂怎么办，谢谢！
作者回复: 这一段直接文本编辑也可以，并不一定要用awk。直接man awk应该有用法的。

2018-07-26

WolvesLeader
想问哈，类的class文件中的所有内容全部会被加载到方法区中，还是class中的方法被加载到方法区
2018-07-26

cxzm
老师，关于类初始化和类实例化有哪些区别呢？
2018-07-25

加多
期待老师讲解，加载的字节码最终都被转换为了那些内容，都放到了哪里，执行时候如何进行链接的，如何去查找到的引用对象的
2018-07-25

ajianzheng
老师，我现在遇到一个问题，在调用jni接口时第一次是正常的，但是后续偶现找不到jni接口，请问这个问题该怎么排查？
2018-07-25

观海雲遠
在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。
按照双亲委派模式 一个类怎么会被不同的加载器加载呢
2018-07-25

Thomas
子类继承父类重写是怎么实现的我挺好奇的老师其他看明白了
2018-07-25

Thomas
子类继承父类重写是怎么实现的我挺好奇的老师其他看明白了
2018-07-25
