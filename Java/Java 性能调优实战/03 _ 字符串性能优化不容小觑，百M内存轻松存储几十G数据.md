# 03 \| 字符串性能优化不容小觑，百M内存轻松存储几十G数据

从第二个模块开始，我将带你学习Java编程的性能优化。今天我们就从最基础的String字符串优化讲起。

String对象是我们使用最频繁的一个对象类型，但它的性能问题却是最容易被忽略的。String对象作为Java语言中重要的数据类型，是内存中占据空间最大的一个对象。高效地使用字符串，可以提升系统的整体性能。

接下来我们就从String对象的实现、特性以及实际使用中的优化这三个方面入手，深入了解。

在开始之前，我想先问你一个小问题，也是我在招聘时，经常会问到面试者的一道题。虽是老生常谈了，但错误率依然很高，当然也有一些面试者答对了，但能解释清楚答案背后原理的人少之又少。问题如下：

通过三种不同的方式创建了三个对象，再依次两两匹配，每组被匹配的两个对象是否相等？代码如下：

```
String str1= "abc";
String str2= new String("abc");
String str3= str2.intern();
assertSame(str1==str2);
assertSame(str2==str3);
assertSame(str1==str3)
```

## String对象是如何实现的？

在Java语言中，Sun公司的工程师们对String对象做了大量的优化，来节约内存空间，提升String对象在系统中的性能。一起来看看优化过程，如下图所示：

![](<https://static001.geekbang.org/resource/image/35/6d/357f1cb1263fd0b5b3e4ccb6b971c96d.jpg?wh=1632*636>)

**1\.在Java6以及之前的版本中**，String对象是对char数组进行了封装实现的对象，主要有四个成员变量：char数组、偏移量offset、字符数量count、哈希值hash。

<!-- [[[read_end]]] -->

String对象是通过offset和count两个属性来定位char[]数组，获取字符串。这么做可以高效、快速地共享数组对象，同时节省内存空间，但这种方式很有可能会导致内存泄漏。

**2\.从Java7版本开始到Java8版本**，Java对String类做了一些改变。String类中不再有offset和count两个变量了。这样的好处是String对象占用的内存稍微少了些，同时，String.substring方法也不再共享char[]，从而解决了使用该方法可能导致的内存泄漏问题。

**3\.从Java9版本开始，** 工程师将char[]字段改为了byte[]字段，又维护了一个新的属性coder，它是一个编码格式的标识。

工程师为什么这样修改呢？

我们知道一个char字符占16位，2个字节。这个情况下，存储单字节编码内的字符（占一个字节的字符）就显得非常浪费。JDK1.9的String类为了节约内存空间，于是使用了占8位，1个字节的byte数组来存放字符串。

而新属性coder的作用是，在计算字符串长度或者使用indexOf（）函数时，我们需要根据这个字段，判断如何计算字符串长度。coder属性默认有0和1两个值，0代表Latin-1（单字节编码），1代表UTF-16。如果String判断字符串只包含了Latin-1，则coder属性值为0，反之则为1。

## String对象的不可变性

了解了String对象的实现后，你有没有发现在实现代码中String类被final关键字修饰了，而且变量char数组也被final修饰了。

我们知道类被final修饰代表该类不可继承，而char[]被final+private修饰，代表了String对象不可被更改**。Java实现的这个特性叫作String对象的不可变性，即String对象一旦创建成功，就不能再对它进行改变。**

**Java这样做的好处在哪里呢？**

第一，保证String对象的安全性。假设String对象是可变的，那么String对象将可能被恶意修改。

第二，保证hash属性值不会频繁变更，确保了唯一性，使得类似HashMap容器才能实现相应的key-value缓存功能。

第三，可以实现字符串常量池。在Java中，通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如String str=“abc”；另一种是字符串变量通过new形式的创建，如String str = new String(“abc”)。

当代码中使用第一种方式创建字符串对象时，JVM首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。

**String str = new String(“abc”)这种方式，首先在编译类文件时，"abc"常量字符串将会放入到常量结构中，在类加载时，“abc"将会在常量池中创建；其次，在调用new时，JVM命令将会调用String的构造函数，同时引用常量池中的"abc” 字符串，在堆内存中创建一个String对象；最后，str将引用String对象**。

**这里附上一个你可能会想到的经典反例。**

平常编程时，对一个String对象str赋值“hello”，然后又让str值为“world”，这个时候str的值变成了“world”。那么str值确实改变了，为什么我还说String对象不可变呢？

首先，我来解释下什么是对象和对象引用。Java初学者往往对此存在误区，特别是一些从PHP转Java的同学。在Java中要比较两个对象是否相等，往往是用==，而要判断两个对象的值是否相等，则需要用equals方法来判断。

这是因为str只是String对象的引用，并不是对象本身。对象在内存中是一块内存地址，str则是一个指向该内存地址的引用。所以在刚刚我们说的这个例子中，第一次赋值的时候，创建了一个“hello”对象，str引用指向“hello”地址；第二次赋值的时候，又重新创建了一个对象“world”，str引用指向了“world”，但“hello”对象依然存在于内存中。

也就是说str并不是对象，而只是一个对象引用。真正的对象依然还在内存中，没有被改变。

## String对象的优化

了解了String对象的实现原理和特性，接下来我们就结合实际场景，看看如何优化String对象的使用，优化的过程中又有哪些需要注意的地方。

### 1\.如何构建超大字符串？

编程过程中，字符串的拼接很常见。前面我讲过String对象是不可变的，如果我们使用String对象相加，拼接我们想要的字符串，是不是就会产生多个对象呢？例如以下代码：

```
String str= "ab" + "cd" + "ef";
```

分析代码可知：首先会生成ab对象，再生成abcd对象，最后生成abcdef对象，从理论上来说，这段代码是低效的。

但实际运行中，我们发现只有一个对象生成，这是为什么呢？难道我们的理论判断错了？我们再来看编译后的代码，你会发现编译器自动优化了这行代码，如下：

```
String str= "abcdef";
```

上面我介绍的是字符串常量的累计，我们再来看看字符串变量的累计又是怎样的呢？

```
String str = "abcdef";

for(int i=0; i<1000; i++) {
      str = str + i;
}
```

上面的代码编译后，你可以看到编译器同样对这段代码进行了优化。不难发现，Java在进行字符串的拼接时，偏向使用StringBuilder，这样可以提高程序的效率。

```
String str = "abcdef";

for(int i=0; i<1000; i++) {
        	  str = (new StringBuilder(String.valueOf(str))).append(i).toString();
}
```

**综上已知：** **即使使用+号作为字符串的拼接，也一样可以被编译器优化成StringBuilder的方式。但再细致些，你会发现在编译器优化的代码中，每次循环都会生成一个新的StringBuilder实例，同样也会降低系统的性能。**

所以平时做字符串拼接的时候，我建议你还是要显示地使用String Builder来提升系统性能。

**如果在多线程编程中，String对象的拼接涉及到线程安全，你可以使用StringBuffer。但是要注意，由于StringBuffer是线程安全的，涉及到锁竞争，所以从性能上来说，要比StringBuilder差一些**。

### 2\.如何使用String.intern节省内存？

讲完了构建字符串，我们再来讨论下String对象的存储问题。先看一个案例。

Twitter每次发布消息状态的时候，都会产生一个地址信息，以当时Twitter用户的规模预估，服务器需要32G的内存来存储地址信息。

```
public class Location {
    private String city;
    private String region;
    private String countryCode;
    private double longitude;
    private double latitude;
}
```

考虑到其中有很多用户在地址信息上是有重合的，比如，国家、省份、城市等，这时就可以将这部分信息单独列出一个类，以减少重复，代码如下：

```
public class SharedLocation {

	private String city;
	private String region;
	private String countryCode;
}

public class Location {

	private SharedLocation sharedLocation;
	double longitude;
	double latitude;
}
```

通过优化，数据存储大小减到了20G左右。但对于内存存储这个数据来说，依然很大，怎么办呢？

这个案例来自一位Twitter工程师在QCon全球软件开发大会上的演讲，他们想到的解决方法，就是使用String.intern来节省内存空间，从而优化String对象的存储。

具体做法就是，在每次赋值的时候使用String的intern方法，如果常量池中有相同值，就会重复使用该对象，返回对象引用，这样一开始的对象就可以被回收掉。这种方式可以使重复性非常高的地址信息存储大小从20G降到几百兆。

```
SharedLocation sharedLocation = new SharedLocation();

sharedLocation.setCity(messageInfo.getCity().intern());		sharedLocation.setCountryCode(messageInfo.getRegion().intern());
sharedLocation.setRegion(messageInfo.getCountryCode().intern());

Location location = new Location();
location.set(sharedLocation);
location.set(messageInfo.getLongitude());
location.set(messageInfo.getLatitude());
```

**为了更好地理解，我们再来通过一个简单的例子，回顾下其中的原理：**

```
String a =new String("abc").intern();
String b = new String("abc").intern();
    	  
if(a==b) {
    System.out.print("a==b");
}
```

输出结果：

```
a==b
```

**在字符串常量中，默认会将对象放入常量池；在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，String对象中的char数组将会引用常量池中的char数组，并返回堆内存对象引用**。

如果调用intern方法，会去查看字符串常量池中是否有等于该对象的字符串的引用，如果没有，在JDK1.6版本中会复制堆中的字符串到常量池中，并返回该字符串引用，堆内存中原有的字符串由于没有引用指向它，将会通过垃圾回收器回收。

在JDK1.7版本以后，由于常量池已经合并到了堆中，所以不会再复制具体字符串了，只是会把首次遇到的字符串的引用添加到常量池中；如果有，就返回常量池中的字符串引用。

了解了原理，我们再一起看下上边的例子。

在一开始字符串"abc"会在加载类时，在常量池中创建一个字符串对象。

创建a变量时，调用new Sting()会在堆内存中创建一个String对象，String对象中的char数组将会引用常量池中字符串。在调用intern方法之后，会去常量池中查找是否有等于该字符串对象的引用，有就返回引用。

创建b变量时，调用new Sting()会在堆内存中创建一个String对象，String对象中的char数组将会引用常量池中字符串。在调用intern方法之后，会去常量池中查找是否有等于该字符串对象的引用，有就返回引用。

而在堆内存中的两个对象，由于没有引用指向它，将会被垃圾回收。所以a和b引用的是同一个对象。

如果在运行时，创建字符串对象，将会直接在堆内存中创建，不会在常量池中创建。所以动态创建的字符串对象，调用intern方法，在JDK1.6版本中会去常量池中创建运行时常量以及返回字符串引用，在JDK1.7版本之后，会将堆中的字符串常量的引用放入到常量池中，当其它堆中的字符串对象通过intern方法获取字符串对象引用时，则会去常量池中判断是否有相同值的字符串的引用，此时有，则返回该常量池中字符串引用，跟之前的字符串指向同一地址的字符串对象。

以一张图来总结String字符串的创建分配内存地址情况：

![](<https://static001.geekbang.org/resource/image/b1/50/b1995253db45cd5e5b7bc1ded7cbdd50.jpg?wh=2510*952>)

使用intern方法需要注意的一点是，一定要结合实际场景。因为常量池的实现是类似于一个HashTable的实现方式，HashTable存储的数据越大，遍历的时间复杂度就会增加。如果数据过大，会增加整个字符串常量池的负担。

### 3\.如何使用字符串的分割方法？

最后我想跟你聊聊字符串的分割，这种方法在编码中也很最常见。Split()方法使用了正则表达式实现了其强大的分割功能，而正则表达式的性能是非常不稳定的，使用不恰当会引起回溯问题，很可能导致CPU居高不下。

所以我们应该慎重使用Split()方法，我们可以用String.indexOf()方法代替Split()方法完成字符串的分割。如果实在无法满足需求，你就在使用Split()方法时，对回溯问题加以重视就可以了。

## 总结

这一讲中，我们认识到做好String字符串性能优化，可以提高系统的整体性能。在这个理论基础上，Java版本在迭代中通过不断地更改成员变量，节约内存空间，对String对象进行优化。

我们还特别提到了String对象的不可变性，正是这个特性实现了字符串常量池，通过减少同一个值的字符串对象的重复创建，进一步节约内存。

但也是因为这个特性，我们在做长字符串拼接时，需要显示使用StringBuilder，以提高字符串的拼接性能。最后，在优化方面，我们还可以使用intern方法，让变量字符串对象重复使用常量池中相同值的对象，进而节约内存。

最后再分享一个个人观点。那就是千里之堤，溃于蚁穴。日常编程中，我们往往可能就是对一个小小的字符串了解不够深入，使用不够恰当，从而引发线上事故。

比如，在我之前的工作经历中，就曾因为使用正则表达式对字符串进行匹配，导致并发瓶颈，这里也可以将其归纳为字符串使用的性能问题。具体实战分析，我将在04讲中为你详解。

## 思考题

通过今天的学习，你知道文章开头那道面试题的答案了吗？背后的原理是什么？

## 互动时刻

今天除了思考题，我还想和你做一个简短的交流。

上两讲中，我收到了很多留言，在此非常感谢你的支持。由于前两讲是概述内容，主要是帮你建立对性能调优的整体认识，所以相对来说重理论、偏基础。但我发现，很多同学都有这样迫切的愿望，那就是赶紧学会使用排查工具，监测分析性能，解决当下的一些问题。

我这里特别想分享一点，其实性能调优不仅仅是学会使用排查监测工具，更重要的是掌握背后的调优原理，这样你不仅能够独立解决同一类的性能问题，还能写出高性能代码，所以我希望给你的学习路径是：夯实基础-结合实战-实现进阶。

最后，欢迎你积极发言，讨论思考题或是你遇到的性能问题都可以，我会知无不尽。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。



## 精选留言(127)

- ![img](https://static001.geekbang.org/account/avatar/00/17/77/61/adf1c799.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  KL3

  老师，能解释下， “String.substring 方法也不再共享 char[]，从而解决了使用该方法可能导致的内存泄漏问题。” 共享char数组可能导致内存泄露问题？

  作者回复: 你好 KL3，在Java6中substring方法会调用new string构造函数，此时会复用原来的char数组，而如果我们仅仅是用substring获取一小段字符，而原本string字符串非常大的情况下，substring的对象如果一直被引用，由于substring的里面的char数组仍然指向原字符串，此时string字符串也无法回收，从而导致内存泄露。 试想下，如果有大量这种通过substring获取超大字符串中一小段字符串的操作，会因为内存泄露而导致内存溢出。

  2019-05-25

  **2

  **129

- ![img](https://static001.geekbang.org/account/avatar/00/11/3d/e0/be2f1bf3.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  扫地僧

  答案是false,false,true。背后的原理是： 1、String str1 = "abc";通过字面量的方式创建，abc存储于字符串常量池中； 2、String str2 = new String("abc");通过new对象的方式创建字符串对象，引用地址存放在堆内存中，abc则存放在字符串常量池中；所以str1 == str2?显然是false 3、String str3 = str2.intern();由于str2调用了intern()方法，会返回常量池中的数据，地址直接指向常量池，所以str1 == str3；而str2和str3地址值不等所以也是false（str2指向堆空间，str3直接指向字符串常量池）。不知道这样理解有木有问题

  作者回复: 答案非常正确，理解了这个题目基本理解了string的特性了。

  2019-05-25

  **11

  **90

- ![img](https://static001.geekbang.org/account/avatar/00/17/98/c5/cf8c3cc2.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  快乐的五五开

  自学一年居然不知道有String.intern这个方法😓😓 不过从Java8开始（大概） String.split() 传入长度为1字符串的时候并不会使用正则，这种情况还是可以用

  作者回复: 非常感谢Geek的补充，我在这里也再补充一个小点，split有两种情况不会使用正则表达式： 第一种为传入的参数长度为1，且不包含“.$|()[{^?*+\\”regex元字符的情况下，不会使用正则表达式； 第二种为传入的参数长度为2，第一个字符是反斜杠，并且第二个字符不是ASCII数字或ASCII字母的情况下，不会使用正则表达式。

  2019-05-25

  **3

  **71

- ![img](https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  行则将至

  老师好，诚心请教一个问题 string s1 = new string(“1”)+new string(“1”); s1.intern; string s2=“11”; s1==s2为什么是true呢，我理解s1指向的对象，s2指向的常量池地址才对啊？ 然后 string s1 = new string(“1”); s1.intern; string s2=“11”; s1==s2又是false了，区别在哪？ 老师，周董提的这个问题，我都琢磨一晚上了。您的回答看了好多遍，确实是看不懂，您能再解释一下吗？目前的回答，咋看也看不懂。。。。。。

  作者回复: 如果看不太懂，建议先熟悉下JVM这块的知识点。我们知道，JVM从逻辑分区可以分为堆、JVM栈、本地方法栈、方法区、程序计数器，方法区中，在JDK1.8之后，包含了元空间、静态常量池、运行时常量池。 对于字符串常量，在类加载时，会将字符串放入方法区中的静态常量池，包括字符串的字面量和字符引用。而在初始化或运行时，会将字符引用转为直接引用，存放在运行时常量池。 如果是运行时动态生成的字符串对象调用intern方法，如果字符串的引用在运行时常量池不存在，则会在常量池中创建一个引用。 所以第一个通过加动态生成的“11”字符串由于在运行时常量中没有该字符串的引用，所以会在调用s1.intern时，在运行时常量池中生成一个s1的引用，当s2再次引用该字符串时，发现运行时常量池中存在相同值的字符串的引用，就直接返回s1的引用。所以s1==s2是返回的true。这也仅限于JDK1.7之后的版本。 而第二种，用于"11"在类加载时，已经存在静态常量池中，在new string(“11”)时，会在运行时常量池中创建一个“11”字符串的直接引用。而s1指向的并不是该引用，而是new string这个对象的引用。当s2=“11”时，返回的是运行时常量池中的引用。所以s1==s2返回false。

  2019-08-01

  **16

  **38

- ![img](https://static001.geekbang.org/account/avatar/00/13/24/c0/74898059.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  周董

  老师，还有一个问题网上众说纷纭，jdk1.8版本，字符串常量池和运行时常量池分别在内存哪个区？您文中的常量池是什么常量池？调用intern后字符串是在哪个常量池生成引用或者对象？麻烦老师抽空解答下，这个困扰很久了。

  作者回复: 严格来说，是静态常量池和运行时常量池，静态常量池是存放字符串字面量、符号引用以及类和方法的信息，而运行时常量池存放的是运行时一些直接引用。 运行时常量池是在类加载完成之后，将静态常量池中的符号引用值转存到运行时常量池中，类在解析之后，将符号引用替换成直接引用。 这两个常量池在JDK1.7版本之后，就移到堆内存中了，这里指的是物理空间，而逻辑上还是属于方法区（方法区是逻辑分区）。 我文中说的是两个常量池，没有具体区分，在初次加载时，是字面量是加载到了静态常量池中，解析之后会将引用加载到运行时常量池。 intern方法生成的引用或对象是在运行时常量池中。

  2019-08-01

  **2

  **27

- ![img](data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QN5aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0MCA3OS4xNjA0NTEsIDIwMTcvMDUvMDYtMDE6MDg6MjEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YWE3YmZhMDItMzBhMC00MDg3LTg3MmYtOGMwMjMxNjNhZWRjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI2MTlEODM3NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2MTlEODM2NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTYyRTNCMDNBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTYyRTNCMDRBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRm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)

  Teanmy

  老师好，有一点始终想不明白，请老师解惑，非常感谢！ 老师先帮忙看看关于这两行代码，我的分析是否正确： str1 = "abc"; str2 = new String("abc") str1 = "abc"; 1.str1，首先是在字符串常量池中寻找"abc"，找到则取其地址，找不到则创建并返回其地址 2.将该地址赋值给栈中的str1 str2 = new String("abc") 1.在堆中创建String对象，我查阅了String构造方法源码，实际值取的是"abc"的（此时"abc"已经存在字符串常量池中）引用，也就是说，str2还是指向常量池，并没有创建新的"abc"。 public String(String original) {        this.value = original.value;        this.hash = original.hash; } 2.堆中创建完String对象，将该对象的地址赋值给栈变量str2 疑问： 既然不管是以上哪种方式，最终实际引用的还是常量池中的"abc"，str2 = new String("abc")只是增加了一个堆中String的“空壳”对象而已（因为实际上char[]指向的还是常量池中的"abc"），这个空壳对象并不会占用过多内存。而.intern的实质只是减少了这个中间的String空壳对象，那何来twitter通过.intern减少大量内存？

  作者回复: 你好 teanmy。运行时创建的字符串对象只会在堆中创建一个对象。在这个前提下，如果有相同值的对象创建，使用intern可以减少重复字符串的创建。例如，有广东省/深圳市/南山区，如果有千万个人发布消息，创建了地址对象，这样导致千万个“广东省”对象在堆内存中创建，如果长时间引用，这些对象都没法释放，使用intern将“广东省”放到常量池中，其他对象引用常量池中的同一个“广东省”字符串，而堆中的千万个对象将被回收。 如果有疑问，请继续留言。

  2019-06-02

  **3

  **22

- ![img](https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  失火的夏天

  开头题目答案是false false true str1是建立在常量池中的“abc”，str2是new出来，在堆内存里的，所以str1!=str2， str3是通过str2..intern()出来的，str1在常量池中已经建立了"abc"，这个时候str3是从常量池里取出来的，和str1指向的是同一个对象，自然也就有了st1==str3，str3!=str2了

  作者回复: 这里我纠正下，str3是intern返回的引用，intern而不是创建出来的。 你的答案是正确的！

  2019-05-25

  **

  **21

- ![img](https://static001.geekbang.org/account/avatar/00/0f/d8/ee/6e7c2264.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Only now

  看了本篇几乎全部留言, 感觉包括老师在内, 对于 "字符串常量池" 和 "常量池", 这俩概念用的很混。 对于jdk7 以及之前的jvm版本不再去深究了, 它的字符串常量池存在于方法区, 但是jdk8以后, 它存在于Java堆中, 唯一, 且由java.lang.String类维护, 它和类文件常量池, 运行时常量池没有半毛钱的关系。  最后我有个疑问问老师, 字符串常量池中的对象, 在失去了所有外部引用之后, 会被gc掉吗?

  作者回复: 非常感谢only now的总结，这一讲中没有详细去区分常量池，而是在强调字符串的使用，后面我们在JVM中可以再一起研究下常量池。 JVM文献中提到方法区是存在垃圾回收。我们可以通过intern方法来验证这个gc问题，通过大量请求请求某个接口，传入参数创建字符串对象，之后通过intern方法在常量池中生成字符串对象，之后失去引用，观察gc情况。

  2019-05-29

  **

  **15

- ![img](https://static001.geekbang.org/account/avatar/00/10/14/e1/ee5705a2.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Zend

  “在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，复制到堆内存对象中，并返回堆内存对象引用。” 比如: 是从常量池中复制到堆内存，这时常量池中字符串与堆内存字符串是完全独立的，内部也不存在引用关系？

  作者回复: 你好 Zend，具体的复制过程是先将常量池中的字符串压入栈中，在使用string的构造方法时，会拿到栈中的字符串作为构造方法的参数。这里我纠正一点，今天我查看了下这个构造函数，String的构造函数是一个char数组赋值过程，不是new char[]重新创建，所以是引用了常量池中的字符串对象，存在引用关系。

  2019-05-26

  **

  **14

- ![img](https://static001.geekbang.org/account/avatar/00/0f/9b/a7/440aff07.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  六维

  使用 intern 方法需要注意的一点是，一定要结合实际场景。因为常量池的实现是类似于一个 HashTable 的实现方式，HashTable 存储的数据越大，遍历的时间复杂度就会增加。如果数据过大，会增加整个字符串常量池的负担。 像国家地区是有边界的。像其他情况，怎么把握这个度呢？

  作者回复: 如果对空间要求高于时间要求，且存在大量重复字符串时，可以考虑使用常量池存储。 如果对查询速度要求很高，且存储字符串数量很大，重复率很低的情况下，不建议存储在常量池中。 具体可以通过模拟测试自己的场景，对比两种存储方式的性能，通过数据来给自己答案。

  2019-05-25

  **3

  **13

- ![img](https://static001.geekbang.org/account/avatar/00/11/67/0e/2a51a2df.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](https://static001.geekbang.org/resource/image/eb/56/eb5afbf568af2917033e5a860de0b756.png?x-oss-process=image/resize,w_14)

  Eric

  对于您文中 “在一开始创建 a 变量时，会在堆内存中创建一个对象，同时在常量池中创建一个字符串对象” 这句话 我认为前部分没有问题 分歧点在后面那部分 我觉得abc常量早就在运行时常量池就存在了 可以理解使用这个类之前 就已经构造好了运行时常量池 而运行时常量池中就包括“abc”常量 至于使用new String(“abc”) 我觉得它应该只会在堆中创建String对象 并将运行时常量池中已经存在的“abc”常量的引用作为构造函数的参数而已 

  作者回复: 你理解的分歧点是对的，这个构造是在加载类时，就已经在常量池中构造好常量。

  2019-05-25

  **2

  **11

- ![img](https://static001.geekbang.org/account/avatar/00/13/24/c0/74898059.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  周董

  老师好，诚心请教一个问题 string s1 = new string(“1”)+new string(“1”); s1.intern; string s2=“11”; s1==s2为什么是true呢，我理解s1指向的对象，s2指向的常量池地址才对啊？ 然后 string s1 = new string(“1”); s1.intern; string s2=“11”; s1==s2又是false了，区别在哪？

  作者回复: String s1 = new String("1") + new String("1")会在堆中组合一个新的字符串对象"11"，在s1.intern()之后，由于常量池中没有该字符串的引用（只有字符串常量"11"），所以常量池中生成一个堆中字符串"11"的引用，此时String s2= "11"返回的是堆字符串"11"的引用，所以s1==s2。 在JDK1.7版本以及之后的版本运行以下代码，你会发现结果为true，在JDK1.6版本运行的结果却为false： String s1 = new String("1") + new String("1"); System.out.println( s1.intern()==s1);  而String s1 = new String("11")首先会在常量池中创建字符串"11"的引用，而s1则是返回的堆中的new String("11")对象的引用，此时s1.intern()返回的是常量池字符串常量"11"的引用，而非堆中的。而String s2="11"又是返回的常量池中常量"11"的引用。所以s1==s2为false。 总结：常量池中同时存在字符串常量和字符串引用，在JDK1.7版本之后的intern()方法只会尝试对象的引用放入常量池，而在之前的版本中，intern()方法会复制字符串常量到常量池中，并返回字符串引用。

  2019-07-26

  **4

  **7

- ![img](https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  -W.LI-

  老师好！第一个问题没有描述清楚。String  a = ”abc”, String b =new String("abc"),String c=new String(new char[]{‘a’,‘b’,‘c’}）。创建的String对象。我debug时发现这三个String对象的value指向的那个char数组地址值都是一样的。他们是复用了一个char数组么?还是工具显示问题?我用的idea。

  作者回复: 你好 W.LI，刚我debug了下，a和b的value是同一个地址，因为a在常量池中创建了"abc"，而new String("abc")时，发现常量池存在"abc"字符串对象，不会创建了。这时通过构造函数String(String original)将常量池中的"abc"复制给value，这里的复制是引用，不是创建新的char[]数组，所以是同一个value地址。 而c中的构造函数，是新开辟了一个char[]数组： public String(char value[]) {        this.value = Arrays.copyOf(value, value.length); } 所以value的地址不一样。 可以再试试，有问题留言。

  2019-05-26

  **

  **7

- ![img](https://static001.geekbang.org/account/avatar/00/11/67/0e/2a51a2df.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](https://static001.geekbang.org/resource/image/eb/56/eb5afbf568af2917033e5a860de0b756.png?x-oss-process=image/resize,w_14)

  Eric

  String s1 = new String("abc").intern() Code:       0: new           #2                  // class java/lang/String       3: dup       4: ldc           #3                  // String abc       6: invokespecial #4                  // Method java/lang/String."<init>":(Ljava/lang/String;)V       9: invokevirtual #5                  // Method java/lang/String.intern:()Ljava/lang/String;      12: astore_1      13: return 9:invokevirtual的时候 常量池里面应该早就有了”abc“这个字符串常量了吧 为什么文中说的是先去堆中创建一个String对象 然后再去常量池创建一个字符串常量? 我理解错误了吗?

  作者回复: 我们可以看到0 new，即是生成了一个对象，这个对象是在堆内存用创建的，之后4 Idc则是将常量池中创建的字符串abc压入栈中，invokespecial调用构造方法复制abc字符串到对象中，invokevirtual调用intern本地方法，返回常量池中的对象引用给s1。 new String("abc")是会创建两个对象的，一个是堆对象，一个是常量池中的对象，intern会去判断常量池中是否有，这个时候是有的，所以不会创建，而是改变s1的引用。 不知道这样是否更好理解？

  2019-05-25

  **

  **7

- ![img](https://static001.geekbang.org/account/avatar/00/12/f6/df/a576bfce.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  建国

  在实际编码中我们应该使用什么方式创建字符传呢？ A.String str= "abcdef"; B.String str= new String("abcdef"); C.String str= new String("abcdef"). intern(); D.String str1=str.intern();

  作者回复: 实际编码中，我们要结合实际场景来选择创建字符串的方式，例如，在创建局部变量以及常量时，我们一般使用A的这种方式；如果我们要区别一个字符串创建两个不同的对象来使用时，会选择B；intern一般使用的比较少，例如我们平时会创建很多一样的字符串的对象时，且对象会保存在内存中，我们可以考虑使用intern方法来减少过多重复对象占用内存空间。

  2019-05-25

  **3

  **7

- ![img](https://static001.geekbang.org/account/avatar/00/13/1d/51/6eb096ba.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](https://static001.geekbang.org/resource/image/eb/56/eb5afbf568af2917033e5a860de0b756.png?x-oss-process=image/resize,w_14)

  benben

  请教最后一张图第三列的意思是对象成员变量是string的话不会放到常量池是吗？

  作者回复: 是的，运行时动态创建是在堆内存中直接创建的，调用intern方法，会反倒常量池中。

  2019-06-26

  **

  **4

- ![img](https://static001.geekbang.org/account/avatar/00/14/ba/61/99e3e2ad.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  水月

  老师请教一个问题，通过抽离出单独类SharedLocation，存储减到了20G，麻烦解析下原理？

  作者回复: 共享一个类，减少在不同的类中重复创建location的信息。

  2019-07-09

  **

  **3

- ![img](https://static001.geekbang.org/account/avatar/00/13/2d/86/ffc4d749.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Hammy

  老师您好，我这里有一个疑问。在听您说完，对象的string属性实质上在运行中是在堆内存中创建而不是引用常量池的时候如雷贯耳一般，觉得自己之前根本没思考过这个问题，完全没想过用intern进行优化。但是我做了一个实验，public class Person {     public String name;      public void setName(String name) {        this.name = name;    }     public String getName() {        return name;    }     public static void main(String[] args) {        Person person1 = new Person();        person1.setName("张三");        Person person2 = new Person();        person2.setName("张三");        System.out.println(person1.name==person2.name);     } 这段代码中，我理解如果string是在运行过程中在堆内存生成对象，那么结果应该是false，但是返回的结果是true。这是我的一个疑惑，劳烦老师帮忙看一下我的测试代码哪里不对，还是有理解错误的地方。

  作者回复: "张三"是常量，而不是一个对象，所以会有问题。我们可以使用外部传值的方式试试。

  2019-06-21

  **4

  **3

- ![img](https://static001.geekbang.org/account/avatar/00/10/fe/9c/c29c44e9.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  西门吹水之城

  老师您好，看下面的留言，您看我这这么理解对吗？ String b=new String(“abc”); for(int i=0;i<10;i++)｛   String c=new String(i+“”); ｝ 上面的代码中，b和c是不同的，b在编译的时候会将abc放入常量池中，b引用的堆内存，堆内存引用常量池。c在编译时候没有字符串，在运行的时候，会直接存入内存中，不会将字符串放入常量池。这样解释可以吗？

  作者回复: b是在类加载时，放入到常量池中。其他地方理解没问题。

  2019-06-04

  **

  **3

- ![img](https://static001.geekbang.org/account/avatar/00/12/f8/25/b871832f.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  ° BugMaker

  刘老师您好!"使用 intern 方法需要注意的一点是，一定要结合实际场景。因为常量池的实现是类似于一个 HashTable 的实现方式，HashTable 存储的数据越大，遍历的时间复杂度就会增加。如果数据过大，会增加整个字符串常量池的负担",那这个Twitter 工程师在 QCon 全球软件开发大会上的演讲的那个 intern 方法是如何做到遍历这么多常量池的数据，同时保证性能的呢?

  作者回复: 你好，如果我们的数据对查询速度没有这么高要求，可以考虑使用。

  2019-05-31

  **

  **3

- ![img](https://static001.geekbang.org/account/avatar/00/11/45/c1/d1dc5e19.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  大海

  String s = new String("abc").intern(); 既然使用intern也会引用到常量池,那么和 使用intern 和 直接使用 String s = "abc"有差别吗

  作者回复: 最终实现达到的结果是一样的，但过程不一样。我拿这个例子来说明，在程序运行期间动态创建的字符串对象，由于这类字符串是在内存中开辟的地址空间存放字符串，可以使用intern方法放在常量池中。

  2019-05-26

  **

  **3

- ![img](https://static001.geekbang.org/account/avatar/00/11/67/0e/2a51a2df.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](https://static001.geekbang.org/resource/image/eb/56/eb5afbf568af2917033e5a860de0b756.png?x-oss-process=image/resize,w_14)

  Eric

  我在《Java虚拟机规范》里面看到一句话 这句话是当类或接口创建时，它的二进制表示中的常量池表被用来构造运行时常量池 我理解的意思是 类或接口 创建时就根据.class文件的常量池表生成了运行时常量池 执行new String("abc")这行代码应该只会生成一个String对象 并且调用它的构造函数 参数是运行时常量池里面"abc"字符串常量的Reference类型的数据（可以理解为指针吧）怎么会在这行代码执行的时候才会在运行时常量池生成”abc“对象呢？

  作者回复: 如果是需要按照创建顺序来讲，常量“abc”，则会在加载编译时构造常量池时在常量池中创建“abc”字符串对象，而new对象的构造函数是在运行时创建并复制常量池中的“abc”。还有一个运行时常量池，也就是说，在运行时创建的字符串对象，通过intern方法会在运行时常量池中创建字符串对象。

  2019-05-25

  **2

  **3

- ![img](https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  张三丰

  老师这里讲的首次遇到的引用添加到常量池中，能举个例子吗？ 在 JDK1.7 版本以后，由于常量池已经合并到了堆中，所以不会再复制具体字符串了，只是会把首次遇到的字符串的引用添加到常量池中；如果有，就返回常量池中的字符串引用

  作者回复: 假设有以下代码： String a1 = "11"; String a2 = new String("11") ； String a3 = a2.intern()； System.out.println(a1==a2); System.out.println(a2==a3); System.out.println(a3==a1); 以上代码，在JDK1.7以上，运行的结果为： false false true 这是为什么呢？ 这是因为String a1 = "11"中的 "11" 是一个常量，类加载时，该常量的字面量会保存在静态常量池中，也就是堆中，当类初始化时，该常量的引用会加载到运行常量池中，这就是“把首次遇到的字符串的引用添加到常量池中。 而 String a2 = new String("11") 则会在运行生成一个new String("11")对象，如果调用String a3 = a2.intern()，此时a2会判断运行常量池中已经存在字面量为"11"的引用了，则会直接返回"11"的引用，所以实际上a3的引用就是a1的引用。

  2019-10-24

  **

  **2

- ![img](https://static001.geekbang.org/account/avatar/00/17/1e/89/25b12054.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Andy

  String str = new String("abc");这个语句会在字符串常量池中和堆中都生成变量，但str指向堆中的变量；如果调用intern方法，则str指向字符串常量池中的变量，此时堆中的变量会被垃圾回收。  请问老师o(^o^)o我的理解对不？

  作者回复: 对的

  2019-10-21

  **

  **2

- ![img](https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  张三丰

  在字符串常量中，默认会将对象放入常量池；在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，复制到堆内存对象中，并返回堆内存对象引用。  首先将对象放进常量池，记为a1  同时堆内存又创建了个对象，记为a2 同时也会在常量池创建一个对象，记为a3 同时复制到堆内存对象中(请问复制的是什么？)，这个过程创建了3个对象？

  作者回复: 这里分两段来理解，前一段是"abc"常量在静态常量池中创建，并将引用存放在运行时常量池中，后一段则是new string对象的创建，此对象是在堆中创建的，该对象的字符串是复制的常量"abc"中的字符串，返回堆中对象的引用给a。所以是创建了两个对象。

  2019-08-23

  **

  **2

- ![img](https://static001.geekbang.org/account/avatar/00/0f/b4/3b/a1f7e3a4.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  ZOU志伟

  老师，有点不明白，intern()方法无论调用不调用，常量池都是会创建字符串的，hashTable都是会增大，何来谨慎使用？

  作者回复: 如果是字符串常量，是在常量池中创建字符串。假如是应用服务运行期间，通过数据库查询出的字符串，则不会在常量池中创建，而是在堆内存中创建。

  2019-07-05

  **

  **2

- ![img](https://static001.geekbang.org/account/avatar/00/13/55/e4/7061abd5.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Mr.J

  老师，String str1 = “abc”；String str2 = new String(“abc”)；str1对象存放在常量池，str1对象是指向常量池的引用，str2对象是在堆内存创建了对象，指向堆内存，同时会将“abc”复制到常量池？这个时候常量池中存着几个“abc”，两个？调用String str3 = str2.intern()方法，返回的是str1的常量？还是str2的

  作者回复: 这里纠正下，不是复制，而且赋值引用常量池中的字符串。常量池不会创建重复的字符串对象，所以只有一个abc字符串。所以你的第二个问题就是返回的常量池中的abc，不是属于谁的，它可以被大家引用。

  2019-06-11

  **

  **2

- ![img](https://static001.geekbang.org/account/avatar/00/13/16/cc/78a21848.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  空

  老师，java8还有字符串常量池吗，都整合到堆里面去了吧

  作者回复: 有的，java8字符串常量池是分配到堆中，并不代表字符串常量池就取消了。

  2019-05-30

  **

  **2

- ![img](https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  晓杰

  回答开篇的问题： str1会在常量池中创建一个对象 str2首先会在堆内存中创建一个对象，然后在加载类的时候在常量池创建一个字符串对象，同时复制到堆内存对象中，并返回堆内存对象的引用 str3会先去常量池中查看存在于该字符串相等的对象，因为str1已经在常量池创建了一个相同的对象，所以str1和str3相等。 综上：str1和str2不相等，str1和str3相等，str2和str3不相等

  2019-05-26

  **

  **2

- ![img](https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  -W.LI-

  老师你说的对!直接把char数组做入参创建的String对象里的value数组地址是不一样的。调用intern()方法后就一样了。是我搞错了，然后回到第一个问题的后半部分，我打印输出a==b是false。之前有看到char数组的地址是一样的。这说明new虽然在堆中新建了一个String对象，但是里面的char数组是复用的。这样做的目的是为了节约char数组的内存开销，然后String本身就是不可变对象，复用char数组不会带来问题。问题一:这个char数组是存放在哪的啊?堆还是常量池，其实我不知道常量池具体是个啥，课上老师说的类似hashmap，这样的话就是接近O(1)随机读取。不知道它能不能存char[]。问题二:复用char[]我猜是这么实现的new创建String时会去常量池中查找对应的String存在拿取char[]复用，如果这样的话其实char[]到底存放在哪不太重要。问题三:常量池的内存会回收么?突然觉得自己对常量池一无所知。。。常量池的生命周期一无所知。

  作者回复: char数组是存放在常量池中，常量是会在编译时生成字面量，在类加载时加载到常量池中。 这个存放位置还是重要的，这就相当于权职划分，每个位置都有自己的功能和职责。 常量池中的垃圾回收，也是垃圾回收器完成，只要没有根引用的对象，包括类信息等等，都会在回收期被回收掉。常量池中的常量一般是固定的，不像对中的对象。

  2019-05-26

  **

  **2

- ![img](https://static001.geekbang.org/account/avatar/00/0f/ee/64/2646f6ef.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  胖

  会在常量池存储字符串对象的时机 1.  调用String的intern; 2. 声明字符串字面常量; 3. 字符串直接常量相加，例如: String c = "a" + "b"; 会在常量池保存"ab"

  作者回复: 再补充一种，在new String("ab")时，也会创建一份在常量池，堆内存中对象会再引用常量池对象

  2019-05-26

  **

  **2

- ![img](03%20_%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8D%E5%AE%B9%E5%B0%8F%E8%A7%91%EF%BC%8C%E7%99%BEM%E5%86%85%E5%AD%98%E8%BD%BB%E6%9D%BE%E5%AD%98%E5%82%A8%E5%87%A0%E5%8D%81G%E6%95%B0%E6%8D%AE.resource/132.jpeg)

  余火

  String s1="123";字符串"123"已经被放入常量池，那要定义一个和s1一样的，用String s2=s1;不就好了，为什么还要用intern方法。推特的那个优化也一样，setCity(messageInfo.getCity())就好了，为什么要用intern呢，这里有些不懂，请老师指教一下，多谢。

  作者回复: 你好余火，我们在类对象中的String属性是在堆内存中开辟的地址空间，所以如果不用intern方法，新生产的对象中的String字段的属性是引用堆内存的地址，而堆内存中创建的字段即使value值一样也会开辟新地址空间。如果使用intern方法，则会引用常量池中的引用，而如果常量池中如果存在字符串对象，则复用，不会再创建了。

  2019-05-25

  **

  **2

- ![img](https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  业余草

  final 标示的一般为常量，按照老师说的 new String("abc").intern() 在常量池中也存在 abc，String str1 = "abc";通过字面量的方式创建，abc存储于字符串常量池中；是不是说用不用 final 都无所谓了？？请帮忙详细解答一下，谢谢！！！ 

  作者回复: 正是因为final，字符串才实现了不可变性，String内部的value已经被final修饰，所以我们不用再在编码时用final修饰。

  2019-05-25

  **

  **2

- ![img](https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  QQ怪

  老师讲的挺到位的，挺容易理解，之前忘记的现在又被老师点出来了，支持老师😁

  2019-05-25

  **

  **2

- ![img](https://static001.geekbang.org/account/avatar/00/0f/54/19/95ff4cbd.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  格非

  很想知道，字符串常量是如何进入到String Pool中的，class文件的字符串常量会放在常量池中，在类加载后，会进入运行时常量池，运行时常量池又是方法区的一部分，但是String Pool在jdk7之后是在堆上分配的，方法区和堆应该是物理上隔离的两块内存区域，那么这个字符串常量是如何进入到堆中的呢？

  作者回复: 方法区和堆只是一种逻辑分区，是一种规范。方法区中的一部分是在物理堆内存空间的，而另外一部分则是在本地内存中。

  2019-07-15

  **

  **1

- ![img](03%20_%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8D%E5%AE%B9%E5%B0%8F%E8%A7%91%EF%BC%8C%E7%99%BEM%E5%86%85%E5%AD%98%E8%BD%BB%E6%9D%BE%E5%AD%98%E5%82%A8%E5%87%A0%E5%8D%81G%E6%95%B0%E6%8D%AE.resource/132-1662425531298-579.png)

  Geek_c33c8e

  String a=" aa"，这种方式创建，aa字符串会被回收，还是一直存在于常量池中？既然String a=" aa"这种方式会把aa字符串加入到常量池，那intern的作用好像没用了啊，不用这个方法，也可以达到添加到常量池的目的，这里有疑惑，还请大佬解答下呗

  作者回复: 这里是字符串常量，而在运行时字符串对象创建时，是不会放到常量池中的。这个时候使用intern可以将字符串在运行时常量池中创建。 如果还有疑惑，可以先看下21讲。

  2019-07-09

  **2

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/18/63/15/cbbbdba0.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  纯风

  你好啊  我不了解堆和栈  能不能给我说下  创建的对象在堆中，栈中放的是对象的引用地址吗  还有使用intern()方法   和   创建的对象放在常量池中 这两者是什么关系

  作者回复: 你好，纯风。如果不了解JVM内存模型，建议可以留意21讲，这里会详细讲解。

  2019-07-05

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/16/62/49/6332c99b.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  man1s

  老湿，那个图上最后一种情况是说运行时创建String不使用常量池的空间吗？ 表示怀疑

  作者回复: 对的，运行时动态创建的字符串对象只有通过intern才会进入常量池。如果还有疑问，可以复习下常量池的作用。

  2019-06-05

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/0f/60/13/efb4ea95.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  哇

  老师，现在还有需要在变量用完后，手动设置变量为null的场景吗？

  作者回复: 不需要手动设置为null，虚拟机会帮我们自动回收。除非对象占用内存大或方法的栈帧长时间不能被回收的情况，我们手动设置对象为null，能提高回收效率。

  2019-06-01

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/10/ef/59/03df5f41.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Pason

  在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，意思是只要创建了字符串变量，就会在常量池中有。那么不是和intern方法矛盾了吗，如果调用 intern 方法，会去查看字符串常量池中是否有等于该对象的字符串，既然前面已经说了创建变量会在常量池中创建，那么intern方法的时候还有必要判断吗？

  作者回复: 你好 Pason，如果是new String("abc")这种方式，就会在编译加载类时在常量池中创建"abc"，在new时，在堆中创建String对象。但在程序运行时动态创建字符串时，只会在堆中创建字符串对象，这个时候就用到intern，就会去常量池创建对象了。 这样解释能否理解呢？

  2019-05-31

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/12/80/f1/19c42f40.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  张华清

  老师好，之前我的理解是对于string对象的创建：String a="a" 这种编译时期创建的对象是放入常量池，然后返回常量池对象引用。对于String b =new String("b")这种运行时期创建是放入堆内存的然后返回堆内存对象的引用，不会放入常量池，只有在调用intern方法的时候才会把b放入常量池。 所以对老师的这句话有点疑惑：“在一开始创建 a 变量时，会在堆内存中创建一个对象，同时会在在加载类时，在常量池中创建一个字符串对象”

  作者回复: 你好，你理解后半段有一点问题。new String()是在执行代码的时候在堆中创建的对象，但new String("b")中的"b"，是在代码编译时，生成了字面量，并且在类加载时，放到了常量池中。在new String之时，会调用String的构造函数引用常量池中的字符串。

  2019-05-29

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/16/65/c3/5324b326.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  半清醒

  这个专栏的老师是我在极客时间上看到最为负责的老师了，每个有疑惑的提问，老师都是认真回答了，不是说别的老师做的不好，而且您做的更好!!另外通过这篇文章也算更加理解String这个类了。

  作者回复: 互联网教学应该是这样的，达到一对一的教学效果，大家在极客时间一起学习成长。

  2019-05-28

  **2

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/11/f8/ca/1a1e190a.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Nu11PointerEx

  老师你好，堆对象在没有可达引用的时候在下一次gc就会被回收，那常量池是什么时候回收的呢？

  作者回复: 在没有引用时，常量池中的对象也会被回收。

  2019-05-28

  **

  **1

- ![img](data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QN5aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0MCA3OS4xNjA0NTEsIDIwMTcvMDUvMDYtMDE6MDg6MjEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YWE3YmZhMDItMzBhMC00MDg3LTg3MmYtOGMwMjMxNjNhZWRjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI2MTlEODM3NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2MTlEODM2NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTYyRTNCMDNBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTYyRTNCMDRBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRm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)

  胖妞

  实际操作字符的时候还真没怎么注意过！因为日常的开发过程中，都是先测试一下能用就直接过去了！以后需要注意了！

  作者回复: 是的，特别用到复杂的正则表达式时，要多留意，可以在校验回溯的网站校验下表达式。

  2019-05-27

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/16/82/97/b26628dc.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  码农 布莱恩特

  老师，有个问题请教下，数据库机器内存使用率一直超过80%，我该如何定位和优化

  作者回复: 你好 布莱恩特，可以查看下是否有运行的sql阻塞了，可以通过在mysql中执行 show full processlist查看。 也有可能mysql配置缓存过大，检查下mysql的缓存配置。

  2019-05-27

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/17/8a/59/d5aec34a.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  胜

  老师我今天遇到一个问题，请教一下使用fast json的JSONObject.parseObject(ss,parameterizedType)时产生过多IdentityHashMap.Entry导致内存泄露，请问该怎么解决？

  作者回复: 看了下Github上也有人遇到跟你一样类似的问题，git上给出的建议是更新到最新版本。

  2019-05-26

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/17/96/42/00456f92.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  some_bird

  关于字符串：String str2= new String("abc") 中变量str2在栈中指向了堆中一个存储了内容为”abc“的对象，还是指向了堆中存放地址（指向字符串常量池中"abc”的地址）的对象

  作者回复: 你好 some_bird，指向队中创建的内存对象，我们可以通过反编译字节码文件，可以发现在创建完对象，通过JVM返回指令返回的是在内存中创建的对象引用。

  2019-05-25

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  -W.LI-

  老师好!jdk8环境下，观察了下。不管是直接赋值还是new创建新对象，String对象的value对应的char数组地址都是同一个，这么做就是不论字符串多大，重复new只会多消耗string对象必须得的16字节内存是么?。jdk8以前常量池在方法区中，属于永久代，GC不会回收这一部分空间是么?jdk8对常量池做了改动，放在了堆中，在堆中会被GC回收。我想知道为啥要做这个调整。常量池也是在新生代创建，然后几次ygc以后进入老年代么?

  作者回复: 这位同学 你好 ，不好意思呀，我没有理解你的第一个问题，你在问substring在java8创建新对象的问题吗？ 常量池放在堆中，是为了解决之前放在方法区时，由于常量池空间大小有限，存储对象过多导致内存溢出问题。也会存在垃圾回收，但与堆的垃圾回收不一样，这里不会进入老年代，而是直接回收。

  2019-05-25

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/11/67/0e/2a51a2df.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](https://static001.geekbang.org/resource/image/eb/56/eb5afbf568af2917033e5a860de0b756.png?x-oss-process=image/resize,w_14)

  Eric

  当类或接口创建时 会根据. class文件里面的常量池表构造运行时常量池 可以认为在调用new String("abc")很早很早之前 运行时常量池已经有了abc这个字符串常量吗？ 这里ldc只是把对应的字符串常量的reference类型的数据压栈 作为后面的invokespecial指令来调用构造方法的第一个参数？ 理解为ldc指令时在运行时常量池创建abc字符串常量是否合适？还是我的理解存在错误？

  作者回复: 你好 Eric，从反编译文件可以看出， 字符串“abc”在编译时，已在常量池中创建，这个没问题。如果是变量，这个需要在运行时在常量池中创建。 Idc是JVM的入栈指令，在这里会将常量池中的“abc”入栈，invokespecial是JVM调用构造函数的指令，此时会调用String的构造函数，“abc”作为参数。之后通过出栈指令返回引用给s1。 大概就是这个流程，有疑问欢迎一起探讨。

  2019-05-25

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/10/cf/b5/d1ec6a7d.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Stalary

  老师，请问indexOf替换Split意思是先indexOf找到切割点再用subString吗？

  作者回复: 你好 Stalary，对的，虽然这种方式比split方法多一些代码，但在某些情况下性能要比split方法好

  2019-05-25

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  WL

  请问老师啥叫正则表达式的回溯问题, 为啥会产生回溯问题, 在网上找了半天资料没太看懂

  作者回复: 你好 WL，下一讲我将会详细讲正则表达式的回溯。

  2019-05-25

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/12/27/1d/1cb36854.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  小辉辉

  false  false  true ，第一个和第二个为false是因为比的是堆和常量池两个不同的对象，第三个为true因为比的是常量池中同一个对象。

  作者回复: 理解到位！

  2019-05-25

  **

  **1

- ![img](https://static001.geekbang.org/account/avatar/00/0f/63/cb/7c004188.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  和你一起搬砖的胡大爷

  老师把基础撸一遍再讲工具技巧是蛮好的

  2019-05-25

  **

  **1

- ![img](data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QN5aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0MCA3OS4xNjA0NTEsIDIwMTcvMDUvMDYtMDE6MDg6MjEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YWE3YmZhMDItMzBhMC00MDg3LTg3MmYtOGMwMjMxNjNhZWRjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI2MTlEODM3NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2MTlEODM2NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTYyRTNCMDNBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTYyRTNCMDRBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRm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)

  走路顺拐

  请教一下：为什么把省市区单独拎出一个类就节省内存了

  2022-06-28

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](https://static001.geekbang.org/resource/image/eb/56/eb5afbf568af2917033e5a860de0b756.png?x-oss-process=image/resize,w_14)

  杯莫停

  String a = new String("abc"); String b ="abc"; 编译过程中:会将“abc”放入常量池，变量a指向的对象其实不是“abc”而是对常量池中char[]的引用。所以虽然打印ab都是“abc”，但是它们指向的不是同一块内存空间。而当a.intern();后a的引用被直接指向了常量池中“abc”。所以此时a==b，new的对象由于没有引用会被回收调; 运行时：动态new一个字符串对象，对象内存中存放的就是“abc”，没有去引用常量池，常量池里面也没有“abc”，当然由于a和b指向的内存空间也是不相同的，所以此时a != b。也只有别的对象用a.intern();后a==b。

  2022-06-24

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/2e/10/29/6f6beaf5.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](https://static001.geekbang.org/resource/image/eb/56/eb5afbf568af2917033e5a860de0b756.png?x-oss-process=image/resize,w_14)

  红色十号

  String str1= "abc"; String str2= new String("abc"); String str3= str2.intern(); 老师 这里的str1指向的还是str2里的数组里的还是str3指向的“abc”都是常量池里的同一个吧

  2022-06-19

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  keep_it_real

  刚开始我以为对象的内存地址就是hashCode我发现我错了    String a = "abc";    String b = new String("abc");    String c = b.intern(); 发现这三个变量打印出的hashCode是一样的，而“b==c”却是false。才想起，只有Object的hashCode才是真正的内存地址，而String的hashCode是重写了的。 用System.identityHashCode(a)取得的hashCode才是真正的内存地址

  2022-05-12

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/1e/d1/b0/f4e91c7b.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  吴亦凡

  有个问题啊，既然string会存放在常量池中，我不明白为什么老师你在举例twitter优化的案例中，要另外声明一个对象存放属性city,region,cityCode,  我难道直接调用 对象location.setCity(location.getCity().intern()); 会有问题么？为什么需要再声明一个 特殊带三个属性的SharedLocation 对象呢？

  2022-05-03

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/24/cf/60/5adef06a.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  王盛东

  老师您好，请教个问题， 分析内存占用的时候经常发现 char 和 string 占用内存最多，这个有没有具体的分析方式， 还是用后文提到的 MAT 来分析下profile？ $ jmap -histo:live 1 | head -20  num     #instances         #bytes  class name ----------------------------------------------   1:        117866       69696352  [I   2:        637423       52429160  [C   3:        635331       15247944  java.lang.String   4:        128302       13684800  [Ljava.lang.Object;

  2022-04-08

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/2a/e0/0b/6f667b2c.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](https://static001.geekbang.org/resource/image/eb/56/eb5afbf568af2917033e5a860de0b756.png?x-oss-process=image/resize,w_14)

  枫林血舞![img](https://static001.geekbang.org/resource/image/89/43/89yyff4c4c2e2b73ce4931bb01a6a943.png)

  交作业：特意跑了一下：false false true 原因： String str1 = "abc"; // 作为字面量，str1是指向到字符串常量池中的"abc"的地址 String str2 = new String("abc"); // str2指向值为“abc”的String对象在堆区的地址 String str3 = str2.intern(); // 调用intern()方法，如果常量池没有"abc"，会将堆区的"abc"地址拷贝到常量池并返回；如果有，直接使用值为"abc"的地址；所以str3指向的地址和str1是一致的

  2022-03-09

  **

  **

- ![img](03%20_%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8D%E5%AE%B9%E5%B0%8F%E8%A7%91%EF%BC%8C%E7%99%BEM%E5%86%85%E5%AD%98%E8%BD%BB%E6%9D%BE%E5%AD%98%E5%82%A8%E5%87%A0%E5%8D%81G%E6%95%B0%E6%8D%AE.resource/132-1662425531299-600.jpeg)

  于无涯

  请教下老师，shardLocation在里面信息一致的情况下实现复用不就完了么，这个跟intern有啥关系？是下面这样么？ 1. 相同SharedLocation肯定要复用 2. 不同SharedLocation里面String相同的，String本身也要复用

  2021-12-27

  **

  **

- ![img](http://thirdwx.qlogo.cn/mmopen/vi_32/9dTx3AVia8Lbx2iaP3dibFvoic99ODDENbp5TAfQOuD4co82C1BzNjU3Uobcqc1CZ3e58qzd3bia0vibt6M0llxRWqicQ/132)

  Geek_f24e8e

  老师不知道理解的对不对，intern不会减少创建成本，只会在创建后找到常量中已经存在的对象把引用替换过来，让新创建的对象可以被回收，本质是一种享元模式

  2021-12-13

  **

  **

- ![img](data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QN5aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0MCA3OS4xNjA0NTEsIDIwMTcvMDUvMDYtMDE6MDg6MjEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YWE3YmZhMDItMzBhMC00MDg3LTg3MmYtOGMwMjMxNjNhZWRjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI2MTlEODM3NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2MTlEODM2NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTYyRTNCMDNBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTYyRTNCMDRBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7/7gAOQWRvYmUAZMAAAAAB/9sAhAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAgICAgICAgICAgIDAwMDAwMDAwMDAQEBAQEBAQIBAQICAgECAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwP/wAARCADuAO4DAREAAhEBAxEB/8QAfAABAAICAwEBAAAAAAAAAAAAAAYHBAgBAwUCCgEBAAAAAAAAAAAAAAAAAAAAABAAAgIBAgIECwQJBQAAAAAAAAECAwQRBSEGMWESF0FRgVITk+MUVJTUIkJiB5EyhBVFhbXFNnFygqJTEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwD9vAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGHmbhg7fD0mbl4+LF69l32wrctPBCMmpTfUk2BG7ue+Wqm4rNsua6XTi5DWvVKyutPyaoDmnnrlq19l506W9NPTYuSk2/xQqnGPlaQElxM7Dzq/S4WVj5VfhlRbC1Rfil2G3GXU9GBlAAAAAAAAAAAAAAAAAAAAAAAAAAAA4bUU5SajGKblJtJJJattvgkkBVHMnP8AJSswtilHSLcLdxcVLV9DWHCWsdF/6ST1+6uiQFW35F+VbK/Jutvum9Z23WSssk/xTm3JgdIADvx8nIxLY34t9uPdD9W2myVc1412otPR6cV0MC1uWufvTTrwd8cITlpCrcYpQhKT4KOXBaQrbf346R8aXFgWmnrxXFPimvCAAAAAAAAAAAAAAAAAAAAAAAAAAFUfmBzHKLexYVjjrGMtxsg+LU12oYia6E4tSn400vOQFTAAAAAAAuDkDmSWRFbHm2OVtUHLb7ZvWU6oLWeK2+LdMV2ofgTX3UBaAAAAAAAAAAAAAAAAAAAAAAAABi52XDAwsvNs4wxce6+S10cvRQlNQX4ptaLrYGr+RfblX3ZN8nO7Itsutk/vWWSc5Pq4sDpAAAAAABlYWXbgZeNmUPS3Guruhx0TcJJ9mWnTGa4NeFMDaDGvrysejJqeteRTVfW/HC2EbI/9ZAdwAAAAAAAAAAAAAAAAAAAAAACJc8WurlncOzwdrxateqeVT2v0wTXlA18AAAAAAAAAbFcnXSu5a2mcnq402U/8cfJuoivJGtASYAAAAAAAAAAAAAAAAAAAAAABFOdqXdyzuSjxlWse7yVZVMp/or1YGvQAAAAAAAADY3lGiWPy3tNclo5Yzv8AF9nJusyYvyxtQEjAAAAAAAAAAAAAAAAAAAAAAAdGVj15eNkYty1qyaLaLF4exbCVctOvSXADWDNxLsDLycLIj2bsa6dM/E3B6KUfHCa0afhTAxQAAAAAAZ224Nu55+LgUp+kyboV6pa9iDetljXm1VpyfUgNnqaoUU1UVLs101wqrj4oVxUILyRQHYAAAAAAAAAAAAAAAAAAAAAAAAVrz5yzPNh++cGtzyaK1HNpgtZX0QX2bopcZW0R4NdLhp5ujCmQAAAAAAXbyLyzPbaXumdW4ZuVX2aKprSWNjS0bck+Mbr9FqumMeHS2gLDAAAAAAAAAAAAAAAAAAAAAAAAAACuOZOQ6c+dmbtDrxcubc7cWX2cbIm+LlW0n7vbLw8OxJ+bxbCpM7bM/bLXVn4l+NPVpekg1CenhrsWtdseuLaAwQAHo7ftO47raqsDEuyZapSlCOlVevhtul2aql/uaAt3lrkWjbJ15u5yry86Gk6qYrXFxpripfaSd90X0NpRi+hNpSAsIAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4sqrug67a4W1y/WhZCM4P/AFjJNMDw7eVuXrm5T2jCTfT6Kr0C49VLrQHNPK/L1ElKvaMJtcU7alfo/Gle7FqB7cK4VQVdcIVwitIwhFQhFeJRikkgPsAAAAAAAAAAAAAAAAAAAAAAAAAY2XmYuBRPKzL68aiv9ay2XZjq+iKXTKcvBFJt+BARGf5g8uRk4q3LsSeinDFkoy60pyhPR9aQHz3h8u+dm/K+0Ad4fLvnZvyvtAHeHy752b8r7QB3h8u+dm/K+0Ad4fLvnZvyvtAHeHy752b8r7QB3h8u+dm/K+0Ad4fLvnZvyvtAMjG575cybY1PKtxnJpRnk0Trq1fglZHtxrXXLRLxgTCMozjGUZKUZJSjKLTjKLWqlFrVNNPgwOQAAAAAAAAAAAAAAAAAAAAUZ+YW43ZG9ywHOSx9vqpUa9fsu7IphkTta8MnCyMepLrYECAAAAAAAAAAAF0/lxuN2Tt+Zg2zlOO320uhyerhTlK1qpPzYWUSa8Xa06NALHAAAAAAAAAAAAAAAAAAAABr3zx/lO6fsX9OxAImAAAAAAAAAAALY/K/+Ofyz+4AWwAAAAAAAAAAAAAAAAAAAADXvnj/ACndP2L+nYgETAAAAAAAAAAAFsflf/HP5Z/cALYAAAAAAAAAAAAAAAAAAAABVvMfJG7bxvOZuONkbdCjI937Eb7cmNq9DiUUS7Ua8S2C1nU2tJPgB4fdrvvxe0+vzPoAHdrvvxe0+vzPoAHdrvvxe0+vzPoAHdrvvxe0+vzPoAHdrvvxe0+vzPoAHdrvvxe0+vzPoAHdrvvxe0+vzPoAHdrvvxe0+vzPoAHdrvvxe0+vzPoAHdrvvxe0+vzPoAJvyby1ncvfvH323Et989z9F7rZdPs+7+9dvt+loo019OtNNfD0ATcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//Z)

  hwg

  String str = "abcdef"; for(int i=0; i<1000; i++) {      str = str + i; }编译后没有改变，老师能解析一下吗

  2021-09-03

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/16/ce/5e/b103d538.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](https://static001.geekbang.org/resource/image/eb/56/eb5afbf568af2917033e5a860de0b756.png?x-oss-process=image/resize,w_14)

  大明猩

  String.intern节省内存这个确实牛，确实基础太重要了！

  2021-09-03

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/0f/ec/27/f708ba52.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  冷夜飞雪

  如果程序中存在大量不重复的字符串，请问该如何优化呢？有具体的方案吗？

  2021-05-07

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/25/20/1d/162c8ad4.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  黄宝玲

  老师，请教一下，上文字符串变量的累计，我用JDK8编译后是这样 String var1 = "abcdef";         for(int var2 = 0; var2 < 1000; ++var2) {            var1 = var1 + var2;        } ，这是为什么呢

  2021-04-07

  **

  **

- ![img](http://thirdwx.qlogo.cn/mmopen/vi_32/acjcuuTycbZx6WWxOQZV99LDtLK3HpTtUxOayuSbVtEoU87bDMyn82DKxSszpz6um9UvSeZ59VFWq5NSb2oHdw/132)

  孟凡赏

  老师，您好，看了不少评论，我不是很明白new String("ja") + new String("va") 这种对象是怎么构成的， 比如下面的代码 在jdk11中 ，如果创建了 s2 再 intern 则 false，不创建 则 true String s1 = new String("ja") + new String("va"); //String s2 = new String("java"); s1.intern(); String s3 = "java"; System.out.println(s1 == s3); 我就不是很明白 在jdk8中无论创不创建 s2 均为  false

  2021-02-05

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/24/6b/f7/b2007360.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Corey

  老师，我这边遇到一个关于intern()问题。我描述一下：  接口做了什么事： 1.查询数据库实体类 大于1000条数据 2.用steam流进行计算此实体类（例如区域字段，以区域分组有多少条在A区多少条在B区） 3.存储结果存一个表大约10条左右的分析数据 问题我学习了你的String之后发现线上环境统计数据可能一次查几十万所有我就给实体类添加了intern（）方法例如区域字段     /**     * 区编码     */    private String districtCode;     public void setDistrictCode(String districtCode) {        if (evtStatusText != null) {            this.districtCode = districtCode.intern();        }    }     public String getDistrictCode() {        if (null == districtCode){            return null;        }        return districtCode.intern();    } 我的想法是mybatis 存储数据依赖实体类的set方法这样程序查数据存在List过程中所有的区域字段都指向常量池的引用， 使用get进行判断的时候直接取也能节约储存空间但是我是用ab压测工具的时候使用jconsole发现我加了intern()方法反而内存使用更多。是我的方法用错了吗。 求翻牌

  2021-01-21

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/15/ca/4b/c1ace3aa.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  蚝不鱿鱼

  专栏里回复率最高的老师，没有之一！感谢老师的辛勤付出！

  2020-11-06

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](https://static001.geekbang.org/resource/image/eb/56/eb5afbf568af2917033e5a860de0b756.png?x-oss-process=image/resize,w_14)

  与路同飞

  虽然已经时间这么久了，还是希望老师回答，评论区中没有相关问题。环境JDK13 String s1 = new String("1") + new String("1");        s1.intern();        String s2 = "11";        System.out.println(s1 == s2); 这个打印是false 将1改成2，11改成22. String s1 = new String("2") + new String("2");        s1.intern();        String s2 = "22";        System.out.println(s1 == s2);打印又变成true了。这是咋回事。想了一晚上了

  2020-09-22

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/18/03/74/26d6e6e7.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  。

  老师，请教下，能理解使用intern的方式和场景，也能理解双引号的方式创建字符串。但不太理解为什么JDK要提供new String()方式，只提供双引号方式直接用常量池的值不就好了，也不用再为new String方式提供intern的优化？

  2020-09-02

  **

  **

- ![img](data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QN5aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0MCA3OS4xNjA0NTEsIDIwMTcvMDUvMDYtMDE6MDg6MjEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YWE3YmZhMDItMzBhMC00MDg3LTg3MmYtOGMwMjMxNjNhZWRjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI2MTlEODM3NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2MTlEODM2NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTYyRTNCMDNBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTYyRTNCMDRBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRm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)

  走路顺拐

  java8 不是把常量池放到本地内存了吗？

  2020-07-30

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/12/04/04/0af56558.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Jc.Chen

  老师你好，可能我学的不够深，我想请问一个问题： 文中“对象在内存中是一块内存地址，str 则是一个指向该内存地址的引用”这个表述，怎么理解呢？我一直认为的是“对象是内存保存的数据；str则是一个内存地址”。

  2020-07-12

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/1a/81/88/72256ea4.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  欢乐马

  老师，我觉得您在文章里还是应该强调一下使用string intern的场景。根据这篇blog，intern的性能是比较差的，java7后虽然default池设成了60000+，但还是在一些情况下很容易占满，大于这个值后如果再增加就会很快降低性能

  2020-07-07

  **1

  **

- ![img](data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QN5aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0MCA3OS4xNjA0NTEsIDIwMTcvMDUvMDYtMDE6MDg6MjEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YWE3YmZhMDItMzBhMC00MDg3LTg3MmYtOGMwMjMxNjNhZWRjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI2MTlEODM3NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2MTlEODM2NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTYyRTNCMDNBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTYyRTNCMDRBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRm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)

  耿嘉艺

  1）String str1 = "abc"；如果常量池中不存在字符串abc，则创建，否则返回引用 2）String str2 = new String ("abc")；同时在常量池和堆上创建对象，通过构造方法将常量池中的字符串abc作为char[]数组，并返回堆上的引用给str2 ，此时str2 != str2.intern() 3）String str3 = new String("1") + new String("1")；str3.intern()；常量池中存在字符串1，但是不存在字符串11，因此会将str3在堆上的引用复制到常量池中，也就是str3 = str3.intern()，此时常量池中不存在字符串11，存在的是11在堆上的引用

  2020-06-18

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/15/f4/8f/6b3d4370.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  瑶老板的小弟

  字符串常量池到底存的引用，还是字符串。 以下说明是指在常量池直接创建字符串？ 中使用第一种方式创建字符串对象时，JVM 首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。 以下说明是指堆引用常量池？ 在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，String 对象中的 char 数组将会引用常量池中的 char 数组，并返回堆内存对象引用。 《深入理解Java虚拟机》里又说的是首次出现是在堆里创建的对象，然后常量池记录String实例引用。 所以到底是谁指向谁。。

  2020-06-09

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/10/46/42/6e0f3754.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Sunny

  string s1 = new string(“1”)+new string(“1”); s1.intern; string s2=“11”; s1==s2为什么是true呢，我理解s1指向的对象，s2指向的常量池地址才对啊？ 然后 string s1 = new string(“1”); s1.intern; string s2=“11”; s1==s2又是false了，区别在哪？ 对于这个问题，看了老师的解答 （而第二种，用于"11"在类加载时，已经存在静态常量池中） 这句话没理解，难道第一种情况s2 ="11" 不会放到常量池中吗？

  2020-06-09

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/15/f4/8f/6b3d4370.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  瑶老板的小弟

  String构造器new String(“abc”),这个构造器创建的是字符串的“副本”。 1.7以后，这个new String（“abc”）如果abc是首次出现，会创建几个对象？

  2020-06-09

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/11/29/a9/4c114382.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  qpy

  “在 JDK1.7 版本以后，由于常量池已经合并到了堆中”，看了jvms8，字符串常量池（确切的说应该是运行时常量池）仍然是在方法区呀，为什么说合并到堆里面了呢？ §2.5.5 ...... ##运行时常量池由方法区分配 Each run-time constant pool is allocated from the Java Virtual Machine's method area  ...... §5.1 ...... ##constant_pool table用来构建每一个类型的运行时常量池 The constant_pool table (§4.4) in the binary representation of a class or interface is used to construct the run-time constant pool upon class or interface creation (§5.3). ...... ##constant_pool table中包含string literal In addition, certain run-time values which are not symbolic references are derived from items found in the constant_pool table: • A string literal is a reference to an instance of class String, and is derived from a CONSTANT_String_info structure (§4.4.3) in the binary representation of a class or interface. The CONSTANT_String_info structure gives the sequence of Unicode code points constituting the string literal. ......

  2020-06-07

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/10/c5/2d/1eebfc3c.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  GaGi

  老师请问下， String a =new String("abc").intern(); String b = new String("abc").intern(); 这两行代码在jdk1.7中，a引用是指向String对象的char数组，也就是说，a引用其实是指向字符串常量池的"abc"的引用； 那么b引用其实也是指向常量池中的"abc"引用，也就是说，当发生gc时，由于第一个String对象的char数组是被a,b引用着，因此不会被gc，但是第二个String对象由于没有引用指向，因此会被回收； 这样理解是正确的吗？

  2020-04-30

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/17/8e/4a/470db251.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  冰飞江南

  老师，您举的Twitter例子中，我怎么想也想不到为什么使用intern后，内存有20G减低为几百M，到底是什么内存被回收了？请指教，谢谢了。

  2020-04-06

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/17/8e/4a/470db251.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  冰飞江南

  老师，实在想不出ntern()为何能节约内存，求指点。 如例子中： messageInfo.getCity() 返回的字符串是“广州”的对象应用地址为“gz”，那么 messageInfo.getCity().ntern()返回的地址也是"gz"啊。为什么能节约内存呢？

  2020-04-06

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/16/b4/63/21902253.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Siping

  大部分人都不注意的细节

  2020-04-04

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/0f/c5/6a/7f858f1f.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](https://static001.geekbang.org/resource/image/eb/56/eb5afbf568af2917033e5a860de0b756.png?x-oss-process=image/resize,w_14)

  白不吃![img](https://static001.geekbang.org/resource/image/8a/95/8ac15yy848f71919ef784a1c9065e495.png)

  老师我有个疑问，是不是每一个String str = "aaa"，都会被放到字符串常量池？那intern()方法不是多余的，因为就算不用intern()方法，下一个String str2 = "aaa"，str2也会自动去关联字符串常量池的引用，因为str==str2

  作者回复: 在常量的这种情况下是多余的

  2020-03-29

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/0f/c5/6a/7f858f1f.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](https://static001.geekbang.org/resource/image/eb/56/eb5afbf568af2917033e5a860de0b756.png?x-oss-process=image/resize,w_14)

  白不吃![img](https://static001.geekbang.org/resource/image/8a/95/8ac15yy848f71919ef784a1c9065e495.png)

  老是我有个疑问，运行常量池不是在方法区么，1.8之后字符串常量池不是放到元空间了么，怎么文章里面说常量池优化到堆了？是我理解的有问题么

  作者回复: 方法区只是一个逻辑分区，这里说的是在堆中分配的内存空间，在逻辑分区中，还是常量池还是属于方法区。

  2020-03-29

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/19/cc/23/6b17fe26.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Nicko

  请问字符串常量池会有大小限制吗，调用大量的intern会不会导致溢出啥的

  作者回复: 目前这个常量池已经在堆中分配，所以只要不超过堆内存大小，就不会内存溢出

  2020-03-07

  **

  **

- ![img](03%20_%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8D%E5%AE%B9%E5%B0%8F%E8%A7%91%EF%BC%8C%E7%99%BEM%E5%86%85%E5%AD%98%E8%BD%BB%E6%9D%BE%E5%AD%98%E5%82%A8%E5%87%A0%E5%8D%81G%E6%95%B0%E6%8D%AE.resource/132-1662425531300-620.jpeg)

  赵伟

  问一下，字符串String a = "a"; 这种方式是a被赋值为 常量池中的的引用，使用intern也使用常量池中的引用，使用中全部使用 String a = "a";  这种方式，是不是intern就没用了

  作者回复: 是的

  2020-01-21

  **

  **

- ![img](http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIy5ULaodUwsLoPuk1wd22hqXsaBbibNEqXM0kgrCTYDGKYQkZICYEyH9wMj4hyUicuQwHdDuOKRj0g/132)

  辉煌码农

  new String("helleo")的时候，如果hello在常量池中不存在，hello这个字符串回存到对内存还是常量池呢。

  作者回复: 在 JDK1.7 版本以后，由于常量池已经合并到了堆中，所以不会再复制具体字符串了，只是会把首次遇到的字符串的引用添加到常量池中；如果有，就返回常量池中的字符串引用。

  2020-01-16

  **

  **

- ![img](data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QN5aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0MCA3OS4xNjA0NTEsIDIwMTcvMDUvMDYtMDE6MDg6MjEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YWE3YmZhMDItMzBhMC00MDg3LTg3MmYtOGMwMjMxNjNhZWRjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI2MTlEODM3NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2MTlEODM2NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTYyRTNCMDNBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTYyRTNCMDRBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRm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)

  地下城勇士

  我们可以用 String.indexOf() 方法代替 Split() 方法完成字符串的分割。为什么indexOf方法能代替Split方法，我刚转Java，希望老师举个例子

  作者回复: 假设我们要替换将aabbcc中的bb替换为dd： 		   String testStr = "aabbcc"; 	   String splitStr = "bb"; 	   String replaceStr = "dd"; 	   int index = testStr.indexOf(splitStr); 	   String replacedStr = testStr.substring(0, index) + replaceStr +testStr.substring(index + splitStr.length(), testStr.length()); 	    	   System.out.print("输出：" + replacedStr);

  2019-12-12

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/0f/42/65/f444ea39.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  grandcool

  老师您好，运行时动态创建字符串只会在堆内存中新建一个对象，那new String("abc")这种不是运行时动态创建吗

  作者回复: 是的

  2019-11-21

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/16/43/bc/59d0720b.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](https://static001.geekbang.org/resource/image/eb/56/eb5afbf568af2917033e5a860de0b756.png?x-oss-process=image/resize,w_14)

  gaga

  “在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，复制到堆内存对象中，并返回堆内存对象引用。” 常量池中中创建的是字符串还是字符串对象？ 文中说的字符串对象是指String对象吗

  作者回复: 这里指的是字符串，字符串对象指的是String对象。

  2019-11-10

  **2

  **

- ![img](data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QN5aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0MCA3OS4xNjA0NTEsIDIwMTcvMDUvMDYtMDE6MDg6MjEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YWE3YmZhMDItMzBhMC00MDg3LTg3MmYtOGMwMjMxNjNhZWRjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI2MTlEODM3NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2MTlEODM2NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTYyRTNCMDNBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTYyRTNCMDRBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRm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)

  Geek_e70286

  "在字符串常量中，默认会将对象放入常量池；在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，复制到堆内存对象中，并返回堆内存对象引用。" 明明是赋值引用, 但是字面上给人理解是复制一个新的副本... 这么久了编辑稿不更新啊...    public String(String original) {        this.value = original.value;        this.hash = original.hash;    }

  作者回复: 感谢纠正

  2019-11-08

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  考休

  如果在多线程编程中，String 对象的拼接涉及到线程安全，你可以使用 StringBuffer。但是要注意，由于 StringBuffer 是线程安全的，涉及到锁竞争，所以从性能上来说，要比 StringBuilder 差一些。 老师，这个地方写错了，最后一句应该是要比StringBuffer差一些。

  作者回复: 再次确认下，没有哦。

  2019-11-07

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  张三丰

  老师，这句话能否再详细讲讲，对象已经在堆内存中创建了，为何还要把常量池中的对象再复制过去？复制过去的是什么？难道是引用？ “在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，复制到堆内存对象中，并返回堆内存对象引用”

  作者回复: 这里说的是前面这个例子： String a =new String("abc").intern(); String b = new String("abc").intern();         if(a==b) {    System.out.print("a==b"); } new String("abc")是一个创建对象操作，而常量“abc”本身是在常量池中，但new String对象时，需要复制该常量的字符串abc到堆内存的对象中。

  2019-10-24

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/14/eb/d7/712912a7.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  mumu

  老师您好，文中讲1.7后常量池合并到堆中了，常量池不是在方法去吗？还是说常量池是引用，然后对象都在堆里面？

  作者回复: 此处的方法区和堆不是一个概念，方法区是指逻辑分区，而堆是指物理空间，常量池在逻辑分区上是属于方法区的，但实际分配的物理空间是堆中分配的。

  2019-10-15

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/0f/63/77/423345ab.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Sdylan

  打卡，2019.10.09 。关键点常量池（itern方法）与new 在堆中的分配情况

  2019-10-09

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  钱

  课后思考及问题 老师讲解的很棒，通俗易懂，同也能看出夯实基础的重要性。 夯实基础 - 结合实战 - 实现进阶——这个观点十亿个赞同，第一步菜和牛的基本都是以基础扎实与否为分水岭的。 请教几个问题 1：几M内存能存下几十G的数据，这个老师具体验证过没？怎么验证的？怎么知道他不是在吹牛逼？ 2：一个字符串的极限长度有多大？使用不同的方式创建这个极限值是一样的吗？我的理解，是受限于常量池或者堆内存空间的老年代的空间大小限制的，老师能具体分析下嘛？网上看到一个字符串有四G的说法？ 3：字符串+号拼接能优化为使用StingBuilder拼接，是有版本限制的吧？记得好像是1.5之后才有的，那之前的版本是怎么优化的，或者换个问题，所有版本的这种优化方式都一样嘛？ 4：使用 intern 方法需要注意的一点是，一定要结合实际场景。因为常量池的实现是类似于一个 HashTable 的实现方式，HashTable 存储的数据越大，遍历的时间复杂度就会增加。 请问这里的时间复杂度会增加，是指类似从O(1)到O(n)嘛？这个要看冲突虑吧？存一个值和存储1亿个值没有冲突的复杂度是一样的吧？ 这节太精彩了，像一场武林大会，都想当武林盟主，但最后都败在了刘栏主的剑下。

  2019-09-07

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/10/4f/9d/abb7bfe3.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  林伊

  老师，您好，想问下调用了intern()方法之后的字符串也是跟正常的对象一样在没有了引用之后就会回收，还是会一直存在呢？

  作者回复: 也会被回收的，常量池也有GC

  2019-08-27

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  👽

  思考题： 1，false 因为s1是指向的是常量池，s2是通过new创建的，所以在对象堆内存中。 2，false s3调intern方法，是先从常量池寻找，如果有已有需要的对象则清楚自己本来就要创建的对象。 3，true 基本原理同上，s2调用intern方法时，指向了常量池的字符串。这时s1 s3指向的内存地址是一样的。所以是true 另外关于intern的使用希望能详细描述一下。什么场景使用它。是字符串大篇幅相等的时候嘛？  举个例子， 1，如果要存给很多用户发送的消息，有三种信息，1请交话费 2您已停机 3正常使用 就适合intern，因为大篇幅是重复的。 2，如果信息是，您已欠费s元。s为任意字符串。这种情况是不是就不适合Intern，因为随机性太强。

  作者回复: 对的

  2019-08-13

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](https://static001.geekbang.org/resource/image/eb/56/eb5afbf568af2917033e5a860de0b756.png?x-oss-process=image/resize,w_14)

  程序员小跃

  这个专栏真好，大家留言都很积极，说明很有这方面的诉求。我本来有疑问的，把留言都看了一遍，基本就没啥太大的问题了，跟着老师持续学习起来。

  2019-08-12

  **

  **

- ![img](http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83equSjO9AVmwhkt5Grf54q4VJFPz8QaYtYvAxxQw9D28touZYcmAIsI0GZxdv0DuFvzyLZA4j57SlQ/132)

  Geek_ab689a

  老师文章提到的StringBuilder要比StringBuffer性能要高，据我了解如果StringBuffer没有逃逸的话JVM会对其进行锁消除，实际的性能理论上来讲应该是一致的吧。如果StringBuffer/StringBuilder逃逸了的话，那StringBuilder就会出现问题，毕竟不是线程安全的类。

  作者回复: 对的，JVM会进行逃逸分析，进行锁消除。如果出现逃逸，会重新加载有锁的编译文件。

  2019-07-30

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/13/8f/f7/9b59c019.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  内卷改变命运

  有什么办法查看衣字符串常量池数据吗

  作者回复: 目前没有

  2019-07-25

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/12/9f/8e/45ffff8f.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  莲花

  老师，有个问题不明白，求解。文章中提到，考虑到其中有很多用户在地址信息上是有重合的，比如，国家、省份、城市等，这时就可以将这部分信息单独列出一个类，以减少重复。数据存储从32G减到20G。 为什么将其中的信息单独出一个类就可以减少存储？这个跟intern无关的

  作者回复: 这也是减少数据重复的一种操作，抽取出公共的一些地址信息作为单独的类，用于多个用户信息共用。

  2019-07-20

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/12/9f/8e/45ffff8f.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  莲花

  在创建 b 字符串变量时，也会在堆中创建一个对象，此时常量池中有该字符串对象，就不再创建。既然不再创建对象了，intern还有什么用？

  作者回复: intern返回的是相同字符串的地址引用，避免在内存中再次申请内存创建相同字符串对象了。

  2019-07-20

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Vincent

  答案：false false true

  2019-07-19

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/12/2e/28/9c3adea2.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  李斯大炮

  String str = new StringBuilder("12").append("va").toString();          System.out.println(str.intern() == str);          System.out.println("---------------------");          String str2 = new StringBuilder("ja").append("va").toString();          System.out.println(str2.intern() == str2); 结果是true   false 有人能帮忙解释下为什么str2的例子就是false，把其中的字符串换成其他字符串就是true，是因为“java”字符串被内置到常量池中了么？

  作者回复: "java"字符串的关键字在加载执行前出现的可能性很大，类似的有例如版本号、main等。

  2019-07-09

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/12/2e/28/9c3adea2.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  李斯大炮

  String str = new StringBuilder("12").append("va").toString();          System.out.println(str.intern() == str);          System.out.println("---------------------");          String str2 = new StringBuilder("ja").append("va").toString();          System.out.println(str2.intern() == str2);

  2019-07-09

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/16/74/bf/35841a56.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  木鱼水心

  老师，String并不是真的不可变的，我们可以通过反射过去char数组，通过改变里面的元素来改变对象

  2019-07-07

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/13/db/4d/263a4508.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  郁陌陵

  老师，我想问一下，如开题所示代码，在常量池中字符串“abc”会有一个还是两个，如果是两个的话，怎么理解 “因为常量池的实现是类似于一个 HashTable 的实现方式”这句话呢

  作者回复: 一个哦

  2019-07-05

  **

  **

- ![img](http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIfQFSpQJNKeqW5Q9PfciaLyDDFm9heqW5SHQCzlrajXO8f38RCH3BE5k8QHGPMictbbAM9IGvicj5EQ/132)

  李

  \2. 如何使用 String.intern 节省内存？ 这个小段最后一个图中的，第3个图什么意思，为什么不在常量池创建

  作者回复: 在运行时动态创建对象，是不会在常量池中创建。

  2019-06-25

  **

  **

- ![img](data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABkAAD/4QN5aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0MCA3OS4xNjA0NTEsIDIwMTcvMDUvMDYtMDE6MDg6MjEgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YWE3YmZhMDItMzBhMC00MDg3LTg3MmYtOGMwMjMxNjNhZWRjIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI2MTlEODM3NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2MTlEODM2NTgzMTExRTk5NDY4Qjk3QUFCNDFBN0QzIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTYyRTNCMDNBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OTYyRTNCMDRBREI4MTFFOEFFNTJDODlGREQ1OTUzMDMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRm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)

  周彬

  老师，在使用字符包含比较时，有没有比字符串自带的包含方法更高效的比较方式，谢谢

  2019-06-24

  **

  **

- ![img](http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRiaKX0ulEibbbwM4xhjyMeza0Pyp7KO1mqvfJceiaM6ZNtGpXJibI6P2qHGwBP9GKwOt9LgHicHflBXw/132)

  Geek_ebda96

  老师，你好，你在文中所说的b对象将指向在常量池中存在引用对象，而原来b对象在堆内存中的空间将被垃圾回收，有两个疑问，第一个，我理解的一个java对象创建分三步，1.new一个对象，2.分配内存空间，3.把分配的空间指向池new的对象，java有没有针对new字符串对象进行优化，new之后直接先查找常量池有没有，如果有直接指向常量池，这样不是省去了分配空间的动作么，应该更快一些，第2个问题，java里的对象也就是全局变量本身也是占用了堆内存空间吧，因为你这边描述的是，b对象之前分配的内存被回收了，但b对象本身还存在，只是指向另外一个内存地址，垃圾回收的时候是不是把这些对象本身所占内存空也要回收，对象所指向的内存空间也一起回收

  作者回复: 第一个问题，如果是String里面的构造参数是常量，这个优化是好的，但是如果是一个非常量，这个new动作就在先了，需要使用intern方法将字符串被放到常量池，这个动作则是在后了。 第二个问题，b不是一个对象，而且一个引用，是放在了虚拟机栈中。

  2019-06-11

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/16/ed/0c/b12258d5.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  伟

  从 20G 降到几百兆，是不是意味着推特的常量池至少有几十上百兆？那这HashTable也不小吧？

  作者回复: 这个具体的性能状况没能了解到，这只是一个优化思路。

  2019-06-10

  **2

  **

- ![img](https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  cricket1981

  请教如何对string类型的值对象加synchronized同步块？有人说synchronized(string.intern())方式不好，容易让对象GC不了，还可能造成dead lock，老师怎么看？标准做法是什么？谢谢！

  2019-06-08

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  王盛武

  Zend同学提的 复制 问题，希望修改文稿为引用赋值才正确。  一开始我也纠结这点，看了Zend跟我提问内容一样

  编辑回复: 已修正～感谢这位细心的同学！

  2019-06-08

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/17/96/56/2cee7672.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](https://static001.geekbang.org/resource/image/eb/56/eb5afbf568af2917033e5a860de0b756.png?x-oss-process=image/resize,w_14)

  中年油腻男

  String.indexOf()怎么切分字符串？求解

  作者回复: 需要结合substring方法一起用。

  2019-06-05

  **

  **

- ![img](http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqEYVfkWyoGovx1wtiaF78Z1MUoT9OPH5UeLmuyOFbVxExs7dibXmQZKIWjiaQATR6sYrsD5iaaGr8O3w/132)

  summer

  所以，一个字符串的值，如“abc”。不管是new 出来的也好，还是 直接 = “abc”的也罢。都会的把"abc“放到常量池中，两个想了解的地方，（1）如果 stringbuffer来连接如：stringbuffer("a").append("b").append("c").toString();这种情况下，是不是会分别创建 a， b，c三个字符串到常量池中呢？（2）：如要所有的值都是放在常量池中，那new String("abc")与 =”abc“这种，在程序里，是不是 ="abc"的性能更好些，毕竟new String(”abc“)多了从常量池中copy的过程。

  作者回复: 对的，如果只是常量，一般就是常量这种写法。

  2019-06-03

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/0f/57/67/01d1580f.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  xinnong

  为什么直接拼接快呢？  public final static String generateCommentAndTopicDailyTaskTimeskey(String userid) {        StringBuilder sb = new StringBuilder();        sb.append("daily_comment_or_topic_times");        sb.append("_");        sb.append(userid);        return  sb.toString();   }      public final static String generateCommentAndTopicDailyTaskTimeskey1(String userid) {        return  "daily_comment_or_topic_times" + "_" + userid;   }      public static void main(String[] args) {        int len = 100000;        long begin = System.currentTimeMillis();        for(int i=0;i<len;i++) {            generateCommentAndTopicDailyTaskTimeskey("12");        }        long end = System.currentTimeMillis();        System.out.println(end-begin);                long begin1 = System.currentTimeMillis();        for(int i=0;i<len;i++) {            generateCommentAndTopicDailyTaskTimeskey1("12");        }        long end1 = System.currentTimeMillis();        System.out.println(end1-begin1);   }

  作者回复: 建议分开运行，这个比较应该没有很大差异。本身编译器会优化+。

  2019-05-29

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/12/16/e0/7abad3cc.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  星期八

  老师，messageInfo.getCity().intern()这个例子中，一开始的对象是指哪个对象呢？

  作者回复: 你好，这个指的是运行时在堆内存中创建的对象。

  2019-05-29

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/14/de/41/bd311da7.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  safe

  老师，我想问一下，如果intern方法是在常量池中寻找是否存在的字符串，如果在多线程的情况下，会不会有资源竞争问题

  作者回复: 你好 safe，这个常量是不可变的，所以不存在锁资源的问题，不会存在竞争。

  2019-05-27

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/12/3e/f7/84413d01.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Alex

  温故知新, 特别好

  2019-05-27

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/15/f4/e2/73ecba29.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Janita

  回溯问题是什么意思

  编辑回复: 同学你好，明天更新的04讲就会讲到这个问题了。

  2019-05-27

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  每天晒白牙

  false false true

  编辑回复: 点赞！

  2019-05-27

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/0f/59/c9/f44cb7f3.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)![img](https://static001.geekbang.org/resource/image/eb/56/eb5afbf568af2917033e5a860de0b756.png?x-oss-process=image/resize,w_14)

  爪哇夜未眠

  老师好，文章提到“使用 intern 方法需要注意的一点是，一定要结合实际场景...HashTable 存储的数据越大，遍历的时间复杂度就会增加...” 那建议多大的量可以使用呢？像Twitter那种，几十G压缩到几百兆的量，算大吗？会有问题吗？

  作者回复: 你好，建议不超过百兆，这个可以根据具体环境和场景进行测试。

  2019-05-26

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/13/1b/86/22a9362f.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  六六六

  str1,str3d都指向的是常量池，str2指向的是堆，所以答案是false，false，true。 想请教老师一个关于机器load的问题，我们有个应用的线上机器load有时会忽然飙升一下，然后又很快降下来，基本可以排除是流量问题。我现在的想法是通过定时脚本来不断检查load，当load升高之后，打印jstack信息。想问下老师还有没有其他的排查方案或者工具呢！谢谢老师

  作者回复: 可以dump下GC日志，结合线程业务日志来排查问题，可以先排查是否是应用服务导致的飙升，还是其他外在因素。

  2019-05-25

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/13/d6/c9/08a62ac7.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  胡小榕

  String s = new String("abc").intern(); "堆内存中原有的对象由于没有引用指向它，将会通过垃圾回收器回收。"这个如何理解呢？是说s指向了"abc"的引用，而new String("abc")这个对象会被回收吗？ 请老师讲讲

  作者回复: 我们知道，在堆创建string对象后，如果没有intern方法，会将引用指向堆中的对象。调用intern方法之后，会将引用指向常量池中的字符串对象，此时堆中的对象则失去了引用。JVM的垃圾回收会将没有根引用的对象回收。 不知道你是否理解了，有问题保持留言。

  2019-05-25

  **

  **

- ![img](https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg?x-oss-process=image/resize,m_fill,h_34,w_34)

  Demon.Lee![img](https://static001.geekbang.org/resource/image/89/43/89yyff4c4c2e2b73ce4931bb01a6a943.png)

  即使使用 + 号作为字符串的拼接，也一样可以被编译器优化成 StringBuilder 的方式。 ----- 老师好，这个是从Java8才开始支持的吧，我的问题是：常量池在内存里面的位置与堆内存有啥区别呀

  作者回复: 编译优化在Java7就实现了。常量池在JDK1.7之前是放在非堆内存区中，且空间大小有限，在1.7以后放在了堆内存中，区别就是逻辑空间隔离与其他堆内存，垃圾回收也是不同于堆中的垃圾回收。

  2019-05-25
