# 树


## 6.2 树的定义

•树(Tree)是n(n>=0)个结点的有限集。当n=0时成为空树，在任意一棵非空树中：
- 有且仅有一个特定的称为根(Root)的结点；
- 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1、T2、...、Tm，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。

注意点：
- n>0时，根结点是唯一的，坚决不可能存在多个根结点。
- m>0时，子树的个数是没有限制的，但它们互相是一定不会相交的。


### 6.2.1 结点分类

- 结点拥有子树数目称为结点的度；
  - 度为0的结点称为叶结点(Leaf)或终端结点
  - 度不为0的结点称为分支结点或非终端结点，除根结点外，分支结点也称为内部结点。

树的度是树内各结点的度的最大值；

### 6.2.2结点之间的关系

•结点的子树的根称为结点的孩子(Child)，相应的，该结点称为孩子的双亲(Parent)，同一双亲的孩子之间互称为兄弟(Sibling)。
•结点的祖先是从根到该结点所经分支上的所有结点。

### 6.2.3 树的其他相关概念

•结点的层次(Level)从根开始定一起，根为第一层，根的孩子为第二层。
•其双亲在同一层的结点互为堂兄弟。
•树中结点的最大层次称为树的深度(Depth)或高度。
如果将树中结点的各个子树看成从左到右是有次序的，不能互换的，则称该树为有序树，否则称为无序树；
森林是m(m>=0)棵互不相交的树的集合；


## 6.3 树的抽象数据类型

```c
ADT  树（tree）
Data
    树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。
Operation
    InitTree(*T):构造空树T
    DestroyTree(*T):销毁树T
    CreateTree(*T,definition):按definition中给出树的定义来构造树
    ClearTree(*T):若树T存在，则将树T情空为空树
    TreeEmpty(T):若T为空树，返回true，否则返回false
    TreeDepth(T):返回T的深度
    Root(T):返回T的根结点
    Value(T,cur_e):cur_e是树T中的一个结点，返回此结点的值
    Assign(T,cur_e,value):给树T的结点cur_e赋值为value
    Parent(T,cur_e):若cur_e是树T的非根结点，则返回它的双亲，否则返回空
    LeftChild(T,cur_e):若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空
    RightSibling(T,cur_e):若cur_e有右兄弟，则返回它的右兄弟，否则返回空
    InsertChild(*T,*p,i,c):其中p指向树T的某个结点，i为所指结点p的度上加1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树
    DeleteChild(*T,*p,i):其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树
endADT
```



## 6.4 树的存储结构

- 三种表示方法：双亲表示法，孩子表示法、孩子兄弟表示法


### 6.4.1 双亲表示法

在每个结点中附设一个指示器指示其双亲结点在数组中的位置。

![双亲表示法结点结构]($resource/%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84.jpg)

双亲表示法结点结构定义代码：
```c
//数的双亲表示法结点结构定义
#define MAX_TREE_SIZE 100
typedef int ElemType;

typedef struct PTNode //结点结构
{
	ElemType data;	// 结点数据
	int parent;		// 双亲位置
}PTNode;

typedef struct //树结构
{
	PTNode nodes[MAX_TREE_SIZE]; //结点数组
	int r;			 //根的位置和节点数
	int n;			
}PTree;
```

注：根节点的位置域即parent域设置为-1；
图示如下：

![双亲表示法]($resource/%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg)


补充：上面的双亲表示法无法很方便的之后某个结点的孩子结点有哪些，因此在结点结构的加上一个最左边（长子）域，没有孩子的结点长子域设置为-1；
如果同时关注各兄弟之间的关系；可以同时加上一个右兄弟域，如果存在右兄弟则记录下标，没有就记为-1;

补充之后图示：
![双亲表示法补充]($resource/%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95%E8%A1%A5%E5%85%85.jpg)

==实际使用过程中，存储结构的设计十分灵活，根据具体情况采用==



### 6.4.2 孩子表示法

因为数的每个结点可能含有多个子树，因此可以使用多重链表：每个结点有多个指针域，其中每个指针指向一棵子树的根节点，称为多重链表表示法；


- 方案一：指针域的个数等于树的度（树的度为数的各个结点度的最大值）
当树中各个结点的度相差很大的时候，浪费空间；相差很小的时候是一种优点；

![孩子表示法方案一结点结构]($resource/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95%E6%96%B9%E6%A1%88%E4%B8%80%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84.jpg)

![孩子表示法方案一]($resource/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95%E6%96%B9%E6%A1%88%E4%B8%80.png)

- 方案二：每个结点指针域的个数等于该结点的度
空间利用率更高了，但是因为各个结点的链表结构不同，维护各个结点度的数值较为麻烦

![孩子表示法方案二结点结构]($resource/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95%E6%96%B9%E6%A1%88%E4%BA%8C%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84.jpg)


![孩子表示法方案二]($resource/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95%E6%96%B9%E6%A1%88%E4%BA%8C.png)


- 具体方案：
把每个结点的孩子结点排列起来，以单链表做存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空；然后n个头指针又组成一个线性表，采用顺序储存结构，存放进一个一维数组中。
如下图所示：
![图片1]($resource/%E5%9B%BE%E7%89%871.jpg)


孩子表示法的结构定义代码：
```c
/*
	孩子表示法结构定义
*/
#define MAX_TREE_SIZE 	100

typedef char ElemType;

// 孩子结点
typedef struct CTNode
{
	int child;				// 该结点在表头数组中的下标
	struct CTNode *next;	
} *ChildPtr;

// 表头结构
typedef struct
{	
	ElemType data;			
	int parent;				
	ChildPtr firstchild;	// 存储该结点孩子链表的头指针
} CTBox;

//树结构
typedef struct
{
	CTBox nodes[MAX_TREE_SIZE];	// 结点数组
	int r, n; //根的位置和结点数
}
```

该结构便于查找某个结点的某个孩子或者某个结点的兄弟有利，但是要查找某个结点的双亲就需要遍历整棵树，可以采用在表头数组中在data和firstchild中加上一列parent实现；称为：双亲孩子表示法。





### 6.4.3 孩子兄弟表示法

理论：如果任意一棵树，他的结点的第一个孩子如果存在就是唯一的，他的右兄弟如果存在也是为唯一的；

树的孩子兄弟表示法结构定义：
```c
/*
	树的孩子兄弟表示法结构定义
*/
typedef struct CSNode{
	TElemType data;
	struct CSNode *firstchild,*rightsib;
}CSNode.*CSTree;
```

![孩子兄弟表示法]($resource/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg)



## 6.5 二叉树

•二叉树（Binary Tree）是n（n>=0）个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。


### 6.5.1二叉树特点

- 每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。
- 左子树和右子树是有顺序的，次序不能颠倒；
- 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树；
- 二叉树的五种基本形态：
  - •空二叉树
  - •只有一个根结点
  -  •根结点只有左子树
  - •根结点只有右子树
  - •根结点既有左子树又有右子树

### 6.5.2 特殊的二叉树

- 斜树：
  - 所有结点都只有左子树或者只有右子树，称为：左斜树和右斜树；
- 满二叉树：
  - 所有分支结点都存在左子树和右子树，并且所有的叶子都在同一层上；
  - 特点：
    - 叶子只能出现在最下一层。
    - 非叶子结点的度一定是2。
    - 在同样深度的二叉树中，满二叉树的结点个数一定最多，同时叶子也是最多。
- 完全二叉树：
  - 对一棵具有n个结点的二叉树按层序编号，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点位置完全相同；
  - 完全二叉树的特点有：
    - 叶子结点只能出现在最下两层。
    - 最下层的叶子一定集中在左部连续位置。
    - 倒数第二层，若有叶子结点，一定都在右部连续位置。
    - 如果结点度为1，则该结点只有左孩子。
    - 同样结点树的二叉树，完全二叉树的深度最小。
  - 注意：满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。
  - 判断：==将每个结点按照满二叉树的结构逐层顺序编号，如果顺序出现空档，则说明不是完全二叉树，否则就是==

## 6.6 二叉树的性质

- 性质1：在二叉树的第i层至多有2^(i-1)个结点(i>=1)；
- 性质2：深度为K的二叉树至多有(2^k)-1个结点（k>=1）;
- 性质3：对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1；
- 性质4：具有n个结点的完全二叉树的深度为⌊log₂n⌋+1；（⌊x⌋表示不大于x的最大整数）
- 性质5：如果对一棵有n个结点的完全二叉树(其深度为⌊log₂n⌋+1)的结点按层序编号，对任一结点i(1<=i<=n)有以下性质：
  - 如果i = 1，则结点 i  是二叉树的根，无双亲；如果i > 1，则其双亲是结点⌊i/2⌋
  - 如果2i > n，则结点 i  无做左孩子(结点 i  为叶子结点)；否则其左孩子是结点2i
  - 如果2i+1 > n，则结点  i  无右孩子；否则其右孩子是结点2i+1






## 6.7二叉树的存储结构

- 顺序存储结构：
二叉树可以使用顺序存储结构；完全二叉树的使用一维数组实现顺序存储结构，同时数组的下标可以体现结点之间的逻辑关系；

![完全二叉树的顺序存储结构]($resource/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png)

当存储普通的二叉树时候使用`^`代替不存在的结点存储在数组中；但是会造成很大的空间浪费，因此==顺序存储结构一般仅仅用于完全二叉树的存储中==

- 链式存储结构：（二叉链表）

二叉链表结点机构示意图：
![二叉链表结点存储结构]($resource/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png)

二叉链表结点结构定义如下：
```c
/*
	二叉树的二叉链表结点结构定义
*/
//结点结构
typedef struct BiTNode{
	TElemType data; //结点数据
	struct BiTNode *lchild,*rchild; //左右孩子指针
}BiTNode.*BiTree;
```
二叉链表存储结构示例：

![二叉链表存储结构示例]($resource/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B.png)




## 6.8 遍历二叉树

•二叉树的遍历(traversing binary tree)是指从根结点出发，按照某种**次序**依次**访问**二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。

### 6.8.1二叉树遍历方法
在限定从左到右的遍历顺序之后，分为四类；

- 前序遍历：
若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。

![二叉树前序遍历]($resource/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.png)

- 中序遍历：
若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。
![二叉树中序遍历]($resource/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png)

- 后序遍历：
若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。
![二叉树后序遍历]($resource/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png)

- 层序遍历：
若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。
![二叉树的层序遍历]($resource/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.png)


### 6.8.3 前序遍历算法
```c
/*
	二叉树的前序遍历算法
*/

void PreOrderTraverse(BiTree T){
	if (T==NULL){
		return;
	}
	printf("%c", T->data); //这里操作时显示结点数据，当然此操作可以自行更改
	PreOrderTraverse(T->lchild); //先序遍历左子树
	PreOrderTraverse(T->rchild); //先序遍历右子树
}

```
使用递归
以下图为例程序说明：
![前序遍历算法]($resource/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95.jpg)


### 6.8.4 中序遍历算法
```c
/*
	二叉树的中序遍历算法
*/

void InOrderTraverse(BiTree T){
	if (T==NULL){
		return;
	}
	PreOrderTraverse(T->lchild); //中序遍历左子树
	printf("%c", T->data); //这里操作时显示结点数据，当然此操作可以自行更改
	PreOrderTraverse(T->rchild); //中序遍历右子树
}

```
中序遍历上面二叉树的节点顺序为：HKDBEAIFCGJ


### 6.8.4 后序遍历算法
```c
/*
	二叉树的后序遍历算法
*/

void InOrderTraverse(BiTree T){
	if (T==NULL){
		return;
	}
	PreOrderTraverse(T->lchild); //后序遍历左子树
	PreOrderTraverse(T->rchild); //后序遍历右子树
	printf("%c", T->data); //这里操作时显示结点数据，当然此操作可以自行更改
}

```
后序遍历上面二叉树的节点顺序为：KHDEBIFJGCA




注意：
- 已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树；
- 已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树；



## 6.9 二叉树的建立

假设二叉树每个结点都是一个字符，而且空节点使用`#`代替；
```c
typedef char ElemType;

typedef struct BiTNode
{
	char data;
	struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 按前序输入二叉树中结点的值（一个字符），使用#表示空树，构造二叉链表表示二叉树
CreateBiTree(BiTree *T)
{
	char c;

	scanf("%c", &c);
	if( '#' == c )
	{
		*T = NULL;
	}
	else
	{
		*T = (BiTNode *)malloc(sizeof(BiTNode));
		if(!*T){
          exit(OVERFLOW);
        }
		(*T)->data = c; //生成根节点
		CreateBiTree(&(*T)->lchild); //构造左子树
		CreateBiTree(&(*T)->rchild); //构造右子树
	}
}
```




## 6.10 线索二叉树

根据二叉链表的图示，可以看出结点结构中没有左孩子和右孩子的部分使用`^`代替，浪费了很多空间；同时二叉链表==只能知道每个结点指向其左右孩子结点的地址，而不知道某个结点的前驱和后继分别是谁，必须通过再次遍历才能得到。==

可以采用之间在存储结点的时候直接记住前驱和后继；

- 线索：指向前驱和后继的指针
- 线索链表：加上线索的二叉链表
- 线索二叉树：对应的二叉树

将==中序遍历==中的`^`充分利用之后的效果图；

![线索二叉树]($resource/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png)


以上方法相当于将一棵二叉树转换成了双向链表；

![二叉树转换成为双向链表]($resource/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%BA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.jpg)

方法补充：引入两个标志域：ltag和rtag（只是存放0或1数字的布尔型变量），得到结点结构如下：

![线索二叉链表结点格式]($resource/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E6%A0%BC%E5%BC%8F.png)

–ltag为0时指向该结点的左孩子，为1时指向该结点的前驱。

–rtag为0时指向该结点的右孩子，为1时指向该结点的后继。

![原结构与线索二叉树结构对比]($resource/%E5%8E%9F%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94.jpg)


线索二叉树结构实现定义代码：
```c
typedef enum {Link, Thread} PointerTag;

typedef struct BiThrNode
{
	char data;
	struct BiThrNode *lchild, *rchild;
	PointerTag ltag;
	PointerTag rtag;
} BiThrNode, *BiThrTree;
```

线索话二叉树的实质就是将二叉链表中的空指针改为指向前驱或者后继的线索，也就是相当于在遍历的过程中修改空指针的过程。

中序遍历线索化的递归函数代码：
解释见书本：p192
```c
BiThrTree pre; //全局变量，始终指向刚刚访问过的结点
void InThreading(BiThrTree T)
{
	if( T )
	{
		InThreading( T->lchild );		// 递归左子树线索化
		if( !T->lchild )	//没有左孩子 
		{
			T->ltag = Thread; //前驱线索
			T->lchild = pre; //左孩子指针指向前驱
		}

		if( !pre->rchild ) //前驱没有右孩子
		{
			pre->rtag = Thread; //后继线索
			pre->rchild = T; //前驱右孩子指针指向后继（当前的结点T）
		}

		pre = T; //保持pre指向T的前驱

		InThreading( T->rchild );		//递归右子树线索化
	}
}

```


遍历的代码：具体见P193
```c
void InOrderThreading( BiThrTree *p, BiThrTree T )
{
	*p = (BiThrTree)malloc(sizeof(BiThrNode));
	(*p)->ltag = Link;
	(*p)->rtag = Thread;
	(*p)->rchild = *p;
	if( !T )
	{
		(*p)->lchild = *p;
	}
	else
	{
		(*p)->lchild = T;
		pre = *p;
		InThreading(T);
		pre->rchild = *p;
		pre->rtag = Thread;
		(*p)->rchild = pre;
	}
}

void visit( char c )
{
	printf("%c", c);
}

// 涓簭閬嶅巻浜屽弶鏍戯紝闈為€掑綊
void InOrderTraverse( BiThrTree T )
{
	BiThrTree p;
	p = T->lchild;

	while( p != T )
	{
		while( p->ltag == Link )
		{
			p = p->lchild;
		}
		visit(p->data);

		while( p->rtag == Thread && p->rchild != T )
		{
			p = p->rchild;
			visit(p->data);
		}
		
		p = p->rchild;
	}
}
```





## 6.11 树、森林转换为二叉树

### 6.11.1 将树转换为二叉树

* 加线，在所有兄弟结点之间加一条连线。
* 去线，对树中每个结点，只保留它与第一孩子结点的连线，删除它与其他孩子结点之间的连线。
* 层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。


### 6.11.2 将森林转换为二叉树

* 把每棵树转换为二叉树。
* 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。

### 6.11.3 二叉树转换为树、森林
•二叉树转换为普通树是刚才的逆过程，步骤也就是反过来做而已。

•判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有的话就是森林，没有的话就是一棵树。



### 6.11.4 树和森林的遍历

- 树的遍历分为两种方式：一种是先根遍历，另一种是后根遍历。
  * 先根遍历：先访问树的根结点，然后再依次先根遍历根的每棵子树。
  * 后根遍历：先依次遍历每棵子树，然后再访问根结点。
* 森林的遍历：前序遍历，后序遍历
•树、森林的前根（序）遍历和二叉树的前序遍历结果相同，树、森林的后根（序）遍历和二叉树的中序遍历结果相同！



----

## 6.12 赫尔曼树 

引例：
因为每个结点出现情况的概率不同，因此可以重新构造二叉树使得总体的路径长度最短；

![赫尔曼树]($resource/%E8%B5%AB%E5%B0%94%E6%9B%BC%E6%A0%91.png)



常用概念：
- 路径长度：从树的一个结点到另一个结点之间的分支构成两个结点之间的路径，路径多行的分支数目称为路径长度；
- 树的路径长度：树根带每一个结点的路径长度之和；
- 树的带权路径长度：等于所有叶子结点的带权路径长度之和；
- 赫夫曼树（最优二叉树）：带权路径长度WPL最小的二叉树；

 
![路径长度和最优二叉树]($resource/%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E5%92%8C%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91.jpg)


赫夫曼树构造方法：

![赫夫曼树构造方法]($resource/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.jpg)

==最有的赫夫曼树不一定性能上是最好的==



## 6.13赫夫曼编码

因为数据传输过程中各个字符出现的频率其实不是等概的，因此如果每个字母都是用相同长度的编码，会浪费空间，然后根据每个字符出现的概率进行构造赫夫曼树，概率值就是每个结点的权，然后将权值左分支改为0，右分支改为1，之后就是赫夫曼树，而编码位数就是结点所处的深度，并且高频字使用短码，低频字使用长码；

如示例图所示：
![赫夫曼编码]($resource/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.jpg)

解码的时候同样使用赫夫曼编码。





