# 补充_Python中str()与repr()函数的区别


在 Python 中要将某一类型的变量或者常量转换为字符串对象通常有两种方法，即 `str()` 或者 `repr()` 。

```
>>> a = 10
>>> type(str(a))
<class 'str'>
>>> type(repr(a))
<class 'str'>

```

但是这二者之间有什么区别呢？因为提供两个功能完全相同的内建函数是没有意义的。先看一个例子。

```
>>> print(str('123'))       
123                         
>>> print(str(123))         
123                         
>>> print(repr('123'))      
'123'                       
>>> print(repr(123))        
123                         

```

从例子中不难发现，当我们把一个字符串传给 `str()` 函数再打印到终端的时候，输出的字符不带引号。而将一个字符串传给 `repr()` 函数再打印到终端的时候，输出的字符带有引号。

造成这两种输出形式不同的原因在于：

*   `print` 语句结合 `str()` 函数实际上是调用了对象的 `__str__` 方法来输出结果。而 `print` 结合 `repr()` 实际上是调用对象的 `__repr__` 方法输出结果。下例中我们用 `str` 对象直接调用这两个方法，输出结果的形式与前一个例子保持一致。

```
>>> print('123'.__repr__())
'123'
>>> print('123'.__str__())
123

```

不过这个例子可能还是无法很好表达到底 `str()` 与 `repr()` 各有什么意义，我们再来看一个例子。

```
>>> from datetime import datetime
>>> now = datetime.now()
>>> print(str(now))
2017-04-22 15:41:33.012917
>>> print(repr(now))
datetime.datetime(2017, 4, 22, 15, 41, 33, 12917)

```

通过 `str()` 的输出结果我们能很好地知道 `now` 实例的内容，但是却丢失了 `now` 实例的数据类型信息。而通过 `repr()` 的输出结果我们不仅能获得 `now` 实例的内容，还能知道 `now` 是 `datetime.datetime` 对象的实例。

因此 `str()` 与 `repr()` 的不同在于：

*   `str()` 的输出追求可读性，输出格式要便于理解，适合用于输出内容到用户终端。
*   `repr()` 的输出追求明确性，除了对象内容，还需要展示出对象的数据类型信息，适合开发和调试阶段使用。

另外如果想要自定义类的实例能够被 `str()` 和 `repr()` 所调用，那么就需要在自定义类中重载 `__str__` 和 `__repr__` 方法。


