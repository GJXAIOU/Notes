# 笔记汇总


---
二轮整理：2019-1-21
---

# 第1章 基本对象类型

@toc

**浮点数的所有运算都要注意**

## 1.1 数和四则运算

1.python可以自动处理大**整数问题，不必担心溢出**

2.单精度浮点数（4个字节）在计算机内部存储方式：
1位为符号位（0为正，1为负），8位用作整数，最后的23位表示有效数字

3.每个**对象**在内存中都有自己的地址，可以使用函数`id()`查看每个对象的内存地址；但是通过`id()`得到的内存地址是只读的，**不能够修改**。

4.使用内建函数`type()`可以查看对象的类型，当然得到的结果也是只读的；

5.==**对象有类型，变量无类型**==

6.四则运算中运算符两侧只要有一个为浮点数，结果就是浮点数，否则为整数

7.浮点数会出现溢出的问题    `*`  表示相乘 ；`**` 表示乘幂 ，等效于`pow()`函数，当然使用的时候要导入math库，   `e-08` 表示10的-8次方；

8.python中的==除法的结果都是浮点数，不论参与运算的数有没有浮点数==

9.`//` 表示两个数相除之后的商（取整），这个商一定为整数

10.python中的已经写好的工具叫做 “库” ，或者“模块”、或者“类库”

11.**导入模块：**

- 单一模块： `import module-name`  表示导入模块：module-name
- 大模块中的小模块： `from module1 import module11` ,表示从库module1（大模块），里面的子模块 module11

**12.针对python中的浮点数问题**
python以双精度64位表示浮点数，默认的小数精度为17位，所以电脑中以二进制进行保存的时候会丢掉后面的一部分，造成存储的实际上就有误差；

- 除法会将无限循环小数截断，还不是按照四舍五入的截断
  解决方法，导入decimal：
```python
#Author:GJXAIOU 
#coding:utf-8 
#!/usr/bin/env python 

import decimal #导入decimal 模块
a = decimal.Decimal("10.0") #使用decimal模块中的Decimal函数
b= decimal.Decimal("3")
print(a/b)
```
程序运行结果：`3.333333333333333333333333333`

- 两个数相除将结果保留为分数：使用`fraction`
```python
#Author:GJXAIOU 
#coding:utf-8 
#!/usr/bin/env python 
from fractions import Fraction
ans = Fraction(10,4)
print(ans)

```
程序运行结果：`5/2`

13.取余：`%`

14.同时获得除法的商和余数，使用内建函数`divmod()`
```python
#Author:GJXAIOU
#coding:utf-8 
#!/usr/bin/env python 
print(divmod(5,2))
```
程序运行结果：`(2, 1)`前面为商，后面为余数

15.对小数进行四舍五入，使用内建函数 `round()`,前一个参数为数字，后一个参数为小数点后的位数
```python
#Author:GJXAIOU 
#coding:utf-8 
#!/usr/bin/env python 
print(round(1.256452233 ,3))
```
程序运行结果：`1.256`


[round（）使用方法](https://blog.csdn.net/gaojixu/article/details/83792109)
- round()如果只有一个数作为参数，不指定位数的时候：
  返回的是一个整数，而且是最靠近的整数（这点上类似四舍五入）。但是当出现.5的时候，两边的距离都一样，round()取靠近的偶数。
- 当指定取舍的小数点位数的时候：
  一般情况也是使用四舍五入的规则，但是碰到.5的这样情况，如果要取舍的位数前的小数是奇数，则直接舍弃，如果偶数这向上取舍。


## 1.3 常见的数学函数以及运算优先级
- 使用`math`
```python
#Author:GJXAIOU 
#coding:utf-8 
#!/usr/bin/env python
import math
print(math.pi)

print(dir(math))
```
程序运行结果：
`3.141592653589793`
下面是math中的所有东西（函数）
`['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']`

其中`math.floor()`为取整函数，`math.fabs(-2)`为求绝对值（也可以使用内建函数`abs()`）,求除法的余数：`math.fmod(5,3)`(也可以使用内建的`/`)


**2.运算优先级**
见书P25-26页
实在不行先加括号


## 1.4 一个简单的程序

1.未经编译就可运行的程序称为脚本程序（script）

2.程序前面两行
```python
#Author:GJXAIOU 

#coding:utf-8   
#本程序采用utf-8编码 
#!/usr/bin/env python   
#在Linux中必须写，在Windows中可以不写，能够引导程序找到python的解释器
```
3.python 中的注释：当行注释：`#` ,多行注释：使用一对`'''`或者一对`"""`
**能单行注释的就单行注释，尽量避免使用多行注释**





## 1.5 字符串

**1.字符串使用单引号或者双引号包裹**
当字符串内部含有其中一种符号（单引号或者双引号）时候，外面采用另一种符号进行包裹，或者在字符串中出现的的符号前加上`\`,相当于转义字符。

事例说明：
```python
#Author:GJXAIOU 
#coding:utf-8 
#!/usr/bin/env python 
str = "what's your name?" #采用双引号包含单引号 
str1 = 'what\'s your name?' # 使用转义字符  
print(str)
print(str1)
```
程序运行结果为：
`what's your name?`
`what's your name?`

2.可以使用`type()`进行检验类型
```python
#Author:GJXAIOU #coding:utf-8 
#!/usr/bin/env python 
print(type(330))
print(type("330"))
```
程序运行结果为：
`<class 'int'>`  对象类型为整型
`<class 'str'>` 对象类型为字符串类型



3.使用`+`实现字符串的连接
首先 **`+`两边的对象给的数据类型必须一致**，例如都是数字就是加法，字符串就是拼接；

- `str()` 实现将整数转换为字符串； #没有返回值
`repr()是返回一个字符串对象；
[补充_Python中str()与repr()函数的区别](补充-python中str-与repr-函数的区别)
- `int()` 实现将字符串转换为整数
4.一行的结尾加上`\` ，实现续行，对于字符串可以采用字符串开头结尾各加上三个`"`表示字符串的续行

5.键盘输入：使用`input()`获取输入的数据,**input ()返回的结果为字符串类型的对象**
```python
#Author:GJXAIOU 
#coding:utf-8 
#!/usr/bin/env python
name = input("what's your name ?")
age = input("how old are you ?")

print("your name is " + name)
print("you are " + age + "years old.")
after_ten = int(age) + 10 
print("you will be" +str(after_ten) + "years old after ten years.")
```
程序运行结果：
`what's your name ?gaojixu`
`how old are you ?23`
`your name is gaojixu`
`you are 23years old.`
`you will be33years old after ten years.`


6.原始字符串：由`r`开头引起的字符串就是原始字符串，在里面放置任何字符都是原始含义，也就是说没有转义字符的性质
```python
a = r"c:\hello"
print(a)
```
程序运行结果：`c:\hello`


7.**序列:** 有序排列，例如字符串、列表等等统称为序列

8.**索引：** 序列中每一个都有编号，这个编号即为：索引
例如：
```python
#Author:GJXAIOU 
#coding:utf-8
#!/usr/bin/env python 

# 索引 
lang = "python is beautiful" 
print("lang = " ,lang)
print("lang[3] = ",lang[3])

ans1 = lang.index("p")# 在lang字符串中查找字符p的位置  
print("index('p')= ",ans1)

#字符串的切片：复制字符串的一部分，（不改变原有的字符串）  
ans2 = lang[2:9]#得到第2到第9个字符（包括第2 个，不包括第9个） 
print("lang[2:9] = ",ans2)

ans3 = lang[1:]#得到从第一个到最后的字符（包括第一个和最后一个） 
print("lang[1:] = ",ans3)

ans4 = lang[:] #得到所有的字符,这时候新的字符串（其实本质上这时候并没有生成新的字符串）和原来字符串的地址也是一样的
print("ans4 = ",ans4)
print("id(lang) = ",id(lang),"id(ans4) = ",id(ans4))  #id()是查看该对象在内存中的地址   
**完全复制的时候不产生新的字符串** 

#对比如下的赋值语句 
ans = lang
print("id(lang) = ",id(lang),"id(ans4) = ",id(ans4))

ans5 = lang[:9] #得到第9个之前的所有字符（不包括第9个） 
print("lang[:9] = ",ans5)
```
程序运行结果：
`lang =  python is beautiful`
`lang[3] =  h`
`index('p')=  0`
`lang[2:9] =  thon is`
`lang[1:] =  ython is beautiful`
`ans4 =  python is beautiful`
`id(lang) =  2381962817448 id(ans4) =  2381962817448`
`id(lang) =  2381962817448 id(ans4) =  2381962817448`
`lang[:9] =  python is`



### 1.5.8 字符串的基本操作

- `len() `求字符串的长度  ,返回值为int型
```python
str = "hello" 
print(len(str))
```
程序运行结果；`5`

- `+`    连接两个序列
```python
str1 = "python" 
str2 = "lisp" 
print(str1 + "&"+ str2)
```
程序运行结果：`python&lisp`

- `*`   重复序列元素
```python
str = "hello"
print(str *3)
```
程序运行结果：`hellohellohello`

- `in`  判断元素是否存在于序列中
```python
str1 = "python" 
print("th" in str1)  #多个元素必须是相邻的
```
程序运行结果：`True`

- `max()`  返回最大值  ;   `min()` 返回最小值 ,`mean()`求平均值
```python
str1 = "python" 
print("max(str1)= ",max(str1),"min(str1)=",min(str1))
```
程序运行结果：`max(str1)=  y min(str1)= h`
比较的是字符编码：可以使用内建函数`ord()`获得一个字符对应的数字编码，使用`chr()`实现数字编码向字符的转换
例如：
```python
print("ord('h') = ",ord("h"), "chr(104) = ",chr(104))
```
程序运行结果：`ord('h') =  104 chr(104) =  h`
*字符串的比较是挨个比较，直到得出结果；

ASCII码：A：65  a :97

- 字符串大小写
```python



```


### 1.5.9 字符串的格式化输出
- 输出方式
  - 方法一：使用占位符`%s` ,(不推荐使用)
```python
print("I like %s" %  "python")
```
  程序运行结果：`I like python`

  - 方法二：使用`format()`方法,使用方法：`string.format()`,format()方法的返回值为一个字符串
同样是使用占位符`{}`,根据中间的数字序号来对应替换
```python
print("I like {1} and {0}".format("lalala","python"))
```
  程序运行结果：`I like python and lalala`

- 输出格式：
  - 对齐：
```python
print("I like {1:10} and {0:^15} and{2:>12}".format("lalala","python","hahaha"))
# 参数含义：第一个位置：占得位置为10个字节，默认左对齐；  第0个位置，占的位置为15个字节，居中对齐；
第2个位置，占得位置长度为12个字节，右对齐；
```
程序运行结果：`I like python     and     lalala      and      hahaha`

  - 长度：
```python
print("I like {1:.2} and {0:^15.4} and{2:>12}".format("lalala","python","hahaha"))
# 参数含义：第1个位置，：后面没有数字表示占得长度自动适应即将放入该位置的字符串，.号后面数字表示对于即将传入的字符串截取前两个字符；
# 第2个参数的含义；放在第0个位置，占位长度为15个字节，居中对齐，截取将传入的字符串前4个字符

```
程序运行结果：`I like py and      lala       and      hahaha`

  - 格式符(针对数字（包括整数和浮点数）)
```python
print("I like {1:4d} and {0:f} and{2:6.2f} and {3:04f}".format(12345,900897,3434478,368937987))
#参数含义：第1个位置，长度为4个字节，以整数形式，默认是右对齐
# 第2个位置：长度自适应，以浮点数形式。默认右对齐
#第3个位置：长度6个字节，填充到此的浮点数保留2位小数，右对齐
#第4个位置：数字前面加0表示如果位数不足则补0；
```
程序运行结果：`I like 900897 and 12345.000000 and3434478.00 and 368937987.000000`


**默认情况下：字符串左对齐，数字右对齐**

### 1.5.10 常用的字符串方法
- 判断是否全为字母，使用`isalpha()`判断字符串是否全由字母组成
```python
str= "python" 
# 下面两个等价 
print(str.isalpha())
print("python".isalpha())
```
程序运行结果：
`True`
`True`

- 根据分隔符分割字符串,**返回结果形式为列表**
  - 单一分隔符：使用 `str.split()`
```python
str= "python,is a python.lan" 
print(str.split(" "))#以空格分割 
print("python,is a python.lan".split("."))#以.进行分割
print(str.split())#默认的分割符为所有空字符，包括空格、换行、制表符等等
```
程序运行结果：
`['python,is', 'a', 'python.lan']`
`['python,is a python', 'lan']`
`['python,is', 'a', 'python.lan']`

  - 多个分割符:导入包`import re`使用`re.split()`
```pyhton
import re
str= "python,is a py?thon.lan"
print(re.split(r",| ",str)) //多个分隔符之间使用|分开
print(re.split(r",| |\?",str)) //当有？等时，需要在前面加上\进行转义
```
- 去掉字符串两头的空格，会产生新的字符串，原来的字符串不变
```python
str = "  hello  " 
print(id(str))#获得原来的字符串的地址
 print("star"+str.strip()+ "end")#去除左右 所有  的空格 
 print(id("star"+str.strip()+ "end"))#获取变换之后的字符串的地址 
 print("start"+str.lstrip()+ "end")#去除 左边 的空格 
 print("start"+str.rstrip()+ "end")#去除 右边 的空格 
 print("start"+str+"end")#去除之后的字符串，原来的值没有变化，这种去除产生了新的字符串
 str = str.strip()  # 去除原来字符串两边空格并保存
```
程序运行结果：
`1651046031536`
`starhelloend`
`1651046258096`
`starthello  end`
`start  helloend`
`start  hello  end`

- 字符大小写的转换，生成一个新的字符串，不改变原有的值
  - str.upper() :将str中的字母全部转换为大写
  - str.lower() :将str中的字母全部转换为小写
  - str.capitalize() :将首字母转换为大写
  - str.isupper() :判断str中的字母是否全为大写
  - str.islower() :判断str中的字母是否全为小写
  - str.istitle() :判断str是否为标题模式，即所有单词首字母大写，其余字母全部小写 
```python
str = "hello PyThon" 
print(str.upper())
print(str.lower())

```
程序运行结果：
`HELLO PYTHON`
`hello python`

- 用join()拼接字符串,主要用于将中的各种类型元素连接，或者使用某个符号来拼接字符串
```python
a = ["python","is","the","best"]
print("*".join(a))
```
程序运行结果：`python*is*the*best`



## 1.6 字符编码
python 3 中所有字符串均采用Unicode编码，UTF-8只是其实现方法之一(采用可变长度字符编码)，同时可以使用`encode()`将Unicode编码的字符转换为其他编码




## 1.7 列表

### 1.7.1 定义
- 形式为`[]`
- 判断列表是否为空：`bool()`  空为false
- 定义：
```python
a = ['2',3,"hello"]#包含字符、数字、字符串
b= ["python",a]#同时可以套一个列表
print(a)
print(b)
```
程序运行结果为：
`['2', 3, 'hello']`
`['python', ['2', 3, 'hello']]`


### 1.7.2 索引和切片

```python
#索引

#列表元素的索引
a = ['2',3,"hello","end"]
print(a[2])
print(a[:2])
print(a[2][1:4])
print(a[-1])  #访问列表中最后一个元素
#列表元素地址的索引
"""
编号方式（适用于字符串和列表等所有序列类型）：从左至右0、1、2  或者从右至左-1、-2、-3、-4.。。。
"""
print(a.index("hello"))#这样默认返回时是按照从左到右的顺序


#切片

#典型的错误读取方式
print(a[-1:-3]) # 等价于a[(4-1):(4-3)]=a[3:1],又因为序列都是从左到右读取，这里是从右到左的读取，因此返回空值
#正确用法
print(a[-3:-1])  #等价于a[1:3]

#根据步长切片，当步长为正数的时候，相当于从左往右看数列，先看到的值为开始的值
print(a[::2])#从头搜到位，步长为2，实际上中间也就间隔一个字符  [开始：结束：步长]

# 当步长为负数的时候，相当于从右往左看数列，先看到的值为开始的值

print(a[1:3:2])
print(a[-3:3:2])
print(a[-2:1:-2])
```
程序运行结果：
`hello`
`['2', 3]`
`ell`
`2`
`[]`
`[3, 'hello']`
`['2', 'hello']`
`[3]`
`[3]`
`['hello']`


### 1.7.3  反转（适用于列表以及字符串）
```python
lst = [1,2,3,4,5,6]
str = "python"
print(lst[: : -1])
print(str[: : -1])

print(lst)
print(str)

#可以使用reversed函数进行反转，但是必须加上list，最后的结果也都是列表格式
print(list(reversed(str)))
print(list(reversed(lst)))
#注意比较两个的不同
```
程序运行结果：
`[6, 5, 4, 3, 2, 1]`
`nohtyp`
`[1, 2, 3, 4, 5, 6]`
`python`
`['n', 'o', 'h', 't', 'y', 'p']`
`[6, 5, 4, 3, 2, 1]`



### 1.7.4 操作列表
- 基本操作
  - `len()`  
```python
lst= ["i","python","lalla"]
print(len(lst))
```
程序运行结果：`3`

  - `+` :连接两个列表
  - `*` :重复序列元素
  - `in` :判断元素是否在列表中（完整性的元素，不是字符）
```python
lst= ["i","python","lalla"]
print("python" in lst)
print("la" in lst)
```
程序运行结果：
`True`
`False`

  - `max()`和`min()`寻找列表中最大或者最小的元素
```python
lst= ["i","python","lalla"]
print(max(lst))
print(min(lst))
```
程序运行结果：
`python`
`i`


- 修改列表元素（修改和追加）
```python
#修改元素

lst= ["i","python","lalla"]
lst[1] = "hello"  #将第1个元素修改为“hello”
print(lst)

#追加元素
lst.append("hulala")#在结尾追加元素,返回值为None,直接使用print(lst.append("hulala")),结果为None 同时进行的也是原地修改
print(lst)
```
程序运行结果：
`['i', 'hello', 'lalla']`
`['i', 'hello', 'lalla', 'hulala']`

**追加元素是原地修改，返回值为None**




### 1.7.5 常见的列表函数

- extend ：将两个列表合并，a:b - >a+b :b,参数可以是列表或者字符串，**但是如果为数值型就会报错**
  extend的参数必须为iterable(可迭代的（可以重复反馈）)
  使用`hasattr()`判断类型是否可迭代，判断本质是看类型中是否含有`_iter_()`这个方法，可以使用`dir`查看
  示例；
```python
lst = [1,2]
lat= 3
print(hasattr(lst,'__iter__'))
#hasattr(object，'x') 函数，用于判断对象object是否含有x属性或方法，有则返回True，否则返回False
print(hasattr(lat,"__iter__"))

```
程序运行结果：
`True`
`False`

```python
la = ["lala","lblb"]
lb = [1,2,3]
print(la.extend(lb))#la.extend(lb)的返回值为none,同时拓展之后的内存位置仍然没有改变，原地修改
print(la)
print(lb)

lc= "abcde"#当拓展参数为字符串的时候，结果是将字符串挨个字符拆开形成列表，然后在追加
la.extend(lc)
print(la)

la = ["lala","lblb"] # 当拓展为列表的时候，不再拆分然后追加，直接追加
ld = ["abcde"]
la.extend(ld)
print(la)
```
程序运行结果：
`None`
`['lala', 'lblb', 1, 2, 3]`
`[1, 2, 3]`
`['lala', 'lblb', 1, 2, 3, 'a', 'b', 'c', 'd', 'e']`
`['lala', 'lblb', 'abcde']`

**append（）和extend（）区别：**
append直接将所有内容整体打包什么都不动（包括列表的[])追加在后面
extend将追加的内容先拆开（针对列表），然后合并成一个列表


- count：查找列表中元素出现的次数(必须是完整的)
```python
lst = [1,2,3,2,1,2,1,'a','aaa']
print(lst.count(1))
print(lst.count('a'))
```
程序运行结果：
`3`
`1`

- index :查找列表中的元素（必须是完整的）在列表中第一次出现的位置
```python
lst = [1,2,3,2,1,2,1,'a']
print(lst.index(1))
print(lst.index('a'))
```
程序运行结果：
`0`
`7`

- insert ：将元素添加在列表中的任意位置：`list(i,x)`,其中i为想插入的位置，X为插入的元素，该元素插入位置之前
```python
lst = [1,2,'a']
lst.insert(2,"lalala")#insert()函数也是列表的原地修改，没有返回值，或者说返回值为None
print(lst)
lst.insert(len(lst),"end") #使用len函数，将插入值放在字符串的最后面
print(lst)

```
程序运行结果为：
`[1, 2, 'lalala', 'a']`
`[1, 2, 'lalala', 'a', 'end']`


- remove 和pop实现删除列表中的元素
  - remove ：
```python
#remove使用方式：
# 正确就删除第一个符合的对象，没有返回值；对列表进行原地修改
#如果删除的元素不在列表中，则会报错：X not in list

lst= ["python","hello","lala",1,2]
print("hello" in lst)#可以在删除之前先判断该元素是否在列表中
lst.remove("hello")#同样没有返回值，
print(lst)

```
程序运行结果：
`True`
`['python', 'lala', 1, 2]`


  - pop :使用方式: `list.pop([i])` ,其中i为所要删除的元素的位置,实际使用的时候没有[]，如果为空则表示删除最后一个，返回值为删除的元素
```python
lst= ["python","hello","lala",1,2]
print(lst.pop(1))#删除列表中第1个元素，返回值为第1个元素的值
print(lst)

```
程序运行结果：
`hello`
`['python', 'lala', 1, 2]`




- reverse :将列表的元素顺序返回来，是原地反过来(原来列表的值变化)，没有返回值,
- reversed :原来列表的值没有变化，有返回值，但是返回值并不是list（），需要转换为list()
```python
lst= ["python","hello","lala",1,2]
#reverse()
lst.reverse()
print(lst)#原列表的值改变了

#reversed()
print(reversed(lst))#返回值不是列表
print(list(reversed(lst)))#将机返回值转换为列表
print(lst)#再次打印列表，经过reversed之后的原列表没有变化
```
程序运行结果；
`[2, 1, 'lala', 'hello', 'python']`
`<list_reverseiterator object at 0x0000029BF3C09160>`
`['python', 'hello', 'lala', 1, 2]`
`[2, 1, 'lala', 'hello', 'python']`



- sort :对列表进行排序，进行原地修改，没有返回值，默认为从小到大进行排序，也可以设置关键字进行排序
```python
#使用sort（）不能实现字符串与整数进行排序，只能各自排序
lst= ["python","hello","lala"]
lst.sort()
print(lst)

#按照从大到小进行排序(反向排序)
lst.sort(reverse = True)#这里的True不能小写
print(lst)

#按照某个关键词进行排序
lst.sort(key = len) #按照长度为关键字进行排序
print(lst)
```
程序运行结果：
`['hello', 'lala', 'python']`
`['python', 'lala', 'hello']`
`['lala', 'hello', 'python']`


- sorted :产生新的列表，有返回值，可以设置从左到右或者从右到左排序
```python
lst= ["python","hello","lala"]
print(sorted(lst))#默认情况下是从小到大的排序
print(lst)#可以得到原列表并没有改变

#实现从大到小的排序
print(sorted(lst,reverse = True))

```
程序运行结果；
`['hello', 'lala', 'python']`
`['python', 'hello', 'lala']`
`['python', 'lala', 'hello']`



### 1.7.6 比较字符串和列表
- 相同点：
  - 都是序列类型
  - 都可以按照顺序进行索引
  - 都可以采用切片得到一个或者多个元素

- 不同点：
  - 列表是可以改变的，然后字符串是不可以改变的。
  - 字符串中每个元素只能是字符，列表中都可以，也可以列表套列表，形成多维列表，在多维情况下，里面的列表被当成一个元素来看待


### 1.7.7 字符串和列表的转换
- split()  ：可以根据某个分隔符将字符串转换为列表
```python
str = "hello.i am GJXAIOU .welcome you"
print(str.split(".")) #以.来分割
print(str.split(".",1))#以第一个.来分割
print(str.split())# 所有的空字符都是分隔符
```
程序运行结果：
`['hello', 'i am GJXAIOU ', 'welcome you']`
`['hello', 'i am GJXAIOU .welcome you']`
`['hello.i', 'am', 'GJXAIOU', '.welcome', 'you']`



- join :连接list中的元素或者字符串中的字符

```python
lst = ['hello.i', 'am', 'GJXAIOU', '.welcome', 'you']
str1 = [1,2,3,'a','b']
print("".join(lst))#没有连接符，表示紧邻着
print(",".join(lst))#以英文的.作为连接符
print(" ".join(str(str1)))#以为list中含有数字，不能直接转换成字符串
```
程序运行结果：
`hello.iamGJXAIOU.welcomeyou`
`hello.i,am,GJXAIOU,.welcome,you`
`[ 1 ,   2 ,   3 ,   ' a ' ,   ' b ' ]`






## 1.8 元组（tuple）

这是一种（数据）或者对象类型,其元素可以包含任何类型的数据,==元组的对象是可以迭代的==
格式为：用（）括起来，中间的元素使用`,`隔开，==元组是序列，元素不能更改==
```python
lst = 1,2,"lalala",["jdjjdfj",1234],("123",12,'abadf')#几乎包含了所有的数据类型
print(lst)
print(type(lst))
```
程序运行结果：
`(1, 2, 'lalala', ['jdjjdfj', 1234], ('123', 12, 'abadf'))`
`<class 'tuple'>`




### 1.8.2 索引和切片

主要的方法和列表以及字符串几乎相同，只是当元组中只有一个元素的时候，元素后面应该加上英文的`,`,
```python
lst = (3)
lat = (3,)
print(type(lst))
print(type(lat))
```
程序运行结果为：
`<class 'int'>`
`<class 'tuple'>`

以为元素是不可修改的，如果需要修改元组可以将元组转换成一个列表，然后在进行修改
函数为：`list()` 以及 `tuple()`






### 1.8.3 元组的用途
- 元组的操作比列表快，所以当定义一个值之后以后只是遍历的话，使用元组
- 元组可以进行“写保护”，如果要改变的话先转换为列表
- 元组可以在字典中用作key（因为字典的key是保持不变的）

- 元组的值不可修改，但是可以给存储元组的变量进行赋值



## 1.9 字典

一般用于存放一个对象的各种属性，或者多个相似对象的同一种信息
### 1.9.1 创建字典
```python
#“A”：“B” ，为一对键/值对,前面为键，后面为值，每一个字典中键都是唯一的，
person = {"name":"gjxaiou","site":"www.gaojixu.com","language":"python"}
print(person)

#向已经建立的字典中增加键值对：
person['name2']= "GJXAIOU"  #字典是进行原地修改


#方法二：使用dict()函数
name = (["first","google"],["second","Yahoo"])
web = dict(name)

print(web)


#方法三：使用fromkeys()
website = {}.fromkeys(("third","forth"),"facebook")
print(website)

#注意；元组可以做键值，但是列表不能
dd = {(1,2):1}
print(dd)
#ee = {[1,2],1},会报错
```

### 1.9.2 访问字典的值，通过键就可以得到值
```python
#首先字典中是没有索引的
person = {"name":"gjxaiou","site":"www.gaojixu.com","language":"python"}
print(person['name'])
```
程序运行结果：`gjxaiou`


### 1.9.3 基本操作
- `len(d)` :返回字典中的键值对数量
- `d[key]` :返回字典中键对应的值
- `d[key] = value` :将value赋值给字典中的键
- `del d[key]` :删除该键对应的键值对
- `key in d` :检查字典中是否含有键为key的项



### 1.9.5 字典的方法
- copy ：对象有类型，变量无类型
```python
#基本的赋值操作
a = 5
b = a
print(a)
print(id(a))
print(id(b))
```
程序运行结果：
`5`
`140703865942992`
`140703865942992`

```python
#使用copy得到的是新的空间，和原来的各不相干
person = {"name":"gjxaiou","site":"www.gaojixu.com","language":"python"}
cd = person.copy()

print(cd)
print(id(cd))
print(id(person))
print(id(person["name"]))
print(id(cd["name"]))#两个键的值（列表）为同一个对象
```
程序运行结果；
`{'name': 'gjxaiou', 'site': 'www.gaojixu.com', 'language': 'python'}`
`2246490159576`
`2246490159504`
`1341291115664`
`1341291115664`

- `deepcopy()` ,深拷贝形成一个副本，相当于两个完全无关的字典

```python
#使用copy得到的是新的空间，和原来的各不相干
import copy
person = {"name":"gjxaiou","site":"www.gaojixu.com","language":"python"}
cd = copy.deepcopy(person)

print(cd)
print(id(cd))
print(id(person))
print(id(person["name"]))
print(id(cd["name"]))#两个键的值（列表）为同一个对象
```
程序运行结果：
`{'name': 'gjxaiou', 'site': 'www.gaojixu.com', 'language': 'python'}`
`1652151429808`
`1652150008208`
`1652150776976`
`1652150776976`






- clear 清空字典中的所有元素,得到空字典，但是对象仍然在内存中，而`del`是直接将字典删除，内存中就没有了
```python
#clear 没有返回值，是对字典进行了原地修改
a = {"name" : "GJXAIOU"}
a.clear()
print(a)

```
程序运行结果：`{}`



- get 和setdefault
  - get 的含义是获取该键对应的值，如果没有发现也不报错
```python
a = {"name" : "GJXAIOU","age":"lalala"}
print(a.get("name"))
print(a.get("gjx","no answer"))#如果找到键的值就返回键的值，如果没有就返回后面的值
print(a.setdefault("first","second"))#如果找到键的值就返回键的值，如果没有就返回后面的值,并且将这个键值对加入原来的字典中
print(a)
```
程序运行结果：
`GJXAIOU`
`no answer`
`second`
`{'name': 'GJXAIOU', 'age': 'lalala', 'first': 'second'}`


- items .keys  .values
  - items
```python
a ={'name': 'GJXAIOU', 'age': 'lalala', 'first': 'second'}
print(a.items())
```
程序运行结果：`dict_items([('name', 'GJXAIOU'), ('age', 'lalala'), ('first', 'second')])`

  - keys 得到所有的键，value 得到所有的值
```python
a ={'name': 'GJXAIOU', 'age': 'lalala', 'first': 'second'}
print(a.keys())
print(a.values()) 
```
程序运行结果：
`dict_keys(['name', 'age', 'first'])`
`dict_values(['GJXAIOU', 'lalala', 'second'])`





- pop 和popitem
  - pop 删除键值对
```python
a ={'name': 'GJXAIOU', 'age': 'lalala', 'first': 'second'}
print(a.pop("name"))#以键为参数，将指定键的键值对删除，返回值为键所对应的值，如果没有找到键，就返回错误
print(a)
print(a.pop("name","no find in:'name'")) #pop后面可以是两个参数，以逗号隔开，如果有这个键，就返回对应的值，如果没有就返回后面的这个参数
print(a)
```
程序运行结果：
`GJXAIOU`
`{'age': 'lalala', 'first': 'second'}`
`no find in:'name'`#这里因为上面已经删除了，所以找不到了
`{'age': 'lalala', 'first': 'second'}`

  - popitem 
```python
a ={'name': 'GJXAIOU', 'age': 'lalala', 'first': 'second'}
print(a.popitem( ))#可以不写参数，就是随机删除一个，然后将删除的值返回，返回的格式为元组
```
程序运行结果：`('first', 'second')`




- update :更新字典内容，函数返回值为None即没有返回值
```python
a ={'name': 'GJXAIOU', 'age': 'lalala', }
b = {'first': 'second'}
a.update(b)
print(a)
# 字典b更新纳入字典a 中，函数返回值为None，当然b并没有变化
```
程序运行结果：`{'name': 'GJXAIOU', 'age': 'lalala', 'first': 'second'}`





## 1.10 集合（set）
特点：有的可变、有的不可变、元素无次序、不可重复
集合没有索引，没有顺序，不属于序列
```python
#创建集合，这里是将字符串拆后形成集合 ，这里hello中有两个l,但是集合中只有一个l

#通过set函数创建
a= set("helloworld")
print(a)

# 直接创建,尽量避免使用这种方法
b = {"facd",123}
print(type(b))
print(b)


#unhashable  不可哈希 ：表示该数据时可变的，例如列表、字典都能原地修改
#使用{} 进行创建的时候，元素要求是可哈希的，随意存在字典、列表就报错
#但是set（）建立起来的集合是可变集合。可变集合都是不可哈希类型
```
程序运行结果；
`{'e', 'h', 'd', 'r', 'w', 'l', 'o'}`
`<class 'set'>`
`{123, 'facd'}`




### 1.10.2 set 的方法

- add和update
```python
#如果要创建一个空集合，只能使用set，
a_set = {}  #这样默认情况下创建的是字典
print(type(a_set))

s= set()
print(type(s))#创建一个空集合
s.add("hello")#为该集合增加一个元素
print(s)
```
程序运行结果：
`<class 'dict'>`
`<class 'set'>`
`{'hello'}`


- update 
```python
s1= set(['a','b'])
s2 = set(['c','d'])
s2.update(s1)
print(s2)
s2.update("hello")
print(s2)
s2.update((2,3))
print(s2)
```
程序运行结果：
`{'c', 'd', 'b', 'a'}`
`{'d', 'e', 'o', 'l', 'c', 'h', 'b', 'a'}`
`{2, 3, 'd', 'e', 'o', 'l', 'c', 'h', 'b', 'a'}`


- pop,remove,discard,clear
```python
#pop :没有参数，删除元素也是随机删除，返回值为删除的元素，没有可以删除的元素的时候就会报错
b_set = {'e', 'h', 'd', 'r', 'w', 'l', 'o'}
print(b_set.pop())

#remove :没有返回值，删除的指定元素不存在时候会报错
b_set.remove("d")#删除指定的值
print(b_set)


#discard :没有返回值，有就删除，没有就什么都不做
b_set.discard("r")
print(b_set)

#clear ：清空所有元素
b_set.clear()
print(b_set)
```
程序运行结果：
`e`
`{'o', 'h', 'l', 'r', 'w'}`
`{'o', 'h', 'l', 'w'}`
`set()`




### 1.10.3 使用frozenset创建不可变集合



### 1.10.4 集合运算

- 元素与集合的关系
```python
#判断元素是否在集合中 
b_set = {'e', 'h', 'd', 'r', 'w', 'l', 'o'}
print("h" in b_set)
```
程序运行结果：`True`


- 集合与集合的关系
```python
#判断两个集合是否完全一样

a_set = {'e','d','g','k'}
b_set = {'e', 'h', 'd', 'r', 'w', 'l', 'o'}
print(a_set == b_set)


#判断A是否是B的子集

a_set = {'e','d','g','k'}
b_set = {'e', 'h', 'd', 'r', 'w', 'l', 'o'}
print(a_set < b_set)
#或者：print(a_set.issubset(b_set))


#求A与B的并集

a_set = {'e','d','g','k'}
b_set = {'e', 'h', 'd', 'r', 'w', 'l', 'o'}
c_set = a_set |b_set
#或者使用  a_set.union(b_set)
print(c_set)



#求A与B的交集

a_set = {'e','d','g','k'}
b_set = {'e', 'h', 'd', 'r', 'w', 'l', 'o'}
c_set = a_set & b_set
#或者：c_set = a.intersection(b_set)
print(c_set)



#A 相对于B的差（补），即A相对于B不同的部分元素    （书P98）

a_set = {'e','d','g','k'}
b_set = {'e', 'h', 'd', 'r', 'w', 'l', 'o'}
print(a_set - b_set)
#上面等价于：print(a_set.difference(b_set))
print(b_set - a_set)
#上面等价于：print(b_set.difference(a_set))



# A 与B的对称差集
a_set = {'e','d','g','k'}
b_set = {'e', 'h', 'd', 'r', 'w', 'l', 'o'}
print(a_set.symmetric_difference(b_set))

```
程序运行结果：
`False`
`False`
`{'w', 'h', 'd', 'r', 'o', 'k', 'l', 'g', 'e'}`
`{'e', 'd'}`
`{'g', 'k'}`
`{'w', 'h', 'r', 'o', 'l'}`
`{'w', 'h', 'r', 'o', 'k', 'l', 'g'}`






-----------------------------------------------------------------







---
dateline:`2018-11-21`
---

# 第2章 语句和文件


## 2.1 运算符

### 2.1.1 算术运算符
| 运算符 | 描述 | 实例 |
|---|---|---|---|
| + | 加 - 两个对象相加                            | a + b 输出结果 30 |
| - | 减 - 得到负数或是一个数减去另一个数            | a - b 输出结果 -10 |
| * | 乘 - 两个数相乘或是返回一个被重复若干次的字符串 | a * b 输出结果 200 |
| / | 除 - x除以y                                  | b / a 输出结果 2 |
| % | 取余 - 返回除法的余数                          | b % a 输出结果 0 |
| ** | 幂 - 返回x的y次幂                     | a**b 为10的20次方， 输出结果 100000000000000000000 |
| // | 取整除 - 返回商的整数部分（**向下取整**） |  9//2 =4    ； -9//2 = -5


### 2.1.2 比较运算符
任何两个同一类型的对象都可以进行比较

| 运算符 | 描述 | 实例 |
|---|---|---|---|
| == | 等于 - 比较对象是否相等 | (a == b) 返回 False。 |
| != | 不等于（python3） - 比较两个对象是否不相等 | (a != b) 返回 true. |
| <> | 不等于（python2） - 比较两个对象是否不相等 | (a <> b) 返回 true。这个运算符类似 != 。 |
| > | 大于 - 返回x是否大于y | (a > b) 返回 False。 |
| < | 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。 | (a < b) 返回 true。 |
| >= | 大于等于 - 返回x是否大于等于y。 | (a >= b) 返回 False。 |
| <= | 小于等于 - 返回x是否小于等于y。 | (a <= b) 返回 true。 |



### 2.1.3 逻辑运算符

- 1.布尔类型
本质上就是返回值为 `True` 和`False` 的对象
注意：
```python
a = " "#这里是空格，空格也是一个字符
print(bool(a))

b = ""#这里是空，不是空格
print(bool(b))

print(bool([])) #这是空列表

print(bool({})) #这是空字典
```
程序运行结果：
`True`
`False`
`False`
`False`

- 2.布尔运算
进行布尔运算的运算符称为逻辑运算符  ：and   or     not

  - and :      A and  B
  **含义：** 如果A 为true，计算B，最终结果为B   ；如果A为False ，就不用计算B，结果为False

  - or  :     A or B  
  **含义：** 如果A的值为True ，结果为True  ； 如果A为False，结果看B的值

  - not   ：not A
  **含义：** 取反就行

对于复杂的布尔表达式一定使用括号来自主选择优先级



## 2.2 简单语句  

### 2.2.1  import   
使用`import math`    导入math模块,
使用math模块里面的函数：`math.pow(3,2)`,这种应用方式可以避免函数重名



### 2.2.2 赋值
```python
#批量的进行一一赋值
x,y,z = 1,"python",["hello","world"]
print(x)
print(y)
print(z)

#将多个值赋值给一个：相当于自动创建一个元组

aa = "hello","python"
print(aa)



## 交换元素值(实现数值对调 )    变量只是贴在对象上的标签

la = 2
lb = 3
la,lb = lb,la
print(la)
print(lb)




## 链式赋值

m = n = "python"
print("m = ",m, "; n = " ,n)
print("id(m) = ",id(m), "id(n) = ",id(n))  #实际上两个变量所指向的是同一个对象
#以上判断内存是否一致方法还可以使用is
print(m is n)  #如果结果为True，则表示两个变量所引用的对象是同一个



## 两变量赋值同样的对象
lala = "python"
lblb = "python"
print(lala is lblb) # 其结果并非同一个


# 下面这句有待商榷
#例外情况：当两个变量都分别赋值小于等于256及其以下的值时候，其所指的都是同一块内存，等价于链式赋值，但是大于256就是两个对象

lu = 256
lk = 256
print(lu is lk)

ld = 257
ldd = 257
print(id(ld),id(ldd))
print(ld is ldd)

ld = 4097
ldd =4097
print(id(ld),id(ldd))
print(ld is ldd)

#可以使用+实现赋值
x = 9
x += 1
print(x)


y = "pyth"
y += "on"
print(y)
```
程序运行结果：
`1`
`python`
`['hello', 'world']`
`('hello', 'python')`
`3`
`2`
`m =  python ; n =  python`
`id(m) =  2859978232080 id(n) =  2859978232080`
`True`
`True`
`True`
`2859977205744 2859977205744`
`True`
`2859978871344 2859978871344`
`True`
`10`
`python`

## 2.3 条件语句

### 2.3.1 if  ...elif ...else
```python
#!/usr/bin/env python
# -*- coding:utf-8 -*-
#@Time :2018/11/14 19:23
#Author:GJXAIOU

import math

print("please input a number :")

number = input()  #这里不能使用int进行强转，如果使用int就不能使用isdigit

if number.isdigit():# isdigit()是检测字符串是否由数字组成

    if int(number) == 10:
        print("The number of you input is :{}".format(number))
        print("You are smart")

    elif int(number) < 10:
        print("The number of you input is :{}".format(number))
        print("The number is bigger than you input")

    else:
        print("The number of you input is :{}".format(number))
        print("The number is smaller than you input")

else:
    print(" The input is not number,please input number")

```


### 2.3.3 三元操作符
```python
name = "qiwsie" if 29 > 21 else "github"
```

**函数定义：**  A = Y if X else Z 
- 如果X为真，那么就执行 A= Y
- 如果X为假，就执行 A= Z




## 2.4 for循环语句
只有序列类型可以使用for 循环（包括：列表和字符串）
```python
for 循环规则：
    操作语句
```

示例程序；
```python
hello = "world"
for i in hello:
    print(i)

```
下面的程序等效于上面的程序：
```python
hello = "world"
for i in range(len(hello)):
    print(hello[i])
```
程序运行结果：
`w`
`o`
`r`
`l`
`d`

- print()默认的`end = \n`,所以在默认的情况下，每个元素都单独占一行
- 字典也可以使用for循环，但是得到的结果是获取字典中所有的键值
```python
s = dict([("web","hello"),("lang","world"),("author","laogao")])
for k in s.keys():  #同样是获得字典中所有的键值
    print(k)

for v in s.values(): #获得字典中所有的值
    print(v)

for k,v in s.items():  #同时获得字典中所有的键和值
    print(k + "-->" +v)
```
程序运行结果：
`web`
`lang`
`author`
`hello`
`world`
`laogao`
`web-->hello`
`lang-->world`
`author-->laogao`

- **for循环所应用的对象必须是可迭代的**
判断一个对象是否可以迭代
```python
from collections import Iterable

print(isinstance(123,Iterable))
```
(需要在终端中运行)程序运行结果：
`False`

==字符串、列表、字典、元组、集合都是可迭代对象==




### 2.4.3  range(start,stop,[,step])
- 参数含义：开始，结尾，步长
- 当步长为1 的时候可以省略
- 当start为0的时候，可以省略
- 当步长不为1的时候，开始不可以省略
```python
"""
range 的使用 ；P118

"""
print(range(1,7,2)) #第一个值为1，然后是start+1 * step ，以此类推
print(type(range(1,7,2))) #range 得到的结果为一个序列类型，序列的名字就是range

print(range(0,-9,-1))  #这样无法得到列表

print(list(range(0,-9,-1)))#结果为列表
```
程序的运行结果；
`range(1, 7, 2)`
`<class 'range'>`
`range(0, -9, -1)`
`[0, -1, -2, -3, -4, -5, -6, -7, -8]`



### 2.4.4 并行迭代
```pyhton

"""
使用zip() 进行并行迭代：P120
"""
#迭代：将for循环用于列表、字符串、字典的键值对就是迭代
# zip()的参数需要是可迭代对象，返回值是一个zip对象

#当参数为普通序列时候
a = "hello"
b = "world"
c = "gaojixu"
print(zip(a,b))  #函数名表示函数在内存中的信息
print(list(zip(a,b)))# 序列长度相同的时候
print(list(zip(a,c))) #序列长度不同的时候，以两个中短的那个为准

#当参数为字典的时候
d = {"name":"GJX"}
e = {"age":"23"}
print(list(zip(d,e))) #得到的是所有的键值


#当参数是一个序列时候
f = "hello"
g = "world"
print(list(zip(f)))
print(list(zip(g)))


#应用，两个序列对应位置元素运算
a = [1,2,4,5,6]
b = [2,3,4,5,7]
d = []
for x,y in zip(a,b):
    d.append(x + y)


print(d)
```
程序运行结果：
`<zip object at 0x0000026214FB9B48>`
`[('h', 'w'), ('e', 'o'), ('l', 'r'), ('l', 'l'), ('o', 'd')]`
`[('h', 'g'), ('e', 'a'), ('l', 'o'), ('l', 'j'), ('o', 'i')]`
`[('name', 'age')]`
`[('h',), ('e',), ('l',), ('l',), ('o',)]`
`[('w',), ('o',), ('r',), ('l',), ('d',)]`
`[3, 5, 8, 10, 13]`

### 2.4.5 enumerate使用
```python
'''
enumerate的使用；p123
'''

'''
同时得到列表中元素的索引和元素 p123
'''
# 一般方法
week = ['monday','sunday','friday']
for i in range(len(week)):
    print(week[i] + 'is' + str(i)) #str(i) ,将整数i 转换为字符串类型，因为有加号

#使用enumerate 内建函数
for (i,day) in enumerate(week):
    print(day + "is" + str(i))

'''
直接显示列表中的索引和元素  p124
'''
seasons = ['spring','summer','fall','winter']
print(list(enumerate(seasons)))
print(list(enumerate(seasons,start = 1)))

'''
当原本的为字符串的时候，需要先转换为列表  p124
'''

#将字符串中部分字符进行替换

raw = "hello world ,you are a good good student ."
raw_list = raw.split()

for i,string in enumerate(raw_list):
    #if string =="good":  使用该语句只能查找得到第一个good,后面的改不了
    if "good" in string:
        raw_list[i] = "best"

print(raw_list)
```
程序运行结果：
`mondayis0`
`sundayis1`
`fridayis2`
`mondayis0`
`sundayis1`
`fridayis2`
`[(0, 'spring'), (1, 'summer'), (2, 'fall'), (3, 'winter')]`
`[(1, 'spring'), (2, 'summer'), (3, 'fall'), (4, 'winter')] `
`['hello', 'world', ',you', 'are', 'a', 'best', 'best', 'student', '.']`

### 2.4.6 列表解析
```python

'''
列表解析：p125
'''

#得到1-9的平方，放入列表并打印

outlist1 = []
for i in range(1,10):
    outlist1.append(i**2)
print(outlist1)

#使用列表解析得到
outlist2 = [(i**2) for i in range(1,10)]
print(outlist2)


#删除列表中字符串前后的空格
raw_list = ["  hello"," lala ","world  "]
ans_list = [one.strip() for one in raw_list]
print(ans_list)
```
程序运行结果：
`[1, 4, 9, 16, 25, 36, 49, 64, 81]`
`[1, 4, 9, 16, 25, 36, 49, 64, 81]`
`['hello', 'lala', 'world']`




## 2.5 while循环语句
示例程序：
```python

'''
while循环示例：P129
'''
import  random
num = random.randint(1,100)
guess = 0

while True:
    num_input = input("please input one interger that is in 1 to 100:")
    guess +=1
    if not num_input.isdigit():#用来判断字符串是否全部由数字组成
        print("please input interger.")
    elif int(num_input) < 0 or int(num_input) > 100:
        print("please input number that is in 1 to 100:")
    else:
        if num == int(num_input):
            print("you are so smart")
            break
        elif num > int(num_input):
            print("the true num is bigger than you input")
        elif num < int(num_input):
            print("the true num is smaller than you input")
        else:
            print("There is something bad")
```

### 2.5.2 break和continue 

**1.break：** 主要是在当前位置中断循环并且跳出循环体

**continue：** 从当前位置（continue 位置）跳到循环体的最后一行的后面（不执行最后一行）

==尽量在循环之前将条件做足，避免使用这两个在循环中跳来跳去==



### 2.5.3 while....else
例子：
```python
'''
while ...else P130
'''

count = 0
while count < 5 :
    print(count ,"is less than 5")
    count += 1
else:
    print(count,"is not less than 5")
```
程序运行结果：
`0 is less than 5`
`1 is less than 5`
`2 is less than 5`
`3 is less than 5`
`4 is less than 5`
`5 is not less than 5`

### 2.5.4 for ...else
```python
'''
for ...else  P131
'''
from math import sqrt
for i in range(99,80,-1):
    root = sqrt(i)
    if root == int (root):
        print(root ,"is the sqrt of",i)
        break                            #这个break作用是？
    else:
        print("nothing")
```
程序运行结果：
`nothing`
`nothing`
`nothing`
`9.0 is the sqrt of 81`



## 2.6  文件

### 2.6.1 读文件

```python
'''
读文件：p131
'''
f = open("123.txt") #表示该文件在当前目录下，如果在其他目录下要写上路径
for line in f:
    print(line)

```
程序运行结果：
`你好世界`

`12345`

`best`
#因为每行的最后都有`\n`,同时print在默认情况下，打印完line的对象之后会增加一个`\n`,因此中间会空一行；

上面程序改进
```python
f = open("123.txt") #表示该文件在当前目录下，如果在其他目录下要写上路径
for line in f:
    print(line,end = ' ')
```

**文件对象是可迭代的**





### 2.6.2 创建文件
‘r’只读模式，**必须打开一个已有的文件，且只能执行读操作**。

‘r+’读+追加模式，可读可写，与‘r’相同之处在于也是必须打开一个已有的文件，不同的是它可写可读，而且写与读不分先后，即随时都可进行读与写。（写为追加在文件末尾）

‘w’只写模式，**打开即默认创建一个新的空文件，当然若打开的是已有文件，则清空文件，且只能执行写操作**。

‘w+’写读模式，打开创建新文件，因此需要先把内容写进去在读。即保证文件有内容通过移动光标来读自己想要的部分。

‘a’追加模式，若打开的是已有文件则直接对已有文件操作，若打开文件不存在则创建新文件，只能执行写（追加在后面），不能读。即追加写。

‘a+’追加读写模式，打开文件方式同‘a’一样，写方式也和'a'一样，但是可以读。且是任意时刻读写。需要注意的是你若刚用‘a+’打开一个文件，则不能立即读，因为此时光标已经是文件末尾，除非你把光标移动到初始位置或任意非末尾的位置。






### 2.6.3 使用with

```python
'''
使用with  p135
'''

#常用的使用文件方法：
# fn = open("abc.txt","a") #打开文件
# fn.write("python is the best") #写入文件
# fn.close()     #关闭文件


#使用with进行操作，这时候就不需要使用close

with open("abc.txt") as fn:
    print(fn.read())

```
当然程序中两个代码的作用是不一样的，这里只是示范一下使用方法

### 2.6.4 文件的状态

可以获取文件的创建日期、修改日期的状态信息
```python

'''
文件的状态：p136
'''

import os
file_state = os.stat("abc.txt")
print(file_state)

```
程序运行结果；
`os.stat_result(st_mode=33206, st_ino=562949953675316, st_dev=1143006259, st_nlink=1, st_uid=0, st_gid=0, st_size=18, st_atime=1542798239, st_mtime=1542798211, st_ctime=1542798211)`
显示的结果看不懂
换一种显示方式：
```python
'''
换种时间显示方式：
'''
import os
file_state = os.stat("abc.txt")
import time
state_file = time.localtime(file_state.st_ctime)
print(state_file)
```
程序运行结果：
`time.struct_time(tm_year=2018, tm_mon=11, tm_mday=21, tm_hour=19, tm_min=3, tm_sec=31, tm_wday=2, tm_yday=325, tm_isdst=0)`


### 2.6.5 read /readline / readlines 

- **read:** 完整的表达方式：read(size) ,指一次性读取文件中size个字符并且返回一个字符串，如果省略的话则读取文件对象中的字符直到EOF，并且依然返回字符串
- **readline:** 每次执行`文件名.readlines()` ,只读取一行，直到最后一行，最后一行之后还执行的话会返回空字符串，但是不报错
- **readlines：** 它的作用是将文件中的各行读取出来，最后结果放在一个列表中返回




### 2.6.6 读很大的文件
使用fileinput模块，使用方式如下：
```python
'''
使用fileinput 模块进行大文件的读取
'''
import fileinput
for line in fileinput.input("lianxi.txt"):
    print(line,end = " ")
```
程序运行结果：防止运行时可以的


### 2.6.7 seek
[seek使用报错解决](https://blog.csdn.net/gaojixu/article/details/84331063)
首先在读取文件的时候，指针随之运动，当读取结束的时候，指针就移动到相应的位置了
例如：文件f.txt中内容如下；
 you raise me up
 when i am down
 please help me
 lalalalala

```python
'''
使用seek   
'''

f = open("f.txt","rb") #如果使用seek，这里必须使用rb
print(f.readline(),end = " ")
print(f.tell()) #文件名.tell()   显示当前偏移量移动指针的位置

f.seek(0) #将指针的位置偏移量置为0，相当于把位置移动到开头
print(f.tell())
print(f.readline(),end = " ")
print(f.tell())


#seek的标准形式为 :seek(offset[,whence])

#whence 默认值为0，表示从文件开头进行计算偏移量，这时候offset必须大于等于0
#whence 如果为1，表示从当前位置开始计算偏移量，如果offence为负数，表示往前移动，为正表示往后移动
#whence 如果为2，表示相对于文件末尾移动

f.seek(-5,1) #以当前位置为准，往后移动两个
print(f.readline(),end = " ")

```
程序运行结果；
`b'you raise me up\r\n' 17`
`0`
`b'you raise me up\r\n' 17`
`b' up\r\n' `



## 2.7 初识迭代

- **循环：** 指是在满足条件的情况下，重复执行同一段代码，如while语句
- **迭代：** 指的是按照某种顺序逐个访问对象（如列表）中的每一句，如for语句
- **递归：** 指的是一个函数不断调用自身的行为，如斐波那契数列
- **遍历：** 指的是按照一定的规则访问树形结构中的每一个节点，而且每个节点都只访问一次，例如for循环




## 书上对应代码练习：
```python
#!/usr/bin/env python
# -*- coding:utf-8 -*-
#@Time :2018/11/15 22:04
#Author:GJXAIOU


"""
本代码为第二章练习代码，从笔记中的2.4.3中开始，其他将会陆续补充

"""



"""
range 的使用 ；P118

"""
# print(range(1,7,2)) #第一个值为1，然后是start+1 * step ，以此类推
# print(type(range(1,7,2))) #range 得到的结果为一个序列类型，序列的名字就是range
#
# print(range(0,-9,-1))  #这样无法得到列表
#
# print(list(range(0,-9,-1)))#结果为列表







"""
使用zip() 进行并行迭代：P120
"""
# #迭代：将for循环用于列表、字符串、字典的键值对就是迭代
# # zip()的参数需要是可迭代对象，返回值是一个zip对象
#
# #当参数为普通序列时候
# a = "hello"
# b = "world"
# c = "gaojixu"
# print(zip(a,b))  #函数名表示函数在内存中的信息
# print(list(zip(a,b)))# 序列长度相同的时候
# print(list(zip(a,c))) #序列长度不同的时候，以两个中短的那个为准
#
# #当参数为字典的时候
# d = {"name":"GJX"}
# e = {"age":"23"}
# print(list(zip(d,e))) #得到的是所有的键值
#
#
# #当参数是一个序列时候
# f = "hello"
# g = "world"
# print(list(zip(f)))
# print(list(zip(g)))
#
#
# #应用，两个序列对应位置元素运算
# a = [1,2,4,5,6]
# b = [2,3,4,5,7]
# d = []
# for x,y in zip(a,b):
#     d.append(x + y)
#
#
# print(d)


'''
enumerate的使用；p123
'''
#
# '''
# 同时得到列表中元素的索引和元素 p123
# '''
# # 一般方法
# week = ['monday','sunday','friday']
# for i in range(len(week)):
#     print(week[i] + 'is' + str(i)) #str(i) ,将整数i 转换为字符串类型，因为有加号
#
# #使用enumerate 内建函数
# for (i,day) in enumerate(week):
#     print(day + "is" + str(i))
#
# '''
# 直接显示列表中的索引和元素  p124
# '''
# seasons = ['spring','summer','fall','winter']
# print(list(enumerate(seasons)))
# print(list(enumerate(seasons,start = 1)))
#
# '''
# 当原本的为字符串的时候，需要先转换为列表  p124
# '''
#
# #将字符串中部分字符进行替换
#
# raw = "hello world ,you are a good good student ."
# raw_list = raw.split()
#
# for i,string in enumerate(raw_list):
#     #if string =="good":  使用该语句只能查找得到第一个good,后面的改不了
#     if "good" in string:
#         raw_list[i] = "best"
#
# print(raw_list)





'''
列表解析：p125
'''

# #得到1-9的平方，放入列表并打印
#
# outlist1 = []
# for i in range(1,10):
#     outlist1.append(i**2)
# print(outlist1)
#
# #使用列表解析得到
# outlist2 = [(i**2) for i in range(1,10)]
# print(outlist2)
#
#
# #删除列表中字符串前后的空格
# raw_list = ["  hello"," lala ","world  "]
# ans_list = [one.strip() for one in raw_list]
# print(ans_list)




'''
while循环示例：P129
'''
# import  random
# num = random.randint(1,100)
# guess = 0
#
# while True:
#     num_input = input("please input one interger that is in 1 to 100:")
#     guess +=1
#     if not num_input.isdigit():
#         print("please input interger.")
#     elif int(num_input) < 0 or int(num_input) > 100:
#         print("please input number that is in 1 to 100:")
#     else:
#         if num == int(num_input):
#             print("you are so smart")
#             break
#         elif num > int(num_input):
#             print("the true num is bigger than you input")
#         elif num < int(num_input):
#             print("the true num is smaller than you input")
#         else:
#             print("There is something bad")




'''
while ...else P130
'''
# count = 0
# # while count < 5 :
# #     print(count ,"is less than 5")
# #     count += 1
# # else:
# #     print(count,"is not less than 5")



'''
for ...else  P131
'''
# from math import sqrt
# for i in range(84,80,-1):
#     root = sqrt(i)
#     if root == int (root):
#         print(root ,"is the sqrt of",i)
#         break                            #这个break作用是？
#     else:
#         print("nothing")


'''
读文件：p131
'''
# f = open("123.txt") #表示该文件在当前目录下，如果在其他目录下要写上路径
# for line in f:
#     print(line,end = ' ')


'''
使用with  p135
'''

#常用的使用文件方法：
# fn = open("abc.txt","a") #打开文件
# fn.write("python is the best") #写入文件
# fn.close()     #关闭文件


#使用with进行操作，这时候就不需要使用close

# with open("abc.txt") as fn:
#     print(fn.read())



'''
文件的状态：p136
'''
#
# import os
# file_state = os.stat("abc.txt")
# print(file_state)
#

'''
换种时间显示方式：
'''
# import os
# # file_state = os.stat("abc.txt")
# # import time
# # state_file = time.localtime(file_state.st_ctime)
# # print(state_file)


'''
使用fileinput 模块进行大文件的读取
'''
# import fileinput
# for line in fileinput.input("lianxi.txt"):
#     print(line,end = " ")
#




'''
使用seek   
'''
#
# f = open("f.txt","rb")
# print(f.readline(),end = " ")
# print(f.tell()) #文件名.tell()   显示当前偏移量移动指针的位置
#
# f.seek(0) #将指针的位置偏移量置为0，相当于把位置移动到开头
# print(f.tell())
# print(f.readline(),end = " ")
# print(f.tell())
#
#
# #seek的标准形式为 :seek(offset[,whence])
#
# #whence 默认值为0，表示从文件开头进行计算偏移量，这时候offset必须大于等于0
# #whence 如果为1，表示从当前位置开始计算偏移量，如果offence为负数，表示往前移动，为正表示往后移动
# #whence 如果为2，表示相对于文件末尾移动
#
# f.seek(-5,1) #以当前位置为准，往后移动两个
# print(f.readline(),end = " ")



'''
闭包：p168
'''
# def foo():
#     a = 3
#     def bar():
#         return a
#     return bar
#
# f = foo()
# print(f())



'''
lambda的使用：p170
'''
# lam = lambda x,y :x + y
# buf = []
# for i in range(10):
#     buf.append(lam(i,i+1))
#
# print(buf)


'''
map使用 p172
'''
# numbers1 = [1,2,3,4,5,6,7,8,9]
# numbers2 = [1,2,3,4,5,6,7,8,9]
# numbers3 = [1,2]
#
# a =list(map(lambda x,y: x+y ,numbers1,numbers2))
# b =list(map(lambda x,y: x+y ,numbers1,numbers3))
# print(a)
# print(b)



'''
reduce p173
'''
# from functools import reduce
# a = reduce(lambda x,y:x+y,[1,2,3,4,5])
# print(a)







```



  




------------------------------------------------------------






---
date：`2018-11-15`
---

# 第3章 函数


## 3.1函数的基本概念

### 3.1.1 理解函数

- 变量本质上时占位符，变量名通常使用小写字母进行命名，可以使用下划线连接多个单词



### 3.1.2 定义函数
1.标准格式
```python
#!/usr/bin/env python
# -*- coding:utf-8 -*-
#@Time :2018/11/15 14:49
#Author:GJXAIOU

def add_function(a,b): 
    #定义一个函数使用 ：  def   函数名（参数）:    其中：表示函数头的结束
    # 函数名的命名；小写字母或者单下划线或者数字
    #这里a,b作为形参，也可以认为是变量，而变量无类型，所以并没有规定其所引用的对象的类型，意义取决于对象的类型，称为多态
    c = a + b   # 函数体必须缩进4个空格
    return c  #return语句执行的时候，python会跳出当前的函数并且返回到调用这个函数的地方


if __name__ == "__main__":
    result = add_function(2,3)  #调用函数并且将实参传递给函数
    print(result)


# 下面为函数的其他使用方法

# 只写函数名会得到该函数在内存中的存储信息
print(add_function)

# 赋值语句可以实现变量和函数对象建立应用关系，
c= add_function
result1 = c(3,4)
print(result1)
```
程序运行结果：
`5`
`<function add_function at 0x000001E65BA4D2F0>`
`7`


### 3.1.3 函数的命名
- **变量名：** 全部小写，使用下划线连接各个单词
- **文件名：** 全部小写，可以使用下划线
- **函数名：** 小写，可以使用下划线
- **函数的参数：** 同变量，本质上就是变量






### 3.1.4 调用函数
**函数调用的时候参数赋值方法**
```python
'''
调用函数 p151
'''
def add(x,y):
    print("x = {}".format(x))
    print("y = {}".format(y))
    return x +y

#参数赋值方法一：
ans1 = add(2,3) #这里传递参数默认按照次序依次赋值
print("ans = ",ans1)

#参数赋值方法二：

ans2 = add(y = 4,x = 5) #直接使用变量= 变量值进行赋值，这就不用理会什么顺序
print(ans2)

```
程序运行结果：
`x = 2`
`y = 3`
`ans =  5`
`x = 5`
`y = 4`
`9`

**特殊：当函数在定义的时候，部分参数赋值**
```python
'''
当定义函数的时候进行部分参数赋值
'''

 #def acfun(x = 1,y,z = 4 ): 这种定义方法是错误的，因为有默认值的参数必须都在没有默认值参数后面
def acfun(x,y,z= 1):
    acans = x +y +z
    return acans

ans1 = acfun(1,2) #可以不给z赋值，则使用默认值
ans2 = acfun(2,3,2)#如果赋值，则使用这个值
print("ans1 = ",ans1)
print("ans2 = ",ans2)

```
程序运行结果：
`ans1 =  4`
`ans2 =  7`





## 3.2 深入探究函数


### 3.2.1 函数返回值

**示例程序：实现Fibonacci数列**
```python

'''

实现Fibonacci数列：P153
'''


# 此函数只有一个返回值（一个列表）

def fib(n):
    result = [0,1]  # 以列表形式返回
    for i in range(n-2):
        result.append(result[-2] + result[-1])
    return result

if __name__ == "__main__":
    haha = fib(10)
    print(haha)


# 但函数的返回值有多个时候，返回值类型为元组

def bilibili():
    return 1,2,3

##接受返回值的方法一；
ans = bilibili()
print("ans = " ,ans)

##接受函数返回值的方法二：
x,y,z = bilibili()
print(x,y,z)


# 如果函数没有return，则返回值为None
```

**return 作用**
- 返回函数的结果：
- 中断函数体内的流程，离开这个函数，即结束正在执行的这个函数，并离开函数体返回到调用位置
示例程序；
```python
'''
验证return的作用：p155
'''

def dilidili():
    print("hello")
    return
    print("world")

ans = dilidili()
print(ans)
```
程序运行结果：
`hello`
`None`
从输出结果可以看出，第二个print实际上并没有执行，遇到return就跳到调用的地方了



### 3.2.2  函数中的文档
```python
'''
函数文档注释；p156
'''

def eilieili():
    """
    this is a function,haha

    """
    print("lalala")
    
print(eilieili.__doc__)  # 参数含义：函数名.__doc__  
#打印函数功能注释：首先注释必须在函数内部
```



### 3.2.3 函数的属性
因为函数也是对象，所以函数也有属性

- 使用：`dir(函数名)` ，可以得到该函数所有的属性和方法，其中一双下划线开始的是特殊属性，都可以使用句点的方式调用
```python
"""

函数的属性：P156
"""

def filifili():
    print("hahha")

print(dir(filifili))
```

程序运行结果：
`['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']`


### 3.2.4 参数和变量
==函数参数传递的是对象的应用==
[函数参数与变量的关系](https://foofish.net/python-function-args.html)
```python

"""
参数与变量 ：p159
"""

def giligili(lst):
    lst.append(0)
    return lst

x = [1,2,3]
y = giligili(x)
print(y)

#这里实现的是原地修改
print(id(x))
print(id(y))
```
程序运行结果；
`[1, 2, 3, 0]`
`1887845442120`
`1887845442120`




### 3.2.5 参数收集

- 输入参数个数不确定
```python
"""
参数收集：p160
"""

def foo(x,*arg):
    print(arg)

foo(1,2,3,4,5,6,7)  #将第一个赋值给x之后，其余后面的所有的都以元组的形式赋值给*arg

foo(1,3)  # 当只有3赋值给*arg时候，结果相当于元组中只有一个元素，这时候结果应该是：（3，），元组中单个元素后面要加上逗号


def foobar(x,y,z,*arg,**args):
    print("x = ",x,"\n y = ",y,"\n z = ",z,"\n *arg = ",arg,"\n **args = ",args) 
    #注意这里打印输出只需要写arg,不需要写*

foobar(1,2,3,4,5,6,7,name = "gaojixu",age = 23)   #**args得到的值为字典类型，注意赋值方式
```
程序运行方式：

`(2, 3, 4, 5, 6, 7)`
`(3,)`
`x =  1 `
 `y =  2 `
 `z =  3 `
 `*arg =  (4, 5, 6, 7) `
 `**args =  {'name': 'gaojixu', 'age': 23}`



## 3.3 函数对象

### 3.3.1递归 ==谨慎使用==

[理解python函数入口](https://blog.csdn.net/gaojixu/article/details/84110883)
- 使用递归的方法实现Fibonacci数列
```python

"""
函数递归：使用递归的方法实现Fibonacci数列值 p163
"""

def fib(n):
    """
    This is a Fibonacci by Recursion

    """
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) +fib(n-2)


if __name__ == "__main__":
    f = fib(10)
    print(f)


```
程序运行结果：
`55`



### 3.3.2传递函数（函数做参数）
```python

"""
传递函数：函数做参数 P164
"""

def power_seq(func,seq):
    #因为pingfang也是一个函数名，可以这样理解：func = pingfang ,
    #后面一个参数seq 接受num_seq中的列表
    return [func(i) for i in seq]
    #因为func = pingfang ,所以func(i)，其实本质上为pingfang(i ),相当于在调用函数
"""
上面的语句等价为：
def power_seq(func,seq):
    ans = []   #新建一个空列表
    for i in seq:
        ans.append(func(i)) #列表中加元素使用追加
    return ans
"""

def pingfang(x):
    return x **2

if __name__ == "__main__":
    num_seq = [111,3.14,8,44]
    r = power_seq(pingfang,num_seq) #调用函数，传递参数
    print(num_seq)
    print(r)


```
程序运行结果：
`[111, 3.14, 8, 44]`
`[12321, 9.8596, 64, 1936]`


### 3.3.3 嵌套函数

```python
"""
嵌套函数：P164
"""

def foo():
    def bar():
        print("bar() is running")
    #bar()  可以在这里进行调用执行
    print("foo() is running ")

print(foo()) #调用执行foo()函数,注意这里并没有调用bar()函数，所以bar()函数不执行
#print(bar()) #在函数外部不能调用里面定义的函数，这能在函数内部调用
```
程序运行结果：
`foo() is running` 
`None`



**理解下面的嵌套程序：**
```python

"""
嵌套函数练习：P166
"""

def weight(g):       #第二步：接受值：g = 10
    def cal_mg(m): #第七步，***
        return m*g
    return cal_mg   #第三步：返回cal_mg

w = weight(10)       #第一步：传值，g= 10   #第四步：接受值，w = cal_mg
mg = w(10)           #第五步：w(10) 相当于：cal_mg(10),调用cal_mg函数
print(mg)
```
程序运行结果：`100`


### 3.3.4 初始装饰器
[查看原文点击这里:](https://foofish.net/python-decorator.html)

### 3.3.5 闭包
- 闭包是一个函数，特点如下；
  - 定义在另一个函数里面；
  - 引用其所在函数环境的自由变量；
  - 装饰器本质上是闭包的一种应用；
 下面程序中`bar()`函数就是一个闭包
```python
'''
闭包：p168
'''
def foo():
    a = 3
    def bar(): #本质上a和bar()互不统属，所以a 相对于bar()是自由变量，但是在bar()中却可以使用a变量；
        return a
    return bar

f = foo()
print(f())

```
程序运行结果： `a = 3`



## 3.4特殊函数

### 3.4.1 lambda函数
**使用方法：**
- 在lanbda后面直接跟变量；
- 变量后面是冒号；
- 冒号后面是表达式，表达式的计算结果就是本函数的返回值

==lambda函数不能包含命令，包含的表达式不能超过一个==
**示例：**
```python
'''
lambda的使用：p171
'''
lam = lambda x,y :x + y
buf = []
for i in range(10):
    buf.append(lam(i,i+1))

print(buf)
```
程序运行结果：
`[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]`


### 3.4.2 map函数
函数形式：`map(func,seq)` ,依次将序列对象seq中的每一个元素，按照从左到右的顺序，依次取出来放在func函数中；==func的返回值依次存在一个列表中==
```python
'''
map使用
'''
numbers1 = [1,2,3,4,5,6,7,8,9]
numbers2 = [1,2,3,4,5,6,7,8,9]
numbers3 = [1,2]

a =list(map(lambda x,y: x+y ,numbers1,numbers2))
b =list(map(lambda x,y: x+y ,numbers1,numbers3))
print(a)
print(b)

```
程序运行结果：
`[2, 4, 6, 8, 10, 12, 14, 16, 18]`
`[2, 4]`

**说明：**
- map相当于对可迭代对象中的每个元素依次使用function方法，就相当于for循环
- 将所有的结果返回一个map对象，这个对象是迭代器；
- 如果参数很多，则参数是并行执行function函数，运行速度相应的就提升了；


### 3.4.3 reduce函数
```python
'''
reduce p173
'''
from functools import reduce
a = reduce(lambda x,y:x+y,[1,2,3,4,5])
print(a)

```
程序运行结果：`15`
**map()函数是上下运算，而reduce()函数是横着逐个元素进行运算**


### 3.4.4 filter函数
```python
""" 
 filter练习 p174 
filter(function, iterable)# 判别函数  可迭代函数 
filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象， 如果要转换为列表，可以使用 list() 来转换。   
该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判， 然后返回 True 或 False，最后将返回 True 的元素放到新列表中 
""" 
nums = range(-5,5)
print(list(filter(lambda x: x>0,nums)))
#以上相当于：
[x for x in nums if x>0]
```
程序运行结果：`[1, 2, 3, 4]`



### 3.4.5 zip()函数
- 是内建函数，但是参数是可迭代对象，返回值为zip对象，可以使用list()进行查看内容
具体事例见：p175，这里没有认真看







## 3.5 命名空间

### 3.5.1全局变量和局部变量
```python
'''
3.5.1全局变量和局部变量;p176
'''
x = 10
def funs():
    global x  # 作用：将x声明称为全局变量，这样in的输出值也为22，同时out输出值为22
    x = 22
    print("in : ",x)

funs()
print("out : ",x)
```
程序运行结果：
`in :  22`
`out :  22`


### 3.5.2 作用域
- python属于动态语言，但是作用域属于静态作用域：python中变量的作用域是由它在程序中的位置决定
- 作用域分类：
  - local：局部作用域或称本地作用域
  - Enclosing:嵌套作用域
  - Global:全局作用域
  - Built-in:内建作用域



### 3.5.3 命名空间
- 定义：命名空间表示标识符的可见范围，同一个标识符可以在多个命名空间中定义，但是不同命名空间中的定义是互不相干的。
- 命名空间是对作用域的特殊抽象，包含了处于该作用域内的标识符，且本身也为一种标识符。
- 分类：
  - 本地命名空间：每个模块中的类和函数，他们定义的命名空间即为本地命名空间，当函数返回结果或者抛出异常则本地命名空间结束。
  - 全局命名空间：每个模块创建的自己的命名空间，各个模块间命名空间相互独立
  - 内置命名空间：python运行起来就存在了，内置函数的命名空间均属于内置命名空间 

- 访问本地命名空间：locals()
- 访问全局命名空间：globals()




## 第三章示例代码
```python
#!/usr/bin/env python
# -*- coding:utf-8 -*-
#@Time :2018/11/15 14:49
#Author:GJXAIOU


'''
定义函数   P147
'''


# def add_function(a,b):  #定义一个函数使用 ：  def   函数名（参数）:    其中：表示函数头的结束
#     # 函数名的命名；小写字母或者单下划线或者数字
#     #这里x,y作为形参，也可以认为是变量，而变量无类型，所以并没有规定其所引用的对象的类型，意义取决于对象的类型，称为多态
#     c = a + b   # 函数体必须缩进4个空格
#     return c  #return语句执行的时候，python会跳出当前的函数并且返回到调用这个函数的地方
#
#
# if __name__ == "__main__":
#     result = add_function(2,3)  #调用函数并且将实参传递给函数
#     print(result)
#
#
# # 下面为函数的其他使用方法
#
# # 只写函数名会得到该函数在内存中的存储信息
# print(add_function)
#
# # 赋值语句可以实现变量和函数对象建立应用关系，
# c= add_function
# result1 = c(3,4)
# print(result1)





 # '''
 # 调用函数 P151
 # '''
# def add(x,y):
#     print("x = {}".format(x))
#     print("y = {}".format(y))
#     return x +y
#
# #参数赋值方法一：
# ans1 = add(2,3) #这里传递参数默认按照次序依次赋值
# print("ans = ",ans1)
#
# #参数赋值方法二：
#
# ans2 = add(y = 4,x = 5) #直接使用变量= 变量值进行赋值，这就不用理会什么顺序
# print(ans2)

#
# '''
# 当定义函数的时候进行部分参数赋值 P151
# '''
#
#  #def acfun(x = 1,y,z = 4 ): 这种定义方法是错误的，因为有默认值的参数必须都在没有默认值参数后面
# def acfun(x,y,z= 1):
#     acans = x +y +z
#     return acans
#
# ans1 = acfun(1,2) #可以不给z赋值，则使用默认值
# ans2 = acfun(2,3,2)#如果赋值，则使用这个值
# print("ans1 = ",ans1)
# print("ans2 = ",ans2)
#
#





# '''
#
# 实现Fibonacci数列：P153
# '''
#
#
# # 此函数只有一个返回值（一个列表）
#
# def fib(n):
#     result = [0,1]  # 以列表形式返回
#     for i in range(n-2):
#         result.append(result[-2] + result[-1])
#     return result
#
# if __name__ == "__main__":
#     haha = fib(10)
#     print(haha)
#
#
# # 但函数的返回值有多个时候，返回值类型为元组
#
# def bilibili():
#     return 1,2,3
#
# ##接受返回值的方法一；
# ans = bilibili()
# print("ans = " ,ans)
#
# ##接受函数返回值的方法二：
# x,y,z = bilibili()
# print(x,y,z)
#
#
# # 如果函数没有return，则返回值为None





#
# '''
#   验证return的作用：p155
#   '''
# def dilidili():
#
#     print("hello")
#     return
#     print("world")
#
# ans = dilidili()
# print(ans)
#

#
# '''
# 函数文档注释；p156
# '''
#
# def eilieili():
#     """
#     this is a function,haha
#
#     """
#     print("lalala")
#
# print(eilieili.__doc__)  # 参数含义：函数名.__doc__
# #打印函数功能注释：首先注释必须在函数内部
#
#


#
# """
#
# 函数的属性：P156
# """
#
# def filifili():
#     print("hahha")
#
# print(dir(filifili))
#
#

#
# """
# 参数与变量 ：p159
# """
#
# def giligili(lst):
#     lst.append(0)
#     return lst
#
# x = [1,2,3]
# y = giligili(x)
# print(y)
#
# #这里实现的是原地修改
# print(id(x))
# print(id(y))




#
# """
# 参数收集：p160
# """
#
# def foo(x,*arg):
#     print(arg)
#
# foo(1,2,3,4,5,6,7)  #将第一个赋值给x之后，其余后面的所有的都以元组的形式赋值给*arg
#
# foo(1,3)  # 当只有3赋值给*arg时候，结果相当于元组中只有一个元素，这时候结果应该是：（3，），元组中单个元素后面要加上逗号
#
#
# def foobar(x,y,z,*arg,**args):
#     print("x = ",x,"\n y = ",y,"\n z = ",z,"\n *arg = ",arg,"\n **args = ",args)
#
# foobar(1,2,3,4,5,6,7,name = "gaojixu",age = 23)   #**args得到的值为字典类型，注意赋值方式


#
# """
# 函数递归：使用递归的方法实现Fibonacci数列值P163
# """
#
# def fib(n):
#     """
#     This is a Fibonacci by Recursion
#
#     """
#     if n == 0:
#         return 0
#     elif n == 1:
#         return 1
#     else:
#         return fib(n-1) +fib(n-2)
#
#
# if __name__ == "__main__":
#     f = fib(10)
#     print(f)
#
#



# """
# 传递函数：函数做参数 P164
# """
#
# def power_seq(func,seq):
#     #因为pingfang也是一个函数名，可以这样理解：func = pingfang ,
#     #后面一个参数seq 接受num_seq中的列表
#     return [func(i) for i in seq]
#     #因为func = pingfang ,所以func(i)，其实本质上为pingfang(i ),相当于在调用函数
# """
# 上面的语句等价为：
# def power_seq(func,seq):
#     ans = []
#     for i in seq:
#         ans.append(func(i))
#     return ans
# """
#
# def pingfang(x):
#     return x **2
#
# if __name__ == "__main__":
#     num_seq = [111,3.14,8,44]
#     r = power_seq(pingfang,num_seq) #调用函数，传递参数
#     print(num_seq)
#     print(r)
#





# """
# 嵌套函数：P164
# """
#
# def foo():
#     def bar():
#         print("bar() is running")
#     #bar()  可以在这里进行调用执行
#     print("foo() is running ")
#
# print(foo()) #调用执行foo()函数,注意这里并没有调用bar()函数，所以bar()函数不执行
# #print(bar()) #在函数外部不能调用里面定义的函数，这能在函数内部调用






# """
# 嵌套函数练习：P166
# """
#
# def weight(g):       #第二步：接受值：g = 10
#     def cal_mg(m): #第七步，***
#         return m*g
#     return cal_mg   #第三步：返回cal_mg
#
# w = weight(10)       #第一步：传值，g= 10   #第四步：接受值，w = cal_mg
# mg = w(10)           #第五步：w(10) 相当于：cal_mg(10),调用cal_mg函数
# print(mg)



"""
# filter练习 p174
filter(function, iterable)# 判别函数  可迭代函数
filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，
如果要转换为列表，可以使用 list() 来转换。

该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，
然后返回 True 或 False，最后将返回 True 的元素放到新列表中
"""
nums = range(-5,5)
print(list(filter(lambda x: x>0,nums)))
#以上相当于：
[x for x in nums if x>0]



'''
3.5 命名空间：p 176
'''


'''
3.5.1全局变量和局部变量;p176
'''
x = 10
def funs():
    global x  # 作用：将x声明称为全局变量，这样in的输出值也为22，同时out输出值为22
    x = 22
    print("in : ",x)

funs()
print("out : ",x)

```













-------------------------------------------------













---
date:2019-1-22
---


# 第4章 类

==python中一切皆对象，包括字符串、函数、模块、类、、、、==

## 4.1基本概念
- 对象:包括状态、行为、和唯一的标识
- 状态：包括类已有的属性（类中已经定义好的），和对象具有的当前属性值（一般为动态的）
- 行为：表现为对象自身状态的改变和信息的传递
- 标识：该对象区别于其他对象的属性，本质上为内存中所创建的对象的地址
对象：应该具有：属性（状态：是什么）和方法（行为：能做什么），标识一般在内存中自动完成。


## 4.2编写类

### 4.2.1创建类

- python3中所有的类均为object类的子类
- 类的名称开头首字母大写
```python
"""
4.2.1创建类
"""

class Person:  #如果继承其他类：格式为：class Person（FatherClass）
    def __init__(self,name):   # 这是构造函数（初始化函数），在使用类创建实例的时候，首先执行构造函数  #类中参数第一个参数必须为self,
        self.name = name       #建立实例的一种属性，属性的名字为name，值为参数name 传递的值

    def get_name(self):
        return self.name

    def color(self, color):
        d = {}
        d[self.name] = color
        return d


if __name__ =="__main__":  #注意这里是两个_
    girl = Person("zhangsan")  #利用上面的类创建实例，因为类中有name 参数，需要进行传值，所以在创建实例的时候有值（传的是引用），self不需要传值
    print(girl.name)
    name = girl.get_name()# 调用类的方法
    print(name)
    her_color = girl.color("white")
    print(her_color)
```
注：girl就是一个实例（girl这个变量引用了Person（‘zhangsan’）实例对象），它有属性和方法
self本质上就是实例对象本身

## 4.3 属性和数据

### 4.3.1 类属性
```python
'''
4.3 类属性
'''
class A:
    x = 5
    z = 8  # 可以直接在类中添加属性
print(A.x)
A.y = 9   # 也可以在类的外部添加属性
print(dir(A)) #查看类的属性，里面包含x，y，z

del A.x  #这样可以删除类A中的X属性
```
- x为类中的一个变量也为属性
- 几类特殊的属性的含义：
  - A.__name__  :以字符串的形式返回类的名字
  - A.__doc__: 显示类的文档
  - A.__base__:类A的所有父类，默认没有其他继承就是显示object类
  - A.__dict__:以字典的形式显示类的所有属性
  - A.__module__:类所在的模块
    - 例如：Person.__module__ 显示结果为__main__,即类Person的全称为：__main__.Person



### 4.3.1 创建实例
```python
class Person: 
   def __init__(self,name): #初始化函数第一个参数必须是self，其次不能含有return 语句，
       self.name = name
if __name__ =="__main__": 
    zhangsan = Person() #创建一个实例zhangsan,本质是将变量zhangsan与实例对象Person（）建立引用关系
```

### 4.3.2 实例属性
```python
class A:
    x = 7
    #x = 8  对类属性值的修改会影响实例的属性值
    y = [1,2,3] #可变对象
foo = A()
print(foo.x)
foo.x = 8  #类中的属性尽量避免更改，但是实例中的属性可以随意更改
#这里更改的本质的建立了一个新的属性，和之前的同名，访问时候覆盖掉了原来的属性，可以使用del foo.x可以得到原来的属性值
print(foo.x)
print(A.x)#类中属性的值不会因为实例属性值更改而改变,当且仅当类中变量引用的是不可变对象：例如字符串
#当类中变量引用的是可变对象的时候，实例改变会影响类中属性的值，因为是原地修改
foo.y.append(4) #修改实例的值
print(A.y)#运行结果：类的值也改变了

foo.z = [1,2,3,4,5]
#print(A.z)   通过实例增加的变量并不能在类中使用
```

## 4.4 方法

### 4.4.1 绑定方法和非绑定方法
- 绑定方法：使用实例调用的方法
- 非绑定方法：使用类的名字调用的方法
```python
'''
4.4.1 绑定与非绑定方法
'''

class Foo:
    def bar(self):
        print("this is a normal method of class")

#实例化与引用
f = Foo()
f.bar()#当建立这个实例的时候，引用方法时候，python解释器会把实例作为第一个参数隐式的传递给该方法

#实例显式传递方法
Foo.bar(f)#实例化之后，self和实例f是相同的，一般在类里使用self,在类外部使用f这个实例。

# 因为python一切皆对象，类Foo的方法bar()也是对象（函数对象）
Foo.bar #该方法为非绑定方法
f.bar   # 绑定方法
```

**描述器**
- 含有：`__get__()`、`__set__()`、`__delete__()`这些方法的对象称为描述器
- 描述器是属性、实例方法、静态方法、类方法和继承中使用的super的背后实现机制
- p198见详述


### 4.4.2 类方法和静态方法
- **classmethod**
```python
'''
4.4.2 类方法和静态方法
'''

#!/usr/bin/env python
#coding:utf-8

class Foo:
    lang = "Java" # 类属性
    def __init__(self):
        self.lang = "python"#方法属性

    @classmethod #装饰器，修饰的方法中的参数第一个不使用self，一般使用cls
    # 使用类和实例执行get_class_attr,得到的都是类属性值，装饰器修饰的方法，参数所引用的对象是类对象Foo。
    def get_class_attr(cls):#这里参数为cls，要求所引用的对象应该具有属性lang。
        return cls.lang


if __name__ == "__main__":
    print("Foo.lang:",Foo.lang)
    r = Foo.get_class_attr()
    print("get class attribute:",r)
    f = Foo()
    print("instance attribute:",f.lang)
    print("instance get_class_attr",f.get_class_attr())
```
**类方法：** 就是类里面定义的方法，该方法由装饰器@classmethod 所装饰，第一个参数cls所引用的是这个类对象，即将类对象作为引用对象传入到该方法中。


- **staticmethod**
```python

'''
4.4.2 类方法和静态方法
'''

#!/usr/bin/env python
#coding:utf-8
import random
class Foo:
    def __init__(self,name):
        self.name = name

    def get_name(self,age):
        if self.select(age):
            return self.name
        else:
            return  "the name is secret"

    @staticmethod #是该方法位于类内但是独立于类，这个方法称为：静态方法
    def select(n):#虽然在类内但是是独立的方法，跟类没有关系，就是类的作用域内的普通函数
        a = random.randint(1,100)
        return a - n > 0
    #该函数不以self开头
    #可以通过实例调用，比如self.select(n);
    #可以通过类调用这个方法，比如 Foo.select(n)
if __name__ == "__main__":
    f = Foo("zhangsan")
    name = f.get_name(22)
    print(name)
```



## 4.5 继承
继承使子类具有父类的方法和属性
继承最主要的用途是实现多态

### 4.5.2 单继承
```python
### 4.5.1 单继承

#!/usr/bin/env python
#coding:utf-8
import random
class Person:
    def __init__(self,name): #建立实例的时候这个初始化函数就要执行
        self.name = name
        print("This is father")

    def height(self,m):
        h = dict((["height",m],))
        return h

class Boy(Person): #继承Person 
    def __init__(self, name): #当子类和父类中的函数重名就会函数重写，以子类中的为准  # 如果子类中没有初始化函数，在实例化的时候就会继承父类中的初始化函数并且执行；
        self.name = name
        print("This is son")
    ```直接让子类包含父类的所有属性```
    #super().__init__(self,name)

    def get_name(self):
        return self.name

if __name__ == "__main__":
    boy = Boy("zhangsan")
    print(boy.get_name())
    print(boy.height(180))
    print(Boy.__bases__) #得到Boy这个子类的所有父类

```

程序运行结果：
`This is son`
`zhangsan`
`{'height': 180}`
`(<class '__main__.Person'>,)`

### 4.5.3 调用覆盖的方法

- 如果子类重写了父类的方法，现在子类中调用父类的方法
```python
# 4.5.3 调用覆盖的方法 # 使父类中被覆盖的方法再次在子类中实现

#!/usr/bin/env python
#coding:utf-8
import random
class Person:
    def __init__(self,name):
        self.name = name
        print("This is father")

    def height(self,m):
        h = dict((["height",m],))
        return h
    #返回一个字典
    def hello(self, a, b)
        C = {"A":a, "B":b}
        return C

class Boy(Person):
    def __init__(self, name):
        # Person.__init__(self, name) #方案一：但是一旦父类名称修改，这这里也要修改
        super(boy, self).__init__(name)  #方案二：使用super    详细使用方法：https://www.cnblogs.com/silencestorm/p/8404046.html
        self.real_name = "lisi"
        print("This is son")

    def get_name(self):
        return self.name

if __name__ == "__main__":
    boy = Boy("zhangsan")
    print(boy.real_name )
    print(boy.get_name())
    print(boy.height(180))
    print(Boy.__bases__) #得到Boy这个子类的所有父类
```
程序运行结果：
`This is father`
`This is son`
`lisi`
`zhangsan`
`{'height': 180}`
`(<class '__main__.Person'>,)`

- 多继承的继承顺序
```python
## 多重继承的继承顺序
# 广度优先

#!usr/bin/env python
# coding=utf-8

class A:
    def Ha(self):
        print("This is A ha")

class B:
    def Ha(self):
        print("This is B ha")
    def La(self):
        print("This is B la")

class AB1(A, B):
    pass
class AB2(A, B):
    def La(self):
        print("This is AB2 la")

class AB(AB1, AB2):
    pass

if __name__ == "__main__":
    print(AB.__mro__) # __mro__ 可以打印出类的继承顺序
    ab = AB()
    ab.Ha()
    ab.La()
```
程序运行结果：
`(<class '__main__.AB'>, <class '__main__.AB1'>, <class '__main__.AB2'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)`
`This is A ha`
`This is AB2 la`








## 4.6 多态与封装

### 4.6.1 多态
```python
### 4.6.1 多态：同一方法传入不同参数结果不同 /对象多种表现形式的体现

# count :数一数某个元素在对象中出现的次数
print("This is a book".count("s" ))
print([1,2,3,4,2,3,2].count(2))

f = lambda x,y: x+y
print(f(2,3))
print(f("hello","world"))
print(f(["a","b"],["c","d"]))

# python 不检查传入对象的类型，这种方式称为：“隐式类型”、“结构式类型”、"鸭子类型”
# 鸭子类型：动态类型的一种风格，该风格中一个对象有效的语义，不是由继承自特定的类或者特定的接口决定的，而是有当前方法和属性的集合决定
```
程序运行结果：
`2`
`3`
`5`
`helloworld`
`['a', 'b', 'c', 'd']`



### 4.6.2 封装和私有化
- 私有化：将类或者函数中的方法或者属性限定在某个区域之内，外部无法调用 
- 私有化方法：在需要私有的数据或者方法属性前面加上__
```python
### 4.6.2 封装和私有化

#!usr/bin/env python
# coding=utf-8

class ProtectMe:
    def __init__(self):
        self.me = "zhangsan"
        self.__name = "lisi"
    def __Python(self):
        print("I Love Python")
    def code(self):
        print("Which Language do you like")
        self.__Python()

if __name__ == "__main__":
    protect = ProtectMe()
    print(protect.me) #这里可以 使用
    protect.code() #因为code()方法和__Python（）均在同一个类中，因此可以调用
    print(protect.__name) # 私有属性类外不能调用
    protect.__python()
```
程序运行结果：
`zhangsan`
`Which Language do you like`
`I Love Python`
`Traceback (most recent call last):File "E:/Program/Python/Study/my/program/daydayup/Code_of_laoqi_python/char4.py", line 343, in <module>`
    `print(protect.__name) # 私有属性类外不能调用`
`AttributeError: 'ProtectMe' object has no attribute '__name'`

- 使用装饰器调用私有化的属性与方法
```python
# 使用装饰器调用类的私有属性

#!usr/bin/env python
# coding=utf-8

class ProtectMe:
    def __init__(self):
        self.me = "zhangsan"
        self.__name = "lisi"

    @property        # 装饰器：主要用于为已存在的对象添加功能
    def code(self):
        return self.__name

if __name__ == "__main__":
    protect = ProtectMe()
    print(protect.code)
```
程序运行结果为：
`lisi`







## 4.7 定制类

 类是对象，也是对象类型
### 4.7.1 类和对象类型
```python
## 4.7 定制类（定制对象类型）

class A:pass
class B:pass
a = A()
b = B()
print(type(a)) #返回对象a的对象类型，使用type()可以得到实例或者变量所引用对象的类型
print(type(b))
print(isinstance(a, A))  #也可以使用isinstance判断一个对象是不是另一个给定类的实例
m = 1
print(isinstance(m, int)) #得出：m所引用的对象是整数型
```
程序运行结果：
`<class '__main__.A'>`
`<class '__main__.B'>`
`True`
`True`

### 4.7.1 自定义对象类型
```python
##示例一：得到仅保留小数点后两位小数的数
#!usr/bin/env python
# coding=utf-8

class RoundFloat:
    #定义一种两位小数的浮点数类型，利用该类可以得到两位小数的浮点数
    def __init__(self, val):
        assert isinstance(val, float), "value must be a float"  #assert的作用相当于布尔运算，当运行到这里，进行对象值的判断，如果为false，则抛出后面的异常提示
        self.value = round(val, 2)

    def __str__(self): #为能够得到打印的内容
        return "{:.2f}".format(self.value) #将前面四舍五入保留两位小数的浮点数，以小数点后有两位小数的形式输出

    __repr__ = __str__#在类被调用即向变量提供__str__()里的内容

if __name__ =="__main__":
    r = RoundFloat(2.185)
    print(r)
    print(type(r))
```
程序运行结果：
`2.19`
`<class '__main__.RoundFloat'>`


- 示例二：输入分子分母得到分数
```python
#!usr/bin/env python
# coding = utf-8

class Fraction:
    def __init__(self, number, denom = 1):
        self.number = number
        self.denom = denom

    def __str__(self):
        return str(self.number) + '/' +str(self.denom)

    __repr__ = __str__

if __name__ == "__main__":
    f = Fraction(2, 3)
    print(f)

```
程序运行结果：`2/3`

- 示例三： 实现分数计算 1/2 + 1/3 = 5/6
```python

#收下按照最小公倍数通分，然后分子相加
#最小公倍数lcm(a, b) = 丨a*b丨 /gcd(a,b)   注：丨因为注释所以有点斜 ，gcd(a,b)表示两个数的最大公约数

 #！usr/bin/env python
 # coding = utf-8

def gcd(a, b):
     #求最大公约数
    if not a > b:
        a, b = b, a
    while b != 0:
        remainder = a % b
        a, b = b, remainder
    return  a

def lcm(a, b):
     #求最小公倍数
    return (a * b) / gcd(a, b)

class Fraction:
    def __init__(self, number, denom = 1):
        self.number = number
        self.denom = denom

    def __str__(self):
        return str(self.number) + '/' +str(self.denom)

    __repr__ = __str__

    def __add__(self, other): #这个类中规定了加减乘除等运算等特殊方法
        lcm_num = lcm(self.denom, other.denom)
        number_sum = (lcm_num / self.denom * self.number) + (lcm_num / other.denom * other.number)
        return Fraction(number_sum, lcm_num)


if __name__ == "__main__":
    m = Fraction(1, 3)
    n = Fraction(1, 2)
    s = m + n
    print(m,"+",n ," = ",s)
```
程序运行结果：
`1/3 + 1/2  =  5.0/6.0`

- 在python中实现某种运算所使用的运算符本质上是以特殊方法实现的，其对应关系为:P218
  - 例如加法对应的特殊方法为：`__add__`或者`__radd__`,两个对象能否相加，取决于两对象是否含有`__add__`方法





## 4.8 一些特殊点

### 4.8.1 优化内存
```python
class Spring:
    time = "From march to June"

print(Spring.__dict__) #每个类都有一个__dict__属性，包含了当前类的属性值

year = Spring()  #建立一个实例
print(year.__dict__)   # 实例也有这个属性，只是刚建立的时候为空

#为了控制__dict__属性，使用__slots__属性替代__dict__属性

class Summer:
    __slots__ = ("tree","flower")

print(dir(Summer))  # 结果没有__dict__属性

print(Summer.__slots__)  #此时Summer仅有两个属性
s1 = Summer()
s2 = Summer()
print(s1.__slots__) # 实例也仅有两个属性
print(s2.__slots__)
print(id(s1.__slots__) == id(s2.__slots__)) #两个实例的__slots__在内存中占同一个位置


# 使用__slots__优化了内存，同时实例不能增加属性，只能通过类属性进行增加
```
程序运行结果：
`{'__module__': '__main__', 'time': 'From march to June', '__dict__': <attribute '__dict__' of 'Spring' objects>, '__weakref__': <attribute '__weakref__' of 'Spring' objects>, '__doc__': None}`
`{}`
`['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__slots__', '__str__', '__subclasshook__', 'flower', 'tree']`
`('tree', 'flower')`
`('tree', 'flower')`
`('tree', 'flower')`
`True`



### 4.8.2 属性拦截 

- 当访问类或者实例的属性时候，若不存在，就会调用某一类方法

|方法|使用方式|
| ---- | ---- |
|`__setattr__(self,name,value)`|如果要给name赋值，则调用|
|`__getattr__(self,name)`| 如果name被访问，但同时它不存在，则调用|
|`__getattribute__(self,name)`|无论name是否存在，只要name被访问时候就会自动被调用|
|`__delattr__(self,name)`| 如果要删除name,则调用|

```python
class A:
    def __getattr__(self, name):
        print("You use getatter")

    def __setattr__(self, name, value):
        print("You use setattr")
        self.__dict__[name] = value  # 将数据和属性保存到对象的__dict__中


a = A()   # 实例化
a.x  #实例不存在这个属性，但是因为有__getattr__方法，当属性X不在对象的__dict__ 中时候，就调用__getattr__ 方法
a.one = 7  # 给对象的属性赋值，调用__setattr__
print(a.one)  # 已经将属性保存到对象的__dict__ 中


class B:
    def __getattribute__(self, name):
        print("You use getattribute")
        return object.__getattribute__(self, name) #这里不能使用self.__dict__[name] = value ，因为这样就得访问属性self.__dict__,相当于死循环

b = B()
b.y  #虽然不存在，但是仍然执行 __getattribute__方法
b.two = 7
print(b.two) #赋值之后就会被加入__dict__中
```
程序运行结果：
`You use getatter`
`You use setattr`
`7`
`You use getattribute`
`Traceback (most recent call last):`
 `File "E:/Program/Python/Study/my/program/daydayup/Code_of_laoqi_python/char4.py", line 521, in <module>`
  `b.y  #虽然不存在，但是仍然执行 __getattribute__方法`
  `File "E:/Program/Python/Study/my/program/daydayup/Code_of_laoqi_python/char4.py", line 518, in __getattribute__ `
  `return object.__getattribute__(self, name) #这里不能使用self.__dict__[name] = value` ，
 `因为这样就得访问属性self.__dict__,相当于死循环,AttributeError: 'B' object has no attribute 'y'`


   
















---------------------------------------------







# 第5章 错误与异常

## 5.1 错误
 - 语法错误：Syntax Error
 - 当python检测到错误则无法执行，从而抛出提示信息，即为异常

## 5.2 异常

- 常见异常以及描述

|异常|描述|
|---|---|
|NameError   |尝试访问一个没有声明的变量（虽然不需要声明，但是变量必须先赋值才能使用）|
|ZeroDivisionError|除数为0|
|SyntaxError|语法错误|
|IndexError|索引超出序列范围；例如：a = [1, 2, 3]   a[4]|
|KeyError|请求一个不存在的字典关键字|
|IOError|输入/输出错误（例如文件不存在,或者文件路径不正确）|
|AttributeError|尝试访问未知的对象类型|   

## 5.3 处理异常


### 5.3.1 使用try....except...

```python
while 1:
    print("This is a program")
    c = input("input 'c' continue,otherwise logout:")
    if c == "c":
        a = input("first number:")
        b = input("second number:")
        try:
            print(float(a)/float(b))
            print("*************")
        except ZeroDivisionError: #当try中没有异常则此部分不执行，如果try子句中有异常，则执行except后面指定的异常类型及其子句
            # 如果except后面没有任何异常类型，则无论try发生什么异常均执行except
            print("the second number can not be zero")
            print("*************")
        except ValueError: # 可以通过怎么except，可以处理多个异常
            print("please input number.")
            print("*************")

        #以上两个except可以合成一个
        except (ZeroDivisionError, ValueError):
            print("please input rightly")
            print("**************")

        # 使用系统默认的异常提示，打印出来但是程序不中断
        except (ZeroDivisionError, ValueError) as e:
            print(e)
            print("**************")
        else:# 如果执行了try ，则except不执行，但是执行else
            print("hello")
        finally: # 不管前面执行try 还是except，都要执行finally
            del e
    else:
        break

```
此程序需在终端中执行


### 5.3.2 assert使用

```python
# assert 用于判定断言，等价于布尔运算
#默认值为真，当发生异常则值为假

class Accout(object):
    def __init__(self,number):
        self.number = number
        self.balance = 0

    def deposit(self, amount):
        try:
            assert amount > 0
            self.balance += amount
        except:
            print("The money should bigger than zero")

    def withdraw(self, amount):
        assert amount > 0
        if amount <= self.balance:
            self.balance -= amount
        else:
            print("balance is not enough")

if __name__ == "__main__":
    a = Accout(1000)
    a.deposit(-10)
```
程序运行结果：
`The money should bigger than zero`

- assert通常使用情况
  - 防御性的编程
  - 运行时对程序逻辑的检测
  - 合约性检查（例如前置条件、后置条件）
  - 程序中的常量
  - 检查文档







-----











# 第六章 模块


- 模块是程序，拓展名：.py

## 6.1 编写模块

### 6.1.1 模块是程序

1.编写一个python程序，例如：char6.py
```python
#!usr/bin/env python
# coding = utf-8

lang = "python"

```
2.将该程序的位置告诉python编译器
```python
import sys
sys.path.append("E:/Program/Python/Study/my/program/daydayup/Code_of_laoqi_python/char6.py")  # 不同系统文件目录形式不同
```
3.在其他程序中使用：
```python
import char6  # 作为模块引入的时候不带文件拓展名
char6.lang    #  采用模块名.属性或类、方法名称
```
程序运行结果：
`"python"`

注：此时在存储char6.py目录下多一个：`__pycache__`目录，目录中的`char6.cpython-37.pyc`即为刚才`char6.py`文件编译后的文件

- 如何区分是作为程序执行还是作为模块引入
1.新建：pm.py
```python
#!usr/bin/env python
#coding = utf-8

def lang():
  return "python"

if __name__ == "__main__"
print(lang())
```
如果作为程序执行：`__name__ == “__main__”`
如果作为模块引入：`pm.__name__ == “pm”` 属性`__name__`值为模块名称
一般如果仅仅用于模块引入，则不必写：`if __name__ == "__main__"`


### 6.1.2 模块的位置

查看所有模块的位置
```python
import sys
import pprint
pprint.pprint(sys.path)
```
程序运行结果：
`['E:\\Program\\Python\\Study\\my\\program\\daydayup\\Code_of_laoqi_python',`
 `'E:\\Program\\Python\\Study\\my\\program\\daydayup',`
 `'E:\\Program\\Python\\Python3.7.1\\python37.zip',`
 `'E:\\Program\\Python\\Python3.7.1\\DLLs',`
 `'E:\\Program\\Python\\Python3.7.1\\lib',`
 `'E:\\Program\\Python\\Python3.7.1',`
 `'E:\\Program\\Python\\Python3.7.1\\lib\\site-packages',`
 `'E:\\Program\\Python\\PycharmPro\\PyCharm '`
 `'2018.2.4\\helpers\\pycharm_matplotlib_backend']`


### 6.1.3 `__all__`在模块中的作用

- 一般情况下：不加`__all__`模块
1.新建文件mokuai_pp.py
```python
#!usr/bin/env python
#coding = utf-8

public_var = "public var"
_private_var = "private var" #以单下划线开头的表示私有变量
def public_class():
    print("This is a public class")
    
def _private_class():
    print("This is a private class")
    
```

2.在char6.py中引用该模块：
```python
import sys
sys.path.append("E:\Program\Python\Study\my\program\daydayup\mokuai_pp.py")
import mokuai_pp
from mokuai_pp import  *   #含义：希望能够访问模块mokuai_pp中有权限访问的全部名称，私有的变量、函数、类没有访问权限
print(public_var)
print(_private_var)  # 报错，私有变量不能访问
```
程序运行结果：
`public var`
`Traceback (most recent call last):`
 `File"E:/Program/Python/Study/my/program/daydayup/Code_of_laoqi_python/char6.py", line 33, in <module>`
    `print(_private_var)`
`NameError: name '_private_var' is not defined`

- 外部可以访问模块的私有属性
```python
import sys
sys.path.append("E:\Program\Python\Study\my\program\daydayup\mokuai_pp.py")
import mokuai_pp
from mokuai_pp import  *  #此时该句可加可不加 
print(mokuai_pp.public_var)
print(mokuai_pp._private_var)
```
程序运行结果：
`public var`
`private var`


- 模块中加入`__all__`之后

模块mokuai_pp.py改为：
```python
# !usr/bin/env python
# coding = utf-8

__all__ = ['_private_var','public_class'] #表示：只有列表中这两个变量和方法可以被访问，其它一律不能访问
public_var = "public var"
_private_var = "private var"

def public_class():
    print("This is a public class")

def _private_class():
    print("This is a private class")

```

char6.py改为：
```python
import sys
sys.path.append("E:\Program\Python\Study\my\program\daydayup\mokuai_pp.py")
import mokuai_pp
from mokuai_pp import *
print(_private_var)  #原来不能访问的可以访问了
print(public_var)    #原来可以访问的不能访问了 
```
程序运行结果：
`private var`
  `File "E:/Program/Python/Study/my/program/daydayup/Code_of_laoqi_python/char6.py", line 33, in <module>`
   `print(public_var)`
`NameError: name 'public_var' is not defined`



### 6.1.4 包与库
- 库找那个含有很多的包，每个包中含有若干的模块
- 包相当于一个目录，要想引用包中某个模块，则需要在目录中放入：名为`__init__.py`的空文件，则该目录中其他.py文件就可以作为模块引用

- 示例：
  - 目录：`Code_of_laoqi_python`,里面含有`mokuai__pp.py`以及`mokuai_qq.py`,并建立一个空文件：`__init__.py`

  - 引用方式：
    - 方法一：
```python
import Code_of_laoqi_python.mokuai_pp
print(Code_of_laoqi_python.mokuai_pp._private_var)
```
    - 方法二：
```python
from Code_of_laoqi_python import mokuai_pp
print(mokuai_pp._private_var)
```
程序运行结果为：
`private var`


## 6.2 标准库概述

### 6.2.1 引用方式
三种，如上
```python
import pprint  # 导包
a = {"lang":"jksdjf"}
pprint.pprint() # 使用模块中的一种方法
```

```python
from pprint import pprint   # 仅引入pprint模块中的pprint()
a = {"lang":"jksdjf"}
pprint(a)    # 这里可以直接使用
```

```python
from pprint import * # 将模块中所有可用的全部引入
```

- 注：将引入的模块改名字
```python
import pprint as pr
pr.pprint(a)

#或者如下：
from pprint import pprint as pr
pr(a)
```


### 6.2.3 帮助、文档与源码

- 创建文档
1.例如新建pm.py
```python
#!usr/bin/env python
#coding = utf-8

"""
This is a document of python   #帮助文档（在所有类、方法以及import之前）     
"""

def lang():
  pass
```
2.将该模块路径加入：
```python
import sys
sys.path.append(".....路径")
import pm
print(pm.__doc__)  #打印出模块的文档
```

- 查看模块的存储位置
```python
print(pprint.__file__)
```



## 6.3 标准库举例
### 6.3.1 sys
部分属性和方法简介：

- sys.argv  :专门先 python；解释器传递参数，即为命令行参数
```python
 #6.3标准库举例
#!usr/bin/env python
#coding = utf-8

import sys
print("The file name: ", sys.argv[0]) #sys.argv[0]是第一个参数，为文件名
print("The number of argument", len(sys.argv)) # 命令行输入的参数数目
print("The argument is: ",str(sys.argv)) # 命令行输入的参数名称
```
在命令行中输入：python char6.py
程序运行结果为：
`The file name:  char6.py`
`The number of argument 1`
`The argument is:  ['char6.py']`

在命令行输入：python char6.py   GJXAIOU  haha
程序运行结果为：
`The file name:  char6.py`
`The number of argument 3`
`The argument is:  ['char6.py', 'GJXAIOU', 'haha']`


- sys.exit()  :退出当前程序，但是返回SystemExit异常

示例程序：
```python
#!usr/bin/env python
#coding = utf-8

import sys
for i in range(10):
    if i == 5:
        sys.exit()
        #sys.exit(0) # 表示正常退出
        #sys.exit("hello") #退出的时候打印里面的提示消息
    else:
        print(i)
```
程序运行结果：
`0`
`1`
`2`
`3`
`4`

**注：** return的作用是终止当前函数，并向调用函数的位置返回相应的值，如果没有就返回None。



### 6.3.2 copy
```python
import copy
print(copy.__all__)
```
得到：`['Error', 'copy', 'deepcopy']`

- copy 和deepcopy 区别
```python
##copy 和deepcopy 区别

#!usr/bin/env python
#coding = utf-8

import copy
class MyCopy:
    def __init__(self, value):
        self.value = value

    def __repr__(self):
        return  str(self.value)

foo = MyCopy(7)

a = ["foo", foo]
b = a[:]
c = list(a)
d = copy.copy(a)
e = copy.deepcopy(a)

a.append("abc")
foo.value = 17

print("original: {0}\n  slice:  {1}\n  list:  {2}\n  copy():  {3}\n  deepcopy():  {4}\n".format(a, b, c, d, e))
```
程序运行结果：
`original: ['foo', 17, 'abc']`
  `slice:  ['foo', 17]`
  `list:  ['foo', 17]`
  `copy():  ['foo', 17]`
  `deepcopy():  ['foo', 7]`



## 6.4 标准库举例：OS

### 6.4.1 操作文件：重命名、删除文件
- 将文件名为:`lala.py`修改为：`haha.py`
在`lala.py`文件中加上：
```python
import os
os.rename("lala.py","haha.py")
```
然后进入命令行模式，进入文件`lala.py`的上一级目录下，执行`python lala.py`

- 删除文件（不能删除目录）
```python
import os
os.remove("文件存放路径")
```

### 6.4.2 操作目录
- os.listdir :显示目录中的内容
```python
import os

files =os.listdir("E:/Program/Python/Study/my/program/daydayup/Code_of_laoqi_python")         #显示该目录下的子目录或者文件，但是不显示隐藏的文件或者子目录，同时返回值为列表
for f in files:
    print(f)
```
程序运行结果：
`123.txt`
`abc.txt`
`char2.py`
`char3.py`
`char4.py`
`char5.py`
`char6.py`
`f.txt`
`lianxi.txt`
`mokuai_pp.py`
`__init__.py`
`__pycache__`

- 工作目录
  - os.getcwd  :当前工作目录
  - os.chdir     :改变当前工作目录
```pythoh
import os
cwd = os.getcwd()   # 当前目录
os.chdir(os.pardir) # 进入上一级目录  #os.pardir 功能为：获得父级目录
up = os.getcwd()
os.chdir("Code_of_laoqi_python") # 进入该目录的下一级目录
down = os.getcwd()
print(cwd)
print(up)
print(down)
```
程序运行结果：
`E:\Program\Python\Study\my\program\daydayup\Code_of_laoqi_python`
`E:\Program\Python\Study\my\program\daydayup`
`E:\Program\Python\Study\my\program\daydayup\Code_of_laoqi_python`

 - 创建和删除目录
```python
## 创建和删除目录 p261
import os
cwd = os.getcwd()   #这为当前目录
print(cwd)
os.makedirs("lingshi") #在此目录下新建一个子目录
os.chdir("lingshi") # 进入子目录中
cwd1 = os.getcwd()
print(cwd1)
files = os.listdir(os.getcwd()) #查看子目录下是否为空
print(files)
newdir = os.getcwd()
print(newdir)
os.removedirs(newdir) #删除当前工作的空目录
```
程序有点问题：


### 6.4.3 文件和目录属性

```python
import os
p = os.getcwd()
infor = os.stat(p) #查看该目录信息
print(infor)
mt = infor[8] #infor[8] 表示该文件最后修改的时间(第八个元素)
print(mt)
import  time
print(time.ctime(mt)) #将时间更好友好化

```
程序运行结果：
`os.stat_result(st_mode=16895, st_ino=562949953662101, st_dev=1143006259, st_nlink=1, st_uid=0, st_gid=0, st_size=4096, st_atime=1550389612, st_mtime=1550389612, st_ctime=1542290649)`
`1550389612`
`Sun Feb 17 15:46:52 2019`



## 6.5 标准库举例：堆
- 是一种数据结构
- 可以看成一棵树的数组对象
- 通过构造二叉堆实现

### 6.5.1 二叉树

- 每个节点最多有两个子树的树结构：左子树   +   右子树
- 并不是所有节点所有两个子节点的树：完全二叉树
- 所有节点都有两个子节点的树：满二叉树
- 节点的值大于等于（或者小于等于）任何子节点的值
- 二叉堆使用二叉树实现的
- 节点左子树和右子树是一个二叉堆，如果父节点的值总是大于等于任意一个子节点的值，则为最大堆；如果父节点的值总小于等于子节点的值，则其为最小堆。

![堆转换成列表]($resource/%E5%A0%86%E8%BD%AC%E6%8D%A2%E6%88%90%E5%88%97%E8%A1%A8.png)


学习至此：p266   2019-2-17









































































