{"compress":true,"commitItems":[["0a987dd0-86ec-4192-a1b1-ab6089238d64",1552743428187,"",[[1552743375766,["GJX@GJXAIOU",[[1,0,"# 笔记汇总\n\n\n\n"]],[0,0],[9,9]]],[1552743393461,["GJX@GJXAIOU",[[1,9,"---\n二轮整理：2019-1-21\n---\n\n# 第1章 基本对象类型\n\n@toc\n\n**浮点数的所有运算都要注意**\n\n## 1.1 数和四则运算\n\n1.python可以自动处理大**整数问题，不必担心溢出**\n\n2.单精度浮点数（4个字节）在计算机内部存储方式：\n1位为符号位（0为正，1为负），8位用作整数，最后的23位表示有效数字\n\n3.每个**对象**在内存中都有自己的地址，可以使用函数`id()`查看每个对象的内存地址；但是通过`id()`得到的内存地址是只读的，**不能够修改**。\n\n4.使用内建函数`type()`可以查看对象的类型，当然得到的结果也是只读的；\n\n5.==**对象有类型，变量无类型**==\n\n6.四则运算中运算符两侧只要有一个为浮点数，结果就是浮点数，否则为整数\n\n7.浮点数会出现溢出的问题    `*`  表示相乘 ；`**` 表示乘幂 ，等效于`pow()`函数，当然使用的时候要导入math库，   `e-08` 表示10的-8次方；\n\n8.python中的==除法的结果都是浮点数，不论参与运算的数有没有浮点数==\n\n9.`//` 表示两个数相除之后的商（取整），这个商一定为整数\n\n10.python中的已经写好的工具叫做 “库” ，或者“模块”、或者“类库”\n\n11.**导入模块：**\n\n- 单一模块： `import module-name`  表示导入模块：module-name\n- 大模块中的小模块： `from module1 import module11` ,表示从库module1（大模块），里面的子模块 module11\n\n**12.针对python中的浮点数问题**\npython以双精度64位表示浮点数，默认的小数精度为17位，所以电脑中以二进制进行保存的时候会丢掉后面的一部分，造成存储的实际上就有误差；\n\n- 除法会将无限循环小数截断，还不是按照四舍五入的截断\n  解决方法，导入decimal：\n```python\n#Author:GJXAIOU \n#coding:utf-8 \n#!/usr/bin/env python \n\nimport decimal #导入decimal 模块\na = decimal.Decimal(\"10.0\") #使用decimal模块中的Decimal函数\nb= decimal.Decimal(\"3\")\nprint(a/b)\n```\n程序运行结果：`3.333333333333333333333333333`\n\n- 两个数相除将结果保留为分数：使用`fraction`\n```python\n#Author:GJXAIOU \n#coding:utf-8 \n#!/usr/bin/env python \nfrom fractions import Fraction\nans = Fraction(10,4)\nprint(ans)\n\n```\n程序运行结果：`5/2`\n\n13.取余：`%`\n\n14.同时获得除法的商和余数，使用内建函数`divmod()`\n```python\n#Author:GJXAIOU\n#coding:utf-8 \n#!/usr/bin/env python \nprint(divmod(5,2))\n```\n程序运行结果：`(2, 1)`前面为商，后面为余数\n\n15.对小数进行四舍五入，使用内建函数 `round()`,前一个参数为数字，后一个参数为小数点后的位数\n```python\n#Author:GJXAIOU \n#coding:utf-8 \n#!/usr/bin/env python \nprint(round(1.256452233 ,3))\n```\n程序运行结果：`1.256`\n\n\n[round（）使用方法](https://blog.csdn.net/gaojixu/article/details/83792109)\n- round()如果只有一个数作为参数，不指定位数的时候：\n  返回的是一个整数，而且是最靠近的整数（这点上类似四舍五入）。但是当出现.5的时候，两边的距离都一样，round()取靠近的偶数。\n- 当指定取舍的小数点位数的时候：\n  一般情况也是使用四舍五入的规则，但是碰到.5的这样情况，如果要取舍的位数前的小数是奇数，则直接舍弃，如果偶数这向上取舍。\n\n\n## 1.3 常见的数学函数以及运算优先级\n- 使用`math`\n```python\n#Author:GJXAIOU \n#coding:utf-8 \n#!/usr/bin/env python\nimport math\nprint(math.pi)\n\nprint(dir(math))\n```\n程序运行结果：\n`3.141592653589793`\n下面是math中的所有东西（函数）\n`['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']`\n\n其中`math.floor()`为取整函数，`math.fabs(-2)`为求绝对值（也可以使用内建函数`abs()`）,求除法的余数：`math.fmod(5,3)`(也可以使用内建的`/`)\n\n\n**2.运算优先级**\n见书P25-26页\n实在不行先加括号\n\n\n## 1.4 一个简单的程序\n\n1.未经编译就可运行的程序称为脚本程序（script）\n\n2.程序前面两行\n```python\n#Author:GJXAIOU \n\n#coding:utf-8   \n#本程序采用utf-8编码 \n#!/usr/bin/env python   \n#在Linux中必须写，在Windows中可以不写，能够引导程序找到python的解释器\n```\n3.python 中的注释：当行注释：`#` ,多行注释：使用一对`'''`或者一对`\"\"\"`\n**能单行注释的就单行注释，尽量避免使用多行注释**\n\n\n\n\n\n## 1.5 字符串\n\n**1.字符串使用单引号或者双引号包裹**\n当字符串内部含有其中一种符号（单引号或者双引号）时候，外面采用另一种符号进行包裹，或者在字符串中出现的的符号前加上`\\`,相当于转义字符。\n\n事例说明：\n```python\n#Author:GJXAIOU \n#coding:utf-8 \n#!/usr/bin/env python \nstr = \"what's your name?\" #采用双引号包含单引号 \nstr1 = 'what\\'s your name?' # 使用转义字符  \nprint(str)\nprint(str1)\n```\n程序运行结果为：\n`what's your name?`\n`what's your name?`\n\n2.可以使用`type()`进行检验类型\n```python\n#Author:GJXAIOU #coding:utf-8 \n#!/usr/bin/env python \nprint(type(330))\nprint(type(\"330\"))\n```\n程序运行结果为：\n`<class 'int'>`  对象类型为整型\n`<class 'str'>` 对象类型为字符串类型\n\n\n\n3.使用`+`实现字符串的连接\n首先 **`+`两边的对象给的数据类型必须一致**，例如都是数字就是加法，字符串就是拼接；\n\n- `str()` 实现将整数转换为字符串； #没有返回值\n`repr()是返回一个字符串对象；\n[补充_Python中str()与repr()函数的区别](补充-python中str-与repr-函数的区别)\n- `int()` 实现将字符串转换为整数\n4.一行的结尾加上`\\` ，实现续行，对于字符串可以采用字符串开头结尾各加上三个`\"`表示字符串的续行\n\n5.键盘输入：使用`input()`获取输入的数据,**input ()返回的结果为字符串类型的对象**\n```python\n#Author:GJXAIOU \n#coding:utf-8 \n#!/usr/bin/env python\nname = input(\"what's your name ?\")\nage = input(\"how old are you ?\")\n\nprint(\"your name is \" + name)\nprint(\"you are \" + age + \"years old.\")\nafter_ten = int(age) + 10 \nprint(\"you will be\" +str(after_ten) + \"years old after ten years.\")\n```\n程序运行结果：\n`what's your name ?gaojixu`\n`how old are you ?23`\n`your name is gaojixu`\n`you are 23years old.`\n`you will be33years old after ten years.`\n\n\n6.原始字符串：由`r`开头引起的字符串就是原始字符串，在里面放置任何字符都是原始含义，也就是说没有转义字符的性质\n```python\na = r\"c:\\hello\"\nprint(a)\n```\n程序运行结果：`c:\\hello`\n\n\n7.**序列:** 有序排列，例如字符串、列表等等统称为序列\n\n8.**索引：** 序列中每一个都有编号，这个编号即为：索引\n例如：\n```python\n#Author:GJXAIOU \n#coding:utf-8\n#!/usr/bin/env python \n\n# 索引 \nlang = \"python is beautiful\" \nprint(\"lang = \" ,lang)\nprint(\"lang[3] = \",lang[3])\n\nans1 = lang.index(\"p\")# 在lang字符串中查找字符p的位置  \nprint(\"index('p')= \",ans1)\n\n#字符串的切片：复制字符串的一部分，（不改变原有的字符串）  \nans2 = lang[2:9]#得到第2到第9个字符（包括第2 个，不包括第9个） \nprint(\"lang[2:9] = \",ans2)\n\nans3 = lang[1:]#得到从第一个到最后的字符（包括第一个和最后一个） \nprint(\"lang[1:] = \",ans3)\n\nans4 = lang[:] #得到所有的字符,这时候新的字符串（其实本质上这时候并没有生成新的字符串）和原来字符串的地址也是一样的\nprint(\"ans4 = \",ans4)\nprint(\"id(lang) = \",id(lang),\"id(ans4) = \",id(ans4))  #id()是查看该对象在内存中的地址   \n**完全复制的时候不产生新的字符串** \n\n#对比如下的赋值语句 \nans = lang\nprint(\"id(lang) = \",id(lang),\"id(ans4) = \",id(ans4))\n\nans5 = lang[:9] #得到第9个之前的所有字符（不包括第9个） \nprint(\"lang[:9] = \",ans5)\n```\n程序运行结果：\n`lang =  python is beautiful`\n`lang[3] =  h`\n`index('p')=  0`\n`lang[2:9] =  thon is`\n`lang[1:] =  ython is beautiful`\n`ans4 =  python is beautiful`\n`id(lang) =  2381962817448 id(ans4) =  2381962817448`\n`id(lang) =  2381962817448 id(ans4) =  2381962817448`\n`lang[:9] =  python is`\n\n\n\n### 1.5.8 字符串的基本操作\n\n- `len() `求字符串的长度  ,返回值为int型\n```python\nstr = \"hello\" \nprint(len(str))\n```\n程序运行结果；`5`\n\n- `+`    连接两个序列\n```python\nstr1 = \"python\" \nstr2 = \"lisp\" \nprint(str1 + \"&\"+ str2)\n```\n程序运行结果：`python&lisp`\n\n- `*`   重复序列元素\n```python\nstr = \"hello\"\nprint(str *3)\n```\n程序运行结果：`hellohellohello`\n\n- `in`  判断元素是否存在于序列中\n```python\nstr1 = \"python\" \nprint(\"th\" in str1)  #多个元素必须是相邻的\n```\n程序运行结果：`True`\n\n- `max()`  返回最大值  ;   `min()` 返回最小值\n```python\nstr1 = \"python\" \nprint(\"max(str1)= \",max(str1),\"min(str1)=\",min(str1))\n```\n程序运行结果：`max(str1)=  y min(str1)= h`\n比较的是字符编码：可以使用内建函数`ord()`获得一个字符对应的数字编码，使用`chr()`实现数字编码向字符的转换\n例如：\n```python\nprint(\"ord('h') = \",ord(\"h\"), \"chr(104) = \",chr(104))\n```\n程序运行结果：`ord('h') =  104 chr(104) =  h`\n*字符串的比较是挨个比较，直到得出结果；\n\nASCII码：A：65  a :97\n\n- 字符串大小写\n```python\n\n\n\n```\n\n\n### 1.5.9 字符串的格式化输出\n- 输出方式\n  - 方法一：使用占位符`%s` ,(不推荐使用)\n```python\nprint(\"I like %s\" %  \"python\")\n```\n  程序运行结果：`I like python`\n\n  - 方法二：使用`format()`方法,使用方法：`string.format()`,format()方法的返回值为一个字符串\n同样是使用占位符`{}`,根据中间的数字序号来对应替换\n```python\nprint(\"I like {1} and {0}\".format(\"lalala\",\"python\"))\n```\n  程序运行结果：`I like python and lalala`\n\n- 输出格式：\n  - 对齐：\n```python\nprint(\"I like {1:10} and {0:^15} and{2:>12}\".format(\"lalala\",\"python\",\"hahaha\"))\n# 参数含义：第一个位置：占得位置为10个字节，默认左对齐；  第0个位置，占的位置为15个字节，居中对齐；\n第2个位置，占得位置长度为12个字节，右对齐；\n```\n程序运行结果：`I like python     and     lalala      and      hahaha`\n\n  - 长度：\n```python\nprint(\"I like {1:.2} and {0:^15.4} and{2:>12}\".format(\"lalala\",\"python\",\"hahaha\"))\n# 参数含义：第1个位置，：后面没有数字表示占得长度自动适应即将放入该位置的字符串，.号后面数字表示对于即将传入的字符串截取前两个字符；\n# 第2个参数的含义；放在第0个位置，占位长度为15个字节，居中对齐，截取将传入的字符串前4个字符\n\n```\n程序运行结果：`I like py and      lala       and      hahaha`\n\n  - 格式符(针对数字（包括整数和浮点数）)\n```python\nprint(\"I like {1:4d} and {0:f} and{2:6.2f} and {3:04f}\".format(12345,900897,3434478,368937987))\n#参数含义：第1个位置，长度为4个字节，以整数形式，默认是右对齐\n# 第2个位置：长度自适应，以浮点数形式。默认右对齐\n#第3个位置：长度6个字节，填充到此的浮点数保留2位小数，右对齐\n#第4个位置：数字前面加0表示如果位数不足则补0；\n```\n程序运行结果：`I like 900897 and 12345.000000 and3434478.00 and 368937987.000000`\n\n\n**默认情况下：字符串左对齐，数字右对齐**\n\n### 1.5.10 常用的字符串方法\n- 判断是否全为字母，使用`isalpha()`判断字符串是否全由字母组成\n```python\nstr= \"python\" \n# 下面两个等价 \nprint(str.isalpha())\nprint(\"python\".isalpha())\n```\n程序运行结果：\n`True`\n`True`\n\n- 根据分隔符分割字符串,**返回结果形式为列表**\n  - 单一分隔符：使用 `str.split()`\n```python\nstr= \"python,is a python.lan\" \nprint(str.split(\" \"))#以空格分割 \nprint(\"python,is a python.lan\".split(\".\"))#以.进行分割\nprint(str.split())#默认的分割符为所有空字符，包括空格、换行、制表符等等\n```\n程序运行结果：\n`['python,is', 'a', 'python.lan']`\n`['python,is a python', 'lan']`\n`['python,is', 'a', 'python.lan']`\n\n  - 多个分割符:导入包`import re`使用`re.split()`\n```pyhton\nimport re\nstr= \"python,is a py?thon.lan\"\nprint(re.split(r\",| \",str)) //多个分隔符之间使用|分开\nprint(re.split(r\",| |\\?\",str)) //当有？等时，需要在前面加上\\进行转义\n```\n- 去掉字符串两头的空格，会产生新的字符串，原来的字符串不变\n```python\nstr = \"  hello  \" \nprint(id(str))#获得原来的字符串的地址\n print(\"star\"+str.strip()+ \"end\")#去除左右 所有  的空格 \n print(id(\"star\"+str.strip()+ \"end\"))#获取变换之后的字符串的地址 \n print(\"start\"+str.lstrip()+ \"end\")#去除 左边 的空格 \n print(\"start\"+str.rstrip()+ \"end\")#去除 右边 的空格 \n print(\"start\"+str+\"end\")#去除之后的字符串，原来的值没有变化，这种去除产生了新的字符串\n str = str.strip()  # 去除原来字符串两边空格并保存\n```\n程序运行结果：\n`1651046031536`\n`starhelloend`\n`1651046258096`\n`starthello  end`\n`start  helloend`\n`start  hello  end`\n\n- 字符大小写的转换，生成一个新的字符串，不改变原有的值\n  - str.upper() :将str中的字母全部转换为大写\n  - str.lower() :将str中的字母全部转换为小写\n  - str.capitalize() :将首字母转换为大写\n  - str.isupper() :判断str中的字母是否全为大写\n  - str.islower() :判断str中的字母是否全为小写\n  - str.istitle() :判断str是否为标题模式，即所有单词首字母大写，其余字母全部小写 \n```python\nstr = \"hello PyThon\" \nprint(str.upper())\nprint(str.lower())\n\n```\n程序运行结果：\n`HELLO PYTHON`\n`hello python`\n\n- 用join()拼接字符串,主要用于将中的各种类型元素连接，或者使用某个符号来拼接字符串\n```python\na = [\"python\",\"is\",\"the\",\"best\"]\nprint(\"*\".join(a))\n```\n程序运行结果：`python*is*the*best`\n\n\n\n## 1.6 字符编码\npython 3 中所有字符串均采用Unicode编码，UTF-8只是其实现方法之一(采用可变长度字符编码)，同时可以使用`encode()`将Unicode编码的字符转换为其他编码\n\n\n\n\n## 1.7 列表\n\n### 1.7.1 定义\n- 形式为`[]`\n- 判断列表是否为空：`bool()`  空为false\n- 定义：\n```python\na = ['2',3,\"hello\"]#包含字符、数字、字符串\nb= [\"python\",a]#同时可以套一个列表\nprint(a)\nprint(b)\n```\n程序运行结果为：\n`['2', 3, 'hello']`\n`['python', ['2', 3, 'hello']]`\n\n\n### 1.7.2 索引和切片\n\n```python\n#索引\n\n#列表元素的索引\na = ['2',3,\"hello\",\"end\"]\nprint(a[2])\nprint(a[:2])\nprint(a[2][1:4])\nprint(a[-1])  #访问列表中最后一个元素\n#列表元素地址的索引\n\"\"\"\n编号方式（适用于字符串和列表等所有序列类型）：从左至右0、1、2  或者从右至左-1、-2、-3、-4.。。。\n\"\"\"\nprint(a.index(\"hello\"))#这样默认返回时是按照从左到右的顺序\n\n\n#切片\n\n#典型的错误读取方式\nprint(a[-1:-3]) # 等价于a[(4-1):(4-3)]=a[3:1],又因为序列都是从左到右读取，这里是从右到左的读取，因此返回空值\n#正确用法\nprint(a[-3:-1])  #等价于a[1:3]\n\n#根据步长切片，当步长为正数的时候，相当于从左往右看数列，先看到的值为开始的值\nprint(a[::2])#从头搜到位，步长为2，实际上中间也就间隔一个字符  [开始：结束：步长]\n\n# 当步长为负数的时候，相当于从右往左看数列，先看到的值为开始的值\n\nprint(a[1:3:2])\nprint(a[-3:3:2])\nprint(a[-2:1:-2])\n```\n程序运行结果：\n`hello`\n`['2', 3]`\n`ell`\n`2`\n`[]`\n`[3, 'hello']`\n`['2', 'hello']`\n`[3]`\n`[3]`\n`['hello']`\n\n\n### 1.7.3  反转（适用于列表以及字符串）\n```python\nlst = [1,2,3,4,5,6]\nstr = \"python\"\nprint(lst[: : -1])\nprint(str[: : -1])\n\nprint(lst)\nprint(str)\n\n#可以使用reversed函数进行反转，但是必须加上list，最后的结果也都是列表格式\nprint(list(reversed(str)))\nprint(list(reversed(lst)))\n#注意比较两个的不同\n```\n程序运行结果：\n`[6, 5, 4, 3, 2, 1]`\n`nohtyp`\n`[1, 2, 3, 4, 5, 6]`\n`python`\n`['n', 'o', 'h', 't', 'y', 'p']`\n`[6, 5, 4, 3, 2, 1]`\n\n\n\n### 1.7.4 操作列表\n- 基本操作\n  - `len()`  \n```python\nlst= [\"i\",\"python\",\"lalla\"]\nprint(len(lst))\n```\n程序运行结果：`3`\n\n  - `+` :连接两个列表\n  - `*` :重复序列元素\n  - `in` :判断元素是否在列表中（完整性的元素，不是字符）\n```python\nlst= [\"i\",\"python\",\"lalla\"]\nprint(\"python\" in lst)\nprint(\"la\" in lst)\n```\n程序运行结果：\n`True`\n`False`\n\n  - `max()`和`min()`寻找列表中最大或者最小的元素\n```python\nlst= [\"i\",\"python\",\"lalla\"]\nprint(max(lst))\nprint(min(lst))\n```\n程序运行结果：\n`python`\n`i`\n\n\n- 修改列表元素（修改和追加）\n```python\n#修改元素\n\nlst= [\"i\",\"python\",\"lalla\"]\nlst[1] = \"hello\"  #将第1个元素修改为“hello”\nprint(lst)\n\n#追加元素\nlst.append(\"hulala\")#在结尾追加元素,返回值为None,直接使用print(lst.append(\"hulala\")),结果为None 同时进行的也是原地修改\nprint(lst)\n```\n程序运行结果：\n`['i', 'hello', 'lalla']`\n`['i', 'hello', 'lalla', 'hulala']`\n\n**追加元素是原地修改，返回值为None**\n\n\n\n\n### 1.7.5 常见的列表函数\n\n- extend ：将两个列表合并，a:b - >a+b :b,参数可以是列表或者字符串，**但是如果为数值型就会报错**\n  extend的参数必须为iterable(可迭代的（可以重复反馈）)\n  使用`hasattr()`判断类型是否可迭代，判断本质是看类型中是否含有`_iter_()`这个方法，可以使用`dir`查看\n  示例；\n```python\nlst = [1,2]\nlat= 3\nprint(hasattr(lst,'__iter__'))\n#hasattr(object，'x') 函数，用于判断对象object是否含有x属性或方法，有则返回True，否则返回False\nprint(hasattr(lat,\"__iter__\"))\n\n```\n程序运行结果：\n`True`\n`False`\n\n```python\nla = [\"lala\",\"lblb\"]\nlb = [1,2,3]\nprint(la.extend(lb))#la.extend(lb)的返回值为none,同时拓展之后的内存位置仍然没有改变，原地修改\nprint(la)\nprint(lb)\n\nlc= \"abcde\"#当拓展参数为字符串的时候，结果是将字符串挨个字符拆开形成列表，然后在追加\nla.extend(lc)\nprint(la)\n\nla = [\"lala\",\"lblb\"] # 当拓展为列表的时候，不再拆分然后追加，直接追加\nld = [\"abcde\"]\nla.extend(ld)\nprint(la)\n```\n程序运行结果：\n`None`\n`['lala', 'lblb', 1, 2, 3]`\n`[1, 2, 3]`\n`['lala', 'lblb', 1, 2, 3, 'a', 'b', 'c', 'd', 'e']`\n`['lala', 'lblb', 'abcde']`\n\n**append（）和extend（）区别：**\nappend直接将所有内容整体打包什么都不动（包括列表的[])追加在后面\nextend将追加的内容先拆开（针对列表），然后合并成一个列表\n\n\n- count：查找列表中元素出现的次数(必须是完整的)\n```python\nlst = [1,2,3,2,1,2,1,'a','aaa']\nprint(lst.count(1))\nprint(lst.count('a'))\n```\n程序运行结果：\n`3`\n`1`\n\n- index :查找列表中的元素（必须是完整的）在列表中第一次出现的位置\n```python\nlst = [1,2,3,2,1,2,1,'a']\nprint(lst.index(1))\nprint(lst.index('a'))\n```\n程序运行结果：\n`0`\n`7`\n\n- insert ：将元素添加在列表中的任意位置：`list(i,x)`,其中i为想插入的位置，X为插入的元素，该元素插入位置之前\n```python\nlst = [1,2,'a']\nlst.insert(2,\"lalala\")#insert()函数也是列表的原地修改，没有返回值，或者说返回值为None\nprint(lst)\nlst.insert(len(lst),\"end\") #使用len函数，将插入值放在字符串的最后面\nprint(lst)\n\n```\n程序运行结果为：\n`[1, 2, 'lalala', 'a']`\n`[1, 2, 'lalala', 'a', 'end']`\n\n\n- remove 和pop实现删除列表中的元素\n  - remove ：\n```python\n#remove使用方式：\n# 正确就删除第一个符合的对象，没有返回值；对列表进行原地修改\n#如果删除的元素不在列表中，则会报错：X not in list\n\nlst= [\"python\",\"hello\",\"lala\",1,2]\nprint(\"hello\" in lst)#可以在删除之前先判断该元素是否在列表中\nlst.remove(\"hello\")#同样没有返回值，\nprint(lst)\n\n```\n程序运行结果：\n`True`\n`['python', 'lala', 1, 2]`\n\n\n  - pop :使用方式: `list.pop([i])` ,其中i为所要删除的元素的位置,实际使用的时候没有[]，如果为空则表示删除最后一个，返回值为删除的元素\n```python\nlst= [\"python\",\"hello\",\"lala\",1,2]\nprint(lst.pop(1))#删除列表中第1个元素，返回值为第1个元素的值\nprint(lst)\n\n```\n程序运行结果：\n`hello`\n`['python', 'lala', 1, 2]`\n\n\n\n\n- reverse :将列表的元素顺序返回来，是原地反过来(原来列表的值变化)，没有返回值,\n- reversed :原来列表的值没有变化，有返回值，但是返回值并不是list（），需要转换为list()\n```python\nlst= [\"python\",\"hello\",\"lala\",1,2]\n#reverse()\nlst.reverse()\nprint(lst)#原列表的值改变了\n\n#reversed()\nprint(reversed(lst))#返回值不是列表\nprint(list(reversed(lst)))#将机返回值转换为列表\nprint(lst)#再次打印列表，经过reversed之后的原列表没有变化\n```\n程序运行结果；\n`[2, 1, 'lala', 'hello', 'python']`\n`<list_reverseiterator object at 0x0000029BF3C09160>`\n`['python', 'hello', 'lala', 1, 2]`\n`[2, 1, 'lala', 'hello', 'python']`\n\n\n\n- sort :对列表进行排序，进行原地修改，没有返回值，默认为从小到大进行排序，也可以设置关键字进行排序\n```python\n#使用sort（）不能实现字符串与整数进行排序，只能各自排序\nlst= [\"python\",\"hello\",\"lala\"]\nlst.sort()\nprint(lst)\n\n#按照从大到小进行排序(反向排序)\nlst.sort(reverse = True)#这里的True不能小写\nprint(lst)\n\n#按照某个关键词进行排序\nlst.sort(key = len) #按照长度为关键字进行排序\nprint(lst)\n```\n程序运行结果：\n`['hello', 'lala', 'python']`\n`['python', 'lala', 'hello']`\n`['lala', 'hello', 'python']`\n\n\n- sorted :产生新的列表，有返回值，可以设置从左到右或者从右到左排序\n```python\nlst= [\"python\",\"hello\",\"lala\"]\nprint(sorted(lst))#默认情况下是从小到大的排序\nprint(lst)#可以得到原列表并没有改变\n\n#实现从大到小的排序\nprint(sorted(lst,reverse = True))\n\n```\n程序运行结果；\n`['hello', 'lala', 'python']`\n`['python', 'hello', 'lala']`\n`['python', 'lala', 'hello']`\n\n\n\n### 1.7.6 比较字符串和列表\n- 相同点：\n  - 都是序列类型\n  - 都可以按照顺序进行索引\n  - 都可以采用切片得到一个或者多个元素\n\n- 不同点：\n  - 列表是可以改变的，然后字符串是不可以改变的。\n  - 字符串中每个元素只能是字符，列表中都可以，也可以列表套列表，形成多维列表，在多维情况下，里面的列表被当成一个元素来看待\n\n\n### 1.7.7 字符串和列表的转换\n- split()  ：可以根据某个分隔符将字符串转换为列表\n```python\nstr = \"hello.i am GJXAIOU .welcome you\"\nprint(str.split(\".\")) #以.来分割\nprint(str.split(\".\",1))#以第一个.来分割\nprint(str.split())# 所有的空字符都是分隔符\n```\n程序运行结果：\n`['hello', 'i am GJXAIOU ', 'welcome you']`\n`['hello', 'i am GJXAIOU .welcome you']`\n`['hello.i', 'am', 'GJXAIOU', '.welcome', 'you']`\n\n\n\n- join :连接list中的元素或者字符串中的字符\n\n```python\nlst = ['hello.i', 'am', 'GJXAIOU', '.welcome', 'you']\nstr1 = [1,2,3,'a','b']\nprint(\"\".join(lst))#没有连接符，表示紧邻着\nprint(\",\".join(lst))#以英文的.作为连接符\nprint(\" \".join(str(str1)))#以为list中含有数字，不能直接转换成字符串\n```\n程序运行结果：\n`hello.iamGJXAIOU.welcomeyou`\n`hello.i,am,GJXAIOU,.welcome,you`\n`[ 1 ,   2 ,   3 ,   ' a ' ,   ' b ' ]`\n\n\n\n\n\n\n## 1.8 元组（tuple）\n\n这是一种（数据）或者对象类型,其元素可以包含任何类型的数据,==元组的对象是可以迭代的==\n格式为：用（）括起来，中间的元素使用`,`隔开，==元组是序列，元素不能更改==\n```python\nlst = 1,2,\"lalala\",[\"jdjjdfj\",1234],(\"123\",12,'abadf')#几乎包含了所有的数据类型\nprint(lst)\nprint(type(lst))\n```\n程序运行结果：\n`(1, 2, 'lalala', ['jdjjdfj', 1234], ('123', 12, 'abadf'))`\n`<class 'tuple'>`\n\n\n\n\n### 1.8.2 索引和切片\n\n主要的方法和列表以及字符串几乎相同，只是当元组中只有一个元素的时候，元素后面应该加上英文的`,`,\n```python\nlst = (3)\nlat = (3,)\nprint(type(lst))\nprint(type(lat))\n```\n程序运行结果为：\n`<class 'int'>`\n`<class 'tuple'>`\n\n以为元素是不可修改的，如果需要修改元组可以将元组转换成一个列表，然后在进行修改\n函数为：`list()` 以及 `tuple()`\n\n\n\n\n\n\n### 1.8.3 元组的用途\n- 元组的操作比列表快，所以当定义一个值之后以后只是遍历的话，使用元组\n- 元组可以进行“写保护”，如果要改变的话先转换为列表\n- 元组可以在字典中用作key（因为字典的key是保持不变的）\n\n- 元组的值不可修改，但是可以给存储元组的变量进行赋值\n\n\n\n## 1.9 字典\n\n一般用于存放一个对象的各种属性，或者多个相似对象的同一种信息\n### 1.9.1 创建字典\n```python\n#“A”：“B” ，为一对键/值对,前面为键，后面为值，每一个字典中键都是唯一的，\nperson = {\"name\":\"gjxaiou\",\"site\":\"www.gaojixu.com\",\"language\":\"python\"}\nprint(person)\n\n#向已经建立的字典中增加键值对：\nperson['name2']= \"GJXAIOU\"  #字典是进行原地修改\n\n\n#方法二：使用dict()函数\nname = ([\"first\",\"google\"],[\"second\",\"Yahoo\"])\nweb = dict(name)\n\nprint(web)\n\n\n#方法三：使用fromkeys()\nwebsite = {}.fromkeys((\"third\",\"forth\"),\"facebook\")\nprint(website)\n\n#注意；元组可以做键值，但是列表不能\ndd = {(1,2):1}\nprint(dd)\n#ee = {[1,2],1},会报错\n```\n\n### 1.9.2 访问字典的值，通过键就可以得到值\n```python\n#首先字典中是没有索引的\nperson = {\"name\":\"gjxaiou\",\"site\":\"www.gaojixu.com\",\"language\":\"python\"}\nprint(person['name'])\n```\n程序运行结果：`gjxaiou`\n\n\n### 1.9.3 基本操作\n- `len(d)` :返回字典中的键值对数量\n- `d[key]` :返回字典中键对应的值\n- `d[key] = value` :将value赋值给字典中的键\n- `del d[key]` :删除该键对应的键值对\n- `key in d` :检查字典中是否含有键为key的项\n\n\n\n### 1.9.5 字典的方法\n- copy ：对象有类型，变量无类型\n```python\n#基本的赋值操作\na = 5\nb = a\nprint(a)\nprint(id(a))\nprint(id(b))\n```\n程序运行结果：\n`5`\n`140703865942992`\n`140703865942992`\n\n```python\n#使用copy得到的是新的空间，和原来的各不相干\nperson = {\"name\":\"gjxaiou\",\"site\":\"www.gaojixu.com\",\"language\":\"python\"}\ncd = person.copy()\n\nprint(cd)\nprint(id(cd))\nprint(id(person))\nprint(id(person[\"name\"]))\nprint(id(cd[\"name\"]))#两个键的值（列表）为同一个对象\n```\n程序运行结果；\n`{'name': 'gjxaiou', 'site': 'www.gaojixu.com', 'language': 'python'}`\n`2246490159576`\n`2246490159504`\n`1341291115664`\n`1341291115664`\n\n- `deepcopy()` ,深拷贝形成一个副本，相当于两个完全无关的字典\n\n```python\n#使用copy得到的是新的空间，和原来的各不相干\nimport copy\nperson = {\"name\":\"gjxaiou\",\"site\":\"www.gaojixu.com\",\"language\":\"python\"}\ncd = copy.deepcopy(person)\n\nprint(cd)\nprint(id(cd))\nprint(id(person))\nprint(id(person[\"name\"]))\nprint(id(cd[\"name\"]))#两个键的值（列表）为同一个对象\n```\n程序运行结果：\n`{'name': 'gjxaiou', 'site': 'www.gaojixu.com', 'language': 'python'}`\n`1652151429808`\n`1652150008208`\n`1652150776976`\n`1652150776976`\n\n\n\n\n\n\n- clear 清空字典中的所有元素,得到空字典，但是对象仍然在内存中，而`del`是直接将字典删除，内存中就没有了\n```python\n#clear 没有返回值，是对字典进行了原地修改\na = {\"name\" : \"GJXAIOU\"}\na.clear()\nprint(a)\n\n```\n程序运行结果：`{}`\n\n\n\n- get 和setdefault\n  - get 的含义是获取该键对应的值，如果没有发现也不报错\n```python\na = {\"name\" : \"GJXAIOU\",\"age\":\"lalala\"}\nprint(a.get(\"name\"))\nprint(a.get(\"gjx\",\"no answer\"))#如果找到键的值就返回键的值，如果没有就返回后面的值\nprint(a.setdefault(\"first\",\"second\"))#如果找到键的值就返回键的值，如果没有就返回后面的值,并且将这个键值对加入原来的字典中\nprint(a)\n```\n程序运行结果：\n`GJXAIOU`\n`no answer`\n`second`\n`{'name': 'GJXAIOU', 'age': 'lalala', 'first': 'second'}`\n\n\n- items .keys  .values\n  - items\n```python\na ={'name': 'GJXAIOU', 'age': 'lalala', 'first': 'second'}\nprint(a.items())\n```\n程序运行结果：`dict_items([('name', 'GJXAIOU'), ('age', 'lalala'), ('first', 'second')])`\n\n  - keys 得到所有的键，value 得到所有的值\n```python\na ={'name': 'GJXAIOU', 'age': 'lalala', 'first': 'second'}\nprint(a.keys())\nprint(a.values()) \n```\n程序运行结果：\n`dict_keys(['name', 'age', 'first'])`\n`dict_values(['GJXAIOU', 'lalala', 'second'])`\n\n\n\n\n\n- pop 和popitem\n  - pop 删除键值对\n```python\na ={'name': 'GJXAIOU', 'age': 'lalala', 'first': 'second'}\nprint(a.pop(\"name\"))#以键为参数，将指定键的键值对删除，返回值为键所对应的值，如果没有找到键，就返回错误\nprint(a)\nprint(a.pop(\"name\",\"no find in:'name'\")) #pop后面可以是两个参数，以逗号隔开，如果有这个键，就返回对应的值，如果没有就返回后面的这个参数\nprint(a)\n```\n程序运行结果：\n`GJXAIOU`\n`{'age': 'lalala', 'first': 'second'}`\n`no find in:'name'`#这里因为上面已经删除了，所以找不到了\n`{'age': 'lalala', 'first': 'second'}`\n\n  - popitem \n```python\na ={'name': 'GJXAIOU', 'age': 'lalala', 'first': 'second'}\nprint(a.popitem( ))#可以不写参数，就是随机删除一个，然后将删除的值返回，返回的格式为元组\n```\n程序运行结果：`('first', 'second')`\n\n\n\n\n- update :更新字典内容，函数返回值为None即没有返回值\n```python\na ={'name': 'GJXAIOU', 'age': 'lalala', }\nb = {'first': 'second'}\na.update(b)\nprint(a)\n# 字典b更新纳入字典a 中，函数返回值为None，当然b并没有变化\n```\n程序运行结果：`{'name': 'GJXAIOU', 'age': 'lalala', 'first': 'second'}`\n\n\n\n\n\n## 1.10 集合（set）\n特点：有的可变、有的不可变、元素无次序、不可重复\n集合没有索引，没有顺序，不属于序列\n```python\n#创建集合，这里是将字符串拆后形成集合 ，这里hello中有两个l,但是集合中只有一个l\n\n#通过set函数创建\na= set(\"helloworld\")\nprint(a)\n\n# 直接创建,尽量避免使用这种方法\nb = {\"facd\",123}\nprint(type(b))\nprint(b)\n\n\n#unhashable  不可哈希 ：表示该数据时可变的，例如列表、字典都能原地修改\n#使用{} 进行创建的时候，元素要求是可哈希的，随意存在字典、列表就报错\n#但是set（）建立起来的集合是可变集合。可变集合都是不可哈希类型\n```\n程序运行结果；\n`{'e', 'h', 'd', 'r', 'w', 'l', 'o'}`\n`<class 'set'>`\n`{123, 'facd'}`\n\n\n\n\n### 1.10.2 set 的方法\n\n- add和update\n```python\n#如果要创建一个空集合，只能使用set，\na_set = {}  #这样默认情况下创建的是字典\nprint(type(a_set))\n\ns= set()\nprint(type(s))#创建一个空集合\ns.add(\"hello\")#为该集合增加一个元素\nprint(s)\n```\n程序运行结果：\n`<class 'dict'>`\n`<class 'set'>`\n`{'hello'}`\n\n\n- update \n```python\ns1= set(['a','b'])\ns2 = set(['c','d'])\ns2.update(s1)\nprint(s2)\ns2.update(\"hello\")\nprint(s2)\ns2.update((2,3))\nprint(s2)\n```\n程序运行结果：\n`{'c', 'd', 'b', 'a'}`\n`{'d', 'e', 'o', 'l', 'c', 'h', 'b', 'a'}`\n`{2, 3, 'd', 'e', 'o', 'l', 'c', 'h', 'b', 'a'}`\n\n\n- pop,remove,discard,clear\n```python\n#pop :没有参数，删除元素也是随机删除，返回值为删除的元素，没有可以删除的元素的时候就会报错\nb_set = {'e', 'h', 'd', 'r', 'w', 'l', 'o'}\nprint(b_set.pop())\n\n#remove :没有返回值，删除的指定元素不存在时候会报错\nb_set.remove(\"d\")#删除指定的值\nprint(b_set)\n\n\n#discard :没有返回值，有就删除，没有就什么都不做\nb_set.discard(\"r\")\nprint(b_set)\n\n#clear ：清空所有元素\nb_set.clear()\nprint(b_set)\n```\n程序运行结果：\n`e`\n`{'o', 'h', 'l', 'r', 'w'}`\n`{'o', 'h', 'l', 'w'}`\n`set()`\n\n\n\n\n### 1.10.3 使用frozenset创建不可变集合\n\n\n\n### 1.10.4 集合运算\n\n- 元素与集合的关系\n```python\n#判断元素是否在集合中 \nb_set = {'e', 'h', 'd', 'r', 'w', 'l', 'o'}\nprint(\"h\" in b_set)\n```\n程序运行结果：`True`\n\n\n- 集合与集合的关系\n```python\n#判断两个集合是否完全一样\n\na_set = {'e','d','g','k'}\nb_set = {'e', 'h', 'd', 'r', 'w', 'l', 'o'}\nprint(a_set == b_set)\n\n\n#判断A是否是B的子集\n\na_set = {'e','d','g','k'}\nb_set = {'e', 'h', 'd', 'r', 'w', 'l', 'o'}\nprint(a_set < b_set)\n#或者：print(a_set.issubset(b_set))\n\n\n#求A与B的并集\n\na_set = {'e','d','g','k'}\nb_set = {'e', 'h', 'd', 'r', 'w', 'l', 'o'}\nc_set = a_set |b_set\n#或者使用  a_set.union(b_set)\nprint(c_set)\n\n\n\n#求A与B的交集\n\na_set = {'e','d','g','k'}\nb_set = {'e', 'h', 'd', 'r', 'w', 'l', 'o'}\nc_set = a_set & b_set\n#或者：c_set = a.intersection(b_set)\nprint(c_set)\n\n\n\n#A 相对于B的差（补），即A相对于B不同的部分元素    （书P98）\n\na_set = {'e','d','g','k'}\nb_set = {'e', 'h', 'd', 'r', 'w', 'l', 'o'}\nprint(a_set - b_set)\n#上面等价于：print(a_set.difference(b_set))\nprint(b_set - a_set)\n#上面等价于：print(b_set.difference(a_set))\n\n\n\n# A 与B的对称差集\na_set = {'e','d','g','k'}\nb_set = {'e', 'h', 'd', 'r', 'w', 'l', 'o'}\nprint(a_set.symmetric_difference(b_set))\n\n```\n程序运行结果：\n`False`\n`False`\n`{'w', 'h', 'd', 'r', 'o', 'k', 'l', 'g', 'e'}`\n`{'e', 'd'}`\n`{'g', 'k'}`\n`{'w', 'h', 'r', 'o', 'l'}`\n`{'w', 'h', 'r', 'o', 'k', 'l', 'g'}`\n\n"]],[9,9],[22096,22096]]],[1552743405769,["GJX@GJXAIOU",[[1,22097,"\n"]],[22096,22096],[22097,22097]]],[1552743406005,["GJX@GJXAIOU",[[1,22098,"\n"]],[22097,22097],[22098,22098]]],[1552743406259,["GJX@GJXAIOU",[[1,22099,"\n"]],[22098,22098],[22099,22099]]],[1552743406469,["GJX@GJXAIOU",[[1,22100,"\n"]],[22099,22099],[22100,22100]]],[1552743406852,["GJX@GJXAIOU",[[-1,22100,"\n"],[1,22101,"-"]],[22100,22100],[22101,22101]]],[1552743420339,["GJX@GJXAIOU",[[1,22101,"----------------------------------------------------------------"]],[22101,22101],[22165,22165]]],[1552743421316,["GJX@GJXAIOU",[[1,22099,"----"]],[22165,22165],[22103,22103]]],[1552743433727,["GJX@GJXAIOU",[[-1,22099,"----"]],[22099,22103],[22099,22099]]],[1552743437049,["GJX@GJXAIOU",[[-1,22099,"\n"]],[22100,22100],[22099,22099]]],[1552743438671,["GJX@GJXAIOU",[[-1,22098,"\n"]],[22099,22099],[22098,22098]]],[1552743439273,["GJX@GJXAIOU",[[-1,22097,"\n"]],[22098,22098],[22097,22097]]],[1552743441404,["GJX@GJXAIOU",[[1,22162,"\n\n"]],[22162,22162],[22163,22163]]],[1552743441601,["GJX@GJXAIOU",[[1,22164,"\n"]],[22163,22163],[22164,22164]]],[1552743441874,["GJX@GJXAIOU",[[1,22165,"\n"]],[22164,22164],[22165,22165]]],[1552743442148,["GJX@GJXAIOU",[[1,22166,"\n"]],[22165,22165],[22166,22166]]],[1552743442638,["GJX@GJXAIOU",[[1,22167,"\n"]],[22166,22166],[22167,22167]]],[1552743442831,["GJX@GJXAIOU",[[1,22168,"\n"]],[22167,22167],[22168,22168]]],[1552743443018,["GJX@GJXAIOU",[[1,22169,"\n"]],[22168,22168],[22169,22169]]],[1552743443199,["GJX@GJXAIOU",[[1,22170,"\n"]],[22169,22169],[22170,22170]]],[1552743443391,["GJX@GJXAIOU",[[1,22171,"\n"]],[22170,22170],[22171,22171]]],[1552743443581,["GJX@GJXAIOU",[[1,22172,"\n"]],[22171,22171],[22172,22172]]],[1552743443809,["GJX@GJXAIOU",[[1,22173,"\n"]],[22172,22172],[22173,22173]]],[1552743444011,["GJX@GJXAIOU",[[1,22174,"\n"]],[22173,22173],[22174,22174]]],[1552743444198,["GJX@GJXAIOU",[[1,22175,"\n"]],[22174,22174],[22175,22175]]],[1552743444379,["GJX@GJXAIOU",[[1,22176,"\n"]],[22175,22175],[22176,22176]]],[1552743444581,["GJX@GJXAIOU",[[1,22177,"\n"]],[22176,22176],[22177,22177]]],[1552743444769,["GJX@GJXAIOU",[[1,22178,"\n"]],[22177,22177],[22178,22178]]],[1552743444956,["GJX@GJXAIOU",[[1,22179,"\n"]],[22178,22178],[22179,22179]]],[1552743445169,["GJX@GJXAIOU",[[1,22180,"\n"]],[22179,22179],[22180,22180]]],[1552743445375,["GJX@GJXAIOU",[[1,22181,"\n"]],[22180,22180],[22181,22181]]],[1552743445615,["GJX@GJXAIOU",[[1,22182,"\n"]],[22181,22181],[22182,22182]]],[1552743445824,["GJX@GJXAIOU",[[1,22183,"\n"]],[22182,22182],[22183,22183]]],[1552743446006,["GJX@GJXAIOU",[[1,22184,"\n"]],[22183,22183],[22184,22184]]],[1552743446195,["GJX@GJXAIOU",[[1,22185,"\n"]],[22184,22184],[22185,22185]]],[1552743446377,["GJX@GJXAIOU",[[1,22186,"\n"]],[22185,22185],[22186,22186]]],[1552743446574,["GJX@GJXAIOU",[[1,22187,"\n"]],[22186,22186],[22187,22187]]],[1552743446765,["GJX@GJXAIOU",[[1,22188,"\n"]],[22187,22187],[22188,22188]]],[1552743446952,["GJX@GJXAIOU",[[1,22189,"\n"]],[22188,22188],[22189,22189]]],[1552743447187,["GJX@GJXAIOU",[[1,22190,"\n"]],[22189,22189],[22190,22190]]],[1552743450089,["GJX@GJXAIOU",[[1,22097,"\n"]],[22096,22096],[22097,22097]]],[1552743450419,["GJX@GJXAIOU",[[1,22098,"\n"]],[22097,22097],[22098,22098]]],[1552743450690,["GJX@GJXAIOU",[[1,22099,"\n"]],[22098,22098],[22099,22099]]],[1552743450970,["GJX@GJXAIOU",[[1,22100,"\n"]],[22099,22099],[22100,22100]]],[1552743463866,["GJX@GJXAIOU",[[1,22174,"---\ndateline:`2018-11-21`\n---\n\n# 第2章 语句和文件\n\n\n## 2.1 运算符\n\n### 2.1.1 算术运算符\n| 运算符 | 描述 | 实例 |\n|---|---|---|---|\n| + | 加 - 两个对象相加                            | a + b 输出结果 30 |\n| - | 减 - 得到负数或是一个数减去另一个数            | a - b 输出结果 -10 |\n| * | 乘 - 两个数相乘或是返回一个被重复若干次的字符串 | a * b 输出结果 200 |\n| / | 除 - x除以y                                  | b / a 输出结果 2 |\n| % | 取余 - 返回除法的余数                          | b % a 输出结果 0 |\n| ** | 幂 - 返回x的y次幂                     | a**b 为10的20次方， 输出结果 100000000000000000000 |\n| // | 取整除 - 返回商的整数部分（**向下取整**） |  9//2 =4    ； -9//2 = -5\n\n\n### 2.1.2 比较运算符\n任何两个同一类型的对象都可以进行比较\n\n| 运算符 | 描述 | 实例 |\n|---|---|---|---|\n| == | 等于 - 比较对象是否相等 | (a == b) 返回 False。 |\n| != | 不等于（python3） - 比较两个对象是否不相等 | (a != b) 返回 true. |\n| <> | 不等于（python2） - 比较两个对象是否不相等 | (a <> b) 返回 true。这个运算符类似 != 。 |\n| > | 大于 - 返回x是否大于y | (a > b) 返回 False。 |\n| < | 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。 | (a < b) 返回 true。 |\n| >= | 大于等于 - 返回x是否大于等于y。 | (a >= b) 返回 False。 |\n| <= | 小于等于 - 返回x是否小于等于y。 | (a <= b) 返回 true。 |\n\n\n\n### 2.1.3 逻辑运算符\n\n- 1.布尔类型\n本质上就是返回值为 `True` 和`False` 的对象\n注意：\n```python\na = \" \"#这里是空格，空格也是一个字符\nprint(bool(a))\n\nb = \"\"#这里是空，不是空格\nprint(bool(b))\n\nprint(bool([])) #这是空列表\n\nprint(bool({})) #这是空字典\n```\n程序运行结果：\n`True`\n`False`\n`False`\n`False`\n\n- 2.布尔运算\n进行布尔运算的运算符称为逻辑运算符  ：and   or     not\n\n  - and :      A and  B\n  **含义：** 如果A 为true，计算B，最终结果为B   ；如果A为False ，就不用计算B，结果为False\n\n  - or  :     A or B  \n  **含义：** 如果A的值为True ，结果为True  ； 如果A为False，结果看B的值\n\n  - not   ：not A\n  **含义：** 取反就行\n\n对于复杂的布尔表达式一定使用括号来自主选择优先级\n\n\n\n## 2.2 简单语句  \n\n### 2.2.1  import   \n使用`import math`    导入math模块,\n使用math模块里面的函数：`math.pow(3,2)`,这种应用方式可以避免函数重名\n\n\n\n### 2.2.2 赋值\n```python\n#批量的进行一一赋值\nx,y,z = 1,\"python\",[\"hello\",\"world\"]\nprint(x)\nprint(y)\nprint(z)\n\n#将多个值赋值给一个：相当于自动创建一个元组\n\naa = \"hello\",\"python\"\nprint(aa)\n\n\n\n## 交换元素值(实现数值对调 )    变量只是贴在对象上的标签\n\nla = 2\nlb = 3\nla,lb = lb,la\nprint(la)\nprint(lb)\n\n\n\n\n## 链式赋值\n\nm = n = \"python\"\nprint(\"m = \",m, \"; n = \" ,n)\nprint(\"id(m) = \",id(m), \"id(n) = \",id(n))  #实际上两个变量所指向的是同一个对象\n#以上判断内存是否一致方法还可以使用is\nprint(m is n)  #如果结果为True，则表示两个变量所引用的对象是同一个\n\n\n\n## 两变量赋值同样的对象\nlala = \"python\"\nlblb = \"python\"\nprint(lala is lblb) # 其结果并非同一个\n\n\n# 下面这句有待商榷\n#例外情况：当两个变量都分别赋值小于等于256及其以下的值时候，其所指的都是同一块内存，等价于链式赋值，但是大于256就是两个对象\n\nlu = 256\nlk = 256\nprint(lu is lk)\n\nld = 257\nldd = 257\nprint(id(ld),id(ldd))\nprint(ld is ldd)\n\nld = 4097\nldd =4097\nprint(id(ld),id(ldd))\nprint(ld is ldd)\n\n#可以使用+实现赋值\nx = 9\nx += 1\nprint(x)\n\n\ny = \"pyth\"\ny += \"on\"\nprint(y)\n```\n程序运行结果：\n`1`\n`python`\n`['hello', 'world']`\n`('hello', 'python')`\n`3`\n`2`\n`m =  python ; n =  python`\n`id(m) =  2859978232080 id(n) =  2859978232080`\n`True`\n`True`\n`True`\n`2859977205744 2859977205744`\n`True`\n`2859978871344 2859978871344`\n`True`\n`10`\n`python`\n\n## 2.3 条件语句\n\n### 2.3.1 if  ...elif ...else\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#@Time :2018/11/14 19:23\n#Author:GJXAIOU\n\nimport math\n\nprint(\"please input a number :\")\n\nnumber = input()  #这里不能使用int进行强转，如果使用int就不能使用isdigit\n\nif number.isdigit():# isdigit()是检测字符串是否由数字组成\n\n    if int(number) == 10:\n        print(\"The number of you input is :{}\".format(number))\n        print(\"You are smart\")\n\n    elif int(number) < 10:\n        print(\"The number of you input is :{}\".format(number))\n        print(\"The number is bigger than you input\")\n\n    else:\n        print(\"The number of you input is :{}\".format(number))\n        print(\"The number is smaller than you input\")\n\nelse:\n    print(\" The input is not number,please input number\")\n\n```\n\n\n### 2.3.3 三元操作符\n```python\nname = \"qiwsie\" if 29 > 21 else \"github\"\n```\n\n**函数定义：**  A = Y if X else Z \n- 如果X为真，那么就执行 A= Y\n- 如果X为假，就执行 A= Z\n\n\n\n\n## 2.4 for循环语句\n只有序列类型可以使用for 循环（包括：列表和字符串）\n```python\nfor 循环规则：\n    操作语句\n```\n\n示例程序；\n```python\nhello = \"world\"\nfor i in hello:\n    print(i)\n\n```\n下面的程序等效于上面的程序：\n```python\nhello = \"world\"\nfor i in range(len(hello)):\n    print(hello[i])\n```\n程序运行结果：\n`w`\n`o`\n`r`\n`l`\n`d`\n\n- print()默认的`end = \\n`,所以在默认的情况下，每个元素都单独占一行\n- 字典也可以使用for循环，但是得到的结果是获取字典中所有的键值\n```python\ns = dict([(\"web\",\"hello\"),(\"lang\",\"world\"),(\"author\",\"laogao\")])\nfor k in s.keys():  #同样是获得字典中所有的键值\n    print(k)\n\nfor v in s.values(): #获得字典中所有的值\n    print(v)\n\nfor k,v in s.items():  #同时获得字典中所有的键和值\n    print(k + \"-->\" +v)\n```\n程序运行结果：\n`web`\n`lang`\n`author`\n`hello`\n`world`\n`laogao`\n`web-->hello`\n`lang-->world`\n`author-->laogao`\n\n- **for循环所应用的对象必须是可迭代的**\n判断一个对象是否可以迭代\n```python\nfrom collections import Iterable\n\nprint(isinstance(123,Iterable))\n```\n(需要在终端中运行)程序运行结果：\n`False`\n\n==字符串、列表、字典、元组、集合都是可迭代对象==\n\n\n\n\n### 2.4.3  range(start,stop,[,step])\n- 参数含义：开始，结尾，步长\n- 当步长为1 的时候可以省略\n- 当start为0的时候，可以省略\n- 当步长不为1的时候，开始不可以省略\n```python\n\"\"\"\nrange 的使用 ；P118\n\n\"\"\"\nprint(range(1,7,2)) #第一个值为1，然后是start+1 * step ，以此类推\nprint(type(range(1,7,2))) #range 得到的结果为一个序列类型，序列的名字就是range\n\nprint(range(0,-9,-1))  #这样无法得到列表\n\nprint(list(range(0,-9,-1)))#结果为列表\n```\n程序的运行结果；\n`range(1, 7, 2)`\n`<class 'range'>`\n`range(0, -9, -1)`\n`[0, -1, -2, -3, -4, -5, -6, -7, -8]`\n\n\n\n### 2.4.4 并行迭代\n```pyhton\n\n\"\"\"\n使用zip() 进行并行迭代：P120\n\"\"\"\n#迭代：将for循环用于列表、字符串、字典的键值对就是迭代\n# zip()的参数需要是可迭代对象，返回值是一个zip对象\n\n#当参数为普通序列时候\na = \"hello\"\nb = \"world\"\nc = \"gaojixu\"\nprint(zip(a,b))  #函数名表示函数在内存中的信息\nprint(list(zip(a,b)))# 序列长度相同的时候\nprint(list(zip(a,c))) #序列长度不同的时候，以两个中短的那个为准\n\n#当参数为字典的时候\nd = {\"name\":\"GJX\"}\ne = {\"age\":\"23\"}\nprint(list(zip(d,e))) #得到的是所有的键值\n\n\n#当参数是一个序列时候\nf = \"hello\"\ng = \"world\"\nprint(list(zip(f)))\nprint(list(zip(g)))\n\n\n#应用，两个序列对应位置元素运算\na = [1,2,4,5,6]\nb = [2,3,4,5,7]\nd = []\nfor x,y in zip(a,b):\n    d.append(x + y)\n\n\nprint(d)\n```\n程序运行结果：\n`<zip object at 0x0000026214FB9B48>`\n`[('h', 'w'), ('e', 'o'), ('l', 'r'), ('l', 'l'), ('o', 'd')]`\n`[('h', 'g'), ('e', 'a'), ('l', 'o'), ('l', 'j'), ('o', 'i')]`\n`[('name', 'age')]`\n`[('h',), ('e',), ('l',), ('l',), ('o',)]`\n`[('w',), ('o',), ('r',), ('l',), ('d',)]`\n`[3, 5, 8, 10, 13]`\n\n### 2.4.5 enumerate使用\n```python\n'''\nenumerate的使用；p123\n'''\n\n'''\n同时得到列表中元素的索引和元素 p123\n'''\n# 一般方法\nweek = ['monday','sunday','friday']\nfor i in range(len(week)):\n    print(week[i] + 'is' + str(i)) #str(i) ,将整数i 转换为字符串类型，因为有加号\n\n#使用enumerate 内建函数\nfor (i,day) in enumerate(week):\n    print(day + \"is\" + str(i))\n\n'''\n直接显示列表中的索引和元素  p124\n'''\nseasons = ['spring','summer','fall','winter']\nprint(list(enumerate(seasons)))\nprint(list(enumerate(seasons,start = 1)))\n\n'''\n当原本的为字符串的时候，需要先转换为列表  p124\n'''\n\n#将字符串中部分字符进行替换\n\nraw = \"hello world ,you are a good good student .\"\nraw_list = raw.split()\n\nfor i,string in enumerate(raw_list):\n    #if string ==\"good\":  使用该语句只能查找得到第一个good,后面的改不了\n    if \"good\" in string:\n        raw_list[i] = \"best\"\n\nprint(raw_list)\n```\n程序运行结果：\n`mondayis0`\n`sundayis1`\n`fridayis2`\n`mondayis0`\n`sundayis1`\n`fridayis2`\n`[(0, 'spring'), (1, 'summer'), (2, 'fall'), (3, 'winter')]`\n`[(1, 'spring'), (2, 'summer'), (3, 'fall'), (4, 'winter')] `\n`['hello', 'world', ',you', 'are', 'a', 'best', 'best', 'student', '.']`\n\n### 2.4.6 列表解析\n```python\n\n'''\n列表解析：p125\n'''\n\n#得到1-9的平方，放入列表并打印\n\noutlist1 = []\nfor i in range(1,10):\n    outlist1.append(i**2)\nprint(outlist1)\n\n#使用列表解析得到\noutlist2 = [(i**2) for i in range(1,10)]\nprint(outlist2)\n\n\n#删除列表中字符串前后的空格\nraw_list = [\"  hello\",\" lala \",\"world  \"]\nans_list = [one.strip() for one in raw_list]\nprint(ans_list)\n```\n程序运行结果：\n`[1, 4, 9, 16, 25, 36, 49, 64, 81]`\n`[1, 4, 9, 16, 25, 36, 49, 64, 81]`\n`['hello', 'lala', 'world']`\n\n\n\n\n## 2.5 while循环语句\n示例程序：\n```python\n\n'''\nwhile循环示例：P129\n'''\nimport  random\nnum = random.randint(1,100)\nguess = 0\n\nwhile True:\n    num_input = input(\"please input one interger that is in 1 to 100:\")\n    guess +=1\n    if not num_input.isdigit():#用来判断字符串是否全部由数字组成\n        print(\"please input interger.\")\n    elif int(num_input) < 0 or int(num_input) > 100:\n        print(\"please input number that is in 1 to 100:\")\n    else:\n        if num == int(num_input):\n            print(\"you are so smart\")\n            break\n        elif num > int(num_input):\n            print(\"the true num is bigger than you input\")\n        elif num < int(num_input):\n            print(\"the true num is smaller than you input\")\n        else:\n            print(\"There is something bad\")\n```\n\n### 2.5.2 break和continue \n\n**1.break：** 主要是在当前位置中断循环并且跳出循环体\n\n**continue：** 从当前位置（continue 位置）跳到循环体的最后一行的后面（不执行最后一行）\n\n==尽量在循环之前将条件做足，避免使用这两个在循环中跳来跳去==\n\n\n\n### 2.5.3 while....else\n例子：\n```python\n'''\nwhile ...else P130\n'''\n\ncount = 0\nwhile count < 5 :\n    print(count ,\"is less than 5\")\n    count += 1\nelse:\n    print(count,\"is not less than 5\")\n```\n程序运行结果：\n`0 is less than 5`\n`1 is less than 5`\n`2 is less than 5`\n`3 is less than 5`\n`4 is less than 5`\n`5 is not less than 5`\n\n### 2.5.4 for ...else\n```python\n'''\nfor ...else  P131\n'''\nfrom math import sqrt\nfor i in range(99,80,-1):\n    root = sqrt(i)\n    if root == int (root):\n        print(root ,\"is the sqrt of\",i)\n        break                            #这个break作用是？\n    else:\n        print(\"nothing\")\n```\n程序运行结果：\n`nothing`\n`nothing`\n`nothing`\n`9.0 is the sqrt of 81`\n\n\n\n## 2.6  文件\n\n### 2.6.1 读文件\n\n```python\n'''\n读文件：p131\n'''\nf = open(\"123.txt\") #表示该文件在当前目录下，如果在其他目录下要写上路径\nfor line in f:\n    print(line)\n\n```\n程序运行结果：\n`你好世界`\n\n`12345`\n\n`best`\n#因为每行的最后都有`\\n`,同时print在默认情况下，打印完line的对象之后会增加一个`\\n`,因此中间会空一行；\n\n上面程序改进\n```python\nf = open(\"123.txt\") #表示该文件在当前目录下，如果在其他目录下要写上路径\nfor line in f:\n    print(line,end = ' ')\n```\n\n**文件对象是可迭代的**\n\n\n\n\n\n### 2.6.2 创建文件\n‘r’只读模式，**必须打开一个已有的文件，且只能执行读操作**。\n\n‘r+’读+追加模式，可读可写，与‘r’相同之处在于也是必须打开一个已有的文件，不同的是它可写可读，而且写与读不分先后，即随时都可进行读与写。（写为追加在文件末尾）\n\n‘w’只写模式，**打开即默认创建一个新的空文件，当然若打开的是已有文件，则清空文件，且只能执行写操作**。\n\n‘w+’写读模式，打开创建新文件，因此需要先把内容写进去在读。即保证文件有内容通过移动光标来读自己想要的部分。\n\n‘a’追加模式，若打开的是已有文件则直接对已有文件操作，若打开文件不存在则创建新文件，只能执行写（追加在后面），不能读。即追加写。\n\n‘a+’追加读写模式，打开文件方式同‘a’一样，写方式也和'a'一样，但是可以读。且是任意时刻读写。需要注意的是你若刚用‘a+’打开一个文件，则不能立即读，因为此时光标已经是文件末尾，除非你把光标移动到初始位置或任意非末尾的位置。\n\n\n\n\n\n\n### 2.6.3 使用with\n\n```python\n'''\n使用with  p135\n'''\n\n#常用的使用文件方法：\n# fn = open(\"abc.txt\",\"a\") #打开文件\n# fn.write(\"python is the best\") #写入文件\n# fn.close()     #关闭文件\n\n\n#使用with进行操作，这时候就不需要使用close\n\nwith open(\"abc.txt\") as fn:\n    print(fn.read())\n\n```\n当然程序中两个代码的作用是不一样的，这里只是示范一下使用方法\n\n### 2.6.4 文件的状态\n\n可以获取文件的创建日期、修改日期的状态信息\n```python\n\n'''\n文件的状态：p136\n'''\n\nimport os\nfile_state = os.stat(\"abc.txt\")\nprint(file_state)\n\n```\n程序运行结果；\n`os.stat_result(st_mode=33206, st_ino=562949953675316, st_dev=1143006259, st_nlink=1, st_uid=0, st_gid=0, st_size=18, st_atime=1542798239, st_mtime=1542798211, st_ctime=1542798211)`\n显示的结果看不懂\n换一种显示方式：\n```python\n'''\n换种时间显示方式：\n'''\nimport os\nfile_state = os.stat(\"abc.txt\")\nimport time\nstate_file = time.localtime(file_state.st_ctime)\nprint(state_file)\n```\n程序运行结果：\n`time.struct_time(tm_year=2018, tm_mon=11, tm_mday=21, tm_hour=19, tm_min=3, tm_sec=31, tm_wday=2, tm_yday=325, tm_isdst=0)`\n\n\n### 2.6.5 read /readline / readlines \n\n- **read:** 完整的表达方式：read(size) ,指一次性读取文件中size个字符并且返回一个字符串，如果省略的话则读取文件对象中的字符直到EOF，并且依然返回字符串\n- **readline:** 每次执行`文件名.readlines()` ,只读取一行，直到最后一行，最后一行之后还执行的话会返回空字符串，但是不报错\n- **readlines：** 它的作用是将文件中的各行读取出来，最后结果放在一个列表中返回\n\n\n\n\n### 2.6.6 读很大的文件\n使用fileinput模块，使用方式如下：\n```python\n'''\n使用fileinput 模块进行大文件的读取\n'''\nimport fileinput\nfor line in fileinput.input(\"lianxi.txt\"):\n    print(line,end = \" \")\n```\n程序运行结果：防止运行时可以的\n\n\n### 2.6.7 seek\n[seek使用报错解决](https://blog.csdn.net/gaojixu/article/details/84331063)\n首先在读取文件的时候，指针随之运动，当读取结束的时候，指针就移动到相应的位置了\n例如：文件f.txt中内容如下；\n you raise me up\n when i am down\n please help me\n lalalalala\n\n```python\n'''\n使用seek   \n'''\n\nf = open(\"f.txt\",\"rb\") #如果使用seek，这里必须使用rb\nprint(f.readline(),end = \" \")\nprint(f.tell()) #文件名.tell()   显示当前偏移量移动指针的位置\n\nf.seek(0) #将指针的位置偏移量置为0，相当于把位置移动到开头\nprint(f.tell())\nprint(f.readline(),end = \" \")\nprint(f.tell())\n\n\n#seek的标准形式为 :seek(offset[,whence])\n\n#whence 默认值为0，表示从文件开头进行计算偏移量，这时候offset必须大于等于0\n#whence 如果为1，表示从当前位置开始计算偏移量，如果offence为负数，表示往前移动，为正表示往后移动\n#whence 如果为2，表示相对于文件末尾移动\n\nf.seek(-5,1) #以当前位置为准，往后移动两个\nprint(f.readline(),end = \" \")\n\n```\n程序运行结果；\n`b'you raise me up\\r\\n' 17`\n`0`\n`b'you raise me up\\r\\n' 17`\n`b' up\\r\\n' `\n\n\n\n## 2.7 初识迭代\n\n- **循环：** 指是在满足条件的情况下，重复执行同一段代码，如while语句\n- **迭代：** 指的是按照某种顺序逐个访问对象（如列表）中的每一句，如for语句\n- **递归：** 指的是一个函数不断调用自身的行为，如斐波那契数列\n- **遍历：** 指的是按照一定的规则访问树形结构中的每一个节点，而且每个节点都只访问一次，例如for循环\n\n\n\n\n## 书上对应代码练习：\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#@Time :2018/11/15 22:04\n#Author:GJXAIOU\n\n\n\"\"\"\n本代码为第二章练习代码，从笔记中的2.4.3中开始，其他将会陆续补充\n\n\"\"\"\n\n\n\n\"\"\"\nrange 的使用 ；P118\n\n\"\"\"\n# print(range(1,7,2)) #第一个值为1，然后是start+1 * step ，以此类推\n# print(type(range(1,7,2))) #range 得到的结果为一个序列类型，序列的名字就是range\n#\n# print(range(0,-9,-1))  #这样无法得到列表\n#\n# print(list(range(0,-9,-1)))#结果为列表\n\n\n\n\n\n\n\n\"\"\"\n使用zip() 进行并行迭代：P120\n\"\"\"\n# #迭代：将for循环用于列表、字符串、字典的键值对就是迭代\n# # zip()的参数需要是可迭代对象，返回值是一个zip对象\n#\n# #当参数为普通序列时候\n# a = \"hello\"\n# b = \"world\"\n# c = \"gaojixu\"\n# print(zip(a,b))  #函数名表示函数在内存中的信息\n# print(list(zip(a,b)))# 序列长度相同的时候\n# print(list(zip(a,c))) #序列长度不同的时候，以两个中短的那个为准\n#\n# #当参数为字典的时候\n# d = {\"name\":\"GJX\"}\n# e = {\"age\":\"23\"}\n# print(list(zip(d,e))) #得到的是所有的键值\n#\n#\n# #当参数是一个序列时候\n# f = \"hello\"\n# g = \"world\"\n# print(list(zip(f)))\n# print(list(zip(g)))\n#\n#\n# #应用，两个序列对应位置元素运算\n# a = [1,2,4,5,6]\n# b = [2,3,4,5,7]\n# d = []\n# for x,y in zip(a,b):\n#     d.append(x + y)\n#\n#\n# print(d)\n\n\n'''\nenumerate的使用；p123\n'''\n#\n# '''\n# 同时得到列表中元素的索引和元素 p123\n# '''\n# # 一般方法\n# week = ['monday','sunday','friday']\n# for i in range(len(week)):\n#     print(week[i] + 'is' + str(i)) #str(i) ,将整数i 转换为字符串类型，因为有加号\n#\n# #使用enumerate 内建函数\n# for (i,day) in enumerate(week):\n#     print(day + \"is\" + str(i))\n#\n# '''\n# 直接显示列表中的索引和元素  p124\n# '''\n# seasons = ['spring','summer','fall','winter']\n# print(list(enumerate(seasons)))\n# print(list(enumerate(seasons,start = 1)))\n#\n# '''\n# 当原本的为字符串的时候，需要先转换为列表  p124\n# '''\n#\n# #将字符串中部分字符进行替换\n#\n# raw = \"hello world ,you are a good good student .\"\n# raw_list = raw.split()\n#\n# for i,string in enumerate(raw_list):\n#     #if string ==\"good\":  使用该语句只能查找得到第一个good,后面的改不了\n#     if \"good\" in string:\n#         raw_list[i] = \"best\"\n#\n# print(raw_list)\n\n\n\n\n\n'''\n列表解析：p125\n'''\n\n# #得到1-9的平方，放入列表并打印\n#\n# outlist1 = []\n# for i in range(1,10):\n#     outlist1.append(i**2)\n# print(outlist1)\n#\n# #使用列表解析得到\n# outlist2 = [(i**2) for i in range(1,10)]\n# print(outlist2)\n#\n#\n# #删除列表中字符串前后的空格\n# raw_list = [\"  hello\",\" lala \",\"world  \"]\n# ans_list = [one.strip() for one in raw_list]\n# print(ans_list)\n\n\n\n\n'''\nwhile循环示例：P129\n'''\n# import  random\n# num = random.randint(1,100)\n# guess = 0\n#\n# while True:\n#     num_input = input(\"please input one interger that is in 1 to 100:\")\n#     guess +=1\n#     if not num_input.isdigit():\n#         print(\"please input interger.\")\n#     elif int(num_input) < 0 or int(num_input) > 100:\n#         print(\"please input number that is in 1 to 100:\")\n#     else:\n#         if num == int(num_input):\n#             print(\"you are so smart\")\n#             break\n#         elif num > int(num_input):\n#             print(\"the true num is bigger than you input\")\n#         elif num < int(num_input):\n#             print(\"the true num is smaller than you input\")\n#         else:\n#             print(\"There is something bad\")\n\n\n\n\n'''\nwhile ...else P130\n'''\n# count = 0\n# # while count < 5 :\n# #     print(count ,\"is less than 5\")\n# #     count += 1\n# # else:\n# #     print(count,\"is not less than 5\")\n\n\n\n'''\nfor ...else  P131\n'''\n# from math import sqrt\n# for i in range(84,80,-1):\n#     root = sqrt(i)\n#     if root == int (root):\n#         print(root ,\"is the sqrt of\",i)\n#         break                            #这个break作用是？\n#     else:\n#         print(\"nothing\")\n\n\n'''\n读文件：p131\n'''\n# f = open(\"123.txt\") #表示该文件在当前目录下，如果在其他目录下要写上路径\n# for line in f:\n#     print(line,end = ' ')\n\n\n'''\n使用with  p135\n'''\n\n#常用的使用文件方法：\n# fn = open(\"abc.txt\",\"a\") #打开文件\n# fn.write(\"python is the best\") #写入文件\n# fn.close()     #关闭文件\n\n\n#使用with进行操作，这时候就不需要使用close\n\n# with open(\"abc.txt\") as fn:\n#     print(fn.read())\n\n\n\n'''\n文件的状态：p136\n'''\n#\n# import os\n# file_state = os.stat(\"abc.txt\")\n# print(file_state)\n#\n\n'''\n换种时间显示方式：\n'''\n# import os\n# # file_state = os.stat(\"abc.txt\")\n# # import time\n# # state_file = time.localtime(file_state.st_ctime)\n# # print(state_file)\n\n\n'''\n使用fileinput 模块进行大文件的读取\n'''\n# import fileinput\n# for line in fileinput.input(\"lianxi.txt\"):\n#     print(line,end = \" \")\n#\n\n\n\n\n'''\n使用seek   \n'''\n#\n# f = open(\"f.txt\",\"rb\")\n# print(f.readline(),end = \" \")\n# print(f.tell()) #文件名.tell()   显示当前偏移量移动指针的位置\n#\n# f.seek(0) #将指针的位置偏移量置为0，相当于把位置移动到开头\n# print(f.tell())\n# print(f.readline(),end = \" \")\n# print(f.tell())\n#\n#\n# #seek的标准形式为 :seek(offset[,whence])\n#\n# #whence 默认值为0，表示从文件开头进行计算偏移量，这时候offset必须大于等于0\n# #whence 如果为1，表示从当前位置开始计算偏移量，如果offence为负数，表示往前移动，为正表示往后移动\n# #whence 如果为2，表示相对于文件末尾移动\n#\n# f.seek(-5,1) #以当前位置为准，往后移动两个\n# print(f.readline(),end = \" \")\n\n\n\n'''\n闭包：p168\n'''\n# def foo():\n#     a = 3\n#     def bar():\n#         return a\n#     return bar\n#\n# f = foo()\n# print(f())\n\n\n\n'''\nlambda的使用：p170\n'''\n# lam = lambda x,y :x + y\n# buf = []\n# for i in range(10):\n#     buf.append(lam(i,i+1))\n#\n# print(buf)\n\n\n'''\nmap使用 p172\n'''\n# numbers1 = [1,2,3,4,5,6,7,8,9]\n# numbers2 = [1,2,3,4,5,6,7,8,9]\n# numbers3 = [1,2]\n#\n# a =list(map(lambda x,y: x+y ,numbers1,numbers2))\n# b =list(map(lambda x,y: x+y ,numbers1,numbers3))\n# print(a)\n# print(b)\n\n\n\n'''\nreduce p173\n'''\n# from functools import reduce\n# a = reduce(lambda x,y:x+y,[1,2,3,4,5])\n# print(a)\n\n\n\n\n\n\n\n```\n\n\n\n  \n\n\n"]],[22174,22174],[39108,39108]]],[1552743483745,["GJX@GJXAIOU",[[1,39110,"------------------------------------------------------------"]],[39110,39110],[39170,39170]]],[1552743485077,["GJX@GJXAIOU",[[1,39189,"\n"]],[39170,39170],[39171,39171]]],[1552743485493,["GJX@GJXAIOU",[[1,39190,"\n"]],[39171,39171],[39172,39172]]],[1552743486628,["GJX@GJXAIOU",[[1,39191,"\n"]],[39172,39172],[39173,39173]]],[1552743487052,["GJX@GJXAIOU",[[1,39192,"\n"]],[39173,39173],[39174,39174]]],[1552743487496,["GJX@GJXAIOU",[[1,39193,"\n"]],[39174,39174],[39175,39175]]],[1552743487926,["GJX@GJXAIOU",[[1,39194,"\n"]],[39175,39175],[39176,39176]]],[1552743488351,["GJX@GJXAIOU",[[1,39195,"\n"]],[39176,39176],[39177,39177]]],[1552743488752,["GJX@GJXAIOU",[[1,39196,"\n"]],[39177,39177],[39178,39178]]],[1552743489189,["GJX@GJXAIOU",[[1,39197,"\n"]],[39178,39178],[39179,39179]]],[1552743505968,["GJX@GJXAIOU",[[1,39177,"---\ndate：`2018-11-15`\n---\n\n# 第3章 函数\n\n\n## 3.1函数的基本概念\n\n### 3.1.1 理解函数\n\n- 变量本质上时占位符，变量名通常使用小写字母进行命名，可以使用下划线连接多个单词\n\n\n\n### 3.1.2 定义函数\n1.标准格式\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#@Time :2018/11/15 14:49\n#Author:GJXAIOU\n\ndef add_function(a,b): \n    #定义一个函数使用 ：  def   函数名（参数）:    其中：表示函数头的结束\n    # 函数名的命名；小写字母或者单下划线或者数字\n    #这里a,b作为形参，也可以认为是变量，而变量无类型，所以并没有规定其所引用的对象的类型，意义取决于对象的类型，称为多态\n    c = a + b   # 函数体必须缩进4个空格\n    return c  #return语句执行的时候，python会跳出当前的函数并且返回到调用这个函数的地方\n\n\nif __name__ == \"__main__\":\n    result = add_function(2,3)  #调用函数并且将实参传递给函数\n    print(result)\n\n\n# 下面为函数的其他使用方法\n\n# 只写函数名会得到该函数在内存中的存储信息\nprint(add_function)\n\n# 赋值语句可以实现变量和函数对象建立应用关系，\nc= add_function\nresult1 = c(3,4)\nprint(result1)\n```\n程序运行结果：\n`5`\n`<function add_function at 0x000001E65BA4D2F0>`\n`7`\n\n\n### 3.1.3 函数的命名\n- **变量名：** 全部小写，使用下划线连接各个单词\n- **文件名：** 全部小写，可以使用下划线\n- **函数名：** 小写，可以使用下划线\n- **函数的参数：** 同变量，本质上就是变量\n\n\n\n\n\n\n### 3.1.4 调用函数\n**函数调用的时候参数赋值方法**\n```python\n'''\n调用函数 p151\n'''\ndef add(x,y):\n    print(\"x = {}\".format(x))\n    print(\"y = {}\".format(y))\n    return x +y\n\n#参数赋值方法一：\nans1 = add(2,3) #这里传递参数默认按照次序依次赋值\nprint(\"ans = \",ans1)\n\n#参数赋值方法二：\n\nans2 = add(y = 4,x = 5) #直接使用变量= 变量值进行赋值，这就不用理会什么顺序\nprint(ans2)\n\n```\n程序运行结果：\n`x = 2`\n`y = 3`\n`ans =  5`\n`x = 5`\n`y = 4`\n`9`\n\n**特殊：当函数在定义的时候，部分参数赋值**\n```python\n'''\n当定义函数的时候进行部分参数赋值\n'''\n\n #def acfun(x = 1,y,z = 4 ): 这种定义方法是错误的，因为有默认值的参数必须都在没有默认值参数后面\ndef acfun(x,y,z= 1):\n    acans = x +y +z\n    return acans\n\nans1 = acfun(1,2) #可以不给z赋值，则使用默认值\nans2 = acfun(2,3,2)#如果赋值，则使用这个值\nprint(\"ans1 = \",ans1)\nprint(\"ans2 = \",ans2)\n\n```\n程序运行结果：\n`ans1 =  4`\n`ans2 =  7`\n\n\n\n\n\n## 3.2 深入探究函数\n\n\n### 3.2.1 函数返回值\n\n**示例程序：实现Fibonacci数列**\n```python\n\n'''\n\n实现Fibonacci数列：P153\n'''\n\n\n# 此函数只有一个返回值（一个列表）\n\ndef fib(n):\n    result = [0,1]  # 以列表形式返回\n    for i in range(n-2):\n        result.append(result[-2] + result[-1])\n    return result\n\nif __name__ == \"__main__\":\n    haha = fib(10)\n    print(haha)\n\n\n# 但函数的返回值有多个时候，返回值类型为元组\n\ndef bilibili():\n    return 1,2,3\n\n##接受返回值的方法一；\nans = bilibili()\nprint(\"ans = \" ,ans)\n\n##接受函数返回值的方法二：\nx,y,z = bilibili()\nprint(x,y,z)\n\n\n# 如果函数没有return，则返回值为None\n```\n\n**return 作用**\n- 返回函数的结果：\n- 中断函数体内的流程，离开这个函数，即结束正在执行的这个函数，并离开函数体返回到调用位置\n示例程序；\n```python\n'''\n验证return的作用：p155\n'''\n\ndef dilidili():\n    print(\"hello\")\n    return\n    print(\"world\")\n\nans = dilidili()\nprint(ans)\n```\n程序运行结果：\n`hello`\n`None`\n从输出结果可以看出，第二个print实际上并没有执行，遇到return就跳到调用的地方了\n\n\n\n### 3.2.2  函数中的文档\n```python\n'''\n函数文档注释；p156\n'''\n\ndef eilieili():\n    \"\"\"\n    this is a function,haha\n\n    \"\"\"\n    print(\"lalala\")\n    \nprint(eilieili.__doc__)  # 参数含义：函数名.__doc__  \n#打印函数功能注释：首先注释必须在函数内部\n```\n\n\n\n### 3.2.3 函数的属性\n因为函数也是对象，所以函数也有属性\n\n- 使用：`dir(函数名)` ，可以得到该函数所有的属性和方法，其中一双下划线开始的是特殊属性，都可以使用句点的方式调用\n```python\n\"\"\"\n\n函数的属性：P156\n\"\"\"\n\ndef filifili():\n    print(\"hahha\")\n\nprint(dir(filifili))\n```\n\n程序运行结果：\n`['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']`\n\n\n### 3.2.4 参数和变量\n==函数参数传递的是对象的应用==\n[函数参数与变量的关系](https://foofish.net/python-function-args.html)\n```python\n\n\"\"\"\n参数与变量 ：p159\n\"\"\"\n\ndef giligili(lst):\n    lst.append(0)\n    return lst\n\nx = [1,2,3]\ny = giligili(x)\nprint(y)\n\n#这里实现的是原地修改\nprint(id(x))\nprint(id(y))\n```\n程序运行结果；\n`[1, 2, 3, 0]`\n`1887845442120`\n`1887845442120`\n\n\n\n\n### 3.2.5 参数收集\n\n- 输入参数个数不确定\n```python\n\"\"\"\n参数收集：p160\n\"\"\"\n\ndef foo(x,*arg):\n    print(arg)\n\nfoo(1,2,3,4,5,6,7)  #将第一个赋值给x之后，其余后面的所有的都以元组的形式赋值给*arg\n\nfoo(1,3)  # 当只有3赋值给*arg时候，结果相当于元组中只有一个元素，这时候结果应该是：（3，），元组中单个元素后面要加上逗号\n\n\ndef foobar(x,y,z,*arg,**args):\n    print(\"x = \",x,\"\\n y = \",y,\"\\n z = \",z,\"\\n *arg = \",arg,\"\\n **args = \",args) \n    #注意这里打印输出只需要写arg,不需要写*\n\nfoobar(1,2,3,4,5,6,7,name = \"gaojixu\",age = 23)   #**args得到的值为字典类型，注意赋值方式\n```\n程序运行方式：\n\n`(2, 3, 4, 5, 6, 7)`\n`(3,)`\n`x =  1 `\n `y =  2 `\n `z =  3 `\n `*arg =  (4, 5, 6, 7) `\n `**args =  {'name': 'gaojixu', 'age': 23}`\n\n\n\n## 3.3 函数对象\n\n### 3.3.1递归 ==谨慎使用==\n\n[理解python函数入口](https://blog.csdn.net/gaojixu/article/details/84110883)\n- 使用递归的方法实现Fibonacci数列\n```python\n\n\"\"\"\n函数递归：使用递归的方法实现Fibonacci数列值 p163\n\"\"\"\n\ndef fib(n):\n    \"\"\"\n    This is a Fibonacci by Recursion\n\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) +fib(n-2)\n\n\nif __name__ == \"__main__\":\n    f = fib(10)\n    print(f)\n\n\n```\n程序运行结果：\n`55`\n\n\n\n### 3.3.2传递函数（函数做参数）\n```python\n\n\"\"\"\n传递函数：函数做参数 P164\n\"\"\"\n\ndef power_seq(func,seq):\n    #因为pingfang也是一个函数名，可以这样理解：func = pingfang ,\n    #后面一个参数seq 接受num_seq中的列表\n    return [func(i) for i in seq]\n    #因为func = pingfang ,所以func(i)，其实本质上为pingfang(i ),相当于在调用函数\n\"\"\"\n上面的语句等价为：\ndef power_seq(func,seq):\n    ans = []   #新建一个空列表\n    for i in seq:\n        ans.append(func(i)) #列表中加元素使用追加\n    return ans\n\"\"\"\n\ndef pingfang(x):\n    return x **2\n\nif __name__ == \"__main__\":\n    num_seq = [111,3.14,8,44]\n    r = power_seq(pingfang,num_seq) #调用函数，传递参数\n    print(num_seq)\n    print(r)\n\n\n```\n程序运行结果：\n`[111, 3.14, 8, 44]`\n`[12321, 9.8596, 64, 1936]`\n\n\n### 3.3.3 嵌套函数\n\n```python\n\"\"\"\n嵌套函数：P164\n\"\"\"\n\ndef foo():\n    def bar():\n        print(\"bar() is running\")\n    #bar()  可以在这里进行调用执行\n    print(\"foo() is running \")\n\nprint(foo()) #调用执行foo()函数,注意这里并没有调用bar()函数，所以bar()函数不执行\n#print(bar()) #在函数外部不能调用里面定义的函数，这能在函数内部调用\n```\n程序运行结果：\n`foo() is running` \n`None`\n\n\n\n**理解下面的嵌套程序：**\n```python\n\n\"\"\"\n嵌套函数练习：P166\n\"\"\"\n\ndef weight(g):       #第二步：接受值：g = 10\n    def cal_mg(m): #第七步，***\n        return m*g\n    return cal_mg   #第三步：返回cal_mg\n\nw = weight(10)       #第一步：传值，g= 10   #第四步：接受值，w = cal_mg\nmg = w(10)           #第五步：w(10) 相当于：cal_mg(10),调用cal_mg函数\nprint(mg)\n```\n程序运行结果：`100`\n\n\n### 3.3.4 初始装饰器\n[查看原文点击这里:](https://foofish.net/python-decorator.html)\n\n### 3.3.5 闭包\n- 闭包是一个函数，特点如下；\n  - 定义在另一个函数里面；\n  - 引用其所在函数环境的自由变量；\n  - 装饰器本质上是闭包的一种应用；\n 下面程序中`bar()`函数就是一个闭包\n```python\n'''\n闭包：p168\n'''\ndef foo():\n    a = 3\n    def bar(): #本质上a和bar()互不统属，所以a 相对于bar()是自由变量，但是在bar()中却可以使用a变量；\n        return a\n    return bar\n\nf = foo()\nprint(f())\n\n```\n程序运行结果： `a = 3`\n\n\n\n## 3.4特殊函数\n\n### 3.4.1 lambda函数\n**使用方法：**\n- 在lanbda后面直接跟变量；\n- 变量后面是冒号；\n- 冒号后面是表达式，表达式的计算结果就是本函数的返回值\n\n==lambda函数不能包含命令，包含的表达式不能超过一个==\n**示例：**\n```python\n'''\nlambda的使用：p171\n'''\nlam = lambda x,y :x + y\nbuf = []\nfor i in range(10):\n    buf.append(lam(i,i+1))\n\nprint(buf)\n```\n程序运行结果：\n`[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]`\n\n\n### 3.4.2 map函数\n函数形式：`map(func,seq)` ,依次将序列对象seq中的每一个元素，按照从左到右的顺序，依次取出来放在func函数中；==func的返回值依次存在一个列表中==\n```python\n'''\nmap使用\n'''\nnumbers1 = [1,2,3,4,5,6,7,8,9]\nnumbers2 = [1,2,3,4,5,6,7,8,9]\nnumbers3 = [1,2]\n\na =list(map(lambda x,y: x+y ,numbers1,numbers2))\nb =list(map(lambda x,y: x+y ,numbers1,numbers3))\nprint(a)\nprint(b)\n\n```\n程序运行结果：\n`[2, 4, 6, 8, 10, 12, 14, 16, 18]`\n`[2, 4]`\n\n**说明：**\n- map相当于对可迭代对象中的每个元素依次使用function方法，就相当于for循环\n- 将所有的结果返回一个map对象，这个对象是迭代器；\n- 如果参数很多，则参数是并行执行function函数，运行速度相应的就提升了；\n\n\n### 3.4.3 reduce函数\n```python\n'''\nreduce p173\n'''\nfrom functools import reduce\na = reduce(lambda x,y:x+y,[1,2,3,4,5])\nprint(a)\n\n```\n程序运行结果：`15`\n**map()函数是上下运算，而reduce()函数是横着逐个元素进行运算**\n\n\n### 3.4.4 filter函数\n```python\n\"\"\" \n filter练习 p174 \nfilter(function, iterable)# 判别函数  可迭代函数 \nfilter() 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象， 如果要转换为列表，可以使用 list() 来转换。   \n该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判， 然后返回 True 或 False，最后将返回 True 的元素放到新列表中 \n\"\"\" \nnums = range(-5,5)\nprint(list(filter(lambda x: x>0,nums)))\n#以上相当于：\n[x for x in nums if x>0]\n```\n程序运行结果：`[1, 2, 3, 4]`\n\n\n\n### 3.4.5 zip()函数\n- 是内建函数，但是参数是可迭代对象，返回值为zip对象，可以使用list()进行查看内容\n具体事例见：p175，这里没有认真看\n\n\n\n\n\n\n\n## 3.5 命名空间\n\n### 3.5.1全局变量和局部变量\n```python\n'''\n3.5.1全局变量和局部变量;p176\n'''\nx = 10\ndef funs():\n    global x  # 作用：将x声明称为全局变量，这样in的输出值也为22，同时out输出值为22\n    x = 22\n    print(\"in : \",x)\n\nfuns()\nprint(\"out : \",x)\n```\n程序运行结果：\n`in :  22`\n`out :  22`\n\n\n### 3.5.2 作用域\n- python属于动态语言，但是作用域属于静态作用域：python中变量的作用域是由它在程序中的位置决定\n- 作用域分类：\n  - local：局部作用域或称本地作用域\n  - Enclosing:嵌套作用域\n  - Global:全局作用域\n  - Built-in:内建作用域\n\n\n\n### 3.5.3 命名空间\n- 定义：命名空间表示标识符的可见范围，同一个标识符可以在多个命名空间中定义，但是不同命名空间中的定义是互不相干的。\n- 命名空间是对作用域的特殊抽象，包含了处于该作用域内的标识符，且本身也为一种标识符。\n- 分类：\n  - 本地命名空间：每个模块中的类和函数，他们定义的命名空间即为本地命名空间，当函数返回结果或者抛出异常则本地命名空间结束。\n  - 全局命名空间：每个模块创建的自己的命名空间，各个模块间命名空间相互独立\n  - 内置命名空间：python运行起来就存在了，内置函数的命名空间均属于内置命名空间 \n\n- 访问本地命名空间：locals()\n- 访问全局命名空间：globals()\n\n\n\n\n## 第三章示例代码\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n#@Time :2018/11/15 14:49\n#Author:GJXAIOU\n\n\n'''\n定义函数   P147\n'''\n\n\n# def add_function(a,b):  #定义一个函数使用 ：  def   函数名（参数）:    其中：表示函数头的结束\n#     # 函数名的命名；小写字母或者单下划线或者数字\n#     #这里x,y作为形参，也可以认为是变量，而变量无类型，所以并没有规定其所引用的对象的类型，意义取决于对象的类型，称为多态\n#     c = a + b   # 函数体必须缩进4个空格\n#     return c  #return语句执行的时候，python会跳出当前的函数并且返回到调用这个函数的地方\n#\n#\n# if __name__ == \"__main__\":\n#     result = add_function(2,3)  #调用函数并且将实参传递给函数\n#     print(result)\n#\n#\n# # 下面为函数的其他使用方法\n#\n# # 只写函数名会得到该函数在内存中的存储信息\n# print(add_function)\n#\n# # 赋值语句可以实现变量和函数对象建立应用关系，\n# c= add_function\n# result1 = c(3,4)\n# print(result1)\n\n\n\n\n\n # '''\n # 调用函数 P151\n # '''\n# def add(x,y):\n#     print(\"x = {}\".format(x))\n#     print(\"y = {}\".format(y))\n#     return x +y\n#\n# #参数赋值方法一：\n# ans1 = add(2,3) #这里传递参数默认按照次序依次赋值\n# print(\"ans = \",ans1)\n#\n# #参数赋值方法二：\n#\n# ans2 = add(y = 4,x = 5) #直接使用变量= 变量值进行赋值，这就不用理会什么顺序\n# print(ans2)\n\n#\n# '''\n# 当定义函数的时候进行部分参数赋值 P151\n# '''\n#\n#  #def acfun(x = 1,y,z = 4 ): 这种定义方法是错误的，因为有默认值的参数必须都在没有默认值参数后面\n# def acfun(x,y,z= 1):\n#     acans = x +y +z\n#     return acans\n#\n# ans1 = acfun(1,2) #可以不给z赋值，则使用默认值\n# ans2 = acfun(2,3,2)#如果赋值，则使用这个值\n# print(\"ans1 = \",ans1)\n# print(\"ans2 = \",ans2)\n#\n#\n\n\n\n\n\n# '''\n#\n# 实现Fibonacci数列：P153\n# '''\n#\n#\n# # 此函数只有一个返回值（一个列表）\n#\n# def fib(n):\n#     result = [0,1]  # 以列表形式返回\n#     for i in range(n-2):\n#         result.append(result[-2] + result[-1])\n#     return result\n#\n# if __name__ == \"__main__\":\n#     haha = fib(10)\n#     print(haha)\n#\n#\n# # 但函数的返回值有多个时候，返回值类型为元组\n#\n# def bilibili():\n#     return 1,2,3\n#\n# ##接受返回值的方法一；\n# ans = bilibili()\n# print(\"ans = \" ,ans)\n#\n# ##接受函数返回值的方法二：\n# x,y,z = bilibili()\n# print(x,y,z)\n#\n#\n# # 如果函数没有return，则返回值为None\n\n\n\n\n\n#\n# '''\n#   验证return的作用：p155\n#   '''\n# def dilidili():\n#\n#     print(\"hello\")\n#     return\n#     print(\"world\")\n#\n# ans = dilidili()\n# print(ans)\n#\n\n#\n# '''\n# 函数文档注释；p156\n# '''\n#\n# def eilieili():\n#     \"\"\"\n#     this is a function,haha\n#\n#     \"\"\"\n#     print(\"lalala\")\n#\n# print(eilieili.__doc__)  # 参数含义：函数名.__doc__\n# #打印函数功能注释：首先注释必须在函数内部\n#\n#\n\n\n#\n# \"\"\"\n#\n# 函数的属性：P156\n# \"\"\"\n#\n# def filifili():\n#     print(\"hahha\")\n#\n# print(dir(filifili))\n#\n#\n\n#\n# \"\"\"\n# 参数与变量 ：p159\n# \"\"\"\n#\n# def giligili(lst):\n#     lst.append(0)\n#     return lst\n#\n# x = [1,2,3]\n# y = giligili(x)\n# print(y)\n#\n# #这里实现的是原地修改\n# print(id(x))\n# print(id(y))\n\n\n\n\n#\n# \"\"\"\n# 参数收集：p160\n# \"\"\"\n#\n# def foo(x,*arg):\n#     print(arg)\n#\n# foo(1,2,3,4,5,6,7)  #将第一个赋值给x之后，其余后面的所有的都以元组的形式赋值给*arg\n#\n# foo(1,3)  # 当只有3赋值给*arg时候，结果相当于元组中只有一个元素，这时候结果应该是：（3，），元组中单个元素后面要加上逗号\n#\n#\n# def foobar(x,y,z,*arg,**args):\n#     print(\"x = \",x,\"\\n y = \",y,\"\\n z = \",z,\"\\n *arg = \",arg,\"\\n **args = \",args)\n#\n# foobar(1,2,3,4,5,6,7,name = \"gaojixu\",age = 23)   #**args得到的值为字典类型，注意赋值方式\n\n\n#\n# \"\"\"\n# 函数递归：使用递归的方法实现Fibonacci数列值P163\n# \"\"\"\n#\n# def fib(n):\n#     \"\"\"\n#     This is a Fibonacci by Recursion\n#\n#     \"\"\"\n#     if n == 0:\n#         return 0\n#     elif n == 1:\n#         return 1\n#     else:\n#         return fib(n-1) +fib(n-2)\n#\n#\n# if __name__ == \"__main__\":\n#     f = fib(10)\n#     print(f)\n#\n#\n\n\n\n# \"\"\"\n# 传递函数：函数做参数 P164\n# \"\"\"\n#\n# def power_seq(func,seq):\n#     #因为pingfang也是一个函数名，可以这样理解：func = pingfang ,\n#     #后面一个参数seq 接受num_seq中的列表\n#     return [func(i) for i in seq]\n#     #因为func = pingfang ,所以func(i)，其实本质上为pingfang(i ),相当于在调用函数\n# \"\"\"\n# 上面的语句等价为：\n# def power_seq(func,seq):\n#     ans = []\n#     for i in seq:\n#         ans.append(func(i))\n#     return ans\n# \"\"\"\n#\n# def pingfang(x):\n#     return x **2\n#\n# if __name__ == \"__main__\":\n#     num_seq = [111,3.14,8,44]\n#     r = power_seq(pingfang,num_seq) #调用函数，传递参数\n#     print(num_seq)\n#     print(r)\n#\n\n\n\n\n\n# \"\"\"\n# 嵌套函数：P164\n# \"\"\"\n#\n# def foo():\n#     def bar():\n#         print(\"bar() is running\")\n#     #bar()  可以在这里进行调用执行\n#     print(\"foo() is running \")\n#\n# print(foo()) #调用执行foo()函数,注意这里并没有调用bar()函数，所以bar()函数不执行\n# #print(bar()) #在函数外部不能调用里面定义的函数，这能在函数内部调用\n\n\n\n\n\n\n# \"\"\"\n# 嵌套函数练习：P166\n# \"\"\"\n#\n# def weight(g):       #第二步：接受值：g = 10\n#     def cal_mg(m): #第七步，***\n#         return m*g\n#     return cal_mg   #第三步：返回cal_mg\n#\n# w = weight(10)       #第一步：传值，g= 10   #第四步：接受值，w = cal_mg\n# mg = w(10)           #第五步：w(10) 相当于：cal_mg(10),调用cal_mg函数\n# print(mg)\n\n\n\n\"\"\"\n# filter练习 p174\nfilter(function, iterable)# 判别函数  可迭代函数\nfilter() 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，\n如果要转换为列表，可以使用 list() 来转换。\n\n该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，\n然后返回 True 或 False，最后将返回 True 的元素放到新列表中\n\"\"\"\nnums = range(-5,5)\nprint(list(filter(lambda x: x>0,nums)))\n#以上相当于：\n[x for x in nums if x>0]\n\n\n\n'''\n3.5 命名空间：p 176\n'''\n\n\n'''\n3.5.1全局变量和局部变量;p176\n'''\nx = 10\ndef funs():\n    global x  # 作用：将x声明称为全局变量，这样in的输出值也为22，同时out输出值为22\n    x = 22\n    print(\"in : \",x)\n\nfuns()\nprint(\"out : \",x)\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],[39177,39177],[52380,52380]]],[1552743546467,["GJX@GJXAIOU",[[1,52281,"-------------------------------------------------"]],[52281,52281],[52330,52330]]],[1552743559844,["GJX@GJXAIOU",[[1,52450,"\n"]],[52332,52332],[52333,52333]]],[1552743560425,["GJX@GJXAIOU",[[1,52451,"\n"]],[52333,52333],[52334,52334]]],[1552743561017,["GJX@GJXAIOU",[[1,52452,"\n"]],[52334,52334],[52335,52335]]],[1552743561606,["GJX@GJXAIOU",[[1,52453,"\n"]],[52335,52335],[52336,52336]]],[1552743562141,["GJX@GJXAIOU",[[1,52454,"\n"]],[52336,52336],[52337,52337]]],[1552743562693,["GJX@GJXAIOU",[[1,52455,"\n"]],[52337,52337],[52338,52338]]],[1552743563332,["GJX@GJXAIOU",[[1,52456,"\n"]],[52338,52338],[52339,52339]]],[1552743563857,["GJX@GJXAIOU",[[1,52457,"\n"]],[52339,52339],[52340,52340]]],[1552743564699,["GJX@GJXAIOU",[[1,52458,"\n"]],[52340,52340],[52341,52341]]],[1552743576728,["GJX@GJXAIOU",[[1,52344,"---\ndate:2019-1-22\n---\n\n\n# 第4章 类\n\n==python中一切皆对象，包括字符串、函数、模块、类、、、、==\n\n## 4.1基本概念\n- 对象:包括状态、行为、和唯一的标识\n- 状态：包括类已有的属性（类中已经定义好的），和对象具有的当前属性值（一般为动态的）\n- 行为：表现为对象自身状态的改变和信息的传递\n- 标识：该对象区别于其他对象的属性，本质上为内存中所创建的对象的地址\n对象：应该具有：属性（状态：是什么）和方法（行为：能做什么），标识一般在内存中自动完成。\n\n\n## 4.2编写类\n\n### 4.2.1创建类\n\n- python3中所有的类均为object类的子类\n- 类的名称开头首字母大写\n```python\n\"\"\"\n4.2.1创建类\n\"\"\"\n\nclass Person:  #如果继承其他类：格式为：class Person（FatherClass）\n    def __init__(self,name):   # 这是构造函数（初始化函数），在使用类创建实例的时候，首先执行构造函数  #类中参数第一个参数必须为self,\n        self.name = name       #建立实例的一种属性，属性的名字为name，值为参数name 传递的值\n\n    def get_name(self):\n        return self.name\n\n    def color(self, color):\n        d = {}\n        d[self.name] = color\n        return d\n\n\nif __name__ ==\"__main__\":  #注意这里是两个_\n    girl = Person(\"zhangsan\")  #利用上面的类创建实例，因为类中有name 参数，需要进行传值，所以在创建实例的时候有值（传的是引用），self不需要传值\n    print(girl.name)\n    name = girl.get_name()# 调用类的方法\n    print(name)\n    her_color = girl.color(\"white\")\n    print(her_color)\n```\n注：girl就是一个实例（girl这个变量引用了Person（‘zhangsan’）实例对象），它有属性和方法\nself本质上就是实例对象本身\n\n## 4.3 属性和数据\n\n### 4.3.1 类属性\n```python\n'''\n4.3 类属性\n'''\nclass A:\n    x = 5\n    z = 8  # 可以直接在类中添加属性\nprint(A.x)\nA.y = 9   # 也可以在类的外部添加属性\nprint(dir(A)) #查看类的属性，里面包含x，y，z\n\ndel A.x  #这样可以删除类A中的X属性\n```\n- x为类中的一个变量也为属性\n- 几类特殊的属性的含义：\n  - A.__name__  :以字符串的形式返回类的名字\n  - A.__doc__: 显示类的文档\n  - A.__base__:类A的所有父类，默认没有其他继承就是显示object类\n  - A.__dict__:以字典的形式显示类的所有属性\n  - A.__module__:类所在的模块\n    - 例如：Person.__module__ 显示结果为__main__,即类Person的全称为：__main__.Person\n\n\n\n### 4.3.1 创建实例\n```python\nclass Person: \n   def __init__(self,name): #初始化函数第一个参数必须是self，其次不能含有return 语句，\n       self.name = name\nif __name__ ==\"__main__\": \n    zhangsan = Person() #创建一个实例zhangsan,本质是将变量zhangsan与实例对象Person（）建立引用关系\n```\n\n### 4.3.2 实例属性\n```python\nclass A:\n    x = 7\n    #x = 8  对类属性值的修改会影响实例的属性值\n    y = [1,2,3] #可变对象\nfoo = A()\nprint(foo.x)\nfoo.x = 8  #类中的属性尽量避免更改，但是实例中的属性可以随意更改\n#这里更改的本质的建立了一个新的属性，和之前的同名，访问时候覆盖掉了原来的属性，可以使用del foo.x可以得到原来的属性值\nprint(foo.x)\nprint(A.x)#类中属性的值不会因为实例属性值更改而改变,当且仅当类中变量引用的是不可变对象：例如字符串\n#当类中变量引用的是可变对象的时候，实例改变会影响类中属性的值，因为是原地修改\nfoo.y.append(4) #修改实例的值\nprint(A.y)#运行结果：类的值也改变了\n\nfoo.z = [1,2,3,4,5]\n#print(A.z)   通过实例增加的变量并不能在类中使用\n```\n\n## 4.4 方法\n\n### 4.4.1 绑定方法和非绑定方法\n- 绑定方法：使用实例调用的方法\n- 非绑定方法：使用类的名字调用的方法\n```python\n'''\n4.4.1 绑定与非绑定方法\n'''\n\nclass Foo:\n    def bar(self):\n        print(\"this is a normal method of class\")\n\n#实例化与引用\nf = Foo()\nf.bar()#当建立这个实例的时候，引用方法时候，python解释器会把实例作为第一个参数隐式的传递给该方法\n\n#实例显式传递方法\nFoo.bar(f)#实例化之后，self和实例f是相同的，一般在类里使用self,在类外部使用f这个实例。\n\n# 因为python一切皆对象，类Foo的方法bar()也是对象（函数对象）\nFoo.bar #该方法为非绑定方法\nf.bar   # 绑定方法\n```\n\n**描述器**\n- 含有：`__get__()`、`__set__()`、`__delete__()`这些方法的对象称为描述器\n- 描述器是属性、实例方法、静态方法、类方法和继承中使用的super的背后实现机制\n- p198见详述\n\n\n### 4.4.2 类方法和静态方法\n- **classmethod**\n```python\n'''\n4.4.2 类方法和静态方法\n'''\n\n#!/usr/bin/env python\n#coding:utf-8\n\nclass Foo:\n    lang = \"Java\" # 类属性\n    def __init__(self):\n        self.lang = \"python\"#方法属性\n\n    @classmethod #装饰器，修饰的方法中的参数第一个不使用self，一般使用cls\n    # 使用类和实例执行get_class_attr,得到的都是类属性值，装饰器修饰的方法，参数所引用的对象是类对象Foo。\n    def get_class_attr(cls):#这里参数为cls，要求所引用的对象应该具有属性lang。\n        return cls.lang\n\n\nif __name__ == \"__main__\":\n    print(\"Foo.lang:\",Foo.lang)\n    r = Foo.get_class_attr()\n    print(\"get class attribute:\",r)\n    f = Foo()\n    print(\"instance attribute:\",f.lang)\n    print(\"instance get_class_attr\",f.get_class_attr())\n```\n**类方法：** 就是类里面定义的方法，该方法由装饰器@classmethod 所装饰，第一个参数cls所引用的是这个类对象，即将类对象作为引用对象传入到该方法中。\n\n\n- **staticmethod**\n```python\n\n'''\n4.4.2 类方法和静态方法\n'''\n\n#!/usr/bin/env python\n#coding:utf-8\nimport random\nclass Foo:\n    def __init__(self,name):\n        self.name = name\n\n    def get_name(self,age):\n        if self.select(age):\n            return self.name\n        else:\n            return  \"the name is secret\"\n\n    @staticmethod #是该方法位于类内但是独立于类，这个方法称为：静态方法\n    def select(n):#虽然在类内但是是独立的方法，跟类没有关系，就是类的作用域内的普通函数\n        a = random.randint(1,100)\n        return a - n > 0\n    #该函数不以self开头\n    #可以通过实例调用，比如self.select(n);\n    #可以通过类调用这个方法，比如 Foo.select(n)\nif __name__ == \"__main__\":\n    f = Foo(\"zhangsan\")\n    name = f.get_name(22)\n    print(name)\n```\n\n\n\n## 4.5 继承\n继承使子类具有父类的方法和属性\n继承最主要的用途是实现多态\n\n### 4.5.2 单继承\n```python\n### 4.5.1 单继承\n\n#!/usr/bin/env python\n#coding:utf-8\nimport random\nclass Person:\n    def __init__(self,name): #建立实例的时候这个初始化函数就要执行\n        self.name = name\n        print(\"This is father\")\n\n    def height(self,m):\n        h = dict(([\"height\",m],))\n        return h\n\nclass Boy(Person): #继承Person \n    def __init__(self, name): #当子类和父类中的函数重名就会函数重写，以子类中的为准  # 如果子类中没有初始化函数，在实例化的时候就会继承父类中的初始化函数并且执行；\n        self.name = name\n        print(\"This is son\")\n    ```直接让子类包含父类的所有属性```\n    #super().__init__(self,name)\n\n    def get_name(self):\n        return self.name\n\nif __name__ == \"__main__\":\n    boy = Boy(\"zhangsan\")\n    print(boy.get_name())\n    print(boy.height(180))\n    print(Boy.__bases__) #得到Boy这个子类的所有父类\n\n```\n\n程序运行结果：\n`This is son`\n`zhangsan`\n`{'height': 180}`\n`(<class '__main__.Person'>,)`\n\n### 4.5.3 调用覆盖的方法\n\n- 如果子类重写了父类的方法，现在子类中调用父类的方法\n```python\n# 4.5.3 调用覆盖的方法 # 使父类中被覆盖的方法再次在子类中实现\n\n#!/usr/bin/env python\n#coding:utf-8\nimport random\nclass Person:\n    def __init__(self,name):\n        self.name = name\n        print(\"This is father\")\n\n    def height(self,m):\n        h = dict(([\"height\",m],))\n        return h\n    #返回一个字典\n    def hello(self, a, b)\n        C = {\"A\":a, \"B\":b}\n        return C\n\nclass Boy(Person):\n    def __init__(self, name):\n        # Person.__init__(self, name) #方案一：但是一旦父类名称修改，这这里也要修改\n        super(boy, self).__init__(name)  #方案二：使用super    详细使用方法：https://www.cnblogs.com/silencestorm/p/8404046.html\n        self.real_name = \"lisi\"\n        print(\"This is son\")\n\n    def get_name(self):\n        return self.name\n\nif __name__ == \"__main__\":\n    boy = Boy(\"zhangsan\")\n    print(boy.real_name )\n    print(boy.get_name())\n    print(boy.height(180))\n    print(Boy.__bases__) #得到Boy这个子类的所有父类\n```\n程序运行结果：\n`This is father`\n`This is son`\n`lisi`\n`zhangsan`\n`{'height': 180}`\n`(<class '__main__.Person'>,)`\n\n- 多继承的继承顺序\n```python\n## 多重继承的继承顺序\n# 广度优先\n\n#!usr/bin/env python\n# coding=utf-8\n\nclass A:\n    def Ha(self):\n        print(\"This is A ha\")\n\nclass B:\n    def Ha(self):\n        print(\"This is B ha\")\n    def La(self):\n        print(\"This is B la\")\n\nclass AB1(A, B):\n    pass\nclass AB2(A, B):\n    def La(self):\n        print(\"This is AB2 la\")\n\nclass AB(AB1, AB2):\n    pass\n\nif __name__ == \"__main__\":\n    print(AB.__mro__) # __mro__ 可以打印出类的继承顺序\n    ab = AB()\n    ab.Ha()\n    ab.La()\n```\n程序运行结果：\n`(<class '__main__.AB'>, <class '__main__.AB1'>, <class '__main__.AB2'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)`\n`This is A ha`\n`This is AB2 la`\n\n\n\n\n\n\n\n\n## 4.6 多态与封装\n\n### 4.6.1 多态\n```python\n### 4.6.1 多态：同一方法传入不同参数结果不同 /对象多种表现形式的体现\n\n# count :数一数某个元素在对象中出现的次数\nprint(\"This is a book\".count(\"s\" ))\nprint([1,2,3,4,2,3,2].count(2))\n\nf = lambda x,y: x+y\nprint(f(2,3))\nprint(f(\"hello\",\"world\"))\nprint(f([\"a\",\"b\"],[\"c\",\"d\"]))\n\n# python 不检查传入对象的类型，这种方式称为：“隐式类型”、“结构式类型”、\"鸭子类型”\n# 鸭子类型：动态类型的一种风格，该风格中一个对象有效的语义，不是由继承自特定的类或者特定的接口决定的，而是有当前方法和属性的集合决定\n```\n程序运行结果：\n`2`\n`3`\n`5`\n`helloworld`\n`['a', 'b', 'c', 'd']`\n\n\n\n### 4.6.2 封装和私有化\n- 私有化：将类或者函数中的方法或者属性限定在某个区域之内，外部无法调用 \n- 私有化方法：在需要私有的数据或者方法属性前面加上__\n```python\n### 4.6.2 封装和私有化\n\n#!usr/bin/env python\n# coding=utf-8\n\nclass ProtectMe:\n    def __init__(self):\n        self.me = \"zhangsan\"\n        self.__name = \"lisi\"\n    def __Python(self):\n        print(\"I Love Python\")\n    def code(self):\n        print(\"Which Language do you like\")\n        self.__Python()\n\nif __name__ == \"__main__\":\n    protect = ProtectMe()\n    print(protect.me) #这里可以 使用\n    protect.code() #因为code()方法和__Python（）均在同一个类中，因此可以调用\n    print(protect.__name) # 私有属性类外不能调用\n    protect.__python()\n```\n程序运行结果：\n`zhangsan`\n`Which Language do you like`\n`I Love Python`\n`Traceback (most recent call last):File \"E:/Program/Python/Study/my/program/daydayup/Code_of_laoqi_python/char4.py\", line 343, in <module>`\n    `print(protect.__name) # 私有属性类外不能调用`\n`AttributeError: 'ProtectMe' object has no attribute '__name'`\n\n- 使用装饰器调用私有化的属性与方法\n```python\n# 使用装饰器调用类的私有属性\n\n#!usr/bin/env python\n# coding=utf-8\n\nclass ProtectMe:\n    def __init__(self):\n        self.me = \"zhangsan\"\n        self.__name = \"lisi\"\n\n    @property        # 装饰器：主要用于为已存在的对象添加功能\n    def code(self):\n        return self.__name\n\nif __name__ == \"__main__\":\n    protect = ProtectMe()\n    print(protect.code)\n```\n程序运行结果为：\n`lisi`\n\n\n\n\n\n\n\n## 4.7 定制类\n\n 类是对象，也是对象类型\n### 4.7.1 类和对象类型\n```python\n## 4.7 定制类（定制对象类型）\n\nclass A:pass\nclass B:pass\na = A()\nb = B()\nprint(type(a)) #返回对象a的对象类型，使用type()可以得到实例或者变量所引用对象的类型\nprint(type(b))\nprint(isinstance(a, A))  #也可以使用isinstance判断一个对象是不是另一个给定类的实例\nm = 1\nprint(isinstance(m, int)) #得出：m所引用的对象是整数型\n```\n程序运行结果：\n`<class '__main__.A'>`\n`<class '__main__.B'>`\n`True`\n`True`\n\n### 4.7.1 自定义对象类型\n```python\n##示例一：得到仅保留小数点后两位小数的数\n#!usr/bin/env python\n# coding=utf-8\n\nclass RoundFloat:\n    #定义一种两位小数的浮点数类型，利用该类可以得到两位小数的浮点数\n    def __init__(self, val):\n        assert isinstance(val, float), \"value must be a float\"  #assert的作用相当于布尔运算，当运行到这里，进行对象值的判断，如果为false，则抛出后面的异常提示\n        self.value = round(val, 2)\n\n    def __str__(self): #为能够得到打印的内容\n        return \"{:.2f}\".format(self.value) #将前面四舍五入保留两位小数的浮点数，以小数点后有两位小数的形式输出\n\n    __repr__ = __str__#在类被调用即向变量提供__str__()里的内容\n\nif __name__ ==\"__main__\":\n    r = RoundFloat(2.185)\n    print(r)\n    print(type(r))\n```\n程序运行结果：\n`2.19`\n`<class '__main__.RoundFloat'>`\n\n\n- 示例二：输入分子分母得到分数\n```python\n#!usr/bin/env python\n# coding = utf-8\n\nclass Fraction:\n    def __init__(self, number, denom = 1):\n        self.number = number\n        self.denom = denom\n\n    def __str__(self):\n        return str(self.number) + '/' +str(self.denom)\n\n    __repr__ = __str__\n\nif __name__ == \"__main__\":\n    f = Fraction(2, 3)\n    print(f)\n\n```\n程序运行结果：`2/3`\n\n- 示例三： 实现分数计算 1/2 + 1/3 = 5/6\n```python\n\n#收下按照最小公倍数通分，然后分子相加\n#最小公倍数lcm(a, b) = 丨a*b丨 /gcd(a,b)   注：丨因为注释所以有点斜 ，gcd(a,b)表示两个数的最大公约数\n\n #！usr/bin/env python\n # coding = utf-8\n\ndef gcd(a, b):\n     #求最大公约数\n    if not a > b:\n        a, b = b, a\n    while b != 0:\n        remainder = a % b\n        a, b = b, remainder\n    return  a\n\ndef lcm(a, b):\n     #求最小公倍数\n    return (a * b) / gcd(a, b)\n\nclass Fraction:\n    def __init__(self, number, denom = 1):\n        self.number = number\n        self.denom = denom\n\n    def __str__(self):\n        return str(self.number) + '/' +str(self.denom)\n\n    __repr__ = __str__\n\n    def __add__(self, other): #这个类中规定了加减乘除等运算等特殊方法\n        lcm_num = lcm(self.denom, other.denom)\n        number_sum = (lcm_num / self.denom * self.number) + (lcm_num / other.denom * other.number)\n        return Fraction(number_sum, lcm_num)\n\n\nif __name__ == \"__main__\":\n    m = Fraction(1, 3)\n    n = Fraction(1, 2)\n    s = m + n\n    print(m,\"+\",n ,\" = \",s)\n```\n程序运行结果：\n`1/3 + 1/2  =  5.0/6.0`\n\n- 在python中实现某种运算所使用的运算符本质上是以特殊方法实现的，其对应关系为:P218\n  - 例如加法对应的特殊方法为：`__add__`或者`__radd__`,两个对象能否相加，取决于两对象是否含有`__add__`方法\n\n\n\n\n\n## 4.8 一些特殊点\n\n### 4.8.1 优化内存\n```python\nclass Spring:\n    time = \"From march to June\"\n\nprint(Spring.__dict__) #每个类都有一个__dict__属性，包含了当前类的属性值\n\nyear = Spring()  #建立一个实例\nprint(year.__dict__)   # 实例也有这个属性，只是刚建立的时候为空\n\n#为了控制__dict__属性，使用__slots__属性替代__dict__属性\n\nclass Summer:\n    __slots__ = (\"tree\",\"flower\")\n\nprint(dir(Summer))  # 结果没有__dict__属性\n\nprint(Summer.__slots__)  #此时Summer仅有两个属性\ns1 = Summer()\ns2 = Summer()\nprint(s1.__slots__) # 实例也仅有两个属性\nprint(s2.__slots__)\nprint(id(s1.__slots__) == id(s2.__slots__)) #两个实例的__slots__在内存中占同一个位置\n\n\n# 使用__slots__优化了内存，同时实例不能增加属性，只能通过类属性进行增加\n```\n程序运行结果：\n`{'__module__': '__main__', 'time': 'From march to June', '__dict__': <attribute '__dict__' of 'Spring' objects>, '__weakref__': <attribute '__weakref__' of 'Spring' objects>, '__doc__': None}`\n`{}`\n`['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__slots__', '__str__', '__subclasshook__', 'flower', 'tree']`\n`('tree', 'flower')`\n`('tree', 'flower')`\n`('tree', 'flower')`\n`True`\n\n\n\n### 4.8.2 属性拦截 \n\n- 当访问类或者实例的属性时候，若不存在，就会调用某一类方法\n\n|方法|使用方式|\n| ---- | ---- |\n|`__setattr__(self,name,value)`|如果要给name赋值，则调用|\n|`__getattr__(self,name)`| 如果name被访问，但同时它不存在，则调用|\n|`__getattribute__(self,name)`|无论name是否存在，只要name被访问时候就会自动被调用|\n|`__delattr__(self,name)`| 如果要删除name,则调用|\n\n```python\nclass A:\n    def __getattr__(self, name):\n        print(\"You use getatter\")\n\n    def __setattr__(self, name, value):\n        print(\"You use setattr\")\n        self.__dict__[name] = value  # 将数据和属性保存到对象的__dict__中\n\n\na = A()   # 实例化\na.x  #实例不存在这个属性，但是因为有__getattr__方法，当属性X不在对象的__dict__ 中时候，就调用__getattr__ 方法\na.one = 7  # 给对象的属性赋值，调用__setattr__\nprint(a.one)  # 已经将属性保存到对象的__dict__ 中\n\n\nclass B:\n    def __getattribute__(self, name):\n        print(\"You use getattribute\")\n        return object.__getattribute__(self, name) #这里不能使用self.__dict__[name] = value ，因为这样就得访问属性self.__dict__,相当于死循环\n\nb = B()\nb.y  #虽然不存在，但是仍然执行 __getattribute__方法\nb.two = 7\nprint(b.two) #赋值之后就会被加入__dict__中\n```\n程序运行结果：\n`You use getatter`\n`You use setattr`\n`7`\n`You use getattribute`\n`Traceback (most recent call last):`\n `File \"E:/Program/Python/Study/my/program/daydayup/Code_of_laoqi_python/char4.py\", line 521, in <module>`\n  `b.y  #虽然不存在，但是仍然执行 __getattribute__方法`\n  `File \"E:/Program/Python/Study/my/program/daydayup/Code_of_laoqi_python/char4.py\", line 518, in __getattribute__ `\n  `return object.__getattribute__(self, name) #这里不能使用self.__dict__[name] = value` ，\n `因为这样就得访问属性self.__dict__,相当于死循环,AttributeError: 'B' object has no attribute 'y'`\n\n\n   \n\n\n\n"]],[52344,52344],[65878,65878]]],[1552743609157,["GJX@GJXAIOU",[[1,65891,"---------------------------------------------"]],[65891,65891],[65936,65936]]],[1552743620290,["GJX@GJXAIOU",[[1,65944,"# 第5章 错误与异常\n\n## 5.1 错误\n - 语法错误：Syntax Error\n - 当python检测到错误则无法执行，从而抛出提示信息，即为异常\n\n## 5.2 异常\n\n- 常见异常以及描述\n\n|异常|描述|\n|---|---|\n|NameError   |尝试访问一个没有声明的变量（虽然不需要声明，但是变量必须先赋值才能使用）|\n|ZeroDivisionError|除数为0|\n|SyntaxError|语法错误|\n|IndexError|索引超出序列范围；例如：a = [1, 2, 3]   a[4]|\n|KeyError|请求一个不存在的字典关键字|\n|IOError|输入/输出错误（例如文件不存在,或者文件路径不正确）|\n|AttributeError|尝试访问未知的对象类型|   \n\n## 5.3 处理异常\n\n\n### 5.3.1 使用try....except...\n\n```python\nwhile 1:\n    print(\"This is a program\")\n    c = input(\"input 'c' continue,otherwise logout:\")\n    if c == \"c\":\n        a = input(\"first number:\")\n        b = input(\"second number:\")\n        try:\n            print(float(a)/float(b))\n            print(\"*************\")\n        except ZeroDivisionError: #当try中没有异常则此部分不执行，如果try子句中有异常，则执行except后面指定的异常类型及其子句\n            # 如果except后面没有任何异常类型，则无论try发生什么异常均执行except\n            print(\"the second number can not be zero\")\n            print(\"*************\")\n        except ValueError: # 可以通过怎么except，可以处理多个异常\n            print(\"please input number.\")\n            print(\"*************\")\n\n        #以上两个except可以合成一个\n        except (ZeroDivisionError, ValueError):\n            print(\"please input rightly\")\n            print(\"**************\")\n\n        # 使用系统默认的异常提示，打印出来但是程序不中断\n        except (ZeroDivisionError, ValueError) as e:\n            print(e)\n            print(\"**************\")\n        else:# 如果执行了try ，则except不执行，但是执行else\n            print(\"hello\")\n        finally: # 不管前面执行try 还是except，都要执行finally\n            del e\n    else:\n        break\n\n```\n此程序需在终端中执行\n\n\n### 5.3.2 assert使用\n\n```python\n# assert 用于判定断言，等价于布尔运算\n#默认值为真，当发生异常则值为假\n\nclass Accout(object):\n    def __init__(self,number):\n        self.number = number\n        self.balance = 0\n\n    def deposit(self, amount):\n        try:\n            assert amount > 0\n            self.balance += amount\n        except:\n            print(\"The money should bigger than zero\")\n\n    def withdraw(self, amount):\n        assert amount > 0\n        if amount <= self.balance:\n            self.balance -= amount\n        else:\n            print(\"balance is not enough\")\n\nif __name__ == \"__main__\":\n    a = Accout(1000)\n    a.deposit(-10)\n```\n程序运行结果：\n`The money should bigger than zero`\n\n- assert通常使用情况\n  - 防御性的编程\n  - 运行时对程序逻辑的检测\n  - 合约性检查（例如前置条件、后置条件）\n  - 程序中的常量\n  - 检查文档"]],[65944,65944],[68210,68210]]],[1552743629645,["GJX@GJXAIOU",[[1,68218,"-----"]],[68218,68218],[68223,68223]]],[1552743644626,["GJX@GJXAIOU",[[1,68235,"# 第六章 模块\n\n\n- 模块是程序，拓展名：.py\n\n## 6.1 编写模块\n\n### 6.1.1 模块是程序\n\n1.编写一个python程序，例如：char6.py\n```python\n#!usr/bin/env python\n# coding = utf-8\n\nlang = \"python\"\n\n```\n2.将该程序的位置告诉python编译器\n```python\nimport sys\nsys.path.append(\"E:/Program/Python/Study/my/program/daydayup/Code_of_laoqi_python/char6.py\")  # 不同系统文件目录形式不同\n```\n3.在其他程序中使用：\n```python\nimport char6  # 作为模块引入的时候不带文件拓展名\nchar6.lang    #  采用模块名.属性或类、方法名称\n```\n程序运行结果：\n`\"python\"`\n\n注：此时在存储char6.py目录下多一个：`__pycache__`目录，目录中的`char6.cpython-37.pyc`即为刚才`char6.py`文件编译后的文件\n\n- 如何区分是作为程序执行还是作为模块引入\n1.新建：pm.py\n```python\n#!usr/bin/env python\n#coding = utf-8\n\ndef lang():\n  return \"python\"\n\nif __name__ == \"__main__\"\nprint(lang())\n```\n如果作为程序执行：`__name__ == “__main__”`\n如果作为模块引入：`pm.__name__ == “pm”` 属性`__name__`值为模块名称\n一般如果仅仅用于模块引入，则不必写：`if __name__ == \"__main__\"`\n\n\n### 6.1.2 模块的位置\n\n查看所有模块的位置\n```python\nimport sys\nimport pprint\npprint.pprint(sys.path)\n```\n程序运行结果：\n`['E:\\\\Program\\\\Python\\\\Study\\\\my\\\\program\\\\daydayup\\\\Code_of_laoqi_python',`\n `'E:\\\\Program\\\\Python\\\\Study\\\\my\\\\program\\\\daydayup',`\n `'E:\\\\Program\\\\Python\\\\Python3.7.1\\\\python37.zip',`\n `'E:\\\\Program\\\\Python\\\\Python3.7.1\\\\DLLs',`\n `'E:\\\\Program\\\\Python\\\\Python3.7.1\\\\lib',`\n `'E:\\\\Program\\\\Python\\\\Python3.7.1',`\n `'E:\\\\Program\\\\Python\\\\Python3.7.1\\\\lib\\\\site-packages',`\n `'E:\\\\Program\\\\Python\\\\PycharmPro\\\\PyCharm '`\n `'2018.2.4\\\\helpers\\\\pycharm_matplotlib_backend']`\n\n\n### 6.1.3 `__all__`在模块中的作用\n\n- 一般情况下：不加`__all__`模块\n1.新建文件mokuai_pp.py\n```python\n#!usr/bin/env python\n#coding = utf-8\n\npublic_var = \"public var\"\n_private_var = \"private var\" #以单下划线开头的表示私有变量\ndef public_class():\n    print(\"This is a public class\")\n    \ndef _private_class():\n    print(\"This is a private class\")\n    \n```\n\n2.在char6.py中引用该模块：\n```python\nimport sys\nsys.path.append(\"E:\\Program\\Python\\Study\\my\\program\\daydayup\\mokuai_pp.py\")\nimport mokuai_pp\nfrom mokuai_pp import  *   #含义：希望能够访问模块mokuai_pp中有权限访问的全部名称，私有的变量、函数、类没有访问权限\nprint(public_var)\nprint(_private_var)  # 报错，私有变量不能访问\n```\n程序运行结果：\n`public var`\n`Traceback (most recent call last):`\n `File\"E:/Program/Python/Study/my/program/daydayup/Code_of_laoqi_python/char6.py\", line 33, in <module>`\n    `print(_private_var)`\n`NameError: name '_private_var' is not defined`\n\n- 外部可以访问模块的私有属性\n```python\nimport sys\nsys.path.append(\"E:\\Program\\Python\\Study\\my\\program\\daydayup\\mokuai_pp.py\")\nimport mokuai_pp\nfrom mokuai_pp import  *  #此时该句可加可不加 \nprint(mokuai_pp.public_var)\nprint(mokuai_pp._private_var)\n```\n程序运行结果：\n`public var`\n`private var`\n\n\n- 模块中加入`__all__`之后\n\n模块mokuai_pp.py改为：\n```python\n# !usr/bin/env python\n# coding = utf-8\n\n__all__ = ['_private_var','public_class'] #表示：只有列表中这两个变量和方法可以被访问，其它一律不能访问\npublic_var = \"public var\"\n_private_var = \"private var\"\n\ndef public_class():\n    print(\"This is a public class\")\n\ndef _private_class():\n    print(\"This is a private class\")\n\n```\n\nchar6.py改为：\n```python\nimport sys\nsys.path.append(\"E:\\Program\\Python\\Study\\my\\program\\daydayup\\mokuai_pp.py\")\nimport mokuai_pp\nfrom mokuai_pp import *\nprint(_private_var)  #原来不能访问的可以访问了\nprint(public_var)    #原来可以访问的不能访问了 \n```\n程序运行结果：\n`private var`\n  `File \"E:/Program/Python/Study/my/program/daydayup/Code_of_laoqi_python/char6.py\", line 33, in <module>`\n   `print(public_var)`\n`NameError: name 'public_var' is not defined`\n\n\n\n### 6.1.4 包与库\n- 库找那个含有很多的包，每个包中含有若干的模块\n- 包相当于一个目录，要想引用包中某个模块，则需要在目录中放入：名为`__init__.py`的空文件，则该目录中其他.py文件就可以作为模块引用\n\n- 示例：\n  - 目录：`Code_of_laoqi_python`,里面含有`mokuai__pp.py`以及`mokuai_qq.py`,并建立一个空文件：`__init__.py`\n\n  - 引用方式：\n    - 方法一：\n```python\nimport Code_of_laoqi_python.mokuai_pp\nprint(Code_of_laoqi_python.mokuai_pp._private_var)\n```\n    - 方法二：\n```python\nfrom Code_of_laoqi_python import mokuai_pp\nprint(mokuai_pp._private_var)\n```\n程序运行结果为：\n`private var`\n\n\n## 6.2 标准库概述\n\n### 6.2.1 引用方式\n三种，如上\n```python\nimport pprint  # 导包\na = {\"lang\":\"jksdjf\"}\npprint.pprint() # 使用模块中的一种方法\n```\n\n```python\nfrom pprint import pprint   # 仅引入pprint模块中的pprint()\na = {\"lang\":\"jksdjf\"}\npprint(a)    # 这里可以直接使用\n```\n\n```python\nfrom pprint import * # 将模块中所有可用的全部引入\n```\n\n- 注：将引入的模块改名字\n```python\nimport pprint as pr\npr.pprint(a)\n\n#或者如下：\nfrom pprint import pprint as pr\npr(a)\n```\n\n\n### 6.2.3 帮助、文档与源码\n\n- 创建文档\n1.例如新建pm.py\n```python\n#!usr/bin/env python\n#coding = utf-8\n\n\"\"\"\nThis is a document of python   #帮助文档（在所有类、方法以及import之前）     \n\"\"\"\n\ndef lang():\n  pass\n```\n2.将该模块路径加入：\n```python\nimport sys\nsys.path.append(\".....路径\")\nimport pm\nprint(pm.__doc__)  #打印出模块的文档\n```\n\n- 查看模块的存储位置\n```python\nprint(pprint.__file__)\n```\n\n\n\n## 6.3 标准库举例\n### 6.3.1 sys\n部分属性和方法简介：\n\n- sys.argv  :专门先 python；解释器传递参数，即为命令行参数\n```python\n #6.3标准库举例\n#!usr/bin/env python\n#coding = utf-8\n\nimport sys\nprint(\"The file name: \", sys.argv[0]) #sys.argv[0]是第一个参数，为文件名\nprint(\"The number of argument\", len(sys.argv)) # 命令行输入的参数数目\nprint(\"The argument is: \",str(sys.argv)) # 命令行输入的参数名称\n```\n在命令行中输入：python char6.py\n程序运行结果为：\n`The file name:  char6.py`\n`The number of argument 1`\n`The argument is:  ['char6.py']`\n\n在命令行输入：python char6.py   GJXAIOU  haha\n程序运行结果为：\n`The file name:  char6.py`\n`The number of argument 3`\n`The argument is:  ['char6.py', 'GJXAIOU', 'haha']`\n\n\n- sys.exit()  :退出当前程序，但是返回SystemExit异常\n\n示例程序：\n```python\n#!usr/bin/env python\n#coding = utf-8\n\nimport sys\nfor i in range(10):\n    if i == 5:\n        sys.exit()\n        #sys.exit(0) # 表示正常退出\n        #sys.exit(\"hello\") #退出的时候打印里面的提示消息\n    else:\n        print(i)\n```\n程序运行结果：\n`0`\n`1`\n`2`\n`3`\n`4`\n\n**注：** return的作用是终止当前函数，并向调用函数的位置返回相应的值，如果没有就返回None。\n\n\n\n### 6.3.2 copy\n```python\nimport copy\nprint(copy.__all__)\n```\n得到：`['Error', 'copy', 'deepcopy']`\n\n- copy 和deepcopy 区别\n```python\n##copy 和deepcopy 区别\n\n#!usr/bin/env python\n#coding = utf-8\n\nimport copy\nclass MyCopy:\n    def __init__(self, value):\n        self.value = value\n\n    def __repr__(self):\n        return  str(self.value)\n\nfoo = MyCopy(7)\n\na = [\"foo\", foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\n\na.append(\"abc\")\nfoo.value = 17\n\nprint(\"original: {0}\\n  slice:  {1}\\n  list:  {2}\\n  copy():  {3}\\n  deepcopy():  {4}\\n\".format(a, b, c, d, e))\n```\n程序运行结果：\n`original: ['foo', 17, 'abc']`\n  `slice:  ['foo', 17]`\n  `list:  ['foo', 17]`\n  `copy():  ['foo', 17]`\n  `deepcopy():  ['foo', 7]`\n\n\n\n## 6.4 标准库举例：OS\n\n### 6.4.1 操作文件：重命名、删除文件\n- 将文件名为:`lala.py`修改为：`haha.py`\n在`lala.py`文件中加上：\n```python\nimport os\nos.rename(\"lala.py\",\"haha.py\")\n```\n然后进入命令行模式，进入文件`lala.py`的上一级目录下，执行`python lala.py`\n\n- 删除文件（不能删除目录）\n```python\nimport os\nos.remove(\"文件存放路径\")\n```\n\n### 6.4.2 操作目录\n- os.listdir :显示目录中的内容\n```python\nimport os\n\nfiles =os.listdir(\"E:/Program/Python/Study/my/program/daydayup/Code_of_laoqi_python\")         #显示该目录下的子目录或者文件，但是不显示隐藏的文件或者子目录，同时返回值为列表\nfor f in files:\n    print(f)\n```\n程序运行结果：\n`123.txt`\n`abc.txt`\n`char2.py`\n`char3.py`\n`char4.py`\n`char5.py`\n`char6.py`\n`f.txt`\n`lianxi.txt`\n`mokuai_pp.py`\n`__init__.py`\n`__pycache__`\n\n- 工作目录\n  - os.getcwd  :当前工作目录\n  - os.chdir     :改变当前工作目录\n```pythoh\nimport os\ncwd = os.getcwd()   # 当前目录\nos.chdir(os.pardir) # 进入上一级目录  #os.pardir 功能为：获得父级目录\nup = os.getcwd()\nos.chdir(\"Code_of_laoqi_python\") # 进入该目录的下一级目录\ndown = os.getcwd()\nprint(cwd)\nprint(up)\nprint(down)\n```\n程序运行结果：\n`E:\\Program\\Python\\Study\\my\\program\\daydayup\\Code_of_laoqi_python`\n`E:\\Program\\Python\\Study\\my\\program\\daydayup`\n`E:\\Program\\Python\\Study\\my\\program\\daydayup\\Code_of_laoqi_python`\n\n - 创建和删除目录\n```python\n## 创建和删除目录 p261\nimport os\ncwd = os.getcwd()   #这为当前目录\nprint(cwd)\nos.makedirs(\"lingshi\") #在此目录下新建一个子目录\nos.chdir(\"lingshi\") # 进入子目录中\ncwd1 = os.getcwd()\nprint(cwd1)\nfiles = os.listdir(os.getcwd()) #查看子目录下是否为空\nprint(files)\nnewdir = os.getcwd()\nprint(newdir)\nos.removedirs(newdir) #删除当前工作的空目录\n```\n程序有点问题：\n\n\n### 6.4.3 文件和目录属性\n\n```python\nimport os\np = os.getcwd()\ninfor = os.stat(p) #查看该目录信息\nprint(infor)\nmt = infor[8] #infor[8] 表示该文件最后修改的时间(第八个元素)\nprint(mt)\nimport  time\nprint(time.ctime(mt)) #将时间更好友好化\n\n```\n程序运行结果：\n`os.stat_result(st_mode=16895, st_ino=562949953662101, st_dev=1143006259, st_nlink=1, st_uid=0, st_gid=0, st_size=4096, st_atime=1550389612, st_mtime=1550389612, st_ctime=1542290649)`\n`1550389612`\n`Sun Feb 17 15:46:52 2019`\n\n\n\n## 6.5 标准库举例：堆\n- 是一种数据结构\n- 可以看成一棵树的数组对象\n- 通过构造二叉堆实现\n\n### 6.5.1 二叉树\n\n- 每个节点最多有两个子树的树结构：左子树   +   右子树\n- 并不是所有节点所有两个子节点的树：完全二叉树\n- 所有节点都有两个子节点的树：满二叉树\n- 节点的值大于等于（或者小于等于）任何子节点的值\n- 二叉堆使用二叉树实现的\n- 节点左子树和右子树是一个二叉堆，如果父节点的值总是大于等于任意一个子节点的值，则为最大堆；如果父节点的值总小于等于子节点的值，则其为最小堆。\n\n![堆转换成列表]($resource/%E5%A0%86%E8%BD%AC%E6%8D%A2%E6%88%90%E5%88%97%E8%A1%A8.png)\n\n\n学习至此：p266   2019-2-17"]],[68235,68235],[76533,76533]]],[1552744264365,["GJX@GJXAIOU",[[1,5820," ,··"]],[5820,5820],[5824,5824]]],[1552744267614,["GJX@GJXAIOU",[[-1,5822,"··"]],[5824,5824],[5822,5822]]],[1552744269204,["GJX@GJXAIOU",[[1,5822,"``"]],[5822,5822],[5824,5824]]],[1552744275215,["GJX@GJXAIOU",[[1,5823,"mui"]],[5823,5823],[5826,5826]]],[1552744276156,["GJX@GJXAIOU",[[-1,5825,"i"]],[5826,5826],[5825,5825]]],[1552744278653,["GJX@GJXAIOU",[[1,5825,"ean"]],[5825,5825],[5828,5828]]],[1552744295747,["GJX@GJXAIOU",[[-1,5824,"u"]],[5825,5825],[5824,5824]]],[1552744299627,["GJX@GJXAIOU",[[1,5827,"()"]],[5827,5827],[5829,5829]]],[1552744319993,["GJX@GJXAIOU",[[1,5830,"qiu"]],[5830,5830],[5833,5833]]],[1552744323554,["GJX@GJXAIOU",[[-1,5830,"qiu"]],[5833,5833],[5830,5830]]],[1552744327137,["GJX@GJXAIOU",[[1,5830,"求平均值"]],[5830,5830],[5834,5834]]]],null,"GJX@GJXAIOU"]]}