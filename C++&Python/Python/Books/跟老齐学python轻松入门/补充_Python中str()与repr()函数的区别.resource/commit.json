{"compress":true,"commitItems":[["81cf22bc-8d0a-4357-9167-bd6a02dbbcfc",1540983725651,"",[[1540983682229,["gjx16@GJXAIOU",[[1,0,"# 补充_\n\n\n\n"]],[0,0],[8,8]]],[1540983683731,["gjx16@GJXAIOU",[[1,8,"在 Python 中要将某一类型的变量或者常量转换为字符串对象通常有两种方法，即 `str()` 或者 `repr()` 。\n\n```\n>>> a = 10\n>>> type(str(a))\n<class 'str'>\n>>> type(repr(a))\n<class 'str'>\n\n```\n\n但是这二者之间有什么区别呢？因为提供两个功能完全相同的内建函数是没有意义的。先看一个例子。\n\n```\n>>> print(str('123'))       \n123                         \n>>> print(str(123))         \n123                         \n>>> print(repr('123'))      \n'123'                       \n>>> print(repr(123))        \n123                         \n\n```\n\n从例子中不难发现，当我们把一个字符串传给 `str()` 函数再打印到终端的时候，输出的字符不带引号。而将一个字符串传给 `repr()` 函数再打印到终端的时候，输出的字符带有引号。\n\n造成这两种输出形式不同的原因在于：\n\n*   `print` 语句结合 `str()` 函数实际上是调用了对象的 `__str__` 方法来输出结果。而 `print` 结合 `repr()` 实际上是调用对象的 `__repr__` 方法输出结果。下例中我们用 `str` 对象直接调用这两个方法，输出结果的形式与前一个例子保持一致。\n\n```\n>>> print('123'.__repr__())\n'123'\n>>> print('123'.__str__())\n123\n\n```\n\n不过这个例子可能还是无法很好表达到底 `str()` 与 `repr()` 各有什么意义，我们再来看一个例子。\n\n```\n>>> from datetime import datetime\n>>> now = datetime.now()\n>>> print(str(now))\n2017-04-22 15:41:33.012917\n>>> print(repr(now))\ndatetime.datetime(2017, 4, 22, 15, 41, 33, 12917)\n\n```\n\n通过 `str()` 的输出结果我们能很好地知道 `now` 实例的内容，但是却丢失了 `now` 实例的数据类型信息。而通过 `repr()` 的输出结果我们不仅能获得 `now` 实例的内容，还能知道 `now` 是 `datetime.datetime` 对象的实例。\n\n因此 `str()` 与 `repr()` 的不同在于：\n\n*   `str()` 的输出追求可读性，输出格式要便于理解，适合用于输出内容到用户终端。\n*   `repr()` 的输出追求明确性，除了对象内容，还需要展示出对象的数据类型信息，适合开发和调试阶段使用。\n\n另外如果想要自定义类的实例能够被 `str()` 和 `repr()` 所调用，那么就需要在自定义类中重载 `__str__` 和 `__repr__` 方法。\n\n作者：叶俊贤\n链接：https://www.jianshu.com/p/2a41315ca47e\n來源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。"]],[8,8],[1473,1473]]]],null,"gjx16@GJXAIOU"],["ebc89721-35bd-49e6-9ae4-f724d01ef6a6",1541426408611,"# 补充_\n\n\n在 Python 中要将某一类型的变量或者常量转换为字符串对象通常有两种方法，即 `str()` 或者 `repr()` 。\n\n```\n>>> a = 10\n>>> type(str(a))\n<class 'str'>\n>>> type(repr(a))\n<class 'str'>\n\n```\n\n但是这二者之间有什么区别呢？因为提供两个功能完全相同的内建函数是没有意义的。先看一个例子。\n\n```\n>>> print(str('123'))       \n123                         \n>>> print(str(123))         \n123                         \n>>> print(repr('123'))      \n'123'                       \n>>> print(repr(123))        \n123                         \n\n```\n\n从例子中不难发现，当我们把一个字符串传给 `str()` 函数再打印到终端的时候，输出的字符不带引号。而将一个字符串传给 `repr()` 函数再打印到终端的时候，输出的字符带有引号。\n\n造成这两种输出形式不同的原因在于：\n\n*   `print` 语句结合 `str()` 函数实际上是调用了对象的 `__str__` 方法来输出结果。而 `print` 结合 `repr()` 实际上是调用对象的 `__repr__` 方法输出结果。下例中我们用 `str` 对象直接调用这两个方法，输出结果的形式与前一个例子保持一致。\n\n```\n>>> print('123'.__repr__())\n'123'\n>>> print('123'.__str__())\n123\n\n```\n\n不过这个例子可能还是无法很好表达到底 `str()` 与 `repr()` 各有什么意义，我们再来看一个例子。\n\n```\n>>> from datetime import datetime\n>>> now = datetime.now()\n>>> print(str(now))\n2017-04-22 15:41:33.012917\n>>> print(repr(now))\ndatetime.datetime(2017, 4, 22, 15, 41, 33, 12917)\n\n```\n\n通过 `str()` 的输出结果我们能很好地知道 `now` 实例的内容，但是却丢失了 `now` 实例的数据类型信息。而通过 `repr()` 的输出结果我们不仅能获得 `now` 实例的内容，还能知道 `now` 是 `datetime.datetime` 对象的实例。\n\n因此 `str()` 与 `repr()` 的不同在于：\n\n*   `str()` 的输出追求可读性，输出格式要便于理解，适合用于输出内容到用户终端。\n*   `repr()` 的输出追求明确性，除了对象内容，还需要展示出对象的数据类型信息，适合开发和调试阶段使用。\n\n另外如果想要自定义类的实例能够被 `str()` 和 `repr()` 所调用，那么就需要在自定义类中重载 `__str__` 和 `__repr__` 方法。\n\n作者：叶俊贤\n链接：https://www.jianshu.com/p/2a41315ca47e\n來源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。\n",[[1541426364290,["gjx16@GJXAIOU",[[1,5,"Python中str()与repr()函数的区别"]],[2,5],[29,29]]]],null,"gjx16@GJXAIOU"],["95eb5b90-6ce7-4691-8130-51f17f7993df",1544755883996,"# 补充_Python中str()与repr()函数的区别\n\n\n在 Python 中要将某一类型的变量或者常量转换为字符串对象通常有两种方法，即 `str()` 或者 `repr()` 。\n\n```\n>>> a = 10\n>>> type(str(a))\n<class 'str'>\n>>> type(repr(a))\n<class 'str'>\n\n```\n\n但是这二者之间有什么区别呢？因为提供两个功能完全相同的内建函数是没有意义的。先看一个例子。\n\n```\n>>> print(str('123'))       \n123                         \n>>> print(str(123))         \n123                         \n>>> print(repr('123'))      \n'123'                       \n>>> print(repr(123))        \n123                         \n\n```\n\n从例子中不难发现，当我们把一个字符串传给 `str()` 函数再打印到终端的时候，输出的字符不带引号。而将一个字符串传给 `repr()` 函数再打印到终端的时候，输出的字符带有引号。\n\n造成这两种输出形式不同的原因在于：\n\n*   `print` 语句结合 `str()` 函数实际上是调用了对象的 `__str__` 方法来输出结果。而 `print` 结合 `repr()` 实际上是调用对象的 `__repr__` 方法输出结果。下例中我们用 `str` 对象直接调用这两个方法，输出结果的形式与前一个例子保持一致。\n\n```\n>>> print('123'.__repr__())\n'123'\n>>> print('123'.__str__())\n123\n\n```\n\n不过这个例子可能还是无法很好表达到底 `str()` 与 `repr()` 各有什么意义，我们再来看一个例子。\n\n```\n>>> from datetime import datetime\n>>> now = datetime.now()\n>>> print(str(now))\n2017-04-22 15:41:33.012917\n>>> print(repr(now))\ndatetime.datetime(2017, 4, 22, 15, 41, 33, 12917)\n\n```\n\n通过 `str()` 的输出结果我们能很好地知道 `now` 实例的内容，但是却丢失了 `now` 实例的数据类型信息。而通过 `repr()` 的输出结果我们不仅能获得 `now` 实例的内容，还能知道 `now` 是 `datetime.datetime` 对象的实例。\n\n因此 `str()` 与 `repr()` 的不同在于：\n\n*   `str()` 的输出追求可读性，输出格式要便于理解，适合用于输出内容到用户终端。\n*   `repr()` 的输出追求明确性，除了对象内容，还需要展示出对象的数据类型信息，适合开发和调试阶段使用。\n\n另外如果想要自定义类的实例能够被 `str()` 和 `repr()` 所调用，那么就需要在自定义类中重载 `__str__` 和 `__repr__` 方法。\n\n作者：叶俊贤\n链接：https://www.jianshu.com/p/2a41315ca47e\n來源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。\n",[[1544755877144,["gjx16@GJXAIOU",[[-1,1408,"作者：叶俊贤\n链接：https://www.jianshu.com/p/2a41315ca47e\n來源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。"]],[1408,1497],[1408,1408]]]],null,"gjx16@GJXAIOU"]]}