{"compress":true,"commitItems":[["6c9e9311-1688-4ab1-8bba-5ea8fb320626",1550296307867,"# [Python迭代器和生成器](https://www.cnblogs.com/wilber2013/p/4652531.html)\n\n在Python中，很多对象都是可以通过for语句来直接遍历的，例如list、string、dict等等，这些对象都可以被称为可迭代对象。至于说哪些对象是可以被迭代访问的，就要了解一下迭代器相关的知识了。\n\n## 迭代器\n\n迭代器对象要求支持迭代器协议的对象，在Python中，支持迭代器协议就是实现对象的__iter__()和next()方法。其中__iter__()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常。\n\n### __iter__()和next()方法\n\n这两个方法是迭代器最基本的方法，一个用来获得迭代器对象，一个用来获取容器中的下一个元素。\n\n对于可迭代对象，可以使用内建函数iter()来获取它的迭代器对象：\n\n![](https://images0.cnblogs.com/blog/593627/201507/162113386417660.png)\n\n例子中，通过iter()方法获得了list的迭代器对象，然后就可以通过next()方法来访问list中的元素了。当容器中没有可访问的元素后，next()方法将会抛出一个StopIteration异常终止迭代器。\n\n其实，当我们使用for语句的时候，for语句就会自动的通过__iter__()方法来获得迭代器对象，并且通过next()方法来获取下一个元素。\n\n### 自定义迭代器\n\n了解了迭代器协议之后，就可以自定义迭代器了。\n\n下面例子中实现了一个MyRange的类型，这个类型中实现了__iter__()方法，通过这个方法返回对象本身作为迭代器对象；同时，实现了next()方法用来获取容器中的下一个元素，当没有可访问元素后，就抛出StopIteration异常。\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0); \"复制代码\")\n\nclass MyRange(object): def __init__(self, n):\n        self.idx = 0\n        self.n = n def __iter__(self): return self def next(self): if self.idx < self.n:\n            val = self.idx\n            self.idx += 1\n            return val else: raise StopIteration()\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0); \"复制代码\")\n\n这个自定义类型跟内建函数xrange很类似，看一下运行结果：\n\nmyRange = MyRange(3) for i in myRange: print i   \n\n![](https://images0.cnblogs.com/blog/593627/201507/162113392048788.png)\n\n### 迭代器和可迭代对象\n\n在上面的例子中，myRange这个对象就是一个可迭代对象，同时它本身也是一个迭代器对象。\n\n看下面的代码，对于一个可迭代对象，如果它本身又是一个迭代器对象，就会有下面的 问题，就没有办法支持多次迭代。\n\n![](https://images0.cnblogs.com/blog/593627/201507/162113401265874.png)\n\n为了解决上面的问题，可以分别定义可迭代类型对象和迭代器类型对象；然后可迭代类型对象的__iter__()方法可以获得一个迭代器类型的对象。看下面的实现：\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0); \"复制代码\")\n\nclass Zrange: def __init__(self, n):\n        self.n = n def __iter__(self): return ZrangeIterator(self.n) class ZrangeIterator: def __init__(self, n):\n        self.i = 0\n        self.n = n def __iter__(self): return self def next(self): if self.i < self.n:\n            i = self.i\n            self.i += 1\n            return i else: raise StopIteration()    \n\nzrange = Zrange(3) print zrange is iter(zrange) print [i for i in zrange] print [i for i in zrange]\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0); \"复制代码\")\n\n代码的运行结果为：\n\n![](https://images0.cnblogs.com/blog/593627/201507/162113404074088.png)\n\n其实，通过下面代码可以看出，list类型也是按照上面的方式，list本身是一个可迭代对象，通过iter()方法可以获得list的迭代器对象：\n\n![](https://images0.cnblogs.com/blog/593627/201507/162113418456316.png)\n\n## 生成器\n\n在Python中，使用生成器可以很方便的支持迭代器协议。生成器通过生成器函数产生，生成器函数可以通过常规的def语句来定义，但是不用return返回，而是用yield一次返回一个结果，在每个结果之间挂起和继续它们的状态，来自动实现迭代协议。\n\n也就是说，yield是一个语法糖，内部实现支持了迭代器协议，同时yield内部是一个状态机，维护着挂起和继续的状态。\n\n下面看看生成器的使用：\n\n![](https://images0.cnblogs.com/blog/593627/201507/162113461573598.png)\n\n在这个例子中，定义了一个生成器函数，函数返回一个生成器对象，然后就可以通过for语句进行迭代访问了。\n\n其实，生成器函数返回生成器的迭代器。 \"生成器的迭代器\"这个术语通常被称作\"生成器\"。要注意的是生成器就是一类特殊的迭代器。作为一个迭代器，生成器必须要定义一些方法，其中一个就是next()。如同迭代器一样，我们可以使用next()函数来获取下一个值。\n\n### 生成器执行流程\n\n下面就仔细看看生成器是怎么工作的。\n\n从上面的例子也可以看到，生成器函数跟普通的函数是有很大差别的。\n\n结合上面的例子我们加入一些打印信息，进一步看看生成器的执行流程：\n\n![](https://images0.cnblogs.com/blog/593627/201507/162113509381037.png)\n\n通过结果可以看到：\n\n*   当调用生成器函数的时候，函数只是返回了一个生成器对象，并没有 执行。\n*   当next()方法第一次被调用的时候，生成器函数才开始执行，执行到yield语句处停止\n\n    *   next()方法的返回值就是yield语句处的参数（yielded value）\n*   当继续调用next()方法的时候，函数将接着上一次停止的yield语句处继续执行，并到下一个yield处停止；如果后面没有yield就抛出StopIteration异常\n\n### 生成器表达式\n\n在开始介绍生成器表达式之前，先看看我们比较熟悉的列表解析( List comprehensions)，列表解析一般都是下面的形式。\n\n[expr for iter_var in iterable if cond_expr]\n\n迭代iterable里所有内容，每一次迭代后，把iterable里满足cond_expr条件的内容放到iter_var中，再在表达式expr中应该iter_var的内容，最后用表达式的计算值生成一个列表。\n\n例如，生成一个list来保护50以内的所以奇数：\n\n[i for i in range(50) if i%2]\n\n生成器表达式是在python2.4中引入的，当序列过长， 而每次只需要获取一个元素时，应当考虑使用生成器表达式而不是列表解析。生成器表达式的语法和列表解析一样，只不过生成器表达式是被()括起来的，而不是[]，如下：\n\n(expr for iter_var in iterable if cond_expr)\n\n看一个例子：\n\n![](https://images0.cnblogs.com/blog/593627/201507/162113519859850.png)\n\n生成器表达式并不是创建一个列表， 而是返回一个生成器，这个生成器在每次计算出一个条目后，把这个条目\"产生\"（yield）出来。 生成器表达式使用了\"惰性计算\"（lazy evaluation），只有在检索时才被赋值（evaluated），所以在列表比较长的情况下使用内存上更有效。\n\n继续看一个例子：\n\n![](https://images0.cnblogs.com/blog/593627/201507/162113540636248.png)\n\n从这个例子中可以看到，生成器表达式产生的生成器，它自身是一个可迭代对象，同时也是迭代器本身。\n\n### 递归生成器\n\n生成器可以向函数一样进行递归使用的，下面看一个简单的例子，对一个序列进行全排列：\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0); \"复制代码\")\n\ndef permutations(li): if len(li) == 0: yield li else: for i in range(len(li)):\n            li[0], li[i] = li[i], li[0] for item in permutations(li[1:]): yield [li[0]] + item for item in permutations(range(3)): print item\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0); \"复制代码\")\n\n代码的结果为：\n\n![](https://images0.cnblogs.com/blog/593627/201507/162113554389261.png)\n\n### 生成器的send()和close()方法\n\n生成器中还有两个很重要的方法：send()和close()。\n\n*   send(value):\n\n    从前面了解到，next()方法可以恢复生成器状态并继续执行，其实send()是除next()外另一个恢复生成器的方法。\n\n    Python 2.5中，yield语句变成了yield表达式，也就是说yield可以有一个值，而这个值就是send()方法的参数，所以send(None)和next()是等效的。同样，next()和send()的返回值都是yield语句处的参数（yielded value）\n\n    关于send()方法需要**注意**的是：调用send传入非None值前，生成器必须处于挂起状态，否则将抛出异常。也就是说，第一次调用时，要使用next()语句或send(None)，因为没有yield语句来接收这个值。\n\n*   close():\n\n    这个方法用于关闭生成器，对关闭的生成器后再次调用next或send将抛出StopIteration异常。\n\n下面看看这两个方法的使用：\n\n![](https://images0.cnblogs.com/blog2015/593627/201507/162152472511515.png)\n\n## 总结\n\n本文介绍了Python迭代器和生成器的相关内容。\n\n*   通过实现迭代器协议对应的__iter__()和next()方法，可以自定义迭代器类型。对于可迭代对象，for语句可以通过iter()方法获取迭代器，并且通过next()方法获得容器的下一个元素。\n*   像列表这种序列类型的对象，可迭代对象和迭代器对象是相互独立存在的，在迭代的过程中各个迭代器相互独立；但是，有的可迭代对象本身又是迭代器对象，那么迭代器就没法独立使用。\n*   itertools模块提供了一系列迭代器，能够帮助用户轻松地使用排列、组合、笛卡尔积或其他组合结构。\n\n*   生成器是一种特殊的迭代器，内部支持了生成器协议，不需要明确定义__iter__()和next()方法。\n*   生成器通过生成器函数产生，生成器函数可以通过常规的def语句来定义，但是不用return返回，而是用yield一次返回一个结果。",[[1550296256148,["gjx16@GJXAIOU",[[-1,825,"[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0); \"复制代码\")"]],[825,910],[825,825]]],[1550296257228,["gjx16@GJXAIOU",[[-1,826,"\n"]],[825,825],[824,824]]],[1550296259585,["gjx16@GJXAIOU",[[1,824,"```"]],[824,824],[827,827]]],[1550296259621,["gjx16@GJXAIOU",[[1,827,"language\n```\n"]],[827,827],[827,835]]],[1550296262549,["gjx16@GJXAIOU",[[-1,836,"```"]],[836,839],[836,836]]],[1550296264765,["gjx16@GJXAIOU",[[1,1099,"```"]],[1099,1099],[1102,1102]]],[1550296267103,["gjx16@GJXAIOU",[[-1,838,"\n"]],[838,838],[837,837]]],[1550296267446,["gjx16@GJXAIOU",[[-1,837,"\n"]],[837,837],[836,836]]],[1550296268341,["gjx16@GJXAIOU",[[-1,836,"\n"]],[836,836],[835,835]]],[1550296279663,["gjx16@GJXAIOU",[[1,1068,"\n            "]],[1068,1068],[1081,1081]]],[1550296292188,["gjx16@GJXAIOU",[[1,859,"\n"]],[859,859],[860,860]]],[1550296293965,["gjx16@GJXAIOU",[[1,860,"  "]],[860,860],[862,862]]],[1550296304909,["gjx16@GJXAIOU",[[1,925,"\n        "]],[925,925],[934,934]]],[1550296310356,["gjx16@GJXAIOU",[[-1,928,"      "]],[934,934],[928,928]]],[1550296318991,["gjx16@GJXAIOU",[[1,948,"\n    "]],[948,948],[953,953]]],[1550296322790,["gjx16@GJXAIOU",[[1,965,"\n    "]],[965,965],[970,970]]],[1550296323372,["gjx16@GJXAIOU",[[-1,968,"  "]],[970,970],[968,968]]],[1550296332293,["gjx16@GJXAIOU",[[1,984,"\n    "]],[984,984],[989,989]]],[1550296339764,["gjx16@GJXAIOU",[[-1,1019,"    "]],[1023,1023],[1019,1019]]],[1550296344790,["gjx16@GJXAIOU",[[-1,1042,"    "]],[1046,1046],[1042,1042]]],[1550296349087,["gjx16@GJXAIOU",[[-1,1064,"    "]],[1068,1068],[1064,1064]]],[1550296356109,["gjx16@GJXAIOU",[[-1,1080,"        "]],[1088,1088],[1080,1080]]],[1550296361334,["gjx16@GJXAIOU",[[1,1086,"\n        "]],[1086,1086],[1095,1095]]],[1550296369076,["gjx16@GJXAIOU",[[-1,1121,"[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0); \"复制代码\")"]],[1121,1206],[1121,1121]]],[1550296376470,["gjx16@GJXAIOU",[[1,1154,"```"]],[1154,1154],[1157,1157]]],[1550296376505,["gjx16@GJXAIOU",[[1,1157,"language\n```\n"]],[1157,1157],[1157,1165]]],[1550296379620,["gjx16@GJXAIOU",[[-1,1166,"```"]],[1166,1169],[1166,1166]]],[1550296381400,["gjx16@GJXAIOU",[[1,1218,"```"]],[1218,1218],[1221,1221]]],[1550296383352,["gjx16@GJXAIOU",[[-1,1167,"\n"]],[1167,1167],[1166,1166]]],[1550296384119,["gjx16@GJXAIOU",[[-1,1166,"\n"]],[1166,1166],[1165,1165]]],[1550296393789,["gjx16@GJXAIOU",[[1,1187,"\n"]],[1187,1187],[1188,1188]]],[1550296396054,["gjx16@GJXAIOU",[[1,1188,"    "]],[1188,1188],[1192,1192]]],[1550296402908,["gjx16@GJXAIOU",[[1,1210,"\n        "]],[1210,1210],[1219,1219]]],[1550296409679,["gjx16@GJXAIOU",[[-1,1188,"    "]],[1192,1192],[1188,1188]]],[1550296412653,["gjx16@GJXAIOU",[[-1,1211,"    "]],[1211,1211],[1207,1207]]],[1550296412965,["gjx16@GJXAIOU",[[-1,1206,"\n"]],[1207,1207],[1206,1206]]],[1550296414204,["gjx16@GJXAIOU",[[1,1206,"\n"]],[1206,1206],[1207,1207]]],[1550296446821,["gjx16@GJXAIOU",[[-1,1567,"[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0); \"复制代码\")\n\nclass Zrange: def __init__(self, n):\n        self.n = n def __iter__(self): return ZrangeIterator(self.n) class ZrangeIterator: def __init__(self, n):\n        self.i = 0\n        self.n = n def __iter__(self): return self def next(self): if self.i < self.n:\n            i = self.i\n            self.i += 1\n            return i else: raise StopIteration()    \n\nzrange = Zrange(3) print zrange is iter(zrange) print [i for i in zrange] print [i for i in zrange]\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0); \"复制代码\")\n"]],[1566,2198],[1566,1566]]],[1550296449294,["gjx16@GJXAIOU",[[1,1566,"```"]],[1566,1566],[1569,1569]]],[1550296449329,["gjx16@GJXAIOU",[[1,1569,"language\n```\n"]],[1569,1569],[1569,1577]]],[1550296451697,["gjx16@GJXAIOU",[[-1,1569,"language"],[1,1577,"p"]],[1569,1577],[1570,1570]]],[1550296452401,["gjx16@GJXAIOU",[[1,1570,"ythopn"]],[1570,1570],[1576,1576]]],[1550296453556,["gjx16@GJXAIOU",[[-1,1574,"pn"]],[1576,1576],[1574,1574]]],[1550296454624,["gjx16@GJXAIOU",[[1,1574,"n"]],[1574,1574],[1575,1575]]],[1550296454997,["gjx16@GJXAIOU",[[1,1576,"\n"]],[1575,1575],[1576,1576]]],[1550296470298,["gjx16@GJXAIOU",[[1,1576,"class Zrange:\n    def __init__(self, n):\n        self.n = n\n\n    def __iter__(self):\n        return ZrangeIterator(self.n)\n\nclass ZrangeIterator:\n    def __init__(self, n):\n        self.i = 0\n        self.n = n\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        if self.i < self.n:\n            i = self.i\n            self.i += 1\n            return i\n        else:\n            raise StopIteration()    \n\n            \nzrange = Zrange(3)\nprint zrange is iter(zrange)         \n\nprint [i for i in zrange]\nprint [i for i in zrange]"]],[1576,1576],[2124,2124]]],[1550296509045,["gjx16@GJXAIOU",[[-1,4074,"[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0); \"复制代码\")\n\ndef permutations(li): if len(li) == 0: yield li else: for i in range(len(li)):\n            li[0], li[i] = li[i], li[0] for item in permutations(li[1:]): yield [li[0]] + item for item in permutations(range(3)): print item\n\n[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0); \"复制代码\")\n"]],[4073,4468],[4073,4073]]],[1550296509084,["gjx16@GJXAIOU",[[1,4073,"="]],[4073,4073],[4074,4074]]],[1550296511040,["gjx16@GJXAIOU",[[-1,4073,"="]],[4074,4074],[4073,4073]]],[1550296513297,["gjx16@GJXAIOU",[[1,4073,"```"]],[4073,4073],[4076,4076]]],[1550296513331,["gjx16@GJXAIOU",[[1,4076,"language\n```\n"]],[4076,4076],[4076,4084]]],[1550296514826,["gjx16@GJXAIOU",[[-1,4076,"language"],[1,4084,"p"]],[4076,4084],[4077,4077]]],[1550296515503,["gjx16@GJXAIOU",[[1,4077,"ython"]],[4077,4077],[4082,4082]]],[1550296515937,["gjx16@GJXAIOU",[[1,4083,"\n"]],[4082,4082],[4083,4083]]],[1550296515974,["gjx16@GJXAIOU",[[1,4083,"'"]],[4083,4083],[4084,4084]]],[1550296517525,["gjx16@GJXAIOU",[[-1,4083,"'"]],[4084,4084],[4083,4083]]],[1550296518216,["gjx16@GJXAIOU",[[1,4083,"def permutations(li):\n    if len(li) == 0:\n        yield li\n    else:\n        for i in range(len(li)):\n            li[0], li[i] = li[i], li[0]\n            for item in permutations(li[1:]):\n                yield [li[0]] + item\n    \nfor item in permutations(range(3)):\n    print item"]],[4083,4083],[4364,4364]]]],null,"gjx16@GJXAIOU"]]}