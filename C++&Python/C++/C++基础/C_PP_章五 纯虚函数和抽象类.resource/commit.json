{"compress":true,"commitItems":[["c4add608-c1a5-465c-a107-4088a5bd7c39",1544339108355,"",[[1544339082867,["gjx16@GJXAIOU",[[1,0,"# C_PP_章五 纯虚函数和抽象类\n\n\n\n"]],[0,0],[21,21]]],[1544339222024,["gjx16@GJXAIOU",[[1,21,"5、纯虚函数和抽象类\n\n**5.1****基本概念**\n\n**5.2****抽象类案例**\n\n**5.3****抽象类在多继承中的应用**\n\nC++中没有Java中的接口概念，抽象类可以模拟Java中的接口类。（接口和协议）\n\n**5.3.1****有关多继承的说明**\n\n**工程上的多继承**\n\n被实际开发经验抛弃的多继承\n\n工程开发中真正意义上的多继承是几乎不被使用的\n\n多重继承带来的代码复杂性远多于其带来的便利\n\n多重继承对代码维护性上的影响是灾难性的\n\n在设计方法上，任何多继承都可以用单继承代替 \n\n**多继承中的二义性和多继承不能解决的问题 **\n\n**5.3.2****多继承的应用场景**\n\n| \n\nC++中是否有Java中的接口概念？\n\n |\n| \n\n绝大多数面向对象语言都不支持多继承\n\n绝大多数面向对象语言都支持接口的概念\n\nC++中没有接口的概念\n\nC++中可以使用纯虚函数实现接口\n\n**接口类中只有函数原型定义，没有任何数据的定义**。\n\nclass Interface \n\n{\n\n public:\n\n virtual void func1() = 0;\n\n virtual void func2(int i) = 0;\n\n virtual void func3(int i) = 0;\n\n};\n\n |\n| \n\n实际工程经验证明\n\n多重继承接口不会带来二义性和复杂性等问题 \n\n多重继承可以通过精心设计用单继承和接口来代替\n\n接口类只是一个功能说明，而不是功能实现。\n\n子类需要根据功能说明定义功能实现。\n\n |\n| \n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n\nC++中没有接口的概念\n\nC++中可以使用纯虚函数实现接口\n\n接口类中只有函数原型定义，没有任何数据的定义。\n\n*/\n\nclass Interface1\n\n{\n\npublic:\n\n virtual void print() = 0;\n\n virtual int add(int a, int b) = 0;\n\n};\n\nclass Interface2\n\n{\n\npublic:\n\n virtual void print() = 0;\n\n virtual int add(int a, int b) = 0;\n\n virtual int minus(int a, int b) = 0;\n\n};\n\nclass parent\n\n{\n\npublic:\n\n int a;\n\n};\n\nclass Child : public parent, public Interface1, public Interface2\n\n{\n\npublic: \n\n void print()\n\n {\n\n cout<<\"Child::print\"<<endl;\n\n }\n\n int add(int a, int b)\n\n {\n\n return a + b;\n\n }\n\n int minus(int a, int b)\n\n {\n\n return a - b;\n\n }\n\n};\n\nint main()\n\n{\n\n Child c;\n\n c.print();\n\n cout<<c.add(3, 5)<<endl;\n\n cout<<c.minus(4, 6)<<endl;\n\n Interface1* i1 = &c;\n\n Interface2* i2 = &c;\n\n cout<<i1->add(7, 8)<<endl;\n\n cout<<i2->add(7, 8)<<endl;\n\n system(\"pause\");\n\n}\n\n |\n\n**5.4****抽象类知识点强化**\n\n/*\n\n编写一个C++程序, 计算程序员( programmer )工资 \n\n 1 要求能计算出初级程序员( junior_programmer ) 中级程序员 ( mid_programmer )高级程序员( adv_programmer)的工资\n\n 2 要求利用抽象类统一界面,方便程序的扩展, 比如:新增, 计算 架构师 (architect ) 的工资\n\n*/\n\n**5.5****面向抽象类编程思想强化**\n\n理论知识\n\nØ 虚函数和多态性使成员函数根据调用对象的类型产生不同的动作\n\nØ  多态性特别适合于实现分层结构的软件系统，便于对问题抽象时  定义共性，实现时定义区别\n\nØ **面向抽象类编程（面向接口编程）**是项目开发中重要技能之一。\n\n**5.4.1****案例：****socket****库****c++****模型设计和实现**\n\n**企业信息系统框架集成第三方产品**\n\n**案例背景**：一般的企业信息系统都有成熟的框架。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求**：请你在**企业信息系统框架**中集成第三方厂商的Socket通信产品和第三方厂商加密产品。\n\n第三方厂商的Socket通信产品：完成两点之间的通信；\n\n第三方厂商加密产品：完成数据发送时加密；数据解密时解密。\n\n**案例要求**： 1）能支持多个厂商的Socket通信产品入围\n\n 2）能支持多个第三方厂商加密产品的入围\n\n 3）企业信息系统框架不轻易发生框架\n\n**需求实现**\n\n  思考1：企业信息系统框架、第三方产品如何分层\n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分成以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n分析有多少个类 CSocketProtocol  CSckFactoryImp1  CSckFactoryImp2\n\nCEncDesProtocol  HwEncdes  ciscoEncdes\n\n1、 定义 CSocketProtocol 抽象类\n\n2、 编写框架函数\n\n3、 编写框架测试函数\n\n4、 厂商1（CSckFactoryImp1）实现CSocketProtocol、厂商2（CSckFactoryImp1）实现CSocketProtocol\n\n5、 抽象加密接口（CEncDesProtocol）、加密厂商1(CHwImp)、加密厂商2(CCiscoImp))，集成实现业务模型\n\n6、 框架（c语言函数方式，框架函数；c++类方式，框架类）\n\n**几个重要的面向对象思想**\n\n继承-组合（强弱）\n\n注入\n\n控制反转 IOC\n\nMVC\n\n  面向对象思想扩展aop思想\n\n aop思想是对继承编程思想的有力的补充\n\n**5.4.2****案例：计算员工工资**\n\n**5.4.3****案例：计算几何体的表面积和体积**\n\n**5.6 C****面向接口编程和****C****多态**\n\n友情提示：今天课程内容，更加贴近实战，并且语法和软件思想都较难，请学员紧跟思路。课后加强复习！\n\n结论：  只要你动手，又很容易！\n\n**5.6.1****函数类型语法基础**\n\n| \n\n函数三要素：  名称、参数、返回值\n\nC语言中的函数有自己特定的类型\n\n |\n| \n\nC语言中通过typedef为函数类型重命名\n\ntypedef type name(parameter list)\n\ntypedef int f(int, int);\n\ntypedef void p(int);\n\n |\n| \n\n函数指针\n\n |\n| \n\n函数指针用于指向一个函数\n\n函数名是函数体的入口地址\n\n1)可通过函数类型定义函数指针: FuncType* pointer;\n\n2)也可以直接定义：type (*pointer)(parameter list);\n\npointer为函数指针变量名\n\ntype为指向函数的返回值类型\n\nparameter list为指向函数的参数类型列表\n\n |\n| \n\n函数指针语法梳理\n\n//函数类型\n\n//函数指针类型\n\n//函数指针变量\n\n数组指针语法梳理 \n\n//数组类型语法\n\n//数组指针类型\n\n//数组指针变量\n\n |\n| \n\ntypedef int(FUNC)(int);\n\nint test(int i)\n\n{\n\n return i * i;\n\n}\n\nvoid f()\n\n{\n\n printf(\"Call f()...\\n\");\n\n}\n\nint main()\n\n{\n\n FUNC* pt = test;\n\n void(*pf)() = &f;\n\n pf();\n\n (*pf)();\n\n printf(\"Function pointer call: %d\\n\", pt(3));\n\n}\n\n |\n\n**5.6.2****函数指针做函数参数**\n\n| \n\n1、 指针做函数参数pk函数指针做函数参数\n\n回忆指针做函数参数\n\n一级指针做函数参数、二级。。。。、三级\n\n |\n| \n\n2、 函数指针做函数参数\n\n当函数指针 做为函数的参数，传递给一个被调用函数，\n\n被调用函数就可以通过这个指针调用外部的函数，这就形成了回调\n\n |\n| \n\n3、练习\n\nint add(int a, int b) \n\nint libfun( int (*pDis)(int a, int b) );\n\nint main(void)\n\n{\n\n int (*pfun)(int a, int b);  \n\n pfun = add;\n\n libfun(pfun);\n\n}\n\nint add(int a, int b)\n\n{\n\n return a + b;\n\n}\n\nint libfun( int (*pDis)(int a, int b) )\n\n{\n\n  int a, b;\n\n  a = 1;\n\n  b = 2;\n\nadd(1,3) //直接调用add函数\n\nprintf(\"%d\", pDis(a, b)); //通过函数指针做函数参数,间接调用add函数\n\n//思考 这样写 pDis(a, b)有什么好处?\n\n}\n\n//剖析思路\n\n//1函数的调用 和 函数的实现  有效的分离\n\n//2 C++的多态,可扩展\n\n现在这几个函数是在同一个文件当中\n\n假如\n\nint libfun(int (*pDis)(int a, int b))\n\n是一个库中的函数，就只有使用回调了，通过函数指针参数将外部函数地址传入\n\n来实现调用\n\n函数 add 的代码作了修改，也不必改动库的代码，就可以正常实现调用\n\n便于程序的维护和升级\n\n |\n\n回调函数思想：\n\n结论：回调函数的本质：提前做了一个协议的约定（把函数的参数、函数返回值提前约定）\n\n请思考：C编译器通过那个具体的语法，实现解耦合的？\n\n C++编译器通过多态的机制(提前布局vptr指针和虚函数表,找虚函数入口地址来实现)\n\n**5.6.3****函数指针正向调用**\n\n| \n\n1、 函数指针做函数参数，调用方式\n\n被调用函数和主调函数在同一文件中（用来教学，没有任何意义）\n\n |\n| \n\n2、函数指针做函数参数\n\n被调用函数和主调函数不在同一个文件中、模块中。\n\n难点：理解被调用函数是什么机制被调用起来的。框架\n\n框架提前设置了被调用函数的入口（框架提供了第三方模块入口地址的集成功能）\n\n框架具备调用第三方模块入口函数\n\n |\n| \n\n3、 练习\n\ntypedef int (*EncDataFunc)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\nint MyEncDataFunc(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen)\n\n{\n\n int rv = 0;\n\n char *p = \"222222222222\";\n\n strcpy(outData, p);\n\n *outDataLen = strlen(p);\n\n return rv;\n\n}\n\nint Send_Data(EncDataFunc encDataFunc, unsigned char *inData, int inDataLen, unsigned char *outData, int *outDatalen)\n\n{\n\n int rv = 0;\n\n if (encDataFunc != NULL)\n\n {\n\n rv = encDataFunc(inData, inDataLen, outData, outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"func encDataFunc() err.\\n\");\n\n return rv;\n\n }\n\n }\n\n return rv;\n\n}\n\nint main()\n\n{\n\n int rv = 0;\n\n EncDataFunc encDataFunc = NULL;\n\n encDataFunc = MyEncDataFunc;\n\n // 第一个调用\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"1111\");\n\n inDataLen = strlen(inData);\n\n rv = encDataFunc(inData,inDataLen, outData, &outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"edf err .....\\n\");\n\n }\n\n else\n\n {\n\n printf(\"edf ok \\n\");\n\n printf(\"%s \\n\", outData);\n\n }\n\n }\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"3333\");\n\n inDataLen = strlen(inData);\n\n rv = Send_Data(MyEncDataFunc, inData, inDataLen, outData, &outDatalen);\n\n if (rv != 0)\n\n {\n\n printf(\"func Send_Data err:%d\", rv);\n\n return rv;\n\n }\n\n printf(\"%s \\n\", outData);\n\n }\n\n getchar();\n\n}\n\n |\n\n**5.6.4****函数指针反向调用**\n\n回调函数效果展示。\n\n**5.6.5.C****动态库升级成框架案例**\n\n**C****语言版本Socket****动态库升级成框架集成第三方产品**\n\n**简称：C****动态库升级成框架案例**\n\n**名字解释       **\n\n  动态库：抽象类一个套接口，单独封装成模块，供别人调用；无法扩展。\n\n  框架：能自由的扩展 \n\n**案例背景**：一般的企业信息系统都有成熟的框架，可以有C语言写，也可以由C++语言。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求：**在socket通信库中，完成数据加密功能，有n个厂商的加密产品供你选择，如何实现动态库和第三个厂商产品的解耦合。\n\n提醒：C++通过抽象类，也就是面向抽象类编程实现的（相当于C++编译器通过多态机制，已经很好用了。提前布局vptr指针、虚函数表；调用是迟绑定完成。），\n\n**C****语言**中如何实现哪？\n\n**案例要求**： 1）能支持多个第三方厂商加密产品的入围\n\n 2）企业信息系统框架不轻易发生框架\n\n**需求实现思路分析**\n\n  思考1：企业信息系统框架、第三方产品如何分层 \n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分层确定后，动态库应该做什么？产品入围厂商应该做什么？\n\n以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n1、 动态库中定义协议，并完成任务的调用\n\ntypedef int (*EncData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\ntypedef int (*DecData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\n2、 加密厂商完成协议函数的编写\n\n3、 对接调试。\n\n4、 动态库中可以缓存第三方函数的入口地址，也可以不缓存，两种实现方式。\n\n**案例总结**\n\n  回调函数：利用函数指针做函数参数，实现的一种调用机制，具体任务的实现者，可以不知道什么时候被调用。\n\n  回调机制原理：\n\n  当具体事件发生时，调用者通过函数指针调用具体函数\n\n  回调机制的将调用者和被调函数分开，两者互不依赖\n\n  任务的实现 和 任务的调用 可以耦合  （提前进行接口的封装和设计）\n\n**5.6.6****附录：诸葛亮的锦囊妙计**\n\n刘备利用周瑜、曹仁厮杀之际，乘虚袭取了南郡、荆州、襄阳，以后又征服了长沙等四郡。周瑜想想十分气恨，正无处报复以夺还荆州。不久，刘备忽然丧偶，周瑜计上心来，对孙权说：“您的妹妹，美丽、刚强，我们以联姻抗曹名义向刘备招亲，把他骗来南徐幽禁，逼他们拿荆州来换。”孙权大喜，郎派人到荆州说亲。\n\n刘备认为这是骗局，想要拒绝，诸葛亮笑道：“送个好妻子上门何不答应？您只管去东吴，我叫赵云陪您去，自有安排，包您得了夫人又不失荆州。”\n\n接着，诸葛亮暗暗关照赵云道：“我这里有三个锦囊，内藏三条妙计。到南徐时打开第一个，到年底时打开第二个，危急无路时打开第三个。”\n\n第一个锦囊\n\n  一到东吴就拜会乔国老\n\n第二个锦囊\n\n  刘备被孙权设计留下就对他谎称曹操大军压境\n\n第三个锦囊\n\n被东吴军队追赶就求孙夫人解围"]],[21,21],[7746,7746]]],[1544339445795,["gjx16@GJXAIOU",[[1,49,"![image071]($resource/image071.png)\n![image072]($resource/image072.png)\n![image073]($resource/image073.png)"]],[49,49],[157,157]]],[1544339480166,["gjx16@GJXAIOU",[[1,174,"![image074]($resource/image074.png)\n![image075]($resource/image075.png)"]],[174,174],[246,246]]],[1544339511123,["gjx16@GJXAIOU",[[1,481,"![image076]($resource/image076.png)"]],[481,481],[517,517]]],[1544339948489,["gjx16@GJXAIOU",[[1,2348,"\n"]],[2347,2347],[2348,2348]]],[1544339948638,["gjx16@GJXAIOU",[[1,2349,"\n"]],[2348,2348],[2349,2349]]],[1544339970090,["gjx16@GJXAIOU",[[1,2348,"![image077]($resource/image077.png)"]],[2348,2348],[2384,2384]]],[1544340013145,["gjx16@GJXAIOU",[[1,4635,"![image078]($resource/image078.png)"]],[4635,4635],[4671,4671]]],[1544340052022,["gjx16@GJXAIOU",[[1,6990,"![image079]($resource/image079.png)"]],[6990,6990],[7026,7026]]],[1544340102608,["gjx16@GJXAIOU",[[-1,33,"**5.1****"]],[33,42],[33,33]]],[1544340103756,["gjx16@GJXAIOU",[[-1,33,""],[1,33,"#"],[-1,444," "],[1,445," "],[-1,468," "],[1,469," "],[-1,676," "],[1,677," "],[-1,827," "],[1,828," "],[-1,1362," "],[1,1363," "],[-1,1802," "],[1,1803," "],[-1,2016," "],[1,2017," "],[-1,3588," "],[1,3589," "],[-1,4059," "],[1,4060," "],[-1,4123," "],[1,4124," "],[-1,4150,"  \n\n "],[1,4155,"  \n\n "],[-1,4168," "],[1,4169," "],[-1,4213," "],[1,4214," "],[-1,4276," "],[1,4277," "],[-1,4289," "],[1,4290," "],[-1,4299," "],[1,4300," "],[-1,6618,"       "],[1,6625,"       "],[-1,6676," "],[1,6677," "],[-1,7041," "],[1,7042," "]],[33,33],[34,34]]],[1544340107556,["gjx16@GJXAIOU",[[1,34,"# 一、"]],[34,34],[38,38]]],[1544340110264,["gjx16@GJXAIOU",[[-1,42,"**"]],[44,44],[42,42]]],[1544340113223,["gjx16@GJXAIOU",[[-1,165,"**"]],[167,167],[165,165]]],[1544340118192,["gjx16@GJXAIOU",[[-1,151,"**5.2****"]],[160,160],[151,151]]],[1544340119187,["gjx16@GJXAIOU",[[1,151,"\n"]],[151,151],[152,152]]],[1544340119314,["gjx16@GJXAIOU",[[1,152,"\n"]],[152,152],[153,153]]],[1544340119441,["gjx16@GJXAIOU",[[1,153,"\n"]],[153,153],[154,154]]],[1544340123503,["gjx16@GJXAIOU",[[1,154,"## 二、"]],[154,154],[159,159]]],[1544340131281,["gjx16@GJXAIOU",[[1,237,"\n"]],[236,236],[237,237]]],[1544340131721,["gjx16@GJXAIOU",[[1,238,"\n"]],[237,237],[238,238]]],[1544340146121,["gjx16@GJXAIOU",[[-1,239,"**5.3****"]],[248,248],[239,239]]],[1544340152509,["gjx16@GJXAIOU",[[1,239,"## 三、"]],[239,239],[244,244]]],[1544340156785,["gjx16@GJXAIOU",[[-1,255,"**"]],[257,257],[255,255]]],[1544340166361,["gjx16@GJXAIOU",[[1,300,"\n"]],[299,299],[300,300]]],[1544340166506,["gjx16@GJXAIOU",[[1,301,"\n"]],[300,300],[301,301]]],[1544340171176,["gjx16@GJXAIOU",[[-1,302,"**5.3.1****"]],[313,313],[302,302]]],[1544340173918,["gjx16@GJXAIOU",[[1,302,"##3 "]],[302,302],[306,306]]],[1544340175289,["gjx16@GJXAIOU",[[-1,304,"3 "]],[306,306],[304,304]]],[1544340177439,["gjx16@GJXAIOU",[[1,304,"# （）"]],[304,304],[308,308]]],[1544340180010,["gjx16@GJXAIOU",[[1,307,"一"]],[307,307],[308,308]]],[1544340183600,["gjx16@GJXAIOU",[[-1,317,"**"]],[319,319],[317,317]]],[1544340190844,["gjx16@GJXAIOU",[[-1,346,"\n"]],[346,346],[345,345]]],[1544340191701,["gjx16@GJXAIOU",[[-1,369,"\n"]],[369,369],[368,368]]],[1544340192584,["gjx16@GJXAIOU",[[-1,391,"\n"]],[391,391],[390,390]]],[1544340193409,["gjx16@GJXAIOU",[[-1,411,"\n"]],[411,411],[410,410]]],[1544340196649,["gjx16@GJXAIOU",[[1,332,"* "],[1,346,"* "],[1,369,"* "],[1,391,"* "],[1,411,"* "]],[332,433],[334,443]]],[1544342387500,["gjx16@GJXAIOU",[[1,506,"\n"]],[505,505],[506,506]]],[1544342387655,["gjx16@GJXAIOU",[[1,507,"\n"]],[506,506],[507,507]]],[1544342395458,["gjx16@GJXAIOU",[[-1,508,"**5.3.2****"]],[519,519],[508,508]]],[1544342400786,["gjx16@GJXAIOU",[[1,508,"### （）"]],[508,508],[514,514]]],[1544342402930,["gjx16@GJXAIOU",[[1,513,"二"]],[513,513],[514,514]]],[1544342408500,["gjx16@GJXAIOU",[[-1,523,"*"]],[524,524],[523,523]]],[1544342411522,["gjx16@GJXAIOU",[[-1,525,"| "]],[527,527],[525,525]]],[1544342411889,["gjx16@GJXAIOU",[[-1,526,"\n"]],[525,525],[524,524]]],[1544342412378,["gjx16@GJXAIOU",[[-1,525,"\n"]],[524,524],[523,523]]],[1544342424490,["gjx16@GJXAIOU",[[-1,548,"| "]],[550,550],[548,548]]],[1544342424873,["gjx16@GJXAIOU",[[-1,549,"\n"]],[548,548],[547,547]]],[1544342425515,["gjx16@GJXAIOU",[[-1,545," |"]],[547,547],[545,545]]],[1544342425827,["gjx16@GJXAIOU",[[-1,546,"\n"]],[545,545],[544,544]]],[1544342426377,["gjx16@GJXAIOU",[[-1,545,"\n"]],[544,544],[543,543]]],[1544342443557,["gjx16@GJXAIOU",[[-1,776,"| "]],[778,778],[776,776]]],[1544342443687,["gjx16@GJXAIOU",[[-1,777,"\n"]],[776,776],[775,775]]],[1544342444330,["gjx16@GJXAIOU",[[-1,773," |"]],[775,775],[773,773]]],[1544342444597,["gjx16@GJXAIOU",[[-1,774,"\n"]],[773,773],[772,772]]],[1544342445092,["gjx16@GJXAIOU",[[-1,773,"\n"]],[772,772],[771,771]]],[1544342449466,["gjx16@GJXAIOU",[[-1,874,"| "]],[876,876],[874,874]]],[1544342449769,["gjx16@GJXAIOU",[[-1,875,"\n"]],[874,874],[873,873]]],[1544342450658,["gjx16@GJXAIOU",[[-1,871," |"]],[873,873],[871,871]]],[1544342450998,["gjx16@GJXAIOU",[[-1,872,"\n"]],[871,871],[870,870]]],[1544342462770,["gjx16@GJXAIOU",[[-1,1715,"**5.4****"]],[1715,1724],[1715,1715]]],[1544342467234,["gjx16@GJXAIOU",[[1,1715,"## 四、"]],[1715,1715],[1720,1720]]],[1544342528348,[null,[[-1,523,"*"],[-1,871,"|"],[1,872,"\n"],[1,1715,"\n"],[-1,1720,"*"]],[523,523],[1720,1720]]],[1544342528348,[null,[[1,523,"*"],[1,870,"|"],[-1,870,"\n"],[-1,1714,"\n"],[1,1720,"*"]],[1720,1720],[523,523]]],[1544342471188,["gjx16@GJXAIOU",[[-1,1728,"**"]],[1730,1730],[1728,1728]]],[1544342475671,["gjx16@GJXAIOU",[[-1,1711," |"]],[1713,1713],[1711,1711]]],[1544342487781,["gjx16@GJXAIOU",[[-1,1914,"**5.5****"]],[1914,1923],[1914,1914]]],[1544342488343,["gjx16@GJXAIOU",[[1,1914,"\n"]],[1914,1914],[1915,1915]]],[1544342494453,["gjx16@GJXAIOU",[[1,1915," ###"]],[1915,1915],[1919,1919]]],[1544342496098,["gjx16@GJXAIOU",[[-1,1918,"#"]],[1919,1919],[1918,1918]]],[1544342499458,["gjx16@GJXAIOU",[[1,1918," 五、"]],[1918,1918],[1921,1921]]],[1544342506250,["gjx16@GJXAIOU",[[-1,1915," "]],[1916,1916],[1915,1915]]],[1544342509388,["gjx16@GJXAIOU",[[-1,1931,"**"]],[1933,1933],[1931,1931]]],[1544342512951,["gjx16@GJXAIOU",[[1,1915,"\n"]],[1914,1914],[1915,1915]]],[1544342523194,["gjx16@GJXAIOU",[[-1,2055,"**5.4.1****"]],[2055,2066],[2055,2055]]],[1544342523969,["gjx16@GJXAIOU",[[1,2055,"\n"]],[2055,2055],[2056,2056]]],[1544342526821,["gjx16@GJXAIOU",[[1,2056,"### （）"]],[2056,2056],[2062,2062]]],[1544342588353,[null,[[-1,523,"*"],[-1,871,"|"],[1,872,"\n"],[-1,1711,"|"],[1,1712,"\n\n"],[-1,1718,"*"],[-1,1726,"*"],[1,1727,"化"],[1,1916,"\n"],[-1,1921,"*"],[-1,1932,"*"],[1,1933,"化"],[1,2056,"\n"],[-1,2062,"*"]],[523,523],[2062,2062]]],[1544342588353,[null,[[1,523,"*"],[1,870,"|"],[-1,870,"\n"],[1,1710,"|"],[-1,1710,"\n\n"],[1,1718,"*"],[1,1725,"*"],[-1,1725,"化"],[-1,1915,"\n"],[1,1921,"*"],[1,1931,"*"],[-1,1931,"化"],[-1,2055,"\n"],[1,2062,"*"]],[2062,2062],[523,523]]],[1544342528596,["gjx16@GJXAIOU",[[1,2061,"一"]],[2061,2061],[2062,2062]]],[1544342531372,["gjx16@GJXAIOU",[[-1,2099,"**"]],[2101,2101],[2099,2099]]],[1544342536482,["gjx16@GJXAIOU",[[-1,2066,"****"]],[2070,2070],[2066,2066]]],[1544342540092,["gjx16@GJXAIOU",[[-1,2072,"****"]],[2076,2076],[2072,2072]]],[1544342543453,["gjx16@GJXAIOU",[[-1,2073,"****"]],[2077,2077],[2073,2073]]],[1544342547083,["gjx16@GJXAIOU",[[-1,2076,"****"]],[2080,2080],[2076,2076]]],[1544342571781,["gjx16@GJXAIOU",[[-1,2951,"**5.4.2****"]],[2951,2962],[2951,2951]]],[1544342572347,["gjx16@GJXAIOU",[[1,2951,"\n"]],[2951,2951],[2952,2952]]],[1544342576854,["gjx16@GJXAIOU",[[1,2952,"### （）"]],[2952,2952],[2958,2958]]],[1544342578650,["gjx16@GJXAIOU",[[1,2957,"二"]],[2957,2957],[2958,2958]]],[1544342582416,["gjx16@GJXAIOU",[[-1,2968,"**"]],[2970,2970],[2968,2968]]],[1544342585130,["gjx16@GJXAIOU",[[1,2970,"\n"]],[2969,2969],[2970,2970]]],[1544342648353,[null,[[-1,523,"*"],[1,525,""],[-1,871,"|"],[1,872,"\n"],[-1,1711,"|"],[1,1712,"\n\n"],[-1,1718,"*"],[-1,1726,"*"],[1,1727,"化"],[1,1916,"\n"],[-1,1921,"*"],[-1,1932,"*"],[1,1933,"化"],[1,2056,"\n"],[-1,2063,"*"],[-1,2066,"*"],[1,2067,"："],[-1,2072,"**c+*"],[1,2077,"t库c++"],[-1,2083,"*"],[1,2084,"现"],[1,2952,"\n"],[-1,2959,"*"],[-1,2968,"*"],[1,2969,"资"]],[523,523],[2970,2970]]],[1544342648353,[null,[[1,523,"*"],[-1,524,""],[1,870,"|"],[-1,870,"\n"],[1,1710,"|"],[-1,1710,"\n\n"],[1,1718,"*"],[1,1725,"*"],[-1,1725,"化"],[-1,1915,"\n"],[1,1921,"*"],[1,1931,"*"],[-1,1931,"化"],[-1,2055,"\n"],[1,2063,"*"],[1,2065,"*"],[-1,2065,"："],[1,2071,"**c+*"],[-1,2071,"t库c++"],[1,2082,"*"],[-1,2082,"现"],[-1,2951,"\n"],[1,2959,"*"],[1,2967,"*"],[-1,2967,"资"]],[2970,2970],[523,523]]],[1544342593499,["gjx16@GJXAIOU",[[-1,2971,"**5.4.3****"]],[2982,2982],[2971,2971]]],[1544342597455,["gjx16@GJXAIOU",[[1,2971,"### （）"]],[2971,2971],[2977,2977]]],[1544342600909,["gjx16@GJXAIOU",[[1,2976,"三"]],[2976,2976],[2977,2977]]],[1544342607018,["gjx16@GJXAIOU",[[-1,2993,"**"]],[2995,2995],[2993,2993]]],[1544342610509,["gjx16@GJXAIOU",[[1,2995,"\n"]],[2994,2994],[2995,2995]]],[1544342610664,["gjx16@GJXAIOU",[[1,2996,"\n"]],[2995,2995],[2996,2996]]],[1544342625172,["gjx16@GJXAIOU",[[-1,2997,"**5.6 C****"]],[3008,3008],[2997,2997]]],[1544342630878,["gjx16@GJXAIOU",[[1,2997,"## 六、"]],[2997,2997],[3002,3002]]],[1544342643922,["gjx16@GJXAIOU",[[-1,3014,"****"]],[3018,3018],[3014,3014]]],[1544342647276,["gjx16@GJXAIOU",[[-1,3009,"****"]],[3013,3013],[3009,3009]]],[1544342708349,[null,[[-1,523,"*"],[1,524,""],[-1,871,"|"],[1,872,"\n"],[-1,1711,"|"],[1,1712,"\n\n"],[-1,1718,"*"],[-1,1726,"*"],[1,1727,"化"],[1,1916,"\n"],[-1,1921,"*"],[-1,1932,"*"],[1,1933,"化"],[1,2056,"\n"],[-1,2063,"*"],[-1,2066,"*"],[1,2067,"："],[-1,2072,"**c+*"],[1,2077,"t库c++"],[-1,2083,"*"],[1,2084,"现"],[1,2952,"\n"],[-1,2959,"*"],[-1,2968,"*"],[1,2969,"资\n"],[-1,2978,"*"],[-1,2993,"*"],[1,2994,"积\n"],[-1,3002,"*"],[-1,3009,"**"],[1,3011,"和C"]],[523,523],[3013,3013]]],[1544342708349,[null,[[1,523,"*"],[-1,523,""],[1,870,"|"],[-1,870,"\n"],[1,1710,"|"],[-1,1710,"\n\n"],[1,1718,"*"],[1,1725,"*"],[-1,1725,"化"],[-1,1915,"\n"],[1,1921,"*"],[1,1931,"*"],[-1,1931,"化"],[-1,2055,"\n"],[1,2063,"*"],[1,2065,"*"],[-1,2065,"："],[1,2071,"**c+*"],[-1,2071,"t库c++"],[1,2082,"*"],[-1,2082,"现"],[-1,2951,"\n"],[1,2959,"*"],[1,2967,"*"],[-1,2967,"资\n"],[1,2978,"*"],[1,2992,"*"],[-1,2992,"积\n"],[1,3002,"*"],[1,3008,"**"],[-1,3008,"和C"]],[3013,3013],[523,523]]],[1544342650409,["gjx16@GJXAIOU",[[-1,3012,"**"]],[3014,3014],[3012,3012]]],[1544342828363,[null,[[-1,523,"*"],[1,524,""],[-1,871,"|"],[1,872,"\n"],[-1,1711,"|"],[1,1712,"\n\n"],[-1,1718,"*"],[-1,1726,"*"],[1,1727,"化"],[1,1916,"\n"],[-1,1921,"*"],[-1,1932,"*"],[1,1933,"化"],[1,2056,"\n"],[-1,2063,"*"],[-1,2066,"*"],[1,2067,"："],[-1,2072,"**c+*"],[1,2077,"t库c++"],[-1,2083,"*"],[1,2084,"现"],[1,2952,"\n"],[-1,2959,"*"],[-1,2968,"*"],[1,2969,"资"],[1,2971,"\n"],[-1,2978,"*"],[-1,2993,"*"],[1,2994,"积"],[1,2997,"\n"],[-1,3002,"*"],[-1,3009,"**多*"],[1,3013,"和C多态"]],[523,523],[3017,3017]]],[1544342828363,[null,[[1,523,"*"],[-1,523,""],[1,870,"|"],[-1,870,"\n"],[1,1710,"|"],[-1,1710,"\n\n"],[1,1718,"*"],[1,1725,"*"],[-1,1725,"化"],[-1,1915,"\n"],[1,1921,"*"],[1,1931,"*"],[-1,1931,"化"],[-1,2055,"\n"],[1,2063,"*"],[1,2065,"*"],[-1,2065,"："],[1,2071,"**c+*"],[-1,2071,"t库c++"],[1,2082,"*"],[-1,2082,"现"],[-1,2951,"\n"],[1,2959,"*"],[1,2967,"*"],[-1,2967,"资"],[-1,2970,"\n"],[1,2978,"*"],[1,2992,"*"],[-1,2992,"积"],[-1,2996,"\n"],[1,3002,"*"],[1,3008,"**多*"],[-1,3008,"和C多态"]],[3017,3017],[523,523]]],[1544342801825,["gjx16@GJXAIOU",[[-1,3081,"**5.6.1****"]],[3081,3092],[3081,3081]]],[1544342805290,["gjx16@GJXAIOU",[[1,3081,"### （）"]],[3081,3081],[3087,3087]]],[1544342807067,["gjx16@GJXAIOU",[[1,3086,"一"]],[3086,3086],[3087,3087]]],[1544342810621,["gjx16@GJXAIOU",[[-1,3096,"**"]],[3098,3098],[3096,3096]]],[1544342813402,["gjx16@GJXAIOU",[[-1,3098,"| "]],[3100,3100],[3098,3098]]],[1544342813882,["gjx16@GJXAIOU",[[-1,3099,"\n"]],[3098,3098],[3097,3097]]],[1544342818146,["gjx16@GJXAIOU",[[-1,3138,"|"]],[3139,3139],[3138,3138]]],[1544342818281,["gjx16@GJXAIOU",[[-1,3137,"\n"]],[3138,3138],[3137,3137]]],[1544342818923,["gjx16@GJXAIOU",[[-1,3136,"| "]],[3137,3137],[3135,3135]]],[1544342819097,["gjx16@GJXAIOU",[[-1,3134,"\n"]],[3135,3135],[3134,3134]]],[1544342822613,["gjx16@GJXAIOU",[[1,3081,"\n"]],[3080,3080],[3081,3081]]],[1544342822724,["gjx16@GJXAIOU",[[1,3082,"\n"]],[3081,3081],[3082,3082]]],[1544342888356,[null,[[-1,523,"*"],[1,524,""],[-1,871,"|"],[1,872,"\n"],[-1,1711,"|"],[1,1712,"\n\n"],[-1,1718,"*"],[-1,1726,"*"],[1,1727,"化"],[1,1916,"\n"],[-1,1921,"*"],[-1,1932,"*"],[1,1933,"化"],[1,2056,"\n"],[-1,2063,"*"],[-1,2066,"*"],[1,2067,"："],[-1,2072,"**c+*"],[1,2077,"t库c++"],[-1,2083,"*"],[1,2084,"现"],[1,2952,"\n"],[-1,2959,"*"],[-1,2968,"*"],[1,2969,"资"],[1,2971,"\n"],[-1,2978,"*"],[-1,2993,"*"],[1,2994,"积"],[1,2997,"\n"],[-1,3002,"*"],[-1,3009,"**多*"],[1,3013,"和C多态"],[1,3083,"\n"],[-1,3090,"*"],[-1,3098,"*\n "],[1,3101,"础\n\n"]],[523,523],[3104,3104]]],[1544342888356,[null,[[1,523,"*"],[-1,523,""],[1,870,"|"],[-1,870,"\n"],[1,1710,"|"],[-1,1710,"\n\n"],[1,1718,"*"],[1,1725,"*"],[-1,1725,"化"],[-1,1915,"\n"],[1,1921,"*"],[1,1931,"*"],[-1,1931,"化"],[-1,2055,"\n"],[1,2063,"*"],[1,2065,"*"],[-1,2065,"："],[1,2071,"**c+*"],[-1,2071,"t库c++"],[1,2082,"*"],[-1,2082,"现"],[-1,2951,"\n"],[1,2959,"*"],[1,2967,"*"],[-1,2967,"资"],[-1,2970,"\n"],[1,2978,"*"],[1,2992,"*"],[-1,2992,"积"],[-1,2996,"\n"],[1,3002,"*"],[1,3008,"**多*"],[-1,3008,"和C多态"],[-1,3082,"\n"],[1,3090,"*"],[1,3097,"*\n "],[-1,3097,"础\n\n"]],[3104,3104],[523,523]]],[1544342829506,["gjx16@GJXAIOU",[[-1,3764,"**5.6.2****"]],[3764,3775],[3764,3764]]],[1544342832238,["gjx16@GJXAIOU",[[1,3764,"### （）"]],[3764,3764],[3770,3770]]],[1544342833613,["gjx16@GJXAIOU",[[1,3769,"二"]],[3769,3769],[3770,3770]]],[1544342836876,["gjx16@GJXAIOU",[[-1,3780,"**"]],[3782,3782],[3780,3780]]],[1544342843898,["gjx16@GJXAIOU",[[-1,4671,"**5.6.3****"]],[4671,4682],[4671,4671]]],[1544342846852,["gjx16@GJXAIOU",[[1,4671,"### （）"]],[4671,4671],[4677,4677]]],[1544342848460,["gjx16@GJXAIOU",[[1,4676,"三"]],[4676,4676],[4677,4677]]],[1544342851269,["gjx16@GJXAIOU",[[-1,4686,"**"]],[4688,4688],[4686,4686]]],[1544342860458,["gjx16@GJXAIOU",[[-1,6376,"**5.6.4****"]],[6376,6387],[6376,6376]]],[1544342864900,["gjx16@GJXAIOU",[[1,6376,"### （）"]],[6376,6376],[6382,6382]]],[1544342866587,["gjx16@GJXAIOU",[[1,6381,"四"]],[6381,6381],[6382,6382]]],[1544342870376,["gjx16@GJXAIOU",[[-1,6391,"**"]],[6393,6393],[6391,6391]]],[1544342875905,["gjx16@GJXAIOU",[[-1,6413,"****"]],[6417,6417],[6413,6413]]],[1544342880045,["gjx16@GJXAIOU",[[-1,6404,"**5.6.5."]],[6412,6412],[6404,6404]]],[1544342880692,["gjx16@GJXAIOU",[[1,6404,"\n"]],[6404,6404],[6405,6405]]],[1544342883558,["gjx16@GJXAIOU",[[1,6405,"### （）"]],[6405,6405],[6411,6411]]],[1544342886508,["gjx16@GJXAIOU",[[1,6410,"五"]],[6410,6410],[6411,6411]]],[1544342948371,[null,[[-1,523,"*"],[1,524,""],[-1,871,"|"],[1,872,"\n"],[-1,1711,"|"],[1,1712,"\n\n"],[-1,1718,"*"],[-1,1726,"*"],[1,1727,"化"],[1,1916,"\n"],[-1,1921,"*"],[-1,1932,"*"],[1,1933,"化"],[1,2056,"\n"],[-1,2063,"*"],[-1,2066,"*"],[1,2067,"："],[-1,2072,"**c+*"],[1,2077,"t库c++"],[-1,2083,"*"],[1,2084,"现"],[1,2952,"\n"],[-1,2959,"*"],[-1,2968,"*"],[1,2969,"资"],[1,2971,"\n"],[-1,2978,"*"],[-1,2993,"*"],[1,2994,"积"],[1,2997,"\n"],[-1,3002,"*"],[-1,3009,"**多*"],[1,3013,"和C多态"],[1,3083,"\n"],[-1,3090,"*"],[-1,3098,"*\n "],[1,3101,"础\n\n"],[1,3764,"\n"],[-1,3771,"*"],[-1,3780,"*"],[1,3781,"数"],[1,4671,"\n"],[-1,4678,"*"],[-1,4686,"*"],[1,4687,"用"],[1,6376,"\n"],[-1,6383,"*"],[-1,6391,"*"],[1,6392,"用"],[1,6405,"\n"],[-1,6412,".*"],[1,6414,"C"]],[523,523],[6415,6415]]],[1544342948372,[null,[[1,523,"*"],[-1,523,""],[1,870,"|"],[-1,870,"\n"],[1,1710,"|"],[-1,1710,"\n\n"],[1,1718,"*"],[1,1725,"*"],[-1,1725,"化"],[-1,1915,"\n"],[1,1921,"*"],[1,1931,"*"],[-1,1931,"化"],[-1,2055,"\n"],[1,2063,"*"],[1,2065,"*"],[-1,2065,"："],[1,2071,"**c+*"],[-1,2071,"t库c++"],[1,2082,"*"],[-1,2082,"现"],[-1,2951,"\n"],[1,2959,"*"],[1,2967,"*"],[-1,2967,"资"],[-1,2970,"\n"],[1,2978,"*"],[1,2992,"*"],[-1,2992,"积"],[-1,2996,"\n"],[1,3002,"*"],[1,3008,"**多*"],[-1,3008,"和C多态"],[-1,3082,"\n"],[1,3090,"*"],[1,3097,"*\n "],[-1,3097,"础\n\n"],[-1,3763,"\n"],[1,3771,"*"],[1,3779,"*"],[-1,3779,"数"],[-1,4670,"\n"],[1,4678,"*"],[1,4685,"*"],[-1,4685,"用"],[-1,6375,"\n"],[1,6383,"*"],[1,6390,"*"],[-1,6390,"用"],[-1,6404,"\n"],[1,6412,".*"],[-1,6412,"C"]],[6415,6415],[523,523]]],[1544342889943,["gjx16@GJXAIOU",[[-1,6423,"**"]],[6425,6425],[6423,6423]]],[1544342897441,["gjx16@GJXAIOU",[[-1,7558,"**5.6.6****"]],[7558,7569],[7558,7558]]],[1544342901186,["gjx16@GJXAIOU",[[1,7558,"### （）"]],[7558,7558],[7564,7564]]],[1544342902834,["gjx16@GJXAIOU",[[1,7563,"六"]],[7563,7563],[7564,7564]]],[1544343068363,[null,[[-1,523,"*"],[1,524,""],[-1,871,"|"],[1,872,"\n"],[-1,1711,"|"],[1,1712,"\n\n"],[-1,1718,"*"],[-1,1726,"*"],[1,1727,"化"],[1,1916,"\n"],[-1,1921,"*"],[-1,1932,"*"],[1,1933,"化"],[1,2056,"\n"],[-1,2063,"*"],[-1,2066,"*"],[1,2067,"："],[-1,2072,"**c+*"],[1,2077,"t库c++"],[-1,2083,"*"],[1,2084,"现"],[1,2952,"\n"],[-1,2959,"*"],[-1,2968,"*"],[1,2969,"资"],[1,2971,"\n"],[-1,2978,"*"],[-1,2993,"*"],[1,2994,"积"],[1,2997,"\n"],[-1,3002,"*"],[-1,3009,"**多*"],[1,3013,"和C多态"],[1,3083,"\n"],[-1,3090,"*"],[-1,3098,"*\n "],[1,3101,"础\n\n"],[1,3764,"\n"],[-1,3771,"*"],[-1,3780,"*"],[1,3781,"数"],[1,4671,"\n"],[-1,4678,"*"],[-1,4686,"*"],[1,4687,"用"],[1,6376,"\n"],[-1,6383,"*"],[-1,6391,"*"],[1,6392,"用"],[1,6403,"\n"],[-1,6412,".*"],[1,6414,"C"],[-1,6423,"*"],[1,6424,"例"],[1,7558,"\n"],[-1,7565,"*"]],[523,523],[7565,7565]]],[1544343068363,[null,[[1,523,"*"],[-1,523,""],[1,870,"|"],[-1,870,"\n"],[1,1710,"|"],[-1,1710,"\n\n"],[1,1718,"*"],[1,1725,"*"],[-1,1725,"化"],[-1,1915,"\n"],[1,1921,"*"],[1,1931,"*"],[-1,1931,"化"],[-1,2055,"\n"],[1,2063,"*"],[1,2065,"*"],[-1,2065,"："],[1,2071,"**c+*"],[-1,2071,"t库c++"],[1,2082,"*"],[-1,2082,"现"],[-1,2951,"\n"],[1,2959,"*"],[1,2967,"*"],[-1,2967,"资"],[-1,2970,"\n"],[1,2978,"*"],[1,2992,"*"],[-1,2992,"积"],[-1,2996,"\n"],[1,3002,"*"],[1,3008,"**多*"],[-1,3008,"和C多态"],[-1,3082,"\n"],[1,3090,"*"],[1,3097,"*\n "],[-1,3097,"础\n\n"],[-1,3763,"\n"],[1,3771,"*"],[1,3779,"*"],[-1,3779,"数"],[-1,4670,"\n"],[1,4678,"*"],[1,4685,"*"],[-1,4685,"用"],[-1,6375,"\n"],[1,6383,"*"],[1,6390,"*"],[-1,6390,"用"],[-1,6402,"\n"],[1,6412,".*"],[-1,6412,"C"],[1,6422,"*"],[-1,6422,"例"],[-1,7557,"\n"],[1,7565,"*"]],[7565,7565],[523,523]]],[1544343040802,["gjx16@GJXAIOU",[[-1,21,"5、纯虚函数和抽象类"]],[21,31],[21,21]]],[1544343041781,["gjx16@GJXAIOU",[[-1,22,"\n"]],[21,21],[20,20]]],[1544343045388,["gjx16@GJXAIOU",[[-1,21,"\n"]],[21,21],[20,20]]],[1544345768430,[null,[[-1,511,"*"],[1,512,""],[-1,859,"|"],[1,860,"\n"],[-1,1699,"|"],[1,1700,"\n\n"],[-1,1706,"*"],[-1,1714,"*"],[1,1715,"化"],[1,1904,"\n"],[-1,1909,"*"],[-1,1920,"*"],[1,1921,"化"],[1,2044,"\n"],[-1,2051,"*"],[-1,2054,"*"],[1,2055,"："],[-1,2060,"**c+*"],[1,2065,"t库c++"],[-1,2071,"*"],[1,2072,"现"],[1,2940,"\n"],[-1,2947,"*"],[-1,2956,"*"],[1,2957,"资"],[1,2959,"\n"],[-1,2966,"*"],[-1,2981,"*"],[1,2982,"积"],[1,2985,"\n"],[-1,2990,"*"],[-1,2997,"**多*"],[1,3001,"和C多态"],[1,3071,"\n"],[-1,3078,"*"],[-1,3086,"*\n "],[1,3089,"础\n\n"],[1,3752,"\n"],[-1,3759,"*"],[-1,3768,"*"],[1,3769,"数"],[1,4659,"\n"],[-1,4666,"*"],[-1,4674,"*"],[1,4675,"用"],[1,6364,"\n"],[-1,6371,"*"],[-1,6379,"*"],[1,6380,"用"],[1,6391,"\n"],[-1,6400,".*"],[1,6402,"C"],[-1,6411,"*"],[1,6412,"例"],[1,7546,"\n"],[-1,7553,"*"]],[511,511],[7553,7553]]],[1544345768430,[null,[[1,511,"*"],[-1,511,""],[1,858,"|"],[-1,858,"\n"],[1,1698,"|"],[-1,1698,"\n\n"],[1,1706,"*"],[1,1713,"*"],[-1,1713,"化"],[-1,1903,"\n"],[1,1909,"*"],[1,1919,"*"],[-1,1919,"化"],[-1,2043,"\n"],[1,2051,"*"],[1,2053,"*"],[-1,2053,"："],[1,2059,"**c+*"],[-1,2059,"t库c++"],[1,2070,"*"],[-1,2070,"现"],[-1,2939,"\n"],[1,2947,"*"],[1,2955,"*"],[-1,2955,"资"],[-1,2958,"\n"],[1,2966,"*"],[1,2980,"*"],[-1,2980,"积"],[-1,2984,"\n"],[1,2990,"*"],[1,2996,"**多*"],[-1,2996,"和C多态"],[-1,3070,"\n"],[1,3078,"*"],[1,3085,"*\n "],[-1,3085,"础\n\n"],[-1,3751,"\n"],[1,3759,"*"],[1,3767,"*"],[-1,3767,"数"],[-1,4658,"\n"],[1,4666,"*"],[1,4673,"*"],[-1,4673,"用"],[-1,6363,"\n"],[1,6371,"*"],[1,6378,"*"],[-1,6378,"用"],[-1,6390,"\n"],[1,6400,".*"],[-1,6400,"C"],[1,6410,"*"],[-1,6410,"例"],[-1,7545,"\n"],[1,7553,"*"]],[7553,7553],[511,511]]],[1544345722778,["gjx16@GJXAIOU",[[1,225,"·"]],[225,225],[226,226]]],[1544345723887,["gjx16@GJXAIOU",[[-1,225,"·"]],[226,226],[225,225]]],[1544345725234,["gjx16@GJXAIOU",[[1,225,"```"]],[225,225],[228,228]]],[1544345725278,["gjx16@GJXAIOU",[[1,228,"language\n```\n"]],[228,228],[228,236]]],[1544345726558,["gjx16@GJXAIOU",[[-1,228,"language"],[1,236,"c"]],[228,236],[229,229]]],[1544345726839,["gjx16@GJXAIOU",[[1,229,"pp"]],[229,229],[231,231]]],[1544345727264,["gjx16@GJXAIOU",[[1,232,"\n"]],[231,231],[232,232]]],[1544345729019,["gjx16@GJXAIOU",[[1,232,"//纯虚函数抽象类语法基础\n\n\n#include \"iostream\"\nusing namespace std;\n\nclass Figure\n{\npublic:\n\tvirtual void Area() = 0;   //声明一个纯虚函数，基类中不需要实现\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\nclass circle :public Figure\n{\npublic:\n\tcircle(int r,int a, int b)\n\t{\n\t\tthis->r = r;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"圆的面积 \" << 3.14*r*r << endl;\n\t}\nprivate:\n\tint r;\n};\n\n\nclass rectangle :public Figure\n{\npublic:\n\trectangle(int length, int width, int a, int b)\n\t{\n\t\tthis->length = length;\n\t\tthis->width = width;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"长方形的面积 \" << length * width << endl;\n\t}\nprivate:\n\tint length;\n\tint width;\n};\n\nvoid getArea(Figure *base)\n{\n\tbase->Area();\n}\n\n\n\nint main()\n{\n\t\n\t//Figure f1;//这是错误的，抽象类不能实例化\n\tFigure *p = NULL;   //但是可以使用指针和引用\n\tcircle c1(2, 1, 2);\n\trectangle r1(1, 2, 3, 4);\n\n\tgetArea(&c1);\n\tgetArea(&r1);\n\tsystem(\"pause\");\n\treturn 0;\n}"]],[232,232],[1101,1101]]],[1544345888428,[null,[[-1,1392,"*"],[1,1393,""],[-1,1740,"|"],[1,1741,"\n"],[-1,2580,"|"],[1,2581,"\n\n"],[-1,2587,"*"],[-1,2595,"*"],[1,2596,"化"],[1,2785,"\n"],[-1,2790,"*"],[-1,2801,"*"],[1,2802,"化"],[1,2925,"\n"],[-1,2932,"*"],[-1,2935,"*"],[1,2936,"："],[-1,2941,"**c+*"],[1,2946,"t库c++"],[-1,2952,"*"],[1,2953,"现"],[1,3821,"\n"],[-1,3828,"*"],[-1,3837,"*"],[1,3838,"资"],[1,3840,"\n"],[-1,3847,"*"],[-1,3862,"*"],[1,3863,"积"],[1,3866,"\n"],[-1,3871,"*"],[-1,3878,"**多*"],[1,3882,"和C多态"],[1,3952,"\n"],[-1,3959,"*"],[-1,3967,"*\n "],[1,3970,"础\n\n"],[1,4633,"\n"],[-1,4640,"*"],[-1,4649,"*"],[1,4650,"数"],[1,5540,"\n"],[-1,5547,"*"],[-1,5555,"*"],[1,5556,"用"],[1,7245,"\n"],[-1,7252,"*"],[-1,7260,"*"],[1,7261,"用"],[1,7272,"\n"],[-1,7281,".*"],[1,7283,"C"],[-1,7292,"*"],[1,7293,"例"],[1,8427,"\n"],[-1,8434,"*"]],[1392,1392],[8434,8434]]],[1544345888428,[null,[[1,1392,"*"],[-1,1392,""],[1,1739,"|"],[-1,1739,"\n"],[1,2579,"|"],[-1,2579,"\n\n"],[1,2587,"*"],[1,2594,"*"],[-1,2594,"化"],[-1,2784,"\n"],[1,2790,"*"],[1,2800,"*"],[-1,2800,"化"],[-1,2924,"\n"],[1,2932,"*"],[1,2934,"*"],[-1,2934,"："],[1,2940,"**c+*"],[-1,2940,"t库c++"],[1,2951,"*"],[-1,2951,"现"],[-1,3820,"\n"],[1,3828,"*"],[1,3836,"*"],[-1,3836,"资"],[-1,3839,"\n"],[1,3847,"*"],[1,3861,"*"],[-1,3861,"积"],[-1,3865,"\n"],[1,3871,"*"],[1,3877,"**多*"],[-1,3877,"和C多态"],[-1,3951,"\n"],[1,3959,"*"],[1,3966,"*\n "],[-1,3966,"础\n\n"],[-1,4632,"\n"],[1,4640,"*"],[1,4648,"*"],[-1,4648,"数"],[-1,5539,"\n"],[1,5547,"*"],[1,5554,"*"],[-1,5554,"用"],[-1,7244,"\n"],[1,7252,"*"],[1,7259,"*"],[-1,7259,"用"],[-1,7271,"\n"],[1,7281,".*"],[-1,7281,"C"],[1,7291,"*"],[-1,7291,"例"],[-1,8426,"\n"],[1,8434,"*"]],[8434,8434],[1392,1392]]],[1544345882001,["gjx16@GJXAIOU",[[1,1101," "]],[1101,1101],[1102,1102]]],[1544346728440,[null,[[-1,1393,"*"],[1,1394,""],[-1,1741,"|"],[1,1742,"\n"],[-1,2581,"|"],[1,2582,"\n\n"],[-1,2588,"*"],[-1,2596,"*"],[1,2597,"化"],[1,2786,"\n"],[-1,2791,"*"],[-1,2802,"*"],[1,2803,"化"],[1,2926,"\n"],[-1,2933,"*"],[-1,2936,"*"],[1,2937,"："],[-1,2942,"**c+*"],[1,2947,"t库c++"],[-1,2953,"*"],[1,2954,"现"],[1,3822,"\n"],[-1,3829,"*"],[-1,3838,"*"],[1,3839,"资"],[1,3841,"\n"],[-1,3848,"*"],[-1,3863,"*"],[1,3864,"积"],[1,3867,"\n"],[-1,3872,"*"],[-1,3879,"**多*"],[1,3883,"和C多态"],[1,3953,"\n"],[-1,3960,"*"],[-1,3968,"*\n "],[1,3971,"础\n\n"],[1,4634,"\n"],[-1,4641,"*"],[-1,4650,"*"],[1,4651,"数"],[1,5541,"\n"],[-1,5548,"*"],[-1,5556,"*"],[1,5557,"用"],[1,7246,"\n"],[-1,7253,"*"],[-1,7261,"*"],[1,7262,"用"],[1,7273,"\n"],[-1,7282,".*"],[1,7284,"C"],[-1,7293,"*"],[1,7294,"例"],[1,8428,"\n"],[-1,8435,"*"]],[1393,1393],[8435,8435]]],[1544346728440,[null,[[1,1393,"*"],[-1,1393,""],[1,1740,"|"],[-1,1740,"\n"],[1,2580,"|"],[-1,2580,"\n\n"],[1,2588,"*"],[1,2595,"*"],[-1,2595,"化"],[-1,2785,"\n"],[1,2791,"*"],[1,2801,"*"],[-1,2801,"化"],[-1,2925,"\n"],[1,2933,"*"],[1,2935,"*"],[-1,2935,"："],[1,2941,"**c+*"],[-1,2941,"t库c++"],[1,2952,"*"],[-1,2952,"现"],[-1,3821,"\n"],[1,3829,"*"],[1,3837,"*"],[-1,3837,"资"],[-1,3840,"\n"],[1,3848,"*"],[1,3862,"*"],[-1,3862,"积"],[-1,3866,"\n"],[1,3872,"*"],[1,3878,"**多*"],[-1,3878,"和C多态"],[-1,3952,"\n"],[1,3960,"*"],[1,3967,"*\n "],[-1,3967,"础\n\n"],[-1,4633,"\n"],[1,4641,"*"],[1,4649,"*"],[-1,4649,"数"],[-1,5540,"\n"],[1,5548,"*"],[1,5555,"*"],[-1,5555,"用"],[-1,7245,"\n"],[1,7253,"*"],[1,7260,"*"],[-1,7260,"用"],[-1,7272,"\n"],[1,7282,".*"],[-1,7282,"C"],[1,7292,"*"],[-1,7292,"例"],[-1,8427,"\n"],[1,8435,"*"]],[8435,8435],[1393,1393]]],[1544346683549,["gjx16@GJXAIOU",[[-1,1849,"class Interface1\n\n{\n\npublic:\n\n virtual void print() = 0;\n\n virtual int add(int a, int b) = 0;\n\n};\n\nclass Interface2\n\n{\n\npublic:\n\n virtual void print() = 0;\n\n virtual int add(int a, int b) = 0;\n\n virtual int minus(int a, int b) = 0;\n\n};\n\nclass parent\n\n{\n\npublic:\n\n int a;\n\n};\n\nclass Child : public parent, public Interface1, public Interface2\n\n{\n\npublic: \n\n void print()\n\n {\n\n cout<<\"Child::print\"<<endl;\n\n }\n\n int add(int a, int b)\n\n {\n\n return a + b;\n\n }\n\n int minus(int a, int b)\n\n {\n\n return a - b;\n\n }\n\n};\n\nint main()\n\n{\n\n Child c;\n\n c.print();\n\n cout<<c.add(3, 5)<<endl;\n\n cout<<c.minus(4, 6)<<endl;\n\n Interface1* i1 = &c;\n\n Interface2* i2 = &c;\n\n cout<<i1->add(7, 8)<<endl;\n\n cout<<i2->add(7, 8)<<endl;\n\n system(\"pause\");\n\n}\n"]],[1849,2580],[1849,1849]]],[1544346687911,["gjx16@GJXAIOU",[[1,1849,"```"]],[1849,1849],[1852,1852]]],[1544346687952,["gjx16@GJXAIOU",[[1,1852,"language\n```\n"]],[1852,1852],[1852,1860]]],[1544346689719,["gjx16@GJXAIOU",[[-1,1852,"language"],[1,1860,"c"]],[1852,1860],[1853,1853]]],[1544346690040,["gjx16@GJXAIOU",[[1,1853,"pp"]],[1853,1853],[1855,1855]]],[1544346690396,["gjx16@GJXAIOU",[[1,1856,"\n"]],[1855,1855],[1856,1856]]],[1544346691451,["gjx16@GJXAIOU",[[1,1856,"//抽象类在多继承中的应用\n\n#include \"iostream\"\nusing namespace std;\n\nclass Interface1\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n};\n\nclass Interface2\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n\tvirtual int minus(int a, int b) = 0;\n};\n\nclass parent\n{\npublic:\n\tint a;\n};\n\nclass Child : public parent, public Interface1, public Interface2\n{\npublic:\n\tvoid print()\n\t{\n\t\tcout << \"Child::print\" << endl;\n\t}\n\n\tint add(int a, int b)\n\t{\n\t\treturn a + b;\n\t}\n\n\tint minus(int a, int b)\n\t{\n\t\treturn a - b;\n\t}\n\n};\n\nint main()\n{\n\n\tChild c;\n\tc.print();\n\tcout << c.add(3, 5) << endl;\n\tcout << c.minus(4, 6) << endl;\n\n\tInterface1* i1 = &c;\n\tInterface2* i2 = &c;\n\n\tcout << i1->add(7, 8) << endl;\n\tcout << i2->add(7, 8) << endl;\n\n\tsystem(\"pause\");\n\n}"]],[1856,1856],[2632,2632]]],[1544346719428,["gjx16@GJXAIOU",[[-1,2693,"\n"]],[2693,2693],[2692,2692]]],[1544346722998,["gjx16@GJXAIOU",[[-1,2779,"\n"]],[2779,2779],[2778,2778]]],[1544346788532,[null,[[-1,1393,"*"],[1,1394,""],[-1,1741,"|"],[1,1742,"\n"],[1,1849,"\n"],[-1,2638,"|"],[1,2639,"\n"],[-1,2645,"*"],[-1,2653,"*"],[1,2654,"化"],[1,2841,"\n"],[-1,2846,"*"],[-1,2857,"*"],[1,2858,"化"],[1,2981,"\n"],[-1,2988,"*"],[-1,2991,"*"],[1,2992,"："],[-1,2997,"**c+*"],[1,3002,"t库c++"],[-1,3008,"*"],[1,3009,"现"],[1,3877,"\n"],[-1,3884,"*"],[-1,3893,"*"],[1,3894,"资"],[1,3896,"\n"],[-1,3903,"*"],[-1,3918,"*"],[1,3919,"积"],[1,3922,"\n"],[-1,3927,"*"],[-1,3934,"**多*"],[1,3938,"和C多态"],[1,4008,"\n"],[-1,4015,"*"],[-1,4023,"*\n "],[1,4026,"础\n\n"],[1,4689,"\n"],[-1,4696,"*"],[-1,4705,"*"],[1,4706,"数"],[1,5596,"\n"],[-1,5603,"*"],[-1,5611,"*"],[1,5612,"用"],[1,7301,"\n"],[-1,7308,"*"],[-1,7316,"*"],[1,7317,"用"],[1,7328,"\n"],[-1,7337,".*"],[1,7339,"C"],[-1,7348,"*"],[1,7349,"例"],[1,8483,"\n"],[-1,8490,"*"]],[1393,1393],[8490,8490]]],[1544346788532,[null,[[1,1393,"*"],[-1,1393,""],[1,1740,"|"],[-1,1740,"\n"],[-1,1848,"\n"],[1,2638,"|"],[-1,2638,"\n"],[1,2645,"*"],[1,2652,"*"],[-1,2652,"化"],[-1,2840,"\n"],[1,2846,"*"],[1,2856,"*"],[-1,2856,"化"],[-1,2980,"\n"],[1,2988,"*"],[1,2990,"*"],[-1,2990,"："],[1,2996,"**c+*"],[-1,2996,"t库c++"],[1,3007,"*"],[-1,3007,"现"],[-1,3876,"\n"],[1,3884,"*"],[1,3892,"*"],[-1,3892,"资"],[-1,3895,"\n"],[1,3903,"*"],[1,3917,"*"],[-1,3917,"积"],[-1,3921,"\n"],[1,3927,"*"],[1,3933,"**多*"],[-1,3933,"和C多态"],[-1,4007,"\n"],[1,4015,"*"],[1,4022,"*\n "],[-1,4022,"础\n\n"],[-1,4688,"\n"],[1,4696,"*"],[1,4704,"*"],[-1,4704,"数"],[-1,5595,"\n"],[1,5603,"*"],[1,5610,"*"],[-1,5610,"用"],[-1,7300,"\n"],[1,7308,"*"],[1,7315,"*"],[-1,7315,"用"],[-1,7327,"\n"],[1,7337,".*"],[-1,7337,"C"],[1,7347,"*"],[-1,7347,"例"],[-1,8482,"\n"],[1,8490,"*"]],[8490,8490],[1393,1393]]],[1544346736359,["gjx16@GJXAIOU",[[1,2841,"\n"]],[2837,2837],[2838,2838]]],[1544346739767,["gjx16@GJXAIOU",[[1,2838,"```"]],[2838,2838],[2841,2841]]],[1544346739812,["gjx16@GJXAIOU",[[1,2841,"language\n```\n"]],[2841,2841],[2841,2849]]],[1544346740862,["gjx16@GJXAIOU",[[-1,2841,"language"],[1,2849,"c"]],[2841,2849],[2842,2842]]],[1544346741613,["gjx16@GJXAIOU",[[1,2842,"pp"]],[2842,2842],[2844,2844]]],[1544346742459,["gjx16@GJXAIOU",[[1,2845,"\n"]],[2844,2844],[2845,2845]]],[1544352858374,[null,[[-1,1393,"*"],[1,1394,""],[-1,1741,"|"],[1,1742,"\n"],[1,1849,"\n"],[-1,2638,"|"],[1,2639,"\n"],[-1,2645,"*"],[-1,2653,"*"],[1,2654,"化"],[1,2838,"\n"],[-1,2859,"*"],[-1,2870,"*"],[1,2871,"化"],[1,2994,"\n"],[-1,3001,"*"],[-1,3004,"*"],[1,3005,"："],[-1,3010,"**c+*"],[1,3015,"t库c++"],[-1,3021,"*"],[1,3022,"现"],[1,3890,"\n"],[-1,3897,"*"],[-1,3906,"*"],[1,3907,"资"],[1,3909,"\n"],[-1,3916,"*"],[-1,3931,"*"],[1,3932,"积"],[1,3935,"\n"],[-1,3940,"*"],[-1,3947,"**多*"],[1,3951,"和C多态"],[1,4021,"\n"],[-1,4028,"*"],[-1,4036,"*\n "],[1,4039,"础\n\n"],[1,4702,"\n"],[-1,4709,"*"],[-1,4718,"*"],[1,4719,"数"],[1,5609,"\n"],[-1,5616,"*"],[-1,5624,"*"],[1,5625,"用"],[1,7314,"\n"],[-1,7321,"*"],[-1,7329,"*"],[1,7330,"用"],[1,7341,"\n"],[-1,7350,".*"],[1,7352,"C"],[-1,7361,"*"],[1,7362,"例"],[1,8496,"\n"],[-1,8503,"*"]],[1393,1393],[8503,8503]]],[1544352858375,[null,[[1,1393,"*"],[-1,1393,""],[1,1740,"|"],[-1,1740,"\n"],[-1,1848,"\n"],[1,2638,"|"],[-1,2638,"\n"],[1,2645,"*"],[1,2652,"*"],[-1,2652,"化"],[-1,2837,"\n"],[1,2859,"*"],[1,2869,"*"],[-1,2869,"化"],[-1,2993,"\n"],[1,3001,"*"],[1,3003,"*"],[-1,3003,"："],[1,3009,"**c+*"],[-1,3009,"t库c++"],[1,3020,"*"],[-1,3020,"现"],[-1,3889,"\n"],[1,3897,"*"],[1,3905,"*"],[-1,3905,"资"],[-1,3908,"\n"],[1,3916,"*"],[1,3930,"*"],[-1,3930,"积"],[-1,3934,"\n"],[1,3940,"*"],[1,3946,"**多*"],[-1,3946,"和C多态"],[-1,4020,"\n"],[1,4028,"*"],[1,4035,"*\n "],[-1,4035,"础\n\n"],[-1,4701,"\n"],[1,4709,"*"],[1,4717,"*"],[-1,4717,"数"],[-1,5608,"\n"],[1,5616,"*"],[1,5623,"*"],[-1,5623,"用"],[-1,7313,"\n"],[1,7321,"*"],[1,7328,"*"],[-1,7328,"用"],[-1,7340,"\n"],[1,7350,".*"],[-1,7350,"C"],[1,7360,"*"],[-1,7360,"例"],[-1,8495,"\n"],[1,8503,"*"]],[8503,8503],[1393,1393]]],[1544352853631,["gjx16@GJXAIOU",[[1,2845,"//抽象类知识点的强化\n\n\n#include \"iostream\"\n#include \"sstream\"\nusing namespace std;\n\nclass programmer\n{\npublic:\n\tvirtual void getSal() = 0;\nprotected:\nprivate:\n};\n\nclass junior_programmer :public programmer\n{\npublic:\n\tjunior_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"junior_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\nclass mid_programmer :public programmer\n{\npublic:\n\tmid_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"mid_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n\nclass adv_programmer :public programmer\n{\npublic:\n\tadv_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"adv_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n//接下来为后期可以拓展的部分\n\n\nclass architect :public programmer\n{\npublic:\n\tarchitect(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"architect:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n//以上为后期拓展部分\n\nvoid pro_sale(programmer *base)\n{\n\tbase->getSal();\n}\n\n\nint main()\n{\n\tjunior_programmer jp(\"张三\",\"初级\",2000);\n\tmid_programmer mp(\"小张\", \"中级\", 8000);\n\tadv_programmer ap(\"小李\", \"高级\", 20394);\n\n\tpro_sale(&jp);\n\tpro_sale(&mp);\n\tpro_sale(&ap);\n\n\n\t//后期新增程序的调用\n\n\tarchitect ar(\"架构师\", \"牛\", 121332);\n\tpro_sale(&ar);\n\tsystem(\"pause\");\n\treturn 0; \n\n}"]],[2845,2845],[4839,4839]]],[1544352855991,["gjx16@GJXAIOU",[[1,2838,"\n"]],[2837,2837],[2838,2838]]],[1544352857223,["gjx16@GJXAIOU",[[1,2838,"diao"]],[2838,2838],[2842,2842]]],[1544352858039,["gjx16@GJXAIOU",[[-1,2839,"iao"]],[2842,2842],[2839,2839]]],[1544352880913,[null,[[-1,1393,"*"],[1,1394,""],[-1,1741,"|"],[1,1742,"\n"],[1,1849,"\n"],[-1,2638,"|"],[1,2639,"\n"],[-1,2645,"*"],[-1,2653,"*"],[1,2654,"化"],[-1,2838,""],[1,2838,"\n"],[-1,4855,"*"],[-1,4866,"*"],[1,4867,"化"],[1,4990,"\n"],[-1,4997,"*"],[-1,5000,"*"],[1,5001,"："],[-1,5006,"**c+*"],[1,5011,"t库c++"],[-1,5017,"*"],[1,5018,"现"],[1,5886,"\n"],[-1,5893,"*"],[-1,5902,"*"],[1,5903,"资"],[1,5905,"\n"],[-1,5912,"*"],[-1,5927,"*"],[1,5928,"积"],[1,5931,"\n"],[-1,5936,"*"],[-1,5943,"**多*"],[1,5947,"和C多态"],[1,6017,"\n"],[-1,6024,"*"],[-1,6032,"*\n "],[1,6035,"础\n\n"],[1,6698,"\n"],[-1,6705,"*"],[-1,6714,"*"],[1,6715,"数"],[1,7605,"\n"],[-1,7612,"*"],[-1,7620,"*"],[1,7621,"用"],[1,9310,"\n"],[-1,9317,"*"],[-1,9325,"*"],[1,9326,"用"],[1,9337,"\n"],[-1,9346,".*"],[1,9348,"C"],[-1,9357,"*"],[1,9358,"例"],[1,10492,"\n"],[-1,10499,"*"]],[1393,1393],[10499,10499]]],[1544352880913,[null,[[1,1393,"*"],[-1,1393,""],[1,1740,"|"],[-1,1740,"\n"],[-1,1848,"\n"],[1,2638,"|"],[-1,2638,"\n"],[1,2645,"*"],[1,2652,"*"],[-1,2652,"化"],[1,2837,""],[-1,2837,"\n"],[1,4855,"*"],[1,4865,"*"],[-1,4865,"化"],[-1,4989,"\n"],[1,4997,"*"],[1,4999,"*"],[-1,4999,"："],[1,5005,"**c+*"],[-1,5005,"t库c++"],[1,5016,"*"],[-1,5016,"现"],[-1,5885,"\n"],[1,5893,"*"],[1,5901,"*"],[-1,5901,"资"],[-1,5904,"\n"],[1,5912,"*"],[1,5926,"*"],[-1,5926,"积"],[-1,5930,"\n"],[1,5936,"*"],[1,5942,"**多*"],[-1,5942,"和C多态"],[-1,6016,"\n"],[1,6024,"*"],[1,6031,"*\n "],[-1,6031,"础\n\n"],[-1,6697,"\n"],[1,6705,"*"],[1,6713,"*"],[-1,6713,"数"],[-1,7604,"\n"],[1,7612,"*"],[1,7619,"*"],[-1,7619,"用"],[-1,9309,"\n"],[1,9317,"*"],[1,9324,"*"],[-1,9324,"用"],[-1,9336,"\n"],[1,9346,".*"],[-1,9346,"C"],[1,9356,"*"],[-1,9356,"例"],[-1,10491,"\n"],[1,10499,"*"]],[10499,10499],[1393,1393]]],[1544352858513,["gjx16@GJXAIOU",[[-1,2838,"d"]],[2839,2839],[2838,2838]]],[1544352860256,["gjx16@GJXAIOU",[[1,2838,"~~~~"]],[2838,2838],[2840,2840]]],[1544352878461,["gjx16@GJXAIOU",[[1,2840,"调用的时候参数有点问题"]],[2840,2840],[2851,2851]]]],null,"gjx16@GJXAIOU"],["012f993c-5149-4efd-9061-2a0eafb03b9f",1544354205114,"# C_PP_章五 纯虚函数和抽象类\n\n\n## 一、基本概念\n![image071]($resource/image071.png)\n![image072]($resource/image072.png)\n![image073]($resource/image073.png)\n\n\n\n## 二、抽象类案例\n![image074]($resource/image074.png)\n![image075]($resource/image075.png)\n```cpp\n//纯虚函数抽象类语法基础\n\n\n#include \"iostream\"\nusing namespace std;\n\nclass Figure\n{\npublic:\n\tvirtual void Area() = 0;   //声明一个纯虚函数，基类中不需要实现\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\nclass circle :public Figure\n{\npublic:\n\tcircle(int r,int a, int b)\n\t{\n\t\tthis->r = r;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"圆的面积 \" << 3.14*r*r << endl;\n\t}\nprivate:\n\tint r;\n};\n\n\nclass rectangle :public Figure\n{\npublic:\n\trectangle(int length, int width, int a, int b)\n\t{\n\t\tthis->length = length;\n\t\tthis->width = width;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"长方形的面积 \" << length * width << endl;\n\t}\nprivate:\n\tint length;\n\tint width;\n};\n\nvoid getArea(Figure *base)\n{\n\tbase->Area();\n}\n\n\n\nint main()\n{\n\t\n\t//Figure f1;//这是错误的，抽象类不能实例化\n\tFigure *p = NULL;   //但是可以使用指针和引用\n\tcircle c1(2, 1, 2);\n\trectangle r1(1, 2, 3, 4);\n\n\tgetArea(&c1);\n\tgetArea(&r1);\n\tsystem(\"pause\");\n\treturn 0;\n} \n```\n\n\n## 三、抽象类在多继承中的应用\n\nC++中没有Java中的接口概念，抽象类可以模拟Java中的接口类。（接口和协议）\n\n\n\n### （一）有关多继承的说明\n\n**工程上的多继承**\n\n* 被实际开发经验抛弃的多继承\n* 工程开发中真正意义上的多继承是几乎不被使用的\n* 多重继承带来的代码复杂性远多于其带来的便利\n* 多重继承对代码维护性上的影响是灾难性的\n* 在设计方法上，任何多继承都可以用单继承代替 \n\n**多继承中的二义性和多继承不能解决的问题 **\n![image076]($resource/image076.png)\n\n\n### （二）多继承的应用场景\n\nC++中是否有Java中的接口概念？\n\n绝大多数面向对象语言都不支持多继承\n\n绝大多数面向对象语言都支持接口的概念\n\nC++中没有接口的概念\n\nC++中可以使用纯虚函数实现接口\n\n**接口类中只有函数原型定义，没有任何数据的定义**。\n\nclass Interface \n\n{\n\n public:\n\n virtual void func1() = 0;\n\n virtual void func2(int i) = 0;\n\n virtual void func3(int i) = 0;\n\n};\n\n实际工程经验证明\n\n多重继承接口不会带来二义性和复杂性等问题 \n\n多重继承可以通过精心设计用单继承和接口来代替\n\n接口类只是一个功能说明，而不是功能实现。\n\n子类需要根据功能说明定义功能实现。\n\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n\nC++中没有接口的概念\n\nC++中可以使用纯虚函数实现接口\n\n接口类中只有函数原型定义，没有任何数据的定义。\n\n*/\n\n```cpp\n//抽象类在多继承中的应用\n\n#include \"iostream\"\nusing namespace std;\n\nclass Interface1\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n};\n\nclass Interface2\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n\tvirtual int minus(int a, int b) = 0;\n};\n\nclass parent\n{\npublic:\n\tint a;\n};\n\nclass Child : public parent, public Interface1, public Interface2\n{\npublic:\n\tvoid print()\n\t{\n\t\tcout << \"Child::print\" << endl;\n\t}\n\n\tint add(int a, int b)\n\t{\n\t\treturn a + b;\n\t}\n\n\tint minus(int a, int b)\n\t{\n\t\treturn a - b;\n\t}\n\n};\n\nint main()\n{\n\n\tChild c;\n\tc.print();\n\tcout << c.add(3, 5) << endl;\n\tcout << c.minus(4, 6) << endl;\n\n\tInterface1* i1 = &c;\n\tInterface2* i2 = &c;\n\n\tcout << i1->add(7, 8) << endl;\n\tcout << i2->add(7, 8) << endl;\n\n\tsystem(\"pause\");\n\n}\n```\n\n\n\n## 四、抽象类知识点强化\n\n/*\n\n编写一个C++程序, 计算程序员( programmer )工资 \n 1 要求能计算出初级程序员( junior_programmer ) 中级程序员 ( mid_programmer )高级程序员( adv_programmer)的工资\n 2 要求利用抽象类统一界面,方便程序的扩展, 比如:新增, 计算 架构师 (architect ) 的工资\n\n*/\n~~调用的时候参数有点问题~~\n```cpp\n//抽象类知识点的强化\n\n\n#include \"iostream\"\n#include \"sstream\"\nusing namespace std;\n\nclass programmer\n{\npublic:\n\tvirtual void getSal() = 0;\nprotected:\nprivate:\n};\n\nclass junior_programmer :public programmer\n{\npublic:\n\tjunior_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"junior_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\nclass mid_programmer :public programmer\n{\npublic:\n\tmid_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"mid_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n\nclass adv_programmer :public programmer\n{\npublic:\n\tadv_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"adv_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n//接下来为后期可以拓展的部分\n\n\nclass architect :public programmer\n{\npublic:\n\tarchitect(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"architect:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n//以上为后期拓展部分\n\nvoid pro_sale(programmer *base)\n{\n\tbase->getSal();\n}\n\n\nint main()\n{\n\tjunior_programmer jp(\"张三\",\"初级\",2000);\n\tmid_programmer mp(\"小张\", \"中级\", 8000);\n\tadv_programmer ap(\"小李\", \"高级\", 20394);\n\n\tpro_sale(&jp);\n\tpro_sale(&mp);\n\tpro_sale(&ap);\n\n\n\t//后期新增程序的调用\n\n\tarchitect ar(\"架构师\", \"牛\", 121332);\n\tpro_sale(&ar);\n\tsystem(\"pause\");\n\treturn 0; \n\n}\n```\n\n\n\n\n## 五、面向抽象类编程思想强化\n\n理论知识\n\nØ 虚函数和多态性使成员函数根据调用对象的类型产生不同的动作\n\nØ  多态性特别适合于实现分层结构的软件系统，便于对问题抽象时  定义共性，实现时定义区别\n\nØ **面向抽象类编程（面向接口编程）**是项目开发中重要技能之一。\n\n\n### （一）案例：socket库c++模型设计和实现\n\n**企业信息系统框架集成第三方产品**\n\n**案例背景**：一般的企业信息系统都有成熟的框架。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求**：请你在**企业信息系统框架**中集成第三方厂商的Socket通信产品和第三方厂商加密产品。\n\n第三方厂商的Socket通信产品：完成两点之间的通信；\n\n第三方厂商加密产品：完成数据发送时加密；数据解密时解密。\n\n![image077]($resource/image077.png)\n\n**案例要求**： 1）能支持多个厂商的Socket通信产品入围\n\n 2）能支持多个第三方厂商加密产品的入围\n\n 3）企业信息系统框架不轻易发生框架\n\n**需求实现**\n\n  思考1：企业信息系统框架、第三方产品如何分层\n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分成以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n分析有多少个类 CSocketProtocol  CSckFactoryImp1  CSckFactoryImp2\n\nCEncDesProtocol  HwEncdes  ciscoEncdes\n\n1、 定义 CSocketProtocol 抽象类\n\n2、 编写框架函数\n\n3、 编写框架测试函数\n\n4、 厂商1（CSckFactoryImp1）实现CSocketProtocol、厂商2（CSckFactoryImp1）实现CSocketProtocol\n\n5、 抽象加密接口（CEncDesProtocol）、加密厂商1(CHwImp)、加密厂商2(CCiscoImp))，集成实现业务模型\n\n6、 框架（c语言函数方式，框架函数；c++类方式，框架类）\n\n**几个重要的面向对象思想**\n\n继承-组合（强弱）\n\n注入\n\n控制反转 IOC\n\nMVC\n\n  面向对象思想扩展aop思想\n\n aop思想是对继承编程思想的有力的补充\n\n\n### （二）案例：计算员工工资\n\n\n### （三）案例：计算几何体的表面积和体积\n\n\n\n## 六、面向接口编程和C多态\n\n友情提示：今天课程内容，更加贴近实战，并且语法和软件思想都较难，请学员紧跟思路。课后加强复习！\n\n结论：  只要你动手，又很容易！\n\n\n\n### （一）函数类型语法基础\n\n\n函数三要素：  名称、参数、返回值\n\nC语言中的函数有自己特定的类型\n \n\nC语言中通过typedef为函数类型重命名\n\ntypedef type name(parameter list)\n\ntypedef int f(int, int);\n\ntypedef void p(int);\n\n |\n| \n\n函数指针\n\n |\n| \n\n函数指针用于指向一个函数\n\n函数名是函数体的入口地址\n\n1)可通过函数类型定义函数指针: FuncType* pointer;\n\n2)也可以直接定义：type (*pointer)(parameter list);\n\npointer为函数指针变量名\n\ntype为指向函数的返回值类型\n\nparameter list为指向函数的参数类型列表\n\n |\n| \n\n函数指针语法梳理\n\n//函数类型\n\n//函数指针类型\n\n//函数指针变量\n\n数组指针语法梳理 \n\n//数组类型语法\n\n//数组指针类型\n\n//数组指针变量\n\n |\n| \n\ntypedef int(FUNC)(int);\n\nint test(int i)\n\n{\n\n return i * i;\n\n}\n\nvoid f()\n\n{\n\n printf(\"Call f()...\\n\");\n\n}\n\nint main()\n\n{\n\n FUNC* pt = test;\n\n void(*pf)() = &f;\n\n pf();\n\n (*pf)();\n\n printf(\"Function pointer call: %d\\n\", pt(3));\n\n}\n\n |\n\n### （二）函数指针做函数参数\n\n| \n\n1、 指针做函数参数pk函数指针做函数参数\n\n回忆指针做函数参数\n\n一级指针做函数参数、二级。。。。、三级\n\n |\n| \n\n2、 函数指针做函数参数\n\n当函数指针 做为函数的参数，传递给一个被调用函数，\n\n被调用函数就可以通过这个指针调用外部的函数，这就形成了回调\n\n |\n| \n\n3、练习\n\nint add(int a, int b) \n\nint libfun( int (*pDis)(int a, int b) );\n\nint main(void)\n\n{\n\n int (*pfun)(int a, int b);  \n\n pfun = add;\n\n libfun(pfun);\n\n}\n\nint add(int a, int b)\n\n{\n\n return a + b;\n\n}\n\nint libfun( int (*pDis)(int a, int b) )\n\n{\n\n  int a, b;\n\n  a = 1;\n\n  b = 2;\n\nadd(1,3) //直接调用add函数\n\nprintf(\"%d\", pDis(a, b)); //通过函数指针做函数参数,间接调用add函数\n\n//思考 这样写 pDis(a, b)有什么好处?\n\n}\n\n//剖析思路\n\n//1函数的调用 和 函数的实现  有效的分离\n\n//2 C++的多态,可扩展\n\n现在这几个函数是在同一个文件当中\n\n假如\n\nint libfun(int (*pDis)(int a, int b))\n\n是一个库中的函数，就只有使用回调了，通过函数指针参数将外部函数地址传入\n\n来实现调用\n\n函数 add 的代码作了修改，也不必改动库的代码，就可以正常实现调用\n\n便于程序的维护和升级\n\n |\n\n回调函数思想：\n![image078]($resource/image078.png)\n结论：回调函数的本质：提前做了一个协议的约定（把函数的参数、函数返回值提前约定）\n\n请思考：C编译器通过那个具体的语法，实现解耦合的？\n\n C++编译器通过多态的机制(提前布局vptr指针和虚函数表,找虚函数入口地址来实现)\n\n### （三）函数指针正向调用\n\n| \n\n1、 函数指针做函数参数，调用方式\n\n被调用函数和主调函数在同一文件中（用来教学，没有任何意义）\n\n |\n| \n\n2、函数指针做函数参数\n\n被调用函数和主调函数不在同一个文件中、模块中。\n\n难点：理解被调用函数是什么机制被调用起来的。框架\n\n框架提前设置了被调用函数的入口（框架提供了第三方模块入口地址的集成功能）\n\n框架具备调用第三方模块入口函数\n\n |\n| \n\n3、 练习\n\ntypedef int (*EncDataFunc)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\nint MyEncDataFunc(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen)\n\n{\n\n int rv = 0;\n\n char *p = \"222222222222\";\n\n strcpy(outData, p);\n\n *outDataLen = strlen(p);\n\n return rv;\n\n}\n\nint Send_Data(EncDataFunc encDataFunc, unsigned char *inData, int inDataLen, unsigned char *outData, int *outDatalen)\n\n{\n\n int rv = 0;\n\n if (encDataFunc != NULL)\n\n {\n\n rv = encDataFunc(inData, inDataLen, outData, outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"func encDataFunc() err.\\n\");\n\n return rv;\n\n }\n\n }\n\n return rv;\n\n}\n\nint main()\n\n{\n\n int rv = 0;\n\n EncDataFunc encDataFunc = NULL;\n\n encDataFunc = MyEncDataFunc;\n\n // 第一个调用\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"1111\");\n\n inDataLen = strlen(inData);\n\n rv = encDataFunc(inData,inDataLen, outData, &outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"edf err .....\\n\");\n\n }\n\n else\n\n {\n\n printf(\"edf ok \\n\");\n\n printf(\"%s \\n\", outData);\n\n }\n\n }\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"3333\");\n\n inDataLen = strlen(inData);\n\n rv = Send_Data(MyEncDataFunc, inData, inDataLen, outData, &outDatalen);\n\n if (rv != 0)\n\n {\n\n printf(\"func Send_Data err:%d\", rv);\n\n return rv;\n\n }\n\n printf(\"%s \\n\", outData);\n\n }\n\n getchar();\n\n}\n\n |\n\n### （四）函数指针反向调用\n\n回调函数效果展示。\n\n\n### （五）C动态库升级成框架案例\n\n**C****语言版本Socket****动态库升级成框架集成第三方产品**\n\n**简称：C****动态库升级成框架案例**\n\n**名字解释       **\n\n  动态库：抽象类一个套接口，单独封装成模块，供别人调用；无法扩展。\n\n  框架：能自由的扩展 \n\n**案例背景**：一般的企业信息系统都有成熟的框架，可以有C语言写，也可以由C++语言。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求：**在socket通信库中，完成数据加密功能，有n个厂商的加密产品供你选择，如何实现动态库和第三个厂商产品的解耦合。\n\n提醒：C++通过抽象类，也就是面向抽象类编程实现的（相当于C++编译器通过多态机制，已经很好用了。提前布局vptr指针、虚函数表；调用是迟绑定完成。），\n\n**C****语言**中如何实现哪？\n\n**案例要求**： 1）能支持多个第三方厂商加密产品的入围\n\n 2）企业信息系统框架不轻易发生框架\n\n**需求实现思路分析**\n![image079]($resource/image079.png)\n  思考1：企业信息系统框架、第三方产品如何分层 \n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分层确定后，动态库应该做什么？产品入围厂商应该做什么？\n\n以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n1、 动态库中定义协议，并完成任务的调用\n\ntypedef int (*EncData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\ntypedef int (*DecData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\n2、 加密厂商完成协议函数的编写\n\n3、 对接调试。\n\n4、 动态库中可以缓存第三方函数的入口地址，也可以不缓存，两种实现方式。\n\n**案例总结**\n\n  回调函数：利用函数指针做函数参数，实现的一种调用机制，具体任务的实现者，可以不知道什么时候被调用。\n\n  回调机制原理：\n\n  当具体事件发生时，调用者通过函数指针调用具体函数\n\n  回调机制的将调用者和被调函数分开，两者互不依赖\n\n  任务的实现 和 任务的调用 可以耦合  （提前进行接口的封装和设计）\n\n### （六）附录：诸葛亮的锦囊妙计**\n\n刘备利用周瑜、曹仁厮杀之际，乘虚袭取了南郡、荆州、襄阳，以后又征服了长沙等四郡。周瑜想想十分气恨，正无处报复以夺还荆州。不久，刘备忽然丧偶，周瑜计上心来，对孙权说：“您的妹妹，美丽、刚强，我们以联姻抗曹名义向刘备招亲，把他骗来南徐幽禁，逼他们拿荆州来换。”孙权大喜，郎派人到荆州说亲。\n\n刘备认为这是骗局，想要拒绝，诸葛亮笑道：“送个好妻子上门何不答应？您只管去东吴，我叫赵云陪您去，自有安排，包您得了夫人又不失荆州。”\n\n接着，诸葛亮暗暗关照赵云道：“我这里有三个锦囊，内藏三条妙计。到南徐时打开第一个，到年底时打开第二个，危急无路时打开第三个。”\n\n第一个锦囊\n\n  一到东吴就拜会乔国老\n\n第二个锦囊\n\n  刘备被孙权设计留下就对他谎称曹操大军压境\n\n第三个锦囊\n\n被东吴军队追赶就求孙夫人解围\n",[[1544354169374,["gjx16@GJXAIOU",[[1,2833," "]],[2833,2833],[2834,2834]]]],null,"gjx16@GJXAIOU"],["b127eea4-caea-4647-b321-b34e9a112a34",1544404894916,"# C_PP_章五 纯虚函数和抽象类\n\n\n## 一、基本概念\n![image071]($resource/image071.png)\n![image072]($resource/image072.png)\n![image073]($resource/image073.png)\n\n\n\n## 二、抽象类案例\n![image074]($resource/image074.png)\n![image075]($resource/image075.png)\n```cpp\n//纯虚函数抽象类语法基础\n\n\n#include \"iostream\"\nusing namespace std;\n\nclass Figure\n{\npublic:\n\tvirtual void Area() = 0;   //声明一个纯虚函数，基类中不需要实现\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\nclass circle :public Figure\n{\npublic:\n\tcircle(int r,int a, int b)\n\t{\n\t\tthis->r = r;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"圆的面积 \" << 3.14*r*r << endl;\n\t}\nprivate:\n\tint r;\n};\n\n\nclass rectangle :public Figure\n{\npublic:\n\trectangle(int length, int width, int a, int b)\n\t{\n\t\tthis->length = length;\n\t\tthis->width = width;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"长方形的面积 \" << length * width << endl;\n\t}\nprivate:\n\tint length;\n\tint width;\n};\n\nvoid getArea(Figure *base)\n{\n\tbase->Area();\n}\n\n\n\nint main()\n{\n\t\n\t//Figure f1;//这是错误的，抽象类不能实例化\n\tFigure *p = NULL;   //但是可以使用指针和引用\n\tcircle c1(2, 1, 2);\n\trectangle r1(1, 2, 3, 4);\n\n\tgetArea(&c1);\n\tgetArea(&r1);\n\tsystem(\"pause\");\n\treturn 0;\n} \n```\n\n\n## 三、抽象类在多继承中的应用\n\nC++中没有Java中的接口概念，抽象类可以模拟Java中的接口类。（接口和协议）\n\n\n\n### （一）有关多继承的说明\n\n**工程上的多继承**\n\n* 被实际开发经验抛弃的多继承\n* 工程开发中真正意义上的多继承是几乎不被使用的\n* 多重继承带来的代码复杂性远多于其带来的便利\n* 多重继承对代码维护性上的影响是灾难性的\n* 在设计方法上，任何多继承都可以用单继承代替 \n\n**多继承中的二义性和多继承不能解决的问题 **\n![image076]($resource/image076.png)\n\n\n### （二）多继承的应用场景\n\nC++中是否有Java中的接口概念？\n\n绝大多数面向对象语言都不支持多继承\n\n绝大多数面向对象语言都支持接口的概念\n\nC++中没有接口的概念\n\nC++中可以使用纯虚函数实现接口\n\n**接口类中只有函数原型定义，没有任何数据的定义**。\n\nclass Interface \n\n{\n\n public:\n\n virtual void func1() = 0;\n\n virtual void func2(int i) = 0;\n\n virtual void func3(int i) = 0;\n\n};\n\n实际工程经验证明\n\n多重继承接口不会带来二义性和复杂性等问题 \n\n多重继承可以通过精心设计用单继承和接口来代替\n\n接口类只是一个功能说明，而不是功能实现。\n\n子类需要根据功能说明定义功能实现。\n\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n\nC++中没有接口的概念\n\nC++中可以使用纯虚函数实现接口\n\n接口类中只有函数原型定义，没有任何数据的定义。\n\n*/\n\n```cpp\n//抽象类在多继承中的应用\n\n#include \"iostream\"\nusing namespace std;\n\nclass Interface1\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n};\n\nclass Interface2\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n\tvirtual int minus(int a, int b) = 0;\n};\n\nclass parent\n{\npublic:\n\tint a;\n};\n\nclass Child : public parent, public Interface1, public Interface2\n{\npublic:\n\tvoid print()\n\t{\n\t\tcout << \"Child::print\" << endl;\n\t}\n\n\tint add(int a, int b)\n\t{\n\t\treturn a + b;\n\t}\n\n\tint minus(int a, int b)\n\t{\n\t\treturn a - b;\n\t}\n\n};\n\nint main()\n{\n\n\tChild c;\n\tc.print();\n\tcout << c.add(3, 5) << endl;\n\tcout << c.minus(4, 6) << endl;\n\n\tInterface1* i1 = &c;\n\tInterface2* i2 = &c;\n\n\tcout << i1->add(7, 8) << endl;\n\tcout << i2->add(7, 8) << endl;\n\n\tsystem(\"pause\");\n\n}\n```\n\n\n\n## 四、抽象类知识点强化\n\n/*\n\n编写一个C++程序, 计算程序员( programmer )工资 \n 1 要求能计算出初级程序员( junior_programmer ) 中级程序员 ( mid_programmer )高级程序员( adv_programmer)的工资\n 2 要求利用抽象类统一界面,方便程序的扩展, 比如:新增, 计算 架构师 (architect ) 的工资 \n\n*/\n~~调用的时候参数有点问题~~\n```cpp\n//抽象类知识点的强化\n\n\n#include \"iostream\"\n#include \"sstream\"\nusing namespace std;\n\nclass programmer\n{\npublic:\n\tvirtual void getSal() = 0;\nprotected:\nprivate:\n};\n\nclass junior_programmer :public programmer\n{\npublic:\n\tjunior_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"junior_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\nclass mid_programmer :public programmer\n{\npublic:\n\tmid_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"mid_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n\nclass adv_programmer :public programmer\n{\npublic:\n\tadv_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"adv_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n//接下来为后期可以拓展的部分\n\n\nclass architect :public programmer\n{\npublic:\n\tarchitect(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"architect:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n//以上为后期拓展部分\n\nvoid pro_sale(programmer *base)\n{\n\tbase->getSal();\n}\n\n\nint main()\n{\n\tjunior_programmer jp(\"张三\",\"初级\",2000);\n\tmid_programmer mp(\"小张\", \"中级\", 8000);\n\tadv_programmer ap(\"小李\", \"高级\", 20394);\n\n\tpro_sale(&jp);\n\tpro_sale(&mp);\n\tpro_sale(&ap);\n\n\n\t//后期新增程序的调用\n\n\tarchitect ar(\"架构师\", \"牛\", 121332);\n\tpro_sale(&ar);\n\tsystem(\"pause\");\n\treturn 0; \n\n}\n```\n\n\n\n\n## 五、面向抽象类编程思想强化\n\n理论知识\n\nØ 虚函数和多态性使成员函数根据调用对象的类型产生不同的动作\n\nØ  多态性特别适合于实现分层结构的软件系统，便于对问题抽象时  定义共性，实现时定义区别\n\nØ **面向抽象类编程（面向接口编程）**是项目开发中重要技能之一。\n\n\n### （一）案例：socket库c++模型设计和实现\n\n**企业信息系统框架集成第三方产品**\n\n**案例背景**：一般的企业信息系统都有成熟的框架。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求**：请你在**企业信息系统框架**中集成第三方厂商的Socket通信产品和第三方厂商加密产品。\n\n第三方厂商的Socket通信产品：完成两点之间的通信；\n\n第三方厂商加密产品：完成数据发送时加密；数据解密时解密。\n\n![image077]($resource/image077.png)\n\n**案例要求**： 1）能支持多个厂商的Socket通信产品入围\n\n 2）能支持多个第三方厂商加密产品的入围\n\n 3）企业信息系统框架不轻易发生框架\n\n**需求实现**\n\n  思考1：企业信息系统框架、第三方产品如何分层\n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分成以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n分析有多少个类 CSocketProtocol  CSckFactoryImp1  CSckFactoryImp2\n\nCEncDesProtocol  HwEncdes  ciscoEncdes\n\n1、 定义 CSocketProtocol 抽象类\n\n2、 编写框架函数\n\n3、 编写框架测试函数\n\n4、 厂商1（CSckFactoryImp1）实现CSocketProtocol、厂商2（CSckFactoryImp1）实现CSocketProtocol\n\n5、 抽象加密接口（CEncDesProtocol）、加密厂商1(CHwImp)、加密厂商2(CCiscoImp))，集成实现业务模型\n\n6、 框架（c语言函数方式，框架函数；c++类方式，框架类）\n\n**几个重要的面向对象思想**\n\n继承-组合（强弱）\n\n注入\n\n控制反转 IOC\n\nMVC\n\n  面向对象思想扩展aop思想\n\n aop思想是对继承编程思想的有力的补充\n\n\n### （二）案例：计算员工工资\n\n\n### （三）案例：计算几何体的表面积和体积\n\n\n\n## 六、面向接口编程和C多态\n\n友情提示：今天课程内容，更加贴近实战，并且语法和软件思想都较难，请学员紧跟思路。课后加强复习！\n\n结论：  只要你动手，又很容易！\n\n\n\n### （一）函数类型语法基础\n\n\n函数三要素：  名称、参数、返回值\n\nC语言中的函数有自己特定的类型\n \n\nC语言中通过typedef为函数类型重命名\n\ntypedef type name(parameter list)\n\ntypedef int f(int, int);\n\ntypedef void p(int);\n\n |\n| \n\n函数指针\n\n |\n| \n\n函数指针用于指向一个函数\n\n函数名是函数体的入口地址\n\n1)可通过函数类型定义函数指针: FuncType* pointer;\n\n2)也可以直接定义：type (*pointer)(parameter list);\n\npointer为函数指针变量名\n\ntype为指向函数的返回值类型\n\nparameter list为指向函数的参数类型列表\n\n |\n| \n\n函数指针语法梳理\n\n//函数类型\n\n//函数指针类型\n\n//函数指针变量\n\n数组指针语法梳理 \n\n//数组类型语法\n\n//数组指针类型\n\n//数组指针变量\n\n |\n| \n\ntypedef int(FUNC)(int);\n\nint test(int i)\n\n{\n\n return i * i;\n\n}\n\nvoid f()\n\n{\n\n printf(\"Call f()...\\n\");\n\n}\n\nint main()\n\n{\n\n FUNC* pt = test;\n\n void(*pf)() = &f;\n\n pf();\n\n (*pf)();\n\n printf(\"Function pointer call: %d\\n\", pt(3));\n\n}\n\n |\n\n### （二）函数指针做函数参数\n\n| \n\n1、 指针做函数参数pk函数指针做函数参数\n\n回忆指针做函数参数\n\n一级指针做函数参数、二级。。。。、三级\n\n |\n| \n\n2、 函数指针做函数参数\n\n当函数指针 做为函数的参数，传递给一个被调用函数，\n\n被调用函数就可以通过这个指针调用外部的函数，这就形成了回调\n\n |\n| \n\n3、练习\n\nint add(int a, int b) \n\nint libfun( int (*pDis)(int a, int b) );\n\nint main(void)\n\n{\n\n int (*pfun)(int a, int b);  \n\n pfun = add;\n\n libfun(pfun);\n\n}\n\nint add(int a, int b)\n\n{\n\n return a + b;\n\n}\n\nint libfun( int (*pDis)(int a, int b) )\n\n{\n\n  int a, b;\n\n  a = 1;\n\n  b = 2;\n\nadd(1,3) //直接调用add函数\n\nprintf(\"%d\", pDis(a, b)); //通过函数指针做函数参数,间接调用add函数\n\n//思考 这样写 pDis(a, b)有什么好处?\n\n}\n\n//剖析思路\n\n//1函数的调用 和 函数的实现  有效的分离\n\n//2 C++的多态,可扩展\n\n现在这几个函数是在同一个文件当中\n\n假如\n\nint libfun(int (*pDis)(int a, int b))\n\n是一个库中的函数，就只有使用回调了，通过函数指针参数将外部函数地址传入\n\n来实现调用\n\n函数 add 的代码作了修改，也不必改动库的代码，就可以正常实现调用\n\n便于程序的维护和升级\n\n |\n\n回调函数思想：\n![image078]($resource/image078.png)\n结论：回调函数的本质：提前做了一个协议的约定（把函数的参数、函数返回值提前约定）\n\n请思考：C编译器通过那个具体的语法，实现解耦合的？\n\n C++编译器通过多态的机制(提前布局vptr指针和虚函数表,找虚函数入口地址来实现)\n\n### （三）函数指针正向调用\n\n| \n\n1、 函数指针做函数参数，调用方式\n\n被调用函数和主调函数在同一文件中（用来教学，没有任何意义）\n\n |\n| \n\n2、函数指针做函数参数\n\n被调用函数和主调函数不在同一个文件中、模块中。\n\n难点：理解被调用函数是什么机制被调用起来的。框架\n\n框架提前设置了被调用函数的入口（框架提供了第三方模块入口地址的集成功能）\n\n框架具备调用第三方模块入口函数\n\n |\n| \n\n3、 练习\n\ntypedef int (*EncDataFunc)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\nint MyEncDataFunc(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen)\n\n{\n\n int rv = 0;\n\n char *p = \"222222222222\";\n\n strcpy(outData, p);\n\n *outDataLen = strlen(p);\n\n return rv;\n\n}\n\nint Send_Data(EncDataFunc encDataFunc, unsigned char *inData, int inDataLen, unsigned char *outData, int *outDatalen)\n\n{\n\n int rv = 0;\n\n if (encDataFunc != NULL)\n\n {\n\n rv = encDataFunc(inData, inDataLen, outData, outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"func encDataFunc() err.\\n\");\n\n return rv;\n\n }\n\n }\n\n return rv;\n\n}\n\nint main()\n\n{\n\n int rv = 0;\n\n EncDataFunc encDataFunc = NULL;\n\n encDataFunc = MyEncDataFunc;\n\n // 第一个调用\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"1111\");\n\n inDataLen = strlen(inData);\n\n rv = encDataFunc(inData,inDataLen, outData, &outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"edf err .....\\n\");\n\n }\n\n else\n\n {\n\n printf(\"edf ok \\n\");\n\n printf(\"%s \\n\", outData);\n\n }\n\n }\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"3333\");\n\n inDataLen = strlen(inData);\n\n rv = Send_Data(MyEncDataFunc, inData, inDataLen, outData, &outDatalen);\n\n if (rv != 0)\n\n {\n\n printf(\"func Send_Data err:%d\", rv);\n\n return rv;\n\n }\n\n printf(\"%s \\n\", outData);\n\n }\n\n getchar();\n\n}\n\n |\n\n### （四）函数指针反向调用\n\n回调函数效果展示。\n\n\n### （五）C动态库升级成框架案例\n\n**C****语言版本Socket****动态库升级成框架集成第三方产品**\n\n**简称：C****动态库升级成框架案例**\n\n**名字解释       **\n\n  动态库：抽象类一个套接口，单独封装成模块，供别人调用；无法扩展。\n\n  框架：能自由的扩展 \n\n**案例背景**：一般的企业信息系统都有成熟的框架，可以有C语言写，也可以由C++语言。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求：**在socket通信库中，完成数据加密功能，有n个厂商的加密产品供你选择，如何实现动态库和第三个厂商产品的解耦合。\n\n提醒：C++通过抽象类，也就是面向抽象类编程实现的（相当于C++编译器通过多态机制，已经很好用了。提前布局vptr指针、虚函数表；调用是迟绑定完成。），\n\n**C****语言**中如何实现哪？\n\n**案例要求**： 1）能支持多个第三方厂商加密产品的入围\n\n 2）企业信息系统框架不轻易发生框架\n\n**需求实现思路分析**\n![image079]($resource/image079.png)\n  思考1：企业信息系统框架、第三方产品如何分层 \n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分层确定后，动态库应该做什么？产品入围厂商应该做什么？\n\n以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n1、 动态库中定义协议，并完成任务的调用\n\ntypedef int (*EncData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\ntypedef int (*DecData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\n2、 加密厂商完成协议函数的编写\n\n3、 对接调试。\n\n4、 动态库中可以缓存第三方函数的入口地址，也可以不缓存，两种实现方式。\n\n**案例总结**\n\n  回调函数：利用函数指针做函数参数，实现的一种调用机制，具体任务的实现者，可以不知道什么时候被调用。\n\n  回调机制原理：\n\n  当具体事件发生时，调用者通过函数指针调用具体函数\n\n  回调机制的将调用者和被调函数分开，两者互不依赖\n\n  任务的实现 和 任务的调用 可以耦合  （提前进行接口的封装和设计）\n\n### （六）附录：诸葛亮的锦囊妙计**\n\n刘备利用周瑜、曹仁厮杀之际，乘虚袭取了南郡、荆州、襄阳，以后又征服了长沙等四郡。周瑜想想十分气恨，正无处报复以夺还荆州。不久，刘备忽然丧偶，周瑜计上心来，对孙权说：“您的妹妹，美丽、刚强，我们以联姻抗曹名义向刘备招亲，把他骗来南徐幽禁，逼他们拿荆州来换。”孙权大喜，郎派人到荆州说亲。\n\n刘备认为这是骗局，想要拒绝，诸葛亮笑道：“送个好妻子上门何不答应？您只管去东吴，我叫赵云陪您去，自有安排，包您得了夫人又不失荆州。”\n\n接着，诸葛亮暗暗关照赵云道：“我这里有三个锦囊，内藏三条妙计。到南徐时打开第一个，到年底时打开第二个，危急无路时打开第三个。”\n\n第一个锦囊\n\n  一到东吴就拜会乔国老\n\n第二个锦囊\n\n  刘备被孙权设计留下就对他谎称曹操大军压境\n\n第三个锦囊\n\n被东吴军队追赶就求孙夫人解围\n",[[1544404849683,["gjx16@GJXAIOU",[[1,31,"\n"]],[30,30],[31,31]]],[1544404850180,["gjx16@GJXAIOU",[[1,32,"\n"]],[31,31],[32,32]]],[1544404851643,["gjx16@GJXAIOU",[[1,32,"****"]],[32,32],[34,34]]],[1544404863192,["gjx16@GJXAIOU",[[1,34,"纯虚函数："]],[34,34],[39,39]]],[1544404864757,["gjx16@GJXAIOU",[[1,42,"\n"]],[41,41],[42,42]]],[1544404888089,["gjx16@GJXAIOU",[[1,42,"春旭函数"]],[42,42],[46,46]]],[1544404890768,["gjx16@GJXAIOU",[[-1,42,"春旭函数"]],[46,46],[42,42]]],[1544404906848,["gjx16@GJXAIOU",[[1,42,"纯虚函数声明格式： ``"]],[42,42],[54,54]]],[1544404925312,["gjx16@GJXAIOU",[[1,53,"virtual 返回值类型    函数名（）"]],[53,53],[75,75]]],[1544404935968,["gjx16@GJXAIOU",[[1,74,"参数列表"]],[74,74],[78,78]]],[1544404940360,["gjx16@GJXAIOU",[[-1,69," "]],[69,69],[68,68]]],[1544404954159,["gjx16@GJXAIOU",[[1,78,"= 0"]],[78,78],[81,81]]],[1544404955222,["gjx16@GJXAIOU",[[1,81," "]],[81,81],[82,82]]],[1544404957979,["gjx16@GJXAIOU",[[1,84,"\n"]],[83,83],[84,84]]],[1544404958141,["gjx16@GJXAIOU",[[1,85,"\n"]],[84,84],[85,85]]],[1544404964238,["gjx16@GJXAIOU",[[1,42,"* "]],[42,42],[44,44]]],[1544404969934,["gjx16@GJXAIOU",[[1,86,"* c"]],[86,86],[89,89]]],[1544404970736,["gjx16@GJXAIOU",[[-1,88,"c"]],[89,89],[88,88]]],[1544404973688,["gjx16@GJXAIOU",[[1,88,"传旭函数"]],[88,88],[92,92]]],[1544404975347,["gjx16@GJXAIOU",[[-1,88,"传旭函数"]],[92,92],[88,88]]],[1544404992096,["gjx16@GJXAIOU",[[1,88,"纯虚函数是一个在积累中"]],[88,88],[99,99]]],[1544404992943,["gjx16@GJXAIOU",[[-1,96,"积累中"]],[99,99],[96,96]]],[1544405011695,["gjx16@GJXAIOU",[[1,96,"基类中声明的虚函数，但是在积累中"]],[96,96],[112,112]]],[1544405012680,["gjx16@GJXAIOU",[[-1,109,"积累中"]],[112,112],[109,109]]],[1544405014657,["gjx16@GJXAIOU",[[1,109,"基类中"]],[109,109],[112,112]]],[1544405021433,["gjx16@GJXAIOU",[[1,112,"并没有立式机"]],[112,112],[118,118]]],[1544405022075,["gjx16@GJXAIOU",[[-1,115,"立式机"]],[118,118],[115,115]]],[1544405027457,["gjx16@GJXAIOU",[[1,115,"定义（）"]],[115,115],[119,119]]],[1544405036417,["gjx16@GJXAIOU",[[1,118,"即没想"]],[118,118],[121,121]]],[1544405037243,["gjx16@GJXAIOU",[[-1,119,"没想"]],[121,121],[119,119]]],[1544405038743,["gjx16@GJXAIOU",[[1,119,"meiyou8"]],[119,119],[126,126]]],[1544405040720,["gjx16@GJXAIOU",[[-1,119,"meiyou8"]],[126,126],[119,119]]],[1544405046097,["gjx16@GJXAIOU",[[1,119,"没有具体的代码实现"]],[119,119],[128,128]]],[1544405069113,["gjx16@GJXAIOU",[[1,129,"，但是要求任何的派生类都要定义（）"]],[129,129],[146,146]]],[1544405071203,["gjx16@GJXAIOU",[[-1,142,"定义（）"]],[146,146],[142,142]]],[1544405073159,["gjx16@GJXAIOU",[[1,142,"实现"]],[142,142],[144,144]]],[1544405077239,["gjx16@GJXAIOU",[[1,144,"数据"]],[144,144],[146,146]]],[1544405078443,["gjx16@GJXAIOU",[[-1,144,"数据"]],[146,146],[144,144]]],[1544405084914,["gjx16@GJXAIOU",[[1,144,"属于自己的这个哈舒"]],[144,144],[153,153]]],[1544405085846,["gjx16@GJXAIOU",[[-1,151,"哈舒"]],[153,153],[151,151]]],[1544405087976,["gjx16@GJXAIOU",[[1,151,"函数；"]],[151,151],[154,154]]],[1544405226426,["gjx16@GJXAIOU",[[1,155,"* \n"]],[154,154],[157,157]]],[1544405232072,["gjx16@GJXAIOU",[[1,157,"春旭"]],[157,157],[159,159]]],[1544405232996,["gjx16@GJXAIOU",[[-1,157,"春旭"]],[159,159],[157,157]]]],null,"gjx16@GJXAIOU"],["fa70b774-e441-43f4-8f5a-d2c6dbae96ba",1544413540919,"# C_PP_章五 纯虚函数和抽象类\n\n\n## 一、基本概念\n\n**纯虚函数：**\n* 纯虚函数声明格式： `virtual 返回值类型   函数名（参数列表）= 0 `\n* 纯虚函数是一个在基类中声明的虚函数，但是在基类中并没有定义（即没有具体的代码实现），但是要求任何的派生类都要实现属于自己的这个函数；\n* \n\n![image071]($resource/image071.png)\n![image072]($resource/image072.png)\n![image073]($resource/image073.png)\n\n\n\n## 二、抽象类案例\n![image074]($resource/image074.png)\n![image075]($resource/image075.png)\n```cpp\n//纯虚函数抽象类语法基础\n\n\n#include \"iostream\"\nusing namespace std;\n\nclass Figure\n{\npublic:\n\tvirtual void Area() = 0;   //声明一个纯虚函数，基类中不需要实现\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\nclass circle :public Figure\n{\npublic:\n\tcircle(int r,int a, int b)\n\t{\n\t\tthis->r = r;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"圆的面积 \" << 3.14*r*r << endl;\n\t}\nprivate:\n\tint r;\n};\n\n\nclass rectangle :public Figure\n{\npublic:\n\trectangle(int length, int width, int a, int b)\n\t{\n\t\tthis->length = length;\n\t\tthis->width = width;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"长方形的面积 \" << length * width << endl;\n\t}\nprivate:\n\tint length;\n\tint width;\n};\n\nvoid getArea(Figure *base)\n{\n\tbase->Area();\n}\n\n\n\nint main()\n{\n\t\n\t//Figure f1;//这是错误的，抽象类不能实例化\n\tFigure *p = NULL;   //但是可以使用指针和引用\n\tcircle c1(2, 1, 2);\n\trectangle r1(1, 2, 3, 4);\n\n\tgetArea(&c1);\n\tgetArea(&r1);\n\tsystem(\"pause\");\n\treturn 0;\n} \n```\n\n\n## 三、抽象类在多继承中的应用\n\nC++中没有Java中的接口概念，抽象类可以模拟Java中的接口类。（接口和协议）\n\n\n\n### （一）有关多继承的说明\n\n**工程上的多继承**\n\n* 被实际开发经验抛弃的多继承\n* 工程开发中真正意义上的多继承是几乎不被使用的\n* 多重继承带来的代码复杂性远多于其带来的便利\n* 多重继承对代码维护性上的影响是灾难性的\n* 在设计方法上，任何多继承都可以用单继承代替 \n\n**多继承中的二义性和多继承不能解决的问题 **\n![image076]($resource/image076.png)\n\n\n### （二）多继承的应用场景\n\nC++中是否有Java中的接口概念？\n\n绝大多数面向对象语言都不支持多继承\n\n绝大多数面向对象语言都支持接口的概念\n\nC++中没有接口的概念\n\nC++中可以使用纯虚函数实现接口\n\n**接口类中只有函数原型定义，没有任何数据的定义**。\n\nclass Interface \n\n{\n\n public:\n\n virtual void func1() = 0;\n\n virtual void func2(int i) = 0;\n\n virtual void func3(int i) = 0;\n\n};\n\n实际工程经验证明\n\n多重继承接口不会带来二义性和复杂性等问题 \n\n多重继承可以通过精心设计用单继承和接口来代替\n\n接口类只是一个功能说明，而不是功能实现。\n\n子类需要根据功能说明定义功能实现。\n\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n\nC++中没有接口的概念\n\nC++中可以使用纯虚函数实现接口\n\n接口类中只有函数原型定义，没有任何数据的定义。\n\n*/\n\n```cpp\n//抽象类在多继承中的应用\n\n#include \"iostream\"\nusing namespace std;\n\nclass Interface1\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n};\n\nclass Interface2\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n\tvirtual int minus(int a, int b) = 0;\n};\n\nclass parent\n{\npublic:\n\tint a;\n};\n\nclass Child : public parent, public Interface1, public Interface2\n{\npublic:\n\tvoid print()\n\t{\n\t\tcout << \"Child::print\" << endl;\n\t}\n\n\tint add(int a, int b)\n\t{\n\t\treturn a + b;\n\t}\n\n\tint minus(int a, int b)\n\t{\n\t\treturn a - b;\n\t}\n\n};\n\nint main()\n{\n\n\tChild c;\n\tc.print();\n\tcout << c.add(3, 5) << endl;\n\tcout << c.minus(4, 6) << endl;\n\n\tInterface1* i1 = &c;\n\tInterface2* i2 = &c;\n\n\tcout << i1->add(7, 8) << endl;\n\tcout << i2->add(7, 8) << endl;\n\n\tsystem(\"pause\");\n\n}\n```\n\n\n\n## 四、抽象类知识点强化\n\n/*\n\n编写一个C++程序, 计算程序员( programmer )工资 \n 1 要求能计算出初级程序员( junior_programmer ) 中级程序员 ( mid_programmer )高级程序员( adv_programmer)的工资\n 2 要求利用抽象类统一界面,方便程序的扩展, 比如:新增, 计算 架构师 (architect ) 的工资 \n\n*/\n~~调用的时候参数有点问题~~\n```cpp\n//抽象类知识点的强化\n\n\n#include \"iostream\"\n#include \"sstream\"\nusing namespace std;\n\nclass programmer\n{\npublic:\n\tvirtual void getSal() = 0;\nprotected:\nprivate:\n};\n\nclass junior_programmer :public programmer\n{\npublic:\n\tjunior_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"junior_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\nclass mid_programmer :public programmer\n{\npublic:\n\tmid_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"mid_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n\nclass adv_programmer :public programmer\n{\npublic:\n\tadv_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"adv_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n//接下来为后期可以拓展的部分\n\n\nclass architect :public programmer\n{\npublic:\n\tarchitect(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"architect:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n//以上为后期拓展部分\n\nvoid pro_sale(programmer *base)\n{\n\tbase->getSal();\n}\n\n\nint main()\n{\n\tjunior_programmer jp(\"张三\",\"初级\",2000);\n\tmid_programmer mp(\"小张\", \"中级\", 8000);\n\tadv_programmer ap(\"小李\", \"高级\", 20394);\n\n\tpro_sale(&jp);\n\tpro_sale(&mp);\n\tpro_sale(&ap);\n\n\n\t//后期新增程序的调用\n\n\tarchitect ar(\"架构师\", \"牛\", 121332);\n\tpro_sale(&ar);\n\tsystem(\"pause\");\n\treturn 0; \n\n}\n```\n\n\n\n\n## 五、面向抽象类编程思想强化\n\n理论知识\n\nØ 虚函数和多态性使成员函数根据调用对象的类型产生不同的动作\n\nØ  多态性特别适合于实现分层结构的软件系统，便于对问题抽象时  定义共性，实现时定义区别\n\nØ **面向抽象类编程（面向接口编程）**是项目开发中重要技能之一。\n\n\n### （一）案例：socket库c++模型设计和实现\n\n**企业信息系统框架集成第三方产品**\n\n**案例背景**：一般的企业信息系统都有成熟的框架。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求**：请你在**企业信息系统框架**中集成第三方厂商的Socket通信产品和第三方厂商加密产品。\n\n第三方厂商的Socket通信产品：完成两点之间的通信；\n\n第三方厂商加密产品：完成数据发送时加密；数据解密时解密。\n\n![image077]($resource/image077.png)\n\n**案例要求**： 1）能支持多个厂商的Socket通信产品入围\n\n 2）能支持多个第三方厂商加密产品的入围\n\n 3）企业信息系统框架不轻易发生框架\n\n**需求实现**\n\n  思考1：企业信息系统框架、第三方产品如何分层\n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分成以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n分析有多少个类 CSocketProtocol  CSckFactoryImp1  CSckFactoryImp2\n\nCEncDesProtocol  HwEncdes  ciscoEncdes\n\n1、 定义 CSocketProtocol 抽象类\n\n2、 编写框架函数\n\n3、 编写框架测试函数\n\n4、 厂商1（CSckFactoryImp1）实现CSocketProtocol、厂商2（CSckFactoryImp1）实现CSocketProtocol\n\n5、 抽象加密接口（CEncDesProtocol）、加密厂商1(CHwImp)、加密厂商2(CCiscoImp))，集成实现业务模型\n\n6、 框架（c语言函数方式，框架函数；c++类方式，框架类）\n\n**几个重要的面向对象思想**\n\n继承-组合（强弱）\n\n注入\n\n控制反转 IOC\n\nMVC\n\n  面向对象思想扩展aop思想\n\n aop思想是对继承编程思想的有力的补充\n\n\n### （二）案例：计算员工工资\n\n\n### （三）案例：计算几何体的表面积和体积\n\n\n\n## 六、面向接口编程和C多态\n\n友情提示：今天课程内容，更加贴近实战，并且语法和软件思想都较难，请学员紧跟思路。课后加强复习！\n\n结论：  只要你动手，又很容易！\n\n\n\n### （一）函数类型语法基础\n\n\n函数三要素：  名称、参数、返回值\n\nC语言中的函数有自己特定的类型\n \n\nC语言中通过typedef为函数类型重命名\n\ntypedef type name(parameter list)\n\ntypedef int f(int, int);\n\ntypedef void p(int);\n\n |\n| \n\n函数指针\n\n |\n| \n\n函数指针用于指向一个函数\n\n函数名是函数体的入口地址\n\n1)可通过函数类型定义函数指针: FuncType* pointer;\n\n2)也可以直接定义：type (*pointer)(parameter list);\n\npointer为函数指针变量名\n\ntype为指向函数的返回值类型\n\nparameter list为指向函数的参数类型列表\n\n |\n| \n\n函数指针语法梳理\n\n//函数类型\n\n//函数指针类型\n\n//函数指针变量\n\n数组指针语法梳理 \n\n//数组类型语法\n\n//数组指针类型\n\n//数组指针变量\n\n |\n| \n\ntypedef int(FUNC)(int);\n\nint test(int i)\n\n{\n\n return i * i;\n\n}\n\nvoid f()\n\n{\n\n printf(\"Call f()...\\n\");\n\n}\n\nint main()\n\n{\n\n FUNC* pt = test;\n\n void(*pf)() = &f;\n\n pf();\n\n (*pf)();\n\n printf(\"Function pointer call: %d\\n\", pt(3));\n\n}\n\n |\n\n### （二）函数指针做函数参数\n\n| \n\n1、 指针做函数参数pk函数指针做函数参数\n\n回忆指针做函数参数\n\n一级指针做函数参数、二级。。。。、三级\n\n |\n| \n\n2、 函数指针做函数参数\n\n当函数指针 做为函数的参数，传递给一个被调用函数，\n\n被调用函数就可以通过这个指针调用外部的函数，这就形成了回调\n\n |\n| \n\n3、练习\n\nint add(int a, int b) \n\nint libfun( int (*pDis)(int a, int b) );\n\nint main(void)\n\n{\n\n int (*pfun)(int a, int b);  \n\n pfun = add;\n\n libfun(pfun);\n\n}\n\nint add(int a, int b)\n\n{\n\n return a + b;\n\n}\n\nint libfun( int (*pDis)(int a, int b) )\n\n{\n\n  int a, b;\n\n  a = 1;\n\n  b = 2;\n\nadd(1,3) //直接调用add函数\n\nprintf(\"%d\", pDis(a, b)); //通过函数指针做函数参数,间接调用add函数\n\n//思考 这样写 pDis(a, b)有什么好处?\n\n}\n\n//剖析思路\n\n//1函数的调用 和 函数的实现  有效的分离\n\n//2 C++的多态,可扩展\n\n现在这几个函数是在同一个文件当中\n\n假如\n\nint libfun(int (*pDis)(int a, int b))\n\n是一个库中的函数，就只有使用回调了，通过函数指针参数将外部函数地址传入\n\n来实现调用\n\n函数 add 的代码作了修改，也不必改动库的代码，就可以正常实现调用\n\n便于程序的维护和升级\n\n |\n\n回调函数思想：\n![image078]($resource/image078.png)\n结论：回调函数的本质：提前做了一个协议的约定（把函数的参数、函数返回值提前约定）\n\n请思考：C编译器通过那个具体的语法，实现解耦合的？\n\n C++编译器通过多态的机制(提前布局vptr指针和虚函数表,找虚函数入口地址来实现)\n\n### （三）函数指针正向调用\n\n| \n\n1、 函数指针做函数参数，调用方式\n\n被调用函数和主调函数在同一文件中（用来教学，没有任何意义）\n\n |\n| \n\n2、函数指针做函数参数\n\n被调用函数和主调函数不在同一个文件中、模块中。\n\n难点：理解被调用函数是什么机制被调用起来的。框架\n\n框架提前设置了被调用函数的入口（框架提供了第三方模块入口地址的集成功能）\n\n框架具备调用第三方模块入口函数\n\n |\n| \n\n3、 练习\n\ntypedef int (*EncDataFunc)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\nint MyEncDataFunc(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen)\n\n{\n\n int rv = 0;\n\n char *p = \"222222222222\";\n\n strcpy(outData, p);\n\n *outDataLen = strlen(p);\n\n return rv;\n\n}\n\nint Send_Data(EncDataFunc encDataFunc, unsigned char *inData, int inDataLen, unsigned char *outData, int *outDatalen)\n\n{\n\n int rv = 0;\n\n if (encDataFunc != NULL)\n\n {\n\n rv = encDataFunc(inData, inDataLen, outData, outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"func encDataFunc() err.\\n\");\n\n return rv;\n\n }\n\n }\n\n return rv;\n\n}\n\nint main()\n\n{\n\n int rv = 0;\n\n EncDataFunc encDataFunc = NULL;\n\n encDataFunc = MyEncDataFunc;\n\n // 第一个调用\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"1111\");\n\n inDataLen = strlen(inData);\n\n rv = encDataFunc(inData,inDataLen, outData, &outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"edf err .....\\n\");\n\n }\n\n else\n\n {\n\n printf(\"edf ok \\n\");\n\n printf(\"%s \\n\", outData);\n\n }\n\n }\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"3333\");\n\n inDataLen = strlen(inData);\n\n rv = Send_Data(MyEncDataFunc, inData, inDataLen, outData, &outDatalen);\n\n if (rv != 0)\n\n {\n\n printf(\"func Send_Data err:%d\", rv);\n\n return rv;\n\n }\n\n printf(\"%s \\n\", outData);\n\n }\n\n getchar();\n\n}\n\n |\n\n### （四）函数指针反向调用\n\n回调函数效果展示。\n\n\n### （五）C动态库升级成框架案例\n\n**C****语言版本Socket****动态库升级成框架集成第三方产品**\n\n**简称：C****动态库升级成框架案例**\n\n**名字解释       **\n\n  动态库：抽象类一个套接口，单独封装成模块，供别人调用；无法扩展。\n\n  框架：能自由的扩展 \n\n**案例背景**：一般的企业信息系统都有成熟的框架，可以有C语言写，也可以由C++语言。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求：**在socket通信库中，完成数据加密功能，有n个厂商的加密产品供你选择，如何实现动态库和第三个厂商产品的解耦合。\n\n提醒：C++通过抽象类，也就是面向抽象类编程实现的（相当于C++编译器通过多态机制，已经很好用了。提前布局vptr指针、虚函数表；调用是迟绑定完成。），\n\n**C****语言**中如何实现哪？\n\n**案例要求**： 1）能支持多个第三方厂商加密产品的入围\n\n 2）企业信息系统框架不轻易发生框架\n\n**需求实现思路分析**\n![image079]($resource/image079.png)\n  思考1：企业信息系统框架、第三方产品如何分层 \n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分层确定后，动态库应该做什么？产品入围厂商应该做什么？\n\n以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n1、 动态库中定义协议，并完成任务的调用\n\ntypedef int (*EncData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\ntypedef int (*DecData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\n2、 加密厂商完成协议函数的编写\n\n3、 对接调试。\n\n4、 动态库中可以缓存第三方函数的入口地址，也可以不缓存，两种实现方式。\n\n**案例总结**\n\n  回调函数：利用函数指针做函数参数，实现的一种调用机制，具体任务的实现者，可以不知道什么时候被调用。\n\n  回调机制原理：\n\n  当具体事件发生时，调用者通过函数指针调用具体函数\n\n  回调机制的将调用者和被调函数分开，两者互不依赖\n\n  任务的实现 和 任务的调用 可以耦合  （提前进行接口的封装和设计）\n\n### （六）附录：诸葛亮的锦囊妙计**\n\n刘备利用周瑜、曹仁厮杀之际，乘虚袭取了南郡、荆州、襄阳，以后又征服了长沙等四郡。周瑜想想十分气恨，正无处报复以夺还荆州。不久，刘备忽然丧偶，周瑜计上心来，对孙权说：“您的妹妹，美丽、刚强，我们以联姻抗曹名义向刘备招亲，把他骗来南徐幽禁，逼他们拿荆州来换。”孙权大喜，郎派人到荆州说亲。\n\n刘备认为这是骗局，想要拒绝，诸葛亮笑道：“送个好妻子上门何不答应？您只管去东吴，我叫赵云陪您去，自有安排，包您得了夫人又不失荆州。”\n\n接着，诸葛亮暗暗关照赵云道：“我这里有三个锦囊，内藏三条妙计。到南徐时打开第一个，到年底时打开第二个，危急无路时打开第三个。”\n\n第一个锦囊\n\n  一到东吴就拜会乔国老\n\n第二个锦囊\n\n  刘备被孙权设计留下就对他谎称曹操大军压境\n\n第三个锦囊\n\n被东吴军队追赶就求孙夫人解围\n",[[1544413536395,["gjx16@GJXAIOU",[[1,157,"纯虚函数为"]],[157,157],[162,162]]],[1544413570541,["gjx16@GJXAIOU",[[1,162,"各派生类提供一个公共界面（）"]],[162,162],[176,176]]],[1544413586723,["gjx16@GJXAIOU",[[1,175,"接口的封装和设计、软件的"]],[175,175],[187,187]]],[1544413613233,["gjx16@GJXAIOU",[[1,187,"模块功能划分"]],[187,187],[193,193]]],[1544413625088,["gjx16@GJXAIOU",[[1,195,"* \n"]],[194,194],[197,197]]],[1544413639775,["gjx16@GJXAIOU",[[-1,195,"* "]],[197,197],[195,195]]],[1544413640483,["gjx16@GJXAIOU",[[1,197,"\n"]],[195,195],[196,196]]],[1544413641548,["gjx16@GJXAIOU",[[1,196,"****"]],[196,196],[198,198]]],[1544413649227,["gjx16@GJXAIOU",[[1,198,"抽象类："]],[198,198],[202,202]]],[1544413651601,["gjx16@GJXAIOU",[[1,206,"\n"]],[204,204],[205,205]]],[1544413659301,["gjx16@GJXAIOU",[[1,205,"一个具有"]],[205,205],[209,209]]],[1544413673366,["gjx16@GJXAIOU",[[1,209,"纯虚函数的基类被称为抽象类"]],[209,209],[222,222]]],[1544413684171,["gjx16@GJXAIOU",[[1,205,"  "]],[205,205],[207,207]]],[1544413688023,["gjx16@GJXAIOU",[[-1,226,"![image071]($resource/image071.png)"]],[226,261],[226,226]]],[1544421639624,["gjx16@GJXAIOU",[[1,520,"，"]],[520,520],[521,521]]],[1544421647725,["gjx16@GJXAIOU",[[1,521,"在下面每一个继承类中"]],[521,521],[531,531]]],[1544421649285,["gjx16@GJXAIOU",[[-1,530,"中"]],[531,531],[530,530]]],[1544421660864,["gjx16@GJXAIOU",[[1,530,"都需要按照各自需求进行实现"]],[530,530],[543,543]]],[1544422314358,["gjx16@GJXAIOU",[[-1,1597,"\n"]],[1597,1597],[1596,1596]]],[1544422317547,["gjx16@GJXAIOU",[[-1,1578,"C++中是否有Java中的接口概念？"]],[1578,1596],[1578,1578]]],[1544422318596,["gjx16@GJXAIOU",[[-1,1597,"\n"]],[1597,1597],[1596,1596]]],[1544422319707,["gjx16@GJXAIOU",[[-1,1616,"\n"]],[1616,1616],[1615,1615]]],[1544422320556,["gjx16@GJXAIOU",[[-1,1628,"\n"]],[1628,1628],[1627,1627]]],[1544422323982,["gjx16@GJXAIOU",[[-1,1647,"*"]],[1648,1648],[1647,1647]]],[1544422326655,["gjx16@GJXAIOU",[[-1,1669,"**。"]],[1671,1671],[1669,1669]]],[1544422328483,["gjx16@GJXAIOU",[[-1,1646,"*"]],[1647,1647],[1646,1646]]],[1544422331723,["gjx16@GJXAIOU",[[-1,1670,"class Interface \n\n{\n\n public:\n\n virtual void func1() = 0;\n\n virtual void func2(int i) = 0;\n\n virtual void func3(int i) = 0;\n\n};"]],[1670,1797],[1670,1670]]],[1544422332539,["gjx16@GJXAIOU",[[-1,1671,"\n"]],[1670,1670],[1669,1669]]],[1544422336253,["gjx16@GJXAIOU",[[-1,1703,"\n"]],[1703,1703],[1702,1702]]],[1544422337292,["gjx16@GJXAIOU",[[-1,1726,"\n"]],[1726,1726],[1725,1725]]],[1544422338139,["gjx16@GJXAIOU",[[-1,1747,"\n"]],[1747,1747],[1746,1746]]],[1544422345376,["gjx16@GJXAIOU",[[1,1681,"* "],[1,1703,"* "],[1,1726,"* "],[1,1747,"* "]],[1681,1764],[1683,1772]]],[1544422354235,["gjx16@GJXAIOU",[[1,1579,"* "],[1,1597,"* "],[1,1616,"* "],[1,1628,"* "],[1,1645,"* "],[1,1646,"* "]],[1579,1668],[1581,1680]]],[1544422357219,["gjx16@GJXAIOU",[[-1,1653,"* "]],[1655,1655],[1653,1653]]],[1544422357702,["gjx16@GJXAIOU",[[-1,1653,"\n"]],[1653,1653],[1652,1652]]],[1544422374452,["gjx16@GJXAIOU",[[-1,1844,"C++中可以使用纯虚函数实现接口"]],[1844,1860],[1844,1844]]],[1544422380998,["gjx16@GJXAIOU",[[-1,1784,"#include \"iostream\"\n\nusing namespace std;\n\n/*\n\nC++中没有接口的概念\n\n\n\n接口类中只有函数原型定义，没有任何数据的定义。\n\n*/"]],[1784,1873],[1784,1784]]],[1544422383915,["gjx16@GJXAIOU",[[-1,1785,"\n"]],[1784,1784],[1783,1783]]],[1544422384065,["gjx16@GJXAIOU",[[-1,1784,"\n"]],[1783,1783],[1782,1782]]],[1544422402152,["gjx16@GJXAIOU",[[1,1783,"抽象类在多继承中的应用的示例程序："]],[1783,1783],[1800,1800]]],[1544422405335,["gjx16@GJXAIOU",[[-1,1689,"\n"]],[1689,1689],[1688,1688]]],[1544422408373,["gjx16@GJXAIOU",[[-1,1578,"\n"]],[1578,1578],[1577,1577]]],[1544422504328,["gjx16@GJXAIOU",[[1,2590,"\n"]],[2589,2589],[2590,2590]]],[1544422510066,["gjx16@GJXAIOU",[[-1,2609,"\n"]],[2609,2609],[2608,2608]]],[1544422512341,["gjx16@GJXAIOU",[[-1,2785,"\n"]],[2785,2785],[2784,2784]]],[1544431634530,["gjx16@GJXAIOU",[[-1,5491,"CEncDesProtocol"],[1,5506,"ns-3.9-pyviz/summary"]],[5491,5506],[5511,5511]]],[1544431637876,["gjx16@GJXAIOU",[[1,5491,"CEncDesProtocol"],[-1,5491,"ns-3.9-pyviz/summary"]],[5511,5511],[5491,5506]]],[1544439986946,["gjx16@GJXAIOU",[[1,5763,"\n"]],[5761,5761],[5762,5762]]],[1544439989570,["gjx16@GJXAIOU",[[1,5764,"\n"]],[5762,5762],[5763,5763]]],[1544439993160,["gjx16@GJXAIOU",[[1,5763,"~~~~"]],[5763,5763],[5765,5765]]],[1544440009118,["gjx16@GJXAIOU",[[1,5765,"des.cpp程序没有，所以第1"]],[5765,5765],[5781,5781]]],[1544440009793,["gjx16@GJXAIOU",[[-1,5780,"1"]],[5781,5781],[5780,5780]]],[1544440026853,["gjx16@GJXAIOU",[[1,5780,"7天的第17-20视频没有看"]],[5780,5780],[5794,5794]]],[1544440451791,["gjx16@GJXAIOU",[[1,5930,"\n"]],[5928,5928],[5929,5929]]],[1544440452290,["gjx16@GJXAIOU",[[1,5931,"\n"]],[5929,5929],[5930,5930]]],[1544440452408,["gjx16@GJXAIOU",[[1,5932,"\n"]],[5930,5930],[5931,5931]]],[1544440452521,["gjx16@GJXAIOU",[[1,5933,"\n"]],[5931,5931],[5932,5932]]],[1544440452748,["gjx16@GJXAIOU",[[1,5934,"\n"]],[5932,5932],[5933,5933]]],[1544440452949,["gjx16@GJXAIOU",[[1,5935,"\n"]],[5933,5933],[5934,5934]]],[1544440453090,["gjx16@GJXAIOU",[[1,5936,"\n"]],[5934,5934],[5935,5935]]],[1544440453245,["gjx16@GJXAIOU",[[1,5937,"\n"]],[5935,5935],[5936,5936]]],[1544440453366,["gjx16@GJXAIOU",[[1,5938,"\n"]],[5936,5936],[5937,5937]]],[1544440453482,["gjx16@GJXAIOU",[[1,5939,"\n"]],[5937,5937],[5938,5938]]],[1544440453601,["gjx16@GJXAIOU",[[1,5940,"\n"]],[5938,5938],[5939,5939]]],[1544440453733,["gjx16@GJXAIOU",[[1,5941,"\n"]],[5939,5939],[5940,5940]]],[1544440454122,["gjx16@GJXAIOU",[[1,5942,"\n"]],[5940,5940],[5941,5941]]],[1544440454241,["gjx16@GJXAIOU",[[1,5943,"\n"]],[5941,5941],[5942,5942]]],[1544440454362,["gjx16@GJXAIOU",[[1,5944,"\n"]],[5942,5942],[5943,5943]]],[1544440454472,["gjx16@GJXAIOU",[[1,5945,"\n"]],[5943,5943],[5944,5944]]],[1544440454620,["gjx16@GJXAIOU",[[1,5946,"\n"]],[5944,5944],[5945,5945]]],[1544440460077,["gjx16@GJXAIOU",[[1,5928,"第21个"]],[5928,5928],[5932,5932]]],[1544440465139,["gjx16@GJXAIOU",[[-1,5928,"第21个"]],[5932,5932],[5928,5928]]],[1544440465593,["gjx16@GJXAIOU",[[-1,5946,"\n"]],[5928,5928],[5927,5927]]],[1544440466792,["gjx16@GJXAIOU",[[1,5927,"~~~~"]],[5927,5927],[5929,5929]]],[1544440473510,["gjx16@GJXAIOU",[[1,5929,"第21个视频上有"]],[5929,5929],[5937,5937]]]],null,"gjx16@GJXAIOU"],["2da6454d-eb17-4e23-859d-8639d849ee66",1544577782500,"# C_PP_章五 纯虚函数和抽象类\n\n\n## 一、基本概念\n\n**纯虚函数：**\n* 纯虚函数声明格式： `virtual 返回值类型   函数名（参数列表）= 0 `\n* 纯虚函数是一个在基类中声明的虚函数，但是在基类中并没有定义（即没有具体的代码实现），但是要求任何的派生类都要实现属于自己的这个函数；\n* 纯虚函数为各派生类提供一个公共界面（接口的封装和设计、软件的模块功能划分）\n\n**抽象类：**\n  一个具有纯虚函数的基类被称为抽象类\n\n\n![image072]($resource/image072.png)\n![image073]($resource/image073.png)\n\n\n\n## 二、抽象类案例\n![image074]($resource/image074.png)\n![image075]($resource/image075.png)\n```cpp\n//纯虚函数抽象类语法基础\n\n\n#include \"iostream\"\nusing namespace std;\n\nclass Figure\n{\npublic:\n\tvirtual void Area() = 0;   //声明一个纯虚函数，基类中不需要实现，在下面每一个继承类都需要按照各自需求进行实现\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\nclass circle :public Figure\n{\npublic:\n\tcircle(int r,int a, int b)\n\t{\n\t\tthis->r = r;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"圆的面积 \" << 3.14*r*r << endl;\n\t}\nprivate:\n\tint r;\n};\n\n\nclass rectangle :public Figure\n{\npublic:\n\trectangle(int length, int width, int a, int b)\n\t{\n\t\tthis->length = length;\n\t\tthis->width = width;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"长方形的面积 \" << length * width << endl;\n\t}\nprivate:\n\tint length;\n\tint width;\n};\n\nvoid getArea(Figure *base)\n{\n\tbase->Area();\n}\n\n\n\nint main()\n{\n\t\n\t//Figure f1;//这是错误的，抽象类不能实例化\n\tFigure *p = NULL;   //但是可以使用指针和引用\n\tcircle c1(2, 1, 2);\n\trectangle r1(1, 2, 3, 4);\n\n\tgetArea(&c1);\n\tgetArea(&r1);\n\tsystem(\"pause\");\n\treturn 0;\n} \n```\n\n\n## 三、抽象类在多继承中的应用\n\nC++中没有Java中的接口概念，抽象类可以模拟Java中的接口类。（接口和协议）\n\n\n\n### （一）有关多继承的说明\n\n**工程上的多继承**\n\n* 被实际开发经验抛弃的多继承\n* 工程开发中真正意义上的多继承是几乎不被使用的\n* 多重继承带来的代码复杂性远多于其带来的便利\n* 多重继承对代码维护性上的影响是灾难性的\n* 在设计方法上，任何多继承都可以用单继承代替 \n\n**多继承中的二义性和多继承不能解决的问题 **\n![image076]($resource/image076.png)\n\n\n### （二）多继承的应用场景\n\n* 绝大多数面向对象语言都不支持多继承\n* 绝大多数面向对象语言都支持接口的概念\n* C++中没有接口的概念\n* C++中可以使用纯虚函数实现接口\n* 接口类中只有函数原型定义，没有任何数据的定义\n\n\n实际工程经验证明\n* 多重继承接口不会带来二义性和复杂性等问题 \n* 多重继承可以通过精心设计用单继承和接口来代替\n* 接口类只是一个功能说明，而不是功能实现。\n* 子类需要根据功能说明定义功能实现。\n\n抽象类在多继承中的应用的示例程序：\n```cpp\n//抽象类在多继承中的应用\n\n#include \"iostream\"\nusing namespace std;\n\nclass Interface1\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n};\n\nclass Interface2\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n\tvirtual int minus(int a, int b) = 0;\n};\n\nclass parent\n{\npublic:\n\tint a;\n};\n\nclass Child : public parent, public Interface1, public Interface2\n{\npublic:\n\tvoid print()\n\t{\n\t\tcout << \"Child::print\" << endl;\n\t}\n\n\tint add(int a, int b)\n\t{\n\t\treturn a + b;\n\t}\n\n\tint minus(int a, int b)\n\t{\n\t\treturn a - b;\n\t}\n\n};\n\nint main()\n{\n\n\tChild c;\n\tc.print();\n\tcout << c.add(3, 5) << endl;\n\tcout << c.minus(4, 6) << endl;\n\n\tInterface1* i1 = &c;\n\tInterface2* i2 = &c;\n\n\tcout << i1->add(7, 8) << endl;\n\tcout << i2->add(7, 8) << endl;\n\n\tsystem(\"pause\");\n\n}\n```\n\n\n\n\n## 四、抽象类知识点强化\n\n/*\n编写一个C++程序, 计算程序员( programmer )工资 \n 1 要求能计算出初级程序员( junior_programmer ) 中级程序员 ( mid_programmer )高级程序员( adv_programmer)的工资\n 2 要求利用抽象类统一界面,方便程序的扩展, 比如:新增, 计算 架构师 (architect ) 的工资 \n*/\n~~调用的时候参数有点问题~~\n```cpp\n//抽象类知识点的强化\n\n\n#include \"iostream\"\n#include \"sstream\"\nusing namespace std;\n\nclass programmer\n{\npublic:\n\tvirtual void getSal() = 0;\nprotected:\nprivate:\n};\n\nclass junior_programmer :public programmer\n{\npublic:\n\tjunior_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"junior_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\nclass mid_programmer :public programmer\n{\npublic:\n\tmid_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"mid_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n\nclass adv_programmer :public programmer\n{\npublic:\n\tadv_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"adv_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n//接下来为后期可以拓展的部分\n\n\nclass architect :public programmer\n{\npublic:\n\tarchitect(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"architect:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n//以上为后期拓展部分\n\nvoid pro_sale(programmer *base)\n{\n\tbase->getSal();\n}\n\n\nint main()\n{\n\tjunior_programmer jp(\"张三\",\"初级\",2000);\n\tmid_programmer mp(\"小张\", \"中级\", 8000);\n\tadv_programmer ap(\"小李\", \"高级\", 20394);\n\n\tpro_sale(&jp);\n\tpro_sale(&mp);\n\tpro_sale(&ap);\n\n\n\t//后期新增程序的调用\n\n\tarchitect ar(\"架构师\", \"牛\", 121332);\n\tpro_sale(&ar);\n\tsystem(\"pause\");\n\treturn 0; \n\n}\n```\n\n\n\n\n## 五、面向抽象类编程思想强化\n\n理论知识\n\nØ 虚函数和多态性使成员函数根据调用对象的类型产生不同的动作\n\nØ  多态性特别适合于实现分层结构的软件系统，便于对问题抽象时  定义共性，实现时定义区别\n\nØ **面向抽象类编程（面向接口编程）**是项目开发中重要技能之一。\n\n\n### （一）案例：socket库c++模型设计和实现\n\n**企业信息系统框架集成第三方产品**\n\n**案例背景**：一般的企业信息系统都有成熟的框架。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求**：请你在**企业信息系统框架**中集成第三方厂商的Socket通信产品和第三方厂商加密产品。\n\n第三方厂商的Socket通信产品：完成两点之间的通信；\n\n第三方厂商加密产品：完成数据发送时加密；数据解密时解密。\n\n![image077]($resource/image077.png)\n\n**案例要求**： 1）能支持多个厂商的Socket通信产品入围\n\n 2）能支持多个第三方厂商加密产品的入围\n\n 3）企业信息系统框架不轻易发生框架\n\n**需求实现**\n\n  思考1：企业信息系统框架、第三方产品如何分层\n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分成以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n分析有多少个类 CSocketProtocol  CSckFactoryImp1  CSckFactoryImp2\n\nCEncDesProtocol  HwEncdes  ciscoEncdes\n\n1、 定义 CSocketProtocol 抽象类\n\n2、 编写框架函数\n\n3、 编写框架测试函数\n\n4、 厂商1（CSckFactoryImp1）实现CSocketProtocol、厂商2（CSckFactoryImp1）实现CSocketProtocol\n\n5、 抽象加密接口（CEncDesProtocol）、加密厂商1(CHwImp)、加密厂商2(CCiscoImp))，集成实现业务模型\n\n6、 框架（c语言函数方式，框架函数；c++类方式，框架类）\n\n~~des.cpp程序没有，所以第7天的第17-20视频没有看~~\n\n**几个重要的面向对象思想**\n\n继承-组合（强弱）\n\n注入\n\n控制反转 IOC\n\nMVC\n\n  面向对象思想扩展aop思想\n\n aop思想是对继承编程思想的有力的补充\n\n\n### （二）案例：计算员工工资\n\n\n### （三）案例：计算几何体的表面积和体积\n~~第21个视频上有~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 六、面向接口编程和C多态\n\n友情提示：今天课程内容，更加贴近实战，并且语法和软件思想都较难，请学员紧跟思路。课后加强复习！\n\n结论：  只要你动手，又很容易！\n\n\n\n### （一）函数类型语法基础\n\n\n函数三要素：  名称、参数、返回值\n\nC语言中的函数有自己特定的类型\n \n\nC语言中通过typedef为函数类型重命名\n\ntypedef type name(parameter list)\n\ntypedef int f(int, int);\n\ntypedef void p(int);\n\n |\n| \n\n函数指针\n\n |\n| \n\n函数指针用于指向一个函数\n\n函数名是函数体的入口地址\n\n1)可通过函数类型定义函数指针: FuncType* pointer;\n\n2)也可以直接定义：type (*pointer)(parameter list);\n\npointer为函数指针变量名\n\ntype为指向函数的返回值类型\n\nparameter list为指向函数的参数类型列表\n\n |\n| \n\n函数指针语法梳理\n\n//函数类型\n\n//函数指针类型\n\n//函数指针变量\n\n数组指针语法梳理 \n\n//数组类型语法\n\n//数组指针类型\n\n//数组指针变量\n\n |\n| \n\ntypedef int(FUNC)(int);\n\nint test(int i)\n\n{\n\n return i * i;\n\n}\n\nvoid f()\n\n{\n\n printf(\"Call f()...\\n\");\n\n}\n\nint main()\n\n{\n\n FUNC* pt = test;\n\n void(*pf)() = &f;\n\n pf();\n\n (*pf)();\n\n printf(\"Function pointer call: %d\\n\", pt(3));\n\n}\n\n |\n\n### （二）函数指针做函数参数\n\n| \n\n1、 指针做函数参数pk函数指针做函数参数\n\n回忆指针做函数参数\n\n一级指针做函数参数、二级。。。。、三级\n\n |\n| \n\n2、 函数指针做函数参数\n\n当函数指针 做为函数的参数，传递给一个被调用函数，\n\n被调用函数就可以通过这个指针调用外部的函数，这就形成了回调\n\n |\n| \n\n3、练习\n\nint add(int a, int b) \n\nint libfun( int (*pDis)(int a, int b) );\n\nint main(void)\n\n{\n\n int (*pfun)(int a, int b);  \n\n pfun = add;\n\n libfun(pfun);\n\n}\n\nint add(int a, int b)\n\n{\n\n return a + b;\n\n}\n\nint libfun( int (*pDis)(int a, int b) )\n\n{\n\n  int a, b;\n\n  a = 1;\n\n  b = 2;\n\nadd(1,3) //直接调用add函数\n\nprintf(\"%d\", pDis(a, b)); //通过函数指针做函数参数,间接调用add函数\n\n//思考 这样写 pDis(a, b)有什么好处?\n\n}\n\n//剖析思路\n\n//1函数的调用 和 函数的实现  有效的分离\n\n//2 C++的多态,可扩展\n\n现在这几个函数是在同一个文件当中\n\n假如\n\nint libfun(int (*pDis)(int a, int b))\n\n是一个库中的函数，就只有使用回调了，通过函数指针参数将外部函数地址传入\n\n来实现调用\n\n函数 add 的代码作了修改，也不必改动库的代码，就可以正常实现调用\n\n便于程序的维护和升级\n\n |\n\n回调函数思想：\n![image078]($resource/image078.png)\n结论：回调函数的本质：提前做了一个协议的约定（把函数的参数、函数返回值提前约定）\n\n请思考：C编译器通过那个具体的语法，实现解耦合的？\n\n C++编译器通过多态的机制(提前布局vptr指针和虚函数表,找虚函数入口地址来实现)\n\n### （三）函数指针正向调用\n\n| \n\n1、 函数指针做函数参数，调用方式\n\n被调用函数和主调函数在同一文件中（用来教学，没有任何意义）\n\n |\n| \n\n2、函数指针做函数参数\n\n被调用函数和主调函数不在同一个文件中、模块中。\n\n难点：理解被调用函数是什么机制被调用起来的。框架\n\n框架提前设置了被调用函数的入口（框架提供了第三方模块入口地址的集成功能）\n\n框架具备调用第三方模块入口函数\n\n |\n| \n\n3、 练习\n\ntypedef int (*EncDataFunc)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\nint MyEncDataFunc(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen)\n\n{\n\n int rv = 0;\n\n char *p = \"222222222222\";\n\n strcpy(outData, p);\n\n *outDataLen = strlen(p);\n\n return rv;\n\n}\n\nint Send_Data(EncDataFunc encDataFunc, unsigned char *inData, int inDataLen, unsigned char *outData, int *outDatalen)\n\n{\n\n int rv = 0;\n\n if (encDataFunc != NULL)\n\n {\n\n rv = encDataFunc(inData, inDataLen, outData, outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"func encDataFunc() err.\\n\");\n\n return rv;\n\n }\n\n }\n\n return rv;\n\n}\n\nint main()\n\n{\n\n int rv = 0;\n\n EncDataFunc encDataFunc = NULL;\n\n encDataFunc = MyEncDataFunc;\n\n // 第一个调用\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"1111\");\n\n inDataLen = strlen(inData);\n\n rv = encDataFunc(inData,inDataLen, outData, &outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"edf err .....\\n\");\n\n }\n\n else\n\n {\n\n printf(\"edf ok \\n\");\n\n printf(\"%s \\n\", outData);\n\n }\n\n }\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"3333\");\n\n inDataLen = strlen(inData);\n\n rv = Send_Data(MyEncDataFunc, inData, inDataLen, outData, &outDatalen);\n\n if (rv != 0)\n\n {\n\n printf(\"func Send_Data err:%d\", rv);\n\n return rv;\n\n }\n\n printf(\"%s \\n\", outData);\n\n }\n\n getchar();\n\n}\n\n |\n\n### （四）函数指针反向调用\n\n回调函数效果展示。\n\n\n### （五）C动态库升级成框架案例\n\n**C****语言版本Socket****动态库升级成框架集成第三方产品**\n\n**简称：C****动态库升级成框架案例**\n\n**名字解释       **\n\n  动态库：抽象类一个套接口，单独封装成模块，供别人调用；无法扩展。\n\n  框架：能自由的扩展 \n\n**案例背景**：一般的企业信息系统都有成熟的框架，可以有C语言写，也可以由C++语言。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求：**在socket通信库中，完成数据加密功能，有n个厂商的加密产品供你选择，如何实现动态库和第三个厂商产品的解耦合。\n\n提醒：C++通过抽象类，也就是面向抽象类编程实现的（相当于C++编译器通过多态机制，已经很好用了。提前布局vptr指针、虚函数表；调用是迟绑定完成。），\n\n**C****语言**中如何实现哪？\n\n**案例要求**： 1）能支持多个第三方厂商加密产品的入围\n\n 2）企业信息系统框架不轻易发生框架\n\n**需求实现思路分析**\n![image079]($resource/image079.png)\n  思考1：企业信息系统框架、第三方产品如何分层 \n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分层确定后，动态库应该做什么？产品入围厂商应该做什么？\n\n以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n1、 动态库中定义协议，并完成任务的调用\n\ntypedef int (*EncData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\ntypedef int (*DecData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\n2、 加密厂商完成协议函数的编写\n\n3、 对接调试。\n\n4、 动态库中可以缓存第三方函数的入口地址，也可以不缓存，两种实现方式。\n\n**案例总结**\n\n  回调函数：利用函数指针做函数参数，实现的一种调用机制，具体任务的实现者，可以不知道什么时候被调用。\n\n  回调机制原理：\n\n  当具体事件发生时，调用者通过函数指针调用具体函数\n\n  回调机制的将调用者和被调函数分开，两者互不依赖\n\n  任务的实现 和 任务的调用 可以耦合  （提前进行接口的封装和设计）\n\n### （六）附录：诸葛亮的锦囊妙计**\n\n刘备利用周瑜、曹仁厮杀之际，乘虚袭取了南郡、荆州、襄阳，以后又征服了长沙等四郡。周瑜想想十分气恨，正无处报复以夺还荆州。不久，刘备忽然丧偶，周瑜计上心来，对孙权说：“您的妹妹，美丽、刚强，我们以联姻抗曹名义向刘备招亲，把他骗来南徐幽禁，逼他们拿荆州来换。”孙权大喜，郎派人到荆州说亲。\n\n刘备认为这是骗局，想要拒绝，诸葛亮笑道：“送个好妻子上门何不答应？您只管去东吴，我叫赵云陪您去，自有安排，包您得了夫人又不失荆州。”\n\n接着，诸葛亮暗暗关照赵云道：“我这里有三个锦囊，内藏三条妙计。到南徐时打开第一个，到年底时打开第二个，危急无路时打开第三个。”\n\n第一个锦囊\n\n  一到东吴就拜会乔国老\n\n第二个锦囊\n\n  刘备被孙权设计留下就对他谎称曹操大军压境\n\n第三个锦囊\n\n被东吴军队追赶就求孙夫人解围\n",[[1544577765360,["gjx16@GJXAIOU",[[1,226,"****"]],[226,226],[228,228]]],[1544577768960,["gjx16@GJXAIOU",[[1,228,"注意点："]],[228,228],[232,232]]],[1544577770980,["gjx16@GJXAIOU",[[1,235,"\n"]],[234,234],[235,235]]],[1544577774671,["gjx16@GJXAIOU",[[1,235,"```cpp"]],[235,235],[241,241]]],[1544577775020,["gjx16@GJXAIOU",[[1,242,"\n"]],[241,241],[242,242]]],[1544577775431,["gjx16@GJXAIOU",[[1,243,"\n"]],[242,242],[243,243]]],[1544577775590,["gjx16@GJXAIOU",[[1,244,"\n"]],[243,243],[244,244]]],[1544577776268,["gjx16@GJXAIOU",[[1,244,"```"]],[244,244],[247,247]]],[1544577807837,["gjx16@GJXAIOU",[[1,242,"class shag"]],[242,242],[252,252]]],[1544577808683,["gjx16@GJXAIOU",[[-1,251,"g"]],[252,252],[251,251]]],[1544577810623,["gjx16@GJXAIOU",[[1,251,"pe"]],[251,251],[253,253]]]],null,"gjx16@GJXAIOU"],["4fc98522-52a8-471b-9f4d-7d02d20eab23",1544581281181,"# C_PP_章五 纯虚函数和抽象类\n\n\n## 一、基本概念\n\n**纯虚函数：**\n* 纯虚函数声明格式： `virtual 返回值类型   函数名（参数列表）= 0 `\n* 纯虚函数是一个在基类中声明的虚函数，但是在基类中并没有定义（即没有具体的代码实现），但是要求任何的派生类都要实现属于自己的这个函数；\n* 纯虚函数为各派生类提供一个公共界面（接口的封装和设计、软件的模块功能划分）\n\n**抽象类：**\n  一个具有纯虚函数的基类被称为抽象类\n\n**注意点：**\n```cpp\nclass shape\n\n```\n![image072]($resource/image072.png)\n![image073]($resource/image073.png)\n\n\n\n## 二、抽象类案例\n![image074]($resource/image074.png)\n![image075]($resource/image075.png)\n```cpp\n//纯虚函数抽象类语法基础\n\n\n#include \"iostream\"\nusing namespace std;\n\nclass Figure\n{\npublic:\n\tvirtual void Area() = 0;   //声明一个纯虚函数，基类中不需要实现，在下面每一个继承类都需要按照各自需求进行实现\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\nclass circle :public Figure\n{\npublic:\n\tcircle(int r,int a, int b)\n\t{\n\t\tthis->r = r;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"圆的面积 \" << 3.14*r*r << endl;\n\t}\nprivate:\n\tint r;\n};\n\n\nclass rectangle :public Figure\n{\npublic:\n\trectangle(int length, int width, int a, int b)\n\t{\n\t\tthis->length = length;\n\t\tthis->width = width;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"长方形的面积 \" << length * width << endl;\n\t}\nprivate:\n\tint length;\n\tint width;\n};\n\nvoid getArea(Figure *base)\n{\n\tbase->Area();\n}\n\n\n\nint main()\n{\n\t\n\t//Figure f1;//这是错误的，抽象类不能实例化\n\tFigure *p = NULL;   //但是可以使用指针和引用\n\tcircle c1(2, 1, 2);\n\trectangle r1(1, 2, 3, 4);\n\n\tgetArea(&c1);\n\tgetArea(&r1);\n\tsystem(\"pause\");\n\treturn 0;\n} \n```\n\n\n## 三、抽象类在多继承中的应用\n\nC++中没有Java中的接口概念，抽象类可以模拟Java中的接口类。（接口和协议）\n\n\n\n### （一）有关多继承的说明\n\n**工程上的多继承**\n\n* 被实际开发经验抛弃的多继承\n* 工程开发中真正意义上的多继承是几乎不被使用的\n* 多重继承带来的代码复杂性远多于其带来的便利\n* 多重继承对代码维护性上的影响是灾难性的\n* 在设计方法上，任何多继承都可以用单继承代替 \n\n**多继承中的二义性和多继承不能解决的问题 **\n![image076]($resource/image076.png)\n\n\n### （二）多继承的应用场景\n\n* 绝大多数面向对象语言都不支持多继承\n* 绝大多数面向对象语言都支持接口的概念\n* C++中没有接口的概念\n* C++中可以使用纯虚函数实现接口\n* 接口类中只有函数原型定义，没有任何数据的定义\n\n\n实际工程经验证明\n* 多重继承接口不会带来二义性和复杂性等问题 \n* 多重继承可以通过精心设计用单继承和接口来代替\n* 接口类只是一个功能说明，而不是功能实现。\n* 子类需要根据功能说明定义功能实现。\n\n抽象类在多继承中的应用的示例程序：\n```cpp\n//抽象类在多继承中的应用\n\n#include \"iostream\"\nusing namespace std;\n\nclass Interface1\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n};\n\nclass Interface2\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n\tvirtual int minus(int a, int b) = 0;\n};\n\nclass parent\n{\npublic:\n\tint a;\n};\n\nclass Child : public parent, public Interface1, public Interface2\n{\npublic:\n\tvoid print()\n\t{\n\t\tcout << \"Child::print\" << endl;\n\t}\n\n\tint add(int a, int b)\n\t{\n\t\treturn a + b;\n\t}\n\n\tint minus(int a, int b)\n\t{\n\t\treturn a - b;\n\t}\n\n};\n\nint main()\n{\n\n\tChild c;\n\tc.print();\n\tcout << c.add(3, 5) << endl;\n\tcout << c.minus(4, 6) << endl;\n\n\tInterface1* i1 = &c;\n\tInterface2* i2 = &c;\n\n\tcout << i1->add(7, 8) << endl;\n\tcout << i2->add(7, 8) << endl;\n\n\tsystem(\"pause\");\n\n}\n```\n\n\n\n\n## 四、抽象类知识点强化\n\n/*\n编写一个C++程序, 计算程序员( programmer )工资 \n 1 要求能计算出初级程序员( junior_programmer ) 中级程序员 ( mid_programmer )高级程序员( adv_programmer)的工资\n 2 要求利用抽象类统一界面,方便程序的扩展, 比如:新增, 计算 架构师 (architect ) 的工资 \n*/\n~~调用的时候参数有点问题~~\n```cpp\n//抽象类知识点的强化\n\n\n#include \"iostream\"\n#include \"sstream\"\nusing namespace std;\n\nclass programmer\n{\npublic:\n\tvirtual void getSal() = 0;\nprotected:\nprivate:\n};\n\nclass junior_programmer :public programmer\n{\npublic:\n\tjunior_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"junior_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\nclass mid_programmer :public programmer\n{\npublic:\n\tmid_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"mid_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n\nclass adv_programmer :public programmer\n{\npublic:\n\tadv_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"adv_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n//接下来为后期可以拓展的部分\n\n\nclass architect :public programmer\n{\npublic:\n\tarchitect(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"architect:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n//以上为后期拓展部分\n\nvoid pro_sale(programmer *base)\n{\n\tbase->getSal();\n}\n\n\nint main()\n{\n\tjunior_programmer jp(\"张三\",\"初级\",2000);\n\tmid_programmer mp(\"小张\", \"中级\", 8000);\n\tadv_programmer ap(\"小李\", \"高级\", 20394);\n\n\tpro_sale(&jp);\n\tpro_sale(&mp);\n\tpro_sale(&ap);\n\n\n\t//后期新增程序的调用\n\n\tarchitect ar(\"架构师\", \"牛\", 121332);\n\tpro_sale(&ar);\n\tsystem(\"pause\");\n\treturn 0; \n\n}\n```\n\n\n\n\n## 五、面向抽象类编程思想强化\n\n理论知识\n\nØ 虚函数和多态性使成员函数根据调用对象的类型产生不同的动作\n\nØ  多态性特别适合于实现分层结构的软件系统，便于对问题抽象时  定义共性，实现时定义区别\n\nØ **面向抽象类编程（面向接口编程）**是项目开发中重要技能之一。\n\n\n### （一）案例：socket库c++模型设计和实现\n\n**企业信息系统框架集成第三方产品**\n\n**案例背景**：一般的企业信息系统都有成熟的框架。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求**：请你在**企业信息系统框架**中集成第三方厂商的Socket通信产品和第三方厂商加密产品。\n\n第三方厂商的Socket通信产品：完成两点之间的通信；\n\n第三方厂商加密产品：完成数据发送时加密；数据解密时解密。\n\n![image077]($resource/image077.png)\n\n**案例要求**： 1）能支持多个厂商的Socket通信产品入围\n\n 2）能支持多个第三方厂商加密产品的入围\n\n 3）企业信息系统框架不轻易发生框架\n\n**需求实现**\n\n  思考1：企业信息系统框架、第三方产品如何分层\n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分成以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n分析有多少个类 CSocketProtocol  CSckFactoryImp1  CSckFactoryImp2\n\nCEncDesProtocol  HwEncdes  ciscoEncdes\n\n1、 定义 CSocketProtocol 抽象类\n\n2、 编写框架函数\n\n3、 编写框架测试函数\n\n4、 厂商1（CSckFactoryImp1）实现CSocketProtocol、厂商2（CSckFactoryImp1）实现CSocketProtocol\n\n5、 抽象加密接口（CEncDesProtocol）、加密厂商1(CHwImp)、加密厂商2(CCiscoImp))，集成实现业务模型\n\n6、 框架（c语言函数方式，框架函数；c++类方式，框架类）\n\n~~des.cpp程序没有，所以第7天的第17-20视频没有看~~\n\n**几个重要的面向对象思想**\n\n继承-组合（强弱）\n\n注入\n\n控制反转 IOC\n\nMVC\n\n  面向对象思想扩展aop思想\n\n aop思想是对继承编程思想的有力的补充\n\n\n### （二）案例：计算员工工资\n\n\n### （三）案例：计算几何体的表面积和体积\n~~第21个视频上有~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 六、面向接口编程和C多态\n\n友情提示：今天课程内容，更加贴近实战，并且语法和软件思想都较难，请学员紧跟思路。课后加强复习！\n\n结论：  只要你动手，又很容易！\n\n\n\n### （一）函数类型语法基础\n\n\n函数三要素：  名称、参数、返回值\n\nC语言中的函数有自己特定的类型\n \n\nC语言中通过typedef为函数类型重命名\n\ntypedef type name(parameter list)\n\ntypedef int f(int, int);\n\ntypedef void p(int);\n\n |\n| \n\n函数指针\n\n |\n| \n\n函数指针用于指向一个函数\n\n函数名是函数体的入口地址\n\n1)可通过函数类型定义函数指针: FuncType* pointer;\n\n2)也可以直接定义：type (*pointer)(parameter list);\n\npointer为函数指针变量名\n\ntype为指向函数的返回值类型\n\nparameter list为指向函数的参数类型列表\n\n |\n| \n\n函数指针语法梳理\n\n//函数类型\n\n//函数指针类型\n\n//函数指针变量\n\n数组指针语法梳理 \n\n//数组类型语法\n\n//数组指针类型\n\n//数组指针变量\n\n |\n| \n\ntypedef int(FUNC)(int);\n\nint test(int i)\n\n{\n\n return i * i;\n\n}\n\nvoid f()\n\n{\n\n printf(\"Call f()...\\n\");\n\n}\n\nint main()\n\n{\n\n FUNC* pt = test;\n\n void(*pf)() = &f;\n\n pf();\n\n (*pf)();\n\n printf(\"Function pointer call: %d\\n\", pt(3));\n\n}\n\n |\n\n### （二）函数指针做函数参数\n\n| \n\n1、 指针做函数参数pk函数指针做函数参数\n\n回忆指针做函数参数\n\n一级指针做函数参数、二级。。。。、三级\n\n |\n| \n\n2、 函数指针做函数参数\n\n当函数指针 做为函数的参数，传递给一个被调用函数，\n\n被调用函数就可以通过这个指针调用外部的函数，这就形成了回调\n\n |\n| \n\n3、练习\n\nint add(int a, int b) \n\nint libfun( int (*pDis)(int a, int b) );\n\nint main(void)\n\n{\n\n int (*pfun)(int a, int b);  \n\n pfun = add;\n\n libfun(pfun);\n\n}\n\nint add(int a, int b)\n\n{\n\n return a + b;\n\n}\n\nint libfun( int (*pDis)(int a, int b) )\n\n{\n\n  int a, b;\n\n  a = 1;\n\n  b = 2;\n\nadd(1,3) //直接调用add函数\n\nprintf(\"%d\", pDis(a, b)); //通过函数指针做函数参数,间接调用add函数\n\n//思考 这样写 pDis(a, b)有什么好处?\n\n}\n\n//剖析思路\n\n//1函数的调用 和 函数的实现  有效的分离\n\n//2 C++的多态,可扩展\n\n现在这几个函数是在同一个文件当中\n\n假如\n\nint libfun(int (*pDis)(int a, int b))\n\n是一个库中的函数，就只有使用回调了，通过函数指针参数将外部函数地址传入\n\n来实现调用\n\n函数 add 的代码作了修改，也不必改动库的代码，就可以正常实现调用\n\n便于程序的维护和升级\n\n |\n\n回调函数思想：\n![image078]($resource/image078.png)\n结论：回调函数的本质：提前做了一个协议的约定（把函数的参数、函数返回值提前约定）\n\n请思考：C编译器通过那个具体的语法，实现解耦合的？\n\n C++编译器通过多态的机制(提前布局vptr指针和虚函数表,找虚函数入口地址来实现)\n\n### （三）函数指针正向调用\n\n| \n\n1、 函数指针做函数参数，调用方式\n\n被调用函数和主调函数在同一文件中（用来教学，没有任何意义）\n\n |\n| \n\n2、函数指针做函数参数\n\n被调用函数和主调函数不在同一个文件中、模块中。\n\n难点：理解被调用函数是什么机制被调用起来的。框架\n\n框架提前设置了被调用函数的入口（框架提供了第三方模块入口地址的集成功能）\n\n框架具备调用第三方模块入口函数\n\n |\n| \n\n3、 练习\n\ntypedef int (*EncDataFunc)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\nint MyEncDataFunc(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen)\n\n{\n\n int rv = 0;\n\n char *p = \"222222222222\";\n\n strcpy(outData, p);\n\n *outDataLen = strlen(p);\n\n return rv;\n\n}\n\nint Send_Data(EncDataFunc encDataFunc, unsigned char *inData, int inDataLen, unsigned char *outData, int *outDatalen)\n\n{\n\n int rv = 0;\n\n if (encDataFunc != NULL)\n\n {\n\n rv = encDataFunc(inData, inDataLen, outData, outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"func encDataFunc() err.\\n\");\n\n return rv;\n\n }\n\n }\n\n return rv;\n\n}\n\nint main()\n\n{\n\n int rv = 0;\n\n EncDataFunc encDataFunc = NULL;\n\n encDataFunc = MyEncDataFunc;\n\n // 第一个调用\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"1111\");\n\n inDataLen = strlen(inData);\n\n rv = encDataFunc(inData,inDataLen, outData, &outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"edf err .....\\n\");\n\n }\n\n else\n\n {\n\n printf(\"edf ok \\n\");\n\n printf(\"%s \\n\", outData);\n\n }\n\n }\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"3333\");\n\n inDataLen = strlen(inData);\n\n rv = Send_Data(MyEncDataFunc, inData, inDataLen, outData, &outDatalen);\n\n if (rv != 0)\n\n {\n\n printf(\"func Send_Data err:%d\", rv);\n\n return rv;\n\n }\n\n printf(\"%s \\n\", outData);\n\n }\n\n getchar();\n\n}\n\n |\n\n### （四）函数指针反向调用\n\n回调函数效果展示。\n\n\n### （五）C动态库升级成框架案例\n\n**C****语言版本Socket****动态库升级成框架集成第三方产品**\n\n**简称：C****动态库升级成框架案例**\n\n**名字解释       **\n\n  动态库：抽象类一个套接口，单独封装成模块，供别人调用；无法扩展。\n\n  框架：能自由的扩展 \n\n**案例背景**：一般的企业信息系统都有成熟的框架，可以有C语言写，也可以由C++语言。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求：**在socket通信库中，完成数据加密功能，有n个厂商的加密产品供你选择，如何实现动态库和第三个厂商产品的解耦合。\n\n提醒：C++通过抽象类，也就是面向抽象类编程实现的（相当于C++编译器通过多态机制，已经很好用了。提前布局vptr指针、虚函数表；调用是迟绑定完成。），\n\n**C****语言**中如何实现哪？\n\n**案例要求**： 1）能支持多个第三方厂商加密产品的入围\n\n 2）企业信息系统框架不轻易发生框架\n\n**需求实现思路分析**\n![image079]($resource/image079.png)\n  思考1：企业信息系统框架、第三方产品如何分层 \n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分层确定后，动态库应该做什么？产品入围厂商应该做什么？\n\n以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n1、 动态库中定义协议，并完成任务的调用\n\ntypedef int (*EncData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\ntypedef int (*DecData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\n2、 加密厂商完成协议函数的编写\n\n3、 对接调试。\n\n4、 动态库中可以缓存第三方函数的入口地址，也可以不缓存，两种实现方式。\n\n**案例总结**\n\n  回调函数：利用函数指针做函数参数，实现的一种调用机制，具体任务的实现者，可以不知道什么时候被调用。\n\n  回调机制原理：\n\n  当具体事件发生时，调用者通过函数指针调用具体函数\n\n  回调机制的将调用者和被调函数分开，两者互不依赖\n\n  任务的实现 和 任务的调用 可以耦合  （提前进行接口的封装和设计）\n\n### （六）附录：诸葛亮的锦囊妙计**\n\n刘备利用周瑜、曹仁厮杀之际，乘虚袭取了南郡、荆州、襄阳，以后又征服了长沙等四郡。周瑜想想十分气恨，正无处报复以夺还荆州。不久，刘备忽然丧偶，周瑜计上心来，对孙权说：“您的妹妹，美丽、刚强，我们以联姻抗曹名义向刘备招亲，把他骗来南徐幽禁，逼他们拿荆州来换。”孙权大喜，郎派人到荆州说亲。\n\n刘备认为这是骗局，想要拒绝，诸葛亮笑道：“送个好妻子上门何不答应？您只管去东吴，我叫赵云陪您去，自有安排，包您得了夫人又不失荆州。”\n\n接着，诸葛亮暗暗关照赵云道：“我这里有三个锦囊，内藏三条妙计。到南徐时打开第一个，到年底时打开第二个，危急无路时打开第三个。”\n\n第一个锦囊\n\n  一到东吴就拜会乔国老\n\n第二个锦囊\n\n  刘备被孙权设计留下就对他谎称曹操大军压境\n\n第三个锦囊\n\n被东吴军队追赶就求孙夫人解围\n",[[1544581239923,["gjx16@GJXAIOU",[[1,255,"\n"]],[253,253],[254,254]]],[1544581241807,["gjx16@GJXAIOU",[[1,254,"{"]],[254,254],[255,255]]],[1544581242132,["gjx16@GJXAIOU",[[1,257,"\n"]],[255,255],[256,256]]],[1544581246994,["gjx16@GJXAIOU",[[1,256,"publlic"]],[256,256],[263,263]]],[1544581248242,["gjx16@GJXAIOU",[[-1,260,"lic"]],[263,263],[260,260]]],[1544581249920,["gjx16@GJXAIOU",[[1,260,"ic:"]],[260,260],[263,263]]],[1544581250299,["gjx16@GJXAIOU",[[1,265,"\n"]],[263,263],[264,264]]],[1544581259264,["gjx16@GJXAIOU",[[1,264,"  point ehre"]],[264,264],[276,276]]],[1544581260658,["gjx16@GJXAIOU",[[-1,272,"ehre"]],[276,276],[272,272]]],[1544581262296,["gjx16@GJXAIOU",[[1,272," "]],[272,272],[273,273]]],[1544581262949,["gjx16@GJXAIOU",[[-1,272," "]],[273,273],[272,272]]],[1544581266757,["gjx16@GJXAIOU",[[1,272,"where()"]],[272,272],[279,279]]],[1544581267046,["gjx16@GJXAIOU",[[1,280,"  \n"]],[279,279],[282,282]]],[1544581267757,["gjx16@GJXAIOU",[[1,282,"{"]],[282,282],[283,283]]],[1544581268077,["gjx16@GJXAIOU",[[1,284,"  \n"]],[283,283],[286,286]]],[1544581270471,["gjx16@GJXAIOU",[[1,286,"t"]],[286,286],[287,287]]],[1544581271036,["gjx16@GJXAIOU",[[-1,286,"t"]],[287,287],[286,286]]],[1544581274933,["gjx16@GJXAIOU",[[1,286,"return center;"]],[286,286],[300,300]]],[1544581275421,["gjx16@GJXAIOU",[[1,301,"  \n"]],[300,300],[303,303]]],[1544581277605,["gjx16@GJXAIOU",[[1,303,"}"]],[303,303],[304,304]]],[1544581278262,["gjx16@GJXAIOU",[[1,305,"  \n"]],[304,304],[307,307]]],[1544581289286,["gjx16@GJXAIOU",[[1,307,"virtual c"]],[307,307],[316,316]]],[1544581289722,["gjx16@GJXAIOU",[[-1,315,"c"]],[316,316],[315,315]]],[1544581297234,["gjx16@GJXAIOU",[[1,315,"void rotate()"]],[315,315],[328,328]]],[1544581301304,["gjx16@GJXAIOU",[[1,327,"int b"]],[327,327],[332,332]]],[1544581306145,["gjx16@GJXAIOU",[[1,333," = 0;"]],[333,333],[338,338]]],[1544581306517,["gjx16@GJXAIOU",[[1,339,"  \n"]],[338,338],[341,341]]],[1544581310197,["gjx16@GJXAIOU",[[1,341,"virtual coi"]],[341,341],[352,352]]],[1544581311405,["gjx16@GJXAIOU",[[-1,349,"coi"]],[352,352],[349,349]]],[1544581319688,["gjx16@GJXAIOU",[[1,349,"void draw() = 0;"]],[349,349],[365,365]]],[1544581322990,["gjx16@GJXAIOU",[[1,366,"  \n"]],[365,365],[368,368]]],[1544581324158,["gjx16@GJXAIOU",[[-1,366,"  "],[1,368,"\n"]],[368,368],[367,367]]],[1544581326984,["gjx16@GJXAIOU",[[1,367,"};"]],[367,367],[369,369]]],[1544581327669,["gjx16@GJXAIOU",[[1,371,"\n"]],[369,369],[370,370]]],[1544581337862,["gjx16@GJXAIOU",[[1,372,"\n"]],[370,370],[371,371]]],[1544581340016,["gjx16@GJXAIOU",[[1,371,"i"]],[371,371],[372,372]]],[1544581343103,["gjx16@GJXAIOU",[[1,374," main()"]],[374,374],[381,381]]],[1544581343348,["gjx16@GJXAIOU",[[1,383,"\n"]],[381,381],[382,382]]],[1544581344462,["gjx16@GJXAIOU",[[1,382,"{}"]],[382,382],[384,384]]],[1544581344732,["gjx16@GJXAIOU",[[1,386,"\n"]],[384,384],[385,385]]],[1544581346965,["gjx16@GJXAIOU",[[1,383,"\n"]],[383,383],[384,384]]],[1544581347293,["gjx16@GJXAIOU",[[1,384,"\n"]],[384,384],[385,385]]],[1544581348859,["gjx16@GJXAIOU",[[1,385,"\n"]],[384,384],[385,385]]],[1544581354893,["gjx16@GJXAIOU",[[1,385,"  return 0;"]],[385,385],[396,396]]],[1544581358473,["gjx16@GJXAIOU",[[1,384,"  shag"]],[384,384],[390,390]]],[1544581359485,["gjx16@GJXAIOU",[[-1,389,"g"]],[390,390],[389,389]]],[1544581370430,["gjx16@GJXAIOU",[[1,389,"pe s;  //cuo"]],[389,389],[401,401]]],[1544581371515,["gjx16@GJXAIOU",[[-1,398,"cuo"]],[401,401],[398,398]]],[1544581382977,["gjx16@GJXAIOU",[[1,398,"错误：抽象类不能建立对西南"]],[398,398],[411,411]]],[1544581384162,["gjx16@GJXAIOU",[[-1,408,"对西南"]],[411,411],[408,408]]],[1544581387092,["gjx16@GJXAIOU",[[1,408,"对象"]],[408,408],[410,410]]],[1544581460172,[null,[[-1,372,"\n\n"],[1,374,"nt"],[-1,381,"`"],[1,382,"\n"],[-1,424,"`"],[1,425,"\n"],[1,427,"``"]],[372,372],[429,429]]],[1544581460172,[null,[[1,372,"\n\n"],[-1,372,"nt"],[1,381,"`"],[-1,381,"\n"],[1,424,"`"],[-1,424,"\n"],[-1,427,"``"]],[429,429],[372,372]]],[1544581418428,["gjx16@GJXAIOU",[[1,413,"\n  "]],[410,410],[413,413]]],[1544581418547,["gjx16@GJXAIOU",[[1,413,"】"]],[413,413],[414,414]]],[1544581420892,["gjx16@GJXAIOU",[[-1,413,"】"]],[414,414],[413,413]]],[1544581422896,["gjx16@GJXAIOU",[[1,413,"chap"]],[413,413],[417,417]]],[1544581424490,["gjx16@GJXAIOU",[[-1,413,"chap"]],[417,417],[413,413]]],[1544581432236,["gjx16@GJXAIOU",[[1,413,"shape *s; //keyi"]],[413,413],[429,429]]],[1544581433570,["gjx16@GJXAIOU",[[-1,425,"keyi"]],[429,429],[425,425]]],[1544581448096,["gjx16@GJXAIOU",[[1,425,"可以：可以声明抽象类的指针"]],[425,425],[438,438]]],[1544581450054,["gjx16@GJXAIOU",[[1,441,"\n  "]],[438,438],[441,441]]],[1544581456629,["gjx16@GJXAIOU",[[1,441,"shape f();;"]],[441,441],[452,452]]],[1544581457786,["gjx16@GJXAIOU",[[-1,451,";"]],[452,452],[451,451]]],[1544581458877,["gjx16@GJXAIOU",[[1,451,"//"]],[451,451],[453,453]]],[1544581520180,[null,[[-1,372,"\n\n"],[1,374,"nt"],[-1,381,"`"],[1,382,"\n"],[-1,467,"`"],[1,468,"\n"],[1,470,"``"]],[372,372],[472,472]]],[1544581520180,[null,[[1,372,"\n\n"],[-1,372,"nt"],[1,381,"`"],[-1,381,"\n"],[1,467,"`"],[-1,467,"\n"],[-1,470,"``"]],[472,472],[372,372]]],[1544581466738,["gjx16@GJXAIOU",[[1,453,"错误：邂逅爱心蕾不能"]],[453,453],[463,463]]],[1544581468786,["gjx16@GJXAIOU",[[-1,456,"邂逅爱心蕾不能"]],[463,463],[456,456]]],[1544581477760,["gjx16@GJXAIOU",[[1,456,"抽象类不能作为返回类型"]],[456,456],[467,467]]],[1544581478567,["gjx16@GJXAIOU",[[1,470,"\n  "]],[467,467],[470,470]]],[1544581482312,["gjx16@GJXAIOU",[[1,470,"vois d"]],[470,470],[476,476]]],[1544581483699,["gjx16@GJXAIOU",[[-1,475,"d"]],[476,476],[475,475]]],[1544581484830,["gjx16@GJXAIOU",[[1,475,"f()"]],[475,475],[478,478]]],[1544581485859,["gjx16@GJXAIOU",[[-1,475,"f()"]],[478,478],[475,475]]],[1544581487350,["gjx16@GJXAIOU",[[1,475,"g()"]],[475,475],[478,478]]],[1544581490284,["gjx16@GJXAIOU",[[1,477,"shape"]],[477,477],[482,482]]],[1544581509865,["gjx16@GJXAIOU",[[1,483,"; //错误：抽象类不能作为擦书类型"]],[483,483],[501,501]]],[1544581512156,["gjx16@GJXAIOU",[[-1,497,"擦书"]],[499,499],[497,497]]],[1544581514303,["gjx16@GJXAIOU",[[1,497,"参数"]],[497,497],[499,499]]],[1544581580177,[null,[[-1,372,"\n\n"],[1,374,"nt"],[-1,381,"`"],[1,382,"\n"],[-1,515,"`"],[1,516,"\n"],[1,518,"``"]],[372,372],[520,520]]],[1544581580177,[null,[[1,372,"\n\n"],[-1,372,"nt"],[1,381,"`"],[-1,381,"\n"],[1,515,"`"],[-1,515,"\n"],[-1,518,"``"]],[520,520],[372,372]]],[1544581560315,["gjx16@GJXAIOU",[[1,504,"\n  "]],[501,501],[504,504]]],[1544581567777,["gjx16@GJXAIOU",[[1,504,"sah"]],[504,504],[507,507]]],[1544581568861,["gjx16@GJXAIOU",[[-1,505,"ah"]],[507,507],[505,505]]],[1544581575714,["gjx16@GJXAIOU",[[1,505,"hape &h()"]],[505,505],[514,514]]],[1544581578504,["gjx16@GJXAIOU",[[1,513,"shape"]],[513,513],[518,518]]],[1544581640189,[null,[[-1,372,"\n\n"],[1,374,"nt"],[-1,381,"`"],[1,382,"\n"],[-1,533,"`"],[1,534,"\n"],[1,536,"``"]],[372,372],[538,538]]],[1544581640189,[null,[[1,372,"\n\n"],[-1,372,"nt"],[1,381,"`"],[-1,381,"\n"],[1,533,"`"],[-1,533,"\n"],[-1,536,"``"]],[538,538],[372,372]]],[1544581580741,["gjx16@GJXAIOU",[[1,518," &"]],[518,518],[520,520]]],[1544581597131,["gjx16@GJXAIOU",[[1,521,";  //可以：可以声明抽象类的引用"]],[521,521],[539,539]]],[1544581618576,["gjx16@GJXAIOU",[[1,253,"  、、"]],[253,253],[257,257]]],[1544581619431,["gjx16@GJXAIOU",[[-1,255,"、、"]],[257,257],[255,255]]],[1544581624494,["gjx16@GJXAIOU",[[1,255,"//抽象类"]],[255,255],[260,260]]],[1544581629586,["gjx16@GJXAIOU",[[-1,567,"![image072]($resource/image072.png)"]],[567,602],[567,567]]],[1544581700192,[null,[[-1,379,"\n\n"],[1,381,"nt"],[-1,388,"`"],[1,389,"\n"],[-1,560,"`"],[1,561,"\n"],[1,564,"``\n"],[-1,566,"["]],[379,379],[566,566]]],[1544581700192,[null,[[1,379,"\n\n"],[-1,379,"nt"],[1,388,"`"],[-1,388,"\n"],[1,560,"`"],[-1,560,"\n"],[-1,564,"``\n"],[1,569,"["]],[566,566],[379,379]]],[1544581680797,["gjx16@GJXAIOU",[[-1,618,"![image074]($resource/image074.png)\n![image075]($resource/image075.png)"]],[618,689],[618,618]]],[1544581880226,[null,[[-1,379,"\n\n"],[1,381,"nt"],[-1,388,"`"],[1,389,"\n"],[-1,560,"`"],[1,561,"\n"],[1,564,"``\n"],[-1,566,"["],[-1,616,"!["],[1,618,"\n`"]],[379,379],[620,620]]],[1544581880226,[null,[[1,379,"\n\n"],[-1,379,"nt"],[1,388,"`"],[-1,388,"\n"],[1,560,"`"],[-1,560,"\n"],[-1,564,"``\n"],[1,569,"["],[1,618,"!["],[-1,618,"\n`"]],[620,620],[379,379]]],[1544581865404,["gjx16@GJXAIOU",[[-1,1753," "]],[1754,1754],[1753,1753]]],[1544581868785,["gjx16@GJXAIOU",[[1,1753," "]],[1753,1753],[1754,1754]]],[1544581872850,["gjx16@GJXAIOU",[[-1,1753," "]],[1754,1754],[1753,1753]]]],null,"gjx16@GJXAIOU"],["123ea3dd-be24-4a95-9f38-b4f79fcac178",1544677034734,"# C_PP_章五 纯虚函数和抽象类\n\n\n## 一、基本概念\n\n**纯虚函数：**\n* 纯虚函数声明格式： `virtual 返回值类型   函数名（参数列表）= 0 `\n* 纯虚函数是一个在基类中声明的虚函数，但是在基类中并没有定义（即没有具体的代码实现），但是要求任何的派生类都要实现属于自己的这个函数；\n* 纯虚函数为各派生类提供一个公共界面（接口的封装和设计、软件的模块功能划分）\n\n**抽象类：**\n  一个具有纯虚函数的基类被称为抽象类\n\n**注意点：**\n```cpp\nclass shape  //抽象类\n{\npublic:\n  point where()\n  {\n  return center;\n  }\n  virtual void rotate(int b) = 0;\n  virtual void draw() = 0;\n\n};\n\nint main()\n{\n  shape s;  //错误：抽象类不能建立对象\n  shape *s; //可以：可以声明抽象类的指针\n  shape f();//错误：抽象类不能作为返回类型\n  vois g(shape); //错误：抽象类不能作为参数类型\n  shape &h(shape &);  //可以：可以声明抽象类的引用\n  return 0;\n}\n\n\n```\n\n![image073]($resource/image073.png)\n\n\n\n## 二、抽象类案例\n\n```cpp\n//纯虚函数抽象类语法基础\n\n\n#include \"iostream\"\nusing namespace std;\n\nclass Figure\n{\npublic:\n\tvirtual void Area() = 0;   //声明一个纯虚函数，基类中不需要实现，在下面每一个继承类都需要按照各自需求进行实现\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\nclass circle :public Figure\n{\npublic:\n\tcircle(int r,int a, int b)\n\t{\n\t\tthis->r = r;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"圆的面积 \" << 3.14*r*r << endl;\n\t}\nprivate:\n\tint r;\n};\n\n\nclass rectangle :public Figure\n{\npublic:\n\trectangle(int length, int width, int a, int b)\n\t{\n\t\tthis->length = length;\n\t\tthis->width = width;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"长方形的面积 \" << length * width << endl;\n\t}\nprivate:\n\tint length;\n\tint width;\n};\n\nvoid getArea(Figure *base)\n{\n\tbase->Area();\n}\n\n\n\nint main()\n{\n\t\n\t//Figure f1;//这是错误的，抽象类不能实例化\n\tFigure *p = NULL;   //但是可以使用指针和引用\n\tcircle c1(2, 1, 2);\n\trectangle r1(1, 2, 3, 4);\n\n\tgetArea(&c1);\n\tgetArea(&r1);\n\tsystem(\"pause\");\n\treturn 0;\n} \n```\n\n\n## 三、抽象类在多继承中的应用\n\nC++中没有Java中的接口概念，抽象类可以模拟Java中的接口类。（接口和协议）\n\n\n\n### （一）有关多继承的说明\n\n**工程上的多继承**\n\n* 被实际开发经验抛弃的多继承\n* 工程开发中真正意义上的多继承是几乎不被使用的\n* 多重继承带来的代码复杂性远多于其带来的便利\n* 多重继承对代码维护性上的影响是灾难性的\n* 在设计方法上，任何多继承都可以用单继承代替 \n\n**多继承中的二义性和多继承不能解决的问题**\n![image076]($resource/image076.png)\n\n\n### （二）多继承的应用场景\n\n* 绝大多数面向对象语言都不支持多继承\n* 绝大多数面向对象语言都支持接口的概念\n* C++中没有接口的概念\n* C++中可以使用纯虚函数实现接口\n* 接口类中只有函数原型定义，没有任何数据的定义\n\n\n实际工程经验证明\n* 多重继承接口不会带来二义性和复杂性等问题 \n* 多重继承可以通过精心设计用单继承和接口来代替\n* 接口类只是一个功能说明，而不是功能实现。\n* 子类需要根据功能说明定义功能实现。\n\n抽象类在多继承中的应用的示例程序：\n```cpp\n//抽象类在多继承中的应用\n\n#include \"iostream\"\nusing namespace std;\n\nclass Interface1\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n};\n\nclass Interface2\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n\tvirtual int minus(int a, int b) = 0;\n};\n\nclass parent\n{\npublic:\n\tint a;\n};\n\nclass Child : public parent, public Interface1, public Interface2\n{\npublic:\n\tvoid print()\n\t{\n\t\tcout << \"Child::print\" << endl;\n\t}\n\n\tint add(int a, int b)\n\t{\n\t\treturn a + b;\n\t}\n\n\tint minus(int a, int b)\n\t{\n\t\treturn a - b;\n\t}\n\n};\n\nint main()\n{\n\n\tChild c;\n\tc.print();\n\tcout << c.add(3, 5) << endl;\n\tcout << c.minus(4, 6) << endl;\n\n\tInterface1* i1 = &c;\n\tInterface2* i2 = &c;\n\n\tcout << i1->add(7, 8) << endl;\n\tcout << i2->add(7, 8) << endl;\n\n\tsystem(\"pause\");\n\n}\n```\n\n\n\n\n## 四、抽象类知识点强化\n\n/*\n编写一个C++程序, 计算程序员( programmer )工资 \n 1 要求能计算出初级程序员( junior_programmer ) 中级程序员 ( mid_programmer )高级程序员( adv_programmer)的工资\n 2 要求利用抽象类统一界面,方便程序的扩展, 比如:新增, 计算 架构师 (architect ) 的工资 \n*/\n~~调用的时候参数有点问题~~\n```cpp\n//抽象类知识点的强化\n\n\n#include \"iostream\"\n#include \"sstream\"\nusing namespace std;\n\nclass programmer\n{\npublic:\n\tvirtual void getSal() = 0;\nprotected:\nprivate:\n};\n\nclass junior_programmer :public programmer\n{\npublic:\n\tjunior_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"junior_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\nclass mid_programmer :public programmer\n{\npublic:\n\tmid_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"mid_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n\nclass adv_programmer :public programmer\n{\npublic:\n\tadv_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"adv_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n//接下来为后期可以拓展的部分\n\n\nclass architect :public programmer\n{\npublic:\n\tarchitect(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"architect:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n//以上为后期拓展部分\n\nvoid pro_sale(programmer *base)\n{\n\tbase->getSal();\n}\n\n\nint main()\n{\n\tjunior_programmer jp(\"张三\",\"初级\",2000);\n\tmid_programmer mp(\"小张\", \"中级\", 8000);\n\tadv_programmer ap(\"小李\", \"高级\", 20394);\n\n\tpro_sale(&jp);\n\tpro_sale(&mp);\n\tpro_sale(&ap);\n\n\n\t//后期新增程序的调用\n\n\tarchitect ar(\"架构师\", \"牛\", 121332);\n\tpro_sale(&ar);\n\tsystem(\"pause\");\n\treturn 0; \n\n}\n```\n\n\n\n\n## 五、面向抽象类编程思想强化\n\n理论知识\n\nØ 虚函数和多态性使成员函数根据调用对象的类型产生不同的动作\n\nØ  多态性特别适合于实现分层结构的软件系统，便于对问题抽象时  定义共性，实现时定义区别\n\nØ **面向抽象类编程（面向接口编程）**是项目开发中重要技能之一。\n\n\n### （一）案例：socket库c++模型设计和实现\n\n**企业信息系统框架集成第三方产品**\n\n**案例背景**：一般的企业信息系统都有成熟的框架。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求**：请你在**企业信息系统框架**中集成第三方厂商的Socket通信产品和第三方厂商加密产品。\n\n第三方厂商的Socket通信产品：完成两点之间的通信；\n\n第三方厂商加密产品：完成数据发送时加密；数据解密时解密。\n\n![image077]($resource/image077.png)\n\n**案例要求**： 1）能支持多个厂商的Socket通信产品入围\n\n 2）能支持多个第三方厂商加密产品的入围\n\n 3）企业信息系统框架不轻易发生框架\n\n**需求实现**\n\n  思考1：企业信息系统框架、第三方产品如何分层\n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分成以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n分析有多少个类 CSocketProtocol  CSckFactoryImp1  CSckFactoryImp2\n\nCEncDesProtocol  HwEncdes  ciscoEncdes\n\n1、 定义 CSocketProtocol 抽象类\n\n2、 编写框架函数\n\n3、 编写框架测试函数\n\n4、 厂商1（CSckFactoryImp1）实现CSocketProtocol、厂商2（CSckFactoryImp1）实现CSocketProtocol\n\n5、 抽象加密接口（CEncDesProtocol）、加密厂商1(CHwImp)、加密厂商2(CCiscoImp))，集成实现业务模型\n\n6、 框架（c语言函数方式，框架函数；c++类方式，框架类）\n\n~~des.cpp程序没有，所以第7天的第17-20视频没有看~~\n\n**几个重要的面向对象思想**\n\n继承-组合（强弱）\n\n注入\n\n控制反转 IOC\n\nMVC\n\n  面向对象思想扩展aop思想\n\n aop思想是对继承编程思想的有力的补充\n\n\n### （二）案例：计算员工工资\n\n\n### （三）案例：计算几何体的表面积和体积\n~~第21个视频上有~~\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 六、面向接口编程和C多态\n\n友情提示：今天课程内容，更加贴近实战，并且语法和软件思想都较难，请学员紧跟思路。课后加强复习！\n\n结论：  只要你动手，又很容易！\n\n\n\n### （一）函数类型语法基础\n\n\n函数三要素：  名称、参数、返回值\n\nC语言中的函数有自己特定的类型\n \n\nC语言中通过typedef为函数类型重命名\n\ntypedef type name(parameter list)\n\ntypedef int f(int, int);\n\ntypedef void p(int);\n\n |\n| \n\n函数指针\n\n |\n| \n\n函数指针用于指向一个函数\n\n函数名是函数体的入口地址\n\n1)可通过函数类型定义函数指针: FuncType* pointer;\n\n2)也可以直接定义：type (*pointer)(parameter list);\n\npointer为函数指针变量名\n\ntype为指向函数的返回值类型\n\nparameter list为指向函数的参数类型列表\n\n |\n| \n\n函数指针语法梳理\n\n//函数类型\n\n//函数指针类型\n\n//函数指针变量\n\n数组指针语法梳理 \n\n//数组类型语法\n\n//数组指针类型\n\n//数组指针变量\n\n |\n| \n\ntypedef int(FUNC)(int);\n\nint test(int i)\n\n{\n\n return i * i;\n\n}\n\nvoid f()\n\n{\n\n printf(\"Call f()...\\n\");\n\n}\n\nint main()\n\n{\n\n FUNC* pt = test;\n\n void(*pf)() = &f;\n\n pf();\n\n (*pf)();\n\n printf(\"Function pointer call: %d\\n\", pt(3));\n\n}\n\n |\n\n### （二）函数指针做函数参数\n\n| \n\n1、 指针做函数参数pk函数指针做函数参数\n\n回忆指针做函数参数\n\n一级指针做函数参数、二级。。。。、三级\n\n |\n| \n\n2、 函数指针做函数参数\n\n当函数指针 做为函数的参数，传递给一个被调用函数，\n\n被调用函数就可以通过这个指针调用外部的函数，这就形成了回调\n\n |\n| \n\n3、练习\n\nint add(int a, int b) \n\nint libfun( int (*pDis)(int a, int b) );\n\nint main(void)\n\n{\n\n int (*pfun)(int a, int b);  \n\n pfun = add;\n\n libfun(pfun);\n\n}\n\nint add(int a, int b)\n\n{\n\n return a + b;\n\n}\n\nint libfun( int (*pDis)(int a, int b) )\n\n{\n\n  int a, b;\n\n  a = 1;\n\n  b = 2;\n\nadd(1,3) //直接调用add函数\n\nprintf(\"%d\", pDis(a, b)); //通过函数指针做函数参数,间接调用add函数\n\n//思考 这样写 pDis(a, b)有什么好处?\n\n}\n\n//剖析思路\n\n//1函数的调用 和 函数的实现  有效的分离\n\n//2 C++的多态,可扩展\n\n现在这几个函数是在同一个文件当中\n\n假如\n\nint libfun(int (*pDis)(int a, int b))\n\n是一个库中的函数，就只有使用回调了，通过函数指针参数将外部函数地址传入\n\n来实现调用\n\n函数 add 的代码作了修改，也不必改动库的代码，就可以正常实现调用\n\n便于程序的维护和升级\n\n |\n\n回调函数思想：\n![image078]($resource/image078.png)\n结论：回调函数的本质：提前做了一个协议的约定（把函数的参数、函数返回值提前约定）\n\n请思考：C编译器通过那个具体的语法，实现解耦合的？\n\n C++编译器通过多态的机制(提前布局vptr指针和虚函数表,找虚函数入口地址来实现)\n\n### （三）函数指针正向调用\n\n| \n\n1、 函数指针做函数参数，调用方式\n\n被调用函数和主调函数在同一文件中（用来教学，没有任何意义）\n\n |\n| \n\n2、函数指针做函数参数\n\n被调用函数和主调函数不在同一个文件中、模块中。\n\n难点：理解被调用函数是什么机制被调用起来的。框架\n\n框架提前设置了被调用函数的入口（框架提供了第三方模块入口地址的集成功能）\n\n框架具备调用第三方模块入口函数\n\n |\n| \n\n3、 练习\n\ntypedef int (*EncDataFunc)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\nint MyEncDataFunc(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen)\n\n{\n\n int rv = 0;\n\n char *p = \"222222222222\";\n\n strcpy(outData, p);\n\n *outDataLen = strlen(p);\n\n return rv;\n\n}\n\nint Send_Data(EncDataFunc encDataFunc, unsigned char *inData, int inDataLen, unsigned char *outData, int *outDatalen)\n\n{\n\n int rv = 0;\n\n if (encDataFunc != NULL)\n\n {\n\n rv = encDataFunc(inData, inDataLen, outData, outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"func encDataFunc() err.\\n\");\n\n return rv;\n\n }\n\n }\n\n return rv;\n\n}\n\nint main()\n\n{\n\n int rv = 0;\n\n EncDataFunc encDataFunc = NULL;\n\n encDataFunc = MyEncDataFunc;\n\n // 第一个调用\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"1111\");\n\n inDataLen = strlen(inData);\n\n rv = encDataFunc(inData,inDataLen, outData, &outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"edf err .....\\n\");\n\n }\n\n else\n\n {\n\n printf(\"edf ok \\n\");\n\n printf(\"%s \\n\", outData);\n\n }\n\n }\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"3333\");\n\n inDataLen = strlen(inData);\n\n rv = Send_Data(MyEncDataFunc, inData, inDataLen, outData, &outDatalen);\n\n if (rv != 0)\n\n {\n\n printf(\"func Send_Data err:%d\", rv);\n\n return rv;\n\n }\n\n printf(\"%s \\n\", outData);\n\n }\n\n getchar();\n\n}\n\n |\n\n### （四）函数指针反向调用\n\n回调函数效果展示。\n\n\n### （五）C动态库升级成框架案例\n\n**C****语言版本Socket****动态库升级成框架集成第三方产品**\n\n**简称：C****动态库升级成框架案例**\n\n**名字解释       **\n\n  动态库：抽象类一个套接口，单独封装成模块，供别人调用；无法扩展。\n\n  框架：能自由的扩展 \n\n**案例背景**：一般的企业信息系统都有成熟的框架，可以有C语言写，也可以由C++语言。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求：**在socket通信库中，完成数据加密功能，有n个厂商的加密产品供你选择，如何实现动态库和第三个厂商产品的解耦合。\n\n提醒：C++通过抽象类，也就是面向抽象类编程实现的（相当于C++编译器通过多态机制，已经很好用了。提前布局vptr指针、虚函数表；调用是迟绑定完成。），\n\n**C****语言**中如何实现哪？\n\n**案例要求**： 1）能支持多个第三方厂商加密产品的入围\n\n 2）企业信息系统框架不轻易发生框架\n\n**需求实现思路分析**\n![image079]($resource/image079.png)\n  思考1：企业信息系统框架、第三方产品如何分层 \n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分层确定后，动态库应该做什么？产品入围厂商应该做什么？\n\n以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n1、 动态库中定义协议，并完成任务的调用\n\ntypedef int (*EncData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\ntypedef int (*DecData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\n2、 加密厂商完成协议函数的编写\n\n3、 对接调试。\n\n4、 动态库中可以缓存第三方函数的入口地址，也可以不缓存，两种实现方式。\n\n**案例总结**\n\n  回调函数：利用函数指针做函数参数，实现的一种调用机制，具体任务的实现者，可以不知道什么时候被调用。\n\n  回调机制原理：\n\n  当具体事件发生时，调用者通过函数指针调用具体函数\n\n  回调机制的将调用者和被调函数分开，两者互不依赖\n\n  任务的实现 和 任务的调用 可以耦合  （提前进行接口的封装和设计）\n\n### （六）附录：诸葛亮的锦囊妙计**\n\n刘备利用周瑜、曹仁厮杀之际，乘虚袭取了南郡、荆州、襄阳，以后又征服了长沙等四郡。周瑜想想十分气恨，正无处报复以夺还荆州。不久，刘备忽然丧偶，周瑜计上心来，对孙权说：“您的妹妹，美丽、刚强，我们以联姻抗曹名义向刘备招亲，把他骗来南徐幽禁，逼他们拿荆州来换。”孙权大喜，郎派人到荆州说亲。\n\n刘备认为这是骗局，想要拒绝，诸葛亮笑道：“送个好妻子上门何不答应？您只管去东吴，我叫赵云陪您去，自有安排，包您得了夫人又不失荆州。”\n\n接着，诸葛亮暗暗关照赵云道：“我这里有三个锦囊，内藏三条妙计。到南徐时打开第一个，到年底时打开第二个，危急无路时打开第三个。”\n\n第一个锦囊\n\n  一到东吴就拜会乔国老\n\n第二个锦囊\n\n  刘备被孙权设计留下就对他谎称曹操大军压境\n\n第三个锦囊\n\n被东吴军队追赶就求孙夫人解围\n",[[1544677001207,["gjx16@GJXAIOU",[[-1,6675,"数组指针语法梳理 \n\n//数组类型语法\n\n//数组指针类型\n\n//数组指针变量\n"]],[6675,6715],[6675,6675]]],[1544677012321,["gjx16@GJXAIOU",[[1,6274,"数组指针语法梳理 \n\n//数组类型语法\n\n//数组指针类型\n\n//数组指针变量\n"]],[6274,6274],[6314,6314]]],[1544677021383,["gjx16@GJXAIOU",[[1,6274,"**"],[1,6283,"**"]],[6274,6283],[6274,6287]]],[1544677023553,["gjx16@GJXAIOU",[[-1,6288,"\n"]],[6288,6288],[6287,6287]]],[1544677025977,["gjx16@GJXAIOU",[[-1,6297,"\n"]],[6297,6297],[6296,6296]]],[1544677027473,["gjx16@GJXAIOU",[[-1,6306,"\n"]],[6306,6306],[6305,6305]]],[1544677037878,["gjx16@GJXAIOU",[[-1,6288,"//"]],[6290,6290],[6288,6288]]],[1544677040403,["gjx16@GJXAIOU",[[-1,6295,"//"]],[6297,6297],[6295,6295]]],[1544677042533,["gjx16@GJXAIOU",[[-1,6302,"//"]],[6304,6304],[6302,6302]]],[1544677049410,["gjx16@GJXAIOU",[[1,6288,"* "],[1,6295,"* "],[1,6302,"* "]],[6288,6308],[6290,6314]]],[1544677052910,["gjx16@GJXAIOU",[[1,6315,"··"]],[6315,6315],[6317,6317]]],[1544677054111,["gjx16@GJXAIOU",[[-1,6315,"··"]],[6317,6317],[6315,6315]]],[1544677055595,["gjx16@GJXAIOU",[[1,6315,"```"]],[6315,6315],[6318,6318]]],[1544677055642,["gjx16@GJXAIOU",[[1,6318,"language\n```\n"]],[6318,6318],[6318,6326]]],[1544677057150,["gjx16@GJXAIOU",[[-1,6318,"language"],[1,6326,"c"]],[6318,6326],[6319,6319]]],[1544677057623,["gjx16@GJXAIOU",[[1,6319,"ppp"]],[6319,6319],[6322,6322]]],[1544677057867,["gjx16@GJXAIOU",[[1,6323,"\n"]],[6322,6322],[6323,6323]]],[1544677058880,["gjx16@GJXAIOU",[[-1,6323,"\n"]],[6323,6323],[6322,6322]]],[1544677059028,["gjx16@GJXAIOU",[[-1,6321,"p"]],[6322,6322],[6321,6321]]],[1544677059786,["gjx16@GJXAIOU",[[1,6322,"\n"]],[6321,6321],[6322,6322]]],[1544677077498,["gjx16@GJXAIOU",[[1,6322,"#include<stdio.h>\n\n//数组类型基本语法的知识梳理\n\n//1.定义一个数组类型\n\n\n//2.定义一个指针数组类型\n\n\n\n//3.定义一个指向 数组类型的指针（即 数组类指针）\n\n\nint  main()\n{\n\n\t//默认定义数组方式\n\tint  a[10];   //其中a代表数组首元素的地址，&a代表整个数组的地址， a+1 的步长为4，&a+1的步长为10\n\n\n\t//使用typedef定义数组类型\n\ttypedef int(MyTypeArray)[10];\n\t//定义变量\n\tMyTypeArray myArray;\n\tmyArray[0] = 10;\n\n\n\t//定义一个指针数组类型\n\ttypedef int (*PTypeArray)[10];\n\tPTypeArray *myPArray;\n\tmyPArray = &a;   //指向a数组的首地址\n\t(*myPArray)[0] = 20;  //操作元素\n\ta[0] = 10;\n\n\t//3.定义一个指向 数组类型的指针（即 数组类指针） 相当于直接定义变量而不是先定义类型在定义指针\n\n\tint(*myPString)[10];\n\tmyPString = &a;\n\t(*myPString)[0] = 10;\n\n\n}"]],[6322,6322],[6875,6875]]],[1544677091214,["gjx16@GJXAIOU",[[-1,7239,"| "]],[7241,7241],[7239,7239]]],[1544677092002,["gjx16@GJXAIOU",[[-1,7240,"\n"]],[7239,7239],[7238,7238]]],[1544677092751,["gjx16@GJXAIOU",[[-1,7236," |"]],[7238,7238],[7236,7236]]],[1544677095239,["gjx16@GJXAIOU",[[-1,7277," |\n| \n"]],[7277,7283],[7277,7277]]],[1544677111540,["gjx16@GJXAIOU",[[1,7275,"```"]],[7275,7275],[7278,7278]]],[1544677111590,["gjx16@GJXAIOU",[[1,7278,"language\n```\n"]],[7278,7278],[7278,7286]]],[1544677112445,["gjx16@GJXAIOU",[[-1,7278,"language"],[1,7286,"c"]],[7278,7286],[7279,7279]]],[1544677112770,["gjx16@GJXAIOU",[[1,7279,"pp"]],[7279,7279],[7281,7281]]],[1544677113036,["gjx16@GJXAIOU",[[1,7282,"\n"]],[7281,7281],[7282,7282]]],[1544677114122,["gjx16@GJXAIOU",[[1,7282,"//函数类型\n\n////1.如何定义一个函数类型\n////2.如何定义一个函数指针类型\n////3.如何定义一个函数指针（指向函数的入口）\n//\n//int add(int a, int b)\n//{\n//\tprintf(\"func is add a and b\");\n//\treturn a + b;\n//}\n//\n//void main()\n//{\n//\t//直接调用\n//\tadd(1, 2);\n//\n//\t//定义一个函数类型\n//\ttypedef int (MyFuncType)(int a, int b);//定义了一个类型\n//\tMyFuncType *myPointerFunc = NULL;//定义了一个指针，指向某一种类的函数，这里的某一类是根据定义来判断：\n//\t//这里某一类是指含有两个参数，返回值为int 的类型\n//\n//\tmyPointerFunc = &add;\n//\tmyPointerFunc(3, 4); //间接调用\n//\tmyPointerFunc = add;  //这里是否取地址都可以\n//\tmyPointerFunc(3, 4); //间接调用\n//\n//\n//\t//定义一个函数指针类型\n//\ttypedef int(*MyPointerFuncType)(int a, int b);   //相当于定义：int *a = NULL;\n//\n//\tMyPointerFuncType MyPointer;//定义一个指针\n//\tMyPointer = add;\n//\tMyPointer(5, 6);\n//\n//\n//\t//直接定义一个函数指针(相当于直接定义了一个变量)\n//\tint(*MyPointerFunc)(int a, int b);//定义了一个变量\n//\tMyPointerFunc = add;\n//\tMyPointerFunc(7, 8);\n//\n//\n//}"]],[7282,7282],[8103,8103]]],[1544677370584,["gjx16@GJXAIOU",[[1,6276,"qizan"]],[6276,6276],[6281,6281]]],[1544677372689,["gjx16@GJXAIOU",[[-1,6276,"qizan"]],[6281,6281],[6276,6276]]],[1544677375493,["gjx16@GJXAIOU",[[1,6276,"前言："]],[6276,6276],[6279,6279]]],[1544677390891,["gjx16@GJXAIOU",[[-1,6922,"\n"]],[6922,6922],[6921,6921]]],[1544677394325,["gjx16@GJXAIOU",[[1,6903,"****"]],[6903,6903],[6905,6905]]],[1544677400753,["gjx16@GJXAIOU",[[1,6905,"基础概念："]],[6905,6905],[6910,6910]]],[1544677404807,["gjx16@GJXAIOU",[[1,6913,"- "]],[6913,6913],[6915,6915]]],[1544677408227,["gjx16@GJXAIOU",[[1,6933,"- "]],[6933,6933],[6935,6935]]],[1544677409698,["gjx16@GJXAIOU",[[-1,6953,"\n"]],[6953,6953],[6952,6952]]],[1544677409844,["gjx16@GJXAIOU",[[-1,6951," "]],[6952,6952],[6951,6951]]],[1544677420347,["gjx16@GJXAIOU",[[1,6952,"-                              "]],[6952,6952],[6983,6983]]],[1544677428847,["gjx16@GJXAIOU",[[-1,6954,"                             "]],[6983,6983],[6954,6954]]],[1544677432563,["gjx16@GJXAIOU",[[-1,7037,"\n"]],[7037,7037],[7036,7036]]],[1544677433811,["gjx16@GJXAIOU",[[-1,7011,"\n"]],[7011,7011],[7010,7010]]],[1544677437048,["gjx16@GJXAIOU",[[1,6977,"  "],[1,7011,"  "],[1,7036,"  "]],[6977,7056],[6977,7062]]],[1544677439968,["gjx16@GJXAIOU",[[1,6979,"* "],[1,7015,"* "],[1,7041," *"]],[6977,7062],[6979,7068]]],[1544677443287,["gjx16@GJXAIOU",[[-1,6976,"\n"]],[6976,6976],[6975,6975]]],[1544677445487,["gjx16@GJXAIOU",[[-1,6951,"\n"]],[6951,6951],[6950,6950]]],[1544677524296,["gjx16@GJXAIOU",[[-1,7068," |\n| \n"]],[7068,7074],[7068,7068]]],[1544677526843,["gjx16@GJXAIOU",[[1,7069,"**"],[1,7073,"**"]],[7069,7073],[7069,7077]]],[1544677528448,["gjx16@GJXAIOU",[[-1,7068,"\n"]],[7068,7068],[7067,7067]]],[1544677531100,["gjx16@GJXAIOU",[[-1,7081,"| "]],[7083,7083],[7081,7081]]],[1544677531561,["gjx16@GJXAIOU",[[-1,7082,"\n"]],[7081,7081],[7080,7080]]],[1544677532426,["gjx16@GJXAIOU",[[-1,7078," |"]],[7080,7080],[7078,7078]]],[1544677532761,["gjx16@GJXAIOU",[[-1,7079,"\n"]],[7078,7078],[7077,7077]]],[1544677533106,["gjx16@GJXAIOU",[[-1,7078,"\n"]],[7077,7077],[7076,7076]]],[1544677549423,["gjx16@GJXAIOU",[[-1,7203,"\n"]],[7203,7203],[7202,7202]]],[1544677550747,["gjx16@GJXAIOU",[[-1,7186,"\n"]],[7186,7186],[7185,7185]]],[1544677552905,["gjx16@GJXAIOU",[[-1,7218,"\n"]],[7218,7218],[7217,7217]]],[1544677555255,["gjx16@GJXAIOU",[[-1,7142,"\n"]],[7142,7142],[7141,7141]]],[1544677557125,["gjx16@GJXAIOU",[[1,7185,"\n"]],[7184,7184],[7185,7185]]],[1544677565264,["gjx16@GJXAIOU",[[1,7078,"* "],[1,7091,"* "],[1,7092,"* "]],[7078,7104],[7080,7110]]],[1544677568671,["gjx16@GJXAIOU",[[-1,7093,"* "]],[7095,7095],[7093,7093]]],[1544677572647,["gjx16@GJXAIOU",[[1,7110,"  "],[1,7146,"  "]],[7110,7188],[7110,7192]]],[1544677574003,["gjx16@GJXAIOU",[[1,7112,"* "],[1,7149," *"]],[7110,7192],[7112,7196]]],[1544677577938,["gjx16@GJXAIOU",[[1,7198,"  "],[1,7214,"  "],[1,7230,"  "]],[7198,7257],[7198,7263]]],[1544677578579,["gjx16@GJXAIOU",[[1,7200,"  "],[1,7216," "],[1,7218," "],[1,7234,"  "]],[7198,7263],[7198,7269]]],[1544677581599,["gjx16@GJXAIOU",[[1,7202,"* "],[1,7222,"* "],[1,7241," *"]],[7198,7269],[7200,7275]]],[1544677595267,["gjx16@GJXAIOU",[[1,7278,"**"],[1,7286,"**"]],[7278,7286],[7278,7290]]],[1544677597251,["gjx16@GJXAIOU",[[-1,7291,"\n"]],[7291,7291],[7290,7290]]],[1544677599096,["gjx16@GJXAIOU",[[-1,7298,"\n"]],[7298,7298],[7297,7297]]],[1544677601304,["gjx16@GJXAIOU",[[-1,7307,"\n"]],[7307,7307],[7306,7306]]],[1544677605285,["gjx16@GJXAIOU",[[-1,7291,"//"]],[7293,7293],[7291,7291]]],[1544677605789,["gjx16@GJXAIOU",[[1,7291,"- "]],[7291,7291],[7293,7293]]],[1544677608163,["gjx16@GJXAIOU",[[-1,7298,"//"]],[7300,7300],[7298,7298]]],[1544677609590,["gjx16@GJXAIOU",[[1,7298," - "]],[7298,7298],[7301,7301]]],[1544677611531,["gjx16@GJXAIOU",[[-1,7298," "]],[7299,7299],[7298,7298]]],[1544677614291,["gjx16@GJXAIOU",[[-1,7307,"//"]],[7309,7309],[7307,7307]]],[1544677615487,["gjx16@GJXAIOU",[[1,7307,"- "]],[7307,7307],[7309,7309]]],[1544677617922,["gjx16@GJXAIOU",[[1,7316,"- \n"]],[7315,7315],[7318,7318]]],[1544677619544,["gjx16@GJXAIOU",[[-1,7316,"- "]],[7318,7318],[7316,7316]]],[1544677632709,["gjx16@GJXAIOU",[[1,7316,"以上三个的实现程序如下："]],[7316,7316],[7328,7328]]],[1544678054408,["gjx16@GJXAIOU",[[1,7344,"Yu Writer"]],[7344,8157],[7353,7353]]],[1544678063696,["gjx16@GJXAIOU",[[-1,7336,"//函数类型\n\nYu Writer////1.如何定义一个函数类型\n////2.如何定义一个函数指针类型\n////3.如何定义一个函数指针（指向函数的入口）\n//\n//int add(int a, int b)\n//{\n//\tprintf(\"func is add a and b\");\n//\treturn a + b;\n//}\n//\n//void main()\n//{\n//\t//直接调用\n//\tadd(1, 2);\n//\n//\t//定义一个函数类型\n//\ttypedef int (MyFuncType)(int a, int b);//定义了一个类型\n//\tMyFuncType *myPointerFunc = NULL;//定义了一个指针，指向某一种类的函数，这里的某一类是根据定义来判断：\n//\t//这里某一类是指含有两个参数，返回值为int 的类型\n//\n//\tmyPointerFunc = &add;\n//\tmyPointerFunc(3, 4); //间接调用\n//\tmyPointerFunc = add;  //这里是否取地址都可以\n//\tmyPointerFunc(3, 4); //间接调用\n//\n//\n//\t//定义一个函数指针类型\n//\ttypedef int(*MyPointerFuncType)(int a, int b);   //相当于定义：int *a = NULL;\n//\n//\tMyPointerFuncType MyPointer;//定义一个指针\n//\tMyPointer = add;\n//\tMyPointer(5, 6);\n//\n//\n//\t//直接定义一个函数指针(相当于直接定义了一个变量)\n//\tint(*MyPointerFunc)(int a, int b);//定义了一个变量\n//\tMyPointerFunc = add;\n//\tMyPointerFunc(7, 8);\n//\n//\n//}"]],[7336,8166],[7336,7336]]],[1544678108371,["gjx16@GJXAIOU",[[1,7336,"//函数类型\n\n//1.如何定义一个函数类型\n//2.如何定义一个函数指针类型\n//3.如何定义一个函数指针（指向函数的入口）\n\nint add(int a, int b)\n{\n\tprintf(\"func is add a and b\");\n\treturn a + b;\n}\n\nvoid main()\n{\n\t//直接调用\n\tadd(1, 2);\n\n\t//定义一个函数类型\n\ttypedef int (MyFuncType)(int a, int b);//定义了一个类型\n\tMyFuncType *myPointerFunc = NULL;//定义了一个指针，指向某一种类的函数，这里的某一类是根据定义来判断：\n\t//这里某一类是指含有两个参数，返回值为int 的类型\n\n\tmyPointerFunc = &add;\n\tmyPointerFunc(3, 4); //间接调用\n\tmyPointerFunc = add;  //这里是否取地址都可以\n\tmyPointerFunc(3, 4); //间接调用\n\n\n\t//定义一个函数指针类型\n\ttypedef int(*MyPointerFuncType)(int a, int b);   //相当于定义：int *a = NULL;\n\n\tMyPointerFuncType MyPointer;//定义一个指针\n\tMyPointer = add;\n\tMyPointer(5, 6);\n\n\n\t//直接定义一个函数指针(相当于直接定义了一个变量)\n\tint(*MyPointerFunc)(int a, int b);//定义了一个变量\n\tMyPointerFunc = add;\n\tMyPointerFunc(7, 8);\n\n\n}"]],[7336,7336],[8075,8075]]],[1544678228875,["gjx16@GJXAIOU",[[-1,8083,"typedef int(FUNC)(int);\n\nint test(int i)\n\n{\n\n return i * i;\n\n}\n\nvoid f()\n\n{\n\n printf(\"Call f()...\\n\");\n\n}\n\nint main()\n\n{\n\n FUNC* pt = test;\n\n void(*pf)() = &f;\n\n pf();\n\n (*pf)();\n\n printf(\"Function pointer call: %d\\n\", pt(3));\n\n}\n\n |\n\n"]],[8082,8317],[8082,8082]]],[1544678229544,["gjx16@GJXAIOU",[[-1,8082,"\n"]],[8082,8082],[8081,8081]]],[1544678233019,["gjx16@GJXAIOU",[[-1,8103,"\n"]],[8103,8103],[8102,8102]]],[1544678233954,["gjx16@GJXAIOU",[[-1,8100,"| "]],[8102,8102],[8100,8100]]],[1544678234568,["gjx16@GJXAIOU",[[-1,8100,"\n"]],[8100,8100],[8099,8099]]],[1544678551800,["gjx16@GJXAIOU",[[-1,8100,"1、 指针做函数参数pk函数指针做函数参数\n\n回忆指针做函数参数\n\n一级指针做函数参数、二级。。。。、三级\n\n |\n| \n"]],[8100,8161],[8100,8100]]],[1544678575169,["gjx16@GJXAIOU",[[-1,8101,"2、 "]],[8104,8104],[8101,8101]]],[1544678575608,["gjx16@GJXAIOU",[[-1,8100,"\n"]],[8101,8101],[8100,8100]]],[1544678582553,["gjx16@GJXAIOU",[[1,8100,"**"],[1,8109,"**概念"]],[8100,8109],[8113,8113]]],[1544678709726,[null,[[1,8111,"概念"],[-1,8113,"概念"]],[8111,8111],[8113,8113]]],[1544678709726,[null,[[-1,8111,"概念"],[1,8115,"概念"]],[8113,8113],[8111,8111]]],[1544678667295,["gjx16@GJXAIOU",[[-1,8182,"3、"]],[8184,8184],[8182,8182]]],[1544678667483,["gjx16@GJXAIOU",[[-1,8181,"\n"]],[8182,8182],[8181,8181]]],[1544678667763,["gjx16@GJXAIOU",[[-1,8180,"\n"]],[8181,8181],[8180,8180]]],[1544678668688,["gjx16@GJXAIOU",[[-1,8178,"| "]],[8180,8180],[8178,8178]]],[1544678668857,["gjx16@GJXAIOU",[[-1,8177,"\n"]],[8178,8178],[8177,8177]]],[1544678669751,["gjx16@GJXAIOU",[[-1,8175," |"]],[8177,8177],[8175,8175]]],[1544678673854,["gjx16@GJXAIOU",[[1,8178,"·"]],[8178,8178],[8179,8179]]],[1544678674784,["gjx16@GJXAIOU",[[-1,8178,"·"]],[8179,8179],[8178,8178]]],[1544678675877,["gjx16@GJXAIOU",[[1,8178,"```"]],[8178,8178],[8181,8181]]],[1544678675929,["gjx16@GJXAIOU",[[1,8181,"language\n```\n"]],[8181,8181],[8181,8189]]],[1544678677048,["gjx16@GJXAIOU",[[-1,8181,"language"],[1,8189,"c"]],[8181,8189],[8182,8182]]],[1544678677365,["gjx16@GJXAIOU",[[1,8182,"pp"]],[8182,8182],[8184,8184]]],[1544678678357,["gjx16@GJXAIOU",[[1,8185,"\n"]],[8184,8184],[8185,8185]]],[1544678686568,["gjx16@GJXAIOU",[[-1,8191,"int add(int a, int b) \n\nint libfun( int (*pDis)(int a, int b) );\n\nint main(void)\n\n{\n\n int (*pfun)(int a, int b);  \n\n pfun = add;\n\n libfun(pfun);\n\n}\n\nint add(int a, int b)\n\n{\n\n return a + b;\n\n}\n\nint libfun( int (*pDis)(int a, int b) )\n\n{\n\n  int a, b;\n\n  a = 1;\n\n  b = 2;\n\nadd(1,3) //直接调用add函数\n\nprintf(\"%d\", pDis(a, b)); //通过函数指针做函数参数,间接调用add函数\n\n//思考 这样写 pDis(a, b)有什么好处?\n\n}"]],[8191,8563],[8191,8191]]],[1544678689936,["gjx16@GJXAIOU",[[1,8185,"int add(int a, int b) \n\nint libfun( int (*pDis)(int a, int b) );\n\nint main(void)\n\n{\n\n int (*pfun)(int a, int b);  \n\n pfun = add;\n\n libfun(pfun);\n\n}\n\nint add(int a, int b)\n\n{\n\n return a + b;\n\n}\n\nint libfun( int (*pDis)(int a, int b) )\n\n{\n\n  int a, b;\n\n  a = 1;\n\n  b = 2;\n\nadd(1,3) //直接调用add函数\n\nprintf(\"%d\", pDis(a, b)); //通过函数指针做函数参数,间接调用add函数\n\n//思考 这样写 pDis(a, b)有什么好处?\n\n}"]],[8185,8185],[8557,8557]]],[1544678769737,[null,[[1,8111,"概念"],[-1,8113,"概念"]],[8111,8111],[8113,8113]]],[1544678769737,[null,[[-1,8111,"概念"],[1,8115,"概念"]],[8113,8113],[8111,8111]]],[1544678720106,["gjx16@GJXAIOU",[[-1,8208,"\n"]],[8208,8208],[8207,8207]]],[1544678722048,["gjx16@GJXAIOU",[[-1,8265,"\n"]],[8265,8265],[8264,8264]]],[1544678723090,["gjx16@GJXAIOU",[[-1,8298,"\n"]],[8298,8298],[8297,8297]]],[1544678723874,["gjx16@GJXAIOU",[[-1,8311,"\n"]],[8311,8311],[8310,8310]]],[1544678725576,["gjx16@GJXAIOU",[[-1,8326,"\n"]],[8326,8326],[8325,8325]]],[1544678726188,["gjx16@GJXAIOU",[[-1,8267,"\n"]],[8267,8267],[8266,8266]]],[1544678727138,["gjx16@GJXAIOU",[[-1,8350,"\n"]],[8350,8350],[8349,8349]]],[1544678728720,["gjx16@GJXAIOU",[[-1,8352,"\n"]],[8352,8352],[8351,8351]]],[1544678729500,["gjx16@GJXAIOU",[[-1,8367,"\n"]],[8367,8367],[8366,8366]]],[1544678730562,["gjx16@GJXAIOU",[[-1,8410,"\n"]],[8410,8410],[8409,8409]]],[1544678732154,["gjx16@GJXAIOU",[[-1,8425,"\n"]],[8425,8425],[8424,8424]]],[1544678733482,["gjx16@GJXAIOU",[[-1,8434,"\n"]],[8434,8434],[8433,8433]]],[1544678734703,["gjx16@GJXAIOU",[[-1,8443,"\n"]],[8443,8443],[8442,8442]]],[1544678735955,["gjx16@GJXAIOU",[[-1,8412,"\n"]],[8412,8412],[8411,8411]]],[1544678983570,[null,[[1,8111,"概念"],[-1,8113,"概念"]],[8111,8111],[8113,8113]]],[1544678983570,[null,[[-1,8111,"概念"],[1,8115,"概念"]],[8113,8113],[8111,8111]]],[1544678957801,["gjx16@GJXAIOU",[[-1,8753," |"]],[8755,8755],[8753,8753]]],[1544678974922,["gjx16@GJXAIOU",[[-1,8551,"//"]],[8553,8553],[8551,8551]]],[1544678978002,["gjx16@GJXAIOU",[[-1,8550,"\n"]],[8550,8550],[8549,8549]]],[1544678981315,["gjx16@GJXAIOU",[[1,8550,"**"],[1,8554,"**"]],[8550,8554],[8550,8558]]],[1544679043570,[null,[[1,8111,"概念"],[-1,8113,"概念"]],[8111,8111],[8113,8113]]],[1544679043570,[null,[[-1,8111,"概念"],[1,8115,"概念"]],[8113,8113],[8111,8111]]],[1544679009771,["gjx16@GJXAIOU",[[-1,8698,"\n"]],[8699,8699],[8698,8698]]],[1544679010608,["gjx16@GJXAIOU",[[-1,8697,"\n"]],[8698,8698],[8697,8697]]],[1544679020762,["gjx16@GJXAIOU",[[-1,8661,"\n"]],[8662,8662],[8661,8661]]],[1544679021343,["gjx16@GJXAIOU",[[-1,8660,"\n"]],[8661,8661],[8660,8660]]],[1544679024529,["gjx16@GJXAIOU",[[-1,8622,"\n"]],[8623,8623],[8622,8622]]],[1544679025111,["gjx16@GJXAIOU",[[-1,8621,"\n"]],[8622,8622],[8621,8621]]],[1544679029319,["gjx16@GJXAIOU",[[-1,8618,"\n"]],[8618,8618],[8617,8617]]],[1544679032031,["gjx16@GJXAIOU",[[-1,8617,"\n"]],[8618,8618],[8617,8617]]],[1544679033391,["gjx16@GJXAIOU",[[1,8617,"dan"]],[8617,8617],[8620,8620]]],[1544679034922,["gjx16@GJXAIOU",[[-1,8617,"dan"]],[8620,8620],[8617,8617]]],[1544679037958,["gjx16@GJXAIOU",[[1,8617,"，但是"]],[8617,8617],[8620,8620]]],[1544679041583,["gjx16@GJXAIOU",[[-1,8700,"\n"]],[8701,8701],[8700,8700]]],[1544679042111,["gjx16@GJXAIOU",[[-1,8699,"\n"]],[8700,8700],[8699,8699]]],[1544679043272,["gjx16@GJXAIOU",[[1,8699,"，"]],[8699,8699],[8700,8700]]],[1544679103570,[null,[[1,8111,"概念"],[-1,8113,"概念"]],[8111,8111],[8113,8113]]],[1544679103570,[null,[[-1,8111,"概念"],[1,8115,"概念"]],[8113,8113],[8111,8111]]],[1544679046247,["gjx16@GJXAIOU",[[1,8700,"即使"]],[8700,8700],[8702,8702]]],[1544679049861,["gjx16@GJXAIOU",[[-1,8737,"\n"]],[8738,8738],[8737,8737]]],[1544679050299,["gjx16@GJXAIOU",[[-1,8736,"\n"]],[8737,8737],[8736,8736]]],[1544679053331,["gjx16@GJXAIOU",[[1,8736,"这样"]],[8736,8736],[8738,8738]]],[1544679056710,["gjx16@GJXAIOU",[[1,8736,"，"]],[8736,8736],[8737,8737]]],[1544679061079,["gjx16@GJXAIOU",[[-1,8584,"\n"]],[8584,8584],[8583,8583]]],[1544679070703,["gjx16@GJXAIOU",[[-1,8751,"\n"]],[8751,8751],[8750,8750]]],[1544679071224,["gjx16@GJXAIOU",[[-1,8750,"\n"]],[8750,8750],[8749,8749]]],[1544679077453,["gjx16@GJXAIOU",[[1,8908,"\n"]],[8907,8907],[8908,8908]]],[1544679077630,["gjx16@GJXAIOU",[[1,8909,"\n"]],[8908,8908],[8909,8909]]],[1544679077776,["gjx16@GJXAIOU",[[1,8910,"\n"]],[8909,8909],[8910,8910]]],[1544679080266,["gjx16@GJXAIOU",[[-1,8928,"| "]],[8930,8930],[8928,8928]]],[1544679080735,["gjx16@GJXAIOU",[[-1,8929,"\n"]],[8928,8928],[8927,8927]]],[1544679081729,["gjx16@GJXAIOU",[[-1,8928,"\n"]],[8927,8927],[8926,8926]]],[1544679084680,["gjx16@GJXAIOU",[[-1,8981,"| "]],[8983,8983],[8981,8981]]],[1544679085043,["gjx16@GJXAIOU",[[-1,8982,"\n"]],[8981,8981],[8980,8980]]],[1544679085848,["gjx16@GJXAIOU",[[-1,8978," |"]],[8980,8980],[8978,8978]]],[1544679086456,["gjx16@GJXAIOU",[[-1,8979,"\n"]],[8978,8978],[8977,8977]]],[1544680483740,[null,[[1,8111,"概念"],[-1,8113,"概念"]],[8111,8111],[8113,8113]]],[1544680483740,[null,[[-1,8111,"概念"],[1,8115,"概念"]],[8113,8113],[8111,8111]]],[1544680478085,["gjx16@GJXAIOU",[[1,8909,"****"]],[8909,8909],[8911,8911]]],[1544680543742,[null,[[1,8111,"概念"],[-1,8113,"概念"]],[8111,8111],[8113,8113]]],[1544680543742,[null,[[-1,8111,"概念"],[1,8115,"概念"]],[8113,8113],[8111,8111]]],[1544680483926,["gjx16@GJXAIOU",[[1,8911,"哈舒"]],[8911,8911],[8913,8913]]],[1544680484630,["gjx16@GJXAIOU",[[-1,8911,"哈舒"]],[8913,8913],[8911,8911]]],[1544680505495,["gjx16@GJXAIOU",[[1,8911,"函数指针做函数参数思想剖析："]],[8911,8911],[8925,8925]]],[1544680507375,["gjx16@GJXAIOU",[[1,8929,"\n"]],[8927,8927],[8928,8928]]],[1544680509854,["gjx16@GJXAIOU",[[1,8928,"```"]],[8928,8928],[8931,8931]]],[1544680509904,["gjx16@GJXAIOU",[[1,8931,"language\n```\n"]],[8931,8931],[8931,8939]]],[1544680510852,["gjx16@GJXAIOU",[[-1,8931,"language"],[1,8939,"c"]],[8931,8939],[8932,8932]]],[1544680511668,["gjx16@GJXAIOU",[[1,8932,"pp"]],[8932,8932],[8934,8934]]],[1544680511957,["gjx16@GJXAIOU",[[1,8935,"\n"]],[8934,8934],[8935,8935]]],[1544683543792,[null,[[1,8111,"概念"],[-1,8113,"概念"]],[8111,8111],[8113,8113]]],[1544683543792,[null,[[-1,8111,"概念"],[1,8115,"概念"]],[8113,8113],[8111,8111]]],[1544683519773,["gjx16@GJXAIOU",[[1,8794,"**"],[1,8834,"**"]],[8794,8834],[8794,8838]]],[1544683666039,[null,[[1,8111,"概念"],[-1,8113,"概念"]],[8111,8111],[8113,8113]]],[1544683666039,[null,[[-1,8111,"概念"],[1,8115,"概念"]],[8113,8113],[8111,8111]]],[1544683654171,["gjx16@GJXAIOU",[[1,8946,"\n"]],[8944,8944],[8945,8945]]],[1544683654312,["gjx16@GJXAIOU",[[1,8947,"\n"]],[8945,8945],[8946,8946]]],[1544683665764,["gjx16@GJXAIOU",[[1,8945,"                 "]],[8945,8945],[8962,8962]]],[1544683786022,[null,[[1,8111,"概念"],[-1,8113,"概念"]],[8111,8111],[8113,8113]]],[1544683786022,[null,[[-1,8111,"概念"],[1,8115,"概念"]],[8113,8113],[8111,8111]]],[1544683757960,["gjx16@GJXAIOU",[[-1,9158,"\n"]],[9158,9158],[9157,9157]]],[1544683758704,["gjx16@GJXAIOU",[[-1,9155,"| "]],[9157,9157],[9155,9155]]],[1544683759058,["gjx16@GJXAIOU",[[-1,9155,"\n"]],[9155,9155],[9154,9154]]],[1544683759976,["gjx16@GJXAIOU",[[-1,9152," |"]],[9154,9154],[9152,9152]]],[1544683760608,["gjx16@GJXAIOU",[[-1,9152,"\n"]],[9152,9152],[9151,9151]]],[1544683766375,["gjx16@GJXAIOU",[[1,9158,"```"]],[9158,9158],[9161,9161]]],[1544683766420,["gjx16@GJXAIOU",[[1,9161,"language\n```\n"]],[9161,9161],[9161,9169]]],[1544683767596,["gjx16@GJXAIOU",[[-1,9161,"language"],[1,9169,"c"]],[9161,9169],[9162,9162]]],[1544683767888,["gjx16@GJXAIOU",[[1,9162,"oo"]],[9162,9162],[9164,9164]]],[1544683769114,["gjx16@GJXAIOU",[[-1,9162,"oo"]],[9164,9164],[9162,9162]]],[1544683770102,["gjx16@GJXAIOU",[[1,9162,"pp"]],[9162,9162],[9164,9164]]],[1544683775236,["gjx16@GJXAIOU",[[1,9165,"\n"]],[9164,9164],[9165,9165]]],[1544685046040,[null,[[1,8111,"概念"],[-1,8113,"概念"]],[8111,8111],[8113,8113]]],[1544685046040,[null,[[-1,8111,"概念"],[1,8115,"概念"]],[8113,8113],[8111,8111]]],[1544685037161,["gjx16@GJXAIOU",[[-1,11176,"9"],[1,11177,"7"]],[11166,11166],[11182,11182]]],[1544685106035,[null,[[1,8111,"概念"],[-1,8113,"概念"]],[8111,8111],[8113,8113]]],[1544685106035,[null,[[-1,8111,"概念"],[1,8115,"概念"]],[8113,8113],[8111,8111]]],[1544685050318,["gjx16@GJXAIOU",[[-1,11176,"7"],[1,11177,"9"]],[11166,11166],[11182,11182]]],[1544685946062,[null,[[1,8111,"概念"],[-1,8113,"概念"]],[8111,8111],[8113,8113]]],[1544685946062,[null,[[-1,8111,"概念"],[1,8115,"概念"]],[8113,8113],[8111,8111]]],[1544685901382,["gjx16@GJXAIOU",[[1,11174,"8"],[-1,11175,"79"]],[11170,11170],[11181,11181]]],[1544686126060,[null,[[1,8111,"概念"],[-1,8113,"概念"]],[8111,8111],[8113,8113]]],[1544686126060,[null,[[-1,8111,"概念"],[1,8115,"概念"]],[8113,8113],[8111,8111]]],[1544686082887,["gjx16@GJXAIOU",[[1,11181," "]],[11181,11181],[11182,11182]]],[1544687386085,[null,[[1,8111,"概念"],[-1,8113,"概念"]],[8111,8111],[8113,8113]]],[1544687386085,[null,[[-1,8111,"概念"],[1,8115,"概念"]],[8113,8113],[8111,8111]]],[1544687329209,["gjx16@GJXAIOU",[[1,12087,"s"]],[12087,12087],[12088,12088]]],[1544687329687,["gjx16@GJXAIOU",[[-1,12087,"s"]],[12088,12088],[12087,12087]]],[1544687330868,["gjx16@GJXAIOU",[[1,12087,"dui"]],[12087,12087],[12090,12090]]],[1544687331737,["gjx16@GJXAIOU",[[-1,12087,"dui"]],[12090,12090],[12087,12087]]],[1544687336478,["gjx16@GJXAIOU",[[1,12087,"对刘备，"]],[12087,12087],[12091,12091]]],[1544687344138,["gjx16@GJXAIOU",[[-1,12081,"接着，"]],[12084,12084],[12081,12081]]],[1544687344336,["gjx16@GJXAIOU",[[-1,12080,"\n"]],[12081,12081],[12080,12080]]],[1544687344552,["gjx16@GJXAIOU",[[-1,12079,"\n"]],[12080,12080],[12079,12079]]],[1544687359429,["gjx16@GJXAIOU",[[-1,12013,"刘备认为这是骗局，想要拒绝，葛亮笑道：“送个好妻子上门何不答应？您只管去东吴，我叫赵云陪您去，自有安排，包您得了夫人又不失荆州。”诸"]],[12079,12079],[12013,12013]]],[1544687359543,["gjx16@GJXAIOU",[[-1,12012,"\n"]],[12013,12013],[12012,12012]]],[1544687359669,["gjx16@GJXAIOU",[[-1,12011,"\n"]],[12012,12012],[12011,12011]]],[1544687368265,["gjx16@GJXAIOU",[[-1,11869,"刘备利用周瑜、曹仁厮杀之际，乘虚袭取了南郡、荆州、襄阳，以后又征服了长沙等四郡。周瑜想想十分气恨，正无处报复以夺还荆州。不久，刘备忽然丧偶，周瑜计上心来，对孙权说：“您的妹妹，美丽、刚强，我们以联姻抗曹名义向刘备招亲，把他骗来南徐幽禁，逼他们拿荆州来换。”孙权大喜，郎派人到荆州说亲。"]],[12011,12011],[11869,11869]]],[1544687446084,[null,[[1,8111,"概念"],[-1,8113,"概念"]],[8111,8111],[8113,8113]]],[1544687446084,[null,[[-1,8111,"概念"],[1,8115,"概念"]],[8113,8113],[8111,8111]]],[1544687387262,["gjx16@GJXAIOU",[[1,6206,"（）"]],[6206,6206],[6208,6208]]],[1544687392690,["gjx16@GJXAIOU",[[1,6207,"在C语言中是西南"]],[6207,6207],[6215,6215]]],[1544687394848,["gjx16@GJXAIOU",[[-1,6212,"是西南"]],[6215,6215],[6212,6212]]],[1544687396086,["gjx16@GJXAIOU",[[1,6212,"是西南"]],[6212,6212],[6215,6215]]],[1544687397497,["gjx16@GJXAIOU",[[-1,6213,"西南"]],[6215,6215],[6213,6213]]],[1544687403239,["gjx16@GJXAIOU",[[1,6213,"实现与C++duotai"]],[6213,6213],[6225,6225]]],[1544687405639,["gjx16@GJXAIOU",[[-1,6219,"duotai"]],[6225,6225],[6219,6219]]],[1544687412134,["gjx16@GJXAIOU",[[1,6219,"多态相同的功能"]],[6219,6219],[6226,6226]]],[1544687417377,["gjx16@GJXAIOU",[[-1,6190,"\n"]],[6188,6188],[6187,6187]]],[1544687417494,["gjx16@GJXAIOU",[[-1,6189,"\n"]],[6187,6187],[6186,6186]]],[1544687417638,["gjx16@GJXAIOU",[[-1,6188,"\n"]],[6186,6186],[6185,6185]]],[1544687417778,["gjx16@GJXAIOU",[[-1,6187,"\n"]],[6185,6185],[6184,6184]]],[1544687417958,["gjx16@GJXAIOU",[[-1,6186,"\n"]],[6184,6184],[6183,6183]]],[1544687419320,["gjx16@GJXAIOU",[[-1,6185,"\n"]],[6183,6183],[6182,6182]]],[1544687419428,["gjx16@GJXAIOU",[[-1,6184,"\n"]],[6182,6182],[6181,6181]]],[1544687419538,["gjx16@GJXAIOU",[[-1,6183,"\n"]],[6181,6181],[6180,6180]]],[1544687439266,["gjx16@GJXAIOU",[[-1,6270,"结论：  只要你动手，又很容易！"]],[6270,6286],[6270,6270]]],[1544687439880,["gjx16@GJXAIOU",[[-1,6270,"\n"]],[6270,6270],[6269,6269]]],[1544687440362,["gjx16@GJXAIOU",[[-1,6269,"\n"]],[6269,6269],[6268,6268]]],[1544687444640,["gjx16@GJXAIOU",[[-1,6221,"友情提示：今天课程内容，更加贴近实战，并且语法和软件思想都较难，请学员紧跟思路。课后加强复习！"]],[6221,6268],[6221,6221]]],[1544687506084,[null,[[1,8059,"概念"],[-1,8061,"概念"]],[8059,8059],[8061,8061]]],[1544687506084,[null,[[-1,8059,"概念"],[1,8063,"概念"]],[8061,8061],[8059,8059]]],[1544687457929,["gjx16@GJXAIOU",[[1,6219,"-贴近实战、胶囊"]],[6219,6219],[6227,6227]]],[1544687458687,["gjx16@GJXAIOU",[[-1,6225,"胶囊"]],[6227,6227],[6225,6225]]],[1544687461874,["gjx16@GJXAIOU",[[1,6225,"较难"]],[6225,6225],[6227,6227]]]],null,"gjx16@GJXAIOU"],["89a0d009-59ac-4b46-930e-d188f8ef6f65",1544690689380,"# C_PP_章五 纯虚函数和抽象类\n\n\n## 一、基本概念\n\n**纯虚函数：**\n* 纯虚函数声明格式： `virtual 返回值类型   函数名（参数列表）= 0 `\n* 纯虚函数是一个在基类中声明的虚函数，但是在基类中并没有定义（即没有具体的代码实现），但是要求任何的派生类都要实现属于自己的这个函数；\n* 纯虚函数为各派生类提供一个公共界面（接口的封装和设计、软件的模块功能划分）\n\n**抽象类：**\n  一个具有纯虚函数的基类被称为抽象类\n\n**注意点：**\n```cpp\nclass shape  //抽象类\n{\npublic:\n  point where()\n  {\n  return center;\n  }\n  virtual void rotate(int b) = 0;\n  virtual void draw() = 0;\n\n};\n\nint main()\n{\n  shape s;  //错误：抽象类不能建立对象\n  shape *s; //可以：可以声明抽象类的指针\n  shape f();//错误：抽象类不能作为返回类型\n  vois g(shape); //错误：抽象类不能作为参数类型\n  shape &h(shape &);  //可以：可以声明抽象类的引用\n  return 0;\n}\n\n\n```\n\n![image073]($resource/image073.png)\n\n\n\n## 二、抽象类案例\n\n```cpp\n//纯虚函数抽象类语法基础\n\n\n#include \"iostream\"\nusing namespace std;\n\nclass Figure\n{\npublic:\n\tvirtual void Area() = 0;   //声明一个纯虚函数，基类中不需要实现，在下面每一个继承类都需要按照各自需求进行实现\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\nclass circle :public Figure\n{\npublic:\n\tcircle(int r,int a, int b)\n\t{\n\t\tthis->r = r;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"圆的面积 \" << 3.14*r*r << endl;\n\t}\nprivate:\n\tint r;\n};\n\n\nclass rectangle :public Figure\n{\npublic:\n\trectangle(int length, int width, int a, int b)\n\t{\n\t\tthis->length = length;\n\t\tthis->width = width;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"长方形的面积 \" << length * width << endl;\n\t}\nprivate:\n\tint length;\n\tint width;\n};\n\nvoid getArea(Figure *base)\n{\n\tbase->Area();\n}\n\n\n\nint main()\n{\n\t\n\t//Figure f1;//这是错误的，抽象类不能实例化\n\tFigure *p = NULL;   //但是可以使用指针和引用\n\tcircle c1(2, 1, 2);\n\trectangle r1(1, 2, 3, 4);\n\n\tgetArea(&c1);\n\tgetArea(&r1);\n\tsystem(\"pause\");\n\treturn 0;\n} \n```\n\n\n## 三、抽象类在多继承中的应用\n\nC++中没有Java中的接口概念，抽象类可以模拟Java中的接口类。（接口和协议）\n\n\n\n### （一）有关多继承的说明\n\n**工程上的多继承**\n\n* 被实际开发经验抛弃的多继承\n* 工程开发中真正意义上的多继承是几乎不被使用的\n* 多重继承带来的代码复杂性远多于其带来的便利\n* 多重继承对代码维护性上的影响是灾难性的\n* 在设计方法上，任何多继承都可以用单继承代替 \n\n**多继承中的二义性和多继承不能解决的问题**\n![image076]($resource/image076.png)\n\n\n### （二）多继承的应用场景\n\n* 绝大多数面向对象语言都不支持多继承\n* 绝大多数面向对象语言都支持接口的概念\n* C++中没有接口的概念\n* C++中可以使用纯虚函数实现接口\n* 接口类中只有函数原型定义，没有任何数据的定义\n\n\n实际工程经验证明\n* 多重继承接口不会带来二义性和复杂性等问题 \n* 多重继承可以通过精心设计用单继承和接口来代替\n* 接口类只是一个功能说明，而不是功能实现。\n* 子类需要根据功能说明定义功能实现。\n\n抽象类在多继承中的应用的示例程序：\n```cpp\n//抽象类在多继承中的应用\n\n#include \"iostream\"\nusing namespace std;\n\nclass Interface1\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n};\n\nclass Interface2\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n\tvirtual int minus(int a, int b) = 0;\n};\n\nclass parent\n{\npublic:\n\tint a;\n};\n\nclass Child : public parent, public Interface1, public Interface2\n{\npublic:\n\tvoid print()\n\t{\n\t\tcout << \"Child::print\" << endl;\n\t}\n\n\tint add(int a, int b)\n\t{\n\t\treturn a + b;\n\t}\n\n\tint minus(int a, int b)\n\t{\n\t\treturn a - b;\n\t}\n\n};\n\nint main()\n{\n\n\tChild c;\n\tc.print();\n\tcout << c.add(3, 5) << endl;\n\tcout << c.minus(4, 6) << endl;\n\n\tInterface1* i1 = &c;\n\tInterface2* i2 = &c;\n\n\tcout << i1->add(7, 8) << endl;\n\tcout << i2->add(7, 8) << endl;\n\n\tsystem(\"pause\");\n\n}\n```\n\n\n\n\n## 四、抽象类知识点强化\n\n/*\n编写一个C++程序, 计算程序员( programmer )工资 \n 1 要求能计算出初级程序员( junior_programmer ) 中级程序员 ( mid_programmer )高级程序员( adv_programmer)的工资\n 2 要求利用抽象类统一界面,方便程序的扩展, 比如:新增, 计算 架构师 (architect ) 的工资 \n*/\n~~调用的时候参数有点问题~~\n```cpp\n//抽象类知识点的强化\n\n\n#include \"iostream\"\n#include \"sstream\"\nusing namespace std;\n\nclass programmer\n{\npublic:\n\tvirtual void getSal() = 0;\nprotected:\nprivate:\n};\n\nclass junior_programmer :public programmer\n{\npublic:\n\tjunior_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"junior_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\nclass mid_programmer :public programmer\n{\npublic:\n\tmid_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"mid_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n\nclass adv_programmer :public programmer\n{\npublic:\n\tadv_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"adv_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n//接下来为后期可以拓展的部分\n\n\nclass architect :public programmer\n{\npublic:\n\tarchitect(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"architect:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n//以上为后期拓展部分\n\nvoid pro_sale(programmer *base)\n{\n\tbase->getSal();\n}\n\n\nint main()\n{\n\tjunior_programmer jp(\"张三\",\"初级\",2000);\n\tmid_programmer mp(\"小张\", \"中级\", 8000);\n\tadv_programmer ap(\"小李\", \"高级\", 20394);\n\n\tpro_sale(&jp);\n\tpro_sale(&mp);\n\tpro_sale(&ap);\n\n\n\t//后期新增程序的调用\n\n\tarchitect ar(\"架构师\", \"牛\", 121332);\n\tpro_sale(&ar);\n\tsystem(\"pause\");\n\treturn 0; \n\n}\n```\n\n\n\n\n## 五、面向抽象类编程思想强化\n\n理论知识\n\nØ 虚函数和多态性使成员函数根据调用对象的类型产生不同的动作\n\nØ  多态性特别适合于实现分层结构的软件系统，便于对问题抽象时  定义共性，实现时定义区别\n\nØ **面向抽象类编程（面向接口编程）**是项目开发中重要技能之一。\n\n\n### （一）案例：socket库c++模型设计和实现\n\n**企业信息系统框架集成第三方产品**\n\n**案例背景**：一般的企业信息系统都有成熟的框架。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求**：请你在**企业信息系统框架**中集成第三方厂商的Socket通信产品和第三方厂商加密产品。\n\n第三方厂商的Socket通信产品：完成两点之间的通信；\n\n第三方厂商加密产品：完成数据发送时加密；数据解密时解密。\n\n![image077]($resource/image077.png)\n\n**案例要求**： 1）能支持多个厂商的Socket通信产品入围\n\n 2）能支持多个第三方厂商加密产品的入围\n\n 3）企业信息系统框架不轻易发生框架\n\n**需求实现**\n\n  思考1：企业信息系统框架、第三方产品如何分层\n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分成以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n分析有多少个类 CSocketProtocol  CSckFactoryImp1  CSckFactoryImp2\n\nCEncDesProtocol  HwEncdes  ciscoEncdes\n\n1、 定义 CSocketProtocol 抽象类\n\n2、 编写框架函数\n\n3、 编写框架测试函数\n\n4、 厂商1（CSckFactoryImp1）实现CSocketProtocol、厂商2（CSckFactoryImp1）实现CSocketProtocol\n\n5、 抽象加密接口（CEncDesProtocol）、加密厂商1(CHwImp)、加密厂商2(CCiscoImp))，集成实现业务模型\n\n6、 框架（c语言函数方式，框架函数；c++类方式，框架类）\n\n~~des.cpp程序没有，所以第7天的第17-20视频没有看~~\n\n**几个重要的面向对象思想**\n\n继承-组合（强弱）\n\n注入\n\n控制反转 IOC\n\nMVC\n\n  面向对象思想扩展aop思想\n\n aop思想是对继承编程思想的有力的补充\n\n\n### （二）案例：计算员工工资\n\n\n### （三）案例：计算几何体的表面积和体积\n~~第21个视频上有~~\n\n\n\n\n\n\n\n\n\n\n## 六、面向接口编程和C多态（在C语言中是实现与C++多态相同的功能）-贴近实战、较难\n\n\n**前言：数组指针语法梳理 **\n* 数组类型语法\n* 数组指针类型\n* 数组指针变量\n```cpp\n#include<stdio.h>\n\n//数组类型基本语法的知识梳理\n\n//1.定义一个数组类型\n\n\n//2.定义一个指针数组类型\n\n\n\n//3.定义一个指向 数组类型的指针（即 数组类指针）\n\n\nint  main()\n{\n\n\t//默认定义数组方式\n\tint  a[10];   //其中a代表数组首元素的地址，&a代表整个数组的地址， a+1 的步长为4，&a+1的步长为10\n\n\n\t//使用typedef定义数组类型\n\ttypedef int(MyTypeArray)[10];\n\t//定义变量\n\tMyTypeArray myArray;\n\tmyArray[0] = 10;\n\n\n\t//定义一个指针数组类型\n\ttypedef int (*PTypeArray)[10];\n\tPTypeArray *myPArray;\n\tmyPArray = &a;   //指向a数组的首地址\n\t(*myPArray)[0] = 20;  //操作元素\n\ta[0] = 10;\n\n\t//3.定义一个指向 数组类型的指针（即 数组类指针） 相当于直接定义变量而不是先定义类型在定义指针\n\n\tint(*myPString)[10];\n\tmyPString = &a;\n\t(*myPString)[0] = 10;\n\n\n}\n```\n\n\n\n### （一）函数类型语法基础\n\n**基础概念：**\n- 函数三要素：  名称、参数、返回值\n- C语言中的函数有自己特定的类型\n- C语言中通过typedef为函数类型重命名\n  * typedef type name(parameter list)\n  * typedef int f(int, int);\n  * typedef void p(int);\n\n**函数指针**\n\n* 函数指针用于指向一个函数\n\n* 函数名是函数体的入口地址\n\n  * 1)可通过函数类型定义函数指针: FuncType* pointer;\n  * 2)也可以直接定义：type (*pointer)(parameter list);\n\n    * pointer为函数指针变量名\n    * type为指向函数的返回值类型\n    * parameter list为指向函数的参数类型列表\n\n\n\n**函数指针语法梳理**\n- 函数类型\n- 函数指针类型\n- 函数指针变量\n以上三个的实现程序如下：\n```cpp\n//函数类型\n\n//1.如何定义一个函数类型\n//2.如何定义一个函数指针类型\n//3.如何定义一个函数指针（指向函数的入口）\n\nint add(int a, int b)\n{\n\tprintf(\"func is add a and b\");\n\treturn a + b;\n}\n\nvoid main()\n{\n\t//直接调用\n\tadd(1, 2);\n\n\t//定义一个函数类型\n\ttypedef int (MyFuncType)(int a, int b);//定义了一个类型\n\tMyFuncType *myPointerFunc = NULL;//定义了一个指针，指向某一种类的函数，这里的某一类是根据定义来判断：\n\t//这里某一类是指含有两个参数，返回值为int 的类型\n\n\tmyPointerFunc = &add;\n\tmyPointerFunc(3, 4); //间接调用\n\tmyPointerFunc = add;  //这里是否取地址都可以\n\tmyPointerFunc(3, 4); //间接调用\n\n\n\t//定义一个函数指针类型\n\ttypedef int(*MyPointerFuncType)(int a, int b);   //相当于定义：int *a = NULL;\n\n\tMyPointerFuncType MyPointer;//定义一个指针\n\tMyPointer = add;\n\tMyPointer(5, 6);\n\n\n\t//直接定义一个函数指针(相当于直接定义了一个变量)\n\tint(*MyPointerFunc)(int a, int b);//定义了一个变量\n\tMyPointerFunc = add;\n\tMyPointerFunc(7, 8);\n\n\n}\n```\n\n\n### （二）函数指针做函数参数\n\n**函数指针做函数参数概念**\n\n当函数指针 做为函数的参数，传递给一个被调用函数，\n\n被调用函数就可以通过这个指针调用外部的函数，这就形成了回调\n\n练习\n```cpp\nint add(int a, int b) \nint libfun( int (*pDis)(int a, int b) );\n\nint main(void)\n{\n int (*pfun)(int a, int b);  \n pfun = add;\n libfun(pfun);\n}\n\nint add(int a, int b)\n{\n return a + b;\n}\n\nint libfun( int (*pDis)(int a, int b) )\n{\n  int a, b;\n  a = 1;\n  b = 2;\nadd(1,3) //直接调用add函数\n\nprintf(\"%d\", pDis(a, b)); //通过函数指针做函数参数,间接调用add函数\n\n//思考 这样写 pDis(a, b)有什么好处?\n\n}\n```\n\n\n**剖析思路**\n\n//1函数的调用 和 函数的实现  有效的分离\n//2 C++的多态,可扩展\n\n现在这几个函数是在同一个文件当中，但是假如int libfun(int (*pDis)(int a, int b))是一个库中的函数，就只有使用回调了，通过函数指针参数将外部函数地址传入来实现调用，即使函数 add 的代码作了修改，也不必改动库的代码，就可以正常实现调用，这样便于程序的维护和升级\n\n回调函数思想：\n![image078]($resource/image078.png)\n**结论：回调函数的本质：提前做了一个协议的约定（把函数的参数、函数返回值提前约定）**\n\n请思考：C编译器通过那个具体的语法，实现解耦合的？\n\n C++编译器通过多态的机制(提前布局vptr指针和虚函数表,找虚函数入口地址来实现)\n\n\n**函数指针做函数参数思想剖析：**\n```cpp\n\n```\n\n                 \n\n\n### （三）函数指针正向调用\n\n1、 函数指针做函数参数，调用方式\n\n被调用函数和主调函数在同一文件中（用来教学，没有任何意义）\n\n\n2、函数指针做函数参数\n\n被调用函数和主调函数不在同一个文件中、模块中。\n\n难点：理解被调用函数是什么机制被调用起来的。框架\n\n框架提前设置了被调用函数的入口（框架提供了第三方模块入口地址的集成功能）\n\n框架具备调用第三方模块入口函数\n\n3、 练习\n```cpp\n\n```\n\ntypedef int (*EncDataFunc)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\nint MyEncDataFunc(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen)\n\n{\n\n int rv = 0;\n\n char *p = \"222222222222\";\n\n strcpy(outData, p);\n\n *outDataLen = strlen(p);\n\n return rv;\n\n}\n\nint Send_Data(EncDataFunc encDataFunc, unsigned char *inData, int inDataLen, unsigned char *outData, int *outDatalen)\n\n{\n\n int rv = 0;\n\n if (encDataFunc != NULL)\n\n {\n\n rv = encDataFunc(inData, inDataLen, outData, outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"func encDataFunc() err.\\n\");\n\n return rv;\n\n }\n\n }\n\n return rv;\n\n}\n\nint main()\n\n{\n\n int rv = 0;\n\n EncDataFunc encDataFunc = NULL;\n\n encDataFunc = MyEncDataFunc;\n\n // 第一个调用\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"1111\");\n\n inDataLen = strlen(inData);\n\n rv = encDataFunc(inData,inDataLen, outData, &outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"edf err .....\\n\");\n\n }\n\n else\n\n {\n\n printf(\"edf ok \\n\");\n\n printf(\"%s \\n\", outData);\n\n }\n\n }\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"3333\");\n\n inDataLen = strlen(inData);\n\n rv = Send_Data(MyEncDataFunc, inData, inDataLen, outData, &outDatalen);\n\n if (rv != 0)\n\n {\n\n printf(\"func Send_Data err:%d\", rv);\n\n return rv;\n\n }\n\n printf(\"%s \\n\", outData);\n\n }\n\n getchar();\n\n}\n\n |\n\n### （四）函数指针反向调用\n\n回调函数效果展示。\n\n\n### （五）C动态库升级成框架案例\n\n**C****语言版本Socket****动态库升级成框架集成第三方产品**\n\n**简称：C****动态库升级成框架案例**\n\n**名字解释       **\n\n  动态库：抽象类一个套接口，单独封装成模块，供别人调用；无法扩展。\n\n  框架：能自由的扩展 \n\n**案例背景**：一般的企业信息系统都有成熟的框架，可以有C语言写，也可以由C++语言。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求：**在socket通信库中，完成数据加密功能，有n个厂商的加密产品供你选择，如何实现动态库和第三个厂商产品的解耦合。\n\n提醒：C++通过抽象类，也就是面向抽象类编程实现的（相当于C++编译器通过多态机制，已经很好用了。提前布局vptr指针、虚函数表；调用是迟绑定完成。），\n\n**C****语言**中如何实现哪？\n\n**案例要求**： 1）能支持多个第三方厂商加密产品的入围\n\n 2）企业信息系统框架不轻易发生框架\n\n**需求实现思路分析**\n![image079]($resource/image80.png) \n  思考1：企业信息系统框架、第三方产品如何分层 \n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分层确定后，动态库应该做什么？产品入围厂商应该做什么？\n\n以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n1、 动态库中定义协议，并完成任务的调用\n\ntypedef int (*EncData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\ntypedef int (*DecData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\n2、 加密厂商完成协议函数的编写\n\n3、 对接调试。\n\n4、 动态库中可以缓存第三方函数的入口地址，也可以不缓存，两种实现方式。\n\n**案例总结**\n\n  回调函数：利用函数指针做函数参数，实现的一种调用机制，具体任务的实现者，可以不知道什么时候被调用。\n\n  回调机制原理：\n\n  当具体事件发生时，调用者通过函数指针调用具体函数\n\n  回调机制的将调用者和被调函数分开，两者互不依赖\n\n  任务的实现 和 任务的调用 可以耦合  （提前进行接口的封装和设计）\n\n### （六）附录：诸葛亮的锦囊妙计**\n\n诸葛亮对刘备，暗暗关照赵云道：“我这里有三个锦囊，内藏三条妙计。到南徐时打开第一个，到年底时打开第二个，危急无路时打开第三个。”\n\n第一个锦囊\n\n  一到东吴就拜会乔国老\n\n第二个锦囊\n\n  刘备被孙权设计留下就对他谎称曹操大军压境\n\n第三个锦囊\n\n被东吴军队追赶就求孙夫人解围\n",[[1544690664982,["gjx16@GJXAIOU",[[1,8895,"//函数指针做函数参数的思想剖析\n#include<stdio.h>\n\n\nint add(int a, int b) //自任务的实现者\n{\n\tprintf(\"func is add a and b\");\n\treturn a + b;\n}\n\n//假设这是后来实现的代码：\nint add2(int a, int b) //自任务的实现者\n{\n\tprintf(\"func2 is add a and b\");\n\treturn a + b;\n}\n\n\n\n\n//定义一个函数指针类型\ntypedef int(*MyPointerFuncType)(int a, int b);   //相当于定义：int *a = NULL;\n\n\n//函数指针做函数参数\nint MainOp(MyPointerFuncType myFuncAdd)\n{\n\t int c = myFuncAdd(5, 6);\n\t return c;\n}\n//函数指针做函数参数的第二种方式\nint MainOp2(int(*MyPointerFuncType)(int a, int b))\n{\n\tint d = MyPointerFuncType(5, 6);\n\treturn d;\n}\n\n\n\nvoid main()\n{\n\n\tMyPointerFuncType myFuncAdd = NULL;\n\tadd(1, 2);\n\n\n\tMyPointerFuncType MyPointer;//定义一个指针\n\tMyPointer = add;\n\tMyPointer(5, 6);\n\n\n\t//具体的调用\n\tMainOp(add);\n\tMainOp2(add);\n\n\t//加上后来实现者之后，在MainOP框架没有任何改变的情况下实现对新增函数的调用\n\tMainOp2(add2);\n\n\treturn 0;\n}\n"]],[8895,8895],[9677,9677]]],[1544690673072,["gjx16@GJXAIOU",[[-1,9693,"       "]],[9690,9690],[9683,9683]]],[1544690673650,["gjx16@GJXAIOU",[[-1,9682,"\n"]],[9683,9683],[9682,9682]]],[1544711147300,["gjx16@GJXAIOU",[[1,293,"  "]],[293,293],[295,295]]],[1544711165499,["gjx16@GJXAIOU",[[-1,273,"point"]],[278,278],[273,273]]],[1544711171718,["gjx16@GJXAIOU",[[1,273,"void"]],[273,273],[277,277]]],[1544711314651,["gjx16@GJXAIOU",[[-1,563,"\n"]],[563,563],[562,562]]],[1544711315379,["gjx16@GJXAIOU",[[-1,562,"\n"]],[562,562],[561,561]]]],null,"gjx16@GJXAIOU"],["e0a82589-e6d7-4e3c-812d-92bb44ef96e2",1547808601220,"# C_PP_章五 纯虚函数和抽象类\n\n\n## 一、基本概念\n\n**纯虚函数：**\n* 纯虚函数声明格式： `virtual 返回值类型   函数名（参数列表）= 0 `\n* 纯虚函数是一个在基类中声明的虚函数，但是在基类中并没有定义（即没有具体的代码实现），但是要求任何的派生类都要实现属于自己的这个函数；\n* 纯虚函数为各派生类提供一个公共界面（接口的封装和设计、软件的模块功能划分）\n\n**抽象类：**\n  一个具有纯虚函数的基类被称为抽象类\n\n**注意点：**\n```cpp\nclass shape  //抽象类\n{\npublic:\n  void where()\n  {\n    return center;\n  }\n  virtual void rotate(int b) = 0;\n  virtual void draw() = 0;\n\n};\n\nint main()\n{\n  shape s;  //错误：抽象类不能建立对象\n  shape *s; //可以：可以声明抽象类的指针\n  shape f();//错误：抽象类不能作为返回类型\n  vois g(shape); //错误：抽象类不能作为参数类型\n  shape &h(shape &);  //可以：可以声明抽象类的引用\n  return 0;\n}\n```\n\n![image073]($resource/image073.png)\n\n\n\n## 二、抽象类案例\n\n```cpp\n//纯虚函数抽象类语法基础\n\n\n#include \"iostream\"\nusing namespace std;\n\nclass Figure\n{\npublic:\n\tvirtual void Area() = 0;   //声明一个纯虚函数，基类中不需要实现，在下面每一个继承类都需要按照各自需求进行实现\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\nclass circle :public Figure\n{\npublic:\n\tcircle(int r,int a, int b)\n\t{\n\t\tthis->r = r;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"圆的面积 \" << 3.14*r*r << endl;\n\t}\nprivate:\n\tint r;\n};\n\n\nclass rectangle :public Figure\n{\npublic:\n\trectangle(int length, int width, int a, int b)\n\t{\n\t\tthis->length = length;\n\t\tthis->width = width;\n\t}\n\n\tvirtual void Area()  //子类中必须实现这个函数\n\t{\n\t\tcout << \"长方形的面积 \" << length * width << endl;\n\t}\nprivate:\n\tint length;\n\tint width;\n};\n\nvoid getArea(Figure *base)\n{\n\tbase->Area();\n}\n\n\n\nint main()\n{\n\t\n\t//Figure f1;//这是错误的，抽象类不能实例化\n\tFigure *p = NULL;   //但是可以使用指针和引用\n\tcircle c1(2, 1, 2);\n\trectangle r1(1, 2, 3, 4);\n\n\tgetArea(&c1);\n\tgetArea(&r1);\n\tsystem(\"pause\");\n\treturn 0;\n} \n```\n\n\n## 三、抽象类在多继承中的应用\n\nC++中没有Java中的接口概念，抽象类可以模拟Java中的接口类。（接口和协议）\n\n\n\n### （一）有关多继承的说明\n\n**工程上的多继承**\n\n* 被实际开发经验抛弃的多继承\n* 工程开发中真正意义上的多继承是几乎不被使用的\n* 多重继承带来的代码复杂性远多于其带来的便利\n* 多重继承对代码维护性上的影响是灾难性的\n* 在设计方法上，任何多继承都可以用单继承代替 \n\n**多继承中的二义性和多继承不能解决的问题**\n![image076]($resource/image076.png)\n\n\n### （二）多继承的应用场景\n\n* 绝大多数面向对象语言都不支持多继承\n* 绝大多数面向对象语言都支持接口的概念\n* C++中没有接口的概念\n* C++中可以使用纯虚函数实现接口\n* 接口类中只有函数原型定义，没有任何数据的定义\n\n\n实际工程经验证明\n* 多重继承接口不会带来二义性和复杂性等问题 \n* 多重继承可以通过精心设计用单继承和接口来代替\n* 接口类只是一个功能说明，而不是功能实现。\n* 子类需要根据功能说明定义功能实现。\n\n抽象类在多继承中的应用的示例程序：\n```cpp\n//抽象类在多继承中的应用\n\n#include \"iostream\"\nusing namespace std;\n\nclass Interface1\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n};\n\nclass Interface2\n{\npublic:\n\tvirtual void print() = 0;\n\tvirtual int add(int a, int b) = 0;\n\tvirtual int minus(int a, int b) = 0;\n};\n\nclass parent\n{\npublic:\n\tint a;\n};\n\nclass Child : public parent, public Interface1, public Interface2\n{\npublic:\n\tvoid print()\n\t{\n\t\tcout << \"Child::print\" << endl;\n\t}\n\n\tint add(int a, int b)\n\t{\n\t\treturn a + b;\n\t}\n\n\tint minus(int a, int b)\n\t{\n\t\treturn a - b;\n\t}\n\n};\n\nint main()\n{\n\n\tChild c;\n\tc.print();\n\tcout << c.add(3, 5) << endl;\n\tcout << c.minus(4, 6) << endl;\n\n\tInterface1* i1 = &c;\n\tInterface2* i2 = &c;\n\n\tcout << i1->add(7, 8) << endl;\n\tcout << i2->add(7, 8) << endl;\n\n\tsystem(\"pause\");\n\n}\n```\n\n\n\n\n## 四、抽象类知识点强化\n\n/*\n编写一个C++程序, 计算程序员( programmer )工资 \n 1 要求能计算出初级程序员( junior_programmer ) 中级程序员 ( mid_programmer )高级程序员( adv_programmer)的工资\n 2 要求利用抽象类统一界面,方便程序的扩展, 比如:新增, 计算 架构师 (architect ) 的工资 \n*/\n~~调用的时候参数有点问题~~\n```cpp\n//抽象类知识点的强化\n\n\n#include \"iostream\"\n#include \"sstream\"\nusing namespace std;\n\nclass programmer\n{\npublic:\n\tvirtual void getSal() = 0;\nprotected:\nprivate:\n};\n\nclass junior_programmer :public programmer\n{\npublic:\n\tjunior_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"junior_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\nclass mid_programmer :public programmer\n{\npublic:\n\tmid_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"mid_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n\nclass adv_programmer :public programmer\n{\npublic:\n\tadv_programmer(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"adv_programmer:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n\n//接下来为后期可以拓展的部分\n\n\nclass architect :public programmer\n{\npublic:\n\tarchitect(char *name, char *job, int sale)\n\t{\n\t\tthis->name = name;\n\t\tthis->job = job;\n\t\tthis->sale = sale;\n\t}\n\n\tvirtual void getSal()\n\t{\n\t\tcout << \"architect:\" << endl;\n\t\tcout << \"name = \" << name << \"  job:\" << job << \" sale :\" << sale << endl;\n\t}\nprotected:\nprivate:\n\tchar *name;\n\tchar *job;\n\tint sale;\n};\n\n//以上为后期拓展部分\n\nvoid pro_sale(programmer *base)\n{\n\tbase->getSal();\n}\n\n\nint main()\n{\n\tjunior_programmer jp(\"张三\",\"初级\",2000);\n\tmid_programmer mp(\"小张\", \"中级\", 8000);\n\tadv_programmer ap(\"小李\", \"高级\", 20394);\n\n\tpro_sale(&jp);\n\tpro_sale(&mp);\n\tpro_sale(&ap);\n\n\n\t//后期新增程序的调用\n\n\tarchitect ar(\"架构师\", \"牛\", 121332);\n\tpro_sale(&ar);\n\tsystem(\"pause\");\n\treturn 0; \n\n}\n```\n\n\n\n\n## 五、面向抽象类编程思想强化\n\n理论知识\n\nØ 虚函数和多态性使成员函数根据调用对象的类型产生不同的动作\n\nØ  多态性特别适合于实现分层结构的软件系统，便于对问题抽象时  定义共性，实现时定义区别\n\nØ **面向抽象类编程（面向接口编程）**是项目开发中重要技能之一。\n\n\n### （一）案例：socket库c++模型设计和实现\n\n**企业信息系统框架集成第三方产品**\n\n**案例背景**：一般的企业信息系统都有成熟的框架。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求**：请你在**企业信息系统框架**中集成第三方厂商的Socket通信产品和第三方厂商加密产品。\n\n第三方厂商的Socket通信产品：完成两点之间的通信；\n\n第三方厂商加密产品：完成数据发送时加密；数据解密时解密。\n\n![image077]($resource/image077.png)\n\n**案例要求**： 1）能支持多个厂商的Socket通信产品入围\n\n 2）能支持多个第三方厂商加密产品的入围\n\n 3）企业信息系统框架不轻易发生框架\n\n**需求实现**\n\n  思考1：企业信息系统框架、第三方产品如何分层\n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分成以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n分析有多少个类 CSocketProtocol  CSckFactoryImp1  CSckFactoryImp2\n\nCEncDesProtocol  HwEncdes  ciscoEncdes\n\n1、 定义 CSocketProtocol 抽象类\n\n2、 编写框架函数\n\n3、 编写框架测试函数\n\n4、 厂商1（CSckFactoryImp1）实现CSocketProtocol、厂商2（CSckFactoryImp1）实现CSocketProtocol\n\n5、 抽象加密接口（CEncDesProtocol）、加密厂商1(CHwImp)、加密厂商2(CCiscoImp))，集成实现业务模型\n\n6、 框架（c语言函数方式，框架函数；c++类方式，框架类）\n\n~~des.cpp程序没有，所以第7天的第17-20视频没有看~~\n\n**几个重要的面向对象思想**\n\n继承-组合（强弱）\n\n注入\n\n控制反转 IOC\n\nMVC\n\n  面向对象思想扩展aop思想\n\n aop思想是对继承编程思想的有力的补充\n\n\n### （二）案例：计算员工工资\n\n\n### （三）案例：计算几何体的表面积和体积\n~~第21个视频上有~~\n\n\n\n\n\n\n\n\n\n\n## 六、面向接口编程和C多态（在C语言中是实现与C++多态相同的功能）-贴近实战、较难\n\n\n**前言：数组指针语法梳理 **\n* 数组类型语法\n* 数组指针类型\n* 数组指针变量\n```cpp\n#include<stdio.h>\n\n//数组类型基本语法的知识梳理\n\n//1.定义一个数组类型\n\n\n//2.定义一个指针数组类型\n\n\n\n//3.定义一个指向 数组类型的指针（即 数组类指针）\n\n\nint  main()\n{\n\n\t//默认定义数组方式\n\tint  a[10];   //其中a代表数组首元素的地址，&a代表整个数组的地址， a+1 的步长为4，&a+1的步长为10\n\n\n\t//使用typedef定义数组类型\n\ttypedef int(MyTypeArray)[10];\n\t//定义变量\n\tMyTypeArray myArray;\n\tmyArray[0] = 10;\n\n\n\t//定义一个指针数组类型\n\ttypedef int (*PTypeArray)[10];\n\tPTypeArray *myPArray;\n\tmyPArray = &a;   //指向a数组的首地址\n\t(*myPArray)[0] = 20;  //操作元素\n\ta[0] = 10;\n\n\t//3.定义一个指向 数组类型的指针（即 数组类指针） 相当于直接定义变量而不是先定义类型在定义指针\n\n\tint(*myPString)[10];\n\tmyPString = &a;\n\t(*myPString)[0] = 10;\n\n\n}\n```\n\n\n\n### （一）函数类型语法基础\n\n**基础概念：**\n- 函数三要素：  名称、参数、返回值\n- C语言中的函数有自己特定的类型\n- C语言中通过typedef为函数类型重命名\n  * typedef type name(parameter list)\n  * typedef int f(int, int);\n  * typedef void p(int);\n\n**函数指针**\n\n* 函数指针用于指向一个函数\n\n* 函数名是函数体的入口地址\n\n  * 1)可通过函数类型定义函数指针: FuncType* pointer;\n  * 2)也可以直接定义：type (*pointer)(parameter list);\n\n    * pointer为函数指针变量名\n    * type为指向函数的返回值类型\n    * parameter list为指向函数的参数类型列表\n\n\n\n**函数指针语法梳理**\n- 函数类型\n- 函数指针类型\n- 函数指针变量\n以上三个的实现程序如下：\n```cpp\n//函数类型\n\n//1.如何定义一个函数类型\n//2.如何定义一个函数指针类型\n//3.如何定义一个函数指针（指向函数的入口）\n\nint add(int a, int b)\n{\n\tprintf(\"func is add a and b\");\n\treturn a + b;\n}\n\nvoid main()\n{\n\t//直接调用\n\tadd(1, 2);\n\n\t//定义一个函数类型\n\ttypedef int (MyFuncType)(int a, int b);//定义了一个类型\n\tMyFuncType *myPointerFunc = NULL;//定义了一个指针，指向某一种类的函数，这里的某一类是根据定义来判断：\n\t//这里某一类是指含有两个参数，返回值为int 的类型\n\n\tmyPointerFunc = &add;\n\tmyPointerFunc(3, 4); //间接调用\n\tmyPointerFunc = add;  //这里是否取地址都可以\n\tmyPointerFunc(3, 4); //间接调用\n\n\n\t//定义一个函数指针类型\n\ttypedef int(*MyPointerFuncType)(int a, int b);   //相当于定义：int *a = NULL;\n\n\tMyPointerFuncType MyPointer;//定义一个指针\n\tMyPointer = add;\n\tMyPointer(5, 6);\n\n\n\t//直接定义一个函数指针(相当于直接定义了一个变量)\n\tint(*MyPointerFunc)(int a, int b);//定义了一个变量\n\tMyPointerFunc = add;\n\tMyPointerFunc(7, 8);\n\n\n}\n```\n\n\n### （二）函数指针做函数参数\n\n**函数指针做函数参数概念**\n\n当函数指针 做为函数的参数，传递给一个被调用函数，\n\n被调用函数就可以通过这个指针调用外部的函数，这就形成了回调\n\n练习\n```cpp\nint add(int a, int b) \nint libfun( int (*pDis)(int a, int b) );\n\nint main(void)\n{\n int (*pfun)(int a, int b);  \n pfun = add;\n libfun(pfun);\n}\n\nint add(int a, int b)\n{\n return a + b;\n}\n\nint libfun( int (*pDis)(int a, int b) )\n{\n  int a, b;\n  a = 1;\n  b = 2;\nadd(1,3) //直接调用add函数\n\nprintf(\"%d\", pDis(a, b)); //通过函数指针做函数参数,间接调用add函数\n\n//思考 这样写 pDis(a, b)有什么好处?\n\n}\n```\n\n\n**剖析思路**\n\n//1函数的调用 和 函数的实现  有效的分离\n//2 C++的多态,可扩展\n\n现在这几个函数是在同一个文件当中，但是假如int libfun(int (*pDis)(int a, int b))是一个库中的函数，就只有使用回调了，通过函数指针参数将外部函数地址传入来实现调用，即使函数 add 的代码作了修改，也不必改动库的代码，就可以正常实现调用，这样便于程序的维护和升级\n\n回调函数思想：\n![image078]($resource/image078.png)\n**结论：回调函数的本质：提前做了一个协议的约定（把函数的参数、函数返回值提前约定）**\n\n请思考：C编译器通过那个具体的语法，实现解耦合的？\n\n C++编译器通过多态的机制(提前布局vptr指针和虚函数表,找虚函数入口地址来实现)\n\n\n**函数指针做函数参数思想剖析：**\n```cpp\n//函数指针做函数参数的思想剖析\n#include<stdio.h>\n\n\nint add(int a, int b) //自任务的实现者\n{\n\tprintf(\"func is add a and b\");\n\treturn a + b;\n}\n\n//假设这是后来实现的代码：\nint add2(int a, int b) //自任务的实现者\n{\n\tprintf(\"func2 is add a and b\");\n\treturn a + b;\n}\n\n\n\n\n//定义一个函数指针类型\ntypedef int(*MyPointerFuncType)(int a, int b);   //相当于定义：int *a = NULL;\n\n\n//函数指针做函数参数\nint MainOp(MyPointerFuncType myFuncAdd)\n{\n\t int c = myFuncAdd(5, 6);\n\t return c;\n}\n//函数指针做函数参数的第二种方式\nint MainOp2(int(*MyPointerFuncType)(int a, int b))\n{\n\tint d = MyPointerFuncType(5, 6);\n\treturn d;\n}\n\n\n\nvoid main()\n{\n\n\tMyPointerFuncType myFuncAdd = NULL;\n\tadd(1, 2);\n\n\n\tMyPointerFuncType MyPointer;//定义一个指针\n\tMyPointer = add;\n\tMyPointer(5, 6);\n\n\n\t//具体的调用\n\tMainOp(add);\n\tMainOp2(add);\n\n\t//加上后来实现者之后，在MainOP框架没有任何改变的情况下实现对新增函数的调用\n\tMainOp2(add2);\n\n\treturn 0;\n}\n\n```\n          \n\n\n### （三）函数指针正向调用\n\n1、 函数指针做函数参数，调用方式\n\n被调用函数和主调函数在同一文件中（用来教学，没有任何意义）\n\n\n2、函数指针做函数参数\n\n被调用函数和主调函数不在同一个文件中、模块中。\n\n难点：理解被调用函数是什么机制被调用起来的。框架\n\n框架提前设置了被调用函数的入口（框架提供了第三方模块入口地址的集成功能）\n\n框架具备调用第三方模块入口函数\n\n3、 练习\n```cpp\n\n```\n\ntypedef int (*EncDataFunc)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\nint MyEncDataFunc(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen)\n\n{\n\n int rv = 0;\n\n char *p = \"222222222222\";\n\n strcpy(outData, p);\n\n *outDataLen = strlen(p);\n\n return rv;\n\n}\n\nint Send_Data(EncDataFunc encDataFunc, unsigned char *inData, int inDataLen, unsigned char *outData, int *outDatalen)\n\n{\n\n int rv = 0;\n\n if (encDataFunc != NULL)\n\n {\n\n rv = encDataFunc(inData, inDataLen, outData, outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"func encDataFunc() err.\\n\");\n\n return rv;\n\n }\n\n }\n\n return rv;\n\n}\n\nint main()\n\n{\n\n int rv = 0;\n\n EncDataFunc encDataFunc = NULL;\n\n encDataFunc = MyEncDataFunc;\n\n // 第一个调用\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"1111\");\n\n inDataLen = strlen(inData);\n\n rv = encDataFunc(inData,inDataLen, outData, &outDatalen, NULL, 0);\n\n if (rv != 0)\n\n {\n\n printf(\"edf err .....\\n\");\n\n }\n\n else\n\n {\n\n printf(\"edf ok \\n\");\n\n printf(\"%s \\n\", outData);\n\n }\n\n }\n\n {\n\n unsigned char inData[2048];\n\n int inDataLen;\n\n unsigned char outData[2048];\n\n int outDatalen;\n\n strcpy(inData, \"3333\");\n\n inDataLen = strlen(inData);\n\n rv = Send_Data(MyEncDataFunc, inData, inDataLen, outData, &outDatalen);\n\n if (rv != 0)\n\n {\n\n printf(\"func Send_Data err:%d\", rv);\n\n return rv;\n\n }\n\n printf(\"%s \\n\", outData);\n\n }\n\n getchar();\n\n}\n\n |\n\n### （四）函数指针反向调用\n\n回调函数效果展示。\n\n\n### （五）C动态库升级成框架案例\n\n**C****语言版本Socket****动态库升级成框架集成第三方产品**\n\n**简称：C****动态库升级成框架案例**\n\n**名字解释       **\n\n  动态库：抽象类一个套接口，单独封装成模块，供别人调用；无法扩展。\n\n  框架：能自由的扩展 \n\n**案例背景**：一般的企业信息系统都有成熟的框架，可以有C语言写，也可以由C++语言。软件框架一般不发生变化，能自由的集成第三方厂商的产品。\n\n**案例需求：**在socket通信库中，完成数据加密功能，有n个厂商的加密产品供你选择，如何实现动态库和第三个厂商产品的解耦合。\n\n提醒：C++通过抽象类，也就是面向抽象类编程实现的（相当于C++编译器通过多态机制，已经很好用了。提前布局vptr指针、虚函数表；调用是迟绑定完成。），\n\n**C****语言**中如何实现哪？\n\n**案例要求**： 1）能支持多个第三方厂商加密产品的入围\n\n 2）企业信息系统框架不轻易发生框架\n\n**需求实现思路分析**\n![image079]($resource/image80.png) \n  思考1：企业信息系统框架、第三方产品如何分层 \n\n思考2：企业信息系统框架，如何自由集成第三方产品\n\n（软件设计：模块要求松、接口要求紧）\n\n  思考3：软件分层确定后，动态库应该做什么？产品入围厂商应该做什么？\n\n以后，开发企业信息系统框架的程序员，应该做什么？\n\n  第三方产品入围应该做什么？\n\n**编码实现**\n\n1、 动态库中定义协议，并完成任务的调用\n\ntypedef int (*EncData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\ntypedef int (*DecData)(unsigned char *inData,int inDataLen,unsigned char *outData,int *outDataLen,void *Ref, int RefLen);\n\n2、 加密厂商完成协议函数的编写\n\n3、 对接调试。\n\n4、 动态库中可以缓存第三方函数的入口地址，也可以不缓存，两种实现方式。\n\n**案例总结**\n\n  回调函数：利用函数指针做函数参数，实现的一种调用机制，具体任务的实现者，可以不知道什么时候被调用。\n\n  回调机制原理：\n\n  当具体事件发生时，调用者通过函数指针调用具体函数\n\n  回调机制的将调用者和被调函数分开，两者互不依赖\n\n  任务的实现 和 任务的调用 可以耦合  （提前进行接口的封装和设计）\n\n### （六）附录：诸葛亮的锦囊妙计**\n\n诸葛亮对刘备，暗暗关照赵云道：“我这里有三个锦囊，内藏三条妙计。到南徐时打开第一个，到年底时打开第二个，危急无路时打开第三个。”\n\n第一个锦囊\n\n  一到东吴就拜会乔国老\n\n第二个锦囊\n\n  刘备被孙权设计留下就对他谎称曹操大军压境\n\n第三个锦囊\n\n被东吴军队追赶就求孙夫人解围\n",[[1547808565363,["gjx16@GJXAIOU",[[-1,11795,"****"]],[11799,11799],[11795,11795]]]],null,"gjx16@GJXAIOU"]]}