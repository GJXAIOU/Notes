{"compress":true,"commitItems":[["8b9834ff-1710-4026-bc2a-a3e250584e93",1542545657606,"",[[1542545628003,["gjx16@GJXAIOU",[[1,0,"# C_PP_章二 类和对象\n\n\n\n"]],[0,0],[17,17]]],[1542545631944,["gjx16@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1542545634794,["gjx16@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1542545634935,["gjx16@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1542545635104,["gjx16@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1542545635127,["gjx16@GJXAIOU",[[1,4,"\n---\n\n"]],[3,3],[4,4]]],[1542545641027,["gjx16@GJXAIOU",[[1,4,"date:``"]],[4,4],[11,11]]],[1542545652026,["gjx16@GJXAIOU",[[1,10,"2018-11-19-201811-2"]],[10,10],[29,29]]],[1542545653492,["gjx16@GJXAIOU",[[-1,28,"2"]],[29,29],[28,28]]],[1542545654201,["gjx16@GJXAIOU",[[1,28,"19"]],[28,28],[30,30]]],[1542545657699,["gjx16@GJXAIOU",[[1,25,"-"]],[25,25],[26,26]]],[1542545748131,["gjx16@GJXAIOU",[[1,54,"**1****前言**\n\nC++学习技术路线及目标\n\n  研究C++编译器管理类和对象的方法 ===》避免死角\n\n c++编译器对类对象的生命周期管理，对象创建、使用、销毁\n\n c++面向对象模型初探\n\n c++面向对象多态原理探究\n\n  操作符重载\n\nC++基础课程学习完毕以后，有没有一个标准，来判断自己有没有入门。\n\n  面向抽象类（接口）编程\n\n**2****类和对象**\n\n**2.1** **基本概念**\n\n1）类、对象、成员变量、成员函数\n\n2）面向对象三大概念\n\n封装、继承、多态\n\n3）编程实践\n\n  类的定义和对象的定义，对象的使用\n\n  求圆形的面积\n\n  定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n**2.2****类的封装**\n\n**1****）封装（Encapsulation****）**\n\nA）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n\nB）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  _备注：有2__层含义（把属性和方法进行封装_ _对属性和方法进行访问控制）_\n\nC++中类的封装\n\n成员变量，C++中用于表示类属性的变量\n\n成员函数，C++中用于表示类行为的函数\n\n**2****）类成员的访问控制**\n\n在C++中可以给成员变量和成员函数定义访问级别\n\nPublic修饰成员变量和成员函数可以在类的内部和类的外部被访问\n\nPrivate修饰成员变量和成员函数只能在类的内部被访问\n\n| \n\n//类是把属性和方法封装 同时对信息进行访问控制\n\n//类的内部，类的外部\n\n//我们抽象了一个类，用类去定义对象\n\n//类是一个数据类型，类是抽象的\n\n//对象是一个具体的变量。。占用内存空间。\n\nclass Circle\n\n{\n\npublic:\n\n double r;\n\n double s;\n\npublic:\n\n double getR()\n\n {\n\n a++;\n\n return r;\n\n }\n\n void setR(double val)\n\n {\n\n r = val;\n\n }\n\npublic:\n\n double getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\n {\n\n s = 3.14f*r*r;\n\n return s;\n\n }\n\n//private:\n\n int a;\n\n};\n\n |\n\n**3****）****struct****和class****关键字区别**\n\n在用struct定义类时，所有成员的默认属性为public\n\n在用class定义类时，所有成员的默认属性为private\n\n**2.3 C++****面向对象程序设计举例**\n\n**目标：面向过程向面向对象思想转变**\n\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n案例1 设计立方体类(cube)，求出立方体的面积和体积\n\n  求两个立方体，是否相等（全局函数和成员函数）\n\n案例2 设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n\n  即：求点和圆的关系（圆内和圆外）\n\n案例3 对于第二个案例，类的声明和类的实现分开\n\n**2.4** **作业**\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n\n2）定义一个圆形类，其属性包括圆心和半径；\n\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。"]],[54,54],[1748,1748]]],[1542545813585,["gjx16@GJXAIOU",[[-1,54,"**1****前言**"]],[54,65],[54,54]]],[1542545818456,["gjx16@GJXAIOU",[[1,54,"## yi"]],[54,54],[59,59]]],[1542545819078,["gjx16@GJXAIOU",[[-1,57,"yi"]],[59,59],[57,57]]],[1542545822721,["gjx16@GJXAIOU",[[1,57,"一、前言"]],[57,57],[61,61]]],[1542545828665,["gjx16@GJXAIOU",[[1,63,"- "]],[63,63],[65,65]]],[1542545831478,["gjx16@GJXAIOU",[[-1,80," "]],[81,81],[80,80]]],[1542545838498,["gjx16@GJXAIOU",[[1,80,"* "],[1,107," * "],[1,109,"* "],[1,138," * "],[1,140,"* "],[1,152," * "],[1,154,"* "],[1,168," * "],[1,170,"*"]],[80,176],[82,197]]],[1542545839847,["gjx16@GJXAIOU",[[1,80,"  "],[1,110,"  "],[1,114,"  "],[1,146,"  "],[1,150,"  "],[1,165,"  "],[1,168,"  "],[1,186,"  "],[1,189,"  "]],[82,197],[84,215]]],[1542545844186,["gjx16@GJXAIOU",[[-1,111,"   * "]],[111,116],[111,111]]],[1542545844798,["gjx16@GJXAIOU",[[-1,111,"\n"]],[111,111],[110,110]]],[1542545846278,["gjx16@GJXAIOU",[[-1,145,"   * "]],[145,150],[145,145]]],[1542545846654,["gjx16@GJXAIOU",[[-1,145,"\n"]],[145,145],[144,144]]],[1542545847541,["gjx16@GJXAIOU",[[-1,166," "]],[167,167],[166,166]]],[1542545847734,["gjx16@GJXAIOU",[[-1,161,"\n"]],[162,162],[161,161]]],[1542545848935,["gjx16@GJXAIOU",[[-1,78,"\n"]],[78,78],[77,77]]],[1542545850463,["gjx16@GJXAIOU",[[-1,188," "]],[189,189],[188,188]]],[1542545851590,["gjx16@GJXAIOU",[[-1,162," *"]],[162,164],[162,162]]],[1542545852502,["gjx16@GJXAIOU",[[-1,182,"   *"]],[182,186],[182,182]]],[1542545853633,["gjx16@GJXAIOU",[[-1,182,"\n"]],[182,182],[181,181]]],[1542545862728,["gjx16@GJXAIOU",[[1,194,"- "]],[194,194],[196,196]]],[1542545867368,["gjx16@GJXAIOU",[[1,233,"  "]],[233,233],[235,235]]],[1542545869993,["gjx16@GJXAIOU",[[-1,234," "]],[235,235],[234,234]]],[1542545874502,["gjx16@GJXAIOU",[[-1,230,"\n"]],[230,230],[229,229]]],[1542545880719,["gjx16@GJXAIOU",[[1,233,"\n   "]],[233,233],[237,237]]],[1542545883400,["gjx16@GJXAIOU",[[-1,234,"   "]],[237,237],[234,234]]],[1542545884639,["gjx16@GJXAIOU",[[-1,233,"\n"]],[234,234],[233,233]]],[1542545886193,["gjx16@GJXAIOU",[[1,233,"\n   \n   "]],[233,233],[241,241]]],[1542545887552,["gjx16@GJXAIOU",[[-1,239,"  "]],[241,241],[239,239]]],[1542545888523,["gjx16@GJXAIOU",[[1,239,"- "]],[239,239],[241,241]]],[1542545894168,["gjx16@GJXAIOU",[[-1,238," "]],[239,239],[238,238]]],[1542545895781,["gjx16@GJXAIOU",[[-1,237,"\n"]],[238,238],[237,237]]],[1542545897174,["gjx16@GJXAIOU",[[1,237,"\n   "]],[237,237],[241,241]]],[1542545897559,["gjx16@GJXAIOU",[[-1,240," "]],[241,241],[240,240]]],[1542545898304,["gjx16@GJXAIOU",[[-1,238,"  "]],[240,240],[238,238]]],[1542545899044,["gjx16@GJXAIOU",[[-1,237,"\n"]],[238,238],[237,237]]],[1542545899977,["gjx16@GJXAIOU",[[1,237,"\n   "]],[237,237],[241,241]]],[1542545901076,["gjx16@GJXAIOU",[[-1,238,"   "]],[241,241],[238,238]]],[1542545904421,["gjx16@GJXAIOU",[[1,252,"- \n"]],[251,251],[254,254]]],[1542545938959,["gjx16@GJXAIOU",[[-1,252,"- "]],[252,254],[252,252]]],[1542545997078,["gjx16@GJXAIOU",[[1,252,"![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)"]],[252,252],[382,382]]],[1542546006918,["gjx16@GJXAIOU",[[-1,383,"**2****类和对象**"]],[383,396],[383,383]]],[1542546007391,["gjx16@GJXAIOU",[[1,385,"\n"]],[383,383],[384,384]]],[1542546007554,["gjx16@GJXAIOU",[[1,386,"\n"]],[384,384],[385,385]]],[1542546014883,["gjx16@GJXAIOU",[[1,385,"## 二、类和对象"]],[385,385],[394,394]]],[1542546021578,["gjx16@GJXAIOU",[[-1,396,"**2.1** **"]],[401,406],[396,396]]],[1542546024543,["gjx16@GJXAIOU",[[-1,400,"**"]],[402,402],[400,400]]],[1542546030471,["gjx16@GJXAIOU",[[1,396,"### （）"]],[396,396],[402,402]]],[1542546032470,["gjx16@GJXAIOU",[[1,401,"一"]],[401,401],[402,402]]],[1542546040829,["gjx16@GJXAIOU",[[1,409,"- "]],[409,409],[411,411]]],[1542546048793,["gjx16@GJXAIOU",[[1,428,"- "],[1,429,"- "],[1,440,"- "],[1,441,"- "],[1,450,"- "],[1,451,"- "],[-1,458,"\n "],[1,460,"- \n-"],[-1,478,"\n "],[1,480,"- \n-"],[-1,488,"\n "],[1,490,"- \n-"]],[409,528],[409,546]]],[1542546062031,["gjx16@GJXAIOU",[[1,473,"  "],[1,492,"  "],[1,495,"  "],[1,504,"  "],[1,507,"  "]],[475,546],[477,556]]],[1542546064515,["gjx16@GJXAIOU",[[-1,470,"- "]],[470,472],[470,470]]],[1542546066702,["gjx16@GJXAIOU",[[1,447,"  "]],[447,447],[449,449]]],[1542546068449,["gjx16@GJXAIOU",[[-1,444,"- "]],[444,446],[444,444]]],[1542546069754,["gjx16@GJXAIOU",[[-1,428,"- "]],[428,430],[428,428]]],[1542546070829,["gjx16@GJXAIOU",[[-1,428,"\n"]],[428,428],[427,427]]],[1542546071717,["gjx16@GJXAIOU",[[-1,441,"\n"]],[441,441],[440,440]]],[1542546073109,["gjx16@GJXAIOU",[[-1,454,"- "]],[456,456],[454,454]]],[1542546073568,["gjx16@GJXAIOU",[[-1,454,"\n"]],[454,454],[453,453]]],[1542546074445,["gjx16@GJXAIOU",[[-1,463,"\n"]],[463,463],[462,462]]],[1542546077533,["gjx16@GJXAIOU",[[-1,502,"- "]],[504,504],[502,502]]],[1542546078621,["gjx16@GJXAIOU",[[-1,484,"  - "]],[484,488],[484,484]]],[1542546079664,["gjx16@GJXAIOU",[[-1,496,"  "]],[498,498],[496,496]]],[1542546080109,["gjx16@GJXAIOU",[[-1,496,"\n"]],[496,496],[495,495]]],[1542546080733,["gjx16@GJXAIOU",[[-1,484,"\n"]],[484,484],[483,483]]],[1542546086102,["gjx16@GJXAIOU",[[-1,538,"**2.2****类的封装**"],[1,553,"\n"]],[538,553],[539,539]]],[1542546086305,["gjx16@GJXAIOU",[[1,541,"\n"]],[539,539],[540,540]]],[1542546089496,["gjx16@GJXAIOU",[[1,540,"### （）"]],[540,540],[546,546]]],[1542546091481,["gjx16@GJXAIOU",[[1,545,"二"]],[545,545],[546,546]]],[1542546097721,["gjx16@GJXAIOU",[[1,547,"类的封装"]],[547,547],[551,551]]],[1542546103913,["gjx16@GJXAIOU",[[-1,556,"****）"]],[556,561],[556,556]]],[1542546105015,["gjx16@GJXAIOU",[[1,556,"。"]],[556,556],[557,557]]],[1542546106601,["gjx16@GJXAIOU",[[-1,556,"。"]],[557,557],[556,556]]],[1542546106978,["gjx16@GJXAIOU",[[1,556,"."]],[556,556],[557,557]]],[1542546110624,["gjx16@GJXAIOU",[[-1,573,"****"]],[573,577],[573,573]]],[1542546115471,["gjx16@GJXAIOU",[[1,578,"- "]],[578,578],[580,580]]],[1542546117868,["gjx16@GJXAIOU",[[1,642,"- "]],[642,642],[644,644]]],[1542546123217,["gjx16@GJXAIOU",[[-1,705,"_"]],[706,706],[705,705]]],[1542546132266,["gjx16@GJXAIOU",[[-1,710,"__"]],[710,712],[710,710]]],[1542546134601,["gjx16@GJXAIOU",[[-1,724,"_ _"]],[724,727],[724,724]]],[1542546136374,["gjx16@GJXAIOU",[[-1,737,"_"]],[737,738],[737,737]]],[1542546144064,["gjx16@GJXAIOU",[[1,739,"- "]],[739,739],[741,741]]],[1542546147043,["gjx16@GJXAIOU",[[1,751,"  - "]],[751,751],[755,755]]],[1542546149196,["gjx16@GJXAIOU",[[1,776,"  - "]],[776,776],[780,780]]],[1542546151057,["gjx16@GJXAIOU",[[-1,775,"\n"]],[775,775],[774,774]]],[1542546151945,["gjx16@GJXAIOU",[[-1,750,"\n"]],[750,750],[749,749]]],[1542546174862,["gjx16@GJXAIOU",[[-1,641,"\n"]],[641,641],[640,640]]],[1542546190305,["gjx16@GJXAIOU",[[-1,801,"****）"]],[801,806],[801,801]]],[1542546194064,["gjx16@GJXAIOU",[[1,813,"- "]],[813,813],[815,815]]],[1542546200104,["gjx16@GJXAIOU",[[1,840,"  - "]],[840,840],[844,844]]],[1542546203574,["gjx16@GJXAIOU",[[1,878,"  - "]],[878,878],[882,882]]],[1542546205734,["gjx16@GJXAIOU",[[-1,877,"\n"]],[877,877],[876,876]]],[1542546207621,["gjx16@GJXAIOU",[[-1,839,"\n"]],[839,839],[838,838]]],[1542546211929,["gjx16@GJXAIOU",[[-1,910,"| \n\n"]],[909,913],[909,909]]],[1542546212510,["gjx16@GJXAIOU",[[-1,909,"\n"]],[909,909],[908,908]]],[1542546223729,["gjx16@GJXAIOU",[[1,909,"\n"]],[909,909],[910,910]]],[1542546230487,["gjx16@GJXAIOU",[[1,910,"* "],[1,935,"* "],[1,936,"* "],[1,948,"* "],[1,949,"* "],[1,968,"* "],[1,969,"* "],[1,986,"* "],[1,987,"* "]],[910,1008],[912,1026]]],[1542546233819,["gjx16@GJXAIOU",[[1,936," * * //类的内部，类的外部 * * //我们抽象了一个类，用类去定义对象 * * //类是一个数据类型，类是抽象的 * * //对象是一个具体的变量。。占用内存空间。//类是把属性和方法封装 同时对信息进行访问控制"]],[912,1026],[1022,1022]]],[1542546235418,["gjx16@GJXAIOU",[[-1,936," * * //类的内部，类的外部 * * //我们抽象了一个类，用类去定义对象 * * //类是一个数据类型，类是抽象的 * * //对象是一个具体的变量。。占用内存空间。//类是把属性和方法封装 同时对信息进行访问控制"]],[1022,1022],[912,1026]]],[1542546237513,["gjx16@GJXAIOU",[[-1,937,"* "]],[937,939],[937,937]]],[1542546238064,["gjx16@GJXAIOU",[[-1,937,"\n"]],[937,937],[936,936]]],[1542546239246,["gjx16@GJXAIOU",[[-1,951,"* "]],[953,953],[951,951]]],[1542546239934,["gjx16@GJXAIOU",[[-1,951,"\n"]],[951,951],[950,950]]],[1542546241086,["gjx16@GJXAIOU",[[-1,972,"* "]],[974,974],[972,972]]],[1542546241727,["gjx16@GJXAIOU",[[-1,972,"\n"]],[972,972],[971,971]]],[1542546242826,["gjx16@GJXAIOU",[[-1,991,"* "]],[991,993],[991,991]]],[1542546243149,["gjx16@GJXAIOU",[[-1,991,"\n"]],[991,991],[990,990]]],[1542546248202,["gjx16@GJXAIOU",[[1,1015,"·"]],[1015,1015],[1016,1016]]],[1542546249014,["gjx16@GJXAIOU",[[-1,1015,"·"]],[1016,1016],[1015,1015]]],[1542546250047,["gjx16@GJXAIOU",[[1,1015,"```"]],[1015,1015],[1018,1018]]],[1542546250077,["gjx16@GJXAIOU",[[1,1018,"language\n```\n"]],[1018,1018],[1018,1026]]],[1542546251122,["gjx16@GJXAIOU",[[-1,1018,"language"],[1,1026,"c"]],[1018,1026],[1019,1019]]],[1542546251473,["gjx16@GJXAIOU",[[1,1019,"pp"]],[1019,1019],[1021,1021]]],[1542546252455,["gjx16@GJXAIOU",[[1,1022,"\n"]],[1021,1021],[1022,1022]]],[1542546260127,["gjx16@GJXAIOU",[[-1,1028,"class Circle\n\n{\n\npublic:\n\n double r;\n\n double s;\n\npublic:\n\n double getR()\n\n {\n\n a++;\n\n return r;\n\n }\n\n void setR(double val)\n\n {\n\n r = val;\n\n }\n\npublic:\n\n double getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\n {\n\n s = 3.14f*r*r;\n\n return s;\n\n }\n\n//private:\n\n int a;\n\n};"]],[1028,1286],[1028,1028]]],[1542546309886,["gjx16@GJXAIOU",[[1,1023,"class Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n"]],[1022,1022],[1271,1271]]],[1542546315119,["gjx16@GJXAIOU",[[-1,1279," |\n\n"]],[1277,1281],[1277,1277]]],[1542546331229,["gjx16@GJXAIOU",[[-1,1282,"****）****"]],[1282,1291],[1282,1282]]],[1542546333914,["gjx16@GJXAIOU",[[1,1282,"."]],[1282,1282],[1283,1283]]],[1542546336173,["gjx16@GJXAIOU",[[-1,1289,"****"]],[1289,1293],[1289,1289]]],[1542546338045,["gjx16@GJXAIOU",[[-1,1295,"****"]],[1295,1299],[1295,1295]]],[1542546347062,["gjx16@GJXAIOU",[[1,1304,"- "]],[1304,1304],[1306,1306]]],[1542546349685,["gjx16@GJXAIOU",[[-1,1336,"\n"]],[1336,1336],[1335,1335]]],[1542546353935,["gjx16@GJXAIOU",[[1,1336,"- "]],[1336,1336],[1338,1338]]],[1542546355960,["gjx16@GJXAIOU",[[-1,1303,"\n"]],[1303,1303],[1302,1302]]],[1542546369529,["gjx16@GJXAIOU",[[-1,1368,"**2.3 "],[1,1374,"#"]],[1368,1374],[1369,1369]]],[1542546369879,["gjx16@GJXAIOU",[[1,1369,"##"]],[1369,1369],[1371,1371]]],[1542546371663,["gjx16@GJXAIOU",[[-1,1370,"#"]],[1371,1371],[1370,1370]]],[1542546373558,["gjx16@GJXAIOU",[[1,1370," san"]],[1370,1370],[1374,1374]]],[1542546375309,["gjx16@GJXAIOU",[[-1,1371,"san"]],[1374,1374],[1371,1371]]],[1542546377153,["gjx16@GJXAIOU",[[1,1371,"三"]],[1371,1371],[1372,1372]]],[1542546378265,["gjx16@GJXAIOU",[[1,1372,"、"]],[1372,1372],[1373,1373]]],[1542546403898,["gjx16@GJXAIOU",[[1,1370,"#"]],[1370,1370],[1371,1371]]],[1542546407882,["gjx16@GJXAIOU",[[-1,1372,"三、"],[1,1374,"（"]],[1372,1372],[1373,1373]]],[1542546407970,["gjx16@GJXAIOU",[[1,1373,"）"]],[1373,1373],[1374,1374]]],[1542546410625,["gjx16@GJXAIOU",[[1,1373,"三"]],[1373,1373],[1374,1374]]],[1542546414853,["gjx16@GJXAIOU",[[-1,1378,"****"]],[1378,1382],[1378,1378]]],[1542546416845,["gjx16@GJXAIOU",[[-1,1388,"**"]],[1388,1390],[1388,1388]]],[1542546421288,["gjx16@GJXAIOU",[[-1,1411,"\n"]],[1411,1411],[1410,1410]]],[1542546426697,["gjx16@GJXAIOU",[[-1,1477,"\n"]],[1477,1477],[1476,1476]]],[1542546429543,["gjx16@GJXAIOU",[[1,1479,"      "]],[1479,1479],[1485,1485]]],[1542546431335,["gjx16@GJXAIOU",[[-1,1557,"\n"]],[1557,1557],[1556,1556]]],[1542546457078,["gjx16@GJXAIOU",[[1,1602,"\n"]],[1601,1601],[1602,1602]]],[1542546480635,["gjx16@GJXAIOU",[[1,1602,"![案例示意图‘’]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)"]],[1602,1602],[1692,1692]]],[1542546484686,["gjx16@GJXAIOU",[[-1,1609,"‘’"]],[1611,1611],[1609,1609]]],[1542546487666,["gjx16@GJXAIOU",[[1,1690,"\n"]],[1689,1689],[1690,1690]]],[1542546487858,["gjx16@GJXAIOU",[[1,1691,"\n"]],[1690,1690],[1691,1691]]],[1542546497029,["gjx16@GJXAIOU",[[-1,1692,"**2.4** **"]],[1702,1702],[1692,1692]]],[1542546500181,["gjx16@GJXAIOU",[[1,1692,"### （）"]],[1692,1692],[1698,1698]]],[1542546502385,["gjx16@GJXAIOU",[[1,1697,"四"]],[1697,1697],[1698,1698]]],[1542546504481,["gjx16@GJXAIOU",[[-1,1701,"**"]],[1703,1703],[1701,1701]]],[1542546515686,["gjx16@GJXAIOU",[[-1,1761,"\n"]],[1761,1761],[1760,1760]]],[1542546516949,["gjx16@GJXAIOU",[[-1,1783,"\n"]],[1783,1783],[1782,1782]]]],null,"gjx16@GJXAIOU"],["40e22adb-a57e-4b27-aa84-82d00561ebd5",1542611558859,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁\n   * c++面向对象模型初探  \n   * c++面向对象多态原理探究\n   * 操作符重载\n\n- C++基础课程学习完毕以后，有没有一个标准，来判断自己有没有入门。\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（把属性和方法进行封装对属性和方法进行访问控制）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n案例1 设计立方体类(cube)，求出立方体的面积和体积\n        求两个立方体，是否相等（全局函数和成员函数）\n\n案例2 设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n  即：求点和圆的关系（圆内和圆外）\n\n案例3 对于第二个案例，类的声明和类的实现分开\n\n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n",[[1542611539324,["gjx16@GJXAIOU",[[1,797,"  - \n"]],[796,796],[801,801]]],[1542611540857,["gjx16@GJXAIOU",[[-1,799,"- "]],[801,801],[799,799]]],[1542611541628,["gjx16@GJXAIOU",[[-1,797,"  "],[1,799,"\n"]],[799,799],[798,798]]],[1542611546881,["gjx16@GJXAIOU",[[1,798,"****"]],[798,798],[800,800]]],[1542611557547,["gjx16@GJXAIOU",[[1,800,"类的封装的第一层含义："]],[800,800],[811,811]]],[1542611559925,["gjx16@GJXAIOU",[[1,815,"\n"]],[813,813],[814,814]]],[1542611562174,["gjx16@GJXAIOU",[[1,814,"~··"]],[814,814],[817,817]]],[1542611563282,["gjx16@GJXAIOU",[[-1,814,"~··"]],[817,817],[814,814]]],[1542611566057,["gjx16@GJXAIOU",[[1,814,"```cpp"]],[814,814],[820,820]]],[1542611566569,["gjx16@GJXAIOU",[[1,822,"\n"]],[820,820],[821,821]]],[1542611567001,["gjx16@GJXAIOU",[[1,823,"\n"]],[821,821],[822,822]]],[1542611567174,["gjx16@GJXAIOU",[[1,824,"\n"]],[822,822],[823,823]]],[1542611567369,["gjx16@GJXAIOU",[[1,825,"\n"]],[823,823],[824,824]]],[1542611568058,["gjx16@GJXAIOU",[[1,824,"```"]],[824,824],[827,827]]],[1542611570146,["gjx16@GJXAIOU",[[1,822,"/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle pc)\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n"]],[821,821],[1600,1600]]],[1542611576436,["gjx16@GJXAIOU",[[-1,1602,"\n"]],[1602,1602],[1601,1601]]],[1542611576551,["gjx16@GJXAIOU",[[-1,1601,"\n"]],[1601,1601],[1600,1600]]],[1542611579220,["gjx16@GJXAIOU",[[1,1606,"\n"]],[1605,1605],[1606,1606]]],[1542611579325,["gjx16@GJXAIOU",[[1,1607,"\n"]],[1606,1606],[1607,1607]]],[1542611582601,["gjx16@GJXAIOU",[[1,1607,"```cpp"]],[1607,1607],[1613,1613]]],[1542611582938,["gjx16@GJXAIOU",[[1,1614,"\n"]],[1613,1613],[1614,1614]]],[1542611583092,["gjx16@GJXAIOU",[[1,1615,"\n"]],[1614,1614],[1615,1615]]],[1542611583226,["gjx16@GJXAIOU",[[1,1616,"\n"]],[1615,1615],[1616,1616]]],[1542611583356,["gjx16@GJXAIOU",[[1,1617,"\n"]],[1616,1616],[1617,1617]]],[1542611584161,["gjx16@GJXAIOU",[[1,1617,"```"]],[1617,1617],[1620,1620]]],[1542611589912,["gjx16@GJXAIOU",[[1,1606,"****"]],[1606,1606],[1608,1608]]],[1542611590819,["gjx16@GJXAIOU",[[1,1608,"lei"]],[1608,1608],[1611,1611]]],[1542611591368,["gjx16@GJXAIOU",[[-1,1608,"lei"]],[1611,1611],[1608,1608]]],[1542611594884,["gjx16@GJXAIOU",[[1,1608,"类的访问"]],[1608,1608],[1612,1612]]],[1542611599799,["gjx16@GJXAIOU",[[-1,1610,"访问"]],[1612,1612],[1610,1610]]],[1542611607283,["gjx16@GJXAIOU",[[1,1610,"封装的第二程"]],[1610,1610],[1616,1616]]],[1542611607906,["gjx16@GJXAIOU",[[-1,1615,"程"]],[1616,1616],[1615,1615]]],[1542611611291,["gjx16@GJXAIOU",[[1,1615,"心狠"]],[1615,1615],[1617,1617]]],[1542611611911,["gjx16@GJXAIOU",[[-1,1615,"心狠"]],[1617,1617],[1615,1615]]],[1542611615148,["gjx16@GJXAIOU",[[1,1615,"层含义："]],[1615,1615],[1619,1619]]],[1542611621779,["gjx16@GJXAIOU",[[1,1636,"\n"]],[1635,1635],[1636,1636]]],[1542611621906,["gjx16@GJXAIOU",[[1,1637,"\n"]],[1636,1636],[1637,1637]]],[1542611622033,["gjx16@GJXAIOU",[[1,1638,"\n"]],[1637,1637],[1638,1638]]],[1542611622148,["gjx16@GJXAIOU",[[1,1639,"\n"]],[1638,1638],[1639,1639]]],[1542611802234,["gjx16@GJXAIOU",[[1,1606,"\n"]],[1604,1604],[1605,1605]]],[1542611807491,["gjx16@GJXAIOU",[[1,1605,"程序运行结果："]],[1605,1605],[1612,1612]]],[1542611807846,["gjx16@GJXAIOU",[[1,1614,"\n"]],[1612,1612],[1613,1613]]],[1542611808731,["gjx16@GJXAIOU",[[1,1613,"c1 s: 314\nr11\ns379.94\nr20\ns1256\nr20\ns1256"]],[1613,1613],[1654,1654]]],[1542611811865,["gjx16@GJXAIOU",[[1,1613,"`"]],[1613,1613],[1614,1614]]],[1542611813550,["gjx16@GJXAIOU",[[1,1624,"`"]],[1624,1624],[1625,1625]]],[1542611814192,["gjx16@GJXAIOU",[[1,1629,"`"]],[1629,1629],[1630,1630]]],[1542611814826,["gjx16@GJXAIOU",[[1,1638,"`"]],[1638,1638],[1639,1639]]],[1542611815377,["gjx16@GJXAIOU",[[1,1643,"`"]],[1643,1643],[1644,1644]]],[1542611815960,["gjx16@GJXAIOU",[[1,1650,"`"]],[1650,1650],[1651,1651]]],[1542611816514,["gjx16@GJXAIOU",[[1,1655,"`"]],[1655,1655],[1656,1656]]],[1542611818312,["gjx16@GJXAIOU",[[1,1654,"`"]],[1654,1654],[1655,1655]]],[1542611819537,["gjx16@GJXAIOU",[[1,1662,"`"]],[1662,1662],[1663,1663]]],[1542611820376,["gjx16@GJXAIOU",[[1,1649,"`"]],[1649,1649],[1650,1650]]],[1542611820766,["gjx16@GJXAIOU",[[1,1642,"`"]],[1642,1642],[1643,1643]]],[1542611821517,["gjx16@GJXAIOU",[[1,1634,"`"]],[1634,1634],[1635,1635]]],[1542611823583,["gjx16@GJXAIOU",[[-1,1634,"`"]],[1635,1635],[1634,1634]]],[1542611825033,["gjx16@GJXAIOU",[[1,1628,"`"]],[1628,1628],[1629,1629]]],[1542611826768,["gjx16@GJXAIOU",[[1,1638,"`"]],[1638,1638],[1639,1639]]],[1542611827706,["gjx16@GJXAIOU",[[1,1623,"`"]],[1623,1623],[1624,1624]]],[1542612571466,["gjx16@GJXAIOU",[[1,1693,"/封装的第二层含义：\n//对属性和方法进行访问控制\n//public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n//private:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问\n//protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\n\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n"]],[1693,1693],[2208,2208]]],[1542612576786,["gjx16@GJXAIOU",[[-1,2210,"\n"]],[2210,2210],[2209,2209]]],[1542612576922,["gjx16@GJXAIOU",[[-1,2209,"\n"]],[2209,2209],[2208,2208]]],[1542612577341,["gjx16@GJXAIOU",[[-1,2208,"\n"]],[2208,2208],[2207,2207]]],[1542613356749,["gjx16@GJXAIOU",[[1,2786,"\n"]],[2785,2785],[2786,2786]]],[1542613356903,["gjx16@GJXAIOU",[[1,2787,"\n"]],[2786,2786],[2787,2787]]],[1542613357036,["gjx16@GJXAIOU",[[1,2788,"\n"]],[2787,2787],[2788,2788]]],[1542613357132,["gjx16@GJXAIOU",[[1,2789,"\n"]],[2788,2788],[2789,2789]]],[1542613357267,["gjx16@GJXAIOU",[[1,2790,"\n"]],[2789,2789],[2790,2790]]],[1542613357388,["gjx16@GJXAIOU",[[1,2791,"\n"]],[2790,2790],[2791,2791]]],[1542613357508,["gjx16@GJXAIOU",[[1,2792,"\n"]],[2791,2791],[2792,2792]]],[1542613358007,["gjx16@GJXAIOU",[[1,2793,"\n"]],[2792,2792],[2793,2793]]],[1542613358057,["gjx16@GJXAIOU",[[1,2794,"\n"]],[2793,2793],[2794,2794]]],[1542613358113,["gjx16@GJXAIOU",[[1,2795,"\n"]],[2794,2794],[2795,2795]]],[1542613358216,["gjx16@GJXAIOU",[[1,2796,"\n"]],[2795,2795],[2796,2796]]],[1542613358359,["gjx16@GJXAIOU",[[1,2797,"\n"]],[2796,2796],[2797,2797]]],[1542613358523,["gjx16@GJXAIOU",[[1,2798,"\n"]],[2797,2797],[2798,2798]]],[1542613358616,["gjx16@GJXAIOU",[[1,2799,"\n"]],[2798,2798],[2799,2799]]],[1542613358739,["gjx16@GJXAIOU",[[1,2800,"\n"]],[2799,2799],[2800,2800]]],[1542613358876,["gjx16@GJXAIOU",[[1,2801,"\n"]],[2800,2800],[2801,2801]]],[1542613359001,["gjx16@GJXAIOU",[[1,2802,"\n"]],[2801,2801],[2802,2802]]],[1542613359153,["gjx16@GJXAIOU",[[1,2803,"\n"]],[2802,2802],[2803,2803]]],[1542613359365,["gjx16@GJXAIOU",[[1,2804,"\n"]],[2803,2803],[2804,2804]]],[1542613359549,["gjx16@GJXAIOU",[[1,2805,"\n"]],[2804,2804],[2805,2805]]],[1542613359679,["gjx16@GJXAIOU",[[1,2806,"\n"]],[2805,2805],[2806,2806]]],[1542613359831,["gjx16@GJXAIOU",[[1,2807,"\n"]],[2806,2806],[2807,2807]]],[1542613360111,["gjx16@GJXAIOU",[[1,2808,"\n"]],[2807,2807],[2808,2808]]],[1542613366286,["gjx16@GJXAIOU",[[1,2787,"#"]],[2787,2787],[2788,2788]]],[1542613366811,["gjx16@GJXAIOU",[[-1,2787,"#"]],[2788,2788],[2787,2787]]],[1542613368066,["gjx16@GJXAIOU",[[1,2787,"****"]],[2787,2787],[2789,2789]]],[1542613370854,["gjx16@GJXAIOU",[[1,2789,"4.lei"]],[2789,2789],[2794,2794]]],[1542613371685,["gjx16@GJXAIOU",[[-1,2791,"lei"]],[2794,2794],[2791,2791]]],[1542613374531,["gjx16@GJXAIOU",[[1,2791,"类的"]],[2791,2791],[2793,2793]]],[1542613376627,["gjx16@GJXAIOU",[[-1,2792,"的"]],[2793,2793],[2792,2792]]],[1542613378486,["gjx16@GJXAIOU",[[1,2792,"得"]],[2792,2792],[2793,2793]]],[1542613380044,["gjx16@GJXAIOU",[[-1,2792,"得"]],[2793,2793],[2792,2792]]],[1542613388113,["gjx16@GJXAIOU",[[1,2792,"的声明和类的实现分开"]],[2792,2792],[2802,2802]]],[1542613390528,["gjx16@GJXAIOU",[[1,2826,"\n"]],[2804,2804],[2805,2805]]],[1542613401128,["gjx16@GJXAIOU",[[1,2805,"首先在“项目”右击，"]],[2805,2805],[2815,2815]]],[1542613470909,["gjx16@GJXAIOU",[[1,2811,"名称"]],[2811,2811],[2813,2813]]],[1542613479637,["gjx16@GJXAIOU",[[1,2817,"选择添加"]],[2817,2817],[2821,2821]]],[1542613480984,["gjx16@GJXAIOU",[[-1,2819,"添加"]],[2821,2821],[2819,2819]]],[1542613491352,["gjx16@GJXAIOU",[[1,2819,"“添加”，然后选择“"]],[2819,2819],[2829,2829]]],[1542613495394,["gjx16@GJXAIOU",[[1,2829,"类”，"]],[2829,2829],[2832,2832]]],[1542613500142,["gjx16@GJXAIOU",[[1,2854,"\n"]],[2832,2832],[2833,2833]]],[1542613512146,["gjx16@GJXAIOU",[[1,2833,"![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)"]],[2833,2833],[2885,2885]]],[1542613516704,["gjx16@GJXAIOU",[[1,2906,"\n"]],[2885,2885],[2886,2886]]],[1542613552693,["gjx16@GJXAIOU",[[1,2886,"在新的弹出窗口内"]],[2886,2886],[2894,2894]]],[1542613571021,["gjx16@GJXAIOU",[[1,2894,"填写类名之后，系统会自动生成两个文件"]],[2894,2894],[2912,2912]]],[1542613571975,["gjx16@GJXAIOU",[[1,2933,"\n"]],[2912,2912],[2913,2913]]],[1542613607676,["gjx16@GJXAIOU",[[1,2913,"![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)"]],[2913,2913],[2963,2963]]],[1542613609497,["gjx16@GJXAIOU",[[1,2983,"\n"]],[2963,2963],[2964,2964]]],[1542614523024,["gjx16@GJXAIOU",[[1,2964,"Teacher.h"]],[2964,2964],[2973,2973]]],[1542614525159,["gjx16@GJXAIOU",[[1,2993,"\n"]],[2973,2973],[2974,2974]]],[1542614527352,["gjx16@GJXAIOU",[[1,2974,"```"]],[2974,2974],[2977,2977]]],[1542614527389,["gjx16@GJXAIOU",[[1,2977,"language\n```\n"]],[2977,2977],[2977,2985]]],[1542614528326,["gjx16@GJXAIOU",[[-1,2977,"language"],[1,2985,"c"]],[2977,2985],[2978,2978]]],[1542614529130,["gjx16@GJXAIOU",[[1,2978,"pp"]],[2978,2978],[2980,2980]]],[1542614531199,["gjx16@GJXAIOU",[[-1,2977,"cpp"]],[2980,2980],[2977,2977]]],[1542614531995,["gjx16@GJXAIOU",[[1,2977,"h"]],[2977,2977],[2978,2978]]],[1542614532763,["gjx16@GJXAIOU",[[1,2979,"\n"]],[2978,2978],[2979,2979]]],[1542614546874,["gjx16@GJXAIOU",[[1,2979,"#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n\t\n};\n"]],[2979,2979],[3113,3113]]],[1542614549878,["gjx16@GJXAIOU",[[1,3138,"\n"]],[3117,3117],[3118,3118]]],[1542614554368,["gjx16@GJXAIOU",[[1,3118,"Teachee"]],[3118,3118],[3125,3125]]],[1542614554990,["gjx16@GJXAIOU",[[-1,3124,"e"]],[3125,3125],[3124,3124]]],[1542614558072,["gjx16@GJXAIOU",[[1,3124,"r.cpp"]],[3124,3124],[3129,3129]]],[1542614558638,["gjx16@GJXAIOU",[[1,3150,"\n"]],[3129,3129],[3130,3130]]],[1542614560136,["gjx16@GJXAIOU",[[1,3130,"```"]],[3130,3130],[3133,3133]]],[1542614560173,["gjx16@GJXAIOU",[[1,3133,"language\n```\n"]],[3133,3133],[3133,3141]]],[1542614561035,["gjx16@GJXAIOU",[[-1,3133,"language"],[1,3141,"c"]],[3133,3141],[3134,3134]]],[1542614561363,["gjx16@GJXAIOU",[[1,3134,"pp"]],[3134,3134],[3136,3136]]],[1542614561782,["gjx16@GJXAIOU",[[1,3137,"\n"]],[3136,3136],[3137,3137]]],[1542614574546,["gjx16@GJXAIOU",[[1,3137,"#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}"]],[3137,3137],[3285,3285]]],[1542614645875,["gjx16@GJXAIOU",[[1,3311,"\n"]],[3289,3289],[3290,3290]]],[1542614649243,["gjx16@GJXAIOU",[[1,3290,"···"]],[3290,3290],[3293,3293]]],[1542614649998,["gjx16@GJXAIOU",[[-1,3290,"···"]],[3293,3293],[3290,3290]]],[1542614651338,["gjx16@GJXAIOU",[[1,3290,"```"]],[3290,3290],[3293,3293]]],[1542614651381,["gjx16@GJXAIOU",[[1,3293,"language\n```\n"]],[3293,3293],[3293,3301]]],[1542614653348,["gjx16@GJXAIOU",[[-1,3293,"language"],[1,3301,"c"]],[3293,3301],[3294,3294]]],[1542614653645,["gjx16@GJXAIOU",[[1,3294,"pp"]],[3294,3294],[3296,3296]]],[1542614654515,["gjx16@GJXAIOU",[[1,3297,"\n"]],[3296,3296],[3297,3297]]],[1542614655473,["gjx16@GJXAIOU",[[1,3297,"/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}"]],[3297,3297],[3523,3523]]],[1542614657202,["gjx16@GJXAIOU",[[1,3290,"\n"]],[3289,3289],[3290,3290]]],[1542614660069,["gjx16@GJXAIOU",[[1,3290,"zai"]],[3290,3290],[3293,3293]]],[1542614660730,["gjx16@GJXAIOU",[[-1,3290,"zai"]],[3293,3293],[3290,3290]]],[1542614665240,["gjx16@GJXAIOU",[[1,3290,"在奇谈"]],[3290,3290],[3293,3293]]],[1542614666399,["gjx16@GJXAIOU",[[-1,3291,"奇谈"]],[3293,3293],[3291,3291]]],[1542614669314,["gjx16@GJXAIOU",[[1,3291,"其他哈数"]],[3291,3291],[3295,3295]]],[1542614669923,["gjx16@GJXAIOU",[[-1,3293,"哈数"]],[3295,3295],[3293,3293]]],[1542614679768,["gjx16@GJXAIOU",[[1,3293,"函数中使用该类；"]],[3293,3293],[3301,3301]]],[1542614680327,["gjx16@GJXAIOU",[[-1,3300,"；"]],[3301,3301],[3300,3300]]],[1542614680768,["gjx16@GJXAIOU",[[1,3300,"；"]],[3300,3300],[3301,3301]]],[1542614683083,["gjx16@GJXAIOU",[[-1,3300,"；"]],[3301,3301],[3300,3300]]],[1542614683477,["gjx16@GJXAIOU",[[1,3300,"："]],[3300,3300],[3301,3301]]],[1542614686848,["gjx16@GJXAIOU",[[1,3290,"\n"]],[3290,3290],[3291,3291]]],[1542614692009,["gjx16@GJXAIOU",[[1,3563,"\n"]],[3540,3540],[3541,3541]]],[1542614700733,["gjx16@GJXAIOU",[[1,3541,"程序运行结果：``"]],[3541,3541],[3550,3550]]],[1542614705814,["gjx16@GJXAIOU",[[1,3549,"ans = 234"]],[3549,3549],[3558,3558]]],[1542614715263,["gjx16@GJXAIOU",[[-1,3581,"\n"]],[3580,3580],[3579,3579]]],[1542614715391,["gjx16@GJXAIOU",[[-1,3580,"\n"]],[3579,3579],[3578,3578]]],[1542614715521,["gjx16@GJXAIOU",[[-1,3579,"\n"]],[3578,3578],[3577,3577]]],[1542614715642,["gjx16@GJXAIOU",[[-1,3578,"\n"]],[3577,3577],[3576,3576]]],[1542614715767,["gjx16@GJXAIOU",[[-1,3577,"\n"]],[3576,3576],[3575,3575]]],[1542614715904,["gjx16@GJXAIOU",[[-1,3576,"\n"]],[3575,3575],[3574,3574]]],[1542614716023,["gjx16@GJXAIOU",[[-1,3575,"\n"]],[3574,3574],[3573,3573]]],[1542614716153,["gjx16@GJXAIOU",[[-1,3574,"\n"]],[3573,3573],[3572,3572]]],[1542614716300,["gjx16@GJXAIOU",[[-1,3573,"\n"]],[3572,3572],[3571,3571]]],[1542614716423,["gjx16@GJXAIOU",[[-1,3572,"\n"]],[3571,3571],[3570,3570]]],[1542614716680,["gjx16@GJXAIOU",[[-1,3571,"\n"]],[3570,3570],[3569,3569]]],[1542614716831,["gjx16@GJXAIOU",[[-1,3570,"\n"]],[3569,3569],[3568,3568]]],[1542614717016,["gjx16@GJXAIOU",[[-1,3569,"\n"]],[3568,3568],[3567,3567]]],[1542614719367,["gjx16@GJXAIOU",[[-1,3568,"\n"]],[3567,3567],[3566,3566]]],[1542614719496,["gjx16@GJXAIOU",[[-1,3567,"\n"]],[3566,3566],[3565,3565]]],[1542614719602,["gjx16@GJXAIOU",[[-1,3566,"\n"]],[3565,3565],[3564,3564]]],[1542614719732,["gjx16@GJXAIOU",[[-1,3565,"\n"]],[3564,3564],[3563,3563]]],[1542614719859,["gjx16@GJXAIOU",[[-1,3564,"\n"]],[3563,3563],[3562,3562]]],[1542617783765,["gjx16@GJXAIOU",[[1,3673,"\n"]],[3672,3672],[3673,3673]]],[1542617786473,["gjx16@GJXAIOU",[[1,3673,"```"]],[3673,3673],[3676,3676]]],[1542617786515,["gjx16@GJXAIOU",[[1,3676,"language\n```\n"]],[3676,3676],[3676,3684]]],[1542617787432,["gjx16@GJXAIOU",[[-1,3676,"language"],[1,3684,"c"]],[3676,3684],[3677,3677]]],[1542617787729,["gjx16@GJXAIOU",[[1,3677,"p"]],[3677,3677],[3678,3678]]],[1542617788238,["gjx16@GJXAIOU",[[1,3679,"\n"]],[3678,3678],[3679,3679]]],[1542617789326,["gjx16@GJXAIOU",[[-1,3679,"\n"]],[3679,3679],[3678,3678]]],[1542617789454,["gjx16@GJXAIOU",[[-1,3677,"p"]],[3678,3678],[3677,3677]]],[1542617790761,["gjx16@GJXAIOU",[[1,3677,"pp"]],[3677,3677],[3679,3679]]],[1542617791201,["gjx16@GJXAIOU",[[1,3680,"\n"]],[3679,3679],[3680,3680]]],[1542617792747,["gjx16@GJXAIOU",[[1,3681,"/*\n\n使用面向对象的思想进行编程练习\n\n*/\n\n\n\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n"]],[3680,3680],[4270,4270]]],[1542617798138,["gjx16@GJXAIOU",[[-1,3684,"\n使用面向对象的思想进行编程练习\n\n*/\n\n\n\n/*\n"]],[3680,3707],[3680,3680]]],[1542617798264,["gjx16@GJXAIOU",[[-1,3680,"\n"]],[3680,3680],[3679,3679]]],[1542617802759,["gjx16@GJXAIOU",[[1,4248,"\n"]],[4246,4246],[4247,4247]]],[1542617804203,["gjx16@GJXAIOU",[[1,4247,"cheng"]],[4247,4247],[4252,4252]]],[1542617804975,["gjx16@GJXAIOU",[[-1,4247,"cheng"]],[4252,4252],[4247,4247]]],[1542617812021,["gjx16@GJXAIOU",[[1,4247,"程序运行"]],[4247,4247],[4251,4251]]],[1542617813191,["gjx16@GJXAIOU",[[1,4253,"；"]],[4253,4253],[4254,4254]]],[1542617814150,["gjx16@GJXAIOU",[[-1,4253,"；"]],[4254,4254],[4253,4253]]],[1542617814686,["gjx16@GJXAIOU",[[1,4253,"："]],[4253,4253],[4254,4254]]],[1542617815314,["gjx16@GJXAIOU",[[1,4256,"\n"]],[4254,4254],[4255,4255]]],[1542617822294,["gjx16@GJXAIOU",[[1,4255,"s = 22\nv = 6"]],[4255,4255],[4267,4267]]],[1542617824163,["gjx16@GJXAIOU",[[1,4255,"·"]],[4255,4255],[4256,4256]]],[1542617825470,["gjx16@GJXAIOU",[[-1,4255,"·"]],[4256,4256],[4255,4255]]],[1542617825923,["gjx16@GJXAIOU",[[1,4255,"`"]],[4255,4255],[4256,4256]]],[1542617827536,["gjx16@GJXAIOU",[[1,4263,"`"]],[4263,4263],[4264,4264]]],[1542617829056,["gjx16@GJXAIOU",[[1,4269,"`"]],[4269,4269],[4270,4270]]],[1542617829960,["gjx16@GJXAIOU",[[1,4262,"`"]],[4262,4262],[4263,4263]]],[1542617834286,["gjx16@GJXAIOU",[[-1,4274,"       "]],[4281,4281],[4274,4274]]],[1542617847555,["gjx16@GJXAIOU",[[1,3644,"-                           "]],[3644,3644],[3672,3672]]],[1542617853145,["gjx16@GJXAIOU",[[-1,3645,"                           "]],[3672,3672],[3645,3645]]],[1542617855769,["gjx16@GJXAIOU",[[1,3645," "]],[3645,3645],[3646,3646]]],[1542617859724,["gjx16@GJXAIOU",[[1,4276,"- "]],[4276,4276],[4278,4278]]],[1542619372948,[null,[[-1,4253,"\n\n： "],[1,4257,"结果：\n"],[-1,4273," "],[1,4274,"\n"],[1,4278,"求两"]],[4253,4253],[4280,4280]]],[1542619372948,[null,[[1,4253,"\n\n： "],[-1,4253,"结果：\n"],[1,4273," "],[-1,4273,"\n"],[-1,4278,"求两"]],[4280,4280],[4253,4253]]],[1542619327868,["gjx16@GJXAIOU",[[1,4301,"```"]],[4301,4301],[4304,4304]]],[1542619327920,["gjx16@GJXAIOU",[[1,4304,"language\n```\n"]],[4304,4304],[4304,4312]]],[1542619328798,["gjx16@GJXAIOU",[[-1,4304,"language"],[1,4312,"c"]],[4304,4312],[4305,4305]]],[1542619329332,["gjx16@GJXAIOU",[[1,4305,"pp"]],[4305,4305],[4307,4307]]],[1542619330235,["gjx16@GJXAIOU",[[1,4308,"\n"]],[4307,4307],[4308,4308]]],[1542619330889,["gjx16@GJXAIOU",[[1,4309,"/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n"]],[4308,4308],[5270,5270]]],[1542619340130,["gjx16@GJXAIOU",[[1,5276,"\n"]],[5274,5274],[5275,5275]]],[1542619341542,["gjx16@GJXAIOU",[[1,5275,"chegnxu"]],[5275,5275],[5282,5282]]],[1542619342795,["gjx16@GJXAIOU",[[-1,5275,"chegnxu"]],[5282,5282],[5275,5275]]],[1542619351410,["gjx16@GJXAIOU",[[1,5275,"程序运行结果："]],[5275,5275],[5282,5282]]],[1542619351907,["gjx16@GJXAIOU",[[1,5284,"\n"]],[5282,5282],[5283,5283]]],[1542619369826,["gjx16@GJXAIOU",[[1,5283,"buxiangdeng"]],[5283,5283],[5294,5294]]],[1542619372293,["gjx16@GJXAIOU",[[1,5283,"`"]],[5283,5283],[5284,5284]]],[1542619432968,[null,[[-1,4253,"\n\n： "],[1,4257,"结果：\n"],[-1,4273," "],[1,4274,"\n"],[1,4278,"求两"],[-1,4299,"\n案"],[-1,5282,"例"],[1,5283,"\n"],[1,5297,"案例"]],[4253,4253],[5299,5299]]],[1542619432968,[null,[[1,4253,"\n\n： "],[-1,4253,"结果：\n"],[1,4273," "],[-1,4273,"\n"],[-1,4278,"求两"],[1,4301,"\n案"],[1,5282,"例"],[-1,5282,"\n"],[-1,5297,"案例"]],[5299,5299],[4253,4253]]],[1542619373732,["gjx16@GJXAIOU",[[-1,5283,"`"]],[5284,5284],[5283,5283]]],[1542619374349,["gjx16@GJXAIOU",[[1,5283,"`"]],[5283,5283],[5284,5284]]],[1542619377000,["gjx16@GJXAIOU",[[1,5295,"`"]],[5295,5295],[5296,5296]]],[1542619552951,[null,[[-1,4253,"\n\n： "],[1,4257,"结果：\n"],[-1,4273," "],[1,4274,"\n"],[1,4278,"求两"],[-1,4299,"\n案"],[-1,5282,"例"],[1,5283,"\n"],[1,5298,"案例"]],[4253,4253],[5300,5300]]],[1542619552951,[null,[[1,4253,"\n\n： "],[-1,4253,"结果：\n"],[1,4273," "],[-1,4273,"\n"],[-1,4278,"求两"],[1,4301,"\n案"],[1,5282,"例"],[-1,5282,"\n"],[-1,5298,"案例"]],[5300,5300],[4253,4253]]],[1542619526770,["gjx16@GJXAIOU",[[1,4301," - \n"]],[4300,4300],[4304,4304]]],[1542619528579,["gjx16@GJXAIOU",[[1,4302,"  "]],[4303,4303],[4305,4305]]],[1542619531231,["gjx16@GJXAIOU",[[1,4306,"fang"]],[4306,4306],[4310,4310]]],[1542619532017,["gjx16@GJXAIOU",[[-1,4306,"fang"]],[4310,4310],[4306,4306]]],[1542619539726,["gjx16@GJXAIOU",[[1,4306,"方法一：使用全局函数法"]],[4306,4306],[4317,4317]]],[1542619912966,[null,[[-1,4253,"\n\n： "],[1,4257,"结果：\n"],[-1,4273," "],[1,4274,"\n"],[1,4278,"求两"],[-1,4299,"\n案"],[-1,5299,"例"],[1,5300,"\n"],[1,5315,"案例"]],[4253,4253],[5317,5317]]],[1542619912966,[null,[[1,4253,"\n\n： "],[-1,4253,"结果：\n"],[1,4273," "],[-1,4273,"\n"],[-1,4278,"求两"],[1,4301,"\n案"],[1,5299,"例"],[-1,5299,"\n"],[-1,5315,"案例"]],[5317,5317],[4253,4253]]],[1542619900163,["gjx16@GJXAIOU",[[-1,4831,"\n"]],[4831,4831],[4830,4830]]],[1542619902034,["gjx16@GJXAIOU",[[-1,4784,"\n"]],[4784,4784],[4783,4783]]],[1542619903594,["gjx16@GJXAIOU",[[-1,4736,"\t"]],[4736,4736],[4735,4735]]],[1542619904162,["gjx16@GJXAIOU",[[-1,4734,"\n"]],[4735,4735],[4734,4734]]],[1542620272966,[null,[[-1,4253,"\n\n： "],[1,4257,"结果：\n"],[-1,4273," "],[1,4274,"\n"],[1,4278,"求两"],[-1,4299,"\n案"],[-1,5295,"例"],[1,5296,"\n"],[1,5311,"案例"]],[4253,4253],[5313,5313]]],[1542620272966,[null,[[1,4253,"\n\n： "],[-1,4253,"结果：\n"],[1,4273," "],[-1,4273,"\n"],[-1,4278,"求两"],[1,4301,"\n案"],[1,5295,"例"],[-1,5295,"\n"],[-1,5311,"案例"]],[5313,5313],[4253,4253]]],[1542620264708,["gjx16@GJXAIOU",[[1,5311,"\n"]],[5309,5309],[5310,5310]]],[1542620264828,["gjx16@GJXAIOU",[[1,5312,"\n"]],[5310,5310],[5311,5311]]],[1542620269877,["gjx16@GJXAIOU",[[1,5311,"  - 方法为"]],[5311,5311],[5318,5318]]],[1542620271592,["gjx16@GJXAIOU",[[-1,5315,"方法为"]],[5318,5318],[5315,5315]]],[1542620272816,["gjx16@GJXAIOU",[[1,5315,"方法"]],[5315,5315],[5317,5317]]],[1542620332970,[null,[[-1,4253,"\n\n： "],[1,4257,"结果：\n"],[-1,4273," "],[1,4274,"\n"],[1,4278,"求两"],[-1,4299,"\n案"],[-1,5295,"例"],[1,5296,"\n"],[1,5319,"案例"]],[4253,4253],[5321,5321]]],[1542620332970,[null,[[1,4253,"\n\n： "],[-1,4253,"结果：\n"],[1,4273," "],[-1,4273,"\n"],[-1,4278,"求两"],[1,4301,"\n案"],[1,5295,"例"],[-1,5295,"\n"],[-1,5319,"案例"]],[5321,5321],[4253,4253]]],[1542620286007,["gjx16@GJXAIOU",[[1,5317,"二：使用类的成员函数"]],[5317,5317],[5327,5327]]],[1542620286641,["gjx16@GJXAIOU",[[1,5328,"  - \n"]],[5327,5327],[5332,5332]]],[1542620288364,["gjx16@GJXAIOU",[[-1,5329," - "]],[5332,5332],[5329,5329]]],[1542620290114,["gjx16@GJXAIOU",[[1,5329,"```"]],[5329,5329],[5332,5332]]],[1542620293163,["gjx16@GJXAIOU",[[-1,5328," "]],[5329,5329],[5328,5328]]],[1542620295596,["gjx16@GJXAIOU",[[-1,5330,"`"]],[5331,5331],[5330,5330]]],[1542620296679,["gjx16@GJXAIOU",[[1,5330,"`"]],[5330,5330],[5331,5331]]],[1542620296717,["gjx16@GJXAIOU",[[1,5331,"language\n```\n"]],[5331,5331],[5331,5339]]],[1542620297926,["gjx16@GJXAIOU",[[-1,5331,"language"],[1,5339,"c"]],[5331,5339],[5332,5332]]],[1542620298334,["gjx16@GJXAIOU",[[1,5332,"pp"]],[5332,5332],[5334,5334]]],[1542620299249,["gjx16@GJXAIOU",[[1,5335,"\n"]],[5334,5334],[5335,5335]]],[1542620299845,["gjx16@GJXAIOU",[[1,5336,"/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n"]],[5335,5335],[6341,6341]]],[1542620304743,["gjx16@GJXAIOU",[[1,6348,"\n"]],[6345,6345],[6346,6346]]],[1542620305239,["gjx16@GJXAIOU",[[1,6346,"c"]],[6346,6346],[6347,6347]]],[1542620305844,["gjx16@GJXAIOU",[[-1,6346,"c"]],[6347,6347],[6346,6346]]],[1542620310452,["gjx16@GJXAIOU",[[1,6346,"程序运行结果；"]],[6346,6346],[6353,6353]]],[1542620311437,["gjx16@GJXAIOU",[[-1,6352,"；"]],[6353,6353],[6352,6352]]],[1542620313876,["gjx16@GJXAIOU",[[1,6352,"：``"]],[6352,6352],[6355,6355]]],[1542620315695,["gjx16@GJXAIOU",[[1,6354,"cu"]],[6354,6354],[6356,6356]]],[1542620316165,["gjx16@GJXAIOU",[[-1,6354,"cu"]],[6356,6356],[6354,6354]]],[1542620319526,["gjx16@GJXAIOU",[[1,6354,"buxiangdeng"]],[6354,6354],[6365,6365]]],[1542626453130,[null,[[-1,4253,"\n\n： "],[1,4257,"结果：\n"],[-1,4273," "],[1,4274,"\n"],[1,4278,"求两"],[-1,4299,"\n案"],[-1,5295,"例"],[1,5296,"\n"],[1,6369,"案例"]],[4253,4253],[6371,6371]]],[1542626453130,[null,[[1,4253,"\n\n： "],[-1,4253,"结果：\n"],[1,4273," "],[-1,4273,"\n"],[-1,4278,"求两"],[1,4301,"\n案"],[1,5295,"例"],[-1,5295,"\n"],[-1,6369,"案例"]],[6371,6371],[4253,4253]]],[1542626440035,["gjx16@GJXAIOU",[[1,6419,"       "]],[6419,6419],[6426,6426]]],[1542626443620,["gjx16@GJXAIOU",[[1,6373,":"]],[6373,6373],[6374,6374]]],[1542626447937,["gjx16@GJXAIOU",[[1,6448,":"]],[6448,6448],[6449,6449]]],[1542626573129,[null,[[-1,4253,"\n\n： "],[1,4257,"结果：\n"],[-1,4273," "],[1,4274,"\n"],[1,4278,"求两"],[-1,4299,"\n案"],[-1,5295,"例"],[1,5296,"\n"],[1,6369,"案例"],[1,6371,":"],[-1,6373,":"],[-1,6418,"即："],[1,6427,"即："],[1,6446,":"],[-1,6448,":"]],[4253,4253],[6448,6448]]],[1542626573129,[null,[[1,4253,"\n\n： "],[-1,4253,"结果：\n"],[1,4273," "],[-1,4273,"\n"],[-1,4278,"求两"],[1,4301,"\n案"],[1,5295,"例"],[-1,5295,"\n"],[-1,6369,"案例"],[-1,6373,":"],[1,6376,":"],[1,6420,"即："],[-1,6427,"即："],[-1,6448,":"],[1,6451,":"]],[6448,6448],[4253,4253]]],[1542626534299,["gjx16@GJXAIOU",[[-1,5837,"\n"]],[5837,5837],[5836,5836]]],[1542626537474,["gjx16@GJXAIOU",[[-1,5790,"\n"]],[5790,5790],[5789,5789]]],[1542626539554,["gjx16@GJXAIOU",[[-1,5743,"\n"]],[5743,5743],[5742,5742]]]],null,"gjx16@GJXAIOU"],["ee3c3e26-49be-4880-99a0-b18fdea66ace",1542694751829,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁\n   * c++面向对象模型初探  \n   * c++面向对象多态原理探究\n   * 操作符重载\n\n- C++基础课程学习完毕以后，有没有一个标准，来判断自己有没有入门。\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（把属性和方法进行封装对属性和方法进行访问控制）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle pc)\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n//public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n//private:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问\n//protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\n\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”，\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n\t\n};\n\n```\nTeacher.cpp\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1 设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n\n案例3: 对于第二个案例，类的声明和类的实现分开\n\n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n",[[1542694749233,["gjx16@GJXAIOU",[[1,6442,"\n"]],[6441,6441],[6442,6442]]],[1542694753514,["gjx16@GJXAIOU",[[-1,6442,"··"]],[6444,6444],[6442,6442]]],[1542694754869,["gjx16@GJXAIOU",[[1,6442,"```"]],[6442,6442],[6445,6445]]],[1542694754907,["gjx16@GJXAIOU",[[1,6445,"language\n```\n"]],[6445,6445],[6445,6453]]],[1542694756149,["gjx16@GJXAIOU",[[-1,6445,"language"],[1,6453,"c"]],[6445,6453],[6446,6446]]],[1542694756501,["gjx16@GJXAIOU",[[1,6446,"pp"]],[6446,6446],[6448,6448]]],[1542694757253,["gjx16@GJXAIOU",[[1,6449,"\n"]],[6448,6448],[6449,6449]]],[1542695410727,[null,[[1,6454,"\n案"]],[6454,6454],[6456,6456]]],[1542695410727,[null,[[-1,6454,"\n案"]],[6456,6456],[6454,6454]]],[1542695386557,["gjx16@GJXAIOU",[[1,6450,"/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n"]],[6449,6449],[7452,7452]]],[1542695590732,[null,[[1,7457,"\n案"]],[7457,7457],[7459,7459]]],[1542695590732,[null,[[-1,7457,"\n案"]],[7459,7459],[7457,7457]]],[1542695559196,["gjx16@GJXAIOU",[[1,7457,"``"]],[7457,7457],[7459,7459]]],[1542695562915,["gjx16@GJXAIOU",[[1,7457,"z"]],[7457,7457],[7458,7458]]],[1542695563481,["gjx16@GJXAIOU",[[-1,7457,"z"]],[7458,7458],[7457,7457]]],[1542695569617,["gjx16@GJXAIOU",[[1,7457,"程序运行结果："]],[7457,7457],[7464,7464]]],[1542695572110,["gjx16@GJXAIOU",[[1,7465,"\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}"]],[7465,7465],[8468,8468]]],[1542695574197,["gjx16@GJXAIOU",[[-1,7465,"\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}"]],[8468,8468],[7465,7465]]],[1542695576393,["gjx16@GJXAIOU",[[1,7465,"zai"]],[7465,7465],[7468,7468]]],[1542711898965,[null,[[1,7469,"\n案"]],[7469,7469],[7471,7471]]],[1542711898965,[null,[[-1,7469,"\n案"]],[7471,7471],[7469,7469]]],[1542711882256,["gjx16@GJXAIOU",[[1,7496,"\n"]],[7494,7494],[7495,7495]]],[1542711885382,["gjx16@GJXAIOU",[[1,7495,"zheg"]],[7495,7495],[7499,7499]]],[1542711886362,["gjx16@GJXAIOU",[[-1,7495,"zheg"]],[7499,7499],[7495,7495]]],[1542711887392,["gjx16@GJXAIOU",[[1,7495,"z"]],[7495,7495],[7496,7496]]],[1542711887922,["gjx16@GJXAIOU",[[-1,7495,"z"]],[7496,7496],[7495,7495]]],[1542711895256,["gjx16@GJXAIOU",[[1,7495,"整个文件分为："]],[7495,7495],[7502,7502]]],[1542711958966,[null,[[1,7469,"\n案"],[-1,7493,"\n!"],[-1,7502,"[\n"],[1,7504,"\n\n!["]],[7469,7469],[7508,7508]]],[1542711958966,[null,[[-1,7469,"\n案"],[1,7495,"\n!"],[1,7502,"[\n"],[-1,7502,"\n\n!["]],[7508,7508],[7469,7469]]],[1542711908494,["gjx16@GJXAIOU",[[1,7502,"main.cpp  myCio"]],[7502,7502],[7517,7517]]],[1542711909100,["gjx16@GJXAIOU",[[-1,7516,"o"]],[7517,7517],[7516,7516]]],[1542711914871,["gjx16@GJXAIOU",[[1,7516,"rcle.h,"]],[7516,7516],[7523,7523]]],[1542711916067,["gjx16@GJXAIOU",[[-1,7522,","]],[7523,7523],[7522,7522]]],[1542711938656,["gjx16@GJXAIOU",[[1,7522,"  myCircle.cpp   myPoint.h   myPoint.cpp"]],[7522,7522],[7562,7562]]],[1542712138961,[null,[[1,7469,"\n案"],[-1,7493,"\n!"],[-1,7562,"[\n"],[1,7564,"\n\n!["]],[7469,7469],[7568,7568]]],[1542712138961,[null,[[-1,7469,"\n案"],[1,7495,"\n!"],[1,7562,"[\n"],[-1,7562,"\n\n!["]],[7568,7568],[7469,7469]]],[1542712135638,["gjx16@GJXAIOU",[[1,7564,"\n"]],[7562,7562],[7563,7563]]],[1542712198961,[null,[[1,7469,"\n案"],[-1,7493,"\n!"],[-1,7562,"["],[1,7563,"\n"],[1,7565,"!["]],[7469,7469],[7567,7567]]],[1542712198961,[null,[[-1,7469,"\n案"],[1,7495,"\n!"],[1,7562,"["],[-1,7562,"\n"],[-1,7565,"!["]],[7567,7567],[7469,7469]]],[1542712139644,["gjx16@GJXAIOU",[[1,7563,"****"]],[7563,7563],[7565,7565]]],[1542712142935,["gjx16@GJXAIOU",[[1,7565,"main.cpp"]],[7565,7565],[7573,7573]]],[1542712145052,["gjx16@GJXAIOU",[[1,7577,"\n"]],[7575,7575],[7576,7576]]],[1542712147023,["gjx16@GJXAIOU",[[1,7576,"·"]],[7576,7576],[7577,7577]]],[1542712147891,["gjx16@GJXAIOU",[[-1,7576,"·"]],[7577,7577],[7576,7576]]],[1542712148959,["gjx16@GJXAIOU",[[1,7576,"```"]],[7576,7576],[7579,7579]]],[1542712149003,["gjx16@GJXAIOU",[[1,7579,"language\n```\n"]],[7579,7579],[7579,7587]]],[1542712150081,["gjx16@GJXAIOU",[[-1,7579,"language"],[1,7587,"c"]],[7579,7587],[7580,7580]]],[1542712150432,["gjx16@GJXAIOU",[[1,7580,"pp"]],[7580,7580],[7582,7582]]],[1542712150924,["gjx16@GJXAIOU",[[1,7583,"\n"]],[7582,7582],[7583,7583]]],[1542712173257,["gjx16@GJXAIOU",[[1,7584,"/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n"]],[7583,7583],[7991,7991]]],[1542712176939,["gjx16@GJXAIOU",[[1,7998,"\n"]],[7995,7995],[7996,7996]]],[1542712178845,["gjx16@GJXAIOU",[[1,7996,"****"]],[7996,7996],[7998,7998]]],[1542712198141,["gjx16@GJXAIOU",[[1,7998,"myCircle."]],[7998,7998],[8007,8007]]],[1542712258981,[null,[[1,7469,"\n案"],[-1,7493,"\n!"],[-1,7562,"["],[1,7563,"\n"],[1,8012,"!["]],[7469,7469],[8014,8014]]],[1542712258981,[null,[[-1,7469,"\n案"],[1,7495,"\n!"],[1,7562,"["],[-1,7562,"\n"],[-1,8012,"!["]],[8014,8014],[7469,7469]]],[1542712199118,["gjx16@GJXAIOU",[[1,8007,"h"]],[8007,8007],[8008,8008]]],[1542712201982,["gjx16@GJXAIOU",[[1,8013,"\n"]],[8010,8010],[8011,8011]]],[1542712203598,["gjx16@GJXAIOU",[[1,8011,"```"]],[8011,8011],[8014,8014]]],[1542712203637,["gjx16@GJXAIOU",[[1,8014,"language\n```\n"]],[8014,8014],[8014,8022]]],[1542712206133,["gjx16@GJXAIOU",[[-1,8014,"language"],[1,8022,"h"]],[8014,8022],[8015,8015]]],[1542712207310,["gjx16@GJXAIOU",[[1,8016,"\n"]],[8015,8015],[8016,8016]]],[1542712216507,["gjx16@GJXAIOU",[[1,8016,"#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};"]],[8016,8016],[8224,8224]]],[1542712220028,["gjx16@GJXAIOU",[[1,8232,"\n"]],[8228,8228],[8229,8229]]],[1542712220171,["gjx16@GJXAIOU",[[1,8233,"\n"]],[8229,8229],[8230,8230]]],[1542712221701,["gjx16@GJXAIOU",[[1,8230,"****"]],[8230,8230],[8232,8232]]],[1542712229584,["gjx16@GJXAIOU",[[1,8232,"myCircle。"]],[8232,8232],[8241,8241]]],[1542712230211,["gjx16@GJXAIOU",[[-1,8240,"。"]],[8241,8241],[8240,8240]]],[1542712232495,["gjx16@GJXAIOU",[[1,8240,".cpp"]],[8240,8240],[8244,8244]]],[1542712234460,["gjx16@GJXAIOU",[[1,8250,"\n"]],[8246,8246],[8247,8247]]],[1542712235935,["gjx16@GJXAIOU",[[1,8247,"```"]],[8247,8247],[8250,8250]]],[1542712235975,["gjx16@GJXAIOU",[[1,8250,"language\n```\n"]],[8250,8250],[8250,8258]]],[1542712236909,["gjx16@GJXAIOU",[[-1,8250,"language"],[1,8258,"c"]],[8250,8258],[8251,8251]]],[1542712237389,["gjx16@GJXAIOU",[[1,8251,"pp"]],[8251,8251],[8253,8253]]],[1542712237656,["gjx16@GJXAIOU",[[1,8254,"\n"]],[8253,8253],[8254,8254]]],[1542712245061,["gjx16@GJXAIOU",[[1,8254,"#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n"]],[8254,8254],[8451,8451]]],[1542712247723,["gjx16@GJXAIOU",[[1,8460,"\n"]],[8455,8455],[8456,8456]]],[1542712247858,["gjx16@GJXAIOU",[[1,8461,"\n"]],[8456,8456],[8457,8457]]],[1542712248874,["gjx16@GJXAIOU",[[1,8457,"****"]],[8457,8457],[8459,8459]]],[1542712253597,["gjx16@GJXAIOU",[[1,8459,"myPoint.h"]],[8459,8459],[8468,8468]]],[1542712255611,["gjx16@GJXAIOU",[[1,8475,"\n"]],[8470,8470],[8471,8471]]],[1542712256747,["gjx16@GJXAIOU",[[1,8471,"```"]],[8471,8471],[8474,8474]]],[1542712256786,["gjx16@GJXAIOU",[[1,8474,"language\n```\n"]],[8474,8474],[8474,8482]]],[1542712258423,["gjx16@GJXAIOU",[[-1,8474,"language"],[1,8482,"h"]],[8474,8482],[8475,8475]]],[1542712258804,["gjx16@GJXAIOU",[[1,8476,"\n"]],[8475,8475],[8476,8476]]],[1542712318975,[null,[[1,7469,"\n案"],[-1,7493,"\n!"],[-1,7562,"["],[1,7563,"\n"],[1,8486,"!["]],[7469,7469],[8488,8488]]],[1542712318975,[null,[[-1,7469,"\n案"],[1,7495,"\n!"],[1,7562,"["],[-1,7562,"\n"],[-1,8486,"!["]],[8488,8488],[7469,7469]]],[1542712268949,["gjx16@GJXAIOU",[[1,8476,"#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n"]],[8476,8476],[8608,8608]]],[1542712289121,["gjx16@GJXAIOU",[[1,8266,"Circle.h\"\n#include\"my"],[1,8276,"class myPoint;\n\n"],[-1,8281," "],[-1,8284,"Point::set_point"],[1,8300,"Circle::get_circle"],[-1,8307,"1"],[1,8308,"0"],[-1,8316,"1)"],[1,8318,"0, int _r)//在函数前面加上类名：："],[-1,8325,"1"],[1,8326,"0"],[-1,8331,"1"],[1,8332,"0"],[-1,8337,"1"],[1,8338,"0"],[-1,8343,"1"],[1,8344,"0;\n\t\tr = _r"],[-1,8356,"1, y1"],[1,8361,"0, y0, r"],[1,8374,"Circle::judge(my"],[-1,8379,":: getX1("],[1,8388," &point"],[-1,8395,"return x1;\n\t}\n\n\tint myP"],[1,8418,"int line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(p"],[-1,8422,"::"],[1,8424,"."],[1,8431," - y0);"],[1,8432,"\t\tif (line <= r * r)\n\t"],[1,8437,"\t"],[-1,8444,"y"],[1,8448,"\t"],[1,8450,"\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n"]],[8254,8450],[8652,8652]]],[1542712310971,["gjx16@GJXAIOU",[[1,8820,"\n"]],[8814,8814],[8815,8815]]],[1542712311117,["gjx16@GJXAIOU",[[1,8821,"\n"]],[8815,8815],[8816,8816]]],[1542712312240,["gjx16@GJXAIOU",[[1,8816,"****"]],[8816,8816],[8818,8818]]],[1542712315419,["gjx16@GJXAIOU",[[1,8818,"myPoint "]],[8818,8818],[8826,8826]]],[1542712316115,["gjx16@GJXAIOU",[[-1,8825," "]],[8826,8826],[8825,8825]]],[1542712317503,["gjx16@GJXAIOU",[[1,8825,".cpp"]],[8825,8825],[8829,8829]]],[1542712378979,[null,[[1,7469,"\n案"],[-1,7493,"\n!"],[-1,7562,"["],[1,7563,"\n"],[1,8837,"!["]],[7469,7469],[8839,8839]]],[1542712378979,[null,[[-1,7469,"\n案"],[1,7495,"\n!"],[1,7562,"["],[-1,7562,"\n"],[-1,8837,"!["]],[8839,8839],[7469,7469]]],[1542712325150,["gjx16@GJXAIOU",[[1,8837,"\n"]],[8831,8831],[8832,8832]]],[1542712326147,["gjx16@GJXAIOU",[[1,8832,"···"]],[8832,8832],[8835,8835]]],[1542712327467,["gjx16@GJXAIOU",[[-1,8832,"···"]],[8835,8835],[8832,8832]]],[1542712328612,["gjx16@GJXAIOU",[[1,8832,"```"]],[8832,8832],[8835,8835]]],[1542712328656,["gjx16@GJXAIOU",[[1,8835,"language\n```\n"]],[8835,8835],[8835,8843]]],[1542712329907,["gjx16@GJXAIOU",[[-1,8835,"language"],[1,8843,"c"]],[8835,8843],[8836,8836]]],[1542712330255,["gjx16@GJXAIOU",[[1,8836,"pp"]],[8836,8836],[8838,8838]]],[1542712331335,["gjx16@GJXAIOU",[[1,8839,"\n"]],[8838,8838],[8839,8839]]],[1542712332568,["gjx16@GJXAIOU",[[1,8839,"#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n"]],[8839,8839],[9036,9036]]],[1542712360292,["gjx16@GJXAIOU",[[-1,9047,"![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n"]],[9046,9134],[9046,9046]]],[1542712371219,["gjx16@GJXAIOU",[[1,6441,"         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n"]],[6440,6440],[6538,6538]]]],null,"gjx16@GJXAIOU"],["f83999bb-db82-4269-be99-990534fc40c4",1542933636701,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁\n   * c++面向对象模型初探  \n   * c++面向对象多态原理探究\n   * 操作符重载\n\n- C++基础课程学习完毕以后，有没有一个标准，来判断自己有没有入门。\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（把属性和方法进行封装对属性和方法进行访问控制）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle pc)\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n//public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n//private:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问\n//protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\n\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”，\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n\t\n};\n\n```\nTeacher.cpp\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1 设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n",[[1542933623229,["gjx16@GJXAIOU",[[1,723,"和"]],[723,723],[724,724]]],[1542933634105,["gjx16@GJXAIOU",[[1,713,"===="]],[713,713],[715,715]]],[1542933635417,["gjx16@GJXAIOU",[[-1,715,"=="]],[715,715],[713,713]]],[1542933639303,["gjx16@GJXAIOU",[[1,738,"===="]],[738,738],[740,740]]],[1542933641806,["gjx16@GJXAIOU",[[-1,740,"=="]],[740,740],[738,738]]],[1542933668508,["gjx16@GJXAIOU",[[-1,826,"\n"]],[826,826],[825,825]]],[1542933742480,["gjx16@GJXAIOU",[[1,1297,"&"]],[1297,1297],[1298,1298]]],[1542934113025,["gjx16@GJXAIOU",[[1,1301,"  、、"]],[1301,1301],[1305,1305]]],[1542934114020,["gjx16@GJXAIOU",[[-1,1303,"、、"]],[1305,1305],[1303,1303]]],[1542934115314,["gjx16@GJXAIOU",[[1,1303,"#"]],[1303,1303],[1304,1304]]],[1542934117132,["gjx16@GJXAIOU",[[1,1304,"在黑夜里"]],[1304,1304],[1308,1308]]],[1542934118455,["gjx16@GJXAIOU",[[-1,1304,"在黑夜里"]],[1308,1308],[1304,1304]]],[1542934126354,["gjx16@GJXAIOU",[[1,1304,"这里加不加&都行"]],[1304,1304],[1312,1312]]],[1542934178373,["gjx16@GJXAIOU",[[-1,1808,"再"]],[1809,1809],[1808,1808]]],[1542934179843,["gjx16@GJXAIOU",[[1,1808,"在"]],[1808,1808],[1809,1809]]],[1542934241217,["gjx16@GJXAIOU",[[-1,1735,"//public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n//private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n//protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数"]],[1735,1900],[1735,1735]]],[1542934244102,["gjx16@GJXAIOU",[[1,1702,"\n"]],[1701,1701],[1702,1702]]],[1542934244653,["gjx16@GJXAIOU",[[1,1702,"//public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n//private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n//protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数"]],[1702,1702],[1867,1867]]],[1542934248094,["gjx16@GJXAIOU",[[-1,1702,"//"]],[1704,1704],[1702,1702]]],[1542934250133,["gjx16@GJXAIOU",[[-1,1737,"//"]],[1739,1739],[1737,1737]]],[1542934251300,["gjx16@GJXAIOU",[[-1,1779,"//"]],[1781,1781],[1779,1779]]],[1542934253421,["gjx16@GJXAIOU",[[1,1702,"- "]],[1702,1702],[1704,1704]]],[1542934254673,["gjx16@GJXAIOU",[[1,1739,"- "]],[1739,1739],[1741,1741]]],[1542934256352,["gjx16@GJXAIOU",[[1,1783,"- "]],[1783,1783],[1785,1785]]],[1542934284879,["gjx16@GJXAIOU",[[-1,1903,"\n"]],[1903,1903],[1902,1902]]],[1542934285019,["gjx16@GJXAIOU",[[-1,1902,"\n"]],[1902,1902],[1901,1901]]],[1542934326589,["gjx16@GJXAIOU",[[-1,2000,"\n"]],[2000,2000],[1999,1999]]],[1542935983989,["gjx16@GJXAIOU",[[1,3316,"（）"]],[3316,3316],[3318,3318]]],[1542935989896,["gjx16@GJXAIOU",[[1,3317,"相当于主函数"]],[3317,3317],[3323,3323]]],[1542936281333,["gjx16@GJXAIOU",[[1,9447,"\n"]],[9445,9445],[9446,9446]]],[1542936281536,["gjx16@GJXAIOU",[[1,9448,"\n"]],[9446,9446],[9447,9447]]],[1542936281667,["gjx16@GJXAIOU",[[1,9449,"\n"]],[9447,9447],[9448,9448]]],[1542936281781,["gjx16@GJXAIOU",[[1,9450,"\n"]],[9448,9448],[9449,9449]]],[1542936281952,["gjx16@GJXAIOU",[[1,9451,"\n"]],[9449,9449],[9450,9450]]],[1542936282091,["gjx16@GJXAIOU",[[1,9452,"\n"]],[9450,9450],[9451,9451]]],[1542936282248,["gjx16@GJXAIOU",[[1,9453,"\n"]],[9451,9451],[9452,9452]]],[1542936282359,["gjx16@GJXAIOU",[[1,9454,"\n"]],[9452,9452],[9453,9453]]],[1542936282542,["gjx16@GJXAIOU",[[1,9455,"\n"]],[9453,9453],[9454,9454]]],[1542936284138,["gjx16@GJXAIOU",[[1,9454,"###"]],[9454,9454],[9457,9457]]],[1542936284941,["gjx16@GJXAIOU",[[-1,9456,"#"]],[9457,9457],[9456,9456]]],[1542936287399,["gjx16@GJXAIOU",[[1,9456," 三。"]],[9456,9456],[9459,9459]]],[1542936288221,["gjx16@GJXAIOU",[[-1,9458,"。"]],[9459,9459],[9458,9458]]],[1542936297707,["gjx16@GJXAIOU",[[1,9458,"、对象的构造和析构"]],[9458,9458],[9467,9467]]],[1542936298412,["gjx16@GJXAIOU",[[1,9469,"\n"]],[9467,9467],[9468,9468]]],[1542936390803,["gjx16@GJXAIOU",[[1,9468,"前言\n\n创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n\n为了解决这个问题，C++编译器提供了**构造函数****(constructor)**来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。\n\n**3.1****构造和析构函数**\n\n**1****构造函数和析构函数的概念**\n\n**有关构造函数**\n\n1构造函数定义及调用\n\n1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n\n2）构造函数在定义时可以有参数；\n\n3）没有任何返回类型的声明。\n\n2构造函数的调用\n\n自动调用：一般情况下C++编译器会自动调用构造函数\n\n手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n3）析构函数定义及调用\n\n 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n\n语法：~ClassName()\n\n2）析构函数没有参数也没有任何返回类型的声明\n\n3）析构函数在对象销毁时自动被调用\n\n4）析构函数调用机制\n\n C++编译器自动调用\n\n代码演示：dm01_构造函数的基础.cpp\n\n**2 C++****编译器构造析构方案** **PK** **对象显示初始化方案**\n\n设计构造函数和析构函数的原因\n\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n普通方案：\n\n为每个类都提供一个public的initialize函数；\n\n对象创建后立即调用initialize函数进行初始化。\n\n优缺点分析\n\n1）initialize只是一个普通的函数，必须显示的调用\n\n2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n\n没有初始化的对象，其内部成员变量的值是不定的\n\n3）不能完全解决问题\n\n| \n\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n\n{\n\npublic:\n\n int m;\n\n int getM() const { return m; }\n\n void setM(int val) { m = val; }\n\n int n;\n\n int getN() const { return n; }\n\n void setN(int val) { n = val; }\n\npublic:\n\n int init(int m,int n)\n\n {\n\n this->m = m;\n\n this->n = n;\n\n return 0;\n\n }\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n\n{\n\n int rv =0;\n\n Test21 t1; //无参构造函数的调用方法\n\n Test21 t2;\n\n //t1.init(100, 200);\n\n //t2.init(300, 400);\n\n cout<<t1.getM()<<\" \"<<t1.getN()<<endl;\n\n cout<<t2.getM()<<\" \"<<t2.getN()<<endl;\n\n **//****定义对象数组时，没有机会进行显示初始化**\n\n Test21 arr[3];\n\n //Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n system(\"pause\");\n\n return rv;\n\n}\n\n |\n\n**3.2****构造函数的分类及调用**\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n| \n\n//有参数构造函数的三种调用方法\n\nclass Test\n\n{\n\nprivate:\n\n int a;\n\n int b;\n\npublic:\n\n //无参数构造函数\n\n Test()\n\n {\n\n ;\n\n }\n\n //带参数的构造函数\n\n Test(int a, int b)\n\n {\n\n ;\n\n }\n\n //赋值构造函数\n\n Test(const Test &obj)\n\n {\n\n ;\n\n }\n\npublic:\n\n void init(int _a, int _b)\n\n {\n\n a = _a;\n\n b = _b;\n\n }\n\n};\n\n |\n\n**1****无参数构造函数**\n\n  调用方法： Test t1, t2;\n\n**2****有参构造函数**\n\n有参构造函数的三种调用方法\n\n| \n\n//有参数构造函数的三种调用方法\n\nclass Test5\n\n{\n\nprivate:\n\n int a;\n\npublic:\n\n //带参数的构造函数\n\n Test5(int a)\n\n {\n\n printf(\"\\na:%d\", a);\n\n }\n\n Test5(int a, int b)\n\n {\n\n printf(\"\\na:%d b:%d\", a, b);\n\n }\n\npublic:\n\n};\n\nint main55()\n\n{\n\n Test5 t1(10); //c++编译器默认调用有参构造函数  括号法\n\n Test5 t2 = (20, 10); //c++编译器默认调用有参构造函数  等号法\n\n Test5 t3 = Test5(30); //程序员手工调用构造函数  产生了一个对象  直接调用构造构造函数法\n\n system(\"pause\");\n\n return 0;\n\n}\n\n |\n\n**3****拷贝构造函数调用时机**\n\n赋值构造函数的四种调用场景（调用时机）\n\n第1和第2个调用场景  \n\n| \n\n#include \"iostream\"\n\nusing namespace std;\n\nclass AA\n\n{\n\npublic:\n\n AA() //无参构造函数 默认构造函数\n\n {\n\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n\n }\n\n AA(int _a) //无参构造函数 默认构造函数\n\n {\n\n a = _a;\n\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n |\n| \n\n第二个应用场景\n\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n\n}\n\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n |\n\n第3个调用场景\n\n| \n\n#include \"iostream\"\n\nusing namespace std;\n\nclass Location\n\n{\n\npublic:\n\n Location( int xx = 0 , int yy = 0 )\n\n {\n\n X = xx ; Y = yy ; cout << \"Constructor Object.\\n\" ;\n\n }\n\n Location( const Location & p )      //拷贝构造函数\n\n {\n\n X = p.X ; Y = p.Y ; cout << \"Copy_constructor called.\" << endl ;\n\n }\n\n ~Location()\n\n {\n\n cout << X << \",\" << Y << \" Object destroyed.\" << endl ;\n\n }\n\n int GetX () { return X ; } int GetY () { return Y ; }\n\nprivate : int X , Y ;\n\n} ;\n\n//alt + f8 排版\n\nvoid f ( Location p )  \n\n{\n\n cout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl ;\n\n}\n\nvoid mainobjplay()\n\n{ \n\n Location A ( 1, 2 ) ;  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n f ( A ) ;\n\n}\n\nvoid main()\n\n{ \n\n mainobjplay();\n\n system(\"pause\");\n\n}\n\n |\n\n第4个调用场景\n\n| \n\n第四个应用场景\n\n#include \"iostream\"\n\nusing namespace std;\n\nclass Location\n\n{\n\npublic:\n\n Location( int xx = 0 , int yy = 0 )\n\n {\n\n X = xx ; Y = yy ; cout << \"Constructor Object.\\n\" ;\n\n }\n\n Location( const Location & p )      //复制构造函数\n\n {\n\n X = p.X ; Y = p.Y ; cout << \"Copy_constructor called.\" << endl ;\n\n }\n\n ~Location()\n\n {\n\n cout << X << \",\" << Y << \" Object destroyed.\" << endl ;\n\n }\n\n int GetX () { return X ; } int GetY () { return Y ; }\n\nprivate : int X , Y ;\n\n} ;\n\n//alt + f8 排版\n\nvoid f ( Location p )  \n\n{\n\n cout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl ;\n\n}\n\nLocation g()\n\n{\n\n Location A(1, 2);\n\n return A;\n\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n\n{ \n\n //若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n //Location B;\n\n //B = g(); **//****用匿名对象** **赋值** **给B****对象，然后匿名对象析构**\n\n //若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象\n\n Location B = g();\n\n cout<<\"传智扫地僧测试\"<<endl;\n\n}\n\nvoid main()\n\n{ \n\n mainobjplay();\n\n system(\"pause\");\n\n}\n\n |\n|  |\n\n**4****默认构造函数**\n\n二个特殊的构造函数\n\n1）默认无参构造函数\n\n当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n2）默认拷贝构造函数\n\n当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n**3.3****构造函数调用规则研究**\n\n1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数\n\n2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数\n\n3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数\n\n4 ）默认拷贝构造函数成员变量简单赋值\n\n总结：只要你写了构造函数，那么你必须用。\n\n**构造析构阶段性总结**\n\n1）构造函数是C++中用于初始化对象状态的特殊函数\n\n2）构造函数在对象创建时自动被调用\n\n3）构造函数和普通成员函数都遵循重载规则\n\n4）拷贝构造函数是对象正确初始化的重要保证\n\n5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n**3.4****深拷贝和浅拷贝**\n\nØ 默认复制构造函数可以完成对象的数据成员值简单的复制\n\nØ  对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1****浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n\n**2****浅拷贝程序****C++****提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n| \n\nclass Name\n\n{\n\npublic:\n\n Name(const char *pname)\n\n {\n\n size = strlen(pname);\n\n pName = (char *)malloc(size + 1);\n\n strcpy(pName, pname);\n\n }\n\n Name(Name &obj)\n\n {\n\n //用obj来初始化自己\n\n pName = (char *)malloc(obj.size + 1);\n\n strcpy(pName, obj.pName);\n\n size = obj.size;\n\n }\n\n ~Name()\n\n {\n\n cout<<\"开始析构\"<<endl;\n\n if (pName!=NULL)\n\n {\n\n free(pName);\n\n pName = NULL;\n\n size = 0;\n\n }\n\n }\n\n void operator=(Name &obj3)\n\n {\n\n if (pName != NULL)\n\n {\n\n free(pName);\n\n pName = NULL;\n\n size = 0;\n\n }\n\n cout<<\"测试有没有调用我。。。。\"<<endl;\n\n //用obj3来=自己\n\n pName = (char *)malloc(obj3.size + 1);\n\n strcpy(pName, obj3.pName);\n\n size = obj3.size;\n\n }\n\nprotected:\n\nprivate:\n\n char *pName;\n\n int size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n\n{\n\n Name obj1(\"obj1.....\");\n\n Name obj2 = obj1; //obj2创建并初始化\n\n Name obj3(\"obj3...\");\n\n //重载=号操作符\n\n obj2 = obj3; //=号操作\n\n cout<<\"业务操作。。。5000\"<<endl;\n\n}\n\nvoid main61()\n\n{\n\n playObj();\n\n system(\"pause\");\n\n}\n\n |\n|  |\n|  |\n\n**3.5****多个对象构造和析构**\n\n**1****对象初始化列表**\n\n1）对象初始化列表出现原因\n\n1.必须这样做：\n\n如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n\n如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n\n当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n\n因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n\n{\n\n // some other assignment operation\n\n}\n\n3）注意概念\n\n初始化：被初始化的对象正在创建\n\n赋值：被赋值的对象已经存在\n\n4）注意：\n\n成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n\n初始化列表先于构造函数的函数体执行\n\n| \n\n/*\n\n1 C++中提供了初始化列表对成员变量进行初始化\n\n2 使用初始化列表出现原因：\n\n1.必须这样做：\n\n如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n\n而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n\n如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n\n当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n\n因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n*/\n\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\n\nusing namespace std;\n\nclass ABC\n\n{\n\npublic:\n\n ABC(int a, int b, int c)\n\n {\n\n this->a = a;\n\n this->b = b;\n\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n\n printf(\"ABC construct ..\\n\");\n\n }\n\n ~ABC()\n\n {\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n\n printf(\"~ABC() ..\\n\");\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n int b;\n\n int c;\n\n};\n\nclass MyD\n\n{\n\npublic:\n\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n\n {\n\n cout<<\"MyD()\"<<endl;\n\n }\n\n ~MyD()\n\n {\n\n cout<<\"~MyD()\"<<endl;\n\n }\n\nprotected:\n\nprivate:\n\n ABC abc1; //c++编译器不知道如何构造abc1\n\n ABC abc2;\n\n const int m;\n\n};\n\nint run()\n\n{\n\n MyD myD;\n\n return 0;\n\n}\n\nint main_dem03()\n\n{\n\n run();\n\n system(\"pause\");\n\n return 0;\n\n}\n\n |\n\n**3.6****构造函数和析构函数的调用顺序研究**\n\n**构造函数与析构函数的调用顺序**\n\n1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n**3.7****构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1****构造析综合训练**\n\ndemo10_构造析构练习强化.cpp （讲解）\n\n  展示分析过程，注意赋值构函数的调用\n\n**2****匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3****匿名对象强化训练**\n\n3） 构造中调用构造\n\ndemo11_匿名对象练习强化.cpp\n\n  构造函数中调用构造函数，是一个蹩脚的行为。\n\n**3.8** **对象的动态建立和释放**\n\n**1 new****和****delete****基本语法**\n\n1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n注意： new和delete是运算符，不是函数，因此执行效率高。\n\n2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： new int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 new char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址 new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n 3）new和delete运算符使用的一般格式为：\n\n用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n\n4） 应用举例\n\n**2** **类对象的动态建立和释放**\n\n使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n比如：\n\nBox *pt;  //定义一个指向Box类对象的指针变量pt\n    pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n  在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3** **编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数"]],[9468,9468],[19894,19894]]],[1542936411296,["gjx16@GJXAIOU",[[1,9468,"**"],[1,9470,"**"]],[9468,9470],[9468,9474]]],[1542936414059,["gjx16@GJXAIOU",[[1,9468,"\n"]],[9468,9468],[9469,9469]]],[1542936428602,["gjx16@GJXAIOU",[[-1,9558,"****"]],[9558,9562],[9558,9558]]],[1542936435598,["gjx16@GJXAIOU",[[-1,9638,"****"]],[9638,9642],[9638,9638]]],[1542936438162,["gjx16@GJXAIOU",[[-1,9633,"**"]],[9635,9635],[9633,9633]]],[1542936439306,["gjx16@GJXAIOU",[[-1,9633,""],[1,9633,"#"],[-1,11963,"  "],[1,11965,"  "],[-1,12145," "],[1,12146," "],[-1,12167," "],[1,12168," "],[-1,12172," "],[1,12173," "],[-1,12221," "],[1,12222," "],[-1,12241," "],[1,12242," "],[-1,12972,"    "],[1,12976,"    "],[-1,13261,"  "],[1,13263,"  "],[-1,13354," "],[1,13355," "],[-1,13380," "],[1,13381," "],[-1,13441," "],[1,13442," "],[-1,13713,"    "],[1,13717,"    "],[-1,14002,"  "],[1,14004,"  "],[-1,14198," "],[1,14199," "],[-1,14419," "],[1,14420," "],[-1,15029," "],[1,15030," "],[-1,18408," "],[1,18409," "],[-1,18459," "],[1,18460," "],[-1,18517," "],[1,18518," "],[-1,18567," "],[1,18568," "],[-1,18633," "],[1,18634," "],[-1,18990," "],[1,18991," "],[-1,19013,"   "],[1,19016,"   "],[-1,19029," "],[1,19030," "],[-1,19091," "],[1,19092," "],[-1,19130," "],[1,19131," "]],[9633,9633],[9634,9634]]],[1542936439791,["gjx16@GJXAIOU",[[1,9634,"##"]],[9634,9634],[9636,9636]]],[1542936444211,["gjx16@GJXAIOU",[[-1,9636,"3.1"]],[9639,9639],[9636,9636]]],[1542936445590,["gjx16@GJXAIOU",[[1,9636,"（）"]],[9636,9636],[9638,9638]]],[1542936449792,["gjx16@GJXAIOU",[[1,9637,"一"]],[9637,9637],[9638,9638]]],[1542936452320,["gjx16@GJXAIOU",[[-1,9646,"**"]],[9648,9648],[9646,9646]]],[1542936455241,["gjx16@GJXAIOU",[[-1,9632,"\n"]],[9633,9633],[9632,9632]]],[1542936456695,["gjx16@GJXAIOU",[[1,9632,"\n"]],[9632,9632],[9633,9633]]],[1542936459444,["gjx16@GJXAIOU",[[-1,9636,"（"]],[9637,9637],[9636,9636]]],[1542936461290,["gjx16@GJXAIOU",[[1,9636,"）"]],[9636,9636],[9637,9637]]],[1542936462625,["gjx16@GJXAIOU",[[-1,9636,"）"]],[9637,9637],[9636,9636]]],[1542936463067,["gjx16@GJXAIOU",[[1,9636,"（"]],[9636,9636],[9637,9637]]],[1542936464572,["gjx16@GJXAIOU",[[1,9636," "]],[9636,9636],[9637,9637]]],[1542936469393,["gjx16@GJXAIOU",[[-1,9652,"****"]],[9652,9656],[9652,9652]]],[1542936481282,["gjx16@GJXAIOU",[[1,9649,"\n"]],[9649,9649],[9650,9650]]],[1542936483524,["gjx16@GJXAIOU",[[1,9650,"#### "]],[9650,9650],[9655,9655]]],[1542936490744,["gjx16@GJXAIOU",[[1,9658,"。"]],[9658,9658],[9659,9659]]],[1542936493810,["gjx16@GJXAIOU",[[-1,9658,"。"]],[9659,9659],[9658,9658]]],[1542936494481,["gjx16@GJXAIOU",[[1,9658,"."]],[9658,9658],[9659,9659]]],[1542936500673,["gjx16@GJXAIOU",[[1,9687,"- "]],[9687,9687],[9689,9689]]],[1542936507909,["gjx16@GJXAIOU",[[1,9701,"* "],[1,9746,"* "],[1,9747,"* "],[1,9764,"* "],[1,9765,"* "],[1,9780,"* "],[1,9781,"* "],[1,9790,"* "],[1,9791,"* "],[1,9817,"* "],[1,9818,"* "]],[9701,9841],[9703,9863]]],[1542936511870,["gjx16@GJXAIOU",[[-1,9748,"* "]],[9750,9750],[9748,9748]]],[1542936515997,["gjx16@GJXAIOU",[[1,9701,"  "]],[9701,9701],[9703,9703]]],[1542936517222,["gjx16@GJXAIOU",[[1,9751,"  "]],[9751,9751],[9753,9753]]],[1542936518036,["gjx16@GJXAIOU",[[1,9775,"  "]],[9775,9775],[9777,9777]]],[1542936520405,["gjx16@GJXAIOU",[[1,9811,"  "]],[9811,9811],[9813,9813]]],[1542936521238,["gjx16@GJXAIOU",[[1,9844,"  "]],[9844,9844],[9846,9846]]],[1542936522818,["gjx16@GJXAIOU",[[-1,9841,"* "]],[9841,9843],[9841,9841]]],[1542936524236,["gjx16@GJXAIOU",[[-1,9809," "]],[9810,9810],[9809,9809]]],[1542936525834,["gjx16@GJXAIOU",[[-1,9795," "]],[9796,9796],[9795,9795]]],[1542936527205,["gjx16@GJXAIOU",[[-1,9807,"*"]],[9808,9808],[9807,9807]]],[1542936528354,["gjx16@GJXAIOU",[[-1,9794,"*"]],[9794,9795],[9794,9794]]],[1542936530129,["gjx16@GJXAIOU",[[-1,9772,"*"]],[9772,9772],[9772,9772]]],[1542936531106,["gjx16@GJXAIOU",[[-1,9771,"\n"]],[9772,9772],[9771,9771]]],[1542936533161,["gjx16@GJXAIOU",[[-1,9804,"\n"]],[9804,9804],[9804,9804]]],[1542936534242,["gjx16@GJXAIOU",[[-1,9834,"\n"]],[9834,9834],[9834,9834]]],[1542936536194,["gjx16@GJXAIOU",[[-1,9750,"\n"]],[9750,9750],[9750,9750]]],[1542936556466,["gjx16@GJXAIOU",[[1,9873,"* "],[1,9885,"* "],[1,9886,"*"],[1,9929,"* "],[1,9930,"* "],[1,9946,"* "],[1,9947,"* "],[1,9970,"* "],[1,9971,"* "],[1,9989,"* "],[1,9990,"* "]],[9873,10000],[9875,10021]]],[1542936565162,["gjx16@GJXAIOU",[[1,10024,"* "]],[10024,10034],[10026,10036]]],[1542936568379,["gjx16@GJXAIOU",[[1,10024,"  "]],[10023,10023],[10025,10025]]],[1542936570135,["gjx16@GJXAIOU",[[-1,10022,"\n"]],[10022,10022],[10022,10022]]],[1542936572946,["gjx16@GJXAIOU",[[-1,10006,"* "]],[10006,10006],[10006,10006]]],[1542936574258,["gjx16@GJXAIOU",[[-1,10006,"\n"]],[10006,10006],[10006,10006]]],[1542936575624,["gjx16@GJXAIOU",[[-1,9983,"* "]],[9983,9983],[9983,9983]]],[1542936576300,["gjx16@GJXAIOU",[[-1,9983,"\n"]],[9983,9983],[9983,9983]]],[1542936577983,["gjx16@GJXAIOU",[[-1,9955,"* "]],[9955,9955],[9955,9955]]],[1542936578209,["gjx16@GJXAIOU",[[-1,9955,"\n"]],[9955,9955],[9955,9955]]],[1542936579562,["gjx16@GJXAIOU",[[-1,9934,"* "]],[9934,9934],[9934,9934]]],[1542936580457,["gjx16@GJXAIOU",[[-1,9934,"\n"]],[9934,9934],[9934,9934]]],[1542936582644,["gjx16@GJXAIOU",[[-1,9887,"* "]],[9887,9887],[9887,9887]]],[1542936583418,["gjx16@GJXAIOU",[[-1,9887,"\n"]],[9887,9887],[9887,9887]]],[1542936588044,["gjx16@GJXAIOU",[[1,9887,"  "]],[9887,9887],[9889,9889]]],[1542936590310,["gjx16@GJXAIOU",[[1,9933,"  "]],[9933,9933],[9935,9935]]],[1542936591709,["gjx16@GJXAIOU",[[1,9953,"  "]],[9953,9953],[9955,9955]]],[1542936592566,["gjx16@GJXAIOU",[[1,9980,"  "]],[9980,9980],[9982,9982]]],[1542936594099,["gjx16@GJXAIOU",[[1,10002,"  "]],[10002,10002],[10004,10004]]],[1542936595598,["gjx16@GJXAIOU",[[1,10020,"  "]],[10020,10020],[10022,10022]]],[1542937438772,["gjx16@GJXAIOU",[[-1,9689,"1"]],[9690,9690],[9689,9689]]],[1542937444060,["gjx16@GJXAIOU",[[-1,9793,"2"]],[9794,9794],[9793,9793]]],[1542939198457,["gjx16@GJXAIOU",[[-1,10040,"m01_构造函数的基础.cpp"],[1,10055,"\n"]],[10040,10055],[10041,10041]]],[1542939198796,["gjx16@GJXAIOU",[[1,10043,"\n"]],[10041,10041],[10042,10042]]],[1542939200097,["gjx16@GJXAIOU",[[-1,10043,"\n"]],[10042,10042],[10041,10041]]],[1542939200331,["gjx16@GJXAIOU",[[-1,10042,"\n"]],[10041,10041],[10040,10040]]],[1542939200801,["gjx16@GJXAIOU",[[-1,10039,"d"]],[10040,10040],[10039,10039]]],[1542939201859,["gjx16@GJXAIOU",[[1,10041,"\n"]],[10039,10039],[10040,10040]]],[1542939202951,["gjx16@GJXAIOU",[[1,10040,"··"]],[10040,10040],[10042,10042]]],[1542939204209,["gjx16@GJXAIOU",[[-1,10040,"··"]],[10042,10042],[10040,10040]]],[1542939205743,["gjx16@GJXAIOU",[[1,10040,"```"]],[10040,10040],[10043,10043]]],[1542939205920,["gjx16@GJXAIOU",[[1,10043,"language\n```\n"]],[10043,10043],[10043,10051]]],[1542939206170,["gjx16@GJXAIOU",[[-1,10043,"language"],[1,10051,"p"]],[10043,10051],[10044,10044]]],[1542939207570,["gjx16@GJXAIOU",[[1,10044,"ython"]],[10044,10044],[10049,10049]]],[1542939207838,["gjx16@GJXAIOU",[[1,10050,"\n"]],[10049,10049],[10050,10050]]],[1542939212231,["gjx16@GJXAIOU",[[-1,10044,"ython"],[1,10049,"c"]],[10044,10049],[10045,10045]]],[1542939213709,["gjx16@GJXAIOU",[[1,10045,"++++"]],[10045,10045],[10047,10047]]],[1542939215649,["gjx16@GJXAIOU",[[-1,10043,"pc++"]],[10047,10047],[10043,10043]]],[1542939216687,["gjx16@GJXAIOU",[[1,10043,"c"]],[10043,10043],[10044,10044]]],[1542939220242,["gjx16@GJXAIOU",[[1,10047,"/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}"]],[10047,10047],[10428,10428]]],[1542939223186,["gjx16@GJXAIOU",[[-1,10044,"++"]],[10046,10046],[10044,10044]]],[1542939225473,["gjx16@GJXAIOU",[[1,10044,"pp"]],[10044,10044],[10046,10046]]],[1542939232651,["gjx16@GJXAIOU",[[1,10435,"\n"]],[10432,10432],[10433,10433]]],[1542939235137,["gjx16@GJXAIOU",[[1,10433,"chengxu"]],[10433,10433],[10440,10440]]],[1542939237850,["gjx16@GJXAIOU",[[-1,10433,"chengxu"]],[10440,10440],[10433,10433]]],[1542939243997,["gjx16@GJXAIOU",[[1,10433,"程序运行及偶"]],[10433,10433],[10439,10439]]],[1542939244566,["gjx16@GJXAIOU",[[-1,10437,"及偶"]],[10439,10439],[10437,10437]]],[1542939246502,["gjx16@GJXAIOU",[[1,10437,"结果："]],[10437,10437],[10440,10440]]],[1542939305578,["gjx16@GJXAIOU",[[1,10443,"\n"]],[10440,10440],[10441,10441]]],[1542939306051,["gjx16@GJXAIOU",[[1,10441,"this is gouzaofunction\nthis is a xigoufunction"]],[10441,10441],[10487,10487]]],[1542939308776,["gjx16@GJXAIOU",[[1,10441,"·"]],[10441,10441],[10442,10442]]],[1542939309941,["gjx16@GJXAIOU",[[-1,10441,"·"]],[10442,10442],[10441,10441]]],[1542939310376,["gjx16@GJXAIOU",[[1,10441,"`"]],[10441,10441],[10442,10442]]],[1542939312138,["gjx16@GJXAIOU",[[1,10465,"`"]],[10465,10465],[10466,10466]]],[1542939315035,["gjx16@GJXAIOU",[[1,10464,"`"]],[10464,10464],[10465,10465]]],[1542939315897,["gjx16@GJXAIOU",[[1,10490,"`"]],[10490,10490],[10491,10491]]],[1542939470145,["gjx16@GJXAIOU",[[-1,10501,"****"]],[10501,10505],[10501,10501]]],[1542939473210,["gjx16@GJXAIOU",[[-1,10510,"** **"]],[10510,10515],[10510,10510]]],[1542939474668,["gjx16@GJXAIOU",[[1,10510,"  "]],[10510,10510],[10512,10512]]],[1542939476253,["gjx16@GJXAIOU",[[-1,10514,"** **"]],[10514,10519],[10514,10514]]],[1542939476673,["gjx16@GJXAIOU",[[1,10514," "]],[10514,10514],[10515,10515]]],[1542940494598,["gjx16@GJXAIOU",[[1,10494,"\n"]],[10492,10492],[10493,10493]]],[1542940494885,["gjx16@GJXAIOU",[[1,10495,"\n"]],[10493,10493],[10494,10494]]],[1542940496996,["gjx16@GJXAIOU",[[1,10494,"···"]],[10494,10494],[10497,10497]]],[1542940498668,["gjx16@GJXAIOU",[[-1,10494,"···"]],[10497,10497],[10494,10494]]],[1542940500453,["gjx16@GJXAIOU",[[1,10494,"```"]],[10494,10494],[10497,10497]]],[1542940500688,["gjx16@GJXAIOU",[[1,10497,"language\n```\n"]],[10497,10497],[10497,10505]]],[1542940500973,["gjx16@GJXAIOU",[[-1,10497,"language"],[1,10505,"p"]],[10497,10505],[10498,10498]]],[1542940501272,["gjx16@GJXAIOU",[[1,10498,"y"]],[10498,10498],[10499,10499]]],[1542940501650,["gjx16@GJXAIOU",[[-1,10498,"y"]],[10499,10499],[10498,10498]]],[1542940503157,["gjx16@GJXAIOU",[[1,10498,"cpp"]],[10498,10498],[10501,10501]]],[1542940505819,["gjx16@GJXAIOU",[[-1,10497,"p"]],[10498,10498],[10497,10497]]],[1542940507405,["gjx16@GJXAIOU",[[1,10501,"\n"]],[10500,10500],[10501,10501]]],[1542940508222,["gjx16@GJXAIOU",[[1,10501,"/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}"]],[10501,10501],[11155,11155]]],[1542943190912,["gjx16@GJXAIOU",[[1,12389,"******"]],[12389,12389],[12393,12393]]],[1542943194690,["gjx16@GJXAIOU",[[-1,12389,"******"]],[12389,12395],[12389,12389]]],[1542943197698,["gjx16@GJXAIOU",[[-1,12304,"|"]],[12305,12305],[12304,12304]]],[1542943197971,["gjx16@GJXAIOU",[[-1,12303,"\n"]],[12304,12304],[12303,12303]]],[1542943199206,["gjx16@GJXAIOU",[[1,12303,"****"]],[12303,12303],[12305,12305]]],[1542943201750,["gjx16@GJXAIOU",[[1,12305,"gouzao"]],[12305,12305],[12311,12311]]],[1542943203249,["gjx16@GJXAIOU",[[-1,12309,"ao"]],[12311,12311],[12309,12309]]],[1542943208612,["gjx16@GJXAIOU",[[-1,12305,"gouz"]],[12309,12309],[12305,12305]]],[1542943221896,["gjx16@GJXAIOU",[[1,12305,"构造参数的抵用方式："]],[12305,12305],[12315,12315]]],[1542943224961,["gjx16@GJXAIOU",[[-1,12310,"抵用方式："]],[12315,12315],[12310,12310]]],[1542943229578,["gjx16@GJXAIOU",[[1,12310,"调用方式："]],[12310,12310],[12315,12315]]],[1542943231991,["gjx16@GJXAIOU",[[1,12317,"\n"]],[12317,12317],[12318,12318]]],[1542943233956,["gjx16@GJXAIOU",[[1,12318,"```"]],[12318,12318],[12321,12321]]],[1542943234139,["gjx16@GJXAIOU",[[1,12321,"language\n```\n"]],[12321,12321],[12321,12329]]],[1542943235619,["gjx16@GJXAIOU",[[-1,12321,"language"],[1,12329,"c"]],[12321,12329],[12322,12322]]],[1542943236363,["gjx16@GJXAIOU",[[1,12322,"pp"]],[12322,12322],[12324,12324]]],[1542943236931,["gjx16@GJXAIOU",[[1,12325,"\n"]],[12324,12324],[12325,12325]]],[1542943238269,["gjx16@GJXAIOU",[[1,12325,"/*\n\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}"]],[12325,12325],[12945,12945]]],[1542943272240,["gjx16@GJXAIOU",[[1,16393,"\n"]],[16391,16391],[16392,16392]]],[1542943274280,["gjx16@GJXAIOU",[[1,16392,"```"]],[16392,16392],[16395,16395]]],[1542943274358,["gjx16@GJXAIOU",[[1,16395,"language\n```\n"]],[16395,16395],[16395,16403]]],[1542943275427,["gjx16@GJXAIOU",[[-1,16395,"language"],[1,16403,"c"]],[16395,16403],[16396,16396]]],[1542943276000,["gjx16@GJXAIOU",[[1,16396,"pp"]],[16396,16396],[16398,16398]]],[1542943276745,["gjx16@GJXAIOU",[[1,16399,"\n"]],[16398,16398],[16399,16399]]],[1542943279693,["gjx16@GJXAIOU",[[1,16399,"//"]],[16399,16399],[16401,16401]]],[1542944078029,["gjx16@GJXAIOU",[[1,16400,"*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*"],[1,16401,"\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}"]],[16399,16401],[16940,16940]]],[1542944215023,["gjx16@GJXAIOU",[[-1,16952,"****"]],[16956,16956],[16952,16952]]],[1542944301944,["gjx16@GJXAIOU",[[1,13702,"随机构造函数（）"]],[13702,13702],[13710,13710]]],[1542944312372,["gjx16@GJXAIOU",[[1,13709,"copy构造函数"]],[13709,13709],[13717,13717]]],[1542944322612,["gjx16@GJXAIOU",[[-1,13718,"拷贝构造函数"]],[13724,13724],[13718,13718]]],[1542944337700,["gjx16@GJXAIOU",[[1,13726,"- "]],[13726,13726],[13728,13728]]],[1542944341183,["gjx16@GJXAIOU",[[1,13749,"·"]],[13749,13749],[13750,13750]]],[1542944341894,["gjx16@GJXAIOU",[[-1,13749,"·"]],[13750,13750],[13749,13749]]],[1542944343687,["gjx16@GJXAIOU",[[1,13749,"  - "]],[13749,13749],[13753,13753]]],[1542944346364,["gjx16@GJXAIOU",[[-1,13770,"\n"]],[13770,13770],[13769,13769]]],[1542944347244,["gjx16@GJXAIOU",[[-1,13767,"| "]],[13769,13769],[13767,13767]]],[1542944347767,["gjx16@GJXAIOU",[[-1,13767,"\n"]],[13767,13767],[13766,13766]]],[1542944348928,["gjx16@GJXAIOU",[[-1,13766,"\n"]],[13766,13766],[13765,13765]]],[1542944351135,["gjx16@GJXAIOU",[[1,13766,"  - \n"]],[13765,13765],[13770,13770]]],[1542944354409,["gjx16@GJXAIOU",[[-1,13766,"  - "]],[13770,13770],[13766,13766]]],[1542944358763,["gjx16@GJXAIOU",[[1,13766,"```cpp"]],[13766,13766],[13772,13772]]],[1542955362538,["gjx16@GJXAIOU",[[-1,9552,"**"]],[9554,9554],[9552,9552]]],[1542955364896,["gjx16@GJXAIOU",[[-1,9569,"**"]],[9571,9571],[9569,9569]]],[1542955370958,["gjx16@GJXAIOU",[[1,9543,"**"],[1,9627,"**"]],[9543,9627],[9543,9631]]],[1542955376783,["gjx16@GJXAIOU",[[1,9477,"- "]],[9477,9477],[9479,9479]]],[1542955379273,["gjx16@GJXAIOU",[[1,9536,"- "]],[9536,9536],[9538,9538]]],[1542955381022,["gjx16@GJXAIOU",[[-1,9535,"\n"]],[9535,9535],[9534,9534]]],[1542955420878,["gjx16@GJXAIOU",[[-1,9652,"\n"]],[9652,9652],[9651,9651]]],[1542955431226,["gjx16@GJXAIOU",[[-1,9701,"\n"]],[9701,9701],[9700,9700]]],[1542955434634,["gjx16@GJXAIOU",[[-1,9697,"及调用"]],[9700,9700],[9697,9697]]],[1542955438372,["gjx16@GJXAIOU",[[1,9695,"的"]],[9695,9695],[9696,9696]]],[1542955508970,["gjx16@GJXAIOU",[[-1,9790,"* "]],[9792,9792],[9790,9790]]],[1542955510652,["gjx16@GJXAIOU",[[1,9790,"- "]],[9790,9790],[9792,9792]]],[1542955546881,["gjx16@GJXAIOU",[[1,9799,"："]],[9799,9799],[9800,9800]]],[1542955549650,["gjx16@GJXAIOU",[[1,9698,"："]],[9698,9698],[9699,9699]]],[1542955580203,["gjx16@GJXAIOU",[[-1,9874,"3）"]],[9876,9876],[9874,9874]]],[1542955661362,["gjx16@GJXAIOU",[[1,10492,"---"]],[10492,10492],[10495,10495]]],[1542955662528,["gjx16@GJXAIOU",[[1,10496,"\n"]],[10495,10495],[10496,10496]]],[1542955664521,["gjx16@GJXAIOU",[[1,10496,"析构"]],[10496,10496],[10498,10498]]],[1542955666652,["gjx16@GJXAIOU",[[-1,10496,"析构"]],[10498,10498],[10496,10496]]],[1542955673801,["gjx16@GJXAIOU",[[1,10496,"构造函数和析构哈数"]],[10496,10496],[10505,10505]]],[1542955674773,["gjx16@GJXAIOU",[[-1,10503,"哈数"]],[10505,10505],[10503,10503]]],[1542955685099,["gjx16@GJXAIOU",[[1,10503,"函数用法：乐意"]],[10503,10503],[10510,10510]]],[1542955686155,["gjx16@GJXAIOU",[[-1,10508,"乐意"]],[10510,10510],[10508,10508]]],[1542955699472,["gjx16@GJXAIOU",[[1,10508,"可以用于初始化和释放内存空间"]],[10508,10508],[10522,10522]]],[1542955770100,["gjx16@GJXAIOU",[[1,11191,"#### "]],[11191,11191],[11196,11196]]],[1542955784556,["gjx16@GJXAIOU",[[1,11229,"（）"]],[11229,11229],[11231,11231]]],[1542955789835,["gjx16@GJXAIOU",[[1,11230,"相当远"]],[11230,11230],[11233,11233]]],[1542955790511,["gjx16@GJXAIOU",[[-1,11232,"远"]],[11233,11233],[11232,11232]]],[1542955829908,["gjx16@GJXAIOU",[[1,11232,"于使用构造函数和析构函数与使用原始的初始化方案的区别"]],[11232,11232],[11258,11258]]],[1542955918641,["gjx16@GJXAIOU",[[1,11260,"**"],[1,11274,"**"]],[11260,11274],[11260,11278]]],[1542955922118,["gjx16@GJXAIOU",[[1,11260,"\n"]],[11260,11260],[11261,11261]]],[1542955924691,["gjx16@GJXAIOU",[[-1,11280,"\n"]],[11280,11280],[11279,11279]]],[1542955953975,["gjx16@GJXAIOU",[[-1,11354,"\n"]],[11354,11354],[11353,11353]]],[1542955956425,["gjx16@GJXAIOU",[[-1,11384,"\n"]],[11384,11384],[11383,11383]]],[1542955958553,["gjx16@GJXAIOU",[[-1,11419,"\n"]],[11419,11419],[11418,11418]]],[1542955959607,["gjx16@GJXAIOU",[[-1,11449,"\n"]],[11449,11449],[11448,11448]]],[1542955966086,["gjx16@GJXAIOU",[[-1,11308,"\n"]],[11308,11308],[11307,11307]]],[1542955970899,["gjx16@GJXAIOU",[[1,11347,"- "]],[11347,11347],[11349,11349]]],[1542955973275,["gjx16@GJXAIOU",[[1,11355,"  "]],[11355,11355],[11357,11357]]],[1542955974743,["gjx16@GJXAIOU",[[1,11387,"  "]],[11387,11387],[11389,11389]]],[1542955976367,["gjx16@GJXAIOU",[[1,11357,"- "]],[11357,11357],[11359,11359]]],[1542955978810,["gjx16@GJXAIOU",[[1,11391,"- "]],[11391,11391],[11393,11393]]],[1542955982939,["gjx16@GJXAIOU",[[1,11422,"* "],[1,11428,"* "],[1,11458,"* "]],[11422,11488],[11424,11494]]],[1542955986402,["gjx16@GJXAIOU",[[1,11430,"  "]],[11430,11430],[11432,11432]]],[1542955987365,["gjx16@GJXAIOU",[[1,11464,"  "]],[11464,11464],[11466,11466]]],[1542956007144,["gjx16@GJXAIOU",[[1,11500,"**"],[1,11522,"**"]],[11500,11522],[11500,11526]]],[1542956009274,["gjx16@GJXAIOU",[[1,11500," "]],[11500,11500],[11501,11501]]],[1542956670555,["gjx16@GJXAIOU",[[-1,11500," "]],[11501,11501],[11500,11500]]],[1542956671755,["gjx16@GJXAIOU",[[-1,11499,"\n"]],[11500,11500],[11499,11499]]],[1542956680624,["gjx16@GJXAIOU",[[1,11499,"     "]],[11499,11499],[11504,11504]]],[1542956682697,["gjx16@GJXAIOU",[[-1,11531,"\n"]],[11531,11531],[11530,11530]]],[1542956688385,["gjx16@GJXAIOU",[[1,11531,"* "]],[11531,11541],[11533,11543]]],[1542956690811,["gjx16@GJXAIOU",[[1,11531,"  "]],[11531,11531],[11533,11533]]],[1542956747009,["gjx16@GJXAIOU",[[-1,11547,"| "]],[11549,11549],[11547,11547]]],[1542956747735,["gjx16@GJXAIOU",[[-1,11548,"\n"]],[11547,11547],[11546,11546]]],[1542956748469,["gjx16@GJXAIOU",[[-1,11547,"\n"]],[11546,11546],[11545,11545]]],[1542956763591,["gjx16@GJXAIOU",[[1,11546,"、、"]],[11546,11546],[11548,11548]]],[1542956765508,["gjx16@GJXAIOU",[[-1,11546,"、、"]],[11548,11548],[11546,11546]]],[1542956770696,["gjx16@GJXAIOU",[[1,11546,"```cpp"]],[11546,11546],[11552,11552]]],[1542956783034,["gjx16@GJXAIOU",[[1,12345,"```"]],[12345,12345],[12348,12348]]],[1542956785558,["gjx16@GJXAIOU",[[-1,12342," |"]],[12344,12344],[12342,12342]]],[1542956795693,["gjx16@GJXAIOU",[[-1,11578,"#include \"iostream\"\n\nusing namespace std;\n\n/*\n\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n\n{\n\npublic:\n\n int m;\n\n int getM() const { return m; }\n\n void setM(int val) { m = val; }\n\n int n;\n\n int getN() const { return n; }\n\n void setN(int val) { n = val; }\n\npublic:\n\n int init(int m,int n)\n\n {\n\n this->m = m;\n\n this->n = n;\n\n return 0;\n\n }\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n\n{\n\n int rv =0;\n\n Test21 t1; //无参构造函数的调用方法\n\n Test21 t2;\n\n //t1.init(100, 200);\n\n //t2.init(300, 400);\n\n cout<<t1.getM()<<\" \"<<t1.getN()<<endl;\n\n cout<<t2.getM()<<\" \"<<t2.getN()<<endl;\n\n **//****定义对象数组时，没有机会进行显示初始化**\n\n Test21 arr[3];\n\n //Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n system(\"pause\");\n\n return rv;\n\n}\n"]],[11577,12340],[11577,11577]]],[1542957326004,["gjx16@GJXAIOU",[[1,11578,"#include \"iostream\"\n\nusing namespace std;\n\n/*\n\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\n\t\tthis->n = n;\n\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n"]],[11577,11577],[12350,12350]]],[1542957358413,["gjx16@GJXAIOU",[[-1,11624,"\n"]],[11624,11624],[11623,11623]]],[1542957365195,["gjx16@GJXAIOU",[[-1,11963,"\n"]],[11963,11963],[11962,11962]]],[1542957366240,["gjx16@GJXAIOU",[[-1,11947,"\n"]],[11947,11947],[11946,11946]]],[1542957381917,["gjx16@GJXAIOU",[[1,12354,"\n"]],[12354,12354],[12355,12355]]],[1542957405539,["gjx16@GJXAIOU",[[1,12355,"## "]],[12355,12355],[12358,12358]]],[1542957412014,["gjx16@GJXAIOU",[[-1,12359,"*3.2****"]],[12367,12367],[12359,12359]]],[1542957414391,["gjx16@GJXAIOU",[[1,12358,"()"]],[12358,12358],[12360,12360]]],[1542957416501,["gjx16@GJXAIOU",[[1,12359,"er"]],[12359,12359],[12361,12361]]],[1542957418355,["gjx16@GJXAIOU",[[-1,12359,"er"]],[12361,12361],[12359,12359]]],[1542957419848,["gjx16@GJXAIOU",[[1,12359,"二"]],[12359,12359],[12360,12360]]],[1542957424848,["gjx16@GJXAIOU",[[-1,12371,"**"]],[12373,12373],[12371,12371]]],[1542957440871,["gjx16@GJXAIOU",[[1,12403,"\n"]],[12402,12402],[12403,12403]]],[1542957447852,["gjx16@GJXAIOU",[[-1,12429,"\n"]],[12429,12429],[12428,12428]]],[1542957532615,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"]],[12361,12361],[12373,12373]]],[1542957532615,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"]],[12373,12373],[12361,12361]]],[1542957491108,["gjx16@GJXAIOU",[[-1,13053,"//有参数构造函数的三种调用方法\n\nclass Test\n\n{\n\nprivate:\n\n int a;\n\n int b;\n\npublic:\n\n //无参数构造函数\n\n Test()\n\n {\n\n ;\n\n }\n\n //带参数的构造函数\n\n Test(int a, int b)\n\n {\n\n ;\n\n }\n\n //赋值构造函数\n\n Test(const Test &obj)\n\n {\n\n ;\n\n }\n\npublic:\n\n void init(int _a, int _b)\n\n {\n\n a = _a;\n\n b = _b;\n\n }\n\n};\n\n |\n"]],[13053,13321],[13053,13053]]],[1542957514211,["gjx16@GJXAIOU",[[-1,13054,"**1****无参数构造函数**\n\n  调用方法： Test t1, t2;\n\n**2****有参构造函数**\n\n有参构造函数的三种调用方法\n\n| \n\n//有参数构造函数的三种调用方法\n\nclass Test5\n\n{\n\nprivate:\n\n int a;\n\npublic:\n\n //带参数的构造函数\n\n Test5(int a)\n\n {\n\n printf(\"\\na:%d\", a);\n\n }\n\n Test5(int a, int b)\n\n {\n\n printf(\"\\na:%d b:%d\", a, b);\n\n }\n\npublic:\n\n};\n\nint main55()\n\n{\n\n Test5 t1(10); //c++编译器默认调用有参构造函数  括号法\n\n Test5 t2 = (20, 10); //c++编译器默认调用有参构造函数  等号法\n\n Test5 t3 = Test5(30); //程序员手工调用构造函数  产生了一个对象  直接调用构造构造函数法\n\n system(\"pause\");\n\n return 0;\n\n}\n\n |"]],[13054,13525],[13054,13054]]],[1542957525006,["gjx16@GJXAIOU",[[-1,13055,"\n"]],[13054,13054],[13053,13053]]],[1542957525700,["gjx16@GJXAIOU",[[-1,13054,"\n"]],[13053,13053],[13052,13052]]],[1542957592679,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"]],[12361,12361],[12373,12373]]],[1542957592679,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"]],[12373,12373],[12361,12361]]],[1542957546365,["gjx16@GJXAIOU",[[1,12411,"定义和"]],[12411,12411],[12414,12414]]],[1542957559435,["gjx16@GJXAIOU",[[-1,13060,"****"]],[13064,13064],[13060,13060]]],[1542957578311,["gjx16@GJXAIOU",[[1,13057,"\n"]],[13056,13056],[13057,13057]]],[1542957579063,["gjx16@GJXAIOU",[[1,13058,"\n"]],[13057,13057],[13058,13058]]],[1542957579375,["gjx16@GJXAIOU",[[1,13059,"\n"]],[13058,13058],[13059,13059]]],[1542957652660,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12411,"的"],[-1,12414,"的"],[-1,13063,"*"],[1,13064,"3"]],[12361,12361],[13065,13065]]],[1542957652660,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12410,"的"],[1,12414,"的"],[1,13062,"*"],[-1,13062,"3"]],[13065,13065],[12361,12361]]],[1542957649588,["gjx16@GJXAIOU",[[-1,15771,"```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```"]],[15771,16323],[15771,15771]]],[1542957712658,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12411,"的"],[-1,12414,"的"],[-1,13063,"*"],[1,13064,"3"],[-1,15771,"`"],[1,15772,"\n"]],[12361,12361],[15773,15773]]],[1542957712658,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12410,"的"],[1,12414,"的"],[1,13062,"*"],[-1,13062,"3"],[1,15770,"`"],[-1,15770,"\n"]],[15773,15773],[12361,12361]]],[1542957659975,["gjx16@GJXAIOU",[[1,13056,"```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```"]],[13056,13056],[13608,13608]]],[1542957679340,["gjx16@GJXAIOU",[[1,13055,"三种构造函数的调用方式："]],[13055,13055],[13067,13067]]],[1542957772659,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12411,"的"],[-1,12414,"的"],[1,13055,"\n"],[-1,13624,"\n*"],[1,13628,"3"],[-1,16335,"`"],[1,16336,"\n"]],[12361,12361],[16337,16337]]],[1542957772659,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12410,"的"],[1,12414,"的"],[-1,13054,"\n"],[1,13624,"\n*"],[-1,13626,"3"],[1,16334,"`"],[-1,16334,"\n"]],[16337,16337],[12361,12361]]],[1542957754738,["gjx16@GJXAIOU",[[1,12406,"1."]],[12406,12406],[12408,12408]]],[1542957832660,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,13057,"\n"],[-1,13626,"\n*"],[1,13630,"3"],[-1,16337,"`"],[1,16338,"\n"]],[12361,12361],[16339,16339]]],[1542957832660,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,13056,"\n"],[1,13626,"\n*"],[-1,13628,"3"],[1,16336,"`"],[-1,16336,"\n"]],[16339,16339],[12361,12361]]],[1542957773584,["gjx16@GJXAIOU",[[-1,13628,"3"]],[13629,13629],[13628,13628]]],[1542957775205,["gjx16@GJXAIOU",[[1,13628,"2，"]],[13628,13628],[13630,13630]]],[1542957824074,["gjx16@GJXAIOU",[[-1,14262," |\n| "],[1,14267,"·"]],[14262,14262],[14263,14263]]],[1542957825239,["gjx16@GJXAIOU",[[1,14263,"··"]],[14263,14263],[14265,14265]]],[1542957827276,["gjx16@GJXAIOU",[[-1,14262,"···"]],[14265,14265],[14262,14262]]],[1542957828797,["gjx16@GJXAIOU",[[1,14262,"```"]],[14262,14262],[14265,14265]]],[1542957892659,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12405,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[-1,16336,"`"],[1,16337,"\n"]],[12361,12361],[16338,16338]]],[1542957892659,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12404,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[1,16335,"`"],[-1,16335,"\n"]],[16338,16338],[12361,12361]]],[1542957833992,["gjx16@GJXAIOU",[[1,14275,"```"]],[14275,14275],[14278,14278]]],[1542957834245,["gjx16@GJXAIOU",[[1,14278,"language\n```\n"]],[14278,14278],[14278,14286]]],[1542957835690,["gjx16@GJXAIOU",[[-1,14278,"language"],[1,14286,"c"]],[14278,14286],[14279,14279]]],[1542957836482,["gjx16@GJXAIOU",[[1,14279,"pp"]],[14279,14279],[14281,14281]]],[1542957840304,["gjx16@GJXAIOU",[[-1,14282,"```"]],[14282,14285],[14282,14282]]],[1542957847913,["gjx16@GJXAIOU",[[1,14458,"```"]],[14458,14458],[14461,14461]]],[1542957854089,["gjx16@GJXAIOU",[[-1,14490," |"]],[14490,14492],[14490,14490]]],[1542957855784,["gjx16@GJXAIOU",[[-1,14491,"\n"]],[14490,14490],[14489,14489]]],[1542957857020,["gjx16@GJXAIOU",[[-1,14490,"\n"]],[14490,14490],[14489,14489]]],[1542957952662,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14275,"\n"],[-1,14281,"\n"],[1,14458,"\n"],[-1,14461,"\n"],[-1,16343,"`"],[1,16344,"\n"]],[12361,12361],[16345,16345]]],[1542957952662,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14274,"\n"],[1,14281,"\n"],[-1,14457,"\n"],[1,14461,"\n"],[1,16342,"`"],[-1,16342,"\n"]],[16345,16345],[12361,12361]]],[1542957894144,["gjx16@GJXAIOU",[[-1,14499,"| \n"]],[14499,14502],[14499,14499]]],[1542957896220,["gjx16@GJXAIOU",[[1,14499,"```"]],[14499,14499],[14502,14502]]],[1542957896302,["gjx16@GJXAIOU",[[1,14502,"language\n```\n"]],[14502,14502],[14502,14510]]],[1542957898529,["gjx16@GJXAIOU",[[-1,14502,"language"],[1,14510,"c"]],[14502,14510],[14503,14503]]],[1542957899196,["gjx16@GJXAIOU",[[1,14503,"pp"]],[14503,14503],[14505,14505]]],[1542957902192,["gjx16@GJXAIOU",[[-1,14506,"```"]],[14506,14509],[14506,14506]]],[1542957913918,["gjx16@GJXAIOU",[[1,15223,"`"],[1,15225,"`"]],[15223,15225],[15223,15227]]],[1542957914298,["gjx16@GJXAIOU",[[1,15224,"`"],[1,15226,"`"]],[15223,15227],[15223,15229]]],[1542957917229,["gjx16@GJXAIOU",[[1,15226,"`"],[1,15227,"`"]],[15226,15229],[15226,15231]]],[1542957921800,["gjx16@GJXAIOU",[[-1,15225," `|```"]],[15225,15231],[15225,15225]]],[1542957922580,["gjx16@GJXAIOU",[[1,15225,"`"]],[15225,15225],[15226,15226]]],[1542957926851,["gjx16@GJXAIOU",[[-1,15237,"| "]],[15237,15239],[15237,15237]]],[1542957935158,["gjx16@GJXAIOU",[[1,15239,"#"]],[15239,15239],[15240,15240]]],[1542957939047,["gjx16@GJXAIOU",[[1,15238,"```"]],[15238,15238],[15241,15241]]],[1542957939289,["gjx16@GJXAIOU",[[1,15241,"language\n```\n"]],[15241,15241],[15241,15249]]],[1542957940201,["gjx16@GJXAIOU",[[-1,15241,"language"],[1,15249,"c"]],[15241,15249],[15242,15242]]],[1542957941127,["gjx16@GJXAIOU",[[1,15242,"pp"]],[15242,15242],[15244,15244]]],[1542957943683,["gjx16@GJXAIOU",[[-1,15245,"```"]],[15245,15248],[15245,15245]]],[1542958012684,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14275,"\n"],[-1,14281,"\n"],[1,14458,"\n"],[-1,14461,"\n"],[1,14499,"\n"],[-1,14505,"\n"],[1,15223,"\n"],[-1,15226,"|"],[-1,15237," "],[1,15238,"\n\n"],[-1,15248,"\n"],[-1,16356,"`"],[1,16357,"\n"]],[12361,12361],[16358,16358]]],[1542958012685,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14274,"\n"],[1,14281,"\n"],[-1,14457,"\n"],[1,14461,"\n"],[-1,14498,"\n"],[1,14505,"\n"],[-1,15222,"\n"],[1,15226,"|"],[1,15236," "],[-1,15236,"\n\n"],[1,15248,"\n"],[1,16355,"`"],[-1,16355,"\n"]],[16358,16358],[12361,12361]]],[1542957964166,["gjx16@GJXAIOU",[[1,16218,"\n"]],[16217,16217],[16218,16218]]],[1542957966692,["gjx16@GJXAIOU",[[1,16218,"```"]],[16218,16218],[16221,16221]]],[1542957969480,["gjx16@GJXAIOU",[[-1,16209," |\n|  |\n"]],[16208,16216],[16208,16208]]],[1542957972713,["gjx16@GJXAIOU",[[1,16214,"\n"]],[16213,16213],[16214,16214]]],[1542958005263,["gjx16@GJXAIOU",[[1,16215,"\n"]],[16214,16214],[16215,16215]]],[1542958072669,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14275,"\n"],[-1,14281,"\n"],[1,14458,"\n"],[-1,14461,"\n"],[1,14499,"\n"],[-1,14505,"\n"],[1,15223,"\n"],[-1,15226,"|"],[-1,15237," "],[1,15238,"\n\n"],[-1,15248,"\n"],[1,16210,"\n"],[-1,16213,"\n"],[-1,16354,"`"],[1,16355,"\n"]],[12361,12361],[16356,16356]]],[1542958072669,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14274,"\n"],[1,14281,"\n"],[-1,14457,"\n"],[1,14461,"\n"],[-1,14498,"\n"],[1,14505,"\n"],[-1,15222,"\n"],[1,15226,"|"],[1,15236," "],[-1,15236,"\n\n"],[1,15248,"\n"],[-1,16209,"\n"],[1,16213,"\n"],[1,16353,"`"],[-1,16353,"\n"]],[16356,16356],[12361,12361]]],[1542958013255,["gjx16@GJXAIOU",[[1,16215,"![全为]($resource/%E5%85%A8%E4%B8%BA.png)"]],[16215,16215],[16255,16255]]],[1542958015804,["gjx16@GJXAIOU",[[1,16255,"\n"]],[16254,16254],[16255,16255]]],[1542958033317,["gjx16@GJXAIOU",[[-1,16259,"****"]],[16263,16263],[16259,16259]]],[1542958041182,["gjx16@GJXAIOU",[[1,16280,"  - "]],[16280,16280],[16284,16284]]],[1542958042755,["gjx16@GJXAIOU",[[1,16296,"  "]],[16296,16296],[16298,16298]]],[1542958046153,["gjx16@GJXAIOU",[[1,16337,"  - "]],[16337,16337],[16341,16341]]],[1542958047738,["gjx16@GJXAIOU",[[1,16353,"  "]],[16353,16353],[16355,16355]]],[1542958050384,["gjx16@GJXAIOU",[[1,16269,"- "]],[16269,16269],[16271,16271]]],[1542958055745,["gjx16@GJXAIOU",[[-1,16407,"**3.3"],[1,16412,"\n"]],[16407,16412],[16408,16408]]],[1542958057159,["gjx16@GJXAIOU",[[1,16408,"####"]],[16408,16408],[16412,16412]]],[1542958058567,["gjx16@GJXAIOU",[[-1,16411,"#"]],[16412,16412],[16411,16411]]],[1542958060616,["gjx16@GJXAIOU",[[1,16411," ()"]],[16411,16411],[16414,16414]]],[1542958063160,["gjx16@GJXAIOU",[[1,16413,"san"]],[16413,16413],[16416,16416]]],[1542958065273,["gjx16@GJXAIOU",[[-1,16413,"san"]],[16416,16416],[16413,16413]]],[1542958067329,["gjx16@GJXAIOU",[[1,16413,"三"]],[16413,16413],[16414,16414]]],[1542958070662,["gjx16@GJXAIOU",[[-1,16425,"**"]],[16425,16427],[16425,16425]]],[1542958133046,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14275,"\n"],[-1,14281,"\n"],[1,14458,"\n"],[-1,14461,"\n"],[1,14499,"\n"],[-1,14505,"\n"],[1,15223,"\n"],[-1,15226,"|"],[-1,15237," "],[1,15238,"\n\n"],[-1,15248,"\n"],[1,16210,"\n"],[-1,16256,"\n*"],[1,16260,"4"],[1,16269,"\n"],[-1,16271,"\n"],[1,16282,"\n"],[-1,16286,"\n"],[1,16298,"\n"],[-1,16300,"\n"],[1,16338,"\n"],[-1,16343,"\n"],[1,16355,"\n"],[-1,16357,"\n"],[-1,16404,"`"],[1,16405,"\n\n"],[-1,16415,"3"],[-1,16425,"*"],[1,16426,"究"]],[12361,12361],[16427,16427]]],[1542958133046,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14274,"\n"],[1,14281,"\n"],[-1,14457,"\n"],[1,14461,"\n"],[-1,14498,"\n"],[1,14505,"\n"],[-1,15222,"\n"],[1,15226,"|"],[1,15236," "],[-1,15236,"\n\n"],[1,15248,"\n"],[-1,16209,"\n"],[1,16256,"\n*"],[-1,16258,"4"],[-1,16268,"\n"],[1,16271,"\n"],[-1,16281,"\n"],[1,16286,"\n"],[-1,16297,"\n"],[1,16300,"\n"],[-1,16337,"\n"],[1,16343,"\n"],[-1,16354,"\n"],[1,16357,"\n"],[1,16403,"`"],[-1,16403,"\n\n"],[1,16415,"3"],[1,16424,"*"],[-1,16424,"究"]],[16427,16427],[12361,12361]]],[1542958085636,["gjx16@GJXAIOU",[[-1,15247,"#第四个应用场景\n\n#include \"iostream\"\n\nusing namespace std;\n\nclass Location\n\n{\n\npublic:\n\n Location( int xx = 0 , int yy = 0 )\n\n {\n\n X = xx ; Y = yy ; cout << \"Constructor Object.\\n\" ;\n\n }\n\n Location( const Location & p )      //复制构造函数\n\n {\n\n X = p.X ; Y = p.Y ; cout << \"Copy_constructor called.\" << endl ;\n\n }\n\n ~Location()\n\n {\n\n cout << X << \",\" << Y << \" Object destroyed.\" << endl ;\n\n }\n\n int GetX () { return X ; } int GetY () { return Y ; }\n\nprivate : int X , Y ;\n\n} ;\n\n//alt + f8 排版\n\nvoid f ( Location p )  \n\n{\n\n cout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl ;\n\n}\n\nLocation g()\n\n{\n\n Location A(1, 2);\n\n return A;\n\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n\n{ \n\n //若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n //Location B;\n\n //B = g(); **//****用匿名对象** **赋值** **给B****对象，然后匿名对象析构**\n\n //若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象\n\n Location B = g();\n\n cout<<\"传智扫地僧测试\"<<endl;\n\n}\n\nvoid main()\n\n{ \n\n mainobjplay();\n\n system(\"pause\");\n\n}\n"]],[15247,16208],[15247,15247]]],[1542958087772,["gjx16@GJXAIOU",[[-1,15248,"\n"]],[15247,15247],[15246,15246]]],[1542958088058,["gjx16@GJXAIOU",[[-1,15247,"\n"]],[15246,15246],[15245,15245]]],[1542958193073,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14275,"\n"],[-1,14281,"\n"],[1,14458,"\n"],[-1,14461,"\n"],[1,14499,"\n"],[-1,14505,"\n"],[1,15223,"\n"],[-1,15226,"|"],[-1,15237," "],[1,15238,"\n\n"],[-1,15293,"\n*"],[1,15297,"4"],[1,15306,"\n"],[-1,15308,"\n"],[1,15319,"\n"],[-1,15323,"\n"],[1,15335,"\n"],[-1,15337,"\n"],[1,15375,"\n"],[-1,15380,"\n"],[1,15392,"\n"],[-1,15394,"\n"],[-1,15441,"`"],[1,15442,"\n\n"],[-1,15452,"3"],[-1,15462,"*"],[1,15463,"究"]],[12361,12361],[15464,15464]]],[1542958193073,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14274,"\n"],[1,14281,"\n"],[-1,14457,"\n"],[1,14461,"\n"],[-1,14498,"\n"],[1,14505,"\n"],[-1,15222,"\n"],[1,15226,"|"],[1,15236," "],[-1,15236,"\n\n"],[1,15293,"\n*"],[-1,15295,"4"],[-1,15305,"\n"],[1,15308,"\n"],[-1,15318,"\n"],[1,15323,"\n"],[-1,15334,"\n"],[1,15337,"\n"],[-1,15374,"\n"],[1,15380,"\n"],[-1,15391,"\n"],[1,15394,"\n"],[1,15440,"`"],[-1,15440,"\n\n"],[1,15452,"3"],[1,15461,"*"],[-1,15461,"究"]],[15464,15464],[12361,12361]]],[1542958183568,["gjx16@GJXAIOU",[[1,15245,"#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g(); **//****用匿名对象** **赋值** **给B****对象，然后匿名对象析构**\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象\n\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n"]],[15245,15245],[16159,16159]]],[1542958253059,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14275,"\n"],[-1,14281,"\n"],[1,14458,"\n"],[-1,14461,"\n"],[1,14499,"\n"],[-1,14505,"\n"],[1,15223,"\n"],[-1,15226,"|"],[-1,15237," "],[1,15238,"\n\n"],[-1,16207,"\n*"],[1,16211,"4"],[1,16220,"\n"],[-1,16222,"\n"],[1,16233,"\n"],[-1,16237,"\n"],[1,16249,"\n"],[-1,16251,"\n"],[1,16289,"\n"],[-1,16294,"\n"],[1,16306,"\n"],[-1,16308,"\n"],[-1,16355,"`"],[1,16356,"\n\n"],[-1,16366,"3"],[-1,16376,"*"],[1,16377,"究"]],[12361,12361],[16378,16378]]],[1542958253059,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14274,"\n"],[1,14281,"\n"],[-1,14457,"\n"],[1,14461,"\n"],[-1,14498,"\n"],[1,14505,"\n"],[-1,15222,"\n"],[1,15226,"|"],[1,15236," "],[-1,15236,"\n\n"],[1,16207,"\n*"],[-1,16209,"4"],[-1,16219,"\n"],[1,16222,"\n"],[-1,16232,"\n"],[1,16237,"\n"],[-1,16248,"\n"],[1,16251,"\n"],[-1,16288,"\n"],[1,16294,"\n"],[-1,16305,"\n"],[1,16308,"\n"],[1,16354,"`"],[-1,16354,"\n\n"],[1,16366,"3"],[1,16375,"*"],[-1,16375,"究"]],[16378,16378],[12361,12361]]],[1542958200756,["gjx16@GJXAIOU",[[-1,13629,"，"]],[13630,13630],[13629,13629]]],[1542958201267,["gjx16@GJXAIOU",[[1,13629,"。"]],[13629,13629],[13630,13630]]],[1542958202628,["gjx16@GJXAIOU",[[-1,13629,"。"]],[13630,13630],[13629,13629]]],[1542958203204,["gjx16@GJXAIOU",[[1,13629,"."]],[13629,13629],[13630,13630]]],[1542958203815,["gjx16@GJXAIOU",[[-1,13629,"."]],[13630,13630],[13629,13629]]],[1542958205580,["gjx16@GJXAIOU",[[1,13629,"."]],[13629,13629],[13630,13630]]],[1542958213310,["gjx16@GJXAIOU",[[1,14267,"  - "]],[14267,14267],[14271,14271]]],[1542958217485,["gjx16@GJXAIOU",[[1,14494,"  - "]],[14494,14494],[14498,14498]]],[1542958223763,["gjx16@GJXAIOU",[[1,15236,"  - "]],[15236,15236],[15240,15240]]],[1542958226044,["gjx16@GJXAIOU",[[-1,15227,"\n"]],[15227,15227],[15226,15226]]],[1542958228708,["gjx16@GJXAIOU",[[-1,15191,"\n"]],[15191,15191],[15190,15190]]],[1542958229408,["gjx16@GJXAIOU",[[-1,15187,"\n"]],[15187,15187],[15186,15186]]],[1542958232133,["gjx16@GJXAIOU",[[-1,15171,"\n"]],[15171,15171],[15170,15170]]],[1542958232962,["gjx16@GJXAIOU",[[-1,15104,"\n"]],[15104,15104],[15103,15103]]],[1542958234413,["gjx16@GJXAIOU",[[-1,15100,"\n"]],[15100,15100],[15099,15099]]],[1542958235455,["gjx16@GJXAIOU",[[-1,15077,"\n"]],[15077,15077],[15076,15076]]],[1542958236245,["gjx16@GJXAIOU",[[-1,15015,"\n"]],[15015,15015],[15014,15014]]],[1542958238504,["gjx16@GJXAIOU",[[-1,15012,"\n"]],[15012,15012],[15011,15011]]],[1542958240245,["gjx16@GJXAIOU",[[-1,14967,"\n"]],[14967,14967],[14966,14966]]],[1542958242149,["gjx16@GJXAIOU",[[-1,14888,"\n"]],[14888,14888],[14887,14887]]],[1542958243309,["gjx16@GJXAIOU",[[-1,14884,"\n"]],[14884,14884],[14883,14883]]],[1542958245093,["gjx16@GJXAIOU",[[-1,14822,"\n"]],[14822,14822],[14821,14821]]],[1542958247021,["gjx16@GJXAIOU",[[-1,14804,"\n"]],[14804,14804],[14803,14803]]],[1542958248256,["gjx16@GJXAIOU",[[-1,14824,"\n"]],[14824,14824],[14823,14823]]],[1542958249928,["gjx16@GJXAIOU",[[-1,14733,"\n"]],[14733,14733],[14732,14732]]],[1542958251230,["gjx16@GJXAIOU",[[-1,14736,"\n"]],[14736,14736],[14735,14735]]],[1542958313069,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13624,"\n"],[1,13628,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14266,"\n"],[-1,14271,"\n"],[1,14279,"\n"],[-1,14285,"\n"],[1,14462,"\n"],[-1,14465,"\n"],[1,14494,"\n"],[-1,14498,"\n"],[1,14506,"\n"],[-1,14516,"\n"],[1,15214,"\n"],[-1,15217,"|"],[1,15218,"\n"],[-1,15223,"\n"],[-1,15232," "],[1,15233,"\n\n"],[-1,16202,"\n*"],[1,16206,"4"],[1,16215,"\n"],[-1,16217,"\n"],[1,16228,"\n"],[-1,16232,"\n"],[1,16244,"\n"],[-1,16246,"\n"],[1,16284,"\n"],[-1,16289,"\n"],[1,16301,"\n"],[-1,16303,"\n"],[-1,16350,"`"],[1,16351,"\n\n"],[-1,16361,"3"],[-1,16371,"*"],[1,16372,"究"]],[12361,12361],[16373,16373]]],[1542958313069,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13624,"\n"],[-1,13627,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14265,"\n"],[1,14271,"\n"],[-1,14278,"\n"],[1,14285,"\n"],[-1,14461,"\n"],[1,14465,"\n"],[-1,14493,"\n"],[1,14498,"\n"],[-1,14505,"\n"],[1,14516,"\n"],[-1,15213,"\n"],[1,15217,"|"],[-1,15217,"\n"],[1,15223,"\n"],[1,15231," "],[-1,15231,"\n\n"],[1,16202,"\n*"],[-1,16204,"4"],[-1,16214,"\n"],[1,16217,"\n"],[-1,16227,"\n"],[1,16232,"\n"],[-1,16243,"\n"],[1,16246,"\n"],[-1,16283,"\n"],[1,16289,"\n"],[-1,16300,"\n"],[1,16303,"\n"],[1,16349,"`"],[-1,16349,"\n\n"],[1,16361,"3"],[1,16370,"*"],[-1,16370,"究"]],[16373,16373],[12361,12361]]],[1542958253726,["gjx16@GJXAIOU",[[-1,14624,"\n"]],[14624,14624],[14623,14623]]],[1542958254882,["gjx16@GJXAIOU",[[-1,14627,"\n"]],[14627,14627],[14626,14626]]],[1542958255873,["gjx16@GJXAIOU",[[-1,14680,"\n"]],[14680,14680],[14679,14679]]],[1542958258181,["gjx16@GJXAIOU",[[-1,14574,"\n"]],[14574,14574],[14573,14573]]],[1542958259229,["gjx16@GJXAIOU",[[-1,14576,"\n"]],[14576,14576],[14575,14575]]],[1542958261441,["gjx16@GJXAIOU",[[-1,14536,"\n"]],[14536,14536],[14535,14535]]],[1542958262326,["gjx16@GJXAIOU",[[-1,14515,"\n"]],[14515,14515],[14514,14514]]],[1542958271816,["gjx16@GJXAIOU",[[-1,16197,"4"]],[16198,16198],[16197,16197]]],[1542958273207,["gjx16@GJXAIOU",[[1,16197,"3."]],[16197,16197],[16199,16199]]],[1542958433068,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13624,"\n"],[1,13628,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14266,"\n"],[-1,14271,"\n"],[1,14279,"\n"],[-1,14285,"\n"],[1,14462,"\n"],[-1,14465,"\n"],[1,14494,"\n"],[-1,14498,"\n"],[1,14506,"\n"],[-1,14515,"\n"],[1,15207,"\n"],[-1,15210,"|"],[1,15211,"\n"],[-1,15216,"\n"],[-1,15225," "],[1,15226,"\n\n"],[-1,16195,"\n"],[1,16196,"*"],[-1,16199,"*"],[1,16209,"\n"],[-1,16211,"\n"],[1,16222,"\n"],[-1,16226,"\n"],[1,16238,"\n"],[-1,16240,"\n"],[1,16278,"\n"],[-1,16283,"\n"],[1,16295,"\n"],[-1,16297,"\n"],[-1,16344,"`"],[1,16345,"\n\n"],[-1,16355,"3"],[-1,16365,"*"],[1,16366,"究"]],[12361,12361],[16367,16367]]],[1542958433068,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13624,"\n"],[-1,13627,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14265,"\n"],[1,14271,"\n"],[-1,14278,"\n"],[1,14285,"\n"],[-1,14461,"\n"],[1,14465,"\n"],[-1,14493,"\n"],[1,14498,"\n"],[-1,14505,"\n"],[1,14515,"\n"],[-1,15206,"\n"],[1,15210,"|"],[-1,15210,"\n"],[1,15216,"\n"],[1,15224," "],[-1,15224,"\n\n"],[1,16195,"\n"],[-1,16195,"*"],[1,16199,"*"],[-1,16208,"\n"],[1,16211,"\n"],[-1,16221,"\n"],[1,16226,"\n"],[-1,16237,"\n"],[1,16240,"\n"],[-1,16277,"\n"],[1,16283,"\n"],[-1,16294,"\n"],[1,16297,"\n"],[1,16343,"`"],[-1,16343,"\n\n"],[1,16355,"3"],[1,16364,"*"],[-1,16364,"究"]],[16367,16367],[12361,12361]]],[1542958386333,["gjx16@GJXAIOU",[[-1,16237,"\n"]],[16237,16237],[16236,16236]]],[1542958391192,["gjx16@GJXAIOU",[[-1,16221,"\n"]],[16221,16221],[16220,16220]]],[1542958393357,["gjx16@GJXAIOU",[[-1,16292,"\n"]],[16292,16292],[16291,16291]]],[1542958493069,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14266,"\n"],[-1,14271,"\n"],[1,14279,"\n"],[-1,14285,"\n"],[1,14462,"\n"],[-1,14465,"\n"],[1,14494,"\n"],[-1,14498,"\n"],[1,14506,"\n"],[-1,14515,"\n"],[1,15207,"\n"],[-1,15210,"|"],[1,15211,"\n"],[-1,15216,"\n"],[-1,15225," "],[1,15226,"\n\n"],[-1,16195,"\n"],[1,16196,"*"],[-1,16199,"*"],[1,16209,"\n"],[-1,16211,"\n"],[1,16221,"\n"],[-1,16225,"\n"],[1,16236,"\n"],[-1,16238,"\n"],[1,16276,"\n"],[-1,16281,"\n"],[1,16292,"\n"],[-1,16294,"\n"],[-1,16341,"`"],[1,16342,"\n\n"],[-1,16352,"3"],[-1,16362,"*"],[1,16363,"究"]],[12361,12361],[16364,16364]]],[1542958493069,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14265,"\n"],[1,14271,"\n"],[-1,14278,"\n"],[1,14285,"\n"],[-1,14461,"\n"],[1,14465,"\n"],[-1,14493,"\n"],[1,14498,"\n"],[-1,14505,"\n"],[1,14515,"\n"],[-1,15206,"\n"],[1,15210,"|"],[-1,15210,"\n"],[1,15216,"\n"],[1,15224," "],[-1,15224,"\n\n"],[1,16195,"\n"],[-1,16195,"*"],[1,16199,"*"],[-1,16208,"\n"],[1,16211,"\n"],[-1,16220,"\n"],[1,16225,"\n"],[-1,16235,"\n"],[1,16238,"\n"],[-1,16275,"\n"],[1,16281,"\n"],[-1,16291,"\n"],[1,16294,"\n"],[1,16340,"`"],[-1,16340,"\n\n"],[1,16352,"3"],[1,16361,"*"],[-1,16361,"究"]],[16364,16364],[12361,12361]]],[1542958476357,["gjx16@GJXAIOU",[[-1,16410,"\n"]],[16410,16410],[16409,16409]]],[1542958478982,["gjx16@GJXAIOU",[[-1,16444,"\n"]],[16444,16444],[16443,16443]]],[1542958481214,["gjx16@GJXAIOU",[[-1,16403,"拷"]],[16404,16404],[16403,16403]]],[1542958484429,["gjx16@GJXAIOU",[[1,16403,"kao"]],[16403,16403],[16406,16406]]],[1542958486379,["gjx16@GJXAIOU",[[-1,16403,"kao"]],[16406,16406],[16403,16403]]],[1542958491914,["gjx16@GJXAIOU",[[1,16403,"拷"]],[16403,16403],[16404,16404]]],[1542958553074,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14266,"\n"],[-1,14271,"\n"],[1,14279,"\n"],[-1,14285,"\n"],[1,14462,"\n"],[-1,14465,"\n"],[1,14494,"\n"],[-1,14498,"\n"],[1,14506,"\n"],[-1,14515,"\n"],[1,15207,"\n"],[-1,15210,"|"],[1,15211,"\n"],[-1,15216,"\n"],[-1,15225," "],[1,15226,"\n\n"],[-1,16195,"\n"],[1,16196,"*"],[-1,16199,"*"],[1,16209,"\n"],[-1,16211,"\n"],[1,16221,"\n"],[-1,16225,"\n"],[1,16236,"\n"],[-1,16238,"\n"],[1,16277,"\n"],[-1,16281,"\n"],[1,16292,"\n"],[-1,16294,"\n"],[-1,16341,"`"],[1,16342,"\n\n"],[-1,16352,"3"],[-1,16362,"*"],[1,16363,"究"],[-1,16403,"拷"],[1,16404,"认"]],[12361,12361],[16405,16405]]],[1542958553074,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14265,"\n"],[1,14271,"\n"],[-1,14278,"\n"],[1,14285,"\n"],[-1,14461,"\n"],[1,14465,"\n"],[-1,14493,"\n"],[1,14498,"\n"],[-1,14505,"\n"],[1,14515,"\n"],[-1,15206,"\n"],[1,15210,"|"],[-1,15210,"\n"],[1,15216,"\n"],[1,15224," "],[-1,15224,"\n\n"],[1,16195,"\n"],[-1,16195,"*"],[1,16199,"*"],[-1,16208,"\n"],[1,16211,"\n"],[-1,16220,"\n"],[1,16225,"\n"],[-1,16235,"\n"],[1,16238,"\n"],[-1,16276,"\n"],[1,16281,"\n"],[-1,16291,"\n"],[1,16294,"\n"],[1,16340,"`"],[-1,16340,"\n\n"],[1,16352,"3"],[1,16361,"*"],[-1,16361,"究"],[1,16402,"拷"],[-1,16402,"认"]],[16405,16405],[12361,12361]]],[1542958494669,["gjx16@GJXAIOU",[[-1,16506,"\n"]],[16506,16506],[16505,16505]]],[1542958500287,["gjx16@GJXAIOU",[[1,16364,"* "],[1,16410,"* "],[1,16444,"* "],[1,16506,"* "]],[16364,16525],[16366,16533]]],[1542958507636,["gjx16@GJXAIOU",[[1,16411,"；"]],[16411,16411],[16412,16412]]],[1542958510272,["gjx16@GJXAIOU",[[1,16448,"；"]],[16448,16448],[16449,16449]]],[1542958512897,["gjx16@GJXAIOU",[[1,16513,"；"]],[16513,16513],[16514,16514]]],[1542958515278,["gjx16@GJXAIOU",[[1,16536,"；"]],[16536,16536],[16537,16537]]],[1542958524956,["gjx16@GJXAIOU",[[1,16561,"- "]],[16561,16561],[16563,16563]]],[1542958527669,["gjx16@GJXAIOU",[[-1,16604,"\n"]],[16604,16604],[16603,16603]]],[1542958528990,["gjx16@GJXAIOU",[[-1,16622,"\n"]],[16622,16622],[16621,16621]]],[1542958529989,["gjx16@GJXAIOU",[[-1,16643,"\n"]],[16643,16643],[16642,16642]]],[1542958531190,["gjx16@GJXAIOU",[[-1,16665,"\n"]],[16665,16665],[16664,16664]]],[1542958537358,["gjx16@GJXAIOU",[[1,16578,"* "],[1,16604,"* "],[1,16622,"* "],[1,16643,"* "],[1,16665,"* "]],[16578,16685],[16580,16695]]],[1542958545962,["gjx16@GJXAIOU",[[1,16578,"  "],[1,16606,"  "],[1,16626,"  "],[1,16649,"  "],[1,16673,"  "]],[16578,16695],[16578,16705]]],[1542958550097,["gjx16@GJXAIOU",[[-1,16577,"\n"]],[16577,16577],[16576,16576]]],[1542958613077,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14266,"\n"],[-1,14271,"\n"],[1,14279,"\n"],[-1,14285,"\n"],[1,14462,"\n"],[-1,14465,"\n"],[1,14494,"\n"],[-1,14498,"\n"],[1,14506,"\n"],[-1,14515,"\n"],[1,15207,"\n"],[-1,15210,"|"],[1,15211,"\n"],[-1,15216,"\n"],[-1,15225," "],[1,15226,"\n\n"],[-1,16195,"\n"],[1,16196,"*"],[-1,16199,"*"],[1,16208,"\n"],[-1,16211,"\n"],[1,16221,"\n"],[-1,16225,"\n"],[1,16236,"\n"],[-1,16238,"\n"],[1,16277,"\n"],[-1,16281,"\n"],[1,16292,"\n"],[-1,16294,"\n"],[-1,16341,"`"],[1,16342,"\n\n"],[-1,16352,"3"],[-1,16362,"*"],[1,16363,"究\n"],[-1,16366,"\n"],[-1,16405,"拷"],[1,16406,"认"],[-1,16411,"；数"],[1,16413,"数；\n"],[-1,16415,"\n"],[-1,16448,"；"],[1,16450,"；\n"],[-1,16452,"\n"],[-1,16513,"；"],[1,16515,"；\n"],[-1,16517,"\n"],[-1,16536,"；"],[1,16538,"；"],[1,16561,"\n"],[-1,16563,"\n"],[1,16577,"\n"],[-1,16581,"\n"],[1,16607,"\n"],[-1,16611,"\n"],[1,16629,"\n"],[-1,16633,"\n"],[1,16654,"\n"],[-1,16658,"\n"],[1,16680,"\n"],[-1,16684,"\n"]],[12361,12361],[16684,16684]]],[1542958613077,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14265,"\n"],[1,14271,"\n"],[-1,14278,"\n"],[1,14285,"\n"],[-1,14461,"\n"],[1,14465,"\n"],[-1,14493,"\n"],[1,14498,"\n"],[-1,14505,"\n"],[1,14515,"\n"],[-1,15206,"\n"],[1,15210,"|"],[-1,15210,"\n"],[1,15216,"\n"],[1,15224," "],[-1,15224,"\n\n"],[1,16195,"\n"],[-1,16195,"*"],[1,16199,"*"],[-1,16207,"\n"],[1,16211,"\n"],[-1,16220,"\n"],[1,16225,"\n"],[-1,16235,"\n"],[1,16238,"\n"],[-1,16276,"\n"],[1,16281,"\n"],[-1,16291,"\n"],[1,16294,"\n"],[1,16340,"`"],[-1,16340,"\n\n"],[1,16352,"3"],[1,16361,"*"],[-1,16361,"究\n"],[1,16366,"\n"],[1,16404,"拷"],[-1,16404,"认"],[1,16410,"；数"],[-1,16410,"数；\n"],[1,16415,"\n"],[1,16447,"；"],[-1,16448,"；\n"],[1,16452,"\n"],[1,16512,"；"],[-1,16513,"；\n"],[1,16517,"\n"],[1,16535,"；"],[-1,16536,"；"],[-1,16560,"\n"],[1,16563,"\n"],[-1,16576,"\n"],[1,16581,"\n"],[-1,16606,"\n"],[1,16611,"\n"],[-1,16628,"\n"],[1,16633,"\n"],[-1,16653,"\n"],[1,16658,"\n"],[-1,16679,"\n"],[1,16684,"\n"]],[16684,16684],[12361,12361]]],[1542958561401,["gjx16@GJXAIOU",[[-1,16736,"**3.4****"],[1,16745,"#"]],[16736,16736],[16737,16737]]],[1542958562037,["gjx16@GJXAIOU",[[1,16737,"##"]],[16737,16737],[16739,16739]]],[1542958563229,["gjx16@GJXAIOU",[[-1,16738,"#"]],[16739,16739],[16738,16738]]],[1542958565133,["gjx16@GJXAIOU",[[1,16738," （）"]],[16738,16738],[16741,16741]]],[1542958567839,["gjx16@GJXAIOU",[[1,16740,"四"]],[16740,16740],[16741,16741]]],[1542958571570,["gjx16@GJXAIOU",[[1,16738,"#"]],[16738,16738],[16739,16739]]],[1542958575998,["gjx16@GJXAIOU",[[-1,16750,"**"]],[16752,16752],[16750,16750]]],[1542958580532,["gjx16@GJXAIOU",[[-1,16752,"Ø "],[1,16754,"-"]],[16752,16752],[16753,16753]]],[1542958580814,["gjx16@GJXAIOU",[[1,16753," "]],[16753,16753],[16754,16754]]],[1542958583323,["gjx16@GJXAIOU",[[-1,16781,"Ø  "],[1,16784,"-"]],[16781,16781],[16782,16782]]],[1542958585849,["gjx16@GJXAIOU",[[1,16782," "]],[16782,16782],[16783,16783]]],[1542958588445,["gjx16@GJXAIOU",[[-1,16780,"\n"]],[16780,16780],[16779,16779]]],[1542958603337,["gjx16@GJXAIOU",[[-1,16819,"****"]],[16819,16823],[16819,16819]]],[1542958607273,["gjx16@GJXAIOU",[[-1,16851,"****"]],[16851,16855],[16851,16851]]],[1542958609697,["gjx16@GJXAIOU",[[-1,16856,"****"]],[16856,16860],[16856,16856]]],[1542958611629,["gjx16@GJXAIOU",[[-1,16859,"****"]],[16859,16863],[16859,16859]]],[1542958673071,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14266,"\n"],[-1,14271,"\n"],[1,14279,"\n"],[-1,14285,"\n"],[1,14462,"\n"],[-1,14465,"\n"],[1,14494,"\n"],[-1,14498,"\n"],[1,14507,"\n"],[-1,14513,"\n"],[1,15207,"\n"],[-1,15210,"|"],[1,15211,"\n"],[-1,15216,"\n"],[-1,15225," "],[1,15226,"\n\n"],[-1,16195,"\n"],[1,16196,"*"],[-1,16199,"*"],[1,16208,"\n"],[-1,16211,"\n"],[1,16221,"\n"],[-1,16225,"\n"],[1,16236,"\n"],[-1,16238,"\n"],[1,16277,"\n"],[-1,16281,"\n"],[1,16292,"\n"],[-1,16294,"\n"],[-1,16341,"`"],[1,16342,"\n"],[1,16345,"\n"],[-1,16352,"3"],[-1,16362,"*"],[1,16363,"究\n"],[-1,16366,"\n"],[-1,16405,"拷"],[1,16406,"认"],[-1,16411,"；"],[1,16413,"；\n"],[-1,16415,"\n"],[-1,16448,"；数"],[1,16450,"数；\n"],[-1,16452,"\n"],[-1,16513,"；"],[1,16515,"；\n"],[-1,16517,"\n"],[-1,16536,"；"],[1,16538,"；"],[1,16560,"\n"],[-1,16563,"\n"],[1,16577,"\n"],[-1,16581,"\n"],[1,16607,"\n"],[-1,16611,"\n"],[1,16629,"\n"],[-1,16633,"\n"],[1,16654,"\n"],[-1,16658,"\n"],[1,16680,"\n"],[-1,16684,"\n"],[1,16736,"\n"],[-1,16743,"*"],[-1,16750,"*"],[1,16751,"贝\n"],[-1,16753," "],[1,16780,"\n"],[-1,16781," "],[-1,16819,"*"],[1,16820,"1"],[-1,16851,"*"],[1,16852,"2"],[-1,16856,"*C+*"],[1,16860,"序C++"]],[12361,12361],[16864,16864]]],[1542958673071,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14265,"\n"],[1,14271,"\n"],[-1,14278,"\n"],[1,14285,"\n"],[-1,14461,"\n"],[1,14465,"\n"],[-1,14493,"\n"],[1,14498,"\n"],[-1,14506,"\n"],[1,14513,"\n"],[-1,15206,"\n"],[1,15210,"|"],[-1,15210,"\n"],[1,15216,"\n"],[1,15224," "],[-1,15224,"\n\n"],[1,16195,"\n"],[-1,16195,"*"],[1,16199,"*"],[-1,16207,"\n"],[1,16211,"\n"],[-1,16220,"\n"],[1,16225,"\n"],[-1,16235,"\n"],[1,16238,"\n"],[-1,16276,"\n"],[1,16281,"\n"],[-1,16291,"\n"],[1,16294,"\n"],[1,16340,"`"],[-1,16340,"\n"],[-1,16344,"\n"],[1,16352,"3"],[1,16361,"*"],[-1,16361,"究\n"],[1,16366,"\n"],[1,16404,"拷"],[-1,16404,"认"],[1,16410,"；"],[-1,16411,"；\n"],[1,16415,"\n"],[1,16447,"；数"],[-1,16447,"数；\n"],[1,16452,"\n"],[1,16512,"；"],[-1,16513,"；\n"],[1,16517,"\n"],[1,16535,"；"],[-1,16536,"；"],[-1,16559,"\n"],[1,16563,"\n"],[-1,16576,"\n"],[1,16581,"\n"],[-1,16606,"\n"],[1,16611,"\n"],[-1,16628,"\n"],[1,16633,"\n"],[-1,16653,"\n"],[1,16658,"\n"],[-1,16679,"\n"],[1,16684,"\n"],[-1,16735,"\n"],[1,16743,"*"],[1,16749,"*"],[-1,16749,"贝\n"],[1,16753," "],[-1,16779,"\n"],[1,16781," "],[1,16818,"*"],[-1,16818,"1"],[1,16850,"*"],[-1,16850,"2"],[1,16855,"*C+*"],[-1,16855,"序C++"]],[16864,16864],[12361,12361]]],[1542958616247,["gjx16@GJXAIOU",[[-1,16911,"| \n"],[1,16914,"·"]],[16911,16911],[16912,16912]]],[1542958617166,["gjx16@GJXAIOU",[[-1,16911,"·"]],[16912,16912],[16911,16911]]],[1542958618967,["gjx16@GJXAIOU",[[1,16911,"```"]],[16911,16911],[16914,16914]]],[1542958619242,["gjx16@GJXAIOU",[[1,16914,"language\n```\n"]],[16914,16914],[16914,16922]]],[1542958620552,["gjx16@GJXAIOU",[[-1,16914,"language"],[1,16922,"c"]],[16914,16922],[16915,16915]]],[1542958621170,["gjx16@GJXAIOU",[[1,16915,"pp"]],[16915,16915],[16917,16917]]],[1542958623881,["gjx16@GJXAIOU",[[-1,16918,"```"]],[16918,16921],[16918,16918]]],[1542958644342,["gjx16@GJXAIOU",[[-1,17846," |\n|  |\n|  |\n"],[1,17859,"```"]],[17846,17859],[17849,17849]]],[1542958655731,["gjx16@GJXAIOU",[[1,17850,"\n"]],[17849,17849],[17850,17850]]],[1542958656066,["gjx16@GJXAIOU",[[1,17851,"\n"]],[17850,17850],[17851,17851]]],[1542959273087,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14266,"\n"],[-1,14271,"\n"],[1,14279,"\n"],[-1,14285,"\n"],[1,14462,"\n"],[-1,14465,"\n"],[1,14494,"\n"],[-1,14498,"\n"],[1,14506,"\n"],[-1,14515,"\n"],[1,15207,"\n"],[-1,15210,"|"],[1,15211,"\n"],[-1,15216,"\n"],[-1,15225," "],[1,15226,"\n\n"],[-1,16195,"\n"],[1,16196,"*"],[-1,16199,"*"],[1,16209,"\n"],[-1,16211,"\n"],[1,16221,"\n"],[-1,16225,"\n"],[1,16236,"\n"],[-1,16238,"\n"],[1,16277,"\n"],[-1,16281,"\n"],[1,16292,"\n"],[-1,16294,"\n"],[-1,16341,"`"],[1,16342,"\n\n"],[-1,16352,"3"],[-1,16362,"*"],[1,16363,"究\n"],[-1,16366,"\n"],[-1,16405,"拷"],[1,16406,"认"],[-1,16411,"；"],[1,16413,"；\n"],[-1,16415,"\n"],[-1,16448,"；"],[1,16450,"；\n"],[-1,16452,"\n"],[-1,16513,"；数"],[1,16515,"数；\n"],[-1,16517,"\n"],[-1,16536,"；"],[1,16538,"；"],[1,16561,"\n"],[-1,16563,"\n"],[1,16577,"\n"],[-1,16581,"\n"],[1,16607,"\n"],[-1,16611,"\n"],[1,16629,"\n"],[-1,16633,"\n"],[1,16654,"\n"],[-1,16658,"\n"],[1,16680,"\n"],[-1,16684,"\n"],[1,16736,"\n"],[-1,16743,"*"],[-1,16750,"*"],[1,16751,"贝\n"],[-1,16753," "],[1,16780,"\n"],[-1,16781," "],[-1,16819,"*"],[1,16820,"1"],[-1,16851,"*"],[1,16852,"2"],[-1,16856,"*C+*"],[1,16860,"序C++"],[1,16911,"\n"],[-1,16917,"\n"],[1,17846,"\n"],[-1,17849,"\n"]],[12361,12361],[17849,17849]]],[1542959273087,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14265,"\n"],[1,14271,"\n"],[-1,14278,"\n"],[1,14285,"\n"],[-1,14461,"\n"],[1,14465,"\n"],[-1,14493,"\n"],[1,14498,"\n"],[-1,14505,"\n"],[1,14515,"\n"],[-1,15206,"\n"],[1,15210,"|"],[-1,15210,"\n"],[1,15216,"\n"],[1,15224," "],[-1,15224,"\n\n"],[1,16195,"\n"],[-1,16195,"*"],[1,16199,"*"],[-1,16208,"\n"],[1,16211,"\n"],[-1,16220,"\n"],[1,16225,"\n"],[-1,16235,"\n"],[1,16238,"\n"],[-1,16276,"\n"],[1,16281,"\n"],[-1,16291,"\n"],[1,16294,"\n"],[1,16340,"`"],[-1,16340,"\n\n"],[1,16352,"3"],[1,16361,"*"],[-1,16361,"究\n"],[1,16366,"\n"],[1,16404,"拷"],[-1,16404,"认"],[1,16410,"；"],[-1,16411,"；\n"],[1,16415,"\n"],[1,16447,"；"],[-1,16448,"；\n"],[1,16452,"\n"],[1,16512,"；数"],[-1,16512,"数；\n"],[1,16517,"\n"],[1,16535,"；"],[-1,16536,"；"],[-1,16560,"\n"],[1,16563,"\n"],[-1,16576,"\n"],[1,16581,"\n"],[-1,16606,"\n"],[1,16611,"\n"],[-1,16628,"\n"],[1,16633,"\n"],[-1,16653,"\n"],[1,16658,"\n"],[-1,16679,"\n"],[1,16684,"\n"],[-1,16735,"\n"],[1,16743,"*"],[1,16749,"*"],[-1,16749,"贝\n"],[1,16753," "],[-1,16779,"\n"],[1,16781," "],[1,16818,"*"],[-1,16818,"1"],[1,16850,"*"],[-1,16850,"2"],[1,16855,"*C+*"],[-1,16855,"序C++"],[-1,16910,"\n"],[1,16917,"\n"],[-1,17845,"\n"],[1,17849,"\n"]],[17849,17849],[12361,12361]]],[1542959271701,["gjx16@GJXAIOU",[[1,17851,"![2]($resource/2.png)\n![3]($resource/3.png)"]],[17851,17851],[17895,17895]]],[1542962461096,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14266,"\n"],[-1,14271,"\n"],[1,14279,"\n"],[-1,14285,"\n"],[1,14462,"\n"],[-1,14465,"\n"],[1,14494,"\n"],[-1,14498,"\n"],[1,14506,"\n"],[-1,14515,"\n"],[1,15207,"\n"],[-1,15210,"|"],[1,15211,"\n"],[-1,15216,"\n"],[-1,15225," "],[1,15226,"\n\n"],[-1,16195,"\n"],[1,16196,"*"],[-1,16199,"*"],[1,16209,"\n"],[-1,16211,"\n"],[1,16221,"\n"],[-1,16225,"\n"],[1,16236,"\n"],[-1,16238,"\n"],[1,16277,"\n"],[-1,16281,"\n"],[1,16292,"\n"],[-1,16294,"\n"],[-1,16341,"`"],[1,16342,"\n\n"],[-1,16352,"3"],[-1,16362,"*"],[1,16363,"究\n"],[-1,16366,"\n"],[-1,16405,"拷"],[1,16406,"认"],[-1,16411,"；"],[1,16413,"；\n"],[-1,16415,"\n"],[-1,16448,"；"],[1,16450,"；\n"],[-1,16452,"\n"],[-1,16513,"；数"],[1,16515,"数；\n"],[-1,16517,"\n"],[-1,16536,"；"],[1,16538,"；"],[1,16561,"\n"],[-1,16563,"\n"],[1,16577,"\n"],[-1,16581,"\n"],[1,16607,"\n"],[-1,16611,"\n"],[1,16629,"\n"],[-1,16633,"\n"],[1,16654,"\n"],[-1,16658,"\n"],[1,16680,"\n"],[-1,16684,"\n"],[1,16736,"\n"],[-1,16743,"*"],[-1,16750,"*"],[1,16751,"贝\n"],[-1,16753," "],[1,16780,"\n"],[-1,16781," "],[-1,16819,"*"],[1,16820,"1"],[-1,16851,"*"],[1,16852,"2"],[-1,16856,"*C+*"],[1,16860,"序C++"],[1,16911,"\n"],[-1,16917,"\n"],[1,17846,"\n"],[-1,17894,"\n"],[1,17895,""]],[12361,12361],[17895,17895]]],[1542962461096,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14265,"\n"],[1,14271,"\n"],[-1,14278,"\n"],[1,14285,"\n"],[-1,14461,"\n"],[1,14465,"\n"],[-1,14493,"\n"],[1,14498,"\n"],[-1,14505,"\n"],[1,14515,"\n"],[-1,15206,"\n"],[1,15210,"|"],[-1,15210,"\n"],[1,15216,"\n"],[1,15224," "],[-1,15224,"\n\n"],[1,16195,"\n"],[-1,16195,"*"],[1,16199,"*"],[-1,16208,"\n"],[1,16211,"\n"],[-1,16220,"\n"],[1,16225,"\n"],[-1,16235,"\n"],[1,16238,"\n"],[-1,16276,"\n"],[1,16281,"\n"],[-1,16291,"\n"],[1,16294,"\n"],[1,16340,"`"],[-1,16340,"\n\n"],[1,16352,"3"],[1,16361,"*"],[-1,16361,"究\n"],[1,16366,"\n"],[1,16404,"拷"],[-1,16404,"认"],[1,16410,"；"],[-1,16411,"；\n"],[1,16415,"\n"],[1,16447,"；"],[-1,16448,"；\n"],[1,16452,"\n"],[1,16512,"；数"],[-1,16512,"数；\n"],[1,16517,"\n"],[1,16535,"；"],[-1,16536,"；"],[-1,16560,"\n"],[1,16563,"\n"],[-1,16576,"\n"],[1,16581,"\n"],[-1,16606,"\n"],[1,16611,"\n"],[-1,16628,"\n"],[1,16633,"\n"],[-1,16653,"\n"],[1,16658,"\n"],[-1,16679,"\n"],[1,16684,"\n"],[-1,16735,"\n"],[1,16743,"*"],[1,16749,"*"],[-1,16749,"贝\n"],[1,16753," "],[-1,16779,"\n"],[1,16781," "],[1,16818,"*"],[-1,16818,"1"],[1,16850,"*"],[-1,16850,"2"],[1,16855,"*C+*"],[-1,16855,"序C++"],[-1,16910,"\n"],[1,16917,"\n"],[-1,17845,"\n"],[1,17894,"\n"],[-1,17894,""]],[17895,17895],[12361,12361]]],[1542962430476,["gjx16@GJXAIOU",[[1,14750,"\n "]],[14750,14750],[14752,14752]]],[1542962521100,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14266,"\n"],[-1,14271,"\n"],[1,14279,"\n"],[-1,14285,"\n"],[1,14462,"\n"],[-1,14465,"\n"],[1,14494,"\n"],[-1,14498,"\n"],[1,14506,"\n"],[-1,14515,"\n"],[-1,14750,"\n"],[1,14752,"\n"],[1,15209,"\n"],[-1,15212,"|"],[1,15213,"\n"],[-1,15218,"\n"],[-1,15227," "],[1,15228,"\n\n"],[-1,16197,"\n"],[1,16198,"*"],[-1,16201,"*"],[1,16211,"\n"],[-1,16213,"\n"],[1,16223,"\n"],[-1,16227,"\n"],[1,16238,"\n"],[-1,16240,"\n"],[1,16279,"\n"],[-1,16283,"\n"],[1,16294,"\n"],[-1,16296,"\n"],[-1,16343,"`"],[1,16344,"\n\n"],[-1,16354,"3"],[-1,16364,"*"],[1,16365,"究\n"],[-1,16368,"\n"],[-1,16407,"拷"],[1,16408,"认"],[-1,16413,"；"],[1,16415,"；\n"],[-1,16417,"\n"],[-1,16450,"；"],[1,16452,"；\n"],[-1,16454,"\n"],[-1,16515,"；数"],[1,16517,"数；\n"],[-1,16519,"\n"],[-1,16538,"；"],[1,16540,"；"],[1,16563,"\n"],[-1,16565,"\n"],[1,16579,"\n"],[-1,16583,"\n"],[1,16609,"\n"],[-1,16613,"\n"],[1,16631,"\n"],[-1,16635,"\n"],[1,16656,"\n"],[-1,16660,"\n"],[1,16682,"\n"],[-1,16686,"\n"],[1,16738,"\n"],[-1,16745,"*"],[-1,16752,"*"],[1,16753,"贝\n"],[-1,16755," "],[1,16782,"\n"],[-1,16783," "],[-1,16821,"*"],[1,16822,"1"],[-1,16853,"*"],[1,16854,"2"],[-1,16858,"*C+*"],[1,16862,"序C++"],[1,16913,"\n"],[-1,16919,"\n"],[1,17848,"\n"],[-1,17896,"\n"],[1,17897,""]],[12361,12361],[17897,17897]]],[1542962521100,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14265,"\n"],[1,14271,"\n"],[-1,14278,"\n"],[1,14285,"\n"],[-1,14461,"\n"],[1,14465,"\n"],[-1,14493,"\n"],[1,14498,"\n"],[-1,14505,"\n"],[1,14515,"\n"],[1,14749,"\n"],[-1,14750,"\n"],[-1,15208,"\n"],[1,15212,"|"],[-1,15212,"\n"],[1,15218,"\n"],[1,15226," "],[-1,15226,"\n\n"],[1,16197,"\n"],[-1,16197,"*"],[1,16201,"*"],[-1,16210,"\n"],[1,16213,"\n"],[-1,16222,"\n"],[1,16227,"\n"],[-1,16237,"\n"],[1,16240,"\n"],[-1,16278,"\n"],[1,16283,"\n"],[-1,16293,"\n"],[1,16296,"\n"],[1,16342,"`"],[-1,16342,"\n\n"],[1,16354,"3"],[1,16363,"*"],[-1,16363,"究\n"],[1,16368,"\n"],[1,16406,"拷"],[-1,16406,"认"],[1,16412,"；"],[-1,16413,"；\n"],[1,16417,"\n"],[1,16449,"；"],[-1,16450,"；\n"],[1,16454,"\n"],[1,16514,"；数"],[-1,16514,"数；\n"],[1,16519,"\n"],[1,16537,"；"],[-1,16538,"；"],[-1,16562,"\n"],[1,16565,"\n"],[-1,16578,"\n"],[1,16583,"\n"],[-1,16608,"\n"],[1,16613,"\n"],[-1,16630,"\n"],[1,16635,"\n"],[-1,16655,"\n"],[1,16660,"\n"],[-1,16681,"\n"],[1,16686,"\n"],[-1,16737,"\n"],[1,16745,"*"],[1,16751,"*"],[-1,16751,"贝\n"],[1,16755," "],[-1,16781,"\n"],[1,16783," "],[1,16820,"*"],[-1,16820,"1"],[1,16852,"*"],[-1,16852,"2"],[1,16857,"*C+*"],[-1,16857,"序C++"],[-1,16912,"\n"],[1,16919,"\n"],[-1,17847,"\n"],[1,17896,"\n"],[-1,17896,""]],[17897,17897],[12361,12361]]],[1542962516521,["gjx16@GJXAIOU",[[1,14752,"  "]],[14752,14752],[14754,14754]]],[1542969001247,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14266,"\n"],[-1,14271,"\n"],[1,14279,"\n"],[-1,14285,"\n"],[1,14462,"\n"],[-1,14465,"\n"],[1,14494,"\n"],[-1,14498,"\n"],[1,14506,"\n"],[-1,14515,"\n"],[-1,14750,"\n"],[1,14752,"\n"],[1,15211,"\n"],[-1,15214,"|"],[1,15215,"\n"],[-1,15220,"\n"],[-1,15229," "],[1,15230,"\n\n"],[-1,16199,"\n"],[1,16200,"*"],[-1,16203,"*"],[1,16213,"\n"],[-1,16215,"\n"],[1,16225,"\n"],[-1,16229,"\n"],[1,16240,"\n"],[-1,16242,"\n"],[1,16281,"\n"],[-1,16285,"\n"],[1,16296,"\n"],[-1,16298,"\n"],[-1,16345,"`"],[1,16346,"\n\n"],[-1,16356,"3"],[-1,16366,"*"],[1,16367,"究\n"],[-1,16370,"\n"],[-1,16409,"拷"],[1,16410,"认"],[-1,16415,"；"],[1,16417,"；\n"],[-1,16419,"\n"],[-1,16452,"；"],[1,16454,"；\n"],[-1,16456,"\n"],[-1,16517,"；数"],[1,16519,"数；\n"],[-1,16521,"\n"],[-1,16540,"；"],[1,16542,"；"],[1,16565,"\n"],[-1,16567,"\n"],[1,16581,"\n"],[-1,16585,"\n"],[1,16611,"\n"],[-1,16615,"\n"],[1,16633,"\n"],[-1,16637,"\n"],[1,16658,"\n"],[-1,16662,"\n"],[1,16684,"\n"],[-1,16688,"\n"],[1,16740,"\n"],[-1,16747,"*"],[-1,16754,"*"],[1,16755,"贝\n"],[-1,16757," "],[1,16784,"\n"],[-1,16785," "],[-1,16823,"*"],[1,16824,"1"],[-1,16855,"*"],[1,16856,"2"],[-1,16860,"*C+*"],[1,16864,"序C++"],[1,16915,"\n"],[-1,16921,"\n"],[1,17850,"\n"],[-1,17898,"\n"],[1,17899,""]],[12361,12361],[17899,17899]]],[1542969001247,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14265,"\n"],[1,14271,"\n"],[-1,14278,"\n"],[1,14285,"\n"],[-1,14461,"\n"],[1,14465,"\n"],[-1,14493,"\n"],[1,14498,"\n"],[-1,14505,"\n"],[1,14515,"\n"],[1,14749,"\n"],[-1,14750,"\n"],[-1,15210,"\n"],[1,15214,"|"],[-1,15214,"\n"],[1,15220,"\n"],[1,15228," "],[-1,15228,"\n\n"],[1,16199,"\n"],[-1,16199,"*"],[1,16203,"*"],[-1,16212,"\n"],[1,16215,"\n"],[-1,16224,"\n"],[1,16229,"\n"],[-1,16239,"\n"],[1,16242,"\n"],[-1,16280,"\n"],[1,16285,"\n"],[-1,16295,"\n"],[1,16298,"\n"],[1,16344,"`"],[-1,16344,"\n\n"],[1,16356,"3"],[1,16365,"*"],[-1,16365,"究\n"],[1,16370,"\n"],[1,16408,"拷"],[-1,16408,"认"],[1,16414,"；"],[-1,16415,"；\n"],[1,16419,"\n"],[1,16451,"；"],[-1,16452,"；\n"],[1,16456,"\n"],[1,16516,"；数"],[-1,16516,"数；\n"],[1,16521,"\n"],[1,16539,"；"],[-1,16540,"；"],[-1,16564,"\n"],[1,16567,"\n"],[-1,16580,"\n"],[1,16585,"\n"],[-1,16610,"\n"],[1,16615,"\n"],[-1,16632,"\n"],[1,16637,"\n"],[-1,16657,"\n"],[1,16662,"\n"],[-1,16683,"\n"],[1,16688,"\n"],[-1,16739,"\n"],[1,16747,"*"],[1,16753,"*"],[-1,16753,"贝\n"],[1,16757," "],[-1,16783,"\n"],[1,16785," "],[1,16822,"*"],[-1,16822,"1"],[1,16854,"*"],[-1,16854,"2"],[1,16859,"*C+*"],[-1,16859,"序C++"],[-1,16914,"\n"],[1,16921,"\n"],[-1,17849,"\n"],[1,17898,"\n"],[-1,17898,""]],[17899,17899],[12361,12361]]],[1542968959448,["gjx16@GJXAIOU",[[-1,14317,"\n"]],[14317,14317],[14316,14316]]],[1542968963974,["gjx16@GJXAIOU",[[-1,14287,"\n"]],[14287,14287],[14286,14286]]],[1542968964775,["gjx16@GJXAIOU",[[-1,14286,"\n"]],[14286,14286],[14285,14285]]],[1542968970350,["gjx16@GJXAIOU",[[-1,14456,"\n"]],[14456,14456],[14455,14455]]],[1542972649166,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14262,"\n"],[-1,14265," "],[1,14266,"\n"],[-1,14271,"\n"],[1,14279,"\n"],[-1,14285,"\n"],[1,14458,"\n"],[-1,14461,"\n"],[1,14490,"\n"],[-1,14494,"\n"],[1,14502,"\n"],[-1,14511,"\n"],[-1,14746,"\n"],[1,14748,"\n"],[1,15207,"\n"],[-1,15210,"|"],[1,15211,"\n"],[-1,15216,"\n"],[-1,15225," "],[1,15226,"\n\n"],[-1,16195,"\n"],[1,16196,"*"],[-1,16199,"*"],[1,16209,"\n"],[-1,16211,"\n"],[1,16221,"\n"],[-1,16225,"\n"],[1,16236,"\n"],[-1,16238,"\n"],[1,16277,"\n"],[-1,16281,"\n"],[1,16292,"\n"],[-1,16294,"\n"],[-1,16341,"`"],[1,16342,"\n\n"],[-1,16352,"3"],[-1,16362,"*"],[1,16363,"究\n"],[-1,16366,"\n"],[-1,16405,"拷"],[1,16406,"认"],[-1,16411,"；"],[1,16413,"；\n"],[-1,16415,"\n"],[-1,16448,"；"],[1,16450,"；\n"],[-1,16452,"\n"],[-1,16513,"；数"],[1,16515,"数；\n"],[-1,16517,"\n"],[-1,16536,"；"],[1,16538,"；"],[1,16561,"\n"],[-1,16563,"\n"],[1,16577,"\n"],[-1,16581,"\n"],[1,16607,"\n"],[-1,16611,"\n"],[1,16629,"\n"],[-1,16633,"\n"],[1,16654,"\n"],[-1,16658,"\n"],[1,16680,"\n"],[-1,16684,"\n"],[1,16736,"\n"],[-1,16743,"*"],[-1,16750,"*"],[1,16751,"贝\n"],[-1,16753," "],[1,16780,"\n"],[-1,16781," "],[-1,16819,"*"],[1,16820,"1"],[-1,16851,"*"],[1,16852,"2"],[-1,16856,"*C+*"],[1,16860,"序C++"],[1,16911,"\n"],[-1,16917,"\n"],[1,17846,"\n"],[-1,17894,"\n"],[1,17895,""]],[12361,12361],[17895,17895]]],[1542972649166,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14261,"\n"],[1,14265," "],[-1,14265,"\n"],[1,14271,"\n"],[-1,14278,"\n"],[1,14285,"\n"],[-1,14457,"\n"],[1,14461,"\n"],[-1,14489,"\n"],[1,14494,"\n"],[-1,14501,"\n"],[1,14511,"\n"],[1,14745,"\n"],[-1,14746,"\n"],[-1,15206,"\n"],[1,15210,"|"],[-1,15210,"\n"],[1,15216,"\n"],[1,15224," "],[-1,15224,"\n\n"],[1,16195,"\n"],[-1,16195,"*"],[1,16199,"*"],[-1,16208,"\n"],[1,16211,"\n"],[-1,16220,"\n"],[1,16225,"\n"],[-1,16235,"\n"],[1,16238,"\n"],[-1,16276,"\n"],[1,16281,"\n"],[-1,16291,"\n"],[1,16294,"\n"],[1,16340,"`"],[-1,16340,"\n\n"],[1,16352,"3"],[1,16361,"*"],[-1,16361,"究\n"],[1,16366,"\n"],[1,16404,"拷"],[-1,16404,"认"],[1,16410,"；"],[-1,16411,"；\n"],[1,16415,"\n"],[1,16447,"；"],[-1,16448,"；\n"],[1,16452,"\n"],[1,16512,"；数"],[-1,16512,"数；\n"],[1,16517,"\n"],[1,16535,"；"],[-1,16536,"；"],[-1,16560,"\n"],[1,16563,"\n"],[-1,16576,"\n"],[1,16581,"\n"],[-1,16606,"\n"],[1,16611,"\n"],[-1,16628,"\n"],[1,16633,"\n"],[-1,16653,"\n"],[1,16658,"\n"],[-1,16679,"\n"],[1,16684,"\n"],[-1,16735,"\n"],[1,16743,"*"],[1,16749,"*"],[-1,16749,"贝\n"],[1,16753," "],[-1,16779,"\n"],[1,16781," "],[1,16818,"*"],[-1,16818,"1"],[1,16850,"*"],[-1,16850,"2"],[1,16855,"*C+*"],[-1,16855,"序C++"],[-1,16910,"\n"],[1,16917,"\n"],[-1,17845,"\n"],[1,17894,"\n"],[-1,17894,""]],[17895,17895],[12361,12361]]],[1542972640495,["gjx16@GJXAIOU",[[-1,13721,"\n"]],[13721,13721],[13720,13720]]],[1542972641455,["gjx16@GJXAIOU",[[-1,13742,"\n"]],[13742,13742],[13741,13741]]],[1542972642326,["gjx16@GJXAIOU",[[-1,13751,"\n"]],[13751,13751],[13750,13750]]],[1542972643377,["gjx16@GJXAIOU",[[-1,13753,"\n"]],[13753,13753],[13752,13752]]],[1542972644705,["gjx16@GJXAIOU",[[-1,13761,"\n"]],[13761,13761],[13760,13760]]],[1542972645597,["gjx16@GJXAIOU",[[-1,13783,"\n"]],[13783,13783],[13782,13782]]],[1542972646325,["gjx16@GJXAIOU",[[-1,13786,"\n"]],[13786,13786],[13785,13785]]],[1542972647159,["gjx16@GJXAIOU",[[-1,13816,"\n"]],[13816,13816],[13815,13815]]],[1542972647871,["gjx16@GJXAIOU",[[-1,13819,"\n"]],[13819,13819],[13818,13818]]],[1542972648726,["gjx16@GJXAIOU",[[-1,13847,"\n"]],[13847,13847],[13846,13846]]],[1542972709267,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[1,14252,"\n"],[-1,14255," "],[1,14256,"\n"],[-1,14261,"\n"],[1,14269,"\n"],[-1,14275,"\n"],[1,14448,"\n"],[-1,14451,"\n"],[1,14480,"\n"],[-1,14484,"\n"],[1,14492,"\n"],[-1,14501,"\n"],[-1,14736,"\n"],[1,14738,"\n"],[1,15197,"\n"],[-1,15200,"|"],[1,15201,"\n"],[-1,15206,"\n"],[-1,15215," "],[1,15216,"\n\n"],[-1,16185,"\n"],[1,16186,"*"],[-1,16189,"*"],[1,16199,"\n"],[-1,16201,"\n"],[1,16211,"\n"],[-1,16215,"\n"],[1,16226,"\n"],[-1,16228,"\n"],[1,16267,"\n"],[-1,16271,"\n"],[1,16282,"\n"],[-1,16284,"\n"],[-1,16331,"`"],[1,16332,"\n\n"],[-1,16342,"3"],[-1,16352,"*"],[1,16353,"究\n"],[-1,16356,"\n"],[-1,16395,"拷"],[1,16396,"认"],[-1,16401,"；"],[1,16403,"；\n"],[-1,16405,"\n"],[-1,16438,"；"],[1,16440,"；\n"],[-1,16442,"\n"],[-1,16503,"；数"],[1,16505,"数；\n"],[-1,16507,"\n"],[-1,16526,"；"],[1,16528,"；"],[1,16551,"\n"],[-1,16553,"\n"],[1,16567,"\n"],[-1,16571,"\n"],[1,16597,"\n"],[-1,16601,"\n"],[1,16619,"\n"],[-1,16623,"\n"],[1,16644,"\n"],[-1,16648,"\n"],[1,16670,"\n"],[-1,16674,"\n"],[1,16726,"\n"],[-1,16733,"*"],[-1,16740,"*"],[1,16741,"贝\n"],[-1,16743," "],[1,16770,"\n"],[-1,16771," "],[-1,16809,"*"],[1,16810,"1"],[-1,16841,"*"],[1,16842,"2"],[-1,16846,"*C+*"],[1,16850,"序C++"],[1,16901,"\n"],[-1,16907,"\n"],[1,17836,"\n"],[-1,17884,"\n"],[1,17885,""]],[12361,12361],[17885,17885]]],[1542972709267,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[-1,14251,"\n"],[1,14255," "],[-1,14255,"\n"],[1,14261,"\n"],[-1,14268,"\n"],[1,14275,"\n"],[-1,14447,"\n"],[1,14451,"\n"],[-1,14479,"\n"],[1,14484,"\n"],[-1,14491,"\n"],[1,14501,"\n"],[1,14735,"\n"],[-1,14736,"\n"],[-1,15196,"\n"],[1,15200,"|"],[-1,15200,"\n"],[1,15206,"\n"],[1,15214," "],[-1,15214,"\n\n"],[1,16185,"\n"],[-1,16185,"*"],[1,16189,"*"],[-1,16198,"\n"],[1,16201,"\n"],[-1,16210,"\n"],[1,16215,"\n"],[-1,16225,"\n"],[1,16228,"\n"],[-1,16266,"\n"],[1,16271,"\n"],[-1,16281,"\n"],[1,16284,"\n"],[1,16330,"`"],[-1,16330,"\n\n"],[1,16342,"3"],[1,16351,"*"],[-1,16351,"究\n"],[1,16356,"\n"],[1,16394,"拷"],[-1,16394,"认"],[1,16400,"；"],[-1,16401,"；\n"],[1,16405,"\n"],[1,16437,"；"],[-1,16438,"；\n"],[1,16442,"\n"],[1,16502,"；数"],[-1,16502,"数；\n"],[1,16507,"\n"],[1,16525,"；"],[-1,16526,"；"],[-1,16550,"\n"],[1,16553,"\n"],[-1,16566,"\n"],[1,16571,"\n"],[-1,16596,"\n"],[1,16601,"\n"],[-1,16618,"\n"],[1,16623,"\n"],[-1,16643,"\n"],[1,16648,"\n"],[-1,16669,"\n"],[1,16674,"\n"],[-1,16725,"\n"],[1,16733,"*"],[1,16739,"*"],[-1,16739,"贝\n"],[1,16743," "],[-1,16769,"\n"],[1,16771," "],[1,16808,"*"],[-1,16808,"1"],[1,16840,"*"],[-1,16840,"2"],[1,16845,"*C+*"],[-1,16845,"序C++"],[-1,16900,"\n"],[1,16907,"\n"],[-1,17835,"\n"],[1,17884,"\n"],[-1,17884,""]],[17885,17885],[12361,12361]]],[1542972652776,["gjx16@GJXAIOU",[[1,13820,"\n "]],[13818,13818],[13820,13820]]],[1542972654608,["gjx16@GJXAIOU",[[1,13853,"\n"]],[13852,13852],[13853,13853]]],[1542972654835,["gjx16@GJXAIOU",[[-1,13853,"\n"]],[13853,13853],[13852,13852]]],[1542972655774,["gjx16@GJXAIOU",[[-1,13852,"\n"]],[13852,13852],[13851,13851]]],[1542972656709,["gjx16@GJXAIOU",[[-1,13861,"\n"]],[13861,13861],[13860,13860]]],[1542972662040,["gjx16@GJXAIOU",[[1,14480,"\n"]],[14479,14479],[14480,14480]]],[1542972663385,["gjx16@GJXAIOU",[[1,14480,"****"]],[14480,14480],[14482,14482]]],[1542972667343,["gjx16@GJXAIOU",[[1,14482,"diyige"]],[14482,14482],[14488,14488]]],[1542972670201,["gjx16@GJXAIOU",[[-1,14482,"diyige"]],[14488,14488],[14482,14482]]],[1542972677700,["gjx16@GJXAIOU",[[1,14482,"第一个和第二个场景："]],[14482,14482],[14492,14492]]],[1542972680689,["gjx16@GJXAIOU",[[1,14495,"\n"]],[14494,14494],[14495,14495]]],[1542972682730,["gjx16@GJXAIOU",[[1,14495,"···"]],[14495,14495],[14498,14498]]],[1542972684301,["gjx16@GJXAIOU",[[-1,14495,"···"]],[14498,14498],[14495,14495]]],[1542972687357,["gjx16@GJXAIOU",[[1,14495,"```cpp"]],[14495,14495],[14501,14501]]],[1542972688448,["gjx16@GJXAIOU",[[1,14502,"\n"]],[14501,14501],[14502,14502]]],[1542972688841,["gjx16@GJXAIOU",[[1,14503,"\n"]],[14502,14502],[14503,14503]]],[1542972689073,["gjx16@GJXAIOU",[[1,14504,"\n"]],[14503,14503],[14504,14504]]],[1542972690063,["gjx16@GJXAIOU",[[1,14504,"```"]],[14504,14504],[14507,14507]]],[1542972708871,["gjx16@GJXAIOU",[[1,14503,"/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n"]],[14502,14502],[15087,15087]]],[1542973288170,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[-1,13820,"\n"],[1,13822,"\n"],[1,14252,"\n"],[-1,14255," "],[1,14256,"\n"],[-1,14261,"\n"],[1,14269,"\n"],[-1,14275,"\n"],[1,14448,"\n"],[-1,14451,"\n"],[1,14479,"\n"],[-1,15097,"\n"],[1,15106,"\n"],[-1,15112,"\n"],[-1,15349,"\n"],[1,15351,"\n"],[1,15810,"\n"],[-1,15813,"|"],[1,15814,"\n"],[-1,15819,"\n"],[-1,15828," "],[1,15829,"\n\n"],[-1,16798,"\n"],[1,16799,"*"],[-1,16802,"*"],[1,16812,"\n"],[-1,16814,"\n"],[1,16824,"\n"],[-1,16828,"\n"],[1,16839,"\n"],[-1,16841,"\n"],[1,16880,"\n"],[-1,16884,"\n"],[1,16895,"\n"],[-1,16897,"\n"],[-1,16944,"`"],[1,16945,"\n\n"],[-1,16955,"3"],[-1,16965,"*"],[1,16966,"究\n"],[-1,16969,"\n"],[-1,17008,"拷"],[1,17009,"认"],[-1,17014,"；"],[1,17016,"；\n"],[-1,17018,"\n"],[-1,17051,"；"],[1,17053,"；\n"],[-1,17055,"\n"],[-1,17116,"；数"],[1,17118,"数；\n"],[-1,17120,"\n"],[-1,17139,"；"],[1,17141,"；"],[1,17164,"\n"],[-1,17166,"\n"],[1,17180,"\n"],[-1,17184,"\n"],[1,17210,"\n"],[-1,17214,"\n"],[1,17232,"\n"],[-1,17236,"\n"],[1,17257,"\n"],[-1,17261,"\n"],[1,17283,"\n"],[-1,17287,"\n"],[1,17339,"\n"],[-1,17346,"*"],[-1,17353,"*"],[1,17354,"贝\n"],[-1,17356," "],[1,17383,"\n"],[-1,17384," "],[-1,17422,"*"],[1,17423,"1"],[-1,17454,"*"],[1,17455,"2"],[-1,17459,"*C+*"],[1,17463,"序C++"],[1,17514,"\n"],[-1,17520,"\n"],[1,18449,"\n"],[-1,18497,"\n"],[1,18498,""]],[12361,12361],[18498,18498]]],[1542973288170,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[1,13819,"\n"],[-1,13820,"\n"],[-1,14251,"\n"],[1,14255," "],[-1,14255,"\n"],[1,14261,"\n"],[-1,14268,"\n"],[1,14275,"\n"],[-1,14447,"\n"],[1,14451,"\n"],[-1,14478,"\n"],[1,15097,"\n"],[-1,15105,"\n"],[1,15112,"\n"],[1,15348,"\n"],[-1,15349,"\n"],[-1,15809,"\n"],[1,15813,"|"],[-1,15813,"\n"],[1,15819,"\n"],[1,15827," "],[-1,15827,"\n\n"],[1,16798,"\n"],[-1,16798,"*"],[1,16802,"*"],[-1,16811,"\n"],[1,16814,"\n"],[-1,16823,"\n"],[1,16828,"\n"],[-1,16838,"\n"],[1,16841,"\n"],[-1,16879,"\n"],[1,16884,"\n"],[-1,16894,"\n"],[1,16897,"\n"],[1,16943,"`"],[-1,16943,"\n\n"],[1,16955,"3"],[1,16964,"*"],[-1,16964,"究\n"],[1,16969,"\n"],[1,17007,"拷"],[-1,17007,"认"],[1,17013,"；"],[-1,17014,"；\n"],[1,17018,"\n"],[1,17050,"；"],[-1,17051,"；\n"],[1,17055,"\n"],[1,17115,"；数"],[-1,17115,"数；\n"],[1,17120,"\n"],[1,17138,"；"],[-1,17139,"；"],[-1,17163,"\n"],[1,17166,"\n"],[-1,17179,"\n"],[1,17184,"\n"],[-1,17209,"\n"],[1,17214,"\n"],[-1,17231,"\n"],[1,17236,"\n"],[-1,17256,"\n"],[1,17261,"\n"],[-1,17282,"\n"],[1,17287,"\n"],[-1,17338,"\n"],[1,17346,"*"],[1,17352,"*"],[-1,17352,"贝\n"],[1,17356," "],[-1,17382,"\n"],[1,17384," "],[1,17421,"*"],[-1,17421,"1"],[1,17453,"*"],[-1,17453,"2"],[1,17458,"*C+*"],[-1,17458,"序C++"],[-1,17513,"\n"],[1,17520,"\n"],[-1,18448,"\n"],[1,18497,"\n"],[-1,18497,""]],[18498,18498],[12361,12361]]],[1542973283097,["gjx16@GJXAIOU",[[-1,15113,""],[1,15113,"/*\n\n第三种应用场景\n*/"],[-1,15182," "],[1,15183,"\t"],[-1,15192," "],[-1,15203," "],[-1,15216," "],[-1,15219," {\n "],[1,15223,"\t{\n\t\t"],[-1,15229," "],[-1,15238," "],[-1,15272," "],[-1,15275," }\n\n "],[1,15280,"\t}\n\n\t"],[-1,15289," "],[-1,15307,"p "],[1,15309,"obj"],[-1,15325," {\n "],[1,15329,"\t{\n\t\t"],[-1,15333,"p"],[1,15334,"obj"],[-1,15336," "],[-1,15343,"p.Y ; \n   "],[1,15353,"obj.Y;\n\t\t"],[-1,15395," "],[-1,15398," }\n\n "],[1,15403,"\t}\n\n\t"],[-1,15415," {\n "],[1,15419,"\t{\n\t\t"],[-1,15472," "],[-1,15475," }\n "],[1,15479,"\t}\n\t"],[-1,15487," "],[-1,15501," "],[-1,15514," "],[-1,15528," "],[-1,15541," "],[-1,15549," "],[-1,15553," "],[-1,15557," "],[-1,15563,"alt + f8 排版\n"],[1,15575,"这是业务函数，形参是一个元素"],[-1,15582," "],[-1,15584," "],[-1,15595," "],[-1,15597,"  "],[-1,15602," "],[1,15603,"\t"],[-1,15660," "],[-1,15686," \n "],[1,15689,"\n\t"],[-1,15699," "],[-1,15701," "],[-1,15706," "],[-1,15708," "],[1,15743,"\t   "],[-1,15745," "],[-1,15747," "],[-1,15749," "],[-1,15751," "],[-1,15770," \n "],[1,15773,"\n\t"],[-1,15789," "],[1,15790,"\t"],[-1,15808,"\n"]],[15113,15809],[15799,15799]]],[1542973348903,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[-1,13057,""],[1,13057,"\n"],[-1,13626,"\n"],[1,13627,"*"],[-1,13630,"*"],[-1,13820,"\n"],[1,13822,"\n"],[1,14252,"\n"],[-1,14255," "],[1,14256,"\n"],[-1,14261,"\n"],[1,14269,"\n"],[-1,14275,"\n"],[1,14448,"\n"],[-1,14451,"\n"],[1,14479,"\n"],[-1,15097,"\n"],[1,15105,"\n"],[-1,15128,"\n"],[1,15196,"\n"],[-1,15197," "],[-1,15206," "],[1,15207,"("],[-1,15216," "],[1,15217,"0"],[-1,15228," )"],[1,15230,"0)\n"],[-1,15235," "],[-1,15241," "],[1,15242,"x"],[-1,15249," "],[1,15250,"y"],[-1,15282," ;"],[1,15284,"\";\n"],[-1,15289," "],[-1,15298," "],[1,15299,"("],[1,15315," "],[-1,15318," "],[1,15334,"\n"],[-1,15339," "],[1,15343," "],[-1,15346,"p. "],[1,15349,".X"],[1,15354," "],[-1,15363," "],[-1,15405," ;"],[1,15407,"l;\n"],[-1,15412," "],[1,15424,"\n"],[-1,15429," "],[-1,15482," ;"],[1,15484,"l;\n"],[-1,15488," "],[-1,15496," "],[1,15497,"X"],[-1,15509," "],[1,15510,"X"],[-1,15521," "],[1,15522,"Y"],[-1,15534," "],[1,15535,"Y"],[-1,15546," "],[1,15547,"e"],[-1,15553," ,  ;\n "],[1,15560,"X, Y;\n}"],[1,15563,"/"],[-1,15578,"\n"],[-1,15585,"  "],[1,15587,"f("],[-1,15596,"  "],[1,15598,"p)"],[1,15600,"\n"],[-1,15601," "],[-1,15658," "],[1,15659,"l"],[1,15683,"{"],[-1,15685," "],[-1,15695,"  1,   "],[1,15702,"A(1, 2)"],[1,15735,"\n"],[-1,15739,"\n     "],[1,15745," f(A)"],[1,15762,"{"],[-1,15764," "],[1,15780,"\n"],[-1,15781," "],[1,15799,"}"],[-1,15803,"|"],[1,15804,"\n"],[-1,15809,"\n"],[-1,15818," "],[1,15819,"\n\n"],[-1,16788,"\n"],[1,16789,"*"],[-1,16792,"*"],[1,16802,"\n"],[-1,16804,"\n"],[1,16814,"\n"],[-1,16818,"\n"],[1,16829,"\n"],[-1,16831,"\n"],[1,16870,"\n"],[-1,16874,"\n"],[1,16885,"\n"],[-1,16887,"\n"],[-1,16934,"`"],[1,16935,"\n\n"],[-1,16945,"3"],[-1,16955,"*"],[1,16956,"究\n"],[-1,16959,"\n"],[-1,16998,"拷"],[1,16999,"认"],[-1,17004,"；"],[1,17006,"；\n"],[-1,17008,"\n"],[-1,17041,"；"],[1,17043,"；\n"],[-1,17045,"\n"],[-1,17106,"；数"],[1,17108,"数；\n"],[-1,17110,"\n"],[-1,17129,"；"],[1,17131,"；"],[1,17154,"\n"],[-1,17156,"\n"],[1,17170,"\n"],[-1,17174,"\n"],[1,17200,"\n"],[-1,17204,"\n"],[1,17222,"\n"],[-1,17226,"\n"],[1,17247,"\n"],[-1,17251,"\n"],[1,17273,"\n"],[-1,17277,"\n"],[1,17329,"\n"],[-1,17336,"*"],[-1,17343,"*"],[1,17344,"贝\n"],[-1,17346," "],[1,17373,"\n"],[-1,17374," "],[-1,17412,"*"],[1,17413,"1"],[-1,17444,"*"],[1,17445,"2"],[-1,17449,"*C+*"],[1,17453,"序C++"],[1,17504,"\n"],[-1,17510,"\n"],[1,18439,"\n"],[-1,18487,"\n"],[1,18488,""]],[12361,12361],[18488,18488]]],[1542973348903,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[1,13056,""],[-1,13056,"\n"],[1,13626,"\n"],[-1,13626,"*"],[1,13630,"*"],[1,13819,"\n"],[-1,13820,"\n"],[-1,14251,"\n"],[1,14255," "],[-1,14255,"\n"],[1,14261,"\n"],[-1,14268,"\n"],[1,14275,"\n"],[-1,14447,"\n"],[1,14451,"\n"],[-1,14478,"\n"],[1,15097,"\n"],[-1,15104,"\n"],[1,15128,"\n"],[-1,15195,"\n"],[1,15197," "],[1,15205," "],[-1,15205,"("],[1,15215," "],[-1,15215,"0"],[1,15227," )"],[-1,15227,"0)\n"],[1,15235," "],[1,15240," "],[-1,15240,"x"],[1,15248," "],[-1,15248,"y"],[1,15281," ;"],[-1,15281,"\";\n"],[1,15289," "],[1,15297," "],[-1,15297,"("],[-1,15314," "],[1,15318," "],[-1,15333,"\n"],[1,15339," "],[-1,15342," "],[1,15346,"p. "],[-1,15346,".X"],[-1,15353," "],[1,15363," "],[1,15404," ;"],[-1,15404,"l;\n"],[1,15412," "],[-1,15423,"\n"],[1,15429," "],[1,15481," ;"],[-1,15481,"l;\n"],[1,15488," "],[1,15495," "],[-1,15495,"X"],[1,15508," "],[-1,15508,"X"],[1,15520," "],[-1,15520,"Y"],[1,15533," "],[-1,15533,"Y"],[1,15545," "],[-1,15545,"e"],[1,15552," ,  ;\n "],[-1,15552,"X, Y;\n}"],[-1,15562,"/"],[1,15578,"\n"],[1,15584,"  "],[-1,15584,"f("],[1,15595,"  "],[-1,15595,"p)"],[-1,15599,"\n"],[1,15601," "],[1,15657," "],[-1,15657,"l"],[-1,15682,"{"],[1,15685," "],[1,15694,"  1,   "],[-1,15694,"A(1, 2)"],[-1,15734,"\n"],[1,15739,"\n     "],[-1,15739," f(A)"],[-1,15761,"{"],[1,15764," "],[-1,15779,"\n"],[1,15781," "],[-1,15798,"}"],[1,15803,"|"],[-1,15803,"\n"],[1,15809,"\n"],[1,15817," "],[-1,15817,"\n\n"],[1,16788,"\n"],[-1,16788,"*"],[1,16792,"*"],[-1,16801,"\n"],[1,16804,"\n"],[-1,16813,"\n"],[1,16818,"\n"],[-1,16828,"\n"],[1,16831,"\n"],[-1,16869,"\n"],[1,16874,"\n"],[-1,16884,"\n"],[1,16887,"\n"],[1,16933,"`"],[-1,16933,"\n\n"],[1,16945,"3"],[1,16954,"*"],[-1,16954,"究\n"],[1,16959,"\n"],[1,16997,"拷"],[-1,16997,"认"],[1,17003,"；"],[-1,17004,"；\n"],[1,17008,"\n"],[1,17040,"；"],[-1,17041,"；\n"],[1,17045,"\n"],[1,17105,"；数"],[-1,17105,"数；\n"],[1,17110,"\n"],[1,17128,"；"],[-1,17129,"；"],[-1,17153,"\n"],[1,17156,"\n"],[-1,17169,"\n"],[1,17174,"\n"],[-1,17199,"\n"],[1,17204,"\n"],[-1,17221,"\n"],[1,17226,"\n"],[-1,17246,"\n"],[1,17251,"\n"],[-1,17272,"\n"],[1,17277,"\n"],[-1,17328,"\n"],[1,17336,"*"],[1,17342,"*"],[-1,17342,"贝\n"],[1,17346," "],[-1,17372,"\n"],[1,17374," "],[1,17411,"*"],[-1,17411,"1"],[1,17443,"*"],[-1,17443,"2"],[1,17448,"*C+*"],[-1,17448,"序C++"],[-1,17503,"\n"],[1,17510,"\n"],[-1,18438,"\n"],[1,18487,"\n"],[-1,18487,""]],[18488,18488],[12361,12361]]],[1542973346888,["gjx16@GJXAIOU",[[1,12721,",zheli"]],[12721,12721],[12727,12727]]],[1542973348542,["gjx16@GJXAIOU",[[-1,12723,"heli"]],[12727,12727],[12723,12723]]],[1542973408889,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12723,"数"],[-1,13059,""],[1,13059,"\n"],[-1,13628,"\n"],[1,13629,"*"],[-1,13632,"*"],[-1,13822,"\n"],[1,13824,"\n"],[1,14254,"\n"],[-1,14257," "],[1,14258,"\n"],[-1,14263,"\n"],[1,14271,"\n"],[-1,14277,"\n"],[1,14450,"\n"],[-1,14453,"\n"],[1,14481,"\n"],[-1,15099,"\n"],[1,15107,"\n"],[-1,15130,"\n"],[1,15198,"\n"],[-1,15199," "],[-1,15208," "],[1,15209,"("],[-1,15218," "],[1,15219,"0"],[-1,15230," )"],[1,15232,"0)\n"],[-1,15237," "],[-1,15243," "],[1,15244,"x"],[-1,15251," "],[1,15252,"y"],[-1,15284," ;"],[1,15286,"\";\n"],[-1,15291," "],[-1,15300," "],[1,15301,"("],[1,15317," "],[-1,15320," "],[1,15336,"\n"],[-1,15341," "],[1,15345," "],[-1,15348,"p. "],[1,15351,".X"],[1,15356," "],[-1,15365," "],[-1,15407," ;"],[1,15409,"l;\n"],[-1,15414," "],[1,15426,"\n"],[-1,15431," "],[-1,15484," ;"],[1,15486,"l;\n"],[-1,15490," "],[-1,15498," "],[1,15499,"X"],[-1,15511," "],[1,15512,"X"],[-1,15523," "],[1,15524,"Y"],[-1,15536," "],[1,15537,"Y"],[-1,15548," "],[1,15549,"e"],[-1,15555," ,  ;\n "],[1,15562,"X, Y;\n}"],[1,15565,"/"],[-1,15580,"\n"],[-1,15587,"  "],[1,15589,"f("],[-1,15598,"  "],[1,15600,"p)"],[1,15602,"\n"],[-1,15603," "],[-1,15660," "],[1,15661,"l"],[1,15685,"{"],[-1,15687," "],[-1,15697,"  1,   "],[1,15704,"A(1, 2)"],[1,15737,"\n"],[-1,15741,"\n     "],[1,15747," f(A)"],[1,15764,"{"],[-1,15766," "],[1,15782,"\n"],[-1,15783," "],[1,15801,"}"],[-1,15805,"|"],[1,15806,"\n"],[-1,15811,"\n"],[-1,15820," "],[1,15821,"\n\n"],[-1,16790,"\n"],[1,16791,"*"],[-1,16794,"*"],[1,16804,"\n"],[-1,16806,"\n"],[1,16816,"\n"],[-1,16820,"\n"],[1,16831,"\n"],[-1,16833,"\n"],[1,16872,"\n"],[-1,16876,"\n"],[1,16887,"\n"],[-1,16889,"\n"],[-1,16936,"`"],[1,16937,"\n\n"],[-1,16947,"3"],[-1,16957,"*"],[1,16958,"究\n"],[-1,16961,"\n"],[-1,17000,"拷"],[1,17001,"认"],[-1,17006,"；"],[1,17008,"；\n"],[-1,17010,"\n"],[-1,17043,"；"],[1,17045,"；\n"],[-1,17047,"\n"],[-1,17108,"；数"],[1,17110,"数；\n"],[-1,17112,"\n"],[-1,17131,"；"],[1,17133,"；"],[1,17156,"\n"],[-1,17158,"\n"],[1,17172,"\n"],[-1,17176,"\n"],[1,17202,"\n"],[-1,17206,"\n"],[1,17224,"\n"],[-1,17228,"\n"],[1,17249,"\n"],[-1,17253,"\n"],[1,17275,"\n"],[-1,17279,"\n"],[1,17331,"\n"],[-1,17338,"*"],[-1,17345,"*"],[1,17346,"贝\n"],[-1,17348," "],[1,17375,"\n"],[-1,17376," "],[-1,17414,"*"],[1,17415,"1"],[-1,17446,"*"],[1,17447,"2"],[-1,17451,"*C+*"],[1,17455,"序C++"],[1,17506,"\n"],[-1,17512,"\n"],[1,18441,"\n"],[-1,18489,"\n"],[1,18490,""]],[12361,12361],[18490,18490]]],[1542973408889,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12723,"数"],[1,13058,""],[-1,13058,"\n"],[1,13628,"\n"],[-1,13628,"*"],[1,13632,"*"],[1,13821,"\n"],[-1,13822,"\n"],[-1,14253,"\n"],[1,14257," "],[-1,14257,"\n"],[1,14263,"\n"],[-1,14270,"\n"],[1,14277,"\n"],[-1,14449,"\n"],[1,14453,"\n"],[-1,14480,"\n"],[1,15099,"\n"],[-1,15106,"\n"],[1,15130,"\n"],[-1,15197,"\n"],[1,15199," "],[1,15207," "],[-1,15207,"("],[1,15217," "],[-1,15217,"0"],[1,15229," )"],[-1,15229,"0)\n"],[1,15237," "],[1,15242," "],[-1,15242,"x"],[1,15250," "],[-1,15250,"y"],[1,15283," ;"],[-1,15283,"\";\n"],[1,15291," "],[1,15299," "],[-1,15299,"("],[-1,15316," "],[1,15320," "],[-1,15335,"\n"],[1,15341," "],[-1,15344," "],[1,15348,"p. "],[-1,15348,".X"],[-1,15355," "],[1,15365," "],[1,15406," ;"],[-1,15406,"l;\n"],[1,15414," "],[-1,15425,"\n"],[1,15431," "],[1,15483," ;"],[-1,15483,"l;\n"],[1,15490," "],[1,15497," "],[-1,15497,"X"],[1,15510," "],[-1,15510,"X"],[1,15522," "],[-1,15522,"Y"],[1,15535," "],[-1,15535,"Y"],[1,15547," "],[-1,15547,"e"],[1,15554," ,  ;\n "],[-1,15554,"X, Y;\n}"],[-1,15564,"/"],[1,15580,"\n"],[1,15586,"  "],[-1,15586,"f("],[1,15597,"  "],[-1,15597,"p)"],[-1,15601,"\n"],[1,15603," "],[1,15659," "],[-1,15659,"l"],[-1,15684,"{"],[1,15687," "],[1,15696,"  1,   "],[-1,15696,"A(1, 2)"],[-1,15736,"\n"],[1,15741,"\n     "],[-1,15741," f(A)"],[-1,15763,"{"],[1,15766," "],[-1,15781,"\n"],[1,15783," "],[-1,15800,"}"],[1,15805,"|"],[-1,15805,"\n"],[1,15811,"\n"],[1,15819," "],[-1,15819,"\n\n"],[1,16790,"\n"],[-1,16790,"*"],[1,16794,"*"],[-1,16803,"\n"],[1,16806,"\n"],[-1,16815,"\n"],[1,16820,"\n"],[-1,16830,"\n"],[1,16833,"\n"],[-1,16871,"\n"],[1,16876,"\n"],[-1,16886,"\n"],[1,16889,"\n"],[1,16935,"`"],[-1,16935,"\n\n"],[1,16947,"3"],[1,16956,"*"],[-1,16956,"究\n"],[1,16961,"\n"],[1,16999,"拷"],[-1,16999,"认"],[1,17005,"；"],[-1,17006,"；\n"],[1,17010,"\n"],[1,17042,"；"],[-1,17043,"；\n"],[1,17047,"\n"],[1,17107,"；数"],[-1,17107,"数；\n"],[1,17112,"\n"],[1,17130,"；"],[-1,17131,"；"],[-1,17155,"\n"],[1,17158,"\n"],[-1,17171,"\n"],[1,17176,"\n"],[-1,17201,"\n"],[1,17206,"\n"],[-1,17223,"\n"],[1,17228,"\n"],[-1,17248,"\n"],[1,17253,"\n"],[-1,17274,"\n"],[1,17279,"\n"],[-1,17330,"\n"],[1,17338,"*"],[1,17344,"*"],[-1,17344,"贝\n"],[1,17348," "],[-1,17374,"\n"],[1,17376," "],[1,17413,"*"],[-1,17413,"1"],[1,17445,"*"],[-1,17445,"2"],[1,17450,"*C+*"],[-1,17450,"序C++"],[-1,17505,"\n"],[1,17512,"\n"],[-1,18440,"\n"],[1,18489,"\n"],[-1,18489,""]],[18490,18490],[12361,12361]]],[1542973352667,["gjx16@GJXAIOU",[[1,12721,",zheli"]],[12721,12721],[12727,12727]]],[1542973356346,["gjx16@GJXAIOU",[[-1,12722,"zheli"]],[12727,12727],[12722,12722]]],[1542973362726,["gjx16@GJXAIOU",[[1,12722,"这里的const kejia"]],[12722,12722],[12736,12736]]],[1542973364465,["gjx16@GJXAIOU",[[-1,12730," kejia"]],[12736,12736],[12730,12730]]],[1542973366455,["gjx16@GJXAIOU",[[1,12730,"k"]],[12730,12730],[12731,12731]]],[1542973366992,["gjx16@GJXAIOU",[[-1,12730,"k"]],[12731,12731],[12730,12730]]],[1542973383740,["gjx16@GJXAIOU",[[1,12730,"可加可不加，后面的obj 自己变换"]],[12730,12730],[12747,12747]]],[1542973708893,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12747,",z数"],[-1,13085,""],[1,13085,"\n"],[-1,13654,"\n"],[1,13655,"*"],[-1,13658,"*"],[-1,13848,"\n"],[1,13850,"\n"],[1,14280,"\n"],[-1,14283," "],[1,14284,"\n"],[-1,14289,"\n"],[1,14297,"\n"],[-1,14303,"\n"],[1,14476,"\n"],[-1,14479,"\n"],[1,14507,"\n"],[-1,15125,"\n"],[1,15133,"\n"],[-1,15156,"\n"],[1,15224,"\n"],[-1,15225," "],[-1,15234," "],[1,15235,"("],[-1,15244," "],[1,15245,"0"],[-1,15256," )"],[1,15258,"0)\n"],[-1,15263," "],[-1,15269," "],[1,15270,"x"],[-1,15277," "],[1,15278,"y"],[-1,15310," ;"],[1,15312,"\";\n"],[-1,15317," "],[-1,15326," "],[1,15327,"("],[1,15343," "],[-1,15346," "],[1,15362,"\n"],[-1,15367," "],[1,15371," "],[-1,15374,"p. "],[1,15377,".X"],[1,15382," "],[-1,15391," "],[-1,15433," ;"],[1,15435,"l;\n"],[-1,15440," "],[1,15452,"\n"],[-1,15457," "],[-1,15510," ;"],[1,15512,"l;\n"],[-1,15516," "],[-1,15524," "],[1,15525,"X"],[-1,15537," "],[1,15538,"X"],[-1,15549," "],[1,15550,"Y"],[-1,15562," "],[1,15563,"Y"],[-1,15574," "],[1,15575,"e"],[-1,15581," ,  ;\n "],[1,15588,"X, Y;\n}"],[1,15591,"/"],[-1,15606,"\n"],[-1,15613,"  "],[1,15615,"f("],[-1,15624,"  "],[1,15626,"p)"],[1,15628,"\n"],[-1,15629," "],[-1,15686," "],[1,15687,"l"],[1,15711,"{"],[-1,15713," "],[-1,15723,"  1,   "],[1,15730,"A(1, 2)"],[1,15763,"\n"],[-1,15767,"\n     "],[1,15773," f(A)"],[1,15790,"{"],[-1,15792," "],[1,15808,"\n"],[-1,15809," "],[1,15827,"}"],[-1,15831,"|"],[1,15832,"\n"],[-1,15837,"\n"],[-1,15846," "],[1,15847,"\n\n"],[-1,16816,"\n"],[1,16817,"*"],[-1,16820,"*"],[1,16830,"\n"],[-1,16832,"\n"],[1,16842,"\n"],[-1,16846,"\n"],[1,16857,"\n"],[-1,16859,"\n"],[1,16898,"\n"],[-1,16902,"\n"],[1,16913,"\n"],[-1,16915,"\n"],[-1,16962,"`"],[1,16963,"\n\n"],[-1,16973,"3"],[-1,16983,"*"],[1,16984,"究\n"],[-1,16987,"\n"],[-1,17026,"拷"],[1,17027,"认"],[-1,17032,"；"],[1,17034,"；\n"],[-1,17036,"\n"],[-1,17069,"；"],[1,17071,"；\n"],[-1,17073,"\n"],[-1,17134,"；数"],[1,17136,"数；\n"],[-1,17138,"\n"],[-1,17157,"；"],[1,17159,"；"],[1,17182,"\n"],[-1,17184,"\n"],[1,17198,"\n"],[-1,17202,"\n"],[1,17228,"\n"],[-1,17232,"\n"],[1,17250,"\n"],[-1,17254,"\n"],[1,17275,"\n"],[-1,17279,"\n"],[1,17301,"\n"],[-1,17305,"\n"],[1,17357,"\n"],[-1,17364,"*"],[-1,17371,"*"],[1,17372,"贝\n"],[-1,17374," "],[1,17401,"\n"],[-1,17402," "],[-1,17440,"*"],[1,17441,"1"],[-1,17472,"*"],[1,17473,"2"],[-1,17477,"*C+*"],[1,17481,"序C++"],[1,17532,"\n"],[-1,17538,"\n"],[1,18467,"\n"],[-1,18515,"\n"],[1,18516,""]],[12361,12361],[18516,18516]]],[1542973708893,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12747,",z数"],[1,13082,""],[-1,13082,"\n"],[1,13652,"\n"],[-1,13652,"*"],[1,13656,"*"],[1,13845,"\n"],[-1,13846,"\n"],[-1,14277,"\n"],[1,14281," "],[-1,14281,"\n"],[1,14287,"\n"],[-1,14294,"\n"],[1,14301,"\n"],[-1,14473,"\n"],[1,14477,"\n"],[-1,14504,"\n"],[1,15123,"\n"],[-1,15130,"\n"],[1,15154,"\n"],[-1,15221,"\n"],[1,15223," "],[1,15231," "],[-1,15231,"("],[1,15241," "],[-1,15241,"0"],[1,15253," )"],[-1,15253,"0)\n"],[1,15261," "],[1,15266," "],[-1,15266,"x"],[1,15274," "],[-1,15274,"y"],[1,15307," ;"],[-1,15307,"\";\n"],[1,15315," "],[1,15323," "],[-1,15323,"("],[-1,15340," "],[1,15344," "],[-1,15359,"\n"],[1,15365," "],[-1,15368," "],[1,15372,"p. "],[-1,15372,".X"],[-1,15379," "],[1,15389," "],[1,15430," ;"],[-1,15430,"l;\n"],[1,15438," "],[-1,15449,"\n"],[1,15455," "],[1,15507," ;"],[-1,15507,"l;\n"],[1,15514," "],[1,15521," "],[-1,15521,"X"],[1,15534," "],[-1,15534,"X"],[1,15546," "],[-1,15546,"Y"],[1,15559," "],[-1,15559,"Y"],[1,15571," "],[-1,15571,"e"],[1,15578," ,  ;\n "],[-1,15578,"X, Y;\n}"],[-1,15588,"/"],[1,15604,"\n"],[1,15610,"  "],[-1,15610,"f("],[1,15621,"  "],[-1,15621,"p)"],[-1,15625,"\n"],[1,15627," "],[1,15683," "],[-1,15683,"l"],[-1,15708,"{"],[1,15711," "],[1,15720,"  1,   "],[-1,15720,"A(1, 2)"],[-1,15760,"\n"],[1,15765,"\n     "],[-1,15765," f(A)"],[-1,15787,"{"],[1,15790," "],[-1,15805,"\n"],[1,15807," "],[-1,15824,"}"],[1,15829,"|"],[-1,15829,"\n"],[1,15835,"\n"],[1,15843," "],[-1,15843,"\n\n"],[1,16814,"\n"],[-1,16814,"*"],[1,16818,"*"],[-1,16827,"\n"],[1,16830,"\n"],[-1,16839,"\n"],[1,16844,"\n"],[-1,16854,"\n"],[1,16857,"\n"],[-1,16895,"\n"],[1,16900,"\n"],[-1,16910,"\n"],[1,16913,"\n"],[1,16959,"`"],[-1,16959,"\n\n"],[1,16971,"3"],[1,16980,"*"],[-1,16980,"究\n"],[1,16985,"\n"],[1,17023,"拷"],[-1,17023,"认"],[1,17029,"；"],[-1,17030,"；\n"],[1,17034,"\n"],[1,17066,"；"],[-1,17067,"；\n"],[1,17071,"\n"],[1,17131,"；数"],[-1,17131,"数；\n"],[1,17136,"\n"],[1,17154,"；"],[-1,17155,"；"],[-1,17179,"\n"],[1,17182,"\n"],[-1,17195,"\n"],[1,17200,"\n"],[-1,17225,"\n"],[1,17230,"\n"],[-1,17247,"\n"],[1,17252,"\n"],[-1,17272,"\n"],[1,17277,"\n"],[-1,17298,"\n"],[1,17303,"\n"],[-1,17354,"\n"],[1,17362,"*"],[1,17368,"*"],[-1,17368,"贝\n"],[1,17372," "],[-1,17398,"\n"],[1,17400," "],[1,17437,"*"],[-1,17437,"1"],[1,17469,"*"],[-1,17469,"2"],[1,17474,"*C+*"],[-1,17474,"序C++"],[-1,17529,"\n"],[1,17536,"\n"],[-1,18464,"\n"],[1,18513,"\n"],[-1,18513,""]],[18516,18516],[12361,12361]]],[1542973692706,["gjx16@GJXAIOU",[[1,12747,"  "]],[12747,12747],[12749,12749]]],[1542974248913,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13656,"\n"],[1,13657,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[-1,16818,"\n"],[1,16819,"*"],[-1,16822,"*"],[1,16832,"\n"],[-1,16834,"\n"],[1,16844,"\n"],[-1,16848,"\n"],[1,16859,"\n"],[-1,16861,"\n"],[1,16900,"\n"],[-1,16904,"\n"],[1,16915,"\n"],[-1,16917,"\n"],[-1,16964,"`"],[1,16965,"\n\n"],[-1,16975,"3"],[-1,16985,"*"],[1,16986,"究\n"],[-1,16989,"\n"],[-1,17028,"拷"],[1,17029,"认"],[-1,17034,"；"],[1,17036,"；\n"],[-1,17038,"\n"],[-1,17071,"；"],[1,17073,"；\n"],[-1,17075,"\n"],[-1,17136,"；数"],[1,17138,"数；\n"],[-1,17140,"\n"],[-1,17159,"；"],[1,17161,"；"],[1,17184,"\n"],[-1,17186,"\n"],[1,17200,"\n"],[-1,17204,"\n"],[1,17230,"\n"],[-1,17234,"\n"],[1,17252,"\n"],[-1,17256,"\n"],[1,17277,"\n"],[-1,17281,"\n"],[1,17303,"\n"],[-1,17307,"\n"],[1,17359,"\n"],[-1,17366,"*"],[-1,17373,"*"],[1,17374,"贝\n"],[-1,17376," "],[1,17403,"\n"],[-1,17404," "],[-1,17442,"*"],[1,17443,"1"],[-1,17474,"*"],[1,17475,"2"],[-1,17479,"*C+*"],[1,17483,"序C++"],[1,17534,"\n"],[-1,17540,"\n"],[1,18469,"\n"],[-1,18517,"\n"],[1,18518,""]],[12361,12361],[18518,18518]]],[1542974248913,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13654,"\n"],[-1,13654,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[1,16816,"\n"],[-1,16816,"*"],[1,16820,"*"],[-1,16829,"\n"],[1,16832,"\n"],[-1,16841,"\n"],[1,16846,"\n"],[-1,16856,"\n"],[1,16859,"\n"],[-1,16897,"\n"],[1,16902,"\n"],[-1,16912,"\n"],[1,16915,"\n"],[1,16961,"`"],[-1,16961,"\n\n"],[1,16973,"3"],[1,16982,"*"],[-1,16982,"究\n"],[1,16987,"\n"],[1,17025,"拷"],[-1,17025,"认"],[1,17031,"；"],[-1,17032,"；\n"],[1,17036,"\n"],[1,17068,"；"],[-1,17069,"；\n"],[1,17073,"\n"],[1,17133,"；数"],[-1,17133,"数；\n"],[1,17138,"\n"],[1,17156,"；"],[-1,17157,"；"],[-1,17181,"\n"],[1,17184,"\n"],[-1,17197,"\n"],[1,17202,"\n"],[-1,17227,"\n"],[1,17232,"\n"],[-1,17249,"\n"],[1,17254,"\n"],[-1,17274,"\n"],[1,17279,"\n"],[-1,17300,"\n"],[1,17305,"\n"],[-1,17356,"\n"],[1,17364,"*"],[1,17370,"*"],[-1,17370,"贝\n"],[1,17374," "],[-1,17400,"\n"],[1,17402," "],[1,17439,"*"],[-1,17439,"1"],[1,17471,"*"],[-1,17471,"2"],[1,17476,"*C+*"],[-1,17476,"序C++"],[-1,17531,"\n"],[1,17538,"\n"],[-1,18466,"\n"],[1,18515,"\n"],[-1,18515,""]],[18518,18518],[12361,12361]]],[1542974223992,["gjx16@GJXAIOU",[[1,16389,"、、"]],[16389,16389],[16391,16391]]],[1542974225500,["gjx16@GJXAIOU",[[-1,16389,"、、"]],[16391,16391],[16389,16389]]],[1542974238084,["gjx16@GJXAIOU",[[1,16389,"//结论一："]],[16389,16389],[16395,16395]]],[1542974241118,["gjx16@GJXAIOU",[[1,16389,"\n"]],[16389,16389],[16390,16390]]],[1542974247907,["gjx16@GJXAIOU",[[1,16396,"函数的"]],[16396,16396],[16399,16399]]],[1542974308911,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13656,"\n"],[1,13657,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16399,"}\n"],[-1,16828,"\n"],[1,16829,"*"],[-1,16832,"*"],[1,16842,"\n"],[-1,16844,"\n"],[1,16854,"\n"],[-1,16858,"\n"],[1,16869,"\n"],[-1,16871,"\n"],[1,16910,"\n"],[-1,16914,"\n"],[1,16925,"\n"],[-1,16927,"\n"],[-1,16974,"`"],[1,16975,"\n\n"],[-1,16985,"3"],[-1,16995,"*"],[1,16996,"究\n"],[-1,16999,"\n"],[-1,17038,"拷"],[1,17039,"认"],[-1,17044,"；"],[1,17046,"；\n"],[-1,17048,"\n"],[-1,17081,"；"],[1,17083,"；\n"],[-1,17085,"\n"],[-1,17146,"；数"],[1,17148,"数；\n"],[-1,17150,"\n"],[-1,17169,"；"],[1,17171,"；"],[1,17194,"\n"],[-1,17196,"\n"],[1,17210,"\n"],[-1,17214,"\n"],[1,17240,"\n"],[-1,17244,"\n"],[1,17262,"\n"],[-1,17266,"\n"],[1,17287,"\n"],[-1,17291,"\n"],[1,17313,"\n"],[-1,17317,"\n"],[1,17369,"\n"],[-1,17376,"*"],[-1,17383,"*"],[1,17384,"贝\n"],[-1,17386," "],[1,17413,"\n"],[-1,17414," "],[-1,17452,"*"],[1,17453,"1"],[-1,17484,"*"],[1,17485,"2"],[-1,17489,"*C+*"],[1,17493,"序C++"],[1,17544,"\n"],[-1,17550,"\n"],[1,18479,"\n"],[-1,18527,"\n"],[1,18528,""]],[12361,12361],[18528,18528]]],[1542974308911,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13654,"\n"],[-1,13654,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16399,"}\n"],[1,16826,"\n"],[-1,16826,"*"],[1,16830,"*"],[-1,16839,"\n"],[1,16842,"\n"],[-1,16851,"\n"],[1,16856,"\n"],[-1,16866,"\n"],[1,16869,"\n"],[-1,16907,"\n"],[1,16912,"\n"],[-1,16922,"\n"],[1,16925,"\n"],[1,16971,"`"],[-1,16971,"\n\n"],[1,16983,"3"],[1,16992,"*"],[-1,16992,"究\n"],[1,16997,"\n"],[1,17035,"拷"],[-1,17035,"认"],[1,17041,"；"],[-1,17042,"；\n"],[1,17046,"\n"],[1,17078,"；"],[-1,17079,"；\n"],[1,17083,"\n"],[1,17143,"；数"],[-1,17143,"数；\n"],[1,17148,"\n"],[1,17166,"；"],[-1,17167,"；"],[-1,17191,"\n"],[1,17194,"\n"],[-1,17207,"\n"],[1,17212,"\n"],[-1,17237,"\n"],[1,17242,"\n"],[-1,17259,"\n"],[1,17264,"\n"],[-1,17284,"\n"],[1,17289,"\n"],[-1,17310,"\n"],[1,17315,"\n"],[-1,17366,"\n"],[1,17374,"*"],[1,17380,"*"],[-1,17380,"贝\n"],[1,17384," "],[-1,17410,"\n"],[1,17412," "],[1,17449,"*"],[-1,17449,"1"],[1,17481,"*"],[-1,17481,"2"],[1,17486,"*C+*"],[-1,17486,"序C++"],[-1,17541,"\n"],[1,17548,"\n"],[-1,18476,"\n"],[1,18525,"\n"],[-1,18525,""]],[18528,18528],[12361,12361]]],[1542974259710,["gjx16@GJXAIOU",[[1,16399,"返回值是一个元素（）"]],[16399,16399],[16409,16409]]],[1542974264077,["gjx16@GJXAIOU",[[1,16408,"复杂类型的"]],[16408,16408],[16413,16413]]],[1542974276895,["gjx16@GJXAIOU",[[1,16414,"，返回的是一个新的匿名对象（）"]],[16414,16414],[16429,16429]]],[1542974296166,["gjx16@GJXAIOU",[[1,16428,"所以会调用匿名对象类的ci"]],[16428,16428],[16441,16441]]],[1542974297188,["gjx16@GJXAIOU",[[-1,16440,"i"]],[16441,16441],[16440,16440]]],[1542974303299,["gjx16@GJXAIOU",[[1,16440,"opy构造哈数"]],[16440,16440],[16447,16447]]],[1542974303935,["gjx16@GJXAIOU",[[-1,16445,"哈数"]],[16447,16447],[16445,16445]]],[1542974308071,["gjx16@GJXAIOU",[[1,16445,"函数"]],[16445,16445],[16447,16447]]],[1542974368918,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13656,"\n"],[1,13657,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[-1,16877,"\n"],[1,16878,"*"],[-1,16881,"*"],[1,16891,"\n"],[-1,16893,"\n"],[1,16903,"\n"],[-1,16907,"\n"],[1,16918,"\n"],[-1,16920,"\n"],[1,16959,"\n"],[-1,16963,"\n"],[1,16974,"\n"],[-1,16976,"\n"],[-1,17023,"`"],[1,17024,"\n\n"],[-1,17034,"3"],[-1,17044,"*"],[1,17045,"究\n"],[-1,17048,"\n"],[-1,17087,"拷"],[1,17088,"认"],[-1,17093,"；"],[1,17095,"；\n"],[-1,17097,"\n"],[-1,17130,"；"],[1,17132,"；\n"],[-1,17134,"\n"],[-1,17195,"；数"],[1,17197,"数；\n"],[-1,17199,"\n"],[-1,17218,"；"],[1,17220,"；"],[1,17243,"\n"],[-1,17245,"\n"],[1,17259,"\n"],[-1,17263,"\n"],[1,17289,"\n"],[-1,17293,"\n"],[1,17311,"\n"],[-1,17315,"\n"],[1,17336,"\n"],[-1,17340,"\n"],[1,17362,"\n"],[-1,17366,"\n"],[1,17418,"\n"],[-1,17425,"*"],[-1,17432,"*"],[1,17433,"贝\n"],[-1,17435," "],[1,17462,"\n"],[-1,17463," "],[-1,17501,"*"],[1,17502,"1"],[-1,17533,"*"],[1,17534,"2"],[-1,17538,"*C+*"],[1,17542,"序C++"],[1,17593,"\n"],[-1,17599,"\n"],[1,18528,"\n"],[-1,18576,"\n"],[1,18577,""]],[12361,12361],[18577,18577]]],[1542974368918,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13654,"\n"],[-1,13654,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[1,16875,"\n"],[-1,16875,"*"],[1,16879,"*"],[-1,16888,"\n"],[1,16891,"\n"],[-1,16900,"\n"],[1,16905,"\n"],[-1,16915,"\n"],[1,16918,"\n"],[-1,16956,"\n"],[1,16961,"\n"],[-1,16971,"\n"],[1,16974,"\n"],[1,17020,"`"],[-1,17020,"\n\n"],[1,17032,"3"],[1,17041,"*"],[-1,17041,"究\n"],[1,17046,"\n"],[1,17084,"拷"],[-1,17084,"认"],[1,17090,"；"],[-1,17091,"；\n"],[1,17095,"\n"],[1,17127,"；"],[-1,17128,"；\n"],[1,17132,"\n"],[1,17192,"；数"],[-1,17192,"数；\n"],[1,17197,"\n"],[1,17215,"；"],[-1,17216,"；"],[-1,17240,"\n"],[1,17243,"\n"],[-1,17256,"\n"],[1,17261,"\n"],[-1,17286,"\n"],[1,17291,"\n"],[-1,17308,"\n"],[1,17313,"\n"],[-1,17333,"\n"],[1,17338,"\n"],[-1,17359,"\n"],[1,17364,"\n"],[-1,17415,"\n"],[1,17423,"*"],[1,17429,"*"],[-1,17429,"贝\n"],[1,17433," "],[-1,17459,"\n"],[1,17461," "],[1,17498,"*"],[-1,17498,"1"],[1,17530,"*"],[-1,17530,"2"],[1,17535,"*C+*"],[-1,17535,"序C++"],[-1,17590,"\n"],[1,17597,"\n"],[-1,18525,"\n"],[1,18574,"\n"],[-1,18574,""]],[18577,18577],[12361,12361]]],[1542974342237,["gjx16@GJXAIOU",[[-1,16724,"\n"]],[16724,16724],[16723,16723]]],[1542974428916,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13654,"\n"],[1,13658,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[-1,16724,"\n"],[1,16725,"象"],[-1,16876,"\n"],[1,16877,"*"],[-1,16880,"*"],[1,16890,"\n"],[-1,16892,"\n"],[1,16902,"\n"],[-1,16906,"\n"],[1,16917,"\n"],[-1,16919,"\n"],[1,16958,"\n"],[-1,16962,"\n"],[1,16973,"\n"],[-1,16975,"\n"],[-1,17022,"`"],[1,17023,"\n\n"],[-1,17033,"3"],[-1,17043,"*"],[1,17044,"究\n"],[-1,17047,"\n"],[-1,17086,"拷"],[1,17087,"认"],[-1,17092,"；"],[1,17094,"；\n"],[-1,17096,"\n"],[-1,17129,"；"],[1,17131,"；\n"],[-1,17133,"\n"],[-1,17194,"；数"],[1,17196,"数；\n"],[-1,17198,"\n"],[-1,17217,"；"],[1,17219,"；"],[1,17242,"\n"],[-1,17244,"\n"],[1,17258,"\n"],[-1,17262,"\n"],[1,17288,"\n"],[-1,17292,"\n"],[1,17310,"\n"],[-1,17314,"\n"],[1,17335,"\n"],[-1,17339,"\n"],[1,17361,"\n"],[-1,17365,"\n"],[1,17417,"\n"],[-1,17424,"*"],[-1,17431,"*"],[1,17432,"贝\n"],[-1,17434," "],[1,17461,"\n"],[-1,17462," "],[-1,17500,"*"],[1,17501,"1"],[-1,17532,"*"],[1,17533,"2"],[-1,17537,"*C+*"],[1,17541,"序C++"],[1,17592,"\n"],[-1,17598,"\n"],[1,18527,"\n"],[-1,18575,"\n"],[1,18576,""]],[12361,12361],[18576,18576]]],[1542974428916,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13652,"\n"],[-1,13655,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[1,16722,"\n"],[-1,16722,"象"],[1,16874,"\n"],[-1,16874,"*"],[1,16878,"*"],[-1,16887,"\n"],[1,16890,"\n"],[-1,16899,"\n"],[1,16904,"\n"],[-1,16914,"\n"],[1,16917,"\n"],[-1,16955,"\n"],[1,16960,"\n"],[-1,16970,"\n"],[1,16973,"\n"],[1,17019,"`"],[-1,17019,"\n\n"],[1,17031,"3"],[1,17040,"*"],[-1,17040,"究\n"],[1,17045,"\n"],[1,17083,"拷"],[-1,17083,"认"],[1,17089,"；"],[-1,17090,"；\n"],[1,17094,"\n"],[1,17126,"；"],[-1,17127,"；\n"],[1,17131,"\n"],[1,17191,"；数"],[-1,17191,"数；\n"],[1,17196,"\n"],[1,17214,"；"],[-1,17215,"；"],[-1,17239,"\n"],[1,17242,"\n"],[-1,17255,"\n"],[1,17260,"\n"],[-1,17285,"\n"],[1,17290,"\n"],[-1,17307,"\n"],[1,17312,"\n"],[-1,17332,"\n"],[1,17337,"\n"],[-1,17358,"\n"],[1,17363,"\n"],[-1,17414,"\n"],[1,17422,"*"],[1,17428,"*"],[-1,17428,"贝\n"],[1,17432," "],[-1,17458,"\n"],[1,17460," "],[1,17497,"*"],[-1,17497,"1"],[1,17529,"*"],[-1,17529,"2"],[1,17534,"*C+*"],[-1,17534,"序C++"],[-1,17589,"\n"],[1,17596,"\n"],[-1,18524,"\n"],[1,18573,"\n"],[-1,18573,""]],[18576,18576],[12361,12361]]],[1542974377341,["gjx16@GJXAIOU",[[1,16723,"B"]],[16723,16723],[16724,16724]]],[1542974548920,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13654,"\n"],[1,13658,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[-1,16723,"B对\n"],[1,16726,"对象B"],[-1,16877,"\n"],[1,16878,"*"],[-1,16881,"*"],[1,16891,"\n"],[-1,16893,"\n"],[1,16903,"\n"],[-1,16907,"\n"],[1,16918,"\n"],[-1,16920,"\n"],[1,16959,"\n"],[-1,16963,"\n"],[1,16974,"\n"],[-1,16976,"\n"],[-1,17023,"`"],[1,17024,"\n\n"],[-1,17034,"3"],[-1,17044,"*"],[1,17045,"究\n"],[-1,17048,"\n"],[-1,17087,"拷"],[1,17088,"认"],[-1,17093,"；"],[1,17095,"；\n"],[-1,17097,"\n"],[-1,17130,"；"],[1,17132,"；\n"],[-1,17134,"\n"],[-1,17195,"；数"],[1,17197,"数；\n"],[-1,17199,"\n"],[-1,17218,"；"],[1,17220,"；"],[1,17243,"\n"],[-1,17245,"\n"],[1,17259,"\n"],[-1,17263,"\n"],[1,17289,"\n"],[-1,17293,"\n"],[1,17311,"\n"],[-1,17315,"\n"],[1,17336,"\n"],[-1,17340,"\n"],[1,17362,"\n"],[-1,17366,"\n"],[1,17418,"\n"],[-1,17425,"*"],[-1,17432,"*"],[1,17433,"贝\n"],[-1,17435," "],[1,17462,"\n"],[-1,17463," "],[-1,17501,"*"],[1,17502,"1"],[-1,17533,"*"],[1,17534,"2"],[-1,17538,"*C+*"],[1,17542,"序C++"],[1,17593,"\n"],[-1,17599,"\n"],[1,18528,"\n"],[-1,18576,"\n"],[1,18577,""]],[12361,12361],[18577,18577]]],[1542974548920,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13652,"\n"],[-1,13655,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[1,16721,"B对\n"],[-1,16721,"对象B"],[1,16875,"\n"],[-1,16875,"*"],[1,16879,"*"],[-1,16888,"\n"],[1,16891,"\n"],[-1,16900,"\n"],[1,16905,"\n"],[-1,16915,"\n"],[1,16918,"\n"],[-1,16956,"\n"],[1,16961,"\n"],[-1,16971,"\n"],[1,16974,"\n"],[1,17020,"`"],[-1,17020,"\n\n"],[1,17032,"3"],[1,17041,"*"],[-1,17041,"究\n"],[1,17046,"\n"],[1,17084,"拷"],[-1,17084,"认"],[1,17090,"；"],[-1,17091,"；\n"],[1,17095,"\n"],[1,17127,"；"],[-1,17128,"；\n"],[1,17132,"\n"],[1,17192,"；数"],[-1,17192,"数；\n"],[1,17197,"\n"],[1,17215,"；"],[-1,17216,"；"],[-1,17240,"\n"],[1,17243,"\n"],[-1,17256,"\n"],[1,17261,"\n"],[-1,17286,"\n"],[1,17291,"\n"],[-1,17308,"\n"],[1,17313,"\n"],[-1,17333,"\n"],[1,17338,"\n"],[-1,17359,"\n"],[1,17364,"\n"],[-1,17415,"\n"],[1,17423,"*"],[1,17429,"*"],[-1,17429,"贝\n"],[1,17433," "],[-1,17459,"\n"],[1,17461," "],[1,17498,"*"],[-1,17498,"1"],[1,17530,"*"],[-1,17530,"2"],[1,17535,"*C+*"],[-1,17535,"序C++"],[-1,17590,"\n"],[1,17597,"\n"],[-1,18525,"\n"],[1,18574,"\n"],[-1,18574,""]],[18577,18577],[12361,12361]]],[1542974499815,["gjx16@GJXAIOU",[[1,16724,"，不会被析构"]],[16724,16724],[16730,16730]]],[1542974668997,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13654,"\n"],[1,13658,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[1,16723,"对象"],[-1,16730,"对\n"],[-1,16883,"\n"],[1,16884,"*"],[-1,16887,"*"],[1,16897,"\n"],[-1,16899,"\n"],[1,16909,"\n"],[-1,16913,"\n"],[1,16924,"\n"],[-1,16926,"\n"],[1,16965,"\n"],[-1,16969,"\n"],[1,16980,"\n"],[-1,16982,"\n"],[-1,17029,"`"],[1,17030,"\n\n"],[-1,17040,"3"],[-1,17050,"*"],[1,17051,"究\n"],[-1,17054,"\n"],[-1,17093,"拷"],[1,17094,"认"],[-1,17099,"；"],[1,17101,"；\n"],[-1,17103,"\n"],[-1,17136,"；"],[1,17138,"；\n"],[-1,17140,"\n"],[-1,17201,"；数"],[1,17203,"数；\n"],[-1,17205,"\n"],[-1,17224,"；"],[1,17226,"；"],[1,17249,"\n"],[-1,17251,"\n"],[1,17265,"\n"],[-1,17269,"\n"],[1,17295,"\n"],[-1,17299,"\n"],[1,17317,"\n"],[-1,17321,"\n"],[1,17342,"\n"],[-1,17346,"\n"],[1,17368,"\n"],[-1,17372,"\n"],[1,17424,"\n"],[-1,17431,"*"],[-1,17438,"*"],[1,17439,"贝\n"],[-1,17441," "],[1,17468,"\n"],[-1,17469," "],[-1,17507,"*"],[1,17508,"1"],[-1,17539,"*"],[1,17540,"2"],[-1,17544,"*C+*"],[1,17548,"序C++"],[1,17599,"\n"],[-1,17605,"\n"],[1,18534,"\n"],[-1,18582,"\n"],[1,18583,""]],[12361,12361],[18583,18583]]],[1542974668997,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13652,"\n"],[-1,13655,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[-1,16721,"对象"],[1,16730,"对\n"],[1,16881,"\n"],[-1,16881,"*"],[1,16885,"*"],[-1,16894,"\n"],[1,16897,"\n"],[-1,16906,"\n"],[1,16911,"\n"],[-1,16921,"\n"],[1,16924,"\n"],[-1,16962,"\n"],[1,16967,"\n"],[-1,16977,"\n"],[1,16980,"\n"],[1,17026,"`"],[-1,17026,"\n\n"],[1,17038,"3"],[1,17047,"*"],[-1,17047,"究\n"],[1,17052,"\n"],[1,17090,"拷"],[-1,17090,"认"],[1,17096,"；"],[-1,17097,"；\n"],[1,17101,"\n"],[1,17133,"；"],[-1,17134,"；\n"],[1,17138,"\n"],[1,17198,"；数"],[-1,17198,"数；\n"],[1,17203,"\n"],[1,17221,"；"],[-1,17222,"；"],[-1,17246,"\n"],[1,17249,"\n"],[-1,17262,"\n"],[1,17267,"\n"],[-1,17292,"\n"],[1,17297,"\n"],[-1,17314,"\n"],[1,17319,"\n"],[-1,17339,"\n"],[1,17344,"\n"],[-1,17365,"\n"],[1,17370,"\n"],[-1,17421,"\n"],[1,17429,"*"],[1,17435,"*"],[-1,17435,"贝\n"],[1,17439," "],[-1,17465,"\n"],[1,17467," "],[1,17504,"*"],[-1,17504,"1"],[1,17536,"*"],[-1,17536,"2"],[1,17541,"*C+*"],[-1,17541,"序C++"],[-1,17596,"\n"],[1,17603,"\n"],[-1,18531,"\n"],[1,18580,"\n"],[-1,18580,""]],[18583,18583],[12361,12361]]],[1542974656851,["gjx16@GJXAIOU",[[-1,16639,"****"]],[16639,16643],[16639,16639]]],[1542974658915,["gjx16@GJXAIOU",[[-1,16634," **"]],[16634,16637],[16634,16634]]],[1542974660810,["gjx16@GJXAIOU",[[1,16634,"  "]],[16634,16634],[16636,16636]]],[1542974662862,["gjx16@GJXAIOU",[[-1,16643,"** **"]],[16643,16648],[16643,16643]]],[1542974664942,["gjx16@GJXAIOU",[[-1,16645,"** **"]],[16645,16650],[16645,16645]]],[1542974666878,["gjx16@GJXAIOU",[[-1,16647,"****"]],[16647,16651],[16647,16647]]],[1542974668555,["gjx16@GJXAIOU",[[-1,16658,"**"]],[16658,16660],[16658,16658]]],[1542977069041,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13654,"\n"],[1,13658,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[1,16634,");"],[-1,16636,"****用匿名******"],[1,16649,"//用匿名对象赋值给B"],[-1,16658,"**"],[1,16660,"析构"],[1,16702,"对象"],[-1,16709,"对\n"],[-1,16862,"\n"],[1,16863,"*"],[-1,16866,"*"],[1,16876,"\n"],[-1,16878,"\n"],[1,16888,"\n"],[-1,16892,"\n"],[1,16903,"\n"],[-1,16905,"\n"],[1,16944,"\n"],[-1,16948,"\n"],[1,16959,"\n"],[-1,16961,"\n"],[-1,17008,"`"],[1,17009,"\n\n"],[-1,17019,"3"],[-1,17029,"*"],[1,17030,"究\n"],[-1,17033,"\n"],[-1,17072,"拷"],[1,17073,"认"],[-1,17078,"；"],[1,17080,"；\n"],[-1,17082,"\n"],[-1,17115,"；"],[1,17117,"；\n"],[-1,17119,"\n"],[-1,17180,"；数"],[1,17182,"数；\n"],[-1,17184,"\n"],[-1,17203,"；"],[1,17205,"；"],[1,17228,"\n"],[-1,17230,"\n"],[1,17244,"\n"],[-1,17248,"\n"],[1,17274,"\n"],[-1,17278,"\n"],[1,17296,"\n"],[-1,17300,"\n"],[1,17321,"\n"],[-1,17325,"\n"],[1,17347,"\n"],[-1,17351,"\n"],[1,17403,"\n"],[-1,17410,"*"],[-1,17417,"*"],[1,17418,"贝\n"],[-1,17420," "],[1,17447,"\n"],[-1,17448," "],[-1,17486,"*"],[1,17487,"1"],[-1,17518,"*"],[1,17519,"2"],[-1,17523,"*C+*"],[1,17527,"序C++"],[1,17578,"\n"],[-1,17584,"\n"],[1,18513,"\n"],[-1,18561,"\n"],[1,18562,""]],[12361,12361],[18562,18562]]],[1542977069041,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13652,"\n"],[-1,13655,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[-1,16632,");"],[1,16636,"****用匿名******"],[-1,16636,"//用匿名对象赋值给B"],[1,16656,"**"],[-1,16656,"析构"],[-1,16700,"对象"],[1,16709,"对\n"],[1,16860,"\n"],[-1,16860,"*"],[1,16864,"*"],[-1,16873,"\n"],[1,16876,"\n"],[-1,16885,"\n"],[1,16890,"\n"],[-1,16900,"\n"],[1,16903,"\n"],[-1,16941,"\n"],[1,16946,"\n"],[-1,16956,"\n"],[1,16959,"\n"],[1,17005,"`"],[-1,17005,"\n\n"],[1,17017,"3"],[1,17026,"*"],[-1,17026,"究\n"],[1,17031,"\n"],[1,17069,"拷"],[-1,17069,"认"],[1,17075,"；"],[-1,17076,"；\n"],[1,17080,"\n"],[1,17112,"；"],[-1,17113,"；\n"],[1,17117,"\n"],[1,17177,"；数"],[-1,17177,"数；\n"],[1,17182,"\n"],[1,17200,"；"],[-1,17201,"；"],[-1,17225,"\n"],[1,17228,"\n"],[-1,17241,"\n"],[1,17246,"\n"],[-1,17271,"\n"],[1,17276,"\n"],[-1,17293,"\n"],[1,17298,"\n"],[-1,17318,"\n"],[1,17323,"\n"],[-1,17344,"\n"],[1,17349,"\n"],[-1,17400,"\n"],[1,17408,"*"],[1,17414,"*"],[-1,17414,"贝\n"],[1,17418," "],[-1,17444,"\n"],[1,17446," "],[1,17483,"*"],[-1,17483,"1"],[1,17515,"*"],[-1,17515,"2"],[1,17520,"*C+*"],[-1,17520,"序C++"],[-1,17575,"\n"],[1,17582,"\n"],[-1,18510,"\n"],[1,18559,"\n"],[-1,18559,""]],[18562,18562],[12361,12361]]],[1542977056181,["gjx16@GJXAIOU",[[1,17114,"需要自己加上"]],[17114,17114],[17120,17120]]],[1542977065857,["gjx16@GJXAIOU",[[1,17185,"需要自己肩上"]],[17185,17185],[17191,17191]]],[1542977068019,["gjx16@GJXAIOU",[[-1,17187,"自己肩上"]],[17191,17191],[17187,17187]]],[1542977129020,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13654,"\n"],[1,13658,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[1,16634,");"],[-1,16636,"****用匿名******"],[1,16649,"//用匿名对象赋值给B"],[-1,16658,"**"],[1,16660,"析构"],[1,16702,"对象"],[-1,16709,"对\n"],[-1,16862,"\n"],[1,16863,"*"],[-1,16866,"*"],[1,16876,"\n"],[-1,16878,"\n"],[1,16888,"\n"],[-1,16892,"\n"],[1,16903,"\n"],[-1,16905,"\n"],[1,16943,"\n"],[-1,16948,"\n"],[1,16959,"\n"],[-1,16961,"\n"],[-1,17008,"`"],[1,17009,"\n\n"],[-1,17019,"3"],[-1,17029,"*"],[1,17030,"究\n"],[-1,17033,"\n"],[-1,17072,"拷"],[1,17073,"认"],[-1,17078,"；数"],[1,17080,"数；\n"],[-1,17082,"\n"],[1,17114,"函数；"],[-1,17120,"函；数"],[1,17123,"\n"],[-1,17125,"\n"],[1,17185,"函数；"],[-1,17187,"函；数"],[1,17190,"\n"],[-1,17192,"\n"],[-1,17211,"；"],[1,17213,"；"],[1,17235,"\n"],[-1,17238,"\n"],[1,17252,"\n"],[-1,17256,"\n"],[1,17282,"\n"],[-1,17286,"\n"],[1,17304,"\n"],[-1,17308,"\n"],[1,17329,"\n"],[-1,17333,"\n"],[1,17355,"\n"],[-1,17359,"\n"],[1,17411,"\n"],[-1,17418,"*"],[-1,17425,"*"],[1,17426,"贝\n"],[-1,17428," "],[1,17455,"\n"],[-1,17457," "],[-1,17494,"*"],[1,17495,"1"],[-1,17526,"*"],[1,17527,"2"],[-1,17531,"*C+*"],[1,17535,"序C++"],[1,17586,"\n"],[-1,17592,"\n"],[1,18521,"\n"],[-1,18569,"\n"],[1,18570,""]],[12361,12361],[18570,18570]]],[1542977129020,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13652,"\n"],[-1,13655,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[-1,16632,");"],[1,16636,"****用匿名******"],[-1,16636,"//用匿名对象赋值给B"],[1,16656,"**"],[-1,16656,"析构"],[-1,16700,"对象"],[1,16709,"对\n"],[1,16860,"\n"],[-1,16860,"*"],[1,16864,"*"],[-1,16873,"\n"],[1,16876,"\n"],[-1,16885,"\n"],[1,16890,"\n"],[-1,16900,"\n"],[1,16903,"\n"],[-1,16940,"\n"],[1,16946,"\n"],[-1,16956,"\n"],[1,16959,"\n"],[1,17005,"`"],[-1,17005,"\n\n"],[1,17017,"3"],[1,17026,"*"],[-1,17026,"究\n"],[1,17031,"\n"],[1,17069,"拷"],[-1,17069,"认"],[1,17075,"；数"],[-1,17075,"数；\n"],[1,17080,"\n"],[-1,17111,"函数；"],[1,17120,"函；数"],[-1,17120,"\n"],[1,17123,"\n"],[-1,17182,"函数；"],[1,17187,"函；数"],[-1,17187,"\n"],[1,17190,"\n"],[1,17208,"；"],[-1,17209,"；"],[-1,17232,"\n"],[1,17236,"\n"],[-1,17249,"\n"],[1,17254,"\n"],[-1,17279,"\n"],[1,17284,"\n"],[-1,17301,"\n"],[1,17306,"\n"],[-1,17326,"\n"],[1,17331,"\n"],[-1,17352,"\n"],[1,17357,"\n"],[-1,17408,"\n"],[1,17416,"*"],[1,17422,"*"],[-1,17422,"贝\n"],[1,17426," "],[-1,17452,"\n"],[1,17455," "],[1,17491,"*"],[-1,17491,"1"],[1,17523,"*"],[-1,17523,"2"],[1,17528,"*C+*"],[-1,17528,"序C++"],[-1,17583,"\n"],[1,17590,"\n"],[-1,18518,"\n"],[1,18567,"\n"],[-1,18567,""]],[18570,18570],[12361,12361]]],[1542977073768,["gjx16@GJXAIOU",[[1,17189,"加上 "]],[17189,17189],[17192,17192]]],[1542980910037,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13654,"\n"],[1,13658,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[1,16634,");"],[-1,16636,"****用匿名******"],[1,16649,"//用匿名对象赋值给B"],[-1,16658,"**"],[1,16660,"析构"],[1,16702,"对象"],[-1,16709,"对\n"],[-1,16862,"\n"],[1,16863,"*"],[-1,16866,"*"],[1,16876,"\n"],[-1,16878,"\n"],[1,16888,"\n"],[-1,16892,"\n"],[1,16903,"\n"],[-1,16905,"\n"],[1,16943,"\n"],[-1,16948,"\n"],[1,16959,"\n"],[-1,16961,"\n"],[-1,17008,"`"],[1,17009,"\n\n"],[-1,17019,"3"],[-1,17029,"*"],[1,17030,"究\n"],[-1,17033,"\n"],[-1,17072,"拷"],[1,17073,"认"],[-1,17078,"；"],[1,17080,"；\n"],[-1,17082,"\n"],[1,17114,"函数；"],[-1,17120,"函；数"],[1,17123,"\n"],[-1,17125,"\n"],[1,17185,"函数；"],[-1,17187,"函；加上 数"],[1,17193,"自己加上 \n"],[-1,17195,"\n"],[1,17214,"值"],[-1,17215,"值"],[1,17238,"\n"],[-1,17241,"\n"],[1,17255,"\n"],[-1,17259,"\n"],[1,17285,"\n"],[-1,17289,"\n"],[1,17307,"\n"],[-1,17311,"\n"],[1,17332,"\n"],[-1,17336,"\n"],[1,17358,"\n"],[-1,17362,"\n"],[1,17414,"\n"],[-1,17421,"*"],[-1,17428,"*"],[1,17429,"贝\n"],[-1,17431," "],[1,17458,"\n"],[-1,17460," "],[-1,17497,"*"],[1,17498,"1"],[-1,17529,"*"],[1,17530,"2"],[-1,17534,"*C+*"],[1,17538,"序C++"],[1,17589,"\n"],[-1,17595,"\n"],[1,18524,"\n"],[-1,18572,"\n"],[1,18573,""]],[12361,12361],[18573,18573]]],[1542980910037,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13652,"\n"],[-1,13655,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[-1,16632,");"],[1,16636,"****用匿名******"],[-1,16636,"//用匿名对象赋值给B"],[1,16656,"**"],[-1,16656,"析构"],[-1,16700,"对象"],[1,16709,"对\n"],[1,16860,"\n"],[-1,16860,"*"],[1,16864,"*"],[-1,16873,"\n"],[1,16876,"\n"],[-1,16885,"\n"],[1,16890,"\n"],[-1,16900,"\n"],[1,16903,"\n"],[-1,16940,"\n"],[1,16946,"\n"],[-1,16956,"\n"],[1,16959,"\n"],[1,17005,"`"],[-1,17005,"\n\n"],[1,17017,"3"],[1,17026,"*"],[-1,17026,"究\n"],[1,17031,"\n"],[1,17069,"拷"],[-1,17069,"认"],[1,17075,"；"],[-1,17076,"；\n"],[1,17080,"\n"],[-1,17111,"函数；"],[1,17120,"函；数"],[-1,17120,"\n"],[1,17123,"\n"],[-1,17182,"函数；"],[1,17187,"函；加上 数"],[-1,17187,"自己加上 \n"],[1,17195,"\n"],[-1,17213,"值"],[1,17215,"值"],[-1,17237,"\n"],[1,17241,"\n"],[-1,17254,"\n"],[1,17259,"\n"],[-1,17284,"\n"],[1,17289,"\n"],[-1,17306,"\n"],[1,17311,"\n"],[-1,17331,"\n"],[1,17336,"\n"],[-1,17357,"\n"],[1,17362,"\n"],[-1,17413,"\n"],[1,17421,"*"],[1,17427,"*"],[-1,17427,"贝\n"],[1,17431," "],[-1,17457,"\n"],[1,17460," "],[1,17496,"*"],[-1,17496,"1"],[1,17528,"*"],[-1,17528,"2"],[1,17533,"*C+*"],[-1,17533,"序C++"],[-1,17588,"\n"],[1,17595,"\n"],[-1,18523,"\n"],[1,18572,"\n"],[-1,18572,""]],[18573,18573],[12361,12361]]],[1542980906290,["gjx16@GJXAIOU",[[1,17526,"\n"]],[17525,17525],[17526,17526]]],[1542980906773,["gjx16@GJXAIOU",[[1,17526,"、"]],[17526,17526],[17527,17527]]],[1542980907033,["gjx16@GJXAIOU",[[1,17528,"\n"]],[17527,17527],[17528,17528]]],[1542980970042,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13654,"\n"],[1,13658,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[1,16634,");"],[-1,16636,"****用匿名******"],[1,16649,"//用匿名对象赋值给B"],[-1,16658,"**"],[1,16660,"析构"],[1,16702,"对象"],[-1,16709,"对\n"],[-1,16862,"\n"],[1,16863,"*"],[-1,16866,"*"],[1,16876,"\n"],[-1,16878,"\n"],[1,16888,"\n"],[-1,16892,"\n"],[1,16903,"\n"],[-1,16905,"\n"],[1,16944,"\n"],[-1,16948,"\n"],[1,16959,"\n"],[-1,16961,"\n"],[-1,17008,"`"],[1,17009,"\n\n"],[-1,17019,"3"],[-1,17029,"*"],[1,17030,"究\n"],[-1,17033,"\n"],[-1,17072,"拷"],[1,17073,"认"],[-1,17078,"；"],[1,17080,"；\n"],[-1,17082,"\n"],[1,17114,"函数；"],[-1,17120,"函；数"],[1,17123,"\n"],[-1,17125,"\n"],[1,17185,"函数；"],[-1,17187,"函；加上 数"],[1,17193,"自己加上 \n"],[-1,17195,"\n"],[-1,17214,"；"],[1,17216,"；"],[1,17238,"\n"],[-1,17241,"\n"],[1,17255,"\n"],[-1,17259,"\n"],[1,17285,"\n"],[-1,17289,"\n"],[1,17307,"\n"],[-1,17311,"\n"],[1,17332,"\n"],[-1,17336,"\n"],[1,17358,"\n"],[-1,17362,"\n"],[1,17414,"\n"],[-1,17421,"*"],[-1,17428,"*"],[1,17429,"贝\n"],[-1,17431," "],[1,17458,"\n"],[-1,17459," "],[-1,17497,"*"],[1,17498,"1"],[1,17526,"\n"],[-1,17529,"\n*"],[1,17533,"2"],[-1,17537,"*C+*"],[1,17541,"序C++"],[1,17592,"\n"],[-1,17598,"\n"],[1,18527,"\n"],[-1,18575,"\n"],[1,18576,""]],[12361,12361],[18576,18576]]],[1542980970042,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13652,"\n"],[-1,13655,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[-1,16632,");"],[1,16636,"****用匿名******"],[-1,16636,"//用匿名对象赋值给B"],[1,16656,"**"],[-1,16656,"析构"],[-1,16700,"对象"],[1,16709,"对\n"],[1,16860,"\n"],[-1,16860,"*"],[1,16864,"*"],[-1,16873,"\n"],[1,16876,"\n"],[-1,16885,"\n"],[1,16890,"\n"],[-1,16900,"\n"],[1,16903,"\n"],[-1,16941,"\n"],[1,16946,"\n"],[-1,16956,"\n"],[1,16959,"\n"],[1,17005,"`"],[-1,17005,"\n\n"],[1,17017,"3"],[1,17026,"*"],[-1,17026,"究\n"],[1,17031,"\n"],[1,17069,"拷"],[-1,17069,"认"],[1,17075,"；"],[-1,17076,"；\n"],[1,17080,"\n"],[-1,17111,"函数；"],[1,17120,"函；数"],[-1,17120,"\n"],[1,17123,"\n"],[-1,17182,"函数；"],[1,17187,"函；加上 数"],[-1,17187,"自己加上 \n"],[1,17195,"\n"],[1,17213,"；"],[-1,17214,"；"],[-1,17237,"\n"],[1,17241,"\n"],[-1,17254,"\n"],[1,17259,"\n"],[-1,17284,"\n"],[1,17289,"\n"],[-1,17306,"\n"],[1,17311,"\n"],[-1,17331,"\n"],[1,17336,"\n"],[-1,17357,"\n"],[1,17362,"\n"],[-1,17413,"\n"],[1,17421,"*"],[1,17427,"*"],[-1,17427,"贝\n"],[1,17431," "],[-1,17457,"\n"],[1,17459," "],[1,17496,"*"],[-1,17496,"1"],[-1,17525,"\n"],[1,17529,"\n*"],[-1,17531,"2"],[1,17536,"*C+*"],[-1,17536,"序C++"],[-1,17591,"\n"],[1,17598,"\n"],[-1,18526,"\n"],[1,18575,"\n"],[-1,18575,""]],[18576,18576],[12361,12361]]],[1542980910099,["gjx16@GJXAIOU",[[-1,17526,"、"]],[17526,17527],[17526,17526]]],[1542980962348,["gjx16@GJXAIOU",[[1,17599,"/*\n\nC++默认浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n"],[-1,17611,"\n"],[-1,17613,"\n"],[-1,17624," "],[1,17625,"\t"],[-1,17649,"\n {\n\n "],[1,17655,"\t{\n\t\t"],[-1,17678," "],[1,17679,"\t\t"],[-1,17714," "],[1,17715,"\t\t"],[-1,17737,"\n }\n\n "],[1,17743,"\t}\n\n\t"],[-1,17759,"\n {\n\n "],[1,17765,"\t{\n\t\t"],[-1,17779," "],[1,17780,"\t\t"],[-1,17819," "],[1,17820,"\t\t"],[-1,17847," "],[1,17848,"\t\t"],[-1,17865,"\n }\n\n "],[1,17871,"\t}\n\n\t//析构函数\n\t"],[-1,17879,"\n {\n\n "],[1,17885,"\t{\n\n\t\t"],[1,17889," "],[1,17891," "],[1,17897," "],[1,17899," "],[-1,17906," "],[1,17907,"\t\t"],[1,17916," "],[1,17918," "],[-1,17925," {\n\n "],[1,17930,"\t\t{\n\n\t\t\t"],[-1,17944," "],[1,17945,"\t\t\t"],[-1,17960," "],[1,17961,"\t\t\t"],[-1,17972," }\n\n }\n\n "],[1,17981,"\t\t}\n\n\t}\n\n\t"],[-1,18009," {\n\n "],[1,18014,"\t{\n\n\t\t"],[-1,18034," {\n\n "],[1,18039,"\t\t{\n\n\t\t\t"],[-1,18053," "],[1,18054,"\t\t\t"],[-1,18069," "],[1,18070,"\t\t\t"],[-1,18081," }\n\n "],[1,18086,"\t\t}\n\n\t\t"],[1,18090," "],[1,18092," "],[1,18106," "],[1,18108," "],[-1,18115," "],[1,18116,"\t\t"],[-1,18129," "],[1,18130,"\t\t"],[-1,18170," "],[1,18171,"\t\t"],[-1,18199," "],[1,18200,"\t\t"],[-1,18219," "],[1,18220,"\t"],[-1,18245," "],[1,18246,"\t"],[-1,18260," "],[1,18261,"\t"],[-1,18320,"\n"],[-1,18324," "],[1,18325,"\t"],[-1,18350," "],[1,18351,"\t"],[-1,18382,"\n "],[1,18384,"\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\t"],[-1,18407," "],[1,18408,"\t"],[-1,18419," "],[1,18420,"\t"],[-1,18441," "],[1,18442,"\t"],[1,18446," "],[1,18448," "],[1,18461," "],[1,18463," "],[-1,18468,"\n"],[-1,18482,"61"],[-1,18486,"\n"],[-1,18490,"\n "],[1,18492,"\t"],[-1,18504," "],[1,18505,"\t"],[-1,18521,"\n"]],[17598,18524],[18683,18683]]],[1542980968818,["gjx16@GJXAIOU",[[1,17525,"···"]],[17525,17525],[17528,17528]]],[1542980969451,["gjx16@GJXAIOU",[[-1,17527,"·"]],[17528,17528],[17527,17527]]],[1542981030053,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13656,"\n"],[1,13657,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[1,16634,");"],[-1,16636,"****用匿名******"],[1,16649,"//用匿名对象赋值给B"],[-1,16658,"**"],[1,16660,"析构"],[1,16702,"对象"],[-1,16709,"对\n"],[-1,16862,"\n"],[1,16863,"*"],[-1,16866,"*"],[1,16876,"\n"],[-1,16878,"\n"],[1,16888,"\n"],[-1,16892,"\n"],[1,16903,"\n"],[-1,16905,"\n"],[1,16943,"\n"],[-1,16948,"\n"],[1,16959,"\n"],[-1,16961,"\n"],[-1,17008,"`"],[1,17009,"\n\n"],[-1,17019,"3"],[-1,17029,"*"],[1,17030,"究\n"],[-1,17033,"\n"],[-1,17072,"拷"],[1,17073,"认"],[-1,17078,"；"],[1,17080,"；\n"],[-1,17082,"\n"],[1,17114,"函数；"],[-1,17120,"函；数"],[1,17123,"\n"],[-1,17125,"\n"],[1,17185,"函数；"],[-1,17187,"函；加上 数"],[1,17193,"自己加上 \n"],[-1,17195,"\n"],[-1,17214,"；"],[1,17216,"；"],[1,17239,"\n"],[-1,17241,"\n"],[1,17255,"\n"],[-1,17259,"\n"],[1,17285,"\n"],[-1,17289,"\n"],[1,17307,"\n"],[-1,17311,"\n"],[1,17332,"\n"],[-1,17336,"\n"],[1,17358,"\n"],[-1,17362,"\n"],[1,17414,"\n"],[-1,17421,"*"],[-1,17428,"*"],[1,17429,"贝\n"],[-1,17431," "],[1,17458,"\n"],[-1,17459," "],[-1,17497,"*"],[1,17498,"1"],[1,17525,"\n"],[-1,17527,"\n"],[-1,17533,"*"],[1,17534,"2"],[-1,17538,"*C+*"],[1,17542,"序C++"],[1,17593,"\n"],[-1,17698,"\n"],[-1,17710,"\n"],[1,17711,"{"],[1,17719,"\n"],[-1,17721," "],[1,17745,"\n"],[-1,17750," "],[1,17773,"\n"],[-1,17775," "],[1,17810,"\n"],[-1,17812," "],[1,17834,"\n"],[-1,17839," "],[1,17855,"\n"],[-1,17860," "],[1,17874,"\n"],[-1,17876," "],[1,17914,"\n"],[-1,17917," "],[1,17944,"\n"],[-1,17946," "],[1,17963,"\n"],[-1,17976," "],[1,17984,"\n"],[-1,17990," "],[-1,17994," "],[1,17996," "],[-1,17997," "],[1,17999," "],[-1,18004," \""],[1,18006,"\" <"],[-1,18008,"<"],[1,18015,"\n"],[-1,18017," "],[-1,18026," "],[-1,18028,"!"],[1,18030,"!"],[1,18031," "],[1,18037,"\n"],[-1,18045," "],[1,18058,"\n"],[-1,18062," "],[1,18077,"\n"],[-1,18080," "],[1,18090,"\n"],[-1,18101," "],[1,18129,"\n"],[-1,18135," "],[1,18155,"\n"],[-1,18163," "],[1,18177,"\n"],[-1,18180," "],[1,18195,"\n"],[-1,18198," "],[1,18208,"\n"],[-1,18216," "],[-1,18220," t"],[1,18222,"t <"],[-1,18224,"<"],[-1,18238," "],[-1,18240,"<"],[1,18243,"< "],[1,18248,"\n"],[-1,18251," "],[1,18264,"\n"],[-1,18266," "],[1,18305,"\n"],[-1,18308," "],[1,18336,"\n"],[-1,18338," "],[1,18356,"\n"],[-1,18358," "],[1,18383,"\n"],[-1,18384," "],[1,18398,"\n"],[-1,18399," "],[1,18461,"\n"],[-1,18462," "],[1,18487,"\n"],[-1,18488," "],[1,18519,"\n"],[-1,18547," "],[1,18570,"\n"],[-1,18571," "],[1,18581,"\n"],[-1,18583," "],[1,18604,"\n"],[-1,18605," "],[-1,18609," "],[-1,18611,"<"],[1,18614,"< "],[-1,18626," \""],[1,18628,"\" <"],[-1,18630,"<"],[-1,18635,"\n"],[1,18636,";"],[-1,18648,"1(\n\n{\t "],[1,18655,"n()\n{\n\t"],[1,18665,"\n"],[-1,18667," "],[-1,18683,"\n"],[1,18684,";"],[1,18687,"\n"],[-1,18735,"\n"],[1,18736,""]],[12361,12361],[18736,18736]]],[1542981030053,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13654,"\n"],[-1,13654,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[-1,16632,");"],[1,16636,"****用匿名******"],[-1,16636,"//用匿名对象赋值给B"],[1,16656,"**"],[-1,16656,"析构"],[-1,16700,"对象"],[1,16709,"对\n"],[1,16860,"\n"],[-1,16860,"*"],[1,16864,"*"],[-1,16873,"\n"],[1,16876,"\n"],[-1,16885,"\n"],[1,16890,"\n"],[-1,16900,"\n"],[1,16903,"\n"],[-1,16940,"\n"],[1,16946,"\n"],[-1,16956,"\n"],[1,16959,"\n"],[1,17005,"`"],[-1,17005,"\n\n"],[1,17017,"3"],[1,17026,"*"],[-1,17026,"究\n"],[1,17031,"\n"],[1,17069,"拷"],[-1,17069,"认"],[1,17075,"；"],[-1,17076,"；\n"],[1,17080,"\n"],[-1,17111,"函数；"],[1,17120,"函；数"],[-1,17120,"\n"],[1,17123,"\n"],[-1,17182,"函数；"],[1,17187,"函；加上 数"],[-1,17187,"自己加上 \n"],[1,17195,"\n"],[1,17213,"；"],[-1,17214,"；"],[-1,17238,"\n"],[1,17241,"\n"],[-1,17254,"\n"],[1,17259,"\n"],[-1,17284,"\n"],[1,17289,"\n"],[-1,17306,"\n"],[1,17311,"\n"],[-1,17331,"\n"],[1,17336,"\n"],[-1,17357,"\n"],[1,17362,"\n"],[-1,17413,"\n"],[1,17421,"*"],[1,17427,"*"],[-1,17427,"贝\n"],[1,17431," "],[-1,17457,"\n"],[1,17459," "],[1,17496,"*"],[-1,17496,"1"],[-1,17524,"\n"],[1,17527,"\n"],[1,17532,"*"],[-1,17532,"2"],[1,17537,"*C+*"],[-1,17537,"序C++"],[-1,17592,"\n"],[1,17698,"\n"],[1,17709,"\n"],[-1,17709,"{"],[-1,17718,"\n"],[1,17721," "],[-1,17744,"\n"],[1,17750," "],[-1,17772,"\n"],[1,17775," "],[-1,17809,"\n"],[1,17812," "],[-1,17833,"\n"],[1,17839," "],[-1,17854,"\n"],[1,17860," "],[-1,17873,"\n"],[1,17876," "],[-1,17913,"\n"],[1,17917," "],[-1,17943,"\n"],[1,17946," "],[-1,17962,"\n"],[1,17976," "],[-1,17983,"\n"],[1,17990," "],[1,17993," "],[-1,17994," "],[1,17996," "],[-1,17997," "],[1,18003," \""],[-1,18003,"\" <"],[1,18008,"<"],[-1,18014,"\n"],[1,18017," "],[1,18025," "],[1,18026,"!"],[-1,18027,"!"],[-1,18029," "],[-1,18036,"\n"],[1,18045," "],[-1,18057,"\n"],[1,18062," "],[-1,18076,"\n"],[1,18080," "],[-1,18089,"\n"],[1,18101," "],[-1,18128,"\n"],[1,18135," "],[-1,18154,"\n"],[1,18163," "],[-1,18176,"\n"],[1,18180," "],[-1,18194,"\n"],[1,18198," "],[-1,18207,"\n"],[1,18216," "],[1,18219," t"],[-1,18219,"t <"],[1,18224,"<"],[1,18237," "],[1,18238,"<"],[-1,18240,"< "],[-1,18247,"\n"],[1,18251," "],[-1,18263,"\n"],[1,18266," "],[-1,18304,"\n"],[1,18308," "],[-1,18335,"\n"],[1,18338," "],[-1,18355,"\n"],[1,18358," "],[-1,18382,"\n"],[1,18384," "],[-1,18397,"\n"],[1,18399," "],[-1,18460,"\n"],[1,18462," "],[-1,18486,"\n"],[1,18488," "],[-1,18518,"\n"],[1,18547," "],[-1,18569,"\n"],[1,18571," "],[-1,18580,"\n"],[1,18583," "],[-1,18603,"\n"],[1,18605," "],[1,18608," "],[1,18609,"<"],[-1,18611,"< "],[1,18625," \""],[-1,18625,"\" <"],[1,18630,"<"],[1,18634,"\n"],[-1,18634,";"],[1,18647,"1(\n\n{\t "],[-1,18647,"n()\n{\n\t"],[-1,18664,"\n"],[1,18667," "],[1,18682,"\n"],[-1,18682,";"],[-1,18686,"\n"],[1,18735,"\n"],[-1,18735,""]],[18736,18736],[12361,12361]]],[1542980971209,["gjx16@GJXAIOU",[[-1,17525,"··"]],[17527,17527],[17525,17525]]],[1542980975336,["gjx16@GJXAIOU",[[1,17525,"```cpp"]],[17525,17525],[17531,17531]]],[1542980976664,["gjx16@GJXAIOU",[[1,17534,"\n"]],[17531,17531],[17532,17532]]],[1542980977068,["gjx16@GJXAIOU",[[1,17535,"\n"]],[17532,17532],[17533,17533]]],[1542980978705,["gjx16@GJXAIOU",[[1,17533,"```"]],[17533,17533],[17536,17536]]],[1542980980745,["gjx16@GJXAIOU",[[1,17533,"/*\n\nC++默认浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n"]],[17532,17532],[18617,18617]]],[1542980988960,["gjx16@GJXAIOU",[[-1,17537,"C++默认浅拷贝的解决方法 "]],[17545,17551],[17537,17537]]],[1542980989810,["gjx16@GJXAIOU",[[-1,17537,"\n"]],[17537,17537],[17536,17536]]],[1542980992500,["gjx16@GJXAIOU",[[1,17536,"ruguo"]],[17536,17536],[17541,17541]]],[1542980995085,["gjx16@GJXAIOU",[[-1,17536,"ruguo"]],[17541,17541],[17536,17536]]],[1542981005401,["gjx16@GJXAIOU",[[1,17536,"如果未定义copy函数，则"]],[17536,17536],[17549,17549]]],[1542981006497,["gjx16@GJXAIOU",[[-1,17548,"则"]],[17549,17549],[17548,17548]]],[1542981025955,["gjx16@GJXAIOU",[[1,17548,"使用C++默认的copy哈数"]],[17548,17548],[17562,17562]]],[1542981026934,["gjx16@GJXAIOU",[[-1,17560,"哈数"]],[17562,17562],[17560,17560]]],[1542981090050,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13656,"\n"],[1,13657,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[1,16634,");"],[-1,16636,"****用匿名******"],[1,16649,"//用匿名对象赋值给B"],[-1,16658,"**"],[1,16660,"析构"],[1,16702,"对象"],[-1,16709,"对\n"],[-1,16862,"\n"],[1,16863,"*"],[-1,16866,"*"],[1,16876,"\n"],[-1,16878,"\n"],[1,16888,"\n"],[-1,16892,"\n"],[1,16903,"\n"],[-1,16905,"\n"],[1,16944,"\n"],[-1,16948,"\n"],[1,16959,"\n"],[-1,16961,"\n"],[-1,17008,"`"],[1,17009,"\n\n"],[-1,17019,"3"],[-1,17029,"*"],[1,17030,"究\n"],[-1,17033,"\n"],[-1,17072,"拷"],[1,17073,"认"],[-1,17078,"；"],[1,17080,"；\n"],[-1,17082,"\n"],[1,17114,"函数；"],[-1,17120,"函；数"],[1,17123,"\n"],[-1,17125,"\n"],[1,17185,"函数；"],[-1,17187,"函；加上 数"],[1,17193,"自己加上 \n"],[-1,17195,"\n"],[-1,17214,"；"],[1,17216,"；"],[1,17239,"\n"],[-1,17241,"\n"],[1,17255,"\n"],[-1,17259,"\n"],[1,17285,"\n"],[-1,17289,"\n"],[1,17307,"\n"],[-1,17311,"\n"],[1,17332,"\n"],[-1,17336,"\n"],[1,17358,"\n"],[-1,17362,"\n"],[1,17414,"\n"],[-1,17421,"*"],[-1,17428,"*"],[1,17429,"贝\n"],[-1,17431," "],[1,17458,"\n"],[-1,17460," "],[-1,17497,"*"],[1,17498,"1"],[1,17525,"\n"],[-1,18633,"\n*"],[1,18637,"2"],[-1,18641,"*C+*"],[1,18645,"序C++"],[1,18696,"\n"],[-1,18801,"\n"],[-1,18813,"\n"],[1,18814,"{"],[1,18823,"\n"],[-1,18824," "],[1,18848,"\n"],[-1,18853," "],[1,18875,"\n"],[-1,18878," "],[1,18913,"\n"],[-1,18915," "],[1,18937,"\n"],[-1,18942," "],[1,18958,"\n"],[-1,18963," "],[1,18977,"\n"],[-1,18979," "],[1,19018,"\n"],[-1,19020," "],[1,19047,"\n"],[-1,19049," "],[1,19066,"\n"],[-1,19079," "],[1,19087,"\n"],[-1,19093," "],[-1,19097," t"],[1,19099,"t <"],[-1,19101,"<"],[-1,19107," "],[-1,19109,"<"],[1,19112,"< "],[1,19118,"\n"],[-1,19120," "],[-1,19129," "],[1,19131," "],[1,19132,"="],[-1,19133,"="],[1,19139,"\n"],[-1,19148," "],[1,19162,"\n"],[-1,19165," "],[1,19180,"\n"],[-1,19183," "],[1,19194,"\n"],[-1,19204," "],[1,19232,"\n"],[-1,19238," "],[1,19257,"\n"],[-1,19266," "],[1,19280,"\n"],[-1,19283," "],[1,19298,"\n"],[-1,19301," "],[1,19311,"\n"],[-1,19319," "],[-1,19323," t"],[1,19325,"t <"],[-1,19327,"<"],[-1,19341," "],[-1,19343,"<"],[1,19346,"< "],[1,19351,"\n"],[-1,19354," "],[1,19367,"\n"],[-1,19369," "],[1,19408,"\n"],[-1,19411," "],[1,19439,"\n"],[-1,19441," "],[1,19459,"\n"],[-1,19461," "],[1,19486,"\n"],[-1,19487," "],[1,19501,"\n"],[-1,19502," "],[1,19564,"\n"],[-1,19565," "],[1,19590,"\n"],[-1,19591," "],[1,19622,"\n"],[-1,19650," "],[1,19673,"\n"],[-1,19674," "],[1,19684,"\n"],[-1,19686," "],[1,19707,"\n"],[-1,19708," "],[-1,19712," "],[-1,19714,"<"],[1,19717,"< "],[-1,19729," \""],[1,19731,"\" <"],[-1,19733,"<"],[-1,19738,"\n"],[1,19739,";"],[-1,19751,"1(\n\n{\t "],[1,19758,"n()\n{\n\t"],[1,19768,"\n"],[-1,19770," "],[-1,19786,"\n"],[1,19787,";"],[1,19790,"\n"],[-1,19838,"\n"],[1,19839,""]],[12361,12361],[19839,19839]]],[1542981090050,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13654,"\n"],[-1,13654,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[-1,16632,");"],[1,16636,"****用匿名******"],[-1,16636,"//用匿名对象赋值给B"],[1,16656,"**"],[-1,16656,"析构"],[-1,16700,"对象"],[1,16709,"对\n"],[1,16860,"\n"],[-1,16860,"*"],[1,16864,"*"],[-1,16873,"\n"],[1,16876,"\n"],[-1,16885,"\n"],[1,16890,"\n"],[-1,16900,"\n"],[1,16903,"\n"],[-1,16941,"\n"],[1,16946,"\n"],[-1,16956,"\n"],[1,16959,"\n"],[1,17005,"`"],[-1,17005,"\n\n"],[1,17017,"3"],[1,17026,"*"],[-1,17026,"究\n"],[1,17031,"\n"],[1,17069,"拷"],[-1,17069,"认"],[1,17075,"；"],[-1,17076,"；\n"],[1,17080,"\n"],[-1,17111,"函数；"],[1,17120,"函；数"],[-1,17120,"\n"],[1,17123,"\n"],[-1,17182,"函数；"],[1,17187,"函；加上 数"],[-1,17187,"自己加上 \n"],[1,17195,"\n"],[1,17213,"；"],[-1,17214,"；"],[-1,17238,"\n"],[1,17241,"\n"],[-1,17254,"\n"],[1,17259,"\n"],[-1,17284,"\n"],[1,17289,"\n"],[-1,17306,"\n"],[1,17311,"\n"],[-1,17331,"\n"],[1,17336,"\n"],[-1,17357,"\n"],[1,17362,"\n"],[-1,17413,"\n"],[1,17421,"*"],[1,17427,"*"],[-1,17427,"贝\n"],[1,17431," "],[-1,17457,"\n"],[1,17460," "],[1,17496,"*"],[-1,17496,"1"],[-1,17524,"\n"],[1,18633,"\n*"],[-1,18635,"2"],[1,18640,"*C+*"],[-1,18640,"序C++"],[-1,18695,"\n"],[1,18801,"\n"],[1,18812,"\n"],[-1,18812,"{"],[-1,18822,"\n"],[1,18824," "],[-1,18847,"\n"],[1,18853," "],[-1,18874,"\n"],[1,18878," "],[-1,18912,"\n"],[1,18915," "],[-1,18936,"\n"],[1,18942," "],[-1,18957,"\n"],[1,18963," "],[-1,18976,"\n"],[1,18979," "],[-1,19017,"\n"],[1,19020," "],[-1,19046,"\n"],[1,19049," "],[-1,19065,"\n"],[1,19079," "],[-1,19086,"\n"],[1,19093," "],[1,19096," t"],[-1,19096,"t <"],[1,19101,"<"],[1,19106," "],[1,19107,"<"],[-1,19109,"< "],[-1,19117,"\n"],[1,19120," "],[1,19128," "],[-1,19129," "],[-1,19131,"="],[1,19133,"="],[-1,19138,"\n"],[1,19148," "],[-1,19161,"\n"],[1,19165," "],[-1,19179,"\n"],[1,19183," "],[-1,19193,"\n"],[1,19204," "],[-1,19231,"\n"],[1,19238," "],[-1,19256,"\n"],[1,19266," "],[-1,19279,"\n"],[1,19283," "],[-1,19297,"\n"],[1,19301," "],[-1,19310,"\n"],[1,19319," "],[1,19322," t"],[-1,19322,"t <"],[1,19327,"<"],[1,19340," "],[1,19341,"<"],[-1,19343,"< "],[-1,19350,"\n"],[1,19354," "],[-1,19366,"\n"],[1,19369," "],[-1,19407,"\n"],[1,19411," "],[-1,19438,"\n"],[1,19441," "],[-1,19458,"\n"],[1,19461," "],[-1,19485,"\n"],[1,19487," "],[-1,19500,"\n"],[1,19502," "],[-1,19563,"\n"],[1,19565," "],[-1,19589,"\n"],[1,19591," "],[-1,19621,"\n"],[1,19650," "],[-1,19672,"\n"],[1,19674," "],[-1,19683,"\n"],[1,19686," "],[-1,19706,"\n"],[1,19708," "],[1,19711," "],[1,19712,"<"],[-1,19714,"< "],[1,19728," \""],[-1,19728,"\" <"],[1,19733,"<"],[1,19737,"\n"],[-1,19737,";"],[1,19750,"1(\n\n{\t "],[-1,19750,"n()\n{\n\t"],[-1,19767,"\n"],[1,19770," "],[1,19785,"\n"],[-1,19785,";"],[-1,19789,"\n"],[1,19838,"\n"],[-1,19838,""]],[19839,19839],[12361,12361]]],[1542981044420,["gjx16@GJXAIOU",[[1,17560,"函数，实质上是一种浅拷贝"]],[17560,17560],[17572,17572]]],[1542981047665,["gjx16@GJXAIOU",[[-1,17577,"\n"]],[17577,17577],[17576,17576]]],[1542981049225,["gjx16@GJXAIOU",[[-1,17532,"\n"]],[17532,17532],[17531,17531]]],[1542981059697,["gjx16@GJXAIOU",[[-1,17789,"\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}"]],[17790,17916],[17789,17789]]],[1542981061160,["gjx16@GJXAIOU",[[-1,17790,"\n"]],[17789,17789],[17788,17788]]],[1542981062332,["gjx16@GJXAIOU",[[-1,17789,"\n"]],[17788,17788],[17787,17787]]],[1542981064236,["gjx16@GJXAIOU",[[-1,17809,"\n"]],[17809,17809],[17808,17808]]],[1542981066083,["gjx16@GJXAIOU",[[-1,17857,"\n"]],[17857,17857],[17856,17856]]],[1542981067268,["gjx16@GJXAIOU",[[-1,17861,"\n"]],[17861,17861],[17860,17860]]],[1542981068945,["gjx16@GJXAIOU",[[-1,17909,"\n"]],[17909,17909],[17908,17908]]],[1542981069977,["gjx16@GJXAIOU",[[-1,17877,"\n"]],[17877,17877],[17876,17876]]],[1542981071162,["gjx16@GJXAIOU",[[-1,17894,"\n"]],[17894,17894],[17893,17893]]],[1542981072566,["gjx16@GJXAIOU",[[-1,17911,"\n"]],[17911,17911],[17910,17910]]],[1542981075433,["gjx16@GJXAIOU",[[-1,17943,"\n"]],[17943,17943],[17942,17942]]],[1542981076395,["gjx16@GJXAIOU",[[-1,17946,"\n"]],[17946,17946],[17945,17945]]],[1542981077433,["gjx16@GJXAIOU",[[-1,17967,"\n"]],[17967,17967],[17966,17966]]],[1542981078331,["gjx16@GJXAIOU",[[-1,17971,"\n"]],[17971,17971],[17970,17970]]],[1542981079769,["gjx16@GJXAIOU",[[-1,18019,"\n"]],[18019,18019],[18018,18018]]],[1542981088405,["gjx16@GJXAIOU",[[1,18502,"\n"]],[18499,18499],[18500,18500]]],[1542981089385,["gjx16@GJXAIOU",[[1,18500,"、、"]],[18500,18500],[18502,18502]]],[1542981150054,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13656,"\n"],[1,13657,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[1,16634,");"],[-1,16636,"****用匿名******"],[1,16649,"//用匿名对象赋值给B"],[-1,16658,"**"],[1,16660,"析构"],[1,16702,"对象"],[-1,16709,"对\n"],[-1,16862,"\n"],[1,16863,"*"],[-1,16866,"*"],[1,16876,"\n"],[-1,16878,"\n"],[1,16888,"\n"],[-1,16892,"\n"],[1,16903,"\n"],[-1,16905,"\n"],[1,16944,"\n"],[-1,16948,"\n"],[1,16959,"\n"],[-1,16961,"\n"],[-1,17008,"`"],[1,17009,"\n\n"],[-1,17019,"3"],[-1,17029,"*"],[1,17030,"究\n"],[-1,17033,"\n"],[-1,17072,"拷"],[1,17073,"认"],[-1,17078,"；"],[1,17080,"；\n"],[-1,17082,"\n"],[1,17114,"函数；"],[-1,17120,"函；数"],[1,17123,"\n"],[-1,17125,"\n"],[1,17185,"函数；"],[-1,17187,"函；加上 数"],[1,17193,"自己加上 \n"],[-1,17195,"\n"],[-1,17214,"；"],[1,17216,"；"],[1,17239,"\n"],[-1,17241,"\n"],[1,17255,"\n"],[-1,17259,"\n"],[1,17285,"\n"],[-1,17289,"\n"],[1,17307,"\n"],[-1,17311,"\n"],[1,17332,"\n"],[-1,17336,"\n"],[1,17358,"\n"],[-1,17362,"\n"],[1,17414,"\n"],[-1,17421,"*"],[-1,17428,"*"],[1,17429,"贝\n"],[-1,17431," "],[1,17458,"\n"],[-1,17460," "],[-1,17497,"*"],[1,17498,"1"],[1,17525,"\n"],[-1,18505,"\n*"],[1,18509,"2"],[-1,18513,"*C+*"],[1,18517,"序C++"],[1,18568,"\n"],[-1,18673,"\n"],[-1,18685,"\n"],[1,18686,"{"],[1,18695,"\n"],[-1,18696," "],[1,18720,"\n"],[-1,18725," "],[1,18747,"\n"],[-1,18750," "],[1,18785,"\n"],[-1,18787," "],[1,18809,"\n"],[-1,18814," "],[1,18830,"\n"],[-1,18835," "],[1,18849,"\n"],[-1,18851," "],[1,18890,"\n"],[-1,18892," "],[1,18919,"\n"],[-1,18921," "],[1,18938,"\n"],[-1,18951," "],[1,18959,"\n"],[-1,18965," "],[-1,18969," t"],[1,18971,"t <"],[-1,18973,"<"],[-1,18979," "],[-1,18981,"<"],[1,18984,"< "],[1,18990,"\n"],[-1,18992," "],[-1,19001," "],[1,19003," "],[1,19004,"="],[-1,19005,"="],[1,19011,"\n"],[-1,19020," "],[1,19034,"\n"],[-1,19037," "],[1,19052,"\n"],[-1,19055," "],[1,19066,"\n"],[-1,19076," "],[1,19104,"\n"],[-1,19110," "],[1,19129,"\n"],[-1,19138," "],[1,19152,"\n"],[-1,19155," "],[1,19170,"\n"],[-1,19173," "],[1,19183,"\n"],[-1,19191," "],[-1,19195," t"],[1,19197,"t <"],[-1,19199,"<"],[-1,19213," "],[-1,19215,"<"],[1,19218,"< "],[1,19223,"\n"],[-1,19226," "],[1,19239,"\n"],[-1,19241," "],[1,19280,"\n"],[-1,19283," "],[1,19311,"\n"],[-1,19313," "],[1,19331,"\n"],[-1,19333," "],[1,19358,"\n"],[-1,19359," "],[1,19373,"\n"],[-1,19374," "],[1,19436,"\n"],[-1,19437," "],[1,19462,"\n"],[-1,19463," "],[1,19494,"\n"],[-1,19522," "],[1,19545,"\n"],[-1,19546," "],[1,19556,"\n"],[-1,19558," "],[1,19579,"\n"],[-1,19580," "],[-1,19584," "],[-1,19586,"<"],[1,19589,"< "],[-1,19601," \""],[1,19603,"\" <"],[-1,19605,"<"],[-1,19610,"\n"],[1,19611,";"],[-1,19623,"1(\n\n{\t "],[1,19630,"n()\n{\n\t"],[1,19640,"\n"],[-1,19642," "],[-1,19658,"\n"],[1,19659,";"],[1,19662,"\n"],[-1,19710,"\n"],[1,19711,""]],[12361,12361],[19711,19711]]],[1542981150055,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13654,"\n"],[-1,13654,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[-1,16632,");"],[1,16636,"****用匿名******"],[-1,16636,"//用匿名对象赋值给B"],[1,16656,"**"],[-1,16656,"析构"],[-1,16700,"对象"],[1,16709,"对\n"],[1,16860,"\n"],[-1,16860,"*"],[1,16864,"*"],[-1,16873,"\n"],[1,16876,"\n"],[-1,16885,"\n"],[1,16890,"\n"],[-1,16900,"\n"],[1,16903,"\n"],[-1,16941,"\n"],[1,16946,"\n"],[-1,16956,"\n"],[1,16959,"\n"],[1,17005,"`"],[-1,17005,"\n\n"],[1,17017,"3"],[1,17026,"*"],[-1,17026,"究\n"],[1,17031,"\n"],[1,17069,"拷"],[-1,17069,"认"],[1,17075,"；"],[-1,17076,"；\n"],[1,17080,"\n"],[-1,17111,"函数；"],[1,17120,"函；数"],[-1,17120,"\n"],[1,17123,"\n"],[-1,17182,"函数；"],[1,17187,"函；加上 数"],[-1,17187,"自己加上 \n"],[1,17195,"\n"],[1,17213,"；"],[-1,17214,"；"],[-1,17238,"\n"],[1,17241,"\n"],[-1,17254,"\n"],[1,17259,"\n"],[-1,17284,"\n"],[1,17289,"\n"],[-1,17306,"\n"],[1,17311,"\n"],[-1,17331,"\n"],[1,17336,"\n"],[-1,17357,"\n"],[1,17362,"\n"],[-1,17413,"\n"],[1,17421,"*"],[1,17427,"*"],[-1,17427,"贝\n"],[1,17431," "],[-1,17457,"\n"],[1,17460," "],[1,17496,"*"],[-1,17496,"1"],[-1,17524,"\n"],[1,18505,"\n*"],[-1,18507,"2"],[1,18512,"*C+*"],[-1,18512,"序C++"],[-1,18567,"\n"],[1,18673,"\n"],[1,18684,"\n"],[-1,18684,"{"],[-1,18694,"\n"],[1,18696," "],[-1,18719,"\n"],[1,18725," "],[-1,18746,"\n"],[1,18750," "],[-1,18784,"\n"],[1,18787," "],[-1,18808,"\n"],[1,18814," "],[-1,18829,"\n"],[1,18835," "],[-1,18848,"\n"],[1,18851," "],[-1,18889,"\n"],[1,18892," "],[-1,18918,"\n"],[1,18921," "],[-1,18937,"\n"],[1,18951," "],[-1,18958,"\n"],[1,18965," "],[1,18968," t"],[-1,18968,"t <"],[1,18973,"<"],[1,18978," "],[1,18979,"<"],[-1,18981,"< "],[-1,18989,"\n"],[1,18992," "],[1,19000," "],[-1,19001," "],[-1,19003,"="],[1,19005,"="],[-1,19010,"\n"],[1,19020," "],[-1,19033,"\n"],[1,19037," "],[-1,19051,"\n"],[1,19055," "],[-1,19065,"\n"],[1,19076," "],[-1,19103,"\n"],[1,19110," "],[-1,19128,"\n"],[1,19138," "],[-1,19151,"\n"],[1,19155," "],[-1,19169,"\n"],[1,19173," "],[-1,19182,"\n"],[1,19191," "],[1,19194," t"],[-1,19194,"t <"],[1,19199,"<"],[1,19212," "],[1,19213,"<"],[-1,19215,"< "],[-1,19222,"\n"],[1,19226," "],[-1,19238,"\n"],[1,19241," "],[-1,19279,"\n"],[1,19283," "],[-1,19310,"\n"],[1,19313," "],[-1,19330,"\n"],[1,19333," "],[-1,19357,"\n"],[1,19359," "],[-1,19372,"\n"],[1,19374," "],[-1,19435,"\n"],[1,19437," "],[-1,19461,"\n"],[1,19463," "],[-1,19493,"\n"],[1,19522," "],[-1,19544,"\n"],[1,19546," "],[-1,19555,"\n"],[1,19558," "],[-1,19578,"\n"],[1,19580," "],[1,19583," "],[1,19584,"<"],[-1,19586,"< "],[1,19600," \""],[-1,19600,"\" <"],[1,19605,"<"],[1,19609,"\n"],[-1,19609,";"],[1,19622,"1(\n\n{\t "],[-1,19622,"n()\n{\n\t"],[-1,19639,"\n"],[1,19642," "],[1,19657,"\n"],[-1,19657,";"],[-1,19661,"\n"],[1,19710,"\n"],[-1,19710,""]],[19711,19711],[12361,12361]]],[1542981091145,["gjx16@GJXAIOU",[[-1,18500,"、、"]],[18502,18502],[18500,18500]]],[1542981094778,["gjx16@GJXAIOU",[[1,18500,"//chegnxu"]],[18500,18500],[18509,18509]]],[1542981098020,["gjx16@GJXAIOU",[[-1,18502,"chegnxu"]],[18509,18509],[18502,18502]]],[1542981103254,["gjx16@GJXAIOU",[[1,18502,"程序在第二次"]],[18502,18502],[18508,18508]]],[1542981105526,["gjx16@GJXAIOU",[[-1,18505,"第二次"]],[18508,18508],[18505,18505]]],[1542981116846,["gjx16@GJXAIOU",[[1,18505,"运行的时候理会出错，因为没有"]],[18505,18505],[18519,18519]]],[1542981119284,["gjx16@GJXAIOU",[[-1,18517,"没有"]],[18519,18519],[18517,18517]]],[1542981142460,["gjx16@GJXAIOU",[[1,18517,"本质上是进行的浅拷贝，一开始释放b"]],[18517,18517],[18534,18534]]],[1542981143322,["gjx16@GJXAIOU",[[-1,18533,"b"]],[18534,18534],[18533,18533]]],[1542981146921,["gjx16@GJXAIOU",[[1,18533,"obf"]],[18533,18533],[18536,18536]]],[1542981147426,["gjx16@GJXAIOU",[[-1,18535,"f"]],[18536,18536],[18535,18535]]],[1542981149330,["gjx16@GJXAIOU",[[1,18535,"j2"]],[18535,18535],[18537,18537]]],[1542981210049,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13656,"\n"],[1,13657,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[1,16634,");"],[-1,16636,"****用匿名******"],[1,16649,"//用匿名对象赋值给B"],[-1,16658,"**"],[1,16660,"析构"],[1,16702,"对象"],[-1,16709,"对\n"],[-1,16862,"\n"],[1,16863,"*"],[-1,16866,"*"],[1,16876,"\n"],[-1,16878,"\n"],[1,16888,"\n"],[-1,16892,"\n"],[1,16903,"\n"],[-1,16905,"\n"],[1,16944,"\n"],[-1,16948,"\n"],[1,16959,"\n"],[-1,16961,"\n"],[-1,17008,"`"],[1,17009,"\n\n"],[-1,17019,"3"],[-1,17029,"*"],[1,17030,"究\n"],[-1,17033,"\n"],[-1,17072,"拷"],[1,17073,"认"],[-1,17078,"；"],[1,17080,"；\n"],[-1,17082,"\n"],[1,17114,"函数；"],[-1,17120,"函；数"],[1,17123,"\n"],[-1,17125,"\n"],[1,17185,"函数；"],[-1,17187,"函；加上 数"],[1,17193,"自己加上 \n"],[-1,17195,"\n"],[-1,17214,"；"],[1,17216,"；"],[1,17239,"\n"],[-1,17241,"\n"],[1,17255,"\n"],[-1,17259,"\n"],[1,17285,"\n"],[-1,17289,"\n"],[1,17307,"\n"],[-1,17311,"\n"],[1,17332,"\n"],[-1,17336,"\n"],[1,17358,"\n"],[-1,17362,"\n"],[1,17414,"\n"],[-1,17421,"*"],[-1,17428,"*"],[1,17429,"贝\n"],[-1,17431," "],[1,17458,"\n"],[-1,17460," "],[-1,17497,"*"],[1,17498,"1"],[1,17525,"\n"],[-1,18540,"\n*"],[1,18544,"2"],[-1,18548,"*C+*"],[1,18552,"序C++"],[1,18603,"\n"],[-1,18708,"\n"],[-1,18720,"\n"],[1,18721,"{"],[1,18730,"\n"],[-1,18731," "],[1,18755,"\n"],[-1,18760," "],[1,18782,"\n"],[-1,18785," "],[1,18820,"\n"],[-1,18822," "],[1,18844,"\n"],[-1,18849," "],[1,18865,"\n"],[-1,18870," "],[1,18884,"\n"],[-1,18886," "],[1,18925,"\n"],[-1,18927," "],[1,18954,"\n"],[-1,18956," "],[1,18973,"\n"],[-1,18986," "],[1,18994,"\n"],[-1,19000," "],[-1,19004," t"],[1,19006,"t <"],[-1,19008,"<"],[-1,19014," "],[-1,19016,"<"],[1,19019,"< "],[1,19025,"\n"],[-1,19027," "],[-1,19036," "],[1,19038," "],[1,19039,"="],[-1,19040,"="],[1,19046,"\n"],[-1,19055," "],[1,19069,"\n"],[-1,19072," "],[1,19087,"\n"],[-1,19090," "],[1,19101,"\n"],[-1,19111," "],[1,19139,"\n"],[-1,19145," "],[1,19164,"\n"],[-1,19173," "],[1,19187,"\n"],[-1,19190," "],[1,19205,"\n"],[-1,19208," "],[1,19218,"\n"],[-1,19226," "],[-1,19230," t"],[1,19232,"t <"],[-1,19234,"<"],[-1,19248," "],[-1,19250,"<"],[1,19253,"< "],[1,19258,"\n"],[-1,19261," "],[1,19274,"\n"],[-1,19276," "],[1,19315,"\n"],[-1,19318," "],[1,19346,"\n"],[-1,19348," "],[1,19366,"\n"],[-1,19368," "],[1,19393,"\n"],[-1,19394," "],[1,19408,"\n"],[-1,19409," "],[1,19471,"\n"],[-1,19472," "],[1,19497,"\n"],[-1,19498," "],[1,19529,"\n"],[-1,19557," "],[1,19580,"\n"],[-1,19581," "],[1,19591,"\n"],[-1,19593," "],[1,19614,"\n"],[-1,19615," "],[-1,19619," "],[-1,19621,"<"],[1,19624,"< "],[-1,19636," \""],[1,19638,"\" <"],[-1,19640,"<"],[-1,19645,"\n"],[1,19646,";"],[-1,19658,"1(\n\n{\t "],[1,19665,"n()\n{\n\t"],[1,19675,"\n"],[-1,19677," "],[-1,19693,"\n"],[1,19694,";"],[1,19697,"\n"],[-1,19745,"\n"],[1,19746,""]],[12361,12361],[19746,19746]]],[1542981210049,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13654,"\n"],[-1,13654,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[-1,16632,");"],[1,16636,"****用匿名******"],[-1,16636,"//用匿名对象赋值给B"],[1,16656,"**"],[-1,16656,"析构"],[-1,16700,"对象"],[1,16709,"对\n"],[1,16860,"\n"],[-1,16860,"*"],[1,16864,"*"],[-1,16873,"\n"],[1,16876,"\n"],[-1,16885,"\n"],[1,16890,"\n"],[-1,16900,"\n"],[1,16903,"\n"],[-1,16941,"\n"],[1,16946,"\n"],[-1,16956,"\n"],[1,16959,"\n"],[1,17005,"`"],[-1,17005,"\n\n"],[1,17017,"3"],[1,17026,"*"],[-1,17026,"究\n"],[1,17031,"\n"],[1,17069,"拷"],[-1,17069,"认"],[1,17075,"；"],[-1,17076,"；\n"],[1,17080,"\n"],[-1,17111,"函数；"],[1,17120,"函；数"],[-1,17120,"\n"],[1,17123,"\n"],[-1,17182,"函数；"],[1,17187,"函；加上 数"],[-1,17187,"自己加上 \n"],[1,17195,"\n"],[1,17213,"；"],[-1,17214,"；"],[-1,17238,"\n"],[1,17241,"\n"],[-1,17254,"\n"],[1,17259,"\n"],[-1,17284,"\n"],[1,17289,"\n"],[-1,17306,"\n"],[1,17311,"\n"],[-1,17331,"\n"],[1,17336,"\n"],[-1,17357,"\n"],[1,17362,"\n"],[-1,17413,"\n"],[1,17421,"*"],[1,17427,"*"],[-1,17427,"贝\n"],[1,17431," "],[-1,17457,"\n"],[1,17460," "],[1,17496,"*"],[-1,17496,"1"],[-1,17524,"\n"],[1,18540,"\n*"],[-1,18542,"2"],[1,18547,"*C+*"],[-1,18547,"序C++"],[-1,18602,"\n"],[1,18708,"\n"],[1,18719,"\n"],[-1,18719,"{"],[-1,18729,"\n"],[1,18731," "],[-1,18754,"\n"],[1,18760," "],[-1,18781,"\n"],[1,18785," "],[-1,18819,"\n"],[1,18822," "],[-1,18843,"\n"],[1,18849," "],[-1,18864,"\n"],[1,18870," "],[-1,18883,"\n"],[1,18886," "],[-1,18924,"\n"],[1,18927," "],[-1,18953,"\n"],[1,18956," "],[-1,18972,"\n"],[1,18986," "],[-1,18993,"\n"],[1,19000," "],[1,19003," t"],[-1,19003,"t <"],[1,19008,"<"],[1,19013," "],[1,19014,"<"],[-1,19016,"< "],[-1,19024,"\n"],[1,19027," "],[1,19035," "],[-1,19036," "],[-1,19038,"="],[1,19040,"="],[-1,19045,"\n"],[1,19055," "],[-1,19068,"\n"],[1,19072," "],[-1,19086,"\n"],[1,19090," "],[-1,19100,"\n"],[1,19111," "],[-1,19138,"\n"],[1,19145," "],[-1,19163,"\n"],[1,19173," "],[-1,19186,"\n"],[1,19190," "],[-1,19204,"\n"],[1,19208," "],[-1,19217,"\n"],[1,19226," "],[1,19229," t"],[-1,19229,"t <"],[1,19234,"<"],[1,19247," "],[1,19248,"<"],[-1,19250,"< "],[-1,19257,"\n"],[1,19261," "],[-1,19273,"\n"],[1,19276," "],[-1,19314,"\n"],[1,19318," "],[-1,19345,"\n"],[1,19348," "],[-1,19365,"\n"],[1,19368," "],[-1,19392,"\n"],[1,19394," "],[-1,19407,"\n"],[1,19409," "],[-1,19470,"\n"],[1,19472," "],[-1,19496,"\n"],[1,19498," "],[-1,19528,"\n"],[1,19557," "],[-1,19579,"\n"],[1,19581," "],[-1,19590,"\n"],[1,19593," "],[-1,19613,"\n"],[1,19615," "],[1,19618," "],[1,19619,"<"],[-1,19621,"< "],[1,19635," \""],[-1,19635,"\" <"],[1,19640,"<"],[1,19644,"\n"],[-1,19644,";"],[1,19657,"1(\n\n{\t "],[-1,19657,"n()\n{\n\t"],[-1,19674,"\n"],[1,19677," "],[1,19692,"\n"],[-1,19692,";"],[-1,19696,"\n"],[1,19745,"\n"],[-1,19745,""]],[19746,19746],[12361,12361]]],[1542981172109,["gjx16@GJXAIOU",[[1,18537,"时候是正常释放的，但是释放obj1de shihou"]],[18537,18537],[18563,18563]]],[1542981176874,["gjx16@GJXAIOU",[[-1,18554,"de shihou"]],[18563,18563],[18554,18554]]],[1542981183156,["gjx16@GJXAIOU",[[1,18554,"的时候家就会出错"]],[18554,18554],[18562,18562]]],[1542981185570,["gjx16@GJXAIOU",[[-1,18557,"家"]],[18558,18558],[18557,18557]]],[1542981189071,["gjx16@GJXAIOU",[[-1,18548,"释放"]],[18550,18550],[18548,18548]]],[1542981190682,["gjx16@GJXAIOU",[[1,18548,"析构"]],[18548,18548],[18550,18550]]],[1542981195007,["gjx16@GJXAIOU",[[-1,18542,"释放"]],[18544,18544],[18542,18542]]],[1542981197094,["gjx16@GJXAIOU",[[1,18542,"析构"]],[18542,18542],[18544,18544]]],[1542981930068,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13656,"\n"],[1,13657,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[1,16634,");"],[-1,16636,"****用匿名******"],[1,16649,"//用匿名对象赋值给B"],[-1,16658,"**"],[1,16660,"析构"],[1,16702,"对象"],[-1,16709,"对\n"],[-1,16862,"\n"],[1,16863,"*"],[-1,16866,"*"],[1,16876,"\n"],[-1,16878,"\n"],[1,16888,"\n"],[-1,16892,"\n"],[1,16903,"\n"],[-1,16905,"\n"],[1,16944,"\n"],[-1,16948,"\n"],[1,16959,"\n"],[-1,16961,"\n"],[-1,17008,"`"],[1,17009,"\n\n"],[-1,17019,"3"],[-1,17029,"*"],[1,17030,"究\n"],[-1,17033,"\n"],[-1,17072,"拷"],[1,17073,"认"],[-1,17078,"；"],[1,17080,"；\n"],[-1,17082,"\n"],[1,17114,"函数；"],[-1,17120,"函；数"],[1,17123,"\n"],[-1,17125,"\n"],[1,17185,"函数；"],[-1,17187,"函；加上 数"],[1,17193,"自己加上 \n"],[-1,17195,"\n"],[-1,17214,"；"],[1,17216,"；"],[1,17239,"\n"],[-1,17241,"\n"],[1,17255,"\n"],[-1,17259,"\n"],[1,17285,"\n"],[-1,17289,"\n"],[1,17307,"\n"],[-1,17311,"\n"],[1,17332,"\n"],[-1,17336,"\n"],[1,17358,"\n"],[-1,17362,"\n"],[1,17414,"\n"],[-1,17421,"*"],[-1,17428,"*"],[1,17429,"贝\n"],[-1,17431," "],[1,17458,"\n"],[-1,17460," "],[-1,17497,"*"],[1,17498,"1"],[1,17525,"\n"],[-1,18564,"\n*"],[1,18568,"2"],[-1,18572,"*C+*"],[1,18576,"序C++"],[1,18627,"\n"],[-1,18732,"\n"],[-1,18744,"\n"],[1,18745,"{"],[1,18754,"\n"],[-1,18755," "],[1,18779,"\n"],[-1,18784," "],[1,18806,"\n"],[-1,18809," "],[1,18844,"\n"],[-1,18846," "],[1,18868,"\n"],[-1,18873," "],[1,18889,"\n"],[-1,18894," "],[1,18908,"\n"],[-1,18910," "],[1,18949,"\n"],[-1,18951," "],[1,18978,"\n"],[-1,18980," "],[1,18997,"\n"],[-1,19010," "],[1,19018,"\n"],[-1,19024," "],[-1,19028," t"],[1,19030,"t <"],[-1,19032,"<"],[-1,19038," "],[-1,19040,"<"],[1,19043,"< "],[1,19049,"\n"],[-1,19051," "],[-1,19060," "],[1,19062," "],[1,19063,"="],[-1,19064,"="],[1,19070,"\n"],[-1,19079," "],[1,19093,"\n"],[-1,19096," "],[1,19111,"\n"],[-1,19114," "],[1,19125,"\n"],[-1,19135," "],[1,19163,"\n"],[-1,19169," "],[1,19188,"\n"],[-1,19197," "],[1,19211,"\n"],[-1,19214," "],[1,19229,"\n"],[-1,19232," "],[1,19242,"\n"],[-1,19250," "],[-1,19254," t"],[1,19256,"t <"],[-1,19258,"<"],[-1,19272," "],[-1,19274,"<"],[1,19277,"< "],[1,19282,"\n"],[-1,19285," "],[1,19298,"\n"],[-1,19300," "],[1,19339,"\n"],[-1,19342," "],[1,19370,"\n"],[-1,19372," "],[1,19390,"\n"],[-1,19392," "],[1,19417,"\n"],[-1,19418," "],[1,19432,"\n"],[-1,19433," "],[1,19495,"\n"],[-1,19496," "],[1,19521,"\n"],[-1,19522," "],[1,19553,"\n"],[-1,19581," "],[1,19604,"\n"],[-1,19605," "],[1,19615,"\n"],[-1,19617," "],[1,19638,"\n"],[-1,19639," "],[-1,19643," "],[-1,19645,"<"],[1,19648,"< "],[-1,19660," \""],[1,19662,"\" <"],[-1,19664,"<"],[-1,19669,"\n"],[1,19670,";"],[-1,19682,"1(\n\n{\t "],[1,19689,"n()\n{\n\t"],[1,19699,"\n"],[-1,19701," "],[-1,19717,"\n"],[1,19718,";"],[1,19721,"\n"],[-1,19769,"\n"],[1,19770,""]],[12361,12361],[19770,19770]]],[1542981930068,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13654,"\n"],[-1,13654,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[-1,16632,");"],[1,16636,"****用匿名******"],[-1,16636,"//用匿名对象赋值给B"],[1,16656,"**"],[-1,16656,"析构"],[-1,16700,"对象"],[1,16709,"对\n"],[1,16860,"\n"],[-1,16860,"*"],[1,16864,"*"],[-1,16873,"\n"],[1,16876,"\n"],[-1,16885,"\n"],[1,16890,"\n"],[-1,16900,"\n"],[1,16903,"\n"],[-1,16941,"\n"],[1,16946,"\n"],[-1,16956,"\n"],[1,16959,"\n"],[1,17005,"`"],[-1,17005,"\n\n"],[1,17017,"3"],[1,17026,"*"],[-1,17026,"究\n"],[1,17031,"\n"],[1,17069,"拷"],[-1,17069,"认"],[1,17075,"；"],[-1,17076,"；\n"],[1,17080,"\n"],[-1,17111,"函数；"],[1,17120,"函；数"],[-1,17120,"\n"],[1,17123,"\n"],[-1,17182,"函数；"],[1,17187,"函；加上 数"],[-1,17187,"自己加上 \n"],[1,17195,"\n"],[1,17213,"；"],[-1,17214,"；"],[-1,17238,"\n"],[1,17241,"\n"],[-1,17254,"\n"],[1,17259,"\n"],[-1,17284,"\n"],[1,17289,"\n"],[-1,17306,"\n"],[1,17311,"\n"],[-1,17331,"\n"],[1,17336,"\n"],[-1,17357,"\n"],[1,17362,"\n"],[-1,17413,"\n"],[1,17421,"*"],[1,17427,"*"],[-1,17427,"贝\n"],[1,17431," "],[-1,17457,"\n"],[1,17460," "],[1,17496,"*"],[-1,17496,"1"],[-1,17524,"\n"],[1,18564,"\n*"],[-1,18566,"2"],[1,18571,"*C+*"],[-1,18571,"序C++"],[-1,18626,"\n"],[1,18732,"\n"],[1,18743,"\n"],[-1,18743,"{"],[-1,18753,"\n"],[1,18755," "],[-1,18778,"\n"],[1,18784," "],[-1,18805,"\n"],[1,18809," "],[-1,18843,"\n"],[1,18846," "],[-1,18867,"\n"],[1,18873," "],[-1,18888,"\n"],[1,18894," "],[-1,18907,"\n"],[1,18910," "],[-1,18948,"\n"],[1,18951," "],[-1,18977,"\n"],[1,18980," "],[-1,18996,"\n"],[1,19010," "],[-1,19017,"\n"],[1,19024," "],[1,19027," t"],[-1,19027,"t <"],[1,19032,"<"],[1,19037," "],[1,19038,"<"],[-1,19040,"< "],[-1,19048,"\n"],[1,19051," "],[1,19059," "],[-1,19060," "],[-1,19062,"="],[1,19064,"="],[-1,19069,"\n"],[1,19079," "],[-1,19092,"\n"],[1,19096," "],[-1,19110,"\n"],[1,19114," "],[-1,19124,"\n"],[1,19135," "],[-1,19162,"\n"],[1,19169," "],[-1,19187,"\n"],[1,19197," "],[-1,19210,"\n"],[1,19214," "],[-1,19228,"\n"],[1,19232," "],[-1,19241,"\n"],[1,19250," "],[1,19253," t"],[-1,19253,"t <"],[1,19258,"<"],[1,19271," "],[1,19272,"<"],[-1,19274,"< "],[-1,19281,"\n"],[1,19285," "],[-1,19297,"\n"],[1,19300," "],[-1,19338,"\n"],[1,19342," "],[-1,19369,"\n"],[1,19372," "],[-1,19389,"\n"],[1,19392," "],[-1,19416,"\n"],[1,19418," "],[-1,19431,"\n"],[1,19433," "],[-1,19494,"\n"],[1,19496," "],[-1,19520,"\n"],[1,19522," "],[-1,19552,"\n"],[1,19581," "],[-1,19603,"\n"],[1,19605," "],[-1,19614,"\n"],[1,19617," "],[-1,19637,"\n"],[1,19639," "],[1,19642," "],[1,19643,"<"],[-1,19645,"< "],[1,19659," \""],[-1,19659,"\" <"],[1,19664,"<"],[1,19668,"\n"],[-1,19668,";"],[1,19681,"1(\n\n{\t "],[-1,19681,"n()\n{\n\t"],[-1,19698,"\n"],[1,19701," "],[1,19716,"\n"],[-1,19716,";"],[-1,19720,"\n"],[1,19769,"\n"],[-1,19769,""]],[19770,19770],[12361,12361]]],[1542981915419,["gjx16@GJXAIOU",[[-1,19726,"![2]($resource/2.png)"]],[19726,19747],[19726,19726]]],[1542981916863,["gjx16@GJXAIOU",[[-1,19726,"\n"]],[19726,19726],[19725,19725]]],[1542981925889,["gjx16@GJXAIOU",[[1,18562,"示意图："]],[18562,18562],[18566,18566]]],[1542981926654,["gjx16@GJXAIOU",[[1,18568,"\n"]],[18566,18566],[18567,18567]]],[1542981929488,["gjx16@GJXAIOU",[[1,18562,"\n"]],[18562,18562],[18563,18563]]],[1542981990071,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13656,"\n"],[1,13657,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[1,16634,");"],[-1,16636,"****用匿名******"],[1,16649,"//用匿名对象赋值给B"],[-1,16658,"**"],[1,16660,"析构"],[1,16702,"对象"],[-1,16709,"对\n"],[-1,16862,"\n"],[1,16863,"*"],[-1,16866,"*"],[1,16876,"\n"],[-1,16878,"\n"],[1,16888,"\n"],[-1,16892,"\n"],[1,16903,"\n"],[-1,16905,"\n"],[1,16944,"\n"],[-1,16948,"\n"],[1,16959,"\n"],[-1,16961,"\n"],[-1,17008,"`"],[1,17009,"\n\n"],[-1,17019,"3"],[-1,17029,"*"],[1,17030,"究\n"],[-1,17033,"\n"],[-1,17072,"拷"],[1,17073,"认"],[-1,17078,"；"],[1,17080,"；\n"],[-1,17082,"\n"],[1,17114,"函数；"],[-1,17120,"函；数"],[1,17123,"\n"],[-1,17125,"\n"],[1,17185,"函数；"],[-1,17187,"函；加上 数"],[1,17193,"自己加上 \n"],[-1,17195,"\n"],[-1,17214,"；"],[1,17216,"；"],[1,17239,"\n"],[-1,17241,"\n"],[1,17255,"\n"],[-1,17259,"\n"],[1,17285,"\n"],[-1,17289,"\n"],[1,17307,"\n"],[-1,17311,"\n"],[1,17332,"\n"],[-1,17336,"\n"],[1,17358,"\n"],[-1,17362,"\n"],[1,17414,"\n"],[-1,17421,"*"],[-1,17428,"*"],[1,17429,"贝\n"],[-1,17431," "],[1,17458,"\n"],[-1,17460," "],[-1,17497,"*"],[1,17498,"1"],[1,17525,"\n"],[-1,18570,"\n*"],[1,18574,"2"],[-1,18578,"*C+*"],[1,18582,"序C++"],[1,18633,"\n"],[-1,18738,"\n"],[-1,18750,"\n"],[1,18751,"{"],[1,18760,"\n"],[-1,18761," "],[1,18785,"\n"],[-1,18790," "],[1,18812,"\n"],[-1,18815," "],[1,18850,"\n"],[-1,18852," "],[1,18874,"\n"],[-1,18879," "],[1,18895,"\n"],[-1,18900," "],[1,18914,"\n"],[-1,18916," "],[1,18955,"\n"],[-1,18957," "],[1,18984,"\n"],[-1,18986," "],[1,19003,"\n"],[-1,19016," "],[1,19024,"\n"],[-1,19030," "],[-1,19034," t"],[1,19036,"t <"],[-1,19038,"<"],[-1,19044," "],[-1,19046,"<"],[1,19049,"< "],[1,19055,"\n"],[-1,19057," "],[-1,19066," "],[1,19068," "],[1,19069,"="],[-1,19070,"="],[1,19076,"\n"],[-1,19085," "],[1,19099,"\n"],[-1,19102," "],[1,19117,"\n"],[-1,19120," "],[1,19131,"\n"],[-1,19141," "],[1,19169,"\n"],[-1,19175," "],[1,19194,"\n"],[-1,19203," "],[1,19217,"\n"],[-1,19220," "],[1,19235,"\n"],[-1,19238," "],[1,19248,"\n"],[-1,19256," "],[-1,19260," t"],[1,19262,"t <"],[-1,19264,"<"],[-1,19278," "],[-1,19280,"<"],[1,19283,"< "],[1,19288,"\n"],[-1,19291," "],[1,19304,"\n"],[-1,19306," "],[1,19345,"\n"],[-1,19348," "],[1,19376,"\n"],[-1,19378," "],[1,19396,"\n"],[-1,19398," "],[1,19423,"\n"],[-1,19424," "],[1,19438,"\n"],[-1,19439," "],[1,19501,"\n"],[-1,19502," "],[1,19527,"\n"],[-1,19528," "],[1,19559,"\n"],[-1,19587," "],[1,19610,"\n"],[-1,19611," "],[1,19621,"\n"],[-1,19623," "],[1,19644,"\n"],[-1,19645," "],[-1,19649," "],[-1,19651,"<"],[1,19654,"< "],[-1,19666," \""],[1,19668,"\" <"],[-1,19670,"<"],[-1,19675,"\n"],[1,19676,";"],[-1,19688,"1(\n\n{\t "],[1,19695,"n()\n{\n\t"],[1,19705,"\n"],[-1,19707," "],[-1,19723,"\n"],[1,19724,";"],[1,19727,"\n"],[-1,19753,"\n"],[1,19754,""]],[12361,12361],[19754,19754]]],[1542981990071,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13654,"\n"],[-1,13654,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[-1,16632,");"],[1,16636,"****用匿名******"],[-1,16636,"//用匿名对象赋值给B"],[1,16656,"**"],[-1,16656,"析构"],[-1,16700,"对象"],[1,16709,"对\n"],[1,16860,"\n"],[-1,16860,"*"],[1,16864,"*"],[-1,16873,"\n"],[1,16876,"\n"],[-1,16885,"\n"],[1,16890,"\n"],[-1,16900,"\n"],[1,16903,"\n"],[-1,16941,"\n"],[1,16946,"\n"],[-1,16956,"\n"],[1,16959,"\n"],[1,17005,"`"],[-1,17005,"\n\n"],[1,17017,"3"],[1,17026,"*"],[-1,17026,"究\n"],[1,17031,"\n"],[1,17069,"拷"],[-1,17069,"认"],[1,17075,"；"],[-1,17076,"；\n"],[1,17080,"\n"],[-1,17111,"函数；"],[1,17120,"函；数"],[-1,17120,"\n"],[1,17123,"\n"],[-1,17182,"函数；"],[1,17187,"函；加上 数"],[-1,17187,"自己加上 \n"],[1,17195,"\n"],[1,17213,"；"],[-1,17214,"；"],[-1,17238,"\n"],[1,17241,"\n"],[-1,17254,"\n"],[1,17259,"\n"],[-1,17284,"\n"],[1,17289,"\n"],[-1,17306,"\n"],[1,17311,"\n"],[-1,17331,"\n"],[1,17336,"\n"],[-1,17357,"\n"],[1,17362,"\n"],[-1,17413,"\n"],[1,17421,"*"],[1,17427,"*"],[-1,17427,"贝\n"],[1,17431," "],[-1,17457,"\n"],[1,17460," "],[1,17496,"*"],[-1,17496,"1"],[-1,17524,"\n"],[1,18570,"\n*"],[-1,18572,"2"],[1,18577,"*C+*"],[-1,18577,"序C++"],[-1,18632,"\n"],[1,18738,"\n"],[1,18749,"\n"],[-1,18749,"{"],[-1,18759,"\n"],[1,18761," "],[-1,18784,"\n"],[1,18790," "],[-1,18811,"\n"],[1,18815," "],[-1,18849,"\n"],[1,18852," "],[-1,18873,"\n"],[1,18879," "],[-1,18894,"\n"],[1,18900," "],[-1,18913,"\n"],[1,18916," "],[-1,18954,"\n"],[1,18957," "],[-1,18983,"\n"],[1,18986," "],[-1,19002,"\n"],[1,19016," "],[-1,19023,"\n"],[1,19030," "],[1,19033," t"],[-1,19033,"t <"],[1,19038,"<"],[1,19043," "],[1,19044,"<"],[-1,19046,"< "],[-1,19054,"\n"],[1,19057," "],[1,19065," "],[-1,19066," "],[-1,19068,"="],[1,19070,"="],[-1,19075,"\n"],[1,19085," "],[-1,19098,"\n"],[1,19102," "],[-1,19116,"\n"],[1,19120," "],[-1,19130,"\n"],[1,19141," "],[-1,19168,"\n"],[1,19175," "],[-1,19193,"\n"],[1,19203," "],[-1,19216,"\n"],[1,19220," "],[-1,19234,"\n"],[1,19238," "],[-1,19247,"\n"],[1,19256," "],[1,19259," t"],[-1,19259,"t <"],[1,19264,"<"],[1,19277," "],[1,19278,"<"],[-1,19280,"< "],[-1,19287,"\n"],[1,19291," "],[-1,19303,"\n"],[1,19306," "],[-1,19344,"\n"],[1,19348," "],[-1,19375,"\n"],[1,19378," "],[-1,19395,"\n"],[1,19398," "],[-1,19422,"\n"],[1,19424," "],[-1,19437,"\n"],[1,19439," "],[-1,19500,"\n"],[1,19502," "],[-1,19526,"\n"],[1,19528," "],[-1,19558,"\n"],[1,19587," "],[-1,19609,"\n"],[1,19611," "],[-1,19620,"\n"],[1,19623," "],[-1,19643,"\n"],[1,19645," "],[1,19648," "],[1,19649,"<"],[-1,19651,"< "],[1,19665," \""],[-1,19665,"\" <"],[1,19670,"<"],[1,19674,"\n"],[-1,19674,";"],[1,19687,"1(\n\n{\t "],[-1,19687,"n()\n{\n\t"],[-1,19704,"\n"],[1,19707," "],[1,19722,"\n"],[-1,19722,";"],[-1,19726,"\n"],[1,19753,"\n"],[-1,19753,""]],[19754,19754],[12361,12361]]],[1542981962620,["gjx16@GJXAIOU",[[1,18568,"![4]($resource/4.png)"]],[18568,18568],[18590,18590]]],[1542982050083,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13656,"\n"],[1,13657,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[1,16634,");"],[-1,16636,"****用匿名******"],[1,16649,"//用匿名对象赋值给B"],[-1,16658,"**"],[1,16660,"析构"],[1,16702,"对象"],[-1,16709,"对\n"],[-1,16862,"\n"],[1,16863,"*"],[-1,16866,"*"],[1,16876,"\n"],[-1,16878,"\n"],[1,16888,"\n"],[-1,16892,"\n"],[1,16903,"\n"],[-1,16905,"\n"],[1,16944,"\n"],[-1,16948,"\n"],[1,16959,"\n"],[-1,16961,"\n"],[-1,17008,"`"],[1,17009,"\n\n"],[-1,17019,"3"],[-1,17029,"*"],[1,17030,"究\n"],[-1,17033,"\n"],[-1,17072,"拷"],[1,17073,"认"],[-1,17078,"；"],[1,17080,"；\n"],[-1,17082,"\n"],[1,17114,"函数；"],[-1,17120,"函；数"],[1,17123,"\n"],[-1,17125,"\n"],[1,17185,"函数；"],[-1,17187,"函；加上 数"],[1,17193,"自己加上 \n"],[-1,17195,"\n"],[-1,17214,"；"],[1,17216,"；"],[1,17239,"\n"],[-1,17241,"\n"],[1,17255,"\n"],[-1,17259,"\n"],[1,17285,"\n"],[-1,17289,"\n"],[1,17307,"\n"],[-1,17311,"\n"],[1,17332,"\n"],[-1,17336,"\n"],[1,17358,"\n"],[-1,17362,"\n"],[1,17414,"\n"],[-1,17421,"*"],[-1,17428,"*"],[1,17429,"贝\n"],[-1,17431," "],[1,17458,"\n"],[-1,17460," "],[-1,17497,"*"],[1,17498,"1"],[1,17525,"\n"],[-1,18591,"\n*"],[1,18595,"2"],[-1,18599,"*C+*"],[1,18603,"序C++"],[1,18654,"\n"],[-1,18759,"\n"],[-1,18771,"\n"],[1,18772,"{"],[1,18781,"\n"],[-1,18782," "],[1,18806,"\n"],[-1,18811," "],[1,18833,"\n"],[-1,18836," "],[1,18871,"\n"],[-1,18873," "],[1,18895,"\n"],[-1,18900," "],[1,18916,"\n"],[-1,18921," "],[1,18935,"\n"],[-1,18937," "],[1,18976,"\n"],[-1,18978," "],[1,19005,"\n"],[-1,19007," "],[1,19024,"\n"],[-1,19037," "],[1,19045,"\n"],[-1,19051," "],[-1,19055," t"],[1,19057,"t <"],[-1,19059,"<"],[-1,19065," "],[-1,19067,"<"],[1,19070,"< "],[1,19076,"\n"],[-1,19078," "],[-1,19087," "],[1,19089," "],[1,19090,"="],[-1,19091,"="],[1,19097,"\n"],[-1,19106," "],[1,19120,"\n"],[-1,19123," "],[1,19138,"\n"],[-1,19141," "],[1,19152,"\n"],[-1,19162," "],[1,19190,"\n"],[-1,19196," "],[1,19215,"\n"],[-1,19224," "],[1,19238,"\n"],[-1,19241," "],[1,19256,"\n"],[-1,19259," "],[1,19269,"\n"],[-1,19277," "],[-1,19281," t"],[1,19283,"t <"],[-1,19285,"<"],[-1,19299," "],[-1,19301,"<"],[1,19304,"< "],[1,19309,"\n"],[-1,19312," "],[1,19325,"\n"],[-1,19327," "],[1,19366,"\n"],[-1,19369," "],[1,19397,"\n"],[-1,19399," "],[1,19417,"\n"],[-1,19419," "],[1,19444,"\n"],[-1,19445," "],[1,19459,"\n"],[-1,19460," "],[1,19522,"\n"],[-1,19523," "],[1,19548,"\n"],[-1,19549," "],[1,19580,"\n"],[-1,19608," "],[1,19631,"\n"],[-1,19632," "],[1,19642,"\n"],[-1,19644," "],[1,19665,"\n"],[-1,19666," "],[-1,19670," "],[-1,19672,"<"],[1,19675,"< "],[-1,19687," \""],[1,19689,"\" <"],[-1,19691,"<"],[-1,19696,"\n"],[1,19697,";"],[-1,19709,"1(\n\n{\t "],[1,19716,"n()\n{\n\t"],[1,19726,"\n"],[-1,19728," "],[-1,19744,"\n"],[1,19745,";"],[1,19748,"\n"],[-1,19774,"\n"],[1,19775,""]],[12361,12361],[19775,19775]]],[1542982050083,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13654,"\n"],[-1,13654,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[-1,16632,");"],[1,16636,"****用匿名******"],[-1,16636,"//用匿名对象赋值给B"],[1,16656,"**"],[-1,16656,"析构"],[-1,16700,"对象"],[1,16709,"对\n"],[1,16860,"\n"],[-1,16860,"*"],[1,16864,"*"],[-1,16873,"\n"],[1,16876,"\n"],[-1,16885,"\n"],[1,16890,"\n"],[-1,16900,"\n"],[1,16903,"\n"],[-1,16941,"\n"],[1,16946,"\n"],[-1,16956,"\n"],[1,16959,"\n"],[1,17005,"`"],[-1,17005,"\n\n"],[1,17017,"3"],[1,17026,"*"],[-1,17026,"究\n"],[1,17031,"\n"],[1,17069,"拷"],[-1,17069,"认"],[1,17075,"；"],[-1,17076,"；\n"],[1,17080,"\n"],[-1,17111,"函数；"],[1,17120,"函；数"],[-1,17120,"\n"],[1,17123,"\n"],[-1,17182,"函数；"],[1,17187,"函；加上 数"],[-1,17187,"自己加上 \n"],[1,17195,"\n"],[1,17213,"；"],[-1,17214,"；"],[-1,17238,"\n"],[1,17241,"\n"],[-1,17254,"\n"],[1,17259,"\n"],[-1,17284,"\n"],[1,17289,"\n"],[-1,17306,"\n"],[1,17311,"\n"],[-1,17331,"\n"],[1,17336,"\n"],[-1,17357,"\n"],[1,17362,"\n"],[-1,17413,"\n"],[1,17421,"*"],[1,17427,"*"],[-1,17427,"贝\n"],[1,17431," "],[-1,17457,"\n"],[1,17460," "],[1,17496,"*"],[-1,17496,"1"],[-1,17524,"\n"],[1,18591,"\n*"],[-1,18593,"2"],[1,18598,"*C+*"],[-1,18598,"序C++"],[-1,18653,"\n"],[1,18759,"\n"],[1,18770,"\n"],[-1,18770,"{"],[-1,18780,"\n"],[1,18782," "],[-1,18805,"\n"],[1,18811," "],[-1,18832,"\n"],[1,18836," "],[-1,18870,"\n"],[1,18873," "],[-1,18894,"\n"],[1,18900," "],[-1,18915,"\n"],[1,18921," "],[-1,18934,"\n"],[1,18937," "],[-1,18975,"\n"],[1,18978," "],[-1,19004,"\n"],[1,19007," "],[-1,19023,"\n"],[1,19037," "],[-1,19044,"\n"],[1,19051," "],[1,19054," t"],[-1,19054,"t <"],[1,19059,"<"],[1,19064," "],[1,19065,"<"],[-1,19067,"< "],[-1,19075,"\n"],[1,19078," "],[1,19086," "],[-1,19087," "],[-1,19089,"="],[1,19091,"="],[-1,19096,"\n"],[1,19106," "],[-1,19119,"\n"],[1,19123," "],[-1,19137,"\n"],[1,19141," "],[-1,19151,"\n"],[1,19162," "],[-1,19189,"\n"],[1,19196," "],[-1,19214,"\n"],[1,19224," "],[-1,19237,"\n"],[1,19241," "],[-1,19255,"\n"],[1,19259," "],[-1,19268,"\n"],[1,19277," "],[1,19280," t"],[-1,19280,"t <"],[1,19285,"<"],[1,19298," "],[1,19299,"<"],[-1,19301,"< "],[-1,19308,"\n"],[1,19312," "],[-1,19324,"\n"],[1,19327," "],[-1,19365,"\n"],[1,19369," "],[-1,19396,"\n"],[1,19399," "],[-1,19416,"\n"],[1,19419," "],[-1,19443,"\n"],[1,19445," "],[-1,19458,"\n"],[1,19460," "],[-1,19521,"\n"],[1,19523," "],[-1,19547,"\n"],[1,19549," "],[-1,19579,"\n"],[1,19608," "],[-1,19630,"\n"],[1,19632," "],[-1,19641,"\n"],[1,19644," "],[-1,19664,"\n"],[1,19666," "],[1,19669," "],[1,19670,"<"],[-1,19672,"< "],[1,19686," \""],[-1,19686,"\" <"],[1,19691,"<"],[1,19695,"\n"],[-1,19695,";"],[1,19708,"1(\n\n{\t "],[-1,19708,"n()\n{\n\t"],[-1,19725,"\n"],[1,19728," "],[1,19743,"\n"],[-1,19743,";"],[-1,19747,"\n"],[1,19774,"\n"],[-1,19774,""]],[19775,19775],[12361,12361]]],[1542982034904,["gjx16@GJXAIOU",[[1,18898,"、、"]],[18898,18898],[18900,18900]]],[1542982036485,["gjx16@GJXAIOU",[[-1,18898,"、、"]],[18900,18900],[18898,18898]]],[1542982041646,["gjx16@GJXAIOU",[[1,18898,"    //结局"]],[18898,18898],[18906,18906]]],[1542982043246,["gjx16@GJXAIOU",[[-1,18904,"结局"]],[18906,18906],[18904,18904]]],[1542982046863,["gjx16@GJXAIOU",[[1,18904,"解决方法："]],[18904,18904],[18909,18909]]],[1542982111052,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13656,"\n"],[1,13657,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[1,16634,");"],[-1,16636,"****用匿名******"],[1,16649,"//用匿名对象赋值给B"],[-1,16658,"**"],[1,16660,"析构"],[1,16702,"对象"],[-1,16709,"对\n"],[-1,16862,"\n"],[1,16863,"*"],[-1,16866,"*"],[1,16876,"\n"],[-1,16878,"\n"],[1,16888,"\n"],[-1,16892,"\n"],[1,16903,"\n"],[-1,16905,"\n"],[1,16944,"\n"],[-1,16948,"\n"],[1,16959,"\n"],[-1,16961,"\n"],[-1,17008,"`"],[1,17009,"\n\n"],[-1,17019,"3"],[-1,17029,"*"],[1,17030,"究\n"],[-1,17033,"\n"],[-1,17072,"拷"],[1,17073,"认"],[-1,17078,"；"],[1,17080,"；\n"],[-1,17082,"\n"],[1,17114,"函数；"],[-1,17120,"函；数"],[1,17123,"\n"],[-1,17125,"\n"],[1,17185,"函数；"],[-1,17187,"函；加上 数"],[1,17193,"自己加上 \n"],[-1,17195,"\n"],[-1,17214,"；"],[1,17216,"；"],[1,17239,"\n"],[-1,17241,"\n"],[1,17255,"\n"],[-1,17259,"\n"],[1,17285,"\n"],[-1,17289,"\n"],[1,17307,"\n"],[-1,17311,"\n"],[1,17332,"\n"],[-1,17336,"\n"],[1,17358,"\n"],[-1,17362,"\n"],[1,17414,"\n"],[-1,17421,"*"],[-1,17428,"*"],[1,17429,"贝\n"],[-1,17431," "],[1,17458,"\n"],[-1,17460," "],[-1,17497,"*"],[1,17498,"1"],[1,17525,"\n"],[-1,18591,"\n*"],[1,18595,"2"],[-1,18599,"*C+*"],[1,18603,"序C++"],[1,18654,"\n"],[-1,18759,"\n"],[-1,18771,"\n"],[1,18772,"{"],[1,18781,"\n"],[-1,18782," "],[1,18806,"\n"],[-1,18811," "],[1,18833,"\n"],[-1,18836," "],[1,18871,"\n"],[-1,18873," "],[1,18895,"\n"],[-1,18911," "],[1,18927,"\n"],[-1,18932," "],[1,18946,"\n"],[-1,18948," "],[1,18987,"\n"],[-1,18989," "],[1,19016,"\n"],[-1,19018," "],[1,19035,"\n"],[-1,19048," "],[1,19056,"\n"],[-1,19062," "],[-1,19066," t"],[1,19068,"t <"],[-1,19070,"<"],[-1,19076," "],[-1,19078,"<"],[1,19081,"< "],[1,19087,"\n"],[-1,19089," "],[-1,19098," "],[1,19100," "],[1,19101,"="],[-1,19102,"="],[1,19108,"\n"],[-1,19117," "],[1,19131,"\n"],[-1,19134," "],[1,19149,"\n"],[-1,19152," "],[1,19163,"\n"],[-1,19173," "],[1,19201,"\n"],[-1,19207," "],[1,19226,"\n"],[-1,19235," "],[1,19249,"\n"],[-1,19252," "],[1,19267,"\n"],[-1,19270," "],[1,19280,"\n"],[-1,19288," "],[-1,19292," t"],[1,19294,"t <"],[-1,19296,"<"],[-1,19310," "],[-1,19312,"<"],[1,19315,"< "],[1,19320,"\n"],[-1,19323," "],[1,19336,"\n"],[-1,19338," "],[1,19377,"\n"],[-1,19380," "],[1,19408,"\n"],[-1,19410," "],[1,19428,"\n"],[-1,19430," "],[1,19455,"\n"],[-1,19456," "],[1,19470,"\n"],[-1,19471," "],[1,19533,"\n"],[-1,19534," "],[1,19559,"\n"],[-1,19560," "],[1,19591,"\n"],[-1,19619," "],[1,19642,"\n"],[-1,19643," "],[1,19653,"\n"],[-1,19655," "],[1,19676,"\n"],[-1,19677," "],[-1,19681," "],[-1,19683,"<"],[1,19686,"< "],[-1,19698," \""],[1,19700,"\" <"],[-1,19702,"<"],[-1,19707,"\n"],[1,19708,";"],[-1,19720,"1(\n\n{\t "],[1,19727,"n()\n{\n\t"],[1,19737,"\n"],[-1,19739," "],[-1,19755,"\n"],[1,19756,";"],[1,19759,"\n"],[-1,19785,"\n"],[1,19786,""]],[12361,12361],[19786,19786]]],[1542982111052,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13654,"\n"],[-1,13654,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[-1,16632,");"],[1,16636,"****用匿名******"],[-1,16636,"//用匿名对象赋值给B"],[1,16656,"**"],[-1,16656,"析构"],[-1,16700,"对象"],[1,16709,"对\n"],[1,16860,"\n"],[-1,16860,"*"],[1,16864,"*"],[-1,16873,"\n"],[1,16876,"\n"],[-1,16885,"\n"],[1,16890,"\n"],[-1,16900,"\n"],[1,16903,"\n"],[-1,16941,"\n"],[1,16946,"\n"],[-1,16956,"\n"],[1,16959,"\n"],[1,17005,"`"],[-1,17005,"\n\n"],[1,17017,"3"],[1,17026,"*"],[-1,17026,"究\n"],[1,17031,"\n"],[1,17069,"拷"],[-1,17069,"认"],[1,17075,"；"],[-1,17076,"；\n"],[1,17080,"\n"],[-1,17111,"函数；"],[1,17120,"函；数"],[-1,17120,"\n"],[1,17123,"\n"],[-1,17182,"函数；"],[1,17187,"函；加上 数"],[-1,17187,"自己加上 \n"],[1,17195,"\n"],[1,17213,"；"],[-1,17214,"；"],[-1,17238,"\n"],[1,17241,"\n"],[-1,17254,"\n"],[1,17259,"\n"],[-1,17284,"\n"],[1,17289,"\n"],[-1,17306,"\n"],[1,17311,"\n"],[-1,17331,"\n"],[1,17336,"\n"],[-1,17357,"\n"],[1,17362,"\n"],[-1,17413,"\n"],[1,17421,"*"],[1,17427,"*"],[-1,17427,"贝\n"],[1,17431," "],[-1,17457,"\n"],[1,17460," "],[1,17496,"*"],[-1,17496,"1"],[-1,17524,"\n"],[1,18591,"\n*"],[-1,18593,"2"],[1,18598,"*C+*"],[-1,18598,"序C++"],[-1,18653,"\n"],[1,18759,"\n"],[1,18770,"\n"],[-1,18770,"{"],[-1,18780,"\n"],[1,18782," "],[-1,18805,"\n"],[1,18811," "],[-1,18832,"\n"],[1,18836," "],[-1,18870,"\n"],[1,18873," "],[-1,18894,"\n"],[1,18911," "],[-1,18926,"\n"],[1,18932," "],[-1,18945,"\n"],[1,18948," "],[-1,18986,"\n"],[1,18989," "],[-1,19015,"\n"],[1,19018," "],[-1,19034,"\n"],[1,19048," "],[-1,19055,"\n"],[1,19062," "],[1,19065," t"],[-1,19065,"t <"],[1,19070,"<"],[1,19075," "],[1,19076,"<"],[-1,19078,"< "],[-1,19086,"\n"],[1,19089," "],[1,19097," "],[-1,19098," "],[-1,19100,"="],[1,19102,"="],[-1,19107,"\n"],[1,19117," "],[-1,19130,"\n"],[1,19134," "],[-1,19148,"\n"],[1,19152," "],[-1,19162,"\n"],[1,19173," "],[-1,19200,"\n"],[1,19207," "],[-1,19225,"\n"],[1,19235," "],[-1,19248,"\n"],[1,19252," "],[-1,19266,"\n"],[1,19270," "],[-1,19279,"\n"],[1,19288," "],[1,19291," t"],[-1,19291,"t <"],[1,19296,"<"],[1,19309," "],[1,19310,"<"],[-1,19312,"< "],[-1,19319,"\n"],[1,19323," "],[-1,19335,"\n"],[1,19338," "],[-1,19376,"\n"],[1,19380," "],[-1,19407,"\n"],[1,19410," "],[-1,19427,"\n"],[1,19430," "],[-1,19454,"\n"],[1,19456," "],[-1,19469,"\n"],[1,19471," "],[-1,19532,"\n"],[1,19534," "],[-1,19558,"\n"],[1,19560," "],[-1,19590,"\n"],[1,19619," "],[-1,19641,"\n"],[1,19643," "],[-1,19652,"\n"],[1,19655," "],[-1,19675,"\n"],[1,19677," "],[1,19680," "],[1,19681,"<"],[-1,19683,"< "],[1,19697," \""],[-1,19697,"\" <"],[1,19702,"<"],[1,19706,"\n"],[-1,19706,";"],[1,19719,"1(\n\n{\t "],[-1,19719,"n()\n{\n\t"],[-1,19736,"\n"],[1,19739," "],[1,19754,"\n"],[-1,19754,";"],[-1,19758,"\n"],[1,19785,"\n"],[-1,19785,""]],[19786,19786],[12361,12361]]],[1542982064092,["gjx16@GJXAIOU",[[1,18909,"手工编写拷贝函数，使用深k"]],[18909,18909],[18922,18922]]],[1542982065351,["gjx16@GJXAIOU",[[-1,18921,"k"]],[18922,18922],[18921,18921]]],[1542982067704,["gjx16@GJXAIOU",[[1,18921,"copy"]],[18921,18921],[18925,18925]]],[1542982719089,[null,[[-1,12361,"*"],[-1,12371,"*"],[1,12372,"用"],[1,12406,"*"],[-1,12408,"*"],[1,12413,"的"],[-1,12416,"的"],[1,12721,"数"],[-1,12749,",z数"],[-1,13087,""],[1,13087,"\n"],[-1,13656,"\n"],[1,13657,"*"],[-1,13660,"*"],[-1,13850,"\n"],[1,13852,"\n"],[1,14282,"\n"],[-1,14285," "],[1,14286,"\n"],[-1,14291,"\n"],[1,14299,"\n"],[-1,14305,"\n"],[1,14478,"\n"],[-1,14481,"\n"],[1,14509,"\n"],[-1,15127,"\n"],[1,15135,"\n"],[-1,15158,"\n"],[1,15226,"\n"],[-1,15227," "],[-1,15236," "],[1,15237,"("],[-1,15246," "],[1,15247,"0"],[-1,15258," )"],[1,15260,"0)\n"],[-1,15265," "],[-1,15271," "],[1,15272,"x"],[-1,15279," "],[1,15280,"y"],[-1,15312," ;"],[1,15314,"\";\n"],[-1,15319," "],[-1,15328," "],[1,15329,"("],[1,15345," "],[-1,15348," "],[1,15364,"\n"],[-1,15369," "],[1,15373," "],[-1,15376,"p. "],[1,15379,".X"],[1,15384," "],[-1,15393," "],[-1,15435," ;"],[1,15437,"l;\n"],[-1,15442," "],[1,15454,"\n"],[-1,15459," "],[-1,15512," ;"],[1,15514,"l;\n"],[-1,15518," "],[-1,15526," "],[1,15527,"X"],[-1,15539," "],[1,15540,"X"],[-1,15551," "],[1,15552,"Y"],[-1,15564," "],[1,15565,"Y"],[-1,15576," "],[1,15577,"e"],[-1,15583," ,  ;\n "],[1,15590,"X, Y;\n}"],[1,15593,"/"],[-1,15608,"\n"],[-1,15615,"  "],[1,15617,"f("],[-1,15626,"  "],[1,15628,"p)"],[1,15630,"\n"],[-1,15631," "],[-1,15688," "],[1,15689,"l"],[1,15713,"{"],[-1,15715," "],[-1,15725,"  1,   "],[1,15732,"A(1, 2)"],[1,15765,"\n"],[-1,15769,"\n     "],[1,15775," f(A)"],[1,15792,"{"],[-1,15794," "],[1,15810,"\n"],[-1,15811," "],[1,15829,"}"],[-1,15833,"|"],[1,15834,"\n"],[-1,15839,"\n"],[-1,15848," "],[1,15849,"\n\n"],[1,16389,"}\n"],[-1,16448,"}\n"],[1,16634,");"],[-1,16636,"****用匿名******"],[1,16649,"//用匿名对象赋值给B"],[-1,16658,"**"],[1,16660,"析构"],[1,16702,"对象"],[-1,16709,"对\n"],[-1,16862,"\n"],[1,16863,"*"],[-1,16866,"*"],[1,16876,"\n"],[-1,16878,"\n"],[1,16888,"\n"],[-1,16892,"\n"],[1,16903,"\n"],[-1,16905,"\n"],[1,16944,"\n"],[-1,16948,"\n"],[1,16959,"\n"],[-1,16961,"\n"],[-1,17008,"`"],[1,17009,"\n\n"],[-1,17019,"3"],[-1,17029,"*"],[1,17030,"究\n"],[-1,17033,"\n"],[-1,17072,"拷"],[1,17073,"认"],[-1,17078,"；"],[1,17080,"；\n"],[-1,17082,"\n"],[1,17114,"函数；"],[-1,17120,"函；数"],[1,17123,"\n"],[-1,17125,"\n"],[1,17185,"函数；"],[-1,17187,"函；加上 数"],[1,17193,"自己加上 \n"],[-1,17195,"\n"],[-1,17214,"；"],[1,17216,"；"],[1,17239,"\n"],[-1,17241,"\n"],[1,17255,"\n"],[-1,17259,"\n"],[1,17285,"\n"],[-1,17289,"\n"],[1,17307,"\n"],[-1,17311,"\n"],[1,17332,"\n"],[-1,17336,"\n"],[1,17358,"\n"],[-1,17362,"\n"],[1,17414,"\n"],[-1,17421,"*"],[-1,17428,"*"],[1,17429,"贝\n"],[-1,17431," "],[1,17458,"\n"],[-1,17460," "],[-1,17497,"*"],[1,17498,"1"],[1,17525,"\n"],[-1,18591,"\n*"],[1,18595,"2"],[-1,18599,"*C+*"],[1,18603,"序C++"],[1,18654,"\n"],[-1,18759,"\n"],[-1,18771,"\n"],[1,18772,"{"],[1,18781,"\n"],[-1,18782," "],[1,18806,"\n"],[-1,18811," "],[1,18833,"\n"],[-1,18836," "],[1,18871,"\n"],[-1,18873," "],[1,18895,"\n"],[-1,18927," "],[1,18943,"\n"],[-1,18948," "],[1,18962,"\n"],[-1,18964," "],[1,19003,"\n"],[-1,19005," "],[1,19032,"\n"],[-1,19034," "],[1,19051,"\n"],[-1,19064," "],[1,19072,"\n"],[-1,19078," "],[-1,19082," t"],[1,19084,"t <"],[-1,19086,"<"],[-1,19092," "],[-1,19094,"<"],[1,19097,"< "],[1,19103,"\n"],[-1,19105," "],[-1,19114," "],[1,19116," "],[1,19117,"="],[-1,19118,"="],[1,19124,"\n"],[-1,19133," "],[1,19147,"\n"],[-1,19150," "],[1,19165,"\n"],[-1,19168," "],[1,19179,"\n"],[-1,19189," "],[1,19217,"\n"],[-1,19223," "],[1,19242,"\n"],[-1,19251," "],[1,19265,"\n"],[-1,19268," "],[1,19283,"\n"],[-1,19286," "],[1,19296,"\n"],[-1,19304," "],[-1,19308," t"],[1,19310,"t <"],[-1,19312,"<"],[-1,19326," "],[-1,19328,"<"],[1,19331,"< "],[1,19336,"\n"],[-1,19339," "],[1,19352,"\n"],[-1,19354," "],[1,19393,"\n"],[-1,19396," "],[1,19424,"\n"],[-1,19426," "],[1,19444,"\n"],[-1,19446," "],[1,19471,"\n"],[-1,19472," "],[1,19486,"\n"],[-1,19487," "],[1,19549,"\n"],[-1,19550," "],[1,19575,"\n"],[-1,19576," "],[1,19607,"\n"],[-1,19635," "],[1,19658,"\n"],[-1,19659," "],[1,19669,"\n"],[-1,19671," "],[1,19692,"\n"],[-1,19693," "],[-1,19697," "],[-1,19699,"<"],[1,19702,"< "],[-1,19714," \""],[1,19716,"\" <"],[-1,19718,"<"],[-1,19723,"\n"],[1,19724,";"],[-1,19736,"1(\n\n{\t "],[1,19743,"n()\n{\n\t"],[1,19753,"\n"],[-1,19755," "],[-1,19771,"\n"],[1,19772,";"],[1,19775,"\n"],[-1,19801,"\n"],[1,19802,""]],[12361,12361],[19802,19802]]],[1542982719089,[null,[[1,12361,"*"],[1,12370,"*"],[-1,12370,"用"],[-1,12405,"*"],[1,12408,"*"],[-1,12412,"的"],[1,12416,"的"],[-1,12720,"数"],[1,12749,",z数"],[1,13084,""],[-1,13084,"\n"],[1,13654,"\n"],[-1,13654,"*"],[1,13658,"*"],[1,13847,"\n"],[-1,13848,"\n"],[-1,14279,"\n"],[1,14283," "],[-1,14283,"\n"],[1,14289,"\n"],[-1,14296,"\n"],[1,14303,"\n"],[-1,14475,"\n"],[1,14479,"\n"],[-1,14506,"\n"],[1,15125,"\n"],[-1,15132,"\n"],[1,15156,"\n"],[-1,15223,"\n"],[1,15225," "],[1,15233," "],[-1,15233,"("],[1,15243," "],[-1,15243,"0"],[1,15255," )"],[-1,15255,"0)\n"],[1,15263," "],[1,15268," "],[-1,15268,"x"],[1,15276," "],[-1,15276,"y"],[1,15309," ;"],[-1,15309,"\";\n"],[1,15317," "],[1,15325," "],[-1,15325,"("],[-1,15342," "],[1,15346," "],[-1,15361,"\n"],[1,15367," "],[-1,15370," "],[1,15374,"p. "],[-1,15374,".X"],[-1,15381," "],[1,15391," "],[1,15432," ;"],[-1,15432,"l;\n"],[1,15440," "],[-1,15451,"\n"],[1,15457," "],[1,15509," ;"],[-1,15509,"l;\n"],[1,15516," "],[1,15523," "],[-1,15523,"X"],[1,15536," "],[-1,15536,"X"],[1,15548," "],[-1,15548,"Y"],[1,15561," "],[-1,15561,"Y"],[1,15573," "],[-1,15573,"e"],[1,15580," ,  ;\n "],[-1,15580,"X, Y;\n}"],[-1,15590,"/"],[1,15606,"\n"],[1,15612,"  "],[-1,15612,"f("],[1,15623,"  "],[-1,15623,"p)"],[-1,15627,"\n"],[1,15629," "],[1,15685," "],[-1,15685,"l"],[-1,15710,"{"],[1,15713," "],[1,15722,"  1,   "],[-1,15722,"A(1, 2)"],[-1,15762,"\n"],[1,15767,"\n     "],[-1,15767," f(A)"],[-1,15789,"{"],[1,15792," "],[-1,15807,"\n"],[1,15809," "],[-1,15826,"}"],[1,15831,"|"],[-1,15831,"\n"],[1,15837,"\n"],[1,15845," "],[-1,15845,"\n\n"],[-1,16387,"}\n"],[1,16448,"}\n"],[-1,16632,");"],[1,16636,"****用匿名******"],[-1,16636,"//用匿名对象赋值给B"],[1,16656,"**"],[-1,16656,"析构"],[-1,16700,"对象"],[1,16709,"对\n"],[1,16860,"\n"],[-1,16860,"*"],[1,16864,"*"],[-1,16873,"\n"],[1,16876,"\n"],[-1,16885,"\n"],[1,16890,"\n"],[-1,16900,"\n"],[1,16903,"\n"],[-1,16941,"\n"],[1,16946,"\n"],[-1,16956,"\n"],[1,16959,"\n"],[1,17005,"`"],[-1,17005,"\n\n"],[1,17017,"3"],[1,17026,"*"],[-1,17026,"究\n"],[1,17031,"\n"],[1,17069,"拷"],[-1,17069,"认"],[1,17075,"；"],[-1,17076,"；\n"],[1,17080,"\n"],[-1,17111,"函数；"],[1,17120,"函；数"],[-1,17120,"\n"],[1,17123,"\n"],[-1,17182,"函数；"],[1,17187,"函；加上 数"],[-1,17187,"自己加上 \n"],[1,17195,"\n"],[1,17213,"；"],[-1,17214,"；"],[-1,17238,"\n"],[1,17241,"\n"],[-1,17254,"\n"],[1,17259,"\n"],[-1,17284,"\n"],[1,17289,"\n"],[-1,17306,"\n"],[1,17311,"\n"],[-1,17331,"\n"],[1,17336,"\n"],[-1,17357,"\n"],[1,17362,"\n"],[-1,17413,"\n"],[1,17421,"*"],[1,17427,"*"],[-1,17427,"贝\n"],[1,17431," "],[-1,17457,"\n"],[1,17460," "],[1,17496,"*"],[-1,17496,"1"],[-1,17524,"\n"],[1,18591,"\n*"],[-1,18593,"2"],[1,18598,"*C+*"],[-1,18598,"序C++"],[-1,18653,"\n"],[1,18759,"\n"],[1,18770,"\n"],[-1,18770,"{"],[-1,18780,"\n"],[1,18782," "],[-1,18805,"\n"],[1,18811," "],[-1,18832,"\n"],[1,18836," "],[-1,18870,"\n"],[1,18873," "],[-1,18894,"\n"],[1,18927," "],[-1,18942,"\n"],[1,18948," "],[-1,18961,"\n"],[1,18964," "],[-1,19002,"\n"],[1,19005," "],[-1,19031,"\n"],[1,19034," "],[-1,19050,"\n"],[1,19064," "],[-1,19071,"\n"],[1,19078," "],[1,19081," t"],[-1,19081,"t <"],[1,19086,"<"],[1,19091," "],[1,19092,"<"],[-1,19094,"< "],[-1,19102,"\n"],[1,19105," "],[1,19113," "],[-1,19114," "],[-1,19116,"="],[1,19118,"="],[-1,19123,"\n"],[1,19133," "],[-1,19146,"\n"],[1,19150," "],[-1,19164,"\n"],[1,19168," "],[-1,19178,"\n"],[1,19189," "],[-1,19216,"\n"],[1,19223," "],[-1,19241,"\n"],[1,19251," "],[-1,19264,"\n"],[1,19268," "],[-1,19282,"\n"],[1,19286," "],[-1,19295,"\n"],[1,19304," "],[1,19307," t"],[-1,19307,"t <"],[1,19312,"<"],[1,19325," "],[1,19326,"<"],[-1,19328,"< "],[-1,19335,"\n"],[1,19339," "],[-1,19351,"\n"],[1,19354," "],[-1,19392,"\n"],[1,19396," "],[-1,19423,"\n"],[1,19426," "],[-1,19443,"\n"],[1,19446," "],[-1,19470,"\n"],[1,19472," "],[-1,19485,"\n"],[1,19487," "],[-1,19548,"\n"],[1,19550," "],[-1,19574,"\n"],[1,19576," "],[-1,19606,"\n"],[1,19635," "],[-1,19657,"\n"],[1,19659," "],[-1,19668,"\n"],[1,19671," "],[-1,19691,"\n"],[1,19693," "],[1,19696," "],[1,19697,"<"],[-1,19699,"< "],[1,19713," \""],[-1,19713,"\" <"],[1,19718,"<"],[1,19722,"\n"],[-1,19722,";"],[1,19735,"1(\n\n{\t "],[-1,19735,"n()\n{\n\t"],[-1,19752,"\n"],[1,19755," "],[1,19770,"\n"],[-1,19770,";"],[-1,19774,"\n"],[1,19801,"\n"],[-1,19801,""]],[19802,19802],[12361,12361]]],[1542982708849,["gjx16@GJXAIOU",[[1,15133,"使用实参去初始化形参，调用形参的copy构造函数去"]],[15133,15133],[15158,15158]]],[1542982714489,["gjx16@GJXAIOU",[[-1,15157,"去"]],[15158,15158],[15157,15157]]]],null,"gjx16@GJXAIOU"],["f9089609-6f21-4922-ad71-3097c9527f8a",1543020425960,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁\n   * c++面向对象模型初探  \n   * c++面向对象多态原理探究\n   * 操作符重载\n\n- C++基础课程学习完毕以后，有没有一个标准，来判断自己有没有入门。\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”，\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n\t\n};\n\n```\nTeacher.cpp\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1 设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n## (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n### (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++默认浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n**3.5****多个对象构造和析构**\n\n**1****对象初始化列表**\n\n1）对象初始化列表出现原因\n\n1.必须这样做：\n\n如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n\n如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n\n当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n\n因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n\n{\n\n // some other assignment operation\n\n}\n\n3）注意概念\n\n初始化：被初始化的对象正在创建\n\n赋值：被赋值的对象已经存在\n\n4）注意：\n\n成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n\n初始化列表先于构造函数的函数体执行\n\n| \n\n/*\n\n1 C++中提供了初始化列表对成员变量进行初始化\n\n2 使用初始化列表出现原因：\n\n1.必须这样做：\n\n如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n\n而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n\n如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n\n当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n\n因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n*/\n\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\n\nusing namespace std;\n\nclass ABC\n\n{\n\npublic:\n\n ABC(int a, int b, int c)\n\n {\n\n this->a = a;\n\n this->b = b;\n\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n\n printf(\"ABC construct ..\\n\");\n\n }\n\n ~ABC()\n\n {\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n\n printf(\"~ABC() ..\\n\");\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n int b;\n\n int c;\n\n};\n\nclass MyD\n\n{\n\npublic:\n\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n\n {\n\n cout<<\"MyD()\"<<endl;\n\n }\n\n ~MyD()\n\n {\n\n cout<<\"~MyD()\"<<endl;\n\n }\n\nprotected:\n\nprivate:\n\n ABC abc1; //c++编译器不知道如何构造abc1\n\n ABC abc2;\n\n const int m;\n\n};\n\nint run()\n\n{\n\n MyD myD;\n\n return 0;\n\n}\n\nint main_dem03()\n\n{\n\n run();\n\n system(\"pause\");\n\n return 0;\n\n}\n\n |\n\n**3.6****构造函数和析构函数的调用顺序研究**\n\n**构造函数与析构函数的调用顺序**\n\n1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n**3.7****构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1****构造析综合训练**\n\ndemo10_构造析构练习强化.cpp （讲解）\n\n  展示分析过程，注意赋值构函数的调用\n\n**2****匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3****匿名对象强化训练**\n\n3） 构造中调用构造\n\ndemo11_匿名对象练习强化.cpp\n\n  构造函数中调用构造函数，是一个蹩脚的行为。\n\n**3.8** **对象的动态建立和释放**\n\n**1 new****和****delete****基本语法**\n\n1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n注意： new和delete是运算符，不是函数，因此执行效率高。\n\n2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： new int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 new char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址 new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n 3）new和delete运算符使用的一般格式为：\n\n用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n\n4） 应用举例\n\n**2** **类对象的动态建立和释放**\n\n使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n比如：\n\nBox *pt;  //定义一个指向Box类对象的指针变量pt\n    pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n  在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3** **编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n",[[1543020393767,["gjx16@GJXAIOU",[[1,18695,"默认copygouza"]],[18695,18695],[18706,18706]]],[1543020397153,["gjx16@GJXAIOU",[[-1,18701,"gouza"]],[18706,18706],[18701,18701]]],[1543020402250,["gjx16@GJXAIOU",[[1,18701,"构造哈数"]],[18701,18701],[18705,18705]]],[1543020404779,["gjx16@GJXAIOU",[[-1,18703,"哈数"]],[18705,18705],[18703,18703]]],[1543020408863,["gjx16@GJXAIOU",[[1,18703,"函数是"]],[18703,18703],[18706,18706]]],[1543020415315,["gjx16@GJXAIOU",[[-1,18694,"认默"]],[18695,18695],[18693,18693]]],[1543020416360,["gjx16@GJXAIOU",[[1,18693,"的"]],[18693,18693],[18694,18694]]],[1543020497519,["gjx16@GJXAIOU",[[1,19836,"\n"]],[19835,19835],[19836,19836]]],[1543020497813,["gjx16@GJXAIOU",[[1,19837,"\n"]],[19836,19836],[19837,19837]]],[1543020498953,["gjx16@GJXAIOU",[[1,19837,"---"]],[19837,19837],[19840,19840]]],[1543020537100,["gjx16@GJXAIOU",[[-1,19841,"**3.5****"]],[19843,19850],[19841,19841]]],[1543020543560,["gjx16@GJXAIOU",[[1,19841,"###"]],[19841,19841],[19844,19844]]],[1543020546669,["gjx16@GJXAIOU",[[1,19844," "]],[19844,19844],[19845,19845]]],[1543020549622,["gjx16@GJXAIOU",[[-1,19854,"**"]],[19856,19856],[19854,19854]]],[1543020553607,["gjx16@GJXAIOU",[[1,19845,"（）"]],[19845,19845],[19847,19847]]],[1543020556607,["gjx16@GJXAIOU",[[1,19846,"五"]],[19846,19846],[19847,19847]]],[1543020559705,["gjx16@GJXAIOU",[[1,19841,"\n"]],[19840,19840],[19841,19841]]],[1543020563929,["gjx16@GJXAIOU",[[1,19841,"@toc"]],[19841,19841],[19845,19845]]],[1543020586576,["gjx16@GJXAIOU",[[1,17038," "]],[17038,17038],[17039,17039]]],[1543020599445,["gjx16@GJXAIOU",[[1,12357,"#"]],[12357,12357],[12358,12358]]],[1543020600430,["gjx16@GJXAIOU",[[1,12359," "]],[12358,12358],[12359,12359]]],[1543020603413,["gjx16@GJXAIOU",[[1,12375,"\n"]],[12373,12373],[12374,12374]]],[1543020604555,["gjx16@GJXAIOU",[[1,12374,"@"]],[12374,12374],[12375,12375]]],[1543020605471,["gjx16@GJXAIOU",[[1,12375,"r"]],[12375,12375],[12376,12376]]],[1543020605966,["gjx16@GJXAIOU",[[-1,12375,"r"]],[12376,12376],[12375,12375]]],[1543020606783,["gjx16@GJXAIOU",[[1,12375,"toc"]],[12375,12375],[12378,12378]]],[1543020615084,["gjx16@GJXAIOU",[[-1,12374,"@toc\n"]],[12374,12379],[12374,12374]]],[1543020647162,["gjx16@GJXAIOU",[[-1,19870,"****"]],[19874,19874],[19870,19870]]],[1543020648942,["gjx16@GJXAIOU",[[1,19870,"。"]],[19870,19870],[19871,19871]]],[1543020650215,["gjx16@GJXAIOU",[[-1,19870,"。"]],[19871,19871],[19870,19870]]],[1543020650631,["gjx16@GJXAIOU",[[1,19870,"."]],[19870,19870],[19871,19871]]],[1543020658685,["gjx16@GJXAIOU",[[1,19882,"- "]],[19882,19882],[19884,19884]]],[1543020664034,["gjx16@GJXAIOU",[[1,19899,"  - "]],[19899,19899],[19903,19903]]],[1543020668436,["gjx16@GJXAIOU",[[1,19913,"  - "]],[19913,19913],[19917,19917]]],[1543020670733,["gjx16@GJXAIOU",[[-1,19912,"\n"]],[19912,19912],[19911,19911]]],[1543020673038,["gjx16@GJXAIOU",[[1,19914,"  "]],[19914,19914],[19916,19916]]],[1543020677699,["gjx16@GJXAIOU",[[-1,20009,"\n"]],[20010,20010],[20009,20009]]],[1543020680240,["gjx16@GJXAIOU",[[1,20009,"    - "]],[20009,20009],[20015,20015]]],[1543020688803,["gjx16@GJXAIOU",[[1,20044,"  - "]],[20044,20044],[20048,20048]]],[1543020692161,["gjx16@GJXAIOU",[[1,20093,"    ="]],[20093,20093],[20098,20098]]],[1543020692766,["gjx16@GJXAIOU",[[-1,20097,"="]],[20098,20098],[20097,20097]]],[1543020693316,["gjx16@GJXAIOU",[[1,20097,"- "]],[20097,20097],[20099,20099]]],[1543020696898,["gjx16@GJXAIOU",[[1,20149,"    -- "]],[20149,20149],[20156,20156]]],[1543020699270,["gjx16@GJXAIOU",[[-1,20154,"- "]],[20156,20156],[20154,20154]]],[1543020699939,["gjx16@GJXAIOU",[[1,20154," "]],[20154,20154],[20155,20155]]],[1543020702131,["gjx16@GJXAIOU",[[-1,20092,"\n"]],[20092,20092],[20091,20091]]],[1543020703155,["gjx16@GJXAIOU",[[-1,20147,"\n"]],[20147,20147],[20146,20146]]],[1543020710946,["gjx16@GJXAIOU",[[1,20200,"- "]],[20200,20200],[20202,20202]]],[1543020718224,["gjx16@GJXAIOU",[[1,20232,"···"]],[20232,20232],[20235,20235]]],[1543020720908,["gjx16@GJXAIOU",[[-1,20232,"···"]],[20235,20235],[20232,20232]]],[1543020722680,["gjx16@GJXAIOU",[[1,20232,"```"]],[20232,20232],[20235,20235]]],[1543020722918,["gjx16@GJXAIOU",[[1,20235,"language\n```\n"]],[20235,20235],[20235,20243]]],[1543020724588,["gjx16@GJXAIOU",[[-1,20235,"language"],[1,20243,"c"]],[20235,20243],[20236,20236]]],[1543020725187,["gjx16@GJXAIOU",[[1,20236,"pp"]],[20236,20236],[20238,20238]]],[1543020726058,["gjx16@GJXAIOU",[[1,20239,"\n"]],[20238,20238],[20239,20239]]],[1543020729874,["gjx16@GJXAIOU",[[-1,20245,"Constructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n\n{\n\n // some other assignment operation\n\n}"]],[20245,20341],[20245,20245]]],[1543020731751,["gjx16@GJXAIOU",[[1,20239,"Constructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n\n{\n\n // some other assignment operation\n\n}"]],[20239,20239],[20335,20335]]],[1543020733718,["gjx16@GJXAIOU",[[-1,20342,"\n"]],[20342,20342],[20341,20341]]],[1543020734830,["gjx16@GJXAIOU",[[-1,20293,"\n"]],[20293,20293],[20292,20292]]],[1543020735659,["gjx16@GJXAIOU",[[-1,20295,"\n"]],[20295,20295],[20294,20294]]],[1543020736607,["gjx16@GJXAIOU",[[-1,20331,"\n"]],[20331,20331],[20330,20330]]],[1543020740192,["gjx16@GJXAIOU",[[1,20339,"- "]],[20339,20339],[20341,20341]]],[1543020743002,["gjx16@GJXAIOU",[[1,20381,"- "]],[20381,20381],[20383,20383]]],[1543020747713,["gjx16@GJXAIOU",[[1,20349,"  "]],[20349,20349],[20351,20351]]],[1543020748505,["gjx16@GJXAIOU",[[1,20368,"  "]],[20368,20368],[20370,20370]]],[1543020750331,["gjx16@GJXAIOU",[[-1,20367,"\n"]],[20367,20367],[20366,20366]]],[1543020753748,["gjx16@GJXAIOU",[[-1,20348,"\n"]],[20348,20348],[20347,20347]]],[1543020756278,["gjx16@GJXAIOU",[[-1,20391,"\n"]],[20391,20391],[20390,20390]]],[1543020757622,["gjx16@GJXAIOU",[[-1,20424,"\n"]],[20424,20424],[20423,20423]]],[1543020760687,["gjx16@GJXAIOU",[[1,20391,"- "],[1,20424,"- "]],[20391,20441],[20393,20445]]],[1543020761892,["gjx16@GJXAIOU",[[1,20391,"  "],[1,20426,"  "]],[20393,20445],[20395,20449]]],[1543020765622,["gjx16@GJXAIOU",[[-1,20348," "],[1,20349,"-"],[-1,20366," "],[1,20367,"-"]],[20348,20381],[20348,20381]]],[1543020766101,["gjx16@GJXAIOU",[[1,20348,"  "],[1,20366,"  "]],[20348,20381],[20348,20385]]],[1543020793124,["gjx16@GJXAIOU",[[-1,20455,"| \n\n/*"]],[20455,20461],[20455,20455]]],[1543020794179,["gjx16@GJXAIOU",[[-1,20456,"\n"]],[20455,20455],[20454,20454]]],[1543020797266,["gjx16@GJXAIOU",[[1,20454,"****"]],[20454,20454],[20456,20456]]],[1543020799989,["gjx16@GJXAIOU",[[1,20456,"zhuyidia"]],[20456,20456],[20464,20464]]],[1543020803934,["gjx16@GJXAIOU",[[-1,20456,"zhuyidia"]],[20464,20464],[20456,20456]]],[1543020806973,["gjx16@GJXAIOU",[[1,20456,"说明："]],[20456,20456],[20459,20459]]],[1543020810661,["gjx16@GJXAIOU",[[1,20454,"\n"]],[20454,20454],[20455,20455]]],[1543020815908,["gjx16@GJXAIOU",[[-1,20489,"\n"]],[20489,20489],[20488,20488]]],[1543020816255,["gjx16@GJXAIOU",[[-1,20487,"化"]],[20488,20488],[20487,20487]]],[1543020818916,["gjx16@GJXAIOU",[[1,20487,"化"]],[20487,20487],[20488,20488]]],[1543020820756,["gjx16@GJXAIOU",[[-1,20504,"\n"]],[20504,20504],[20503,20503]]],[1543020821676,["gjx16@GJXAIOU",[[-1,20513,"\n"]],[20513,20513],[20512,20512]]],[1543020822460,["gjx16@GJXAIOU",[[-1,20560,"\n"]],[20560,20560],[20559,20559]]],[1543020823364,["gjx16@GJXAIOU",[[-1,20606,"\n"]],[20606,20606],[20605,20605]]],[1543020824230,["gjx16@GJXAIOU",[[-1,20634,"\n"]],[20634,20634],[20633,20633]]],[1543020825147,["gjx16@GJXAIOU",[[-1,20678,"\n"]],[20678,20678],[20677,20677]]],[1543020826077,["gjx16@GJXAIOU",[[-1,20727,"\n"]],[20727,20727],[20726,20726]]],[1543020831725,["gjx16@GJXAIOU",[[1,20464,"* "],[1,20489,"* "],[1,20504,"* "],[1,20513,"* "],[1,20560,"* "],[1,20606,"* "],[1,20634,"* "],[1,20678,"* "],[1,20727,"* "]],[20464,20772],[20466,20790]]],[1543020845421,["gjx16@GJXAIOU",[[1,20508,"  "],[1,20519,"  "],[1,20568,"  "]],[20510,20615],[20512,20621]]],[1543020849372,["gjx16@GJXAIOU",[[1,20523,"  "],[1,20572,"  "]],[20525,20621],[20527,20625]]],[1543020855234,["gjx16@GJXAIOU",[[1,20626,"    "]],[20626,20655],[20630,20630]]],[1543020861463,["gjx16@GJXAIOU",[[1,20660,"  "]],[20660,20705],[20662,20662]]],[1543020864364,["gjx16@GJXAIOU",[[1,20708,"  "],[1,20759,"  "]],[20708,20806],[20708,20810]]],[1543020864764,["gjx16@GJXAIOU",[[1,20710,"  "],[1,20761,"  "]],[20708,20810],[20708,20814]]],[1543020869295,["gjx16@GJXAIOU",[[-1,20816,"*/\n"]],[20815,20818],[20815,20815]]],[1543020873751,["gjx16@GJXAIOU",[[1,20816,"·"]],[20816,20816],[20817,20817]]],[1543020875003,["gjx16@GJXAIOU",[[-1,20816,"·"]],[20817,20817],[20816,20816]]],[1543020876629,["gjx16@GJXAIOU",[[1,20816,"```"]],[20816,20816],[20819,20819]]],[1543020876695,["gjx16@GJXAIOU",[[1,20819,"language\n```\n"]],[20819,20819],[20819,20827]]],[1543020877894,["gjx16@GJXAIOU",[[-1,20819,"language"],[1,20827,"c"]],[20819,20827],[20820,20820]]],[1543020878404,["gjx16@GJXAIOU",[[1,20820,"pp"]],[20820,20820],[20822,20822]]],[1543020879047,["gjx16@GJXAIOU",[[1,20823,"\n"]],[20822,20822],[20823,20823]]],[1543020896262,["gjx16@GJXAIOU",[[-1,20829,"//总结 构造和析构的调用顺序\n\n#include \"iostream\"\n\nusing namespace std;\n\nclass ABC\n\n{\n\npublic:\n\n ABC(int a, int b, int c)\n\n {\n\n this->a = a;\n\n this->b = b;\n\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n\n printf(\"ABC construct ..\\n\");\n\n }\n\n ~ABC()\n\n {\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n\n printf(\"~ABC() ..\\n\");\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n int b;\n\n int c;\n\n};\n\nclass MyD\n\n{\n\npublic:\n\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n\n {\n\n cout<<\"MyD()\"<<endl;\n\n }\n\n ~MyD()\n\n {\n\n cout<<\"~MyD()\"<<endl;\n\n }\n\nprotected:\n\nprivate:\n\n ABC abc1; //c++编译器不知道如何构造abc1\n\n ABC abc2;\n\n const int m;\n\n};\n\nint run()\n\n{\n\n MyD myD;\n\n return 0;\n\n}\n\nint main_dem03()\n\n{\n\n run();\n\n system(\"pause\");\n\n return 0;\n\n}\n"]],[20829,21531],[20829,20829]]],[1543020899267,["gjx16@GJXAIOU",[[1,20823,"//总结 构造和析构的调用顺序\n\n#include \"iostream\"\n\nusing namespace std;\n\nclass ABC\n\n{\n\npublic:\n\n ABC(int a, int b, int c)\n\n {\n\n this->a = a;\n\n this->b = b;\n\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n\n printf(\"ABC construct ..\\n\");\n\n }\n\n ~ABC()\n\n {\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n\n printf(\"~ABC() ..\\n\");\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n int b;\n\n int c;\n\n};\n\nclass MyD\n\n{\n\npublic:\n\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n\n {\n\n cout<<\"MyD()\"<<endl;\n\n }\n\n ~MyD()\n\n {\n\n cout<<\"~MyD()\"<<endl;\n\n }\n\nprotected:\n\nprivate:\n\n ABC abc1; //c++编译器不知道如何构造abc1\n\n ABC abc2;\n\n const int m;\n\n};\n\nint run()\n\n{\n\n MyD myD;\n\n return 0;\n\n}\n\nint main_dem03()\n\n{\n\n run();\n\n system(\"pause\");\n\n return 0;\n\n}\n"]],[20823,20823],[21525,21525]]],[1543020901862,["gjx16@GJXAIOU",[[-1,20860,"\n"]],[20860,20860],[20859,20859]]],[1543020902795,["gjx16@GJXAIOU",[[-1,20881,"\n"]],[20881,20881],[20880,20880]]],[1543020904357,["gjx16@GJXAIOU",[[-1,20891,"\n"]],[20891,20891],[20890,20890]]],[1543020905293,["gjx16@GJXAIOU",[[-1,20893,"\n"]],[20893,20893],[20892,20892]]],[1543020906484,["gjx16@GJXAIOU",[[-1,20901,"\n"]],[20901,20901],[20900,20900]]],[1543020907471,["gjx16@GJXAIOU",[[-1,20927,"\n"]],[20927,20927],[20926,20926]]],[1543020913591,["gjx16@GJXAIOU",[[-1,20902,"ABC(int a, int b, int c)"]],[20926,20926],[20902,20902]]]],null,"gjx16@GJXAIOU"],["c8966b27-25db-48f6-ac1d-e52379da0db2",1543020985817,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁\n   * c++面向对象模型初探  \n   * c++面向对象多态原理探究\n   * 操作符重载\n\n- C++基础课程学习完毕以后，有没有一个标准，来判断自己有没有入门。\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”，\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n\t\n};\n\n```\nTeacher.cpp\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1 设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n###  (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n###  (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++的默认copy构造函数是浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n\n---\n@toc\n### （五）多个对象构造和析构\n\n**1.对象初始化列表**\n\n- 1）对象初始化列表出现原因\n\n  - 1.必须这样做：\n    - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    - 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n  - 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    - 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    - 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n- 2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n```cpp\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n{\n // some other assignment operation\n}\n```\n\n\n- 3）注意概念\n  - 初始化：被初始化的对象正在创建\n  - 赋值：被赋值的对象已经存在\n\n- 4）注意：\n  - 成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n  - 初始化列表先于构造函数的函数体执行\n\n**说明：**\n\n* 1 C++中提供了初始化列表对成员变量进行初始化\n* 2 使用初始化列表出现原因：\n  * 1.必须这样做：\n    * 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n    * 而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    * 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n  * 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    * 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    * 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n```cpp\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\nusing namespace std;\nclass ABC\n{\npublic:\n \n {\n\n this->a = a;\n\n this->b = b;\n\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n\n printf(\"ABC construct ..\\n\");\n\n }\n\n ~ABC()\n\n {\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n\n printf(\"~ABC() ..\\n\");\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n int b;\n\n int c;\n\n};\n\nclass MyD\n\n{\n\npublic:\n\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n\n {\n\n cout<<\"MyD()\"<<endl;\n\n }\n\n ~MyD()\n\n {\n\n cout<<\"~MyD()\"<<endl;\n\n }\n\nprotected:\n\nprivate:\n\n ABC abc1; //c++编译器不知道如何构造abc1\n\n ABC abc2;\n\n const int m;\n\n};\n\nint run()\n\n{\n\n MyD myD;\n\n return 0;\n\n}\n\nint main_dem03()\n\n{\n\n run();\n\n system(\"pause\");\n\n return 0;\n\n}\n\n```\n\n\n |\n\n**3.6****构造函数和析构函数的调用顺序研究**\n\n**构造函数与析构函数的调用顺序**\n\n1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n**3.7****构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1****构造析综合训练**\n\ndemo10_构造析构练习强化.cpp （讲解）\n\n  展示分析过程，注意赋值构函数的调用\n\n**2****匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3****匿名对象强化训练**\n\n3） 构造中调用构造\n\ndemo11_匿名对象练习强化.cpp\n\n  构造函数中调用构造函数，是一个蹩脚的行为。\n\n**3.8** **对象的动态建立和释放**\n\n**1 new****和****delete****基本语法**\n\n1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n注意： new和delete是运算符，不是函数，因此执行效率高。\n\n2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： new int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 new char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址 new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n 3）new和delete运算符使用的一般格式为：\n\n用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n\n4） 应用举例\n\n**2** **类对象的动态建立和释放**\n\n使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n比如：\n\nBox *pt;  //定义一个指向Box类对象的指针变量pt\n    pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n  在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3** **编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n",[[1543020953421,["gjx16@GJXAIOU",[[1,20860,"\n"],[1,20881,"\n"],[1,20891,"\n"],[1,20892,"\n"],[1,20901,"\n"],[1,20902,"ABC(int a, int b, int c)\n"]],[20823,21494],[21524,21524]]],[1543020959180,["gjx16@GJXAIOU",[[-1,20860,"\n"]],[20860,20860],[20859,20859]]],[1543020961347,["gjx16@GJXAIOU",[[-1,20892,"\n"]],[20892,20892],[20891,20891]]],[1543020962843,["gjx16@GJXAIOU",[[-1,20894,"\n"]],[20894,20894],[20893,20893]]],[1543020963845,["gjx16@GJXAIOU",[[-1,20902,"\n"]],[20902,20902],[20901,20901]]],[1543020964920,["gjx16@GJXAIOU",[[-1,20928,"\n"]],[20928,20928],[20927,20927]]],[1543020966148,["gjx16@GJXAIOU",[[-1,20931,"\n"]],[20931,20931],[20930,20930]]],[1543020967596,["gjx16@GJXAIOU",[[-1,20945,"\n"]],[20945,20945],[20944,20944]]],[1543020968582,["gjx16@GJXAIOU",[[-1,20959,"\n"]],[20959,20959],[20958,20958]]],[1543020970099,["gjx16@GJXAIOU",[[-1,21013,"\n"]],[21013,21013],[21012,21012]]],[1543020971123,["gjx16@GJXAIOU",[[-1,21044,"\n"]],[21044,21044],[21043,21043]]],[1543020974051,["gjx16@GJXAIOU",[[-1,21056,"\n"]],[21056,21056],[21055,21055]]],[1543020975595,["gjx16@GJXAIOU",[[-1,21059,"\n"]],[21059,21059],[21058,21058]]],[1543020976444,["gjx16@GJXAIOU",[[-1,21098,"\n"]],[21098,21098],[21097,21097]]],[1543020977299,["gjx16@GJXAIOU",[[-1,21122,"\n"]],[21122,21122],[21121,21121]]],[1543020979788,["gjx16@GJXAIOU",[[-1,21137,"\n"]],[21137,21137],[21136,21136]]],[1543020980661,["gjx16@GJXAIOU",[[-1,21146,"\n"]],[21146,21146],[21145,21145]]],[1543020981596,["gjx16@GJXAIOU",[[-1,21154,"\n"]],[21154,21154],[21153,21153]]],[1543020982421,["gjx16@GJXAIOU",[[-1,21162,"\n"]],[21162,21162],[21161,21161]]],[1543020984285,["gjx16@GJXAIOU",[[-1,21170,"\n"]],[21170,21170],[21169,21169]]],[1543020988164,["gjx16@GJXAIOU",[[-1,21184,"\n"]],[21184,21184],[21183,21183]]],[1543020988981,["gjx16@GJXAIOU",[[-1,21186,"\n"]],[21186,21186],[21185,21185]]],[1543020989980,["gjx16@GJXAIOU",[[-1,21194,"\n"]],[21194,21194],[21193,21193]]],[1543020991083,["gjx16@GJXAIOU",[[-1,21242,"\n"]],[21242,21242],[21241,21241]]],[1543020992316,["gjx16@GJXAIOU",[[-1,21245,"\n"]],[21245,21245],[21244,21244]]],[1543020993029,["gjx16@GJXAIOU",[[-1,21268," "]],[21269,21269],[21268,21268]]],[1543020993527,["gjx16@GJXAIOU",[[-1,21267,"\n"]],[21267,21267],[21266,21266]]],[1543020995008,["gjx16@GJXAIOU",[[1,21267," "]],[21267,21267],[21268,21268]]],[1543020997188,["gjx16@GJXAIOU",[[-1,21279,"\n"]],[21279,21279],[21278,21278]]],[1543020999252,["gjx16@GJXAIOU",[[-1,21282,"\n"]],[21282,21282],[21281,21281]]],[1543021000397,["gjx16@GJXAIOU",[[-1,21305,"\n"]],[21305,21305],[21304,21304]]],[1543021001510,["gjx16@GJXAIOU",[[-1,21320,"\n"]],[21320,21320],[21319,21319]]],[1543021002436,["gjx16@GJXAIOU",[[-1,21329,"\n"]],[21329,21329],[21328,21328]]],[1543021003278,["gjx16@GJXAIOU",[[-1,21360,"\n"]],[21360,21360],[21359,21359]]],[1543021004108,["gjx16@GJXAIOU",[[-1,21371,"\n"]],[21371,21371],[21370,21370]]],[1543021005171,["gjx16@GJXAIOU",[[-1,21385,"\n"]],[21385,21385],[21384,21384]]],[1543021006821,["gjx16@GJXAIOU",[[-1,21399,"\n"]],[21399,21399],[21398,21398]]],[1543021008220,["gjx16@GJXAIOU",[[-1,21401,"\n"]],[21401,21401],[21400,21400]]],[1543021009512,["gjx16@GJXAIOU",[[-1,21423,"\n"]],[21423,21423],[21422,21422]]],[1543021010236,["gjx16@GJXAIOU",[[-1,21411,"\n"]],[21411,21411],[21410,21410]]],[1543021011724,["gjx16@GJXAIOU",[[-1,21442,"\n"]],[21442,21442],[21441,21441]]],[1543021012691,["gjx16@GJXAIOU",[[-1,21444,"\n"]],[21444,21444],[21443,21443]]],[1543021014064,["gjx16@GJXAIOU",[[-1,21483,"\n"]],[21483,21483],[21482,21482]]],[1543021014987,["gjx16@GJXAIOU",[[-1,21471,"\n"]],[21471,21471],[21470,21470]]],[1543021015679,["gjx16@GJXAIOU",[[-1,21452,"\n"]],[21452,21452],[21451,21451]]],[1543021018263,["gjx16@GJXAIOU",[[-1,21490," |"]],[21490,21492],[21490,21490]]],[1543021027550,["gjx16@GJXAIOU",[[-1,21492,"**3.6****"],[1,21501,"#"]],[21492,21492],[21493,21493]]],[1543021030163,["gjx16@GJXAIOU",[[1,21493,"## （）"]],[21493,21493],[21498,21498]]],[1543021032780,["gjx16@GJXAIOU",[[1,21497,"六"]],[21497,21497],[21498,21498]]],[1543021036516,["gjx16@GJXAIOU",[[-1,21515,"**"]],[21515,21517],[21515,21515]]],[1543021043293,["gjx16@GJXAIOU",[[1,21537,"- "]],[21537,21537],[21539,21539]]],[1543021045236,["gjx16@GJXAIOU",[[1,21598,"- "]],[21598,21598],[21600,21600]]],[1543021050935,["gjx16@GJXAIOU",[[-1,21627,"**3.7****"],[1,21636,"#"]],[21627,21627],[21628,21628]]],[1543021053364,["gjx16@GJXAIOU",[[1,21628,"## （）"]],[21628,21628],[21633,21633]]],[1543021057512,["gjx16@GJXAIOU",[[1,21632,"七"]],[21632,21632],[21633,21633]]],[1543021068654,["gjx16@GJXAIOU",[[-1,21671,"****"]],[21671,21675],[21671,21671]]],[1543021071380,["gjx16@GJXAIOU",[[-1,21732,"****"]],[21732,21736],[21732,21732]]],[1543021075031,["gjx16@GJXAIOU",[[-1,21795,"****"]],[21795,21799],[21795,21795]]],[1543021079030,["gjx16@GJXAIOU",[[-1,21870,"** **"]],[21870,21875],[21870,21870]]],[1543021393509,["gjx16@GJXAIOU",[[1,18439,"，也是一种浅拷贝"]],[18439,18439],[18447,18447]]],[1543021434412,["gjx16@GJXAIOU",[[1,18410,"需要"]],[18410,18410],[18412,18412]]],[1543021450812,["gjx16@GJXAIOU",[[1,18419,"，才能解决带来的浅拷贝问题"]],[18419,18419],[18432,18432]]],[1543021639085,["gjx16@GJXAIOU",[[-1,19867,"@toc"]],[19867,19871],[19867,19867]]],[1543021640632,["gjx16@GJXAIOU",[[1,19868,"\n"]],[19867,19867],[19868,19868]]],[1543022520761,["gjx16@GJXAIOU",[[1,19918,"```cpp"]],[19918,19918],[19924,19924]]],[1543022521473,["gjx16@GJXAIOU",[[1,19925,"\n"]],[19924,19924],[19925,19925]]],[1543022522462,["gjx16@GJXAIOU",[[1,19926,"\n"]],[19925,19925],[19926,19926]]],[1543022522834,["gjx16@GJXAIOU",[[1,19927,"\n"]],[19926,19926],[19927,19927]]],[1543022524016,["gjx16@GJXAIOU",[[1,19927,"```"]],[19927,19927],[19930,19930]]],[1543022526251,["gjx16@GJXAIOU",[[1,19926,"/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B   //在一个类里面组合了一个带有参数的构造函数的类，因为C++编译器要确定分配给B多大的内存，但是没法初始化A定义的两个对象（因为需要调用有参的构造函数）\n{\npublic:   //没有写B的构造函数，按理说应该调用默认的构造函数\n\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  //主要是因为没有方法和没有机会去初始化这两个A定义的对象\n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB;\n\treturn 0;\n\n}\n"]],[19925,19925],[20334,20334]]],[1543022535789,["gjx16@GJXAIOU",[[1,19918,"- \n"]],[19917,19917],[19920,19920]]],[1543022537571,["gjx16@GJXAIOU",[[-1,19918,"- "]],[19920,19920],[19918,19918]]],[1543022540795,["gjx16@GJXAIOU",[[1,19918,"chengxu"]],[19918,19918],[19925,19925]]],[1543022544328,["gjx16@GJXAIOU",[[-1,19918,"chengxu"]],[19925,19925],[19918,19918]]],[1543022549983,["gjx16@GJXAIOU",[[1,19918,"程序本身石油焦"]],[19918,19918],[19925,19925]]],[1543022551950,["gjx16@GJXAIOU",[[-1,19922,"石油焦"]],[19925,19925],[19922,19922]]],[1543022557766,["gjx16@GJXAIOU",[[1,19922,"是有问题的"]],[19922,19922],[19927,19927]]],[1543022563472,["gjx16@GJXAIOU",[[1,20350,"\n"]],[20349,20349],[20350,20350]]],[1543022564478,["gjx16@GJXAIOU",[[1,20351,"\n"]],[20350,20350],[20351,20351]]],[1543022568960,["gjx16@GJXAIOU",[[1,20351,"解决放啊发："]],[20351,20351],[20357,20357]]],[1543022572555,["gjx16@GJXAIOU",[[-1,20353,"放啊发："]],[20357,20357],[20353,20353]]],[1543022574494,["gjx16@GJXAIOU",[[1,20353,"方法："]],[20353,20353],[20356,20356]]],[1543022576054,["gjx16@GJXAIOU",[[1,20357,"\n"]],[20356,20356],[20357,20357]]],[1543022581050,["gjx16@GJXAIOU",[[1,20357,"```cpp"]],[20357,20357],[20363,20363]]],[1543022581387,["gjx16@GJXAIOU",[[1,20364,"\n"]],[20363,20363],[20364,20364]]],[1543022582036,["gjx16@GJXAIOU",[[1,20365,"\n"]],[20364,20364],[20365,20365]]],[1543022582339,["gjx16@GJXAIOU",[[1,20366,"\n"]],[20365,20365],[20366,20366]]],[1543022583713,["gjx16@GJXAIOU",[[1,20366,"```"]],[20366,20366],[20369,20369]]],[1543022860655,["gjx16@GJXAIOU",[[1,20364,"/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n};\n\n\nclass B  \n{\npublic:   \n\tB(int _a, int _b) : a1(1), a2(3)  //含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）\n\t{\n\n\t}\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  \n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB(1,2);\n\treturn 0;\n\n}"]],[20364,20364],[20747,20747]]],[1543022864099,["gjx16@GJXAIOU",[[-1,20367,"\n"]],[20367,20367],[20366,20366]]],[1543022883950,["gjx16@GJXAIOU",[[-1,20561,"//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）"]],[20561,20629],[20561,20561]]],[1543022885974,["gjx16@GJXAIOU",[[1,20526,"\n"]],[20525,20525],[20526,20526]]],[1543022887501,["gjx16@GJXAIOU",[[1,20526,"//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）"]],[20526,20526],[20594,20594]]],[1543022896086,["gjx16@GJXAIOU",[[1,20753,"\n"]],[20752,20752],[20753,20753]]],[1543023150640,["gjx16@GJXAIOU",[[1,20638,"\t\n"]],[20637,20637],[20639,20639]]],[1543023153287,["gjx16@GJXAIOU",[[1,20639,"//di"]],[20639,20639],[20643,20643]]],[1543023154506,["gjx16@GJXAIOU",[[-1,20641,"di"]],[20643,20643],[20641,20641]]],[1543023165166,["gjx16@GJXAIOU",[[1,20641,"第二种参数传递的方法："]],[20641,20641],[20652,20652]]],[1543023166264,["gjx16@GJXAIOU",[[1,20653,"\t\n"]],[20652,20652],[20654,20654]]],[1543023168131,["gjx16@GJXAIOU",[[1,20654,"、"]],[20654,20654],[20655,20655]]],[1543023168907,["gjx16@GJXAIOU",[[-1,20654,"、"]],[20655,20655],[20654,20654]]],[1543023169842,["gjx16@GJXAIOU",[[1,20654,"、。"]],[20654,20654],[20656,20656]]],[1543023171690,["gjx16@GJXAIOU",[[-1,20653,"\t、。"]],[20656,20656],[20653,20653]]],[1543023173161,["gjx16@GJXAIOU",[[1,20653,"、"]],[20653,20653],[20654,20654]]],[1543023173890,["gjx16@GJXAIOU",[[-1,20653,"、"]],[20654,20654],[20653,20653]]],[1543023174739,["gjx16@GJXAIOU",[[1,20653,"/."]],[20653,20653],[20655,20655]]],[1543023177621,["gjx16@GJXAIOU",[[-1,20654,"."]],[20655,20655],[20654,20654]]],[1543023180991,["gjx16@GJXAIOU",[[1,20654,"**/"]],[20654,20654],[20657,20657]]],[1543023186877,["gjx16@GJXAIOU",[[1,20655,"\n"]],[20655,20655],[20656,20656]]],[1543023187491,["gjx16@GJXAIOU",[[1,20656,"\n"]],[20656,20656],[20657,20657]]],[1543023189420,["gjx16@GJXAIOU",[[1,20656,"B(int _a, int _b) : a1(1), a2(3)  \n\t{\n\n\t}"]],[20656,20656],[20697,20697]]],[1543023193211,["gjx16@GJXAIOU",[[-1,20638,"\t"]],[20639,20639],[20638,20638]]],[1543023201602,["gjx16@GJXAIOU",[[1,20671,",int m,int n"]],[20671,20671],[20683,20683]]],[1543023205092,["gjx16@GJXAIOU",[[-1,20690,"1"]],[20691,20691],[20690,20690]]],[1543023208206,["gjx16@GJXAIOU",[[1,20690,"m"]],[20690,20690],[20691,20691]]],[1543023210818,["gjx16@GJXAIOU",[[-1,20697,"3"]],[20698,20698],[20697,20697]]],[1543023211216,["gjx16@GJXAIOU",[[1,20697,"n"]],[20697,20697],[20698,20698]]],[1543023219018,["gjx16@GJXAIOU",[[1,20705,"      a = _a;"]],[20705,20705],[20718,20718]]],[1543023219541,["gjx16@GJXAIOU",[[1,20719,"      \n"]],[20718,20718],[20725,20725]]],[1543023222876,["gjx16@GJXAIOU",[[1,20725,"b = _b;"]],[20725,20725],[20732,20732]]],[1543023227509,["gjx16@GJXAIOU",[[1,20736,"\t\n"]],[20735,20735],[20737,20737]]],[1543023234812,["gjx16@GJXAIOU",[[1,20838,"\n\t"]],[20836,20836],[20838,20838]]],[1543023248866,["gjx16@GJXAIOU",[[1,20838,"//第二种方式：B b"]],[20838,20838],[20849,20849]]],[1543023249378,["gjx16@GJXAIOU",[[-1,20848,"b"]],[20849,20849],[20848,20848]]],[1543023254331,["gjx16@GJXAIOU",[[1,20848,"objB()"]],[20848,20848],[20854,20854]]],[1543023258570,["gjx16@GJXAIOU",[[1,20853,"1,2.3/"]],[20853,20853],[20859,20859]]],[1543023259986,["gjx16@GJXAIOU",[[-1,20856,".3/"]],[20859,20859],[20856,20856]]],[1543023263616,["gjx16@GJXAIOU",[[1,20856,",4.3"]],[20856,20856],[20860,20860]]],[1543023264442,["gjx16@GJXAIOU",[[-1,20858,".3"]],[20860,20860],[20858,20858]]],[1543023266103,["gjx16@GJXAIOU",[[1,20858,",3"]],[20858,20858],[20860,20860]]],[1543023341943,["gjx16@GJXAIOU",[[1,20882,"\n"]],[20880,20880],[20881,20881]]],[1543023342203,["gjx16@GJXAIOU",[[1,20883,"\n"]],[20881,20881],[20882,20882]]],[1543023344968,["gjx16@GJXAIOU",[[1,20882,"****"]],[20882,20882],[20884,20884]]],[1543023347846,["gjx16@GJXAIOU",[[1,20884,"yishang"]],[20884,20884],[20891,20891]]],[1543023351218,["gjx16@GJXAIOU",[[-1,20884,"yishang"]],[20891,20891],[20884,20884]]],[1543023360953,["gjx16@GJXAIOU",[[1,20884,"以上程序的操作顺序："]],[20884,20884],[20894,20894]]],[1543023363144,["gjx16@GJXAIOU",[[1,20898,"\n"]],[20896,20896],[20897,20897]]],[1543023383740,["gjx16@GJXAIOU",[[1,20897,"首先执行被组合对象的构造函数（）"]],[20897,20897],[20913,20913]]],[1543023388899,["gjx16@GJXAIOU",[[1,20912,"a1,a2"]],[20912,20912],[20917,20917]]],[1543023406885,["gjx16@GJXAIOU",[[1,20918,"，如果有多个组合对象，则按照定一"]],[20918,20918],[20934,20934]]],[1543023408253,["gjx16@GJXAIOU",[[-1,20932,"定一"]],[20934,20934],[20932,20932]]],[1543023422601,["gjx16@GJXAIOU",[[1,20932,"定义的顺序，而不是按照初始化列表的顺序（）"]],[20932,20932],[20953,20953]]],[1543023424996,["gjx16@GJXAIOU",[[1,20952,"“"]],[20952,20952],[20953,20953]]],[1543023426299,["gjx16@GJXAIOU",[[-1,20952,"“"]],[20953,20953],[20952,20952]]],[1543023434149,["gjx16@GJXAIOU",[[1,20952,"：后面的顺序"]],[20952,20952],[20958,20958]]],[1543023436271,["gjx16@GJXAIOU",[[1,20959,"，"]],[20959,20959],[20960,20960]]],[1543023437859,["gjx16@GJXAIOU",[[-1,20959,"，"]],[20960,20960],[20959,20959]]],[1543023438719,["gjx16@GJXAIOU",[[1,20961,"\n"]],[20959,20959],[20960,20960]]],[1543023444687,["gjx16@GJXAIOU",[[1,20960,"析构函数"]],[20960,20960],[20964,20964]]],[1543023455370,["gjx16@GJXAIOU",[[1,20965,"和构造函数的调用熟悉怒"]],[20965,20965],[20976,20976]]],[1543023458411,["gjx16@GJXAIOU",[[-1,20973,"熟悉怒"]],[20976,20976],[20973,20973]]],[1543023461525,["gjx16@GJXAIOU",[[1,20973,"顺序想法"]],[20973,20973],[20977,20977]]],[1543023463159,["gjx16@GJXAIOU",[[-1,20975,"想法"]],[20977,20977],[20975,20975]]],[1543023465096,["gjx16@GJXAIOU",[[1,20975,"相反"]],[20975,20975],[20977,20977]]],[1543024165206,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"]],[20964,20964],[20978,20978]]],[1543024165206,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"]],[20978,20978],[20964,20964]]],[1543024143258,["gjx16@GJXAIOU",[[-1,22753,"析"]],[22754,22754],[22753,22753]]],[1543024147470,["gjx16@GJXAIOU",[[1,22753,"析构"]],[22753,22753],[22755,22755]]],[1543024225202,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"],[-1,22753,"析"],[1,22755,"综"]],[20964,20964],[22756,22756]]],[1543024225202,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"],[1,22754,"析"],[-1,22755,"综"]],[22756,22756],[20964,20964]]],[1543024181061,["gjx16@GJXAIOU",[[-1,22763,"demo10_构造析构练习强化.cpp （讲解）"]],[22763,22787],[22763,22763]]],[1543024184489,["gjx16@GJXAIOU",[[-1,22765,"  展示分析过程，注意赋值构函数的调用"]],[22765,22784],[22765,22765]]],[1543024185262,["gjx16@GJXAIOU",[[-1,22766,"\n"]],[22765,22765],[22764,22764]]],[1543024200890,["gjx16@GJXAIOU",[[-1,22765,"\n"]],[22764,22764],[22763,22763]]],[1543024201637,["gjx16@GJXAIOU",[[-1,22764,"\n"]],[22763,22763],[22762,22762]]],[1543024205005,["gjx16@GJXAIOU",[[1,22762,"```"]],[22762,22762],[22765,22765]]],[1543024205187,["gjx16@GJXAIOU",[[1,22765,"language\n```\n"]],[22765,22765],[22765,22773]]],[1543024205861,["gjx16@GJXAIOU",[[-1,22765,"language"],[1,22773,"c"]],[22765,22773],[22766,22766]]],[1543024206509,["gjx16@GJXAIOU",[[1,22766,"pp"]],[22766,22766],[22768,22768]]],[1543024206967,["gjx16@GJXAIOU",[[1,22769,"\n"]],[22768,22768],[22769,22769]]],[1543024207332,["gjx16@GJXAIOU",[[1,22770,"\n"]],[22769,22769],[22770,22770]]],[1543029145281,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"],[-1,22753,"析"],[1,22755,"综"],[-1,22760,"\n"],[-1,22775,"d\n"],[1,22777,"\n\n*"]],[20964,20964],[22780,22780]]],[1543029145281,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"],[1,22754,"析"],[-1,22755,"综"],[1,22761,"\n"],[1,22775,"d\n"],[-1,22775,"\n\n*"]],[22780,22780],[20964,20964]]],[1543029137198,["gjx16@GJXAIOU",[[-1,21903,"//"],[1,21905,"\n/*\n\n"],[1,21918,"\n\n*/"],[-1,21982," "],[1,21983,"\t"],[-1,22007,"\n {\n "],[1,22012,"   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\t"],[-1,22025," "],[1,22026,"\t\t"],[-1,22039," "],[1,22040,"\t\t"],[-1,22054," printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf("],[1,22101,"\t\tcout << "],[-1,22121,");\n }\n\n "],[1,22129," << this->a << this->b << this->c << endl;\n\n\t}\n\n\t"],[-1,22136," {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n "],[1,22203,"\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t"],[-1,22226," "],[1,22227,"\t"],[-1,22234," "],[1,22235,"\t"],[-1,22242," "],[1,22243,"\t"],[1,22254,"\n"],[1,22263," "],[-1,22274," "],[1,22275,"\t"],[1,22280," "],[1,22288," "],[1,22290," "],[1,22293," "],[1,22300," "],[1,22302," "],[1,22305," "],[-1,22311,"\n\n //"],[1,22316,"  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~"],[-1,22322," {\n "],[1,22326,"\t{\n\t\t"],[1,22330," "],[1,22332," "],[1,22333,"~"],[1,22339," "],[1,22341," "],[-1,22347," "],[1,22348,"\t"],[1,22351,"\tMyD(const"],[-1,22352,"~"],[-1,22356,"()\n {\n "],[1,22363," & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\t"],[1,22367," "],[1,22369," "],[-1,22370,"~"],[1,22375,"const MyD &obj"],[1,22377," "],[1,22379," "],[-1,22385," "],[1,22386,"\t"],[-1,22409," "],[1,22410,"\t"],[-1,22439,"\n "],[1,22441,"//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\t"],[1,22451,"\tconst"],[1,22452,"int m;//因为是"],[1,22458,"m,所以上面所有的m都进行了赋值\n};\n\n\n"],[1,22462,"doThing(MyD "],[1,22463,"yel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl"],[-1,22466,";"],[1,22467,"\n"],[1,22476,"2"],[1,22478,"//二"],[-1,22481," "],[1,22482,"\t"],[-1,22490,"\n "],[1,22492,"//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\t"],[-1,22509,"main_dem03"],[1,22519,"run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main"],[-1,22524," "],[1,22525,"\t"],[1,22528,"2"],[-1,22531,"\n "],[1,22533,"//一\n\t//run3();\n\t"],[-1,22550," "],[1,22551,"\t"],[1,22562,"\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n"]],[21903,22562],[23991,23991]]],[1543029265291,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"],[-1,21902,"/"],[1,21908,"总"],[-1,21920,"\n"],[1,21926,"\n"],[-1,21988," "],[1,21990,"A"],[-1,22013,"\n"],[1,22069,"t"],[-1,22081," "],[1,22084,"t"],[-1,22096," "],[1,22099,"t"],[-1,22112," "],[1,22123,"\""],[-1,22142,")"],[1,22192,"~"],[-1,22198," "],[-1,22313,""],[1,22313,"}"],[-1,22335," "],[1,22337,"i"],[-1,22343," "],[1,22345,"i"],[-1,22351," "],[1,22353,"i"],[-1,22363,"c"],[1,22365,"c"],[1,22373," "],[-1,22374," "],[-1,22385," "],[1,22387,"M"],[-1,22391,":"],[1,22393,":"],[1,22400," "],[1,22401,","],[-1,22402,","],[-1,22404," "],[1,22407," "],[-1,22408," "],[1,22415," "],[1,22416,","],[-1,22417,","],[-1,22419," "],[1,22422," "],[-1,22423," "],[-1,22429,"\n"],[1,22523,"M"],[-1,22528," "],[1,22534,"c"],[-1,22537,"<"],[-1,22540,"\" M~"],[1,22544,"< \"~M"],[-1,22549,"<"],[-1,22552,"e "],[1,22554,"< e"],[-1,22559," "],[1,22561,"}"],[-1,22563," "],[-1,22574,"~"],[1,22575," M"],[-1,22577,"("],[1,22653,"c"],[-1,22656,"<"],[-1,22659,"\" ~"],[1,22662,"< \"M"],[-1,22665,")"],[1,22680,")"],[-1,22681,"<"],[-1,22684,"e "],[1,22686,"< e"],[-1,22691," "],[1,22693,"}"],[-1,22715," "],[1,22717,"A"],[-1,22745,"\n"],[1,22776,"A"],[-1,22785," "],[-1,22792,"c"],[1,22793," "],[1,22804,"c"],[-1,22809,"i"],[1,22832,"i"],[-1,22835,"m"],[-1,22848,";"],[1,22849,"m"],[1,22931,";"],[-1,22933,";"],[1,22934,"\n"],[-1,22943,"("],[1,22945,"("],[-1,22946,"\n"],[1,22950,"\n"],[-1,22952," "],[1,22954,"M"],[-1,22961,"\n"],[1,23043,"r"],[-1,23059,"m"],[1,23146,"("],[-1,23150," "],[1,23152,"r"],[-1,23154,"("],[1,23156,"("],[-1,23158,"\n"],[1,23175,"s"],[-1,23191," "],[1,23193,"r"],[-1,23206,"\n"],[1,23992,"\n"],[-1,24182,"析"],[1,24184,"综"],[-1,24189,"\n"],[-1,24204,"d"],[1,24206,"\n*"]],[20964,20964],[24208,24208]]],[1543029265291,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"],[1,21903,"/"],[-1,21908,"总"],[1,21921,"\n"],[-1,21926,"\n"],[1,21989," "],[-1,21990,"A"],[1,22014,"\n"],[-1,22069,"t"],[1,22082," "],[-1,22084,"t"],[1,22097," "],[-1,22099,"t"],[1,22113," "],[-1,22123,"\""],[1,22143,")"],[-1,22192,"~"],[1,22199," "],[1,22313,""],[-1,22313,"}"],[1,22336," "],[-1,22337,"i"],[1,22344," "],[-1,22345,"i"],[1,22352," "],[-1,22353,"i"],[1,22364,"c"],[-1,22365,"c"],[-1,22374," "],[1,22376," "],[1,22386," "],[-1,22387,"M"],[1,22392,":"],[-1,22393,":"],[-1,22401," "],[-1,22403,","],[1,22405,","],[1,22406," "],[-1,22408," "],[1,22410," "],[-1,22416," "],[-1,22418,","],[1,22420,","],[1,22421," "],[-1,22423," "],[1,22425," "],[1,22430,"\n"],[-1,22523,"M"],[1,22529," "],[-1,22534,"c"],[1,22538,"<"],[1,22540,"\" M~"],[-1,22540,"< \"~M"],[1,22550,"<"],[1,22552,"e "],[-1,22552,"< e"],[1,22560," "],[-1,22561,"}"],[1,22564," "],[1,22574,"~"],[-1,22574," M"],[1,22578,"("],[-1,22653,"c"],[1,22657,"<"],[1,22659,"\" ~"],[-1,22659,"< \"M"],[1,22666,")"],[-1,22680,")"],[1,22682,"<"],[1,22684,"e "],[-1,22684,"< e"],[1,22692," "],[-1,22693,"}"],[1,22716," "],[-1,22717,"A"],[1,22746,"\n"],[-1,22776,"A"],[1,22786," "],[1,22792,"c"],[-1,22792," "],[-1,22804,"c"],[1,22810,"i"],[-1,22832,"i"],[1,22836,"m"],[1,22848,";"],[-1,22848,"m"],[-1,22931,";"],[1,22934,";"],[-1,22934,"\n"],[1,22944,"("],[-1,22945,"("],[1,22947,"\n"],[-1,22950,"\n"],[1,22953," "],[-1,22954,"M"],[1,22962,"\n"],[-1,23043,"r"],[1,23060,"m"],[-1,23146,"("],[1,23151," "],[-1,23152,"r"],[1,23155,"("],[-1,23156,"("],[1,23159,"\n"],[-1,23175,"s"],[1,23192," "],[-1,23193,"r"],[1,23207,"\n"],[-1,23992,"\n"],[1,24183,"析"],[-1,24184,"综"],[1,24190,"\n"],[1,24204,"d"],[-1,24205,"\n*"]],[24208,24208],[20964,20964]]],[1543029223709,["gjx16@GJXAIOU",[[1,21903,"//"],[-1,21903,"\n/*\n\n"],[-1,21921,"\n\n*/"],[1,21989," "],[-1,21989,"\t"],[1,22014,"\n {\n "],[-1,22014,"   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\t"],[1,22082," "],[-1,22082,"\t\t"],[1,22097," "],[-1,22097,"\t\t"],[1,22113," printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf("],[-1,22113,"\t\tcout << "],[1,22143,");\n }\n\n "],[-1,22143," << this->a << this->b << this->c << endl;\n\n\t}\n\n\t"],[1,22199," {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n "],[-1,22199,"\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t"],[1,22336," "],[-1,22336,"\t"],[1,22344," "],[-1,22344,"\t"],[1,22352," "],[-1,22352,"\t"],[-1,22364,"\n"],[-1,22374," "],[1,22386," "],[-1,22386,"\t"],[-1,22392," "],[-1,22401," "],[-1,22404," "],[-1,22408," "],[-1,22416," "],[-1,22419," "],[-1,22423," "],[1,22430,"\n\n //"],[-1,22430,"  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~"],[1,22529," {\n "],[-1,22529,"\t{\n\t\t"],[-1,22538," "],[-1,22541," "],[-1,22543,"~"],[-1,22550," "],[-1,22553," "],[1,22560," "],[-1,22560,"\t"],[-1,22564,"\tMyD(const"],[1,22575,"~"],[1,22578,"()\n {\n "],[-1,22578," & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\t"],[-1,22657," "],[-1,22660," "],[1,22662,"~"],[-1,22666,"const MyD &obj"],[-1,22682," "],[-1,22685," "],[1,22692," "],[-1,22692,"\t"],[1,22716," "],[-1,22716,"\t"],[1,22746,"\n "],[-1,22746,"//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\t"],[-1,22786,"\tconst"],[-1,22793,"int m;//因为是"],[-1,22810,"m,所以上面所有的m都进行了赋值\n};\n\n\n"],[-1,22836,"doThing(MyD "],[-1,22849,"yel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl"],[1,22934,";"],[-1,22934,"\n"],[-1,22944,"2"],[-1,22947,"//二"],[1,22953," "],[-1,22953,"\t"],[1,22962,"\n "],[-1,22962,"//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\t"],[1,23060,"main_dem03"],[-1,23060,"run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main"],[1,23151," "],[-1,23151,"\t"],[-1,23155,"2"],[1,23159,"\n "],[-1,23159,"//一\n\t//run3();\n\t"],[1,23192," "],[-1,23192,"\t"],[-1,23204,"\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n"]],[23991,23991],[21903,22562]]],[1543029237610,["gjx16@GJXAIOU",[[1,22770,"/*\n\n总结 构造和析构的调用顺序\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n\tABC(int a, int b, int c)   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\n\t}\n\n\t~ABC()\n\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\n\nclass MyD \n{\npublic:\n\tMyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~MyD()\n\t{\n\t\tcout << \"~MyD()\" << endl;\n\t}\n\n\tMyD(const MyD & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\tcout << \"MyD(const MyD &obj)\" << endl;\n\t}\n\nprotected:\nprivate:\n\tABC abc1; //c++编译器不知道如何构造abc1//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\tABC abc2;\n\tconst int m;//因为是const m,所以上面所有的m都进行了赋值\n};\n\n\nint doThing(MyD myel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;\n}\n\n\nint run2()//二\n{\n\tMyD myD;//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\treturn 0;\n}\n\nint run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main()\n{\n\trun2();//一\n\t//run3();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n\n"]],[22769,22769],[24857,24857]]],[1543035746000,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"],[-1,21904,"/"],[1,21905,"总"],[-1,21982," "],[1,21983,"A"],[-1,22007,"\n"],[1,22012,"t"],[-1,22025," "],[1,22026,"t"],[-1,22039," "],[1,22040,"t"],[-1,22053," "],[1,22101,"\""],[-1,22121,")"],[1,22129,"~"],[-1,22135," "],[-1,22203,""],[1,22203,"}"],[-1,22226," "],[1,22227,"i"],[-1,22234," "],[1,22235,"i"],[-1,22242," "],[1,22243,"i"],[-1,22274," "],[1,22275,"M"],[-1,22312,"\n"],[1,22316,"M"],[-1,22322," "],[1,22326,"c"],[-1,22347," "],[1,22348,"}"],[-1,22352,"~"],[1,22353,"M"],[-1,22355,"("],[1,22363,"c"],[-1,22370,"~"],[1,22371,"M"],[-1,22385," "],[1,22386,"}"],[-1,22409," "],[1,22410,"A"],[-1,22439,"\n"],[1,22441,"A"],[-1,22466,";"],[1,22467,"\n"],[-1,22481," "],[1,22482,"M"],[-1,22489,"\n"],[1,22492,"r"],[-1,22509,"m"],[1,22519,"("],[-1,22524," "],[1,22525,"r"],[-1,22531,"\n"],[1,22533,"s"],[-1,22550," "],[1,22551,"r"],[-1,22753,"析"],[1,22755,"综"],[-1,22760,"\n"],[-1,24863,"d\n"],[1,24865,"\n\n*"]],[20964,20964],[24868,24868]]],[1543035746000,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"],[1,21905,"/"],[-1,21905,"总"],[1,21983," "],[-1,21983,"A"],[1,22008,"\n"],[-1,22012,"t"],[1,22026," "],[-1,22026,"t"],[1,22040," "],[-1,22040,"t"],[1,22054," "],[-1,22101,"\""],[1,22122,")"],[-1,22129,"~"],[1,22136," "],[1,22203,""],[-1,22203,"}"],[1,22227," "],[-1,22227,"i"],[1,22235," "],[-1,22235,"i"],[1,22243," "],[-1,22243,"i"],[1,22275," "],[-1,22275,"M"],[1,22313,"\n"],[-1,22316,"M"],[1,22323," "],[-1,22326,"c"],[1,22348," "],[-1,22348,"}"],[1,22353,"~"],[-1,22353,"M"],[1,22356,"("],[-1,22363,"c"],[1,22371,"~"],[-1,22371,"M"],[1,22386," "],[-1,22386,"}"],[1,22410," "],[-1,22410,"A"],[1,22440,"\n"],[-1,22441,"A"],[1,22467,";"],[-1,22467,"\n"],[1,22482," "],[-1,22482,"M"],[1,22490,"\n"],[-1,22492,"r"],[1,22510,"m"],[-1,22519,"("],[1,22525," "],[-1,22525,"r"],[1,22532,"\n"],[-1,22533,"s"],[1,22551," "],[-1,22551,"r"],[1,22754,"析"],[-1,22755,"综"],[1,22761,"\n"],[1,24863,"d\n"],[-1,24863,"\n\n*"]],[24868,24868],[20964,20964]]],[1543035704016,["gjx16@GJXAIOU",[[1,24955,"`"],[1,24974,"`"]],[24955,24974],[24955,24976]]],[1543035705531,["gjx16@GJXAIOU",[[-1,24955,"`demo11_匿名对象练习强化.cpp`"]],[24955,24976],[24955,24955]]],[1543035706955,["gjx16@GJXAIOU",[[1,24955,"```"]],[24955,24955],[24958,24958]]],[1543035707225,["gjx16@GJXAIOU",[[1,24958,"language\n```\n"]],[24958,24958],[24958,24966]]],[1543035707743,["gjx16@GJXAIOU",[[-1,24958,"language"],[1,24966,"p"]],[24958,24966],[24959,24959]]],[1543035708245,["gjx16@GJXAIOU",[[1,24959,"y"]],[24959,24959],[24960,24960]]],[1543035709629,["gjx16@GJXAIOU",[[-1,24958,"py"]],[24960,24960],[24958,24958]]],[1543035710851,["gjx16@GJXAIOU",[[1,24958,"cpp"]],[24958,24958],[24961,24961]]],[1543035711414,["gjx16@GJXAIOU",[[1,24962,"\n"]],[24961,24961],[24962,24962]]],[1543035711956,["gjx16@GJXAIOU",[[1,24962,"/*\n\n构造中调用构造\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass MyTest\n{\npublic:\n\tMyTest(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t}\n\n\tMyTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\n\t\tMyTest(a, b, 10);\n\t}\n\n\t~MyTest()\n\t{\n\t\tcout << \"MyTest is ...\" << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n\n\npublic:\n\tint getC() const { return c; }\n\n\tvoid setC(int val) { c = val; }\n};\n\nint main()\n{\n\tMyTest t1(1, 2);\n\tcout << t1.getC() << endl;\n\tsystem(\"pause\");\n\treturn 0;\n\t\n}\n\n"]],[24962,24962],[25463,25463]]],[1543035718265,["gjx16@GJXAIOU",[[-1,25469,"\n"]],[25469,25469],[25468,25468]]],[1543035722797,["gjx16@GJXAIOU",[[1,25470,"jielun"]],[25470,25470],[25476,25476]]],[1543035727841,["gjx16@GJXAIOU",[[-1,25470,"jielun"]],[25476,25476],[25470,25470]]],[1543035730495,["gjx16@GJXAIOU",[[1,25470,"结论："]],[25470,25470],[25473,25473]]],[1543035743269,["gjx16@GJXAIOU",[[1,25496,"程序内存图："]],[25496,25496],[25502,25502]]],[1543035743776,["gjx16@GJXAIOU",[[1,25503,"\n"]],[25502,25502],[25503,25503]]],[1543035805994,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"],[-1,21904,"/"],[1,21905,"总"],[-1,21982," "],[1,21983,"A"],[-1,22007,"\n"],[1,22012,"t"],[-1,22025," "],[1,22026,"t"],[-1,22039," "],[1,22040,"t"],[-1,22053," "],[1,22101,"\""],[-1,22121,")"],[1,22129,"~"],[-1,22135," "],[-1,22203,""],[1,22203,"}"],[-1,22226," "],[1,22227,"i"],[-1,22234," "],[1,22235,"i"],[-1,22242," "],[1,22243,"i"],[-1,22274," "],[1,22275,"M"],[-1,22312,"\n"],[1,22316,"M"],[-1,22322," "],[1,22326,"c"],[-1,22347," "],[1,22348,"}"],[-1,22352,"~"],[1,22353,"M"],[-1,22355,"("],[1,22363,"c"],[-1,22370,"~"],[1,22371,"M"],[-1,22385," "],[1,22386,"}"],[-1,22409," "],[1,22410,"A"],[-1,22438,"\n"],[1,22441,"A"],[-1,22466,";"],[1,22467,"\n"],[-1,22481," "],[1,22482,"M"],[-1,22490,"\n"],[1,22492,"r"],[-1,22509,"m"],[1,22519,"("],[-1,22524," "],[1,22525,"r"],[-1,22531,"\n"],[1,22533,"s"],[-1,22550," "],[1,22551,"r"],[-1,22753,"析"],[1,22755,"综"],[-1,22760,"\n"],[-1,24863,"d"],[1,24865,"\n*"],[-1,24954,"d"],[1,24955,""],[1,25473," "],[-1,25495,"\n"],[1,25502,"\n\n"],[-1,25503,"\n"]],[20964,20964],[25503,25503]]],[1543035805994,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"],[1,21905,"/"],[-1,21905,"总"],[1,21983," "],[-1,21983,"A"],[1,22008,"\n"],[-1,22012,"t"],[1,22026," "],[-1,22026,"t"],[1,22040," "],[-1,22040,"t"],[1,22054," "],[-1,22101,"\""],[1,22122,")"],[-1,22129,"~"],[1,22136," "],[1,22203,""],[-1,22203,"}"],[1,22227," "],[-1,22227,"i"],[1,22235," "],[-1,22235,"i"],[1,22243," "],[-1,22243,"i"],[1,22275," "],[-1,22275,"M"],[1,22313,"\n"],[-1,22316,"M"],[1,22323," "],[-1,22326,"c"],[1,22348," "],[-1,22348,"}"],[1,22353,"~"],[-1,22353,"M"],[1,22356,"("],[-1,22363,"c"],[1,22371,"~"],[-1,22371,"M"],[1,22386," "],[-1,22386,"}"],[1,22410," "],[-1,22410,"A"],[1,22439,"\n"],[-1,22441,"A"],[1,22467,";"],[-1,22467,"\n"],[1,22482," "],[-1,22482,"M"],[1,22491,"\n"],[-1,22492,"r"],[1,22510,"m"],[-1,22519,"("],[1,22525," "],[-1,22525,"r"],[1,22532,"\n"],[-1,22533,"s"],[1,22551," "],[-1,22551,"r"],[1,22754,"析"],[-1,22755,"综"],[1,22761,"\n"],[1,24863,"d"],[-1,24864,"\n*"],[1,24955,"d"],[-1,24955,""],[-1,25473," "],[1,25496,"\n"],[-1,25502,"\n\n"],[1,25505,"\n"]],[25503,25503],[20964,20964]]],[1543035760311,["gjx16@GJXAIOU",[[1,25503,"![搜狗截图20181124125452]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181124125452.png)"]],[25503,25503],[25591,25591]]],[1543035764831,["gjx16@GJXAIOU",[[1,25591,"\n"]],[25590,25590],[25591,25591]]],[1543062095658,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"],[-1,21904,"/"],[1,21905,"总"],[-1,21982," "],[1,21983,"A"],[-1,22007,"\n"],[1,22012,"t"],[-1,22025," "],[1,22026,"t"],[-1,22039," "],[1,22040,"t"],[-1,22053," "],[1,22101,"\""],[-1,22121,")"],[1,22129,"~"],[-1,22135," "],[-1,22203,""],[1,22203,"}"],[-1,22226," "],[1,22227,"i"],[-1,22234," "],[1,22235,"i"],[-1,22242," "],[1,22243,"i"],[-1,22274," "],[1,22275,"M"],[-1,22312,"\n"],[1,22316,"M"],[-1,22322," "],[1,22326,"c"],[-1,22347," "],[1,22348,"}"],[-1,22352,"~"],[1,22353,"M"],[-1,22355,"("],[1,22363,"c"],[-1,22370,"~"],[1,22371,"M"],[-1,22385," "],[1,22386,"}"],[-1,22409," "],[1,22410,"A"],[-1,22439,"\n"],[1,22441,"A"],[-1,22466,";"],[1,22467,"\n"],[-1,22481," "],[1,22482,"M"],[-1,22489,"\n"],[1,22492,"r"],[-1,22509,"m"],[1,22519,"("],[-1,22524," "],[1,22525,"r"],[-1,22531,"\n"],[1,22533,"s"],[-1,22550," "],[1,22551,"r"],[-1,22753,"析"],[1,22755,"综"],[-1,22760,"\n"],[-1,24863,"d"],[1,24865,"\n*"],[-1,24954,"d"],[1,24955,""],[1,25473," "],[-1,25495,"\n"],[-1,25502,"*"],[1,25503,"\n"],[1,25592,"*"]],[20964,20964],[25593,25593]]],[1543062095658,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"],[1,21905,"/"],[-1,21905,"总"],[1,21983," "],[-1,21983,"A"],[1,22008,"\n"],[-1,22012,"t"],[1,22026," "],[-1,22026,"t"],[1,22040," "],[-1,22040,"t"],[1,22054," "],[-1,22101,"\""],[1,22122,")"],[-1,22129,"~"],[1,22136," "],[1,22203,""],[-1,22203,"}"],[1,22227," "],[-1,22227,"i"],[1,22235," "],[-1,22235,"i"],[1,22243," "],[-1,22243,"i"],[1,22275," "],[-1,22275,"M"],[1,22313,"\n"],[-1,22316,"M"],[1,22323," "],[-1,22326,"c"],[1,22348," "],[-1,22348,"}"],[1,22353,"~"],[-1,22353,"M"],[1,22356,"("],[-1,22363,"c"],[1,22371,"~"],[-1,22371,"M"],[1,22386," "],[-1,22386,"}"],[1,22410," "],[-1,22410,"A"],[1,22440,"\n"],[-1,22441,"A"],[1,22467,";"],[-1,22467,"\n"],[1,22482," "],[-1,22482,"M"],[1,22490,"\n"],[-1,22492,"r"],[1,22510,"m"],[-1,22519,"("],[1,22525," "],[-1,22525,"r"],[1,22532,"\n"],[-1,22533,"s"],[1,22551," "],[-1,22551,"r"],[1,22754,"析"],[-1,22755,"综"],[1,22761,"\n"],[1,24863,"d"],[-1,24864,"\n*"],[1,24955,"d"],[-1,24955,""],[-1,25473," "],[1,25496,"\n"],[1,25502,"*"],[-1,25502,"\n"],[-1,25592,"*"]],[25593,25593],[20964,20964]]],[1543062056575,["gjx16@GJXAIOU",[[-1,25618,"****"]],[25622,25622],[25618,25618]]],[1543062064391,["gjx16@GJXAIOU",[[-1,25619,"****"]],[25623,25623],[25619,25619]]],[1543062071270,["gjx16@GJXAIOU",[[-1,25625,"****"]],[25629,25629],[25625,25625]]],[1543062695694,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"],[-1,21904,"/"],[1,21905,"总"],[-1,21982," "],[1,21983,"A"],[-1,22007,"\n"],[1,22012,"t"],[-1,22025," "],[1,22026,"t"],[-1,22039," "],[1,22040,"t"],[-1,22053," "],[1,22101,"\""],[-1,22121,")"],[1,22129,"~"],[-1,22135," "],[-1,22203,""],[1,22203,"}"],[-1,22226," "],[1,22227,"i"],[-1,22234," "],[1,22235,"i"],[-1,22242," "],[1,22243,"i"],[-1,22274," "],[1,22275,"M"],[-1,22312,"\n"],[1,22316,"M"],[-1,22322," "],[1,22326,"c"],[-1,22347," "],[1,22348,"}"],[-1,22352,"~"],[1,22353,"M"],[-1,22355,"("],[1,22363,"c"],[-1,22370,"~"],[1,22371,"M"],[-1,22385," "],[1,22386,"}"],[-1,22409," "],[1,22410,"A"],[-1,22439,"\n"],[1,22441,"A"],[-1,22466,";"],[1,22467,"\n"],[-1,22481," "],[1,22482,"M"],[-1,22489,"\n"],[1,22492,"r"],[-1,22509,"m"],[1,22519,"("],[-1,22524," "],[1,22525,"r"],[-1,22531,"\n"],[1,22533,"s"],[-1,22550," "],[1,22551,"r"],[-1,22753,"析"],[1,22755,"综"],[-1,22760,"\n"],[-1,24863,"d"],[1,24865,"\n*"],[-1,24954,"d"],[1,24955,""],[1,25473," "],[-1,25495,"\n"],[-1,25502,"*"],[1,25503,"\n"],[1,25593,"*"],[-1,25617,"**"],[1,25619,"和d"],[-1,25624,"*"],[1,25625,"基"]],[20964,20964],[25626,25626]]],[1543062695694,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"],[1,21905,"/"],[-1,21905,"总"],[1,21983," "],[-1,21983,"A"],[1,22008,"\n"],[-1,22012,"t"],[1,22026," "],[-1,22026,"t"],[1,22040," "],[-1,22040,"t"],[1,22054," "],[-1,22101,"\""],[1,22122,")"],[-1,22129,"~"],[1,22136," "],[1,22203,""],[-1,22203,"}"],[1,22227," "],[-1,22227,"i"],[1,22235," "],[-1,22235,"i"],[1,22243," "],[-1,22243,"i"],[1,22275," "],[-1,22275,"M"],[1,22313,"\n"],[-1,22316,"M"],[1,22323," "],[-1,22326,"c"],[1,22348," "],[-1,22348,"}"],[1,22353,"~"],[-1,22353,"M"],[1,22356,"("],[-1,22363,"c"],[1,22371,"~"],[-1,22371,"M"],[1,22386," "],[-1,22386,"}"],[1,22410," "],[-1,22410,"A"],[1,22440,"\n"],[-1,22441,"A"],[1,22467,";"],[-1,22467,"\n"],[1,22482," "],[-1,22482,"M"],[1,22490,"\n"],[-1,22492,"r"],[1,22510,"m"],[-1,22519,"("],[1,22525," "],[-1,22525,"r"],[1,22532,"\n"],[-1,22533,"s"],[1,22551," "],[-1,22551,"r"],[1,22754,"析"],[-1,22755,"综"],[1,22761,"\n"],[1,24863,"d"],[-1,24864,"\n*"],[1,24955,"d"],[-1,24955,""],[-1,25473," "],[1,25496,"\n"],[1,25502,"*"],[-1,25502,"\n"],[-1,25593,"*"],[1,25618,"**"],[-1,25618,"和d"],[1,25625,"*"],[-1,25625,"基"]],[25626,25626],[20964,20964]]],[1543062660404,["gjx16@GJXAIOU",[[-1,26283,"** **"]],[26288,26288],[26283,26283]]],[1543062755679,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"],[-1,21904,"/"],[1,21905,"总"],[-1,21982," "],[1,21983,"A"],[-1,22007,"\n"],[1,22012,"t"],[-1,22025," "],[1,22026,"t"],[-1,22039," "],[1,22040,"t"],[-1,22053," "],[1,22101,"\""],[-1,22121,")"],[1,22129,"~"],[-1,22135," "],[-1,22203,""],[1,22203,"}"],[-1,22226," "],[1,22227,"i"],[-1,22234," "],[1,22235,"i"],[-1,22242," "],[1,22243,"i"],[-1,22274," "],[1,22275,"M"],[-1,22312,"\n"],[1,22316,"M"],[-1,22322," "],[1,22326,"c"],[-1,22347," "],[1,22348,"}"],[-1,22352,"~"],[1,22353,"M"],[-1,22355,"("],[1,22363,"c"],[-1,22370,"~"],[1,22371,"M"],[-1,22385," "],[1,22386,"}"],[-1,22409," "],[1,22410,"A"],[-1,22439,"\n"],[1,22441,"A"],[-1,22466,";"],[1,22467,"\n"],[-1,22481," "],[1,22482,"M"],[-1,22489,"\n"],[1,22492,"r"],[-1,22509,"m"],[1,22519,"("],[-1,22524," "],[1,22525,"r"],[-1,22531,"\n"],[1,22533,"s"],[-1,22550," "],[1,22551,"r"],[-1,22753,"析"],[1,22755,"综"],[-1,22760,"\n"],[-1,24863,"d"],[1,24865,"\n*"],[-1,24954,"d"],[1,24955,""],[1,25473," "],[-1,25495,"\n"],[-1,25502,"*"],[1,25503,"\n"],[1,25593,"*"],[-1,25617,"**"],[1,25619,"和d"],[-1,25624,"*"],[1,25625,"基"],[-1,26282,"*"],[1,26283,"类"]],[20964,20964],[26284,26284]]],[1543062755679,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"],[1,21905,"/"],[-1,21905,"总"],[1,21983," "],[-1,21983,"A"],[1,22008,"\n"],[-1,22012,"t"],[1,22026," "],[-1,22026,"t"],[1,22040," "],[-1,22040,"t"],[1,22054," "],[-1,22101,"\""],[1,22122,")"],[-1,22129,"~"],[1,22136," "],[1,22203,""],[-1,22203,"}"],[1,22227," "],[-1,22227,"i"],[1,22235," "],[-1,22235,"i"],[1,22243," "],[-1,22243,"i"],[1,22275," "],[-1,22275,"M"],[1,22313,"\n"],[-1,22316,"M"],[1,22323," "],[-1,22326,"c"],[1,22348," "],[-1,22348,"}"],[1,22353,"~"],[-1,22353,"M"],[1,22356,"("],[-1,22363,"c"],[1,22371,"~"],[-1,22371,"M"],[1,22386," "],[-1,22386,"}"],[1,22410," "],[-1,22410,"A"],[1,22440,"\n"],[-1,22441,"A"],[1,22467,";"],[-1,22467,"\n"],[1,22482," "],[-1,22482,"M"],[1,22490,"\n"],[-1,22492,"r"],[1,22510,"m"],[-1,22519,"("],[1,22525," "],[-1,22525,"r"],[1,22532,"\n"],[-1,22533,"s"],[1,22551," "],[-1,22551,"r"],[1,22754,"析"],[-1,22755,"综"],[1,22761,"\n"],[1,24863,"d"],[-1,24864,"\n*"],[1,24955,"d"],[-1,24955,""],[-1,25473," "],[1,25496,"\n"],[1,25502,"*"],[-1,25502,"\n"],[-1,25593,"*"],[1,25618,"**"],[-1,25618,"和d"],[1,25625,"*"],[-1,25625,"基"],[1,26283,"*"],[-1,26283,"类"]],[26284,26284],[20964,20964]]],[1543062720039,["gjx16@GJXAIOU",[[-1,25592,"**3.8"]],[25597,25597],[25592,25592]]],[1543062726655,["gjx16@GJXAIOU",[[-1,25602,"**"]],[25604,25604],[25602,25602]]],[1543062737401,["gjx16@GJXAIOU",[[1,25592,"### （）"]],[25592,25592],[25598,25598]]],[1543062741070,["gjx16@GJXAIOU",[[1,25597,"八"]],[25597,25597],[25598,25598]]],[1543062815935,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"],[-1,21904,"/"],[1,21905,"总"],[-1,21982," "],[1,21983,"A"],[-1,22007,"\n"],[1,22012,"t"],[-1,22025," "],[1,22026,"t"],[-1,22039," "],[1,22040,"t"],[-1,22053," "],[1,22101,"\""],[-1,22121,")"],[1,22129,"~"],[-1,22135," "],[-1,22203,""],[1,22203,"}"],[-1,22226," "],[1,22227,"i"],[-1,22234," "],[1,22235,"i"],[-1,22242," "],[1,22243,"i"],[-1,22274," "],[1,22275,"M"],[-1,22312,"\n"],[1,22316,"M"],[-1,22322," "],[1,22326,"c"],[-1,22347," "],[1,22348,"}"],[-1,22352,"~"],[1,22353,"M"],[-1,22355,"("],[1,22363,"c"],[-1,22370,"~"],[1,22371,"M"],[-1,22385," "],[1,22386,"}"],[-1,22409," "],[1,22410,"A"],[-1,22438,"\n"],[1,22441,"A"],[-1,22466,";"],[1,22467,"\n"],[-1,22481," "],[1,22482,"M"],[-1,22490,"\n"],[1,22492,"r"],[-1,22509,"m"],[1,22519,"("],[-1,22524," "],[1,22525,"r"],[-1,22531,"\n"],[1,22533,"s"],[-1,22550," "],[1,22551,"r"],[-1,22753,"析"],[1,22755,"综"],[-1,22760,"\n"],[-1,24863,"d"],[1,24865,"\n*"],[-1,24954,"d"],[1,24955,""],[1,25473," "],[-1,25495,"\n"],[-1,25502,"*"],[1,25503,"\n"],[1,25599,"对"],[-1,25608,"*"],[1,25609,"\n"],[-1,25617,"**"],[1,25619,"和d"],[-1,25624,"*"],[1,25625,"基"],[-1,26282,"*"],[1,26283,"类"]],[20964,20964],[26284,26284]]],[1543062815935,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"],[1,21905,"/"],[-1,21905,"总"],[1,21983," "],[-1,21983,"A"],[1,22008,"\n"],[-1,22012,"t"],[1,22026," "],[-1,22026,"t"],[1,22040," "],[-1,22040,"t"],[1,22054," "],[-1,22101,"\""],[1,22122,")"],[-1,22129,"~"],[1,22136," "],[1,22203,""],[-1,22203,"}"],[1,22227," "],[-1,22227,"i"],[1,22235," "],[-1,22235,"i"],[1,22243," "],[-1,22243,"i"],[1,22275," "],[-1,22275,"M"],[1,22313,"\n"],[-1,22316,"M"],[1,22323," "],[-1,22326,"c"],[1,22348," "],[-1,22348,"}"],[1,22353,"~"],[-1,22353,"M"],[1,22356,"("],[-1,22363,"c"],[1,22371,"~"],[-1,22371,"M"],[1,22386," "],[-1,22386,"}"],[1,22410," "],[-1,22410,"A"],[1,22439,"\n"],[-1,22441,"A"],[1,22467,";"],[-1,22467,"\n"],[1,22482," "],[-1,22482,"M"],[1,22491,"\n"],[-1,22492,"r"],[1,22510,"m"],[-1,22519,"("],[1,22525," "],[-1,22525,"r"],[1,22532,"\n"],[-1,22533,"s"],[1,22551," "],[-1,22551,"r"],[1,22754,"析"],[-1,22755,"综"],[1,22761,"\n"],[1,24863,"d"],[-1,24864,"\n*"],[1,24955,"d"],[-1,24955,""],[-1,25473," "],[1,25496,"\n"],[1,25502,"*"],[-1,25502,"\n"],[-1,25599,"对"],[1,25609,"*"],[-1,25609,"\n"],[1,25618,"**"],[-1,25618,"和d"],[1,25625,"*"],[-1,25625,"基"],[1,26283,"*"],[-1,26283,"类"]],[26284,26284],[20964,20964]]],[1543062761331,["gjx16@GJXAIOU",[[-1,25614," "]],[25615,25615],[25614,25614]]],[1543062761814,["gjx16@GJXAIOU",[[1,25614,"。"]],[25614,25614],[25615,25615]]],[1543062763351,["gjx16@GJXAIOU",[[-1,25614,"。"]],[25615,25615],[25614,25614]]],[1543062764185,["gjx16@GJXAIOU",[[1,25614,"."]],[25614,25614],[25615,25615]]],[1543062768953,["gjx16@GJXAIOU",[[1,25633,"- "]],[25633,25633],[25635,25635]]],[1543062780568,["gjx16@GJXAIOU",[[1,25761,"**"],[1,25793,"**"]],[25761,25793],[25761,25797]]],[1543062786565,["gjx16@GJXAIOU",[[1,25761,"  "]],[25761,25761],[25763,25763]]],[1543062791729,["gjx16@GJXAIOU",[[1,25801,"- "]],[25801,25801],[25803,25803]]],[1543062810677,["gjx16@GJXAIOU",[[1,25884,"\n"]],[25884,25884],[25885,25885]]],[1543062815409,["gjx16@GJXAIOU",[[1,25989,"\n"]],[25989,25989],[25990,25990]]],[1543062875902,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"],[-1,21904,"/"],[1,21905,"总"],[-1,21982," "],[1,21983,"A"],[-1,22007,"\n"],[1,22012,"t"],[-1,22025," "],[1,22026,"t"],[-1,22039," "],[1,22040,"t"],[-1,22053," "],[1,22101,"\""],[-1,22121,")"],[1,22129,"~"],[-1,22135," "],[-1,22203,""],[1,22203,"}"],[-1,22226," "],[1,22227,"i"],[-1,22234," "],[1,22235,"i"],[-1,22242," "],[1,22243,"i"],[-1,22274," "],[1,22275,"M"],[-1,22312,"\n"],[1,22316,"M"],[-1,22322," "],[1,22326,"c"],[-1,22347," "],[1,22348,"}"],[-1,22352,"~"],[1,22353,"M"],[-1,22355,"("],[1,22363,"c"],[-1,22370,"~"],[1,22371,"M"],[-1,22385," "],[1,22386,"}"],[-1,22409," "],[1,22410,"A"],[-1,22438,"\n"],[1,22441,"A"],[-1,22466,";"],[1,22467,"\n"],[-1,22481," "],[1,22482,"M"],[-1,22490,"\n"],[1,22492,"r"],[-1,22509,"m"],[1,22519,"("],[-1,22524," "],[1,22525,"r"],[-1,22531,"\n"],[1,22533,"s"],[-1,22550," "],[1,22551,"r"],[-1,22753,"析"],[1,22755,"综"],[-1,22760,"\n"],[-1,24863,"d"],[1,24865,"\n*"],[-1,24954,"d"],[1,24955,""],[1,25473," "],[-1,25495,"\n"],[-1,25502,"*"],[1,25503,"\n"],[1,25599,"对"],[-1,25608,"*"],[1,25609,"\n"],[-1,25613," "],[1,25615,"n"],[-1,25617,"**"],[1,25619,"和d"],[-1,25624,"*"],[1,25625,"基"],[-1,25632,"1"],[1,25635,"1"],[-1,25760,"注"],[1,25765,"注"],[-1,25796,"\n"],[-1,25800,"2"],[1,25801,"\n"],[1,25803,"2"],[-1,25883,"n"],[1,25885,"n"],[-1,25988,"n"],[1,25990,"n"],[-1,26294,"*"],[1,26295,"类"]],[20964,20964],[26296,26296]]],[1543062875902,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"],[1,21905,"/"],[-1,21905,"总"],[1,21983," "],[-1,21983,"A"],[1,22008,"\n"],[-1,22012,"t"],[1,22026," "],[-1,22026,"t"],[1,22040," "],[-1,22040,"t"],[1,22054," "],[-1,22101,"\""],[1,22122,")"],[-1,22129,"~"],[1,22136," "],[1,22203,""],[-1,22203,"}"],[1,22227," "],[-1,22227,"i"],[1,22235," "],[-1,22235,"i"],[1,22243," "],[-1,22243,"i"],[1,22275," "],[-1,22275,"M"],[1,22313,"\n"],[-1,22316,"M"],[1,22323," "],[-1,22326,"c"],[1,22348," "],[-1,22348,"}"],[1,22353,"~"],[-1,22353,"M"],[1,22356,"("],[-1,22363,"c"],[1,22371,"~"],[-1,22371,"M"],[1,22386," "],[-1,22386,"}"],[1,22410," "],[-1,22410,"A"],[1,22439,"\n"],[-1,22441,"A"],[1,22467,";"],[-1,22467,"\n"],[1,22482," "],[-1,22482,"M"],[1,22491,"\n"],[-1,22492,"r"],[1,22510,"m"],[-1,22519,"("],[1,22525," "],[-1,22525,"r"],[1,22532,"\n"],[-1,22533,"s"],[1,22551," "],[-1,22551,"r"],[1,22754,"析"],[-1,22755,"综"],[1,22761,"\n"],[1,24863,"d"],[-1,24864,"\n*"],[1,24955,"d"],[-1,24955,""],[-1,25473," "],[1,25496,"\n"],[1,25502,"*"],[-1,25502,"\n"],[-1,25599,"对"],[1,25609,"*"],[-1,25609,"\n"],[1,25614," "],[-1,25615,"n"],[1,25618,"**"],[-1,25618,"和d"],[1,25625,"*"],[-1,25625,"基"],[1,25633,"1"],[-1,25635,"1"],[1,25761,"注"],[-1,25765,"注"],[1,25797,"\n"],[1,25800,"2"],[-1,25800,"\n"],[-1,25803,"2"],[1,25884,"n"],[-1,25885,"n"],[1,25989,"n"],[-1,25990,"n"],[1,26295,"*"],[-1,26295,"类"]],[26296,26296],[20964,20964]]],[1543062831255,["gjx16@GJXAIOU",[[1,26039,"   "]],[26039,26039],[26042,26042]]],[1543062844734,["gjx16@GJXAIOU",[[1,26179,"-"]],[26179,26179],[26180,26180]]],[1543062845125,["gjx16@GJXAIOU",[[1,26181," "]],[26180,26180],[26181,26181]]],[1543062849070,["gjx16@GJXAIOU",[[-1,26181," "]],[26182,26182],[26181,26181]]],[1543062852711,["gjx16@GJXAIOU",[[-1,26206,"\n"]],[26206,26206],[26205,26205]]],[1543062855162,["gjx16@GJXAIOU",[[1,26206,"  "]],[26206,26206],[26208,26208]]],[1543062857675,["gjx16@GJXAIOU",[[1,26288,"- "]],[26288,26288],[26290,26290]]],[1543063055921,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"],[-1,21904,"/"],[1,21905,"总"],[-1,21982," "],[1,21983,"A"],[-1,22007,"\n"],[1,22012,"t"],[-1,22025," "],[1,22026,"t"],[-1,22039," "],[1,22040,"t"],[-1,22053," "],[1,22101,"\""],[-1,22121,")"],[1,22129,"~"],[-1,22135," "],[-1,22203,""],[1,22203,"}"],[-1,22226," "],[1,22227,"i"],[-1,22234," "],[1,22235,"i"],[-1,22242," "],[1,22243,"i"],[-1,22274," "],[1,22275,"M"],[-1,22312,"\n"],[1,22316,"M"],[-1,22322," "],[1,22326,"c"],[-1,22347," "],[1,22348,"}"],[-1,22352,"~"],[1,22353,"M"],[-1,22355,"("],[1,22363,"c"],[-1,22370,"~"],[1,22371,"M"],[-1,22385," "],[1,22386,"}"],[-1,22409," "],[1,22410,"A"],[-1,22439,"\n"],[1,22441,"A"],[-1,22466,";"],[1,22467,"\n"],[-1,22481," "],[1,22482,"M"],[-1,22489,"\n"],[1,22492,"r"],[-1,22509,"m"],[1,22519,"("],[-1,22524," "],[1,22525,"r"],[-1,22531,"\n"],[1,22533,"s"],[-1,22550," "],[1,22551,"r"],[-1,22753,"析"],[1,22755,"综"],[-1,22760,"\n"],[-1,24863,"d"],[1,24865,"\n*"],[-1,24954,"d"],[1,24955,""],[1,25473," "],[-1,25495,"\n"],[-1,25502,"*"],[1,25503,"\n"],[1,25599,"对"],[-1,25608,"*"],[1,25609,"\n"],[-1,25613," "],[1,25615,"n"],[-1,25617,"**"],[1,25619,"和d"],[-1,25624,"*"],[1,25625,"基"],[-1,25632,"1"],[1,25635,"1"],[-1,25760,"注"],[1,25765,"注"],[-1,25796,"\n"],[-1,25800,"2"],[1,25801,"\n"],[1,25803,"2"],[1,25883,"\n"],[-1,25884,"\n"],[-1,25988,"n"],[1,25990,"n"],[-1,26038,"n"],[1,26042,"n"],[-1,26178," "],[1,26180," "],[-1,26205,"\n"],[1,26208,"用"],[-1,26287,"4"],[1,26290,"4"],[-1,26301,"*"],[1,26302,"类"]],[20964,20964],[26303,26303]]],[1543063055921,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"],[1,21905,"/"],[-1,21905,"总"],[1,21983," "],[-1,21983,"A"],[1,22008,"\n"],[-1,22012,"t"],[1,22026," "],[-1,22026,"t"],[1,22040," "],[-1,22040,"t"],[1,22054," "],[-1,22101,"\""],[1,22122,")"],[-1,22129,"~"],[1,22136," "],[1,22203,""],[-1,22203,"}"],[1,22227," "],[-1,22227,"i"],[1,22235," "],[-1,22235,"i"],[1,22243," "],[-1,22243,"i"],[1,22275," "],[-1,22275,"M"],[1,22313,"\n"],[-1,22316,"M"],[1,22323," "],[-1,22326,"c"],[1,22348," "],[-1,22348,"}"],[1,22353,"~"],[-1,22353,"M"],[1,22356,"("],[-1,22363,"c"],[1,22371,"~"],[-1,22371,"M"],[1,22386," "],[-1,22386,"}"],[1,22410," "],[-1,22410,"A"],[1,22440,"\n"],[-1,22441,"A"],[1,22467,";"],[-1,22467,"\n"],[1,22482," "],[-1,22482,"M"],[1,22490,"\n"],[-1,22492,"r"],[1,22510,"m"],[-1,22519,"("],[1,22525," "],[-1,22525,"r"],[1,22532,"\n"],[-1,22533,"s"],[1,22551," "],[-1,22551,"r"],[1,22754,"析"],[-1,22755,"综"],[1,22761,"\n"],[1,24863,"d"],[-1,24864,"\n*"],[1,24955,"d"],[-1,24955,""],[-1,25473," "],[1,25496,"\n"],[1,25502,"*"],[-1,25502,"\n"],[-1,25599,"对"],[1,25609,"*"],[-1,25609,"\n"],[1,25614," "],[-1,25615,"n"],[1,25618,"**"],[-1,25618,"和d"],[1,25625,"*"],[-1,25625,"基"],[1,25633,"1"],[-1,25635,"1"],[1,25761,"注"],[-1,25765,"注"],[1,25797,"\n"],[1,25800,"2"],[-1,25800,"\n"],[-1,25803,"2"],[-1,25884,"\n"],[1,25886,"\n"],[1,25989,"n"],[-1,25990,"n"],[1,26039,"n"],[-1,26042,"n"],[1,26179," "],[-1,26180," "],[1,26206,"\n"],[-1,26208,"用"],[1,26288,"4"],[-1,26290,"4"],[1,26302,"*"],[-1,26302,"类"]],[26303,26303],[20964,20964]]],[1543063000238,["gjx16@GJXAIOU",[[1,26287,"![new运算符动态]($resource/new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%A8%E6%80%81.png)"]],[26287,26287],[26363,26363]]],[1543063003172,["gjx16@GJXAIOU",[[1,26363,"\n"]],[26362,26362],[26363,26363]]],[1543063175915,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"],[-1,21904,"/"],[1,21905,"总"],[-1,21982," "],[1,21983,"A"],[-1,22007,"\n"],[1,22012,"t"],[-1,22025," "],[1,22026,"t"],[-1,22039," "],[1,22040,"t"],[-1,22053," "],[1,22101,"\""],[-1,22121,")"],[1,22129,"~"],[-1,22135," "],[-1,22203,""],[1,22203,"}"],[-1,22226," "],[1,22227,"i"],[-1,22234," "],[1,22235,"i"],[-1,22242," "],[1,22243,"i"],[-1,22274," "],[1,22275,"M"],[-1,22312,"\n"],[1,22316,"M"],[-1,22322," "],[1,22326,"c"],[-1,22347," "],[1,22348,"}"],[-1,22352,"~"],[1,22353,"M"],[-1,22355,"("],[1,22363,"c"],[-1,22370,"~"],[1,22371,"M"],[-1,22385," "],[1,22386,"}"],[-1,22409," "],[1,22410,"A"],[-1,22438,"\n"],[1,22441,"A"],[-1,22466,";"],[1,22467,"\n"],[-1,22481," "],[1,22482,"M"],[-1,22490,"\n"],[1,22492,"r"],[-1,22509,"m"],[1,22519,"("],[-1,22524," "],[1,22525,"r"],[-1,22531,"\n"],[1,22533,"s"],[-1,22550," "],[1,22551,"r"],[-1,22753,"析"],[1,22755,"综"],[-1,22760,"\n"],[-1,24863,"d"],[1,24865,"\n*"],[-1,24954,"d"],[1,24955,""],[1,25473," "],[-1,25495,"\n"],[-1,25502,"*"],[1,25503,"\n"],[1,25599,"对"],[-1,25608,"*"],[1,25609,"\n"],[-1,25613," "],[1,25615,"n"],[-1,25617,"**"],[1,25619,"和d"],[-1,25624,"*"],[1,25625,"基"],[-1,25632,"1"],[1,25635,"1"],[-1,25760,"注"],[1,25765,"注"],[-1,25796,"\n"],[-1,25800,"2"],[1,25801,"\n"],[1,25803,"2"],[-1,25883,"n"],[1,25885,"n"],[-1,25988,"n"],[1,25990,"n"],[-1,26038,"n"],[1,26042,"n"],[1,26178,"-"],[-1,26179,"-"],[-1,26205,"\n"],[1,26208,"用"],[-1,26286,"\n"],[-1,26362,"4"],[1,26363,"\n"],[1,26366,"4"],[-1,26377,"*"],[1,26378,"类"]],[20964,20964],[26379,26379]]],[1543063175915,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"],[1,21905,"/"],[-1,21905,"总"],[1,21983," "],[-1,21983,"A"],[1,22008,"\n"],[-1,22012,"t"],[1,22026," "],[-1,22026,"t"],[1,22040," "],[-1,22040,"t"],[1,22054," "],[-1,22101,"\""],[1,22122,")"],[-1,22129,"~"],[1,22136," "],[1,22203,""],[-1,22203,"}"],[1,22227," "],[-1,22227,"i"],[1,22235," "],[-1,22235,"i"],[1,22243," "],[-1,22243,"i"],[1,22275," "],[-1,22275,"M"],[1,22313,"\n"],[-1,22316,"M"],[1,22323," "],[-1,22326,"c"],[1,22348," "],[-1,22348,"}"],[1,22353,"~"],[-1,22353,"M"],[1,22356,"("],[-1,22363,"c"],[1,22371,"~"],[-1,22371,"M"],[1,22386," "],[-1,22386,"}"],[1,22410," "],[-1,22410,"A"],[1,22439,"\n"],[-1,22441,"A"],[1,22467,";"],[-1,22467,"\n"],[1,22482," "],[-1,22482,"M"],[1,22491,"\n"],[-1,22492,"r"],[1,22510,"m"],[-1,22519,"("],[1,22525," "],[-1,22525,"r"],[1,22532,"\n"],[-1,22533,"s"],[1,22551," "],[-1,22551,"r"],[1,22754,"析"],[-1,22755,"综"],[1,22761,"\n"],[1,24863,"d"],[-1,24864,"\n*"],[1,24955,"d"],[-1,24955,""],[-1,25473," "],[1,25496,"\n"],[1,25502,"*"],[-1,25502,"\n"],[-1,25599,"对"],[1,25609,"*"],[-1,25609,"\n"],[1,25614," "],[-1,25615,"n"],[1,25618,"**"],[-1,25618,"和d"],[1,25625,"*"],[-1,25625,"基"],[1,25633,"1"],[-1,25635,"1"],[1,25761,"注"],[-1,25765,"注"],[1,25797,"\n"],[1,25800,"2"],[-1,25800,"\n"],[-1,25803,"2"],[1,25884,"n"],[-1,25885,"n"],[1,25989,"n"],[-1,25990,"n"],[1,26039,"n"],[-1,26042,"n"],[-1,26179,"-"],[1,26181,"-"],[1,26206,"\n"],[-1,26208,"用"],[1,26287,"\n"],[1,26362,"4"],[-1,26362,"\n"],[-1,26366,"4"],[1,26378,"*"],[-1,26378,"类"]],[26379,26379],[20964,20964]]],[1543063144664,["gjx16@GJXAIOU",[[1,26374,"![5]($resource/5.png)"]],[26374,26374],[26396,26396]]],[1543063153470,["gjx16@GJXAIOU",[[1,26396,"\n"]],[26395,26395],[26396,26396]]],[1543063155658,["gjx16@GJXAIOU",[[1,26374,"- \n"]],[26373,26373],[26376,26376]]],[1543063157923,["gjx16@GJXAIOU",[[-1,26374,"- "]],[26376,26376],[26374,26374]]],[1543063355947,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"],[-1,21904,"/"],[1,21905,"总"],[-1,21982," "],[1,21983,"A"],[-1,22007,"\n"],[1,22012,"t"],[-1,22025," "],[1,22026,"t"],[-1,22039," "],[1,22040,"t"],[-1,22053," "],[1,22101,"\""],[-1,22121,")"],[1,22129,"~"],[-1,22135," "],[-1,22203,""],[1,22203,"}"],[-1,22226," "],[1,22227,"i"],[-1,22234," "],[1,22235,"i"],[-1,22242," "],[1,22243,"i"],[-1,22274," "],[1,22275,"M"],[-1,22312,"\n"],[1,22316,"M"],[-1,22322," "],[1,22326,"c"],[-1,22347," "],[1,22348,"}"],[-1,22352,"~"],[1,22353,"M"],[-1,22355,"("],[1,22363,"c"],[-1,22370,"~"],[1,22371,"M"],[-1,22385," "],[1,22386,"}"],[-1,22409," "],[1,22410,"A"],[-1,22439,"\n"],[1,22441,"A"],[-1,22466,";"],[1,22467,"\n"],[-1,22481," "],[1,22482,"M"],[-1,22489,"\n"],[1,22492,"r"],[-1,22509,"m"],[1,22519,"("],[-1,22524," "],[1,22525,"r"],[-1,22531,"\n"],[1,22533,"s"],[-1,22550," "],[1,22551,"r"],[-1,22753,"析"],[1,22755,"综"],[-1,22760,"\n"],[-1,24863,"d"],[1,24865,"\n*"],[-1,24954,"d"],[1,24955,""],[1,25473," "],[-1,25495,"\n"],[-1,25502,"*"],[1,25503,"\n"],[1,25599,"对"],[-1,25608,"*"],[1,25609,"\n"],[-1,25613," "],[1,25615,"n"],[-1,25617,"**"],[1,25619,"和d"],[-1,25624,"*"],[1,25625,"基"],[-1,25632,"1"],[1,25635,"1"],[-1,25760,"注"],[1,25765,"注"],[-1,25796,"\n"],[-1,25800,"2"],[1,25801,"\n"],[1,25803,"2"],[-1,25883,"n"],[1,25885,"n"],[-1,25988,"n"],[1,25990,"n"],[-1,26038,"n"],[1,26042,"n"],[-1,26178," "],[1,26180," "],[-1,26205,"\n"],[1,26208,"用"],[-1,26286,"\n"],[-1,26362,"4"],[1,26363,"\n"],[1,26366,"4"],[-1,26372,"\n"],[1,26396,"\n\n"],[-1,26397,"\n"],[-1,26400,"*"],[1,26401,"类"]],[20964,20964],[26402,26402]]],[1543063355947,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"],[1,21905,"/"],[-1,21905,"总"],[1,21983," "],[-1,21983,"A"],[1,22008,"\n"],[-1,22012,"t"],[1,22026," "],[-1,22026,"t"],[1,22040," "],[-1,22040,"t"],[1,22054," "],[-1,22101,"\""],[1,22122,")"],[-1,22129,"~"],[1,22136," "],[1,22203,""],[-1,22203,"}"],[1,22227," "],[-1,22227,"i"],[1,22235," "],[-1,22235,"i"],[1,22243," "],[-1,22243,"i"],[1,22275," "],[-1,22275,"M"],[1,22313,"\n"],[-1,22316,"M"],[1,22323," "],[-1,22326,"c"],[1,22348," "],[-1,22348,"}"],[1,22353,"~"],[-1,22353,"M"],[1,22356,"("],[-1,22363,"c"],[1,22371,"~"],[-1,22371,"M"],[1,22386," "],[-1,22386,"}"],[1,22410," "],[-1,22410,"A"],[1,22440,"\n"],[-1,22441,"A"],[1,22467,";"],[-1,22467,"\n"],[1,22482," "],[-1,22482,"M"],[1,22490,"\n"],[-1,22492,"r"],[1,22510,"m"],[-1,22519,"("],[1,22525," "],[-1,22525,"r"],[1,22532,"\n"],[-1,22533,"s"],[1,22551," "],[-1,22551,"r"],[1,22754,"析"],[-1,22755,"综"],[1,22761,"\n"],[1,24863,"d"],[-1,24864,"\n*"],[1,24955,"d"],[-1,24955,""],[-1,25473," "],[1,25496,"\n"],[1,25502,"*"],[-1,25502,"\n"],[-1,25599,"对"],[1,25609,"*"],[-1,25609,"\n"],[1,25614," "],[-1,25615,"n"],[1,25618,"**"],[-1,25618,"和d"],[1,25625,"*"],[-1,25625,"基"],[1,25633,"1"],[-1,25635,"1"],[1,25761,"注"],[-1,25765,"注"],[1,25797,"\n"],[1,25800,"2"],[-1,25800,"\n"],[-1,25803,"2"],[1,25884,"n"],[-1,25885,"n"],[1,25989,"n"],[-1,25990,"n"],[1,26039,"n"],[-1,26042,"n"],[1,26179," "],[-1,26180," "],[1,26206,"\n"],[-1,26208,"用"],[1,26287,"\n"],[1,26362,"4"],[-1,26362,"\n"],[-1,26366,"4"],[1,26373,"\n"],[-1,26396,"\n\n"],[1,26399,"\n"],[1,26401,"*"],[-1,26401,"类"]],[26402,26402],[20964,20964]]],[1543063330344,["gjx16@GJXAIOU",[[1,26416,"- "]],[26416,26416],[26418,26418]]],[1543063336150,["gjx16@GJXAIOU",[[1,26528,"-"]],[26528,26528],[26529,26529]]],[1543063336521,["gjx16@GJXAIOU",[[1,26530," "]],[26529,26529],[26530,26530]]],[1543063339971,["gjx16@GJXAIOU",[[1,26568,"  "]],[26568,26568],[26570,26570]]],[1543063341989,["gjx16@GJXAIOU",[[1,26576,"  "]],[26576,26576],[26578,26578]]],[1543063345862,["gjx16@GJXAIOU",[[-1,26576,"  "]],[26578,26578],[26576,26576]]],[1543063347504,["gjx16@GJXAIOU",[[1,26575,"  "]],[26575,26575],[26577,26577]]],[1543063355214,["gjx16@GJXAIOU",[[1,26613,"  "]],[26612,26612],[26614,26614]]],[1543063415928,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"],[-1,21904,"/"],[1,21905,"总"],[-1,21982," "],[1,21983,"A"],[-1,22007,"\n"],[1,22012,"t"],[-1,22025," "],[1,22026,"t"],[-1,22039," "],[1,22040,"t"],[-1,22053," "],[1,22101,"\""],[-1,22121,")"],[1,22129,"~"],[-1,22135," "],[-1,22203,""],[1,22203,"}"],[-1,22226," "],[1,22227,"i"],[-1,22234," "],[1,22235,"i"],[-1,22242," "],[1,22243,"i"],[-1,22274," "],[1,22275,"M"],[-1,22312,"\n"],[1,22316,"M"],[-1,22322," "],[1,22326,"c"],[-1,22347," "],[1,22348,"}"],[-1,22352,"~"],[1,22353,"M"],[-1,22355,"("],[1,22363,"c"],[-1,22370,"~"],[1,22371,"M"],[-1,22385," "],[1,22386,"}"],[-1,22409," "],[1,22410,"A"],[-1,22439,"\n"],[1,22441,"A"],[-1,22466,";"],[1,22467,"\n"],[-1,22481," "],[1,22482,"M"],[-1,22489,"\n"],[1,22492,"r"],[-1,22509,"m"],[1,22519,"("],[-1,22524," "],[1,22525,"r"],[-1,22531,"\n"],[1,22533,"s"],[-1,22550," "],[1,22551,"r"],[-1,22753,"析"],[1,22755,"综"],[-1,22760,"\n"],[-1,24863,"d"],[1,24865,"\n*"],[-1,24954,"d"],[1,24955,""],[1,25473," "],[-1,25495,"\n"],[-1,25502,"*"],[1,25503,"\n"],[1,25599,"对"],[-1,25608,"*"],[1,25609,"\n"],[-1,25613," "],[1,25615,"n"],[-1,25617,"**"],[1,25619,"和d"],[-1,25624,"*"],[1,25625,"基"],[-1,25632,"1"],[1,25635,"1"],[-1,25760,"注"],[1,25765,"注"],[-1,25796,"\n"],[-1,25800,"2"],[1,25801,"\n"],[1,25803,"2"],[-1,25883,"n"],[1,25885,"n"],[-1,25988,"n"],[1,25990,"n"],[-1,26038,"n"],[1,26042,"n"],[-1,26178," "],[1,26180," "],[-1,26204,"\n"],[1,26208,"用"],[-1,26286,"\n"],[-1,26362,"4"],[1,26363,"\n"],[1,26366,"4"],[-1,26372,"\n"],[-1,26396,"*\n*2*"],[1,26401,"\n\n**2类"],[-1,26415,"使"],[1,26418,"使"],[-1,26527," "],[-1,26529,"C"],[1,26531," C"],[-1,26567,"比"],[1,26570,"比"],[-1,26574,"B"],[1,26577,"B"],[-1,26612,"p"],[1,26615,"p"]],[20964,20964],[26616,26616]]],[1543063415928,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"],[1,21905,"/"],[-1,21905,"总"],[1,21983," "],[-1,21983,"A"],[1,22008,"\n"],[-1,22012,"t"],[1,22026," "],[-1,22026,"t"],[1,22040," "],[-1,22040,"t"],[1,22054," "],[-1,22101,"\""],[1,22122,")"],[-1,22129,"~"],[1,22136," "],[1,22203,""],[-1,22203,"}"],[1,22227," "],[-1,22227,"i"],[1,22235," "],[-1,22235,"i"],[1,22243," "],[-1,22243,"i"],[1,22275," "],[-1,22275,"M"],[1,22313,"\n"],[-1,22316,"M"],[1,22323," "],[-1,22326,"c"],[1,22348," "],[-1,22348,"}"],[1,22353,"~"],[-1,22353,"M"],[1,22356,"("],[-1,22363,"c"],[1,22371,"~"],[-1,22371,"M"],[1,22386," "],[-1,22386,"}"],[1,22410," "],[-1,22410,"A"],[1,22440,"\n"],[-1,22441,"A"],[1,22467,";"],[-1,22467,"\n"],[1,22482," "],[-1,22482,"M"],[1,22490,"\n"],[-1,22492,"r"],[1,22510,"m"],[-1,22519,"("],[1,22525," "],[-1,22525,"r"],[1,22532,"\n"],[-1,22533,"s"],[1,22551," "],[-1,22551,"r"],[1,22754,"析"],[-1,22755,"综"],[1,22761,"\n"],[1,24863,"d"],[-1,24864,"\n*"],[1,24955,"d"],[-1,24955,""],[-1,25473," "],[1,25496,"\n"],[1,25502,"*"],[-1,25502,"\n"],[-1,25599,"对"],[1,25609,"*"],[-1,25609,"\n"],[1,25614," "],[-1,25615,"n"],[1,25618,"**"],[-1,25618,"和d"],[1,25625,"*"],[-1,25625,"基"],[1,25633,"1"],[-1,25635,"1"],[1,25761,"注"],[-1,25765,"注"],[1,25797,"\n"],[1,25800,"2"],[-1,25800,"\n"],[-1,25803,"2"],[1,25884,"n"],[-1,25885,"n"],[1,25989,"n"],[-1,25990,"n"],[1,26039,"n"],[-1,26042,"n"],[1,26179," "],[-1,26180," "],[1,26205,"\n"],[-1,26208,"用"],[1,26287,"\n"],[1,26362,"4"],[-1,26362,"\n"],[-1,26366,"4"],[1,26373,"\n"],[1,26396,"*\n*2*"],[-1,26396,"\n\n**2类"],[1,26416,"使"],[-1,26418,"使"],[1,26528," "],[1,26529,"C"],[-1,26530," C"],[1,26568,"比"],[-1,26570,"比"],[1,26575,"B"],[-1,26577,"B"],[1,26613,"p"],[-1,26615,"p"]],[26616,26616],[20964,20964]]],[1543063357973,["gjx16@GJXAIOU",[[1,26811,"    "]],[26811,26811],[26815,26815]]],[1543063360184,["gjx16@GJXAIOU",[[-1,26814," "]],[26815,26815],[26814,26814]]],[1543063363552,["gjx16@GJXAIOU",[[1,26866,"  "]],[26866,26866],[26868,26868]]],[1543063365519,["gjx16@GJXAIOU",[[1,26932,"  "]],[26932,26932],[26934,26934]]],[1543063367761,["gjx16@GJXAIOU",[[-1,26933," "]],[26934,26934],[26933,26933]]],[1543063381718,["gjx16@GJXAIOU",[[-1,27312,"** **"]],[27312,27317],[27312,27312]]],[1543063384751,["gjx16@GJXAIOU",[[1,27312,"。"]],[27312,27312],[27313,27313]]],[1543063386105,["gjx16@GJXAIOU",[[-1,27312,"。"]],[27313,27313],[27312,27312]]],[1543063386737,["gjx16@GJXAIOU",[[1,27312,"."]],[27312,27312],[27313,27313]]],[1543063390632,["gjx16@GJXAIOU",[[1,27320,"```"]],[27320,27320],[27323,27323]]],[1543063390719,["gjx16@GJXAIOU",[[1,27323,"language\n```\n"]],[27323,27323],[27323,27331]]],[1543063392938,["gjx16@GJXAIOU",[[-1,27323,"language"],[1,27331,"c"]],[27323,27331],[27324,27324]]],[1543063393638,["gjx16@GJXAIOU",[[1,27324,"pp"]],[27324,27324],[27326,27326]]],[1543063395139,["gjx16@GJXAIOU",[[1,27327,"\n"]],[27326,27326],[27327,27327]]],[1543063399240,["gjx16@GJXAIOU",[[-1,27328,"```"]],[27328,27331],[27328,27328]]],[1543063476025,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"],[-1,21904,"/"],[1,21905,"总"],[-1,21982," "],[1,21983,"A"],[-1,22007,"\n"],[1,22012,"t"],[-1,22025," "],[1,22026,"t"],[-1,22039," "],[1,22040,"t"],[-1,22053," "],[1,22101,"\""],[-1,22121,")"],[1,22129,"~"],[-1,22135," "],[-1,22203,""],[1,22203,"}"],[-1,22226," "],[1,22227,"i"],[-1,22234," "],[1,22235,"i"],[-1,22242," "],[1,22243,"i"],[-1,22274," "],[1,22275,"M"],[-1,22312,"\n"],[1,22316,"M"],[-1,22322," "],[1,22326,"c"],[-1,22347," "],[1,22348,"}"],[-1,22352,"~"],[1,22353,"M"],[-1,22355,"("],[1,22363,"c"],[-1,22370,"~"],[1,22371,"M"],[-1,22385," "],[1,22386,"}"],[-1,22409," "],[1,22410,"A"],[-1,22438,"\n"],[1,22441,"A"],[-1,22466,";"],[1,22467,"\n"],[-1,22481," "],[1,22482,"M"],[-1,22490,"\n"],[1,22492,"r"],[-1,22509,"m"],[1,22519,"("],[-1,22524," "],[1,22525,"r"],[-1,22531,"\n"],[1,22533,"s"],[-1,22550," "],[1,22551,"r"],[-1,22753,"析"],[1,22755,"综"],[-1,22760,"\n"],[-1,24863,"d"],[1,24865,"\n*"],[-1,24954,"d"],[1,24955,""],[1,25473," "],[-1,25495,"\n"],[-1,25502,"*"],[1,25503,"\n"],[1,25599,"对"],[-1,25608,"*"],[1,25609,"\n"],[-1,25613," "],[1,25615,"n"],[-1,25617,"**"],[1,25619,"和d"],[-1,25624,"*"],[1,25625,"基"],[-1,25632,"1"],[1,25635,"1"],[-1,25760,"注"],[1,25765,"注"],[-1,25796,"\n"],[-1,25800,"2"],[1,25801,"\n"],[1,25803,"2"],[1,25883,"\n"],[-1,25884,"\n"],[-1,25988,"n"],[1,25990,"n"],[-1,26038,"n"],[1,26042,"n"],[-1,26178," "],[1,26180," "],[-1,26205,"\n"],[1,26208,"用"],[-1,26286,"\n"],[-1,26362,"4"],[1,26363,"\n"],[1,26366,"4"],[-1,26372,"\n"],[-1,26396,"*"],[1,26397,"\n"],[-1,26399,"2"],[1,26401,"2类"],[-1,26415,"使"],[1,26418,"使"],[-1,26527," "],[1,26529,"  "],[-1,26530," "],[-1,26567,"比"],[1,26570,"比"],[-1,26574,"B"],[1,26577,"B"],[-1,26612,"p"],[1,26615,"p"],[-1,26810,"这"],[1,26814,"这"],[-1,26865,"新"],[1,26868,"新"],[-1,26931,"在"],[1,26933,"在"],[-1,27311,"*"],[1,27313,"编"],[-1,27319,"\n"],[1,27326,"\n"]],[20964,20964],[27327,27327]]],[1543063476026,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"],[1,21905,"/"],[-1,21905,"总"],[1,21983," "],[-1,21983,"A"],[1,22008,"\n"],[-1,22012,"t"],[1,22026," "],[-1,22026,"t"],[1,22040," "],[-1,22040,"t"],[1,22054," "],[-1,22101,"\""],[1,22122,")"],[-1,22129,"~"],[1,22136," "],[1,22203,""],[-1,22203,"}"],[1,22227," "],[-1,22227,"i"],[1,22235," "],[-1,22235,"i"],[1,22243," "],[-1,22243,"i"],[1,22275," "],[-1,22275,"M"],[1,22313,"\n"],[-1,22316,"M"],[1,22323," "],[-1,22326,"c"],[1,22348," "],[-1,22348,"}"],[1,22353,"~"],[-1,22353,"M"],[1,22356,"("],[-1,22363,"c"],[1,22371,"~"],[-1,22371,"M"],[1,22386," "],[-1,22386,"}"],[1,22410," "],[-1,22410,"A"],[1,22439,"\n"],[-1,22441,"A"],[1,22467,";"],[-1,22467,"\n"],[1,22482," "],[-1,22482,"M"],[1,22491,"\n"],[-1,22492,"r"],[1,22510,"m"],[-1,22519,"("],[1,22525," "],[-1,22525,"r"],[1,22532,"\n"],[-1,22533,"s"],[1,22551," "],[-1,22551,"r"],[1,22754,"析"],[-1,22755,"综"],[1,22761,"\n"],[1,24863,"d"],[-1,24864,"\n*"],[1,24955,"d"],[-1,24955,""],[-1,25473," "],[1,25496,"\n"],[1,25502,"*"],[-1,25502,"\n"],[-1,25599,"对"],[1,25609,"*"],[-1,25609,"\n"],[1,25614," "],[-1,25615,"n"],[1,25618,"**"],[-1,25618,"和d"],[1,25625,"*"],[-1,25625,"基"],[1,25633,"1"],[-1,25635,"1"],[1,25761,"注"],[-1,25765,"注"],[1,25797,"\n"],[1,25800,"2"],[-1,25800,"\n"],[-1,25803,"2"],[-1,25884,"\n"],[1,25886,"\n"],[1,25989,"n"],[-1,25990,"n"],[1,26039,"n"],[-1,26042,"n"],[1,26179," "],[-1,26180," "],[1,26206,"\n"],[-1,26208,"用"],[1,26287,"\n"],[1,26362,"4"],[-1,26362,"\n"],[-1,26366,"4"],[1,26373,"\n"],[1,26396,"*"],[-1,26396,"\n"],[1,26399,"2"],[-1,26400,"2类"],[1,26416,"使"],[-1,26418,"使"],[1,26528," "],[-1,26529,"  "],[1,26532," "],[1,26568,"比"],[-1,26570,"比"],[1,26575,"B"],[-1,26577,"B"],[1,26613,"p"],[-1,26615,"p"],[1,26811,"这"],[-1,26814,"这"],[1,26866,"新"],[-1,26868,"新"],[1,26932,"在"],[-1,26933,"在"],[1,27312,"*"],[-1,27313,"编"],[1,27320,"\n"],[-1,27326,"\n"]],[27327,27327],[20964,20964]]],[1543063459746,["gjx16@GJXAIOU",[[-1,27329,"\n"]],[27329,27329],[27328,27328]]],[1543063460051,["gjx16@GJXAIOU",[[-1,27328,"\n"]],[27328,27328],[27327,27327]]],[1543063461022,["gjx16@GJXAIOU",[[-1,27327,"\n"]],[27327,27327],[27326,27326]]],[1543063464848,["gjx16@GJXAIOU",[[-1,27320,"```cpp"]],[27326,27326],[27320,27320]]],[1543065336022,[null,[[-1,20964,"\n"],[1,20965,"："],[1,20977,"\n"],[-1,21904,"/"],[1,21905,"总"],[-1,21982," "],[1,21983,"A"],[-1,22007,"\n"],[1,22012,"t"],[-1,22025," "],[1,22026,"t"],[-1,22039," "],[1,22040,"t"],[-1,22053," "],[1,22101,"\""],[-1,22121,")"],[1,22129,"~"],[-1,22135," "],[-1,22203,""],[1,22203,"}"],[-1,22226," "],[1,22227,"i"],[-1,22234," "],[1,22235,"i"],[-1,22242," "],[1,22243,"i"],[-1,22274," "],[1,22275,"M"],[-1,22312,"\n"],[1,22316,"M"],[-1,22322," "],[1,22326,"c"],[-1,22347," "],[1,22348,"}"],[-1,22352,"~"],[1,22353,"M"],[-1,22355,"("],[1,22363,"c"],[-1,22370,"~"],[1,22371,"M"],[-1,22385," "],[1,22386,"}"],[-1,22409," "],[1,22410,"A"],[-1,22438,"\n"],[1,22441,"A"],[-1,22466,";"],[1,22467,"\n"],[-1,22481," "],[1,22482,"M"],[-1,22490,"\n"],[1,22492,"r"],[-1,22509,"m"],[1,22519,"("],[-1,22524," "],[1,22525,"r"],[-1,22531,"\n"],[1,22533,"s"],[-1,22550," "],[1,22551,"r"],[-1,22753,"析"],[1,22755,"综"],[-1,22760,"\n"],[-1,24863,"d"],[1,24865,"\n*"],[-1,24954,"d"],[1,24955,""],[1,25473," "],[-1,25495,"\n"],[-1,25502,"*"],[1,25503,"\n"],[1,25599,"对"],[-1,25608,"*"],[1,25609,"\n"],[-1,25613," "],[1,25615,"n"],[-1,25617,"**"],[1,25619,"和d"],[-1,25624,"*"],[1,25625,"基"],[-1,25632,"1"],[1,25635,"1"],[-1,25760,"注"],[1,25765,"注"],[-1,25796,"\n"],[-1,25800,"2"],[1,25801,"\n"],[1,25803,"2"],[1,25883,"\n"],[-1,25884,"\n"],[-1,25988,"n"],[1,25990,"n"],[-1,26038,"n"],[1,26042,"n"],[-1,26178," "],[1,26180," "],[-1,26205,"\n"],[1,26208,"用"],[-1,26286,"\n"],[-1,26362,"4"],[1,26363,"\n"],[1,26366,"4"],[-1,26372,"\n"],[-1,26396,"*"],[1,26397,"\n"],[-1,26399,"2"],[1,26401,"2类"],[-1,26415,"使"],[1,26418,"使"],[-1,26527," "],[1,26529,"  "],[-1,26530," "],[-1,26567,"比"],[1,26570,"比"],[-1,26574,"B"],[1,26577,"B"],[-1,26612,"p"],[1,26615,"p"],[-1,26810,"这"],[1,26814,"这"],[-1,26865,"新"],[1,26868,"新"],[-1,26931,"在"],[1,26933,"在"],[-1,27311,"*"],[1,27313,"编"],[-1,27320,"\n"],[1,27321,"/"]],[20964,20964],[27322,27322]]],[1543065336022,[null,[[1,20964,"\n"],[-1,20964,"："],[-1,20977,"\n"],[1,21905,"/"],[-1,21905,"总"],[1,21983," "],[-1,21983,"A"],[1,22008,"\n"],[-1,22012,"t"],[1,22026," "],[-1,22026,"t"],[1,22040," "],[-1,22040,"t"],[1,22054," "],[-1,22101,"\""],[1,22122,")"],[-1,22129,"~"],[1,22136," "],[1,22203,""],[-1,22203,"}"],[1,22227," "],[-1,22227,"i"],[1,22235," "],[-1,22235,"i"],[1,22243," "],[-1,22243,"i"],[1,22275," "],[-1,22275,"M"],[1,22313,"\n"],[-1,22316,"M"],[1,22323," "],[-1,22326,"c"],[1,22348," "],[-1,22348,"}"],[1,22353,"~"],[-1,22353,"M"],[1,22356,"("],[-1,22363,"c"],[1,22371,"~"],[-1,22371,"M"],[1,22386," "],[-1,22386,"}"],[1,22410," "],[-1,22410,"A"],[1,22439,"\n"],[-1,22441,"A"],[1,22467,";"],[-1,22467,"\n"],[1,22482," "],[-1,22482,"M"],[1,22491,"\n"],[-1,22492,"r"],[1,22510,"m"],[-1,22519,"("],[1,22525," "],[-1,22525,"r"],[1,22532,"\n"],[-1,22533,"s"],[1,22551," "],[-1,22551,"r"],[1,22754,"析"],[-1,22755,"综"],[1,22761,"\n"],[1,24863,"d"],[-1,24864,"\n*"],[1,24955,"d"],[-1,24955,""],[-1,25473," "],[1,25496,"\n"],[1,25502,"*"],[-1,25502,"\n"],[-1,25599,"对"],[1,25609,"*"],[-1,25609,"\n"],[1,25614," "],[-1,25615,"n"],[1,25618,"**"],[-1,25618,"和d"],[1,25625,"*"],[-1,25625,"基"],[1,25633,"1"],[-1,25635,"1"],[1,25761,"注"],[-1,25765,"注"],[1,25797,"\n"],[1,25800,"2"],[-1,25800,"\n"],[-1,25803,"2"],[-1,25884,"\n"],[1,25886,"\n"],[1,25989,"n"],[-1,25990,"n"],[1,26039,"n"],[-1,26042,"n"],[1,26179," "],[-1,26180," "],[1,26206,"\n"],[-1,26208,"用"],[1,26287,"\n"],[1,26362,"4"],[-1,26362,"\n"],[-1,26366,"4"],[1,26373,"\n"],[1,26396,"*"],[-1,26396,"\n"],[1,26399,"2"],[-1,26400,"2类"],[1,26416,"使"],[-1,26418,"使"],[1,26528," "],[-1,26529,"  "],[1,26532," "],[1,26568,"比"],[-1,26570,"比"],[1,26575,"B"],[-1,26577,"B"],[1,26613,"p"],[-1,26615,"p"],[1,26811,"这"],[-1,26814,"这"],[1,26866,"新"],[-1,26868,"新"],[1,26932,"在"],[-1,26933,"在"],[1,27312,"*"],[-1,27313,"编"],[1,27321,"\n"],[-1,27321,"/"]],[27322,27322],[20964,20964]]],[1543065322258,["gjx16@GJXAIOU",[[1,143,";"]],[143,143],[144,144]]],[1543065327626,["gjx16@GJXAIOU",[[1,161,";"]],[161,161],[162,162]]],[1543065331131,["gjx16@GJXAIOU",[[1,183,";"]],[183,183],[184,184]]],[1543065333754,["gjx16@GJXAIOU",[[1,195,";"]],[195,195],[196,196]]],[1543065396022,[null,[[-1,20968,"\n"],[1,20969,"："],[1,20981,"\n"],[-1,21908,"/"],[1,21909,"总"],[-1,21986," "],[1,21987,"A"],[-1,22011,"\n"],[1,22016,"t"],[-1,22029," "],[1,22030,"t"],[-1,22043," "],[1,22044,"t"],[-1,22057," "],[1,22105,"\""],[-1,22125,")"],[1,22133,"~"],[-1,22139," "],[-1,22207,""],[1,22207,"}"],[-1,22230," "],[1,22231,"i"],[-1,22238," "],[1,22239,"i"],[-1,22246," "],[1,22247,"i"],[-1,22278," "],[1,22279,"M"],[-1,22316,"\n"],[1,22320,"M"],[-1,22326," "],[1,22330,"c"],[-1,22351," "],[1,22352,"}"],[-1,22356,"~"],[1,22357,"M"],[-1,22359,"("],[1,22367,"c"],[-1,22374,"~"],[1,22375,"M"],[-1,22389," "],[1,22390,"}"],[-1,22413," "],[1,22414,"A"],[-1,22442,"\n"],[1,22445,"A"],[-1,22470,";"],[1,22471,"\n"],[-1,22485," "],[1,22486,"M"],[-1,22494,"\n"],[1,22496,"r"],[-1,22513,"m"],[1,22523,"("],[-1,22528," "],[1,22529,"r"],[-1,22535,"\n"],[1,22537,"s"],[-1,22554," "],[1,22555,"r"],[-1,22757,"析"],[1,22759,"综"],[-1,22764,"\n"],[-1,24867,"d"],[1,24869,"\n*"],[-1,24958,"d"],[1,24959,""],[1,25477," "],[-1,25499,"\n"],[-1,25506,"*"],[1,25507,"\n"],[1,25603,"对"],[-1,25612,"*"],[1,25613,"\n"],[-1,25617," "],[1,25619,"n"],[-1,25621,"**"],[1,25623,"和d"],[-1,25628,"*"],[1,25629,"基"],[-1,25636,"1"],[1,25639,"1"],[-1,25764,"注"],[1,25769,"注"],[-1,25800,"\n"],[-1,25804,"2"],[1,25805,"\n"],[1,25807,"2"],[1,25887,"\n"],[-1,25888,"\n"],[-1,25992,"n"],[1,25994,"n"],[-1,26042,"n"],[1,26046,"n"],[-1,26182," "],[1,26184," "],[-1,26209,"\n"],[1,26212,"用"],[-1,26290,"\n"],[-1,26366,"4"],[1,26367,"\n"],[1,26370,"4"],[-1,26376,"\n"],[-1,26400,"*"],[1,26401,"\n"],[-1,26403,"2"],[1,26405,"2类"],[-1,26419,"使"],[1,26422,"使"],[-1,26531," "],[1,26533,"  "],[-1,26534," "],[-1,26571,"比"],[1,26574,"比"],[-1,26578,"B"],[1,26581,"B"],[-1,26616,"p"],[1,26619,"p"],[-1,26814,"这"],[1,26818,"这"],[-1,26869,"新"],[1,26872,"新"],[-1,26935,"在"],[1,26937,"在"],[-1,27315,"*"],[1,27317,"编"],[-1,27324,"\n"],[1,27325,"/"]],[20968,20968],[27326,27326]]],[1543065396022,[null,[[1,20968,"\n"],[-1,20968,"："],[-1,20981,"\n"],[1,21909,"/"],[-1,21909,"总"],[1,21987," "],[-1,21987,"A"],[1,22012,"\n"],[-1,22016,"t"],[1,22030," "],[-1,22030,"t"],[1,22044," "],[-1,22044,"t"],[1,22058," "],[-1,22105,"\""],[1,22126,")"],[-1,22133,"~"],[1,22140," "],[1,22207,""],[-1,22207,"}"],[1,22231," "],[-1,22231,"i"],[1,22239," "],[-1,22239,"i"],[1,22247," "],[-1,22247,"i"],[1,22279," "],[-1,22279,"M"],[1,22317,"\n"],[-1,22320,"M"],[1,22327," "],[-1,22330,"c"],[1,22352," "],[-1,22352,"}"],[1,22357,"~"],[-1,22357,"M"],[1,22360,"("],[-1,22367,"c"],[1,22375,"~"],[-1,22375,"M"],[1,22390," "],[-1,22390,"}"],[1,22414," "],[-1,22414,"A"],[1,22443,"\n"],[-1,22445,"A"],[1,22471,";"],[-1,22471,"\n"],[1,22486," "],[-1,22486,"M"],[1,22495,"\n"],[-1,22496,"r"],[1,22514,"m"],[-1,22523,"("],[1,22529," "],[-1,22529,"r"],[1,22536,"\n"],[-1,22537,"s"],[1,22555," "],[-1,22555,"r"],[1,22758,"析"],[-1,22759,"综"],[1,22765,"\n"],[1,24867,"d"],[-1,24868,"\n*"],[1,24959,"d"],[-1,24959,""],[-1,25477," "],[1,25500,"\n"],[1,25506,"*"],[-1,25506,"\n"],[-1,25603,"对"],[1,25613,"*"],[-1,25613,"\n"],[1,25618," "],[-1,25619,"n"],[1,25622,"**"],[-1,25622,"和d"],[1,25629,"*"],[-1,25629,"基"],[1,25637,"1"],[-1,25639,"1"],[1,25765,"注"],[-1,25769,"注"],[1,25801,"\n"],[1,25804,"2"],[-1,25804,"\n"],[-1,25807,"2"],[-1,25888,"\n"],[1,25890,"\n"],[1,25993,"n"],[-1,25994,"n"],[1,26043,"n"],[-1,26046,"n"],[1,26183," "],[-1,26184," "],[1,26210,"\n"],[-1,26212,"用"],[1,26291,"\n"],[1,26366,"4"],[-1,26366,"\n"],[-1,26370,"4"],[1,26377,"\n"],[1,26400,"*"],[-1,26400,"\n"],[1,26403,"2"],[-1,26404,"2类"],[1,26420,"使"],[-1,26422,"使"],[1,26532," "],[-1,26533,"  "],[1,26536," "],[1,26572,"比"],[-1,26574,"比"],[1,26579,"B"],[-1,26581,"B"],[1,26617,"p"],[-1,26619,"p"],[1,26815,"这"],[-1,26818,"这"],[1,26870,"新"],[-1,26872,"新"],[1,26936,"在"],[-1,26937,"在"],[1,27316,"*"],[-1,27317,"编"],[1,27325,"\n"],[-1,27325,"/"]],[27326,27326],[20968,20968]]],[1543065353657,["gjx16@GJXAIOU",[[1,233,"习完毕以后，有没有一个标准，来判断自己有没有入门。"]],[208,233],[233,233]]],[1543065357546,["gjx16@GJXAIOU",[[-1,198,"- C++基础课程学习完毕以后，有没有一个标准，来判断自己有没有入门。习完毕以后，有没有一个标准，来判断自己有没有入门。"]],[198,258],[198,198]]],[1543065358454,["gjx16@GJXAIOU",[[-1,198,"\n"]],[198,198],[197,197]]],[1543065359229,["gjx16@GJXAIOU",[[-1,197,"\n"]],[197,197],[196,196]]],[1543066236019,[null,[[-1,20931,"\n"],[1,20932,"："],[1,20944,"\n"],[-1,21871,"/"],[1,21872,"总"],[-1,21949," "],[1,21950,"A"],[-1,21974,"\n"],[1,21979,"t"],[-1,21992," "],[1,21993,"t"],[-1,22006," "],[1,22007,"t"],[-1,22020," "],[1,22068,"\""],[-1,22088,")"],[1,22096,"~"],[-1,22102," "],[-1,22170,""],[1,22170,"}"],[-1,22193," "],[1,22194,"i"],[-1,22201," "],[1,22202,"i"],[-1,22209," "],[1,22210,"i"],[-1,22241," "],[1,22242,"M"],[-1,22279,"\n"],[1,22283,"M"],[-1,22289," "],[1,22293,"c"],[-1,22314," "],[1,22315,"}"],[-1,22319,"~"],[1,22320,"M"],[-1,22322,"("],[1,22330,"c"],[-1,22337,"~"],[1,22338,"M"],[-1,22352," "],[1,22353,"}"],[-1,22376," "],[1,22377,"A"],[-1,22405,"\n"],[1,22408,"A"],[-1,22433,";"],[1,22434,"\n"],[-1,22448," "],[1,22449,"M"],[-1,22457,"\n"],[1,22459,"r"],[-1,22476,"m"],[1,22486,"("],[-1,22491," "],[1,22492,"r"],[-1,22498,"\n"],[1,22500,"s"],[-1,22517," "],[1,22518,"r"],[-1,22720,"析"],[1,22722,"综"],[-1,22727,"\n"],[-1,24830,"d"],[1,24832,"\n*"],[-1,24921,"d"],[1,24922,""],[1,25440," "],[-1,25462,"\n"],[-1,25469,"*"],[1,25470,"\n"],[1,25566,"对"],[-1,25575,"*"],[1,25576,"\n"],[-1,25580," "],[1,25582,"n"],[-1,25584,"**"],[1,25586,"和d"],[-1,25591,"*"],[1,25592,"基"],[-1,25599,"1"],[1,25602,"1"],[-1,25727,"注"],[1,25732,"注"],[-1,25763,"\n"],[-1,25767,"2"],[1,25768,"\n"],[1,25770,"2"],[1,25850,"\n"],[-1,25851,"\n"],[-1,25955,"n"],[1,25957,"n"],[-1,26005,"n"],[1,26009,"n"],[-1,26145," "],[1,26147," "],[-1,26172,"\n"],[1,26175,"用"],[-1,26253,"\n"],[-1,26329,"4"],[1,26330,"\n"],[1,26333,"4"],[-1,26339,"\n"],[-1,26363,"*"],[1,26364,"\n"],[-1,26366,"2"],[1,26368,"2类"],[-1,26382,"使"],[1,26385,"使"],[-1,26494," "],[1,26496,"  "],[-1,26497," "],[-1,26534,"比"],[1,26537,"比"],[-1,26541,"B"],[1,26544,"B"],[-1,26579,"p"],[1,26582,"p"],[-1,26777,"这"],[1,26781,"这"],[-1,26832,"新"],[1,26835,"新"],[-1,26898,"在"],[1,26900,"在"],[-1,27278,"*"],[1,27280,"编"],[-1,27287,"\n"],[1,27288,"/"]],[20931,20931],[27289,27289]]],[1543066236019,[null,[[1,20931,"\n"],[-1,20931,"："],[-1,20944,"\n"],[1,21872,"/"],[-1,21872,"总"],[1,21950," "],[-1,21950,"A"],[1,21975,"\n"],[-1,21979,"t"],[1,21993," "],[-1,21993,"t"],[1,22007," "],[-1,22007,"t"],[1,22021," "],[-1,22068,"\""],[1,22089,")"],[-1,22096,"~"],[1,22103," "],[1,22170,""],[-1,22170,"}"],[1,22194," "],[-1,22194,"i"],[1,22202," "],[-1,22202,"i"],[1,22210," "],[-1,22210,"i"],[1,22242," "],[-1,22242,"M"],[1,22280,"\n"],[-1,22283,"M"],[1,22290," "],[-1,22293,"c"],[1,22315," "],[-1,22315,"}"],[1,22320,"~"],[-1,22320,"M"],[1,22323,"("],[-1,22330,"c"],[1,22338,"~"],[-1,22338,"M"],[1,22353," "],[-1,22353,"}"],[1,22377," "],[-1,22377,"A"],[1,22406,"\n"],[-1,22408,"A"],[1,22434,";"],[-1,22434,"\n"],[1,22449," "],[-1,22449,"M"],[1,22458,"\n"],[-1,22459,"r"],[1,22477,"m"],[-1,22486,"("],[1,22492," "],[-1,22492,"r"],[1,22499,"\n"],[-1,22500,"s"],[1,22518," "],[-1,22518,"r"],[1,22721,"析"],[-1,22722,"综"],[1,22728,"\n"],[1,24830,"d"],[-1,24831,"\n*"],[1,24922,"d"],[-1,24922,""],[-1,25440," "],[1,25463,"\n"],[1,25469,"*"],[-1,25469,"\n"],[-1,25566,"对"],[1,25576,"*"],[-1,25576,"\n"],[1,25581," "],[-1,25582,"n"],[1,25585,"**"],[-1,25585,"和d"],[1,25592,"*"],[-1,25592,"基"],[1,25600,"1"],[-1,25602,"1"],[1,25728,"注"],[-1,25732,"注"],[1,25764,"\n"],[1,25767,"2"],[-1,25767,"\n"],[-1,25770,"2"],[-1,25851,"\n"],[1,25853,"\n"],[1,25956,"n"],[-1,25957,"n"],[1,26006,"n"],[-1,26009,"n"],[1,26146," "],[-1,26147," "],[1,26173,"\n"],[-1,26175,"用"],[1,26254,"\n"],[1,26329,"4"],[-1,26329,"\n"],[-1,26333,"4"],[1,26340,"\n"],[1,26363,"*"],[-1,26363,"\n"],[1,26366,"2"],[-1,26367,"2类"],[1,26383,"使"],[-1,26385,"使"],[1,26495," "],[-1,26496,"  "],[1,26499," "],[1,26535,"比"],[-1,26537,"比"],[1,26542,"B"],[-1,26544,"B"],[1,26580,"p"],[-1,26582,"p"],[1,26778,"这"],[-1,26781,"这"],[1,26833,"新"],[-1,26835,"新"],[1,26899,"在"],[-1,26900,"在"],[1,27279,"*"],[-1,27280,"编"],[1,27288,"\n"],[-1,27288,"/"]],[27289,27289],[20931,20931]]],[1543066206005,["gjx16@GJXAIOU",[[1,1389,"//定义两个对象c2"]],[1389,1389],[1399,1399]]],[1543066206399,["gjx16@GJXAIOU",[[-1,1398,"2"]],[1399,1399],[1398,1398]]],[1543066210781,["gjx16@GJXAIOU",[[1,1398,"1和c2"]],[1398,1398],[1402,1402]]],[1543066356027,[null,[[-1,20944,"\n"],[1,20945,"："],[1,20957,"\n"],[-1,21884,"/"],[1,21885,"总"],[-1,21962," "],[1,21963,"A"],[-1,21987,"\n"],[1,21992,"t"],[-1,22005," "],[1,22006,"t"],[-1,22019," "],[1,22020,"t"],[-1,22033," "],[1,22081,"\""],[-1,22101,")"],[1,22109,"~"],[-1,22115," "],[-1,22183,""],[1,22183,"}"],[-1,22206," "],[1,22207,"i"],[-1,22214," "],[1,22215,"i"],[-1,22222," "],[1,22223,"i"],[-1,22254," "],[1,22255,"M"],[-1,22292,"\n"],[1,22296,"M"],[-1,22302," "],[1,22306,"c"],[-1,22327," "],[1,22328,"}"],[-1,22332,"~"],[1,22333,"M"],[-1,22335,"("],[1,22343,"c"],[-1,22350,"~"],[1,22351,"M"],[-1,22365," "],[1,22366,"}"],[-1,22389," "],[1,22390,"A"],[-1,22418,"\n"],[1,22421,"A"],[-1,22446,";"],[1,22447,"\n"],[-1,22461," "],[1,22462,"M"],[-1,22470,"\n"],[1,22472,"r"],[-1,22489,"m"],[1,22499,"("],[-1,22504," "],[1,22505,"r"],[-1,22511,"\n"],[1,22513,"s"],[-1,22530," "],[1,22531,"r"],[-1,22733,"析"],[1,22735,"综"],[-1,22740,"\n"],[-1,24843,"d"],[1,24845,"\n*"],[-1,24934,"d"],[1,24935,""],[1,25453," "],[-1,25475,"\n"],[-1,25482,"*"],[1,25483,"\n"],[1,25579,"对"],[-1,25588,"*"],[1,25589,"\n"],[-1,25593," "],[1,25595,"n"],[-1,25597,"**"],[1,25599,"和d"],[-1,25604,"*"],[1,25605,"基"],[-1,25612,"1"],[1,25615,"1"],[-1,25740,"注"],[1,25745,"注"],[-1,25776,"\n"],[-1,25780,"2"],[1,25781,"\n"],[1,25783,"2"],[1,25863,"\n"],[-1,25864,"\n"],[-1,25968,"n"],[1,25970,"n"],[-1,26018,"n"],[1,26022,"n"],[-1,26158," "],[1,26160," "],[-1,26185,"\n"],[1,26188,"用"],[-1,26266,"\n"],[-1,26342,"4"],[1,26343,"\n"],[1,26346,"4"],[-1,26352,"\n"],[-1,26376,"*"],[1,26377,"\n"],[-1,26379,"2"],[1,26381,"2类"],[-1,26395,"使"],[1,26398,"使"],[-1,26507," "],[1,26509,"  "],[-1,26510," "],[-1,26547,"比"],[1,26550,"比"],[-1,26554,"B"],[1,26557,"B"],[-1,26592,"p"],[1,26595,"p"],[-1,26790,"这"],[1,26794,"这"],[-1,26845,"新"],[1,26848,"新"],[-1,26911,"在"],[1,26913,"在"],[-1,27291,"*"],[1,27293,"编"],[-1,27300,"\n"],[1,27301,"/"]],[20944,20944],[27302,27302]]],[1543066356027,[null,[[1,20944,"\n"],[-1,20944,"："],[-1,20957,"\n"],[1,21885,"/"],[-1,21885,"总"],[1,21963," "],[-1,21963,"A"],[1,21988,"\n"],[-1,21992,"t"],[1,22006," "],[-1,22006,"t"],[1,22020," "],[-1,22020,"t"],[1,22034," "],[-1,22081,"\""],[1,22102,")"],[-1,22109,"~"],[1,22116," "],[1,22183,""],[-1,22183,"}"],[1,22207," "],[-1,22207,"i"],[1,22215," "],[-1,22215,"i"],[1,22223," "],[-1,22223,"i"],[1,22255," "],[-1,22255,"M"],[1,22293,"\n"],[-1,22296,"M"],[1,22303," "],[-1,22306,"c"],[1,22328," "],[-1,22328,"}"],[1,22333,"~"],[-1,22333,"M"],[1,22336,"("],[-1,22343,"c"],[1,22351,"~"],[-1,22351,"M"],[1,22366," "],[-1,22366,"}"],[1,22390," "],[-1,22390,"A"],[1,22419,"\n"],[-1,22421,"A"],[1,22447,";"],[-1,22447,"\n"],[1,22462," "],[-1,22462,"M"],[1,22471,"\n"],[-1,22472,"r"],[1,22490,"m"],[-1,22499,"("],[1,22505," "],[-1,22505,"r"],[1,22512,"\n"],[-1,22513,"s"],[1,22531," "],[-1,22531,"r"],[1,22734,"析"],[-1,22735,"综"],[1,22741,"\n"],[1,24843,"d"],[-1,24844,"\n*"],[1,24935,"d"],[-1,24935,""],[-1,25453," "],[1,25476,"\n"],[1,25482,"*"],[-1,25482,"\n"],[-1,25579,"对"],[1,25589,"*"],[-1,25589,"\n"],[1,25594," "],[-1,25595,"n"],[1,25598,"**"],[-1,25598,"和d"],[1,25605,"*"],[-1,25605,"基"],[1,25613,"1"],[-1,25615,"1"],[1,25741,"注"],[-1,25745,"注"],[1,25777,"\n"],[1,25780,"2"],[-1,25780,"\n"],[-1,25783,"2"],[-1,25864,"\n"],[1,25866,"\n"],[1,25969,"n"],[-1,25970,"n"],[1,26019,"n"],[-1,26022,"n"],[1,26159," "],[-1,26160," "],[1,26186,"\n"],[-1,26188,"用"],[1,26267,"\n"],[1,26342,"4"],[-1,26342,"\n"],[-1,26346,"4"],[1,26353,"\n"],[1,26376,"*"],[-1,26376,"\n"],[1,26379,"2"],[-1,26380,"2类"],[1,26396,"使"],[-1,26398,"使"],[1,26508," "],[-1,26509,"  "],[1,26512," "],[1,26548,"比"],[-1,26550,"比"],[1,26555,"B"],[-1,26557,"B"],[1,26593,"p"],[-1,26595,"p"],[1,26791,"这"],[-1,26794,"这"],[1,26846,"新"],[-1,26848,"新"],[1,26912,"在"],[-1,26913,"在"],[1,27292,"*"],[-1,27293,"编"],[1,27301,"\n"],[-1,27301,"/"]],[27302,27302],[20944,20944]]],[1543066336973,["gjx16@GJXAIOU",[[-1,2209,"\n"]],[2209,2209],[2208,2208]]],[1543066337771,["gjx16@GJXAIOU",[[-1,2208,"\n"]],[2208,2208],[2207,2207]]],[1543066338482,["gjx16@GJXAIOU",[[-1,2207,"\n"]],[2207,2207],[2206,2206]]],[1543066416016,[null,[[-1,20941,"\n"],[1,20942,"："],[1,20954,"\n"],[-1,21881,"/"],[1,21882,"总"],[-1,21959," "],[1,21960,"A"],[-1,21984,"\n"],[1,21989,"t"],[-1,22002," "],[1,22003,"t"],[-1,22016," "],[1,22017,"t"],[-1,22030," "],[1,22078,"\""],[-1,22098,")"],[1,22106,"~"],[-1,22112," "],[-1,22180,""],[1,22180,"}"],[-1,22203," "],[1,22204,"i"],[-1,22211," "],[1,22212,"i"],[-1,22219," "],[1,22220,"i"],[-1,22251," "],[1,22252,"M"],[-1,22289,"\n"],[1,22293,"M"],[-1,22299," "],[1,22303,"c"],[-1,22324," "],[1,22325,"}"],[-1,22329,"~"],[1,22330,"M"],[-1,22332,"("],[1,22340,"c"],[-1,22347,"~"],[1,22348,"M"],[-1,22362," "],[1,22363,"}"],[-1,22386," "],[1,22387,"A"],[-1,22415,"\n"],[1,22418,"A"],[-1,22443,";"],[1,22444,"\n"],[-1,22458," "],[1,22459,"M"],[-1,22467,"\n"],[1,22469,"r"],[-1,22486,"m"],[1,22496,"("],[-1,22501," "],[1,22502,"r"],[-1,22508,"\n"],[1,22510,"s"],[-1,22527," "],[1,22528,"r"],[-1,22730,"析"],[1,22732,"综"],[-1,22737,"\n"],[-1,24840,"d"],[1,24842,"\n*"],[-1,24931,"d"],[1,24932,""],[1,25450," "],[-1,25472,"\n"],[-1,25479,"*"],[1,25480,"\n"],[1,25576,"对"],[-1,25585,"*"],[1,25586,"\n"],[-1,25590," "],[1,25592,"n"],[-1,25594,"**"],[1,25596,"和d"],[-1,25601,"*"],[1,25602,"基"],[-1,25609,"1"],[1,25612,"1"],[-1,25737,"注"],[1,25742,"注"],[-1,25773,"\n"],[-1,25777,"2"],[1,25778,"\n"],[1,25780,"2"],[1,25860,"\n"],[-1,25861,"\n"],[-1,25965,"n"],[1,25967,"n"],[-1,26015,"n"],[1,26019,"n"],[-1,26155," "],[1,26157," "],[-1,26182,"\n"],[1,26185,"用"],[-1,26263,"\n"],[-1,26339,"4"],[1,26340,"\n"],[1,26343,"4"],[-1,26349,"\n"],[-1,26373,"*"],[1,26374,"\n"],[-1,26376,"2"],[1,26378,"2类"],[-1,26392,"使"],[1,26395,"使"],[-1,26504," "],[1,26506,"  "],[-1,26507," "],[-1,26544,"比"],[1,26547,"比"],[-1,26551,"B"],[1,26554,"B"],[-1,26589,"p"],[1,26592,"p"],[-1,26787,"这"],[1,26791,"这"],[-1,26842,"新"],[1,26845,"新"],[-1,26908,"在"],[1,26910,"在"],[-1,27288,"*"],[1,27290,"编"],[-1,27297,"\n"],[1,27298,"/"]],[20941,20941],[27299,27299]]],[1543066416016,[null,[[1,20941,"\n"],[-1,20941,"："],[-1,20954,"\n"],[1,21882,"/"],[-1,21882,"总"],[1,21960," "],[-1,21960,"A"],[1,21985,"\n"],[-1,21989,"t"],[1,22003," "],[-1,22003,"t"],[1,22017," "],[-1,22017,"t"],[1,22031," "],[-1,22078,"\""],[1,22099,")"],[-1,22106,"~"],[1,22113," "],[1,22180,""],[-1,22180,"}"],[1,22204," "],[-1,22204,"i"],[1,22212," "],[-1,22212,"i"],[1,22220," "],[-1,22220,"i"],[1,22252," "],[-1,22252,"M"],[1,22290,"\n"],[-1,22293,"M"],[1,22300," "],[-1,22303,"c"],[1,22325," "],[-1,22325,"}"],[1,22330,"~"],[-1,22330,"M"],[1,22333,"("],[-1,22340,"c"],[1,22348,"~"],[-1,22348,"M"],[1,22363," "],[-1,22363,"}"],[1,22387," "],[-1,22387,"A"],[1,22416,"\n"],[-1,22418,"A"],[1,22444,";"],[-1,22444,"\n"],[1,22459," "],[-1,22459,"M"],[1,22468,"\n"],[-1,22469,"r"],[1,22487,"m"],[-1,22496,"("],[1,22502," "],[-1,22502,"r"],[1,22509,"\n"],[-1,22510,"s"],[1,22528," "],[-1,22528,"r"],[1,22731,"析"],[-1,22732,"综"],[1,22738,"\n"],[1,24840,"d"],[-1,24841,"\n*"],[1,24932,"d"],[-1,24932,""],[-1,25450," "],[1,25473,"\n"],[1,25479,"*"],[-1,25479,"\n"],[-1,25576,"对"],[1,25586,"*"],[-1,25586,"\n"],[1,25591," "],[-1,25592,"n"],[1,25595,"**"],[-1,25595,"和d"],[1,25602,"*"],[-1,25602,"基"],[1,25610,"1"],[-1,25612,"1"],[1,25738,"注"],[-1,25742,"注"],[1,25774,"\n"],[1,25777,"2"],[-1,25777,"\n"],[-1,25780,"2"],[-1,25861,"\n"],[1,25863,"\n"],[1,25966,"n"],[-1,25967,"n"],[1,26016,"n"],[-1,26019,"n"],[1,26156," "],[-1,26157," "],[1,26183,"\n"],[-1,26185,"用"],[1,26264,"\n"],[1,26339,"4"],[-1,26339,"\n"],[-1,26343,"4"],[1,26350,"\n"],[1,26373,"*"],[-1,26373,"\n"],[1,26376,"2"],[-1,26377,"2类"],[1,26393,"使"],[-1,26395,"使"],[1,26505," "],[-1,26506,"  "],[1,26509," "],[1,26545,"比"],[-1,26547,"比"],[1,26552,"B"],[-1,26554,"B"],[1,26590,"p"],[-1,26592,"p"],[1,26788,"这"],[-1,26791,"这"],[1,26843,"新"],[-1,26845,"新"],[1,26909,"在"],[-1,26910,"在"],[1,27289,"*"],[-1,27290,"编"],[1,27298,"\n"],[-1,27298,"/"]],[27299,27299],[20941,20941]]],[1543066390020,["gjx16@GJXAIOU",[[-1,2415,"。"]],[2415,2415],[2414,2414]]],[1543066656291,[null,[[-1,20940,"\n"],[1,20941,"："],[1,20953,"\n"],[-1,21880,"/"],[1,21881,"总"],[-1,21958," "],[1,21959,"A"],[-1,21983,"\n"],[1,21988,"t"],[-1,22001," "],[1,22002,"t"],[-1,22015," "],[1,22016,"t"],[-1,22029," "],[1,22077,"\""],[-1,22097,")"],[1,22105,"~"],[-1,22111," "],[-1,22179,""],[1,22179,"}"],[-1,22202," "],[1,22203,"i"],[-1,22210," "],[1,22211,"i"],[-1,22218," "],[1,22219,"i"],[-1,22250," "],[1,22251,"M"],[-1,22288,"\n"],[1,22292,"M"],[-1,22298," "],[1,22302,"c"],[-1,22323," "],[1,22324,"}"],[-1,22328,"~"],[1,22329,"M"],[-1,22331,"("],[1,22339,"c"],[-1,22346,"~"],[1,22347,"M"],[-1,22361," "],[1,22362,"}"],[-1,22385," "],[1,22386,"A"],[-1,22414,"\n"],[1,22417,"A"],[-1,22442,";"],[1,22443,"\n"],[-1,22457," "],[1,22458,"M"],[-1,22466,"\n"],[1,22468,"r"],[-1,22485,"m"],[1,22495,"("],[-1,22500," "],[1,22501,"r"],[-1,22507,"\n"],[1,22509,"s"],[-1,22526," "],[1,22527,"r"],[-1,22729,"析"],[1,22731,"综"],[-1,22736,"\n"],[-1,24839,"d"],[1,24841,"\n*"],[-1,24930,"d"],[1,24931,""],[1,25449," "],[-1,25471,"\n"],[-1,25478,"*"],[1,25479,"\n"],[1,25575,"对"],[-1,25584,"*"],[1,25585,"\n"],[-1,25589," "],[1,25591,"n"],[-1,25593,"**"],[1,25595,"和d"],[-1,25600,"*"],[1,25601,"基"],[-1,25608,"1"],[1,25611,"1"],[-1,25736,"注"],[1,25741,"注"],[-1,25772,"\n"],[-1,25776,"2"],[1,25777,"\n"],[1,25779,"2"],[1,25859,"\n"],[-1,25860,"\n"],[-1,25964,"n"],[1,25966,"n"],[-1,26014,"n"],[1,26018,"n"],[-1,26154," "],[1,26156," "],[-1,26181,"\n"],[1,26184,"用"],[-1,26262,"\n"],[-1,26338,"4"],[1,26339,"\n"],[1,26342,"4"],[-1,26348,"\n"],[-1,26372,"*"],[1,26373,"\n"],[-1,26375,"2"],[1,26377,"2类"],[-1,26391,"使"],[1,26394,"使"],[-1,26503," "],[1,26505,"  "],[-1,26506," "],[-1,26543,"比"],[1,26546,"比"],[-1,26550,"B"],[1,26553,"B"],[-1,26588,"p"],[1,26591,"p"],[-1,26786,"这"],[1,26790,"这"],[-1,26841,"新"],[1,26844,"新"],[-1,26907,"在"],[1,26909,"在"],[-1,27287,"*"],[1,27289,"编"],[-1,27296,"\n"],[1,27297,"/"]],[20940,20940],[27298,27298]]],[1543066656291,[null,[[1,20940,"\n"],[-1,20940,"："],[-1,20953,"\n"],[1,21881,"/"],[-1,21881,"总"],[1,21959," "],[-1,21959,"A"],[1,21984,"\n"],[-1,21988,"t"],[1,22002," "],[-1,22002,"t"],[1,22016," "],[-1,22016,"t"],[1,22030," "],[-1,22077,"\""],[1,22098,")"],[-1,22105,"~"],[1,22112," "],[1,22179,""],[-1,22179,"}"],[1,22203," "],[-1,22203,"i"],[1,22211," "],[-1,22211,"i"],[1,22219," "],[-1,22219,"i"],[1,22251," "],[-1,22251,"M"],[1,22289,"\n"],[-1,22292,"M"],[1,22299," "],[-1,22302,"c"],[1,22324," "],[-1,22324,"}"],[1,22329,"~"],[-1,22329,"M"],[1,22332,"("],[-1,22339,"c"],[1,22347,"~"],[-1,22347,"M"],[1,22362," "],[-1,22362,"}"],[1,22386," "],[-1,22386,"A"],[1,22415,"\n"],[-1,22417,"A"],[1,22443,";"],[-1,22443,"\n"],[1,22458," "],[-1,22458,"M"],[1,22467,"\n"],[-1,22468,"r"],[1,22486,"m"],[-1,22495,"("],[1,22501," "],[-1,22501,"r"],[1,22508,"\n"],[-1,22509,"s"],[1,22527," "],[-1,22527,"r"],[1,22730,"析"],[-1,22731,"综"],[1,22737,"\n"],[1,24839,"d"],[-1,24840,"\n*"],[1,24931,"d"],[-1,24931,""],[-1,25449," "],[1,25472,"\n"],[1,25478,"*"],[-1,25478,"\n"],[-1,25575,"对"],[1,25585,"*"],[-1,25585,"\n"],[1,25590," "],[-1,25591,"n"],[1,25594,"**"],[-1,25594,"和d"],[1,25601,"*"],[-1,25601,"基"],[1,25609,"1"],[-1,25611,"1"],[1,25737,"注"],[-1,25741,"注"],[1,25773,"\n"],[1,25776,"2"],[-1,25776,"\n"],[-1,25779,"2"],[-1,25860,"\n"],[1,25862,"\n"],[1,25965,"n"],[-1,25966,"n"],[1,26015,"n"],[-1,26018,"n"],[1,26155," "],[-1,26156," "],[1,26182,"\n"],[-1,26184,"用"],[1,26263,"\n"],[1,26338,"4"],[-1,26338,"\n"],[-1,26342,"4"],[1,26349,"\n"],[1,26372,"*"],[-1,26372,"\n"],[1,26375,"2"],[-1,26376,"2类"],[1,26392,"使"],[-1,26394,"使"],[1,26504," "],[-1,26505,"  "],[1,26508," "],[1,26544,"比"],[-1,26546,"比"],[1,26551,"B"],[-1,26553,"B"],[1,26589,"p"],[-1,26591,"p"],[1,26787,"这"],[-1,26790,"这"],[1,26842,"新"],[-1,26844,"新"],[1,26908,"在"],[-1,26909,"在"],[1,27288,"*"],[-1,27289,"编"],[1,27297,"\n"],[-1,27297,"/"]],[27298,27298],[20940,20940]]],[1543066621383,["gjx16@GJXAIOU",[[1,3120,"\n"]],[3119,3119],[3120,3120]]],[1543066622927,["gjx16@GJXAIOU",[[1,3120,"、、"]],[3120,3120],[3122,3122]]],[1543066624771,["gjx16@GJXAIOU",[[-1,3120,"、、"]],[3122,3122],[3120,3120]]],[1543066655661,["gjx16@GJXAIOU",[[1,3120,"//具体实现函数内容，"]],[3120,3120],[3131,3131]]],[1543066716284,[null,[[-1,20952,"\n"],[1,20953,"："],[1,20965,"\n"],[-1,21892,"/"],[1,21893,"总"],[-1,21970," "],[1,21971,"A"],[-1,21995,"\n"],[1,22000,"t"],[-1,22013," "],[1,22014,"t"],[-1,22027," "],[1,22028,"t"],[-1,22041," "],[1,22089,"\""],[-1,22109,")"],[1,22117,"~"],[-1,22123," "],[-1,22191,""],[1,22191,"}"],[-1,22214," "],[1,22215,"i"],[-1,22222," "],[1,22223,"i"],[-1,22230," "],[1,22231,"i"],[-1,22262," "],[1,22263,"M"],[-1,22300,"\n"],[1,22304,"M"],[-1,22310," "],[1,22314,"c"],[-1,22335," "],[1,22336,"}"],[-1,22340,"~"],[1,22341,"M"],[-1,22343,"("],[1,22351,"c"],[-1,22358,"~"],[1,22359,"M"],[-1,22373," "],[1,22374,"}"],[-1,22397," "],[1,22398,"A"],[-1,22426,"\n"],[1,22429,"A"],[-1,22454,";"],[1,22455,"\n"],[-1,22469," "],[1,22470,"M"],[-1,22478,"\n"],[1,22480,"r"],[-1,22497,"m"],[1,22507,"("],[-1,22512," "],[1,22513,"r"],[-1,22519,"\n"],[1,22521,"s"],[-1,22538," "],[1,22539,"r"],[-1,22741,"析"],[1,22743,"综"],[-1,22748,"\n"],[-1,24851,"d"],[1,24853,"\n*"],[-1,24942,"d"],[1,24943,""],[1,25461," "],[-1,25483,"\n"],[-1,25490,"*"],[1,25491,"\n"],[1,25587,"对"],[-1,25596,"*"],[1,25597,"\n"],[-1,25601," "],[1,25603,"n"],[-1,25605,"**"],[1,25607,"和d"],[-1,25612,"*"],[1,25613,"基"],[-1,25620,"1"],[1,25623,"1"],[-1,25748,"注"],[1,25753,"注"],[-1,25784,"\n"],[-1,25788,"2"],[1,25789,"\n"],[1,25791,"2"],[1,25871,"\n"],[-1,25872,"\n"],[-1,25976,"n"],[1,25978,"n"],[-1,26026,"n"],[1,26030,"n"],[-1,26166," "],[1,26168," "],[-1,26193,"\n"],[1,26196,"用"],[-1,26274,"\n"],[-1,26350,"4"],[1,26351,"\n"],[1,26354,"4"],[-1,26360,"\n"],[-1,26384,"*"],[1,26385,"\n"],[-1,26387,"2"],[1,26389,"2类"],[-1,26403,"使"],[1,26406,"使"],[-1,26515," "],[1,26517,"  "],[-1,26518," "],[-1,26555,"比"],[1,26558,"比"],[-1,26562,"B"],[1,26565,"B"],[-1,26600,"p"],[1,26603,"p"],[-1,26798,"这"],[1,26802,"这"],[-1,26853,"新"],[1,26856,"新"],[-1,26919,"在"],[1,26921,"在"],[-1,27299,"*"],[1,27301,"编"],[-1,27308,"\n"],[1,27309,"/"]],[20952,20952],[27310,27310]]],[1543066716284,[null,[[1,20952,"\n"],[-1,20952,"："],[-1,20965,"\n"],[1,21893,"/"],[-1,21893,"总"],[1,21971," "],[-1,21971,"A"],[1,21996,"\n"],[-1,22000,"t"],[1,22014," "],[-1,22014,"t"],[1,22028," "],[-1,22028,"t"],[1,22042," "],[-1,22089,"\""],[1,22110,")"],[-1,22117,"~"],[1,22124," "],[1,22191,""],[-1,22191,"}"],[1,22215," "],[-1,22215,"i"],[1,22223," "],[-1,22223,"i"],[1,22231," "],[-1,22231,"i"],[1,22263," "],[-1,22263,"M"],[1,22301,"\n"],[-1,22304,"M"],[1,22311," "],[-1,22314,"c"],[1,22336," "],[-1,22336,"}"],[1,22341,"~"],[-1,22341,"M"],[1,22344,"("],[-1,22351,"c"],[1,22359,"~"],[-1,22359,"M"],[1,22374," "],[-1,22374,"}"],[1,22398," "],[-1,22398,"A"],[1,22427,"\n"],[-1,22429,"A"],[1,22455,";"],[-1,22455,"\n"],[1,22470," "],[-1,22470,"M"],[1,22479,"\n"],[-1,22480,"r"],[1,22498,"m"],[-1,22507,"("],[1,22513," "],[-1,22513,"r"],[1,22520,"\n"],[-1,22521,"s"],[1,22539," "],[-1,22539,"r"],[1,22742,"析"],[-1,22743,"综"],[1,22749,"\n"],[1,24851,"d"],[-1,24852,"\n*"],[1,24943,"d"],[-1,24943,""],[-1,25461," "],[1,25484,"\n"],[1,25490,"*"],[-1,25490,"\n"],[-1,25587,"对"],[1,25597,"*"],[-1,25597,"\n"],[1,25602," "],[-1,25603,"n"],[1,25606,"**"],[-1,25606,"和d"],[1,25613,"*"],[-1,25613,"基"],[1,25621,"1"],[-1,25623,"1"],[1,25749,"注"],[-1,25753,"注"],[1,25785,"\n"],[1,25788,"2"],[-1,25788,"\n"],[-1,25791,"2"],[-1,25872,"\n"],[1,25874,"\n"],[1,25977,"n"],[-1,25978,"n"],[1,26027,"n"],[-1,26030,"n"],[1,26167," "],[-1,26168," "],[1,26194,"\n"],[-1,26196,"用"],[1,26275,"\n"],[1,26350,"4"],[-1,26350,"\n"],[-1,26354,"4"],[1,26361,"\n"],[1,26384,"*"],[-1,26384,"\n"],[1,26387,"2"],[-1,26388,"2类"],[1,26404,"使"],[-1,26406,"使"],[1,26516," "],[-1,26517,"  "],[1,26520," "],[1,26556,"比"],[-1,26558,"比"],[1,26563,"B"],[-1,26565,"B"],[1,26601,"p"],[-1,26603,"p"],[1,26799,"这"],[-1,26802,"这"],[1,26854,"新"],[-1,26856,"新"],[1,26920,"在"],[-1,26921,"在"],[1,27300,"*"],[-1,27301,"编"],[1,27309,"\n"],[-1,27309,"/"]],[27310,27310],[20952,20952]]],[1543066669875,["gjx16@GJXAIOU",[[1,3131,"在函数名前面加上类"]],[3131,3131],[3140,3140]]],[1543066671061,["gjx16@GJXAIOU",[[-1,3139,"类"]],[3140,3140],[3139,3139]]],[1543066674056,["gjx16@GJXAIOU",[[1,3139,"``"]],[3139,3139],[3141,3141]]],[1543066678870,["gjx16@GJXAIOU",[[1,3140,"leiming"]],[3140,3140],[3147,3147]]],[1543066684291,["gjx16@GJXAIOU",[[-1,3140,"leiming"]],[3147,3147],[3140,3140]]],[1543066690392,["gjx16@GJXAIOU",[[1,3140,"类名：："]],[3140,3140],[3144,3144]]],[1543066692253,["gjx16@GJXAIOU",[[-1,3142,"：："]],[3144,3144],[3142,3142]]],[1543066694198,["gjx16@GJXAIOU",[[1,3142,"::"]],[3142,3142],[3144,3144]]],[1543066776271,[null,[[-1,20966,"\n"],[1,20967,"："],[1,20979,"\n"],[-1,21906,"/"],[1,21907,"总"],[-1,21984," "],[1,21985,"A"],[-1,22009,"\n"],[1,22014,"t"],[-1,22027," "],[1,22028,"t"],[-1,22041," "],[1,22042,"t"],[-1,22055," "],[1,22103,"\""],[-1,22123,")"],[1,22131,"~"],[-1,22137," "],[-1,22205,""],[1,22205,"}"],[-1,22228," "],[1,22229,"i"],[-1,22236," "],[1,22237,"i"],[-1,22244," "],[1,22245,"i"],[-1,22276," "],[1,22277,"M"],[-1,22314,"\n"],[1,22318,"M"],[-1,22324," "],[1,22328,"c"],[-1,22349," "],[1,22350,"}"],[-1,22354,"~"],[1,22355,"M"],[-1,22357,"("],[1,22365,"c"],[-1,22372,"~"],[1,22373,"M"],[-1,22387," "],[1,22388,"}"],[-1,22411," "],[1,22412,"A"],[-1,22440,"\n"],[1,22443,"A"],[-1,22468,";"],[1,22469,"\n"],[-1,22483," "],[1,22484,"M"],[-1,22492,"\n"],[1,22494,"r"],[-1,22511,"m"],[1,22521,"("],[-1,22526," "],[1,22527,"r"],[-1,22533,"\n"],[1,22535,"s"],[-1,22552," "],[1,22553,"r"],[-1,22755,"析"],[1,22757,"综"],[-1,22762,"\n"],[-1,24865,"d"],[1,24867,"\n*"],[-1,24956,"d"],[1,24957,""],[1,25475," "],[-1,25497,"\n"],[-1,25504,"*"],[1,25505,"\n"],[1,25601,"对"],[-1,25610,"*"],[1,25611,"\n"],[-1,25615," "],[1,25617,"n"],[-1,25619,"**"],[1,25621,"和d"],[-1,25626,"*"],[1,25627,"基"],[-1,25634,"1"],[1,25637,"1"],[-1,25762,"注"],[1,25767,"注"],[-1,25798,"\n"],[-1,25802,"2"],[1,25803,"\n"],[1,25805,"2"],[1,25885,"\n"],[-1,25886,"\n"],[-1,25990,"n"],[1,25992,"n"],[-1,26040,"n"],[1,26044,"n"],[-1,26180," "],[1,26182," "],[-1,26207,"\n"],[1,26210,"用"],[-1,26288,"\n"],[-1,26364,"4"],[1,26365,"\n"],[1,26368,"4"],[-1,26374,"\n"],[-1,26398,"*"],[1,26399,"\n"],[-1,26401,"2"],[1,26403,"2类"],[-1,26417,"使"],[1,26420,"使"],[-1,26529," "],[1,26531,"  "],[-1,26532," "],[-1,26569,"比"],[1,26572,"比"],[-1,26576,"B"],[1,26579,"B"],[-1,26614,"p"],[1,26617,"p"],[-1,26812,"这"],[1,26816,"这"],[-1,26867,"新"],[1,26870,"新"],[-1,26933,"在"],[1,26935,"在"],[-1,27313,"*"],[1,27315,"编"],[-1,27322,"\n"],[1,27323,"/"]],[20966,20966],[27324,27324]]],[1543066776272,[null,[[1,20966,"\n"],[-1,20966,"："],[-1,20979,"\n"],[1,21907,"/"],[-1,21907,"总"],[1,21985," "],[-1,21985,"A"],[1,22010,"\n"],[-1,22014,"t"],[1,22028," "],[-1,22028,"t"],[1,22042," "],[-1,22042,"t"],[1,22056," "],[-1,22103,"\""],[1,22124,")"],[-1,22131,"~"],[1,22138," "],[1,22205,""],[-1,22205,"}"],[1,22229," "],[-1,22229,"i"],[1,22237," "],[-1,22237,"i"],[1,22245," "],[-1,22245,"i"],[1,22277," "],[-1,22277,"M"],[1,22315,"\n"],[-1,22318,"M"],[1,22325," "],[-1,22328,"c"],[1,22350," "],[-1,22350,"}"],[1,22355,"~"],[-1,22355,"M"],[1,22358,"("],[-1,22365,"c"],[1,22373,"~"],[-1,22373,"M"],[1,22388," "],[-1,22388,"}"],[1,22412," "],[-1,22412,"A"],[1,22441,"\n"],[-1,22443,"A"],[1,22469,";"],[-1,22469,"\n"],[1,22484," "],[-1,22484,"M"],[1,22493,"\n"],[-1,22494,"r"],[1,22512,"m"],[-1,22521,"("],[1,22527," "],[-1,22527,"r"],[1,22534,"\n"],[-1,22535,"s"],[1,22553," "],[-1,22553,"r"],[1,22756,"析"],[-1,22757,"综"],[1,22763,"\n"],[1,24865,"d"],[-1,24866,"\n*"],[1,24957,"d"],[-1,24957,""],[-1,25475," "],[1,25498,"\n"],[1,25504,"*"],[-1,25504,"\n"],[-1,25601,"对"],[1,25611,"*"],[-1,25611,"\n"],[1,25616," "],[-1,25617,"n"],[1,25620,"**"],[-1,25620,"和d"],[1,25627,"*"],[-1,25627,"基"],[1,25635,"1"],[-1,25637,"1"],[1,25763,"注"],[-1,25767,"注"],[1,25799,"\n"],[1,25802,"2"],[-1,25802,"\n"],[-1,25805,"2"],[-1,25886,"\n"],[1,25888,"\n"],[1,25991,"n"],[-1,25992,"n"],[1,26041,"n"],[-1,26044,"n"],[1,26181," "],[-1,26182," "],[1,26208,"\n"],[-1,26210,"用"],[1,26289,"\n"],[1,26364,"4"],[-1,26364,"\n"],[-1,26368,"4"],[1,26375,"\n"],[1,26398,"*"],[-1,26398,"\n"],[1,26401,"2"],[-1,26402,"2类"],[1,26418,"使"],[-1,26420,"使"],[1,26530," "],[-1,26531,"  "],[1,26534," "],[1,26570,"比"],[-1,26572,"比"],[1,26577,"B"],[-1,26579,"B"],[1,26615,"p"],[-1,26617,"p"],[1,26813,"这"],[-1,26816,"这"],[1,26868,"新"],[-1,26870,"新"],[1,26934,"在"],[-1,26935,"在"],[1,27314,"*"],[-1,27315,"编"],[1,27323,"\n"],[-1,27323,"/"]],[27324,27324],[20966,20966]]],[1543066753015,["gjx16@GJXAIOU",[[1,3673,":"]],[3673,3673],[3674,3674]]],[1543066756615,["gjx16@GJXAIOU",[[-1,3674," "]],[3675,3675],[3674,3674]]],[1543066896285,[null,[[-1,20966,"\n"],[1,20967,"："],[1,20979,"\n"],[-1,21906,"/"],[1,21907,"总"],[-1,21984," "],[1,21985,"A"],[-1,22009,"\n"],[1,22014,"t"],[-1,22027," "],[1,22028,"t"],[-1,22041," "],[1,22042,"t"],[-1,22055," "],[1,22103,"\""],[-1,22123,")"],[1,22131,"~"],[-1,22137," "],[-1,22205,""],[1,22205,"}"],[-1,22228," "],[1,22229,"i"],[-1,22236," "],[1,22237,"i"],[-1,22244," "],[1,22245,"i"],[-1,22276," "],[1,22277,"M"],[-1,22314,"\n"],[1,22318,"M"],[-1,22324," "],[1,22328,"c"],[-1,22349," "],[1,22350,"}"],[-1,22354,"~"],[1,22355,"M"],[-1,22357,"("],[1,22365,"c"],[-1,22372,"~"],[1,22373,"M"],[-1,22387," "],[1,22388,"}"],[-1,22411," "],[1,22412,"A"],[-1,22440,"\n"],[1,22443,"A"],[-1,22468,";"],[1,22469,"\n"],[-1,22483," "],[1,22484,"M"],[-1,22492,"\n"],[1,22494,"r"],[-1,22511,"m"],[1,22521,"("],[-1,22526," "],[1,22527,"r"],[-1,22533,"\n"],[1,22535,"s"],[-1,22552," "],[1,22553,"r"],[-1,22755,"析"],[1,22757,"综"],[-1,22762,"\n"],[-1,24865,"d"],[1,24867,"\n*"],[-1,24956,"d"],[1,24957,""],[1,25475," "],[-1,25497,"\n"],[-1,25504,"*"],[1,25505,"\n"],[1,25601,"对"],[-1,25610,"*"],[1,25611,"\n"],[-1,25615," "],[1,25617,"n"],[-1,25619,"**"],[1,25621,"和d"],[-1,25626,"*"],[1,25627,"基"],[-1,25634,"1"],[1,25637,"1"],[-1,25762,"注"],[1,25767,"注"],[-1,25798,"\n"],[-1,25802,"2"],[1,25803,"\n"],[1,25805,"2"],[1,25885,"\n"],[-1,25886,"\n"],[-1,25990,"n"],[1,25992,"n"],[-1,26040,"n"],[1,26044,"n"],[-1,26180," "],[1,26182," "],[-1,26207,"\n"],[1,26210,"用"],[-1,26288,"\n"],[-1,26364,"4"],[1,26365,"\n"],[1,26368,"4"],[-1,26374,"\n"],[-1,26398,"*"],[1,26399,"\n"],[-1,26401,"2"],[1,26403,"2类"],[-1,26417,"使"],[1,26420,"使"],[-1,26529," "],[1,26531,"  "],[-1,26532," "],[-1,26569,"比"],[1,26572,"比"],[-1,26576,"B"],[1,26579,"B"],[-1,26614,"p"],[1,26617,"p"],[-1,26812,"这"],[1,26816,"这"],[-1,26867,"新"],[1,26870,"新"],[-1,26933,"在"],[1,26935,"在"],[-1,27313,"*"],[1,27315,"编"],[-1,27322,"\n"],[1,27323,"/"]],[20966,20966],[27324,27324]]],[1543066896285,[null,[[1,20966,"\n"],[-1,20966,"："],[-1,20979,"\n"],[1,21907,"/"],[-1,21907,"总"],[1,21985," "],[-1,21985,"A"],[1,22010,"\n"],[-1,22014,"t"],[1,22028," "],[-1,22028,"t"],[1,22042," "],[-1,22042,"t"],[1,22056," "],[-1,22103,"\""],[1,22124,")"],[-1,22131,"~"],[1,22138," "],[1,22205,""],[-1,22205,"}"],[1,22229," "],[-1,22229,"i"],[1,22237," "],[-1,22237,"i"],[1,22245," "],[-1,22245,"i"],[1,22277," "],[-1,22277,"M"],[1,22315,"\n"],[-1,22318,"M"],[1,22325," "],[-1,22328,"c"],[1,22350," "],[-1,22350,"}"],[1,22355,"~"],[-1,22355,"M"],[1,22358,"("],[-1,22365,"c"],[1,22373,"~"],[-1,22373,"M"],[1,22388," "],[-1,22388,"}"],[1,22412," "],[-1,22412,"A"],[1,22441,"\n"],[-1,22443,"A"],[1,22469,";"],[-1,22469,"\n"],[1,22484," "],[-1,22484,"M"],[1,22493,"\n"],[-1,22494,"r"],[1,22512,"m"],[-1,22521,"("],[1,22527," "],[-1,22527,"r"],[1,22534,"\n"],[-1,22535,"s"],[1,22553," "],[-1,22553,"r"],[1,22756,"析"],[-1,22757,"综"],[1,22763,"\n"],[1,24865,"d"],[-1,24866,"\n*"],[1,24957,"d"],[-1,24957,""],[-1,25475," "],[1,25498,"\n"],[1,25504,"*"],[-1,25504,"\n"],[-1,25601,"对"],[1,25611,"*"],[-1,25611,"\n"],[1,25616," "],[-1,25617,"n"],[1,25620,"**"],[-1,25620,"和d"],[1,25627,"*"],[-1,25627,"基"],[1,25635,"1"],[-1,25637,"1"],[1,25763,"注"],[-1,25767,"注"],[1,25799,"\n"],[1,25802,"2"],[-1,25802,"\n"],[-1,25805,"2"],[-1,25886,"\n"],[1,25888,"\n"],[1,25991,"n"],[-1,25992,"n"],[1,26041,"n"],[-1,26044,"n"],[1,26181," "],[-1,26182," "],[1,26208,"\n"],[-1,26210,"用"],[1,26289,"\n"],[1,26364,"4"],[-1,26364,"\n"],[-1,26368,"4"],[1,26375,"\n"],[1,26398,"*"],[-1,26398,"\n"],[1,26401,"2"],[-1,26402,"2类"],[1,26418,"使"],[-1,26420,"使"],[1,26530," "],[-1,26531,"  "],[1,26534," "],[1,26570,"比"],[-1,26572,"比"],[1,26577,"B"],[-1,26579,"B"],[1,26615,"p"],[-1,26617,"p"],[1,26813,"这"],[-1,26816,"这"],[1,26868,"新"],[-1,26870,"新"],[1,26934,"在"],[-1,26935,"在"],[1,27314,"*"],[-1,27315,"编"],[1,27323,"\n"],[-1,27323,"/"]],[27324,27324],[20966,20966]]],[1543066841145,["gjx16@GJXAIOU",[[1,3886,"//因为是"]],[3886,3886],[3891,3891]]],[1543066842318,["gjx16@GJXAIOU",[[-1,3890,"是"]],[3891,3891],[3890,3890]]],[1543066861502,["gjx16@GJXAIOU",[[1,3890,"类的成员变量这里都是prinvate"]],[3890,3890],[3908,3908]]],[1543066865723,["gjx16@GJXAIOU",[[-1,3902,"invate"]],[3908,3908],[3902,3902]]],[1543066868357,["gjx16@GJXAIOU",[[1,3902,"vate"]],[3902,3902],[3906,3906]]],[1543066872485,["gjx16@GJXAIOU",[[-1,3902,"vate"]],[3906,3906],[3902,3902]]],[1543066876842,["gjx16@GJXAIOU",[[1,3902,"ivate:"]],[3902,3902],[3908,3908]]]],null,"gjx16@GJXAIOU"],["2db6ff53-453d-4cde-89db-1e667a288677",1543114091829,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁;\n   * c++面向对象模型初探;  \n   * c++面向对象多态原理探究;\n   * 操作符重载;\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;//定义两个对象c1和c2\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”，\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n\t\n};\n\n```\nTeacher.cpp\n//具体实现函数内容，在函数名前面加上`类名::`\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1:设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)//因为类的成员变量这里都是private:\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n###  (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n###  (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//需要重载=号操作符，才能解决带来的浅拷贝问题\n\n\tobj2 = obj3; //=号操作，也是一种浅拷贝\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++的默认copy构造函数是浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n\n---\n\n\n### （五）多个对象构造和析构\n\n**1.对象初始化列表**\n\n- 1）对象初始化列表出现原因\n程序本身是有问题的\n```cpp\n\n/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B   //在一个类里面组合了一个带有参数的构造函数的类，因为C++编译器要确定分配给B多大的内存，但是没法初始化A定义的两个对象（因为需要调用有参的构造函数）\n{\npublic:   //没有写B的构造函数，按理说应该调用默认的构造函数\n\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  //主要是因为没有方法和没有机会去初始化这两个A定义的对象\n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB;\n\treturn 0;\n\n}\n\n```\n\n解决方法：\n```cpp\n/*\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n};\n\n\nclass B  \n{\npublic:   \n//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）\n\tB(int _a, int _b) : a1(1), a2(3)  \n\t{\n\n\t}\n//第二种参数传递的方法：\n/*\nB(int _a, int _b,int m,int n) : a1(m), a2(n)  \n\t{\n      a = _a;\n      b = _b;\n\t}\n\t\n*/\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  \n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB(1,2);\n\t//第二种方式：B objB(1,2,4,3)\n\treturn 0;\n\n}\n\n```\n\n**以上程序的操作顺序：**\n首先执行被组合对象的构造函数（a1,a2），如果有多个组合对象，则按照定义的顺序，而不是按照初始化列表的顺序（：后面的顺序）\n析构函数：和构造函数的调用顺序相反\n\n  - 1.必须这样做：\n    - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    - 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n  - 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    - 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    - 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n- 2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n```cpp\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n{\n // some other assignment operation\n}\n```\n\n\n- 3）注意概念\n  - 初始化：被初始化的对象正在创建\n  - 赋值：被赋值的对象已经存在\n\n- 4）注意：\n  - 成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n  - 初始化列表先于构造函数的函数体执行\n\n**说明：**\n\n* 1 C++中提供了初始化列表对成员变量进行初始化\n* 2 使用初始化列表出现原因：\n  * 1.必须这样做：\n    * 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n    * 而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    * 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n  * 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    * 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    * 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n```cpp\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n ABC(int a, int b, int c)\n {\n this->a = a;\n this->b = b;\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"ABC construct ..\\n\");\n }\n\n ~ABC()\n {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n }\n\nprotected:\nprivate:\n int a;\n int b;\n int c;\n};\n\nclass MyD\n{\npublic:\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n {\n cout<<\"MyD()\"<<endl;\n }\n\n ~MyD()\n {\n cout<<\"~MyD()\"<<endl;\n }\n\nprotected:\nprivate:\n ABC abc1; //c++编译器不知道如何构造abc1\n ABC abc2;\n const int m;\n};\n\nint run()\n{\n MyD myD;\n return 0;\n}\n\nint main_dem03()\n{\n run();\n system(\"pause\");\n return 0;\n}\n\n```\n\n\n\n\n### （六）构造函数和析构函数的调用顺序研究\n\n**构造函数与析构函数的调用顺序**\n\n- 1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n- 2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n### （七）构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1构造析构综合训练**\n```cpp\n\n/*\n\n总结 构造和析构的调用顺序\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n\tABC(int a, int b, int c)   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\n\t}\n\n\t~ABC()\n\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\n\nclass MyD \n{\npublic:\n\tMyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~MyD()\n\t{\n\t\tcout << \"~MyD()\" << endl;\n\t}\n\n\tMyD(const MyD & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\tcout << \"MyD(const MyD &obj)\" << endl;\n\t}\n\nprotected:\nprivate:\n\tABC abc1; //c++编译器不知道如何构造abc1//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\tABC abc2;\n\tconst int m;//因为是const m,所以上面所有的m都进行了赋值\n};\n\n\nint doThing(MyD myel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;\n}\n\n\nint run2()//二\n{\n\tMyD myD;//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\treturn 0;\n}\n\nint run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main()\n{\n\trun2();//一\n\t//run3();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n\n\n```\n\n\n**2匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3匿名对象强化训练**\n\n3） 构造中调用构造\n\n```cpp\n/*\n\n构造中调用构造\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass MyTest\n{\npublic:\n\tMyTest(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t}\n\n\tMyTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\n\t\tMyTest(a, b, 10);\n\t}\n\n\t~MyTest()\n\t{\n\t\tcout << \"MyTest is ...\" << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n\n\npublic:\n\tint getC() const { return c; }\n\n\tvoid setC(int val) { c = val; }\n};\n\nint main()\n{\n\tMyTest t1(1, 2);\n\tcout << t1.getC() << endl;\n\tsystem(\"pause\");\n\treturn 0;\n\t\n}\n\n\n```\n\n 结论： 构造函数中调用构造函数，是一个蹩脚的行为。\n程序内存图：\n![搜狗截图20181124125452]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181124125452.png)\n\n### （八）对象的动态建立和释放\n\n**1.new和delete基本语法**\n\n- 1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n  **注意： new和delete是运算符，不是函数，因此执行效率高。**\n\n- 2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： \nnew int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 \nnew char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址    new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n- 3）new和delete运算符使用的一般格式为：\n  用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n![new运算符动态]($resource/new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%A8%E6%80%81.png)\n\n- 4） 应用举例\n\n![5]($resource/5.png)\n\n**2类对象的动态建立和释放**\n\n- 使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n-  C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n  比如：\n\n  Box *pt;  //定义一个指向Box类对象的指针变量pt\n      pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n   这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n  新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n   在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3.编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n",[[1543114073744,["gjx16@GJXAIOU",[[1,25656,"·"]],[25656,25656],[25657,25657]]],[1543114077932,["gjx16@GJXAIOU",[[-1,25656,"·"]],[25657,25657],[25656,25656]]],[1543114079630,["gjx16@GJXAIOU",[[1,25656,"```"]],[25656,25656],[25659,25659]]],[1543114079699,["gjx16@GJXAIOU",[[1,25659,"language\n```\n"]],[25659,25659],[25659,25667]]],[1543114081189,["gjx16@GJXAIOU",[[-1,25659,"language"],[1,25667,"c"]],[25659,25667],[25660,25660]]],[1543114081768,["gjx16@GJXAIOU",[[1,25660,"oo"]],[25660,25660],[25662,25662]]],[1543114082458,["gjx16@GJXAIOU",[[1,25663,"\n"]],[25662,25662],[25663,25663]]],[1543114083588,["gjx16@GJXAIOU",[[-1,25663,"\n"]],[25663,25663],[25662,25662]]],[1543114084797,["gjx16@GJXAIOU",[[-1,25660,"oo"]],[25662,25662],[25660,25660]]],[1543114085514,["gjx16@GJXAIOU",[[1,25660,"pp"]],[25660,25660],[25662,25662]]],[1543114086207,["gjx16@GJXAIOU",[[1,25663,"\n"]],[25662,25662],[25663,25663]]],[1543114087902,["gjx16@GJXAIOU",[[1,25663,"/*\n\nnew 和delete的使用\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nvoid main()\n{\n\t//先分配内存然后赋值\n\tint *p = new int;  //分配基础类型\n\t*p = 20;  \n\n\t//在定义的时候直接分配内存\n\tint *p1 = new int(30);\n\tcout << *p1 << endl;\n\n\tsystem(\"pause\");\n\treturn; \n}\n"]],[25663,25663],[25890,25890]]],[1543116196498,["gjx16@GJXAIOU",[[1,26626,"···"]],[26626,26626],[26629,26629]]],[1543116198488,["gjx16@GJXAIOU",[[-1,26626,"···"]],[26629,26629],[26626,26626]]],[1543116200235,["gjx16@GJXAIOU",[[1,26626,"```"]],[26626,26626],[26629,26629]]],[1543116200537,["gjx16@GJXAIOU",[[1,26629,"language\n```\n"]],[26629,26629],[26629,26637]]],[1543116202192,["gjx16@GJXAIOU",[[-1,26629,"language"],[1,26637,"c"]],[26629,26637],[26630,26630]]],[1543116202790,["gjx16@GJXAIOU",[[1,26630,"pp"]],[26630,26630],[26632,26632]]],[1543116204005,["gjx16@GJXAIOU",[[1,26633,"\n"]],[26632,26632],[26633,26633]]],[1543116205230,["gjx16@GJXAIOU",[[1,26634,"/*\n使用malloc /free 与new /delete的区别\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest();\n\t~Test();\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\nTest::Test()\n{\n\tcout << \"执行了构造函数\" << endl;\n}\n\nTest::~Test()\n{\n\tcout << \"执行了析构函数\" << endl;\n}\n\n\n\nint main()\n{\n\t//基础类型\n\tint *p1 = (int *)malloc(sizeof(int));\n\t*p1 = 10;\n\tdelete p1;\n\n\tint *p2 = new int;\n\t*p2 = 20;\n\tfree(p2);\n\n\n\n\t//数组类型（元素为基础类型）\n\tint *p3 = (int *)malloc(sizeof(int)*10);\n\tp3[0] = 1;\n\tdelete[]p3;\n\n\tint *p4 = new int[10];\n\tp4[1] = 2;\n\tfree(p4);\n\n\n\t//类\n\tTest *p5 = (Test *)malloc(sizeof(Test));\n\tdelete p5;\n\n\tTest *p6 = new Test(10);\n\tfree(p6);\n}\n\n\n"]],[26633,26633],[27249,27249]]],[1543116210740,["gjx16@GJXAIOU",[[1,27255,"\n"]],[27253,27253],[27254,27254]]],[1543116212866,["gjx16@GJXAIOU",[[1,27254,"jielun"]],[27254,27254],[27260,27260]]],[1543116218870,["gjx16@GJXAIOU",[[-1,27254,"jielun"]],[27260,27260],[27254,27254]]],[1543116221145,["gjx16@GJXAIOU",[[1,27254,"****"]],[27254,27254],[27256,27256]]],[1543116223091,["gjx16@GJXAIOU",[[1,27256,"结论"]],[27256,27256],[27258,27258]]],[1543116224151,["gjx16@GJXAIOU",[[1,27260,"****"]],[27258,27258],[27260,27260]]],[1543116225030,["gjx16@GJXAIOU",[[-1,27262,"**"]],[27260,27260],[27258,27258]]],[1543116226291,["gjx16@GJXAIOU",[[1,27258,"；"]],[27258,27258],[27259,27259]]],[1543116227910,["gjx16@GJXAIOU",[[-1,27258,"；"]],[27259,27259],[27258,27258]]],[1543116228449,["gjx16@GJXAIOU",[[1,27258,"："]],[27258,27258],[27259,27259]]],[1543116230879,["gjx16@GJXAIOU",[[-1,27261,"**"]],[27261,27261],[27259,27259]]],[1543116248709,["gjx16@GJXAIOU",[[1,27261," new不仅分配内存，而"]],[27261,27261],[27273,27273]]],[1543116258281,["gjx16@GJXAIOU",[[1,27273,"且调用了构造函数"]],[27273,27273],[27281,27281]]],[1543116258787,["gjx16@GJXAIOU",[[1,27283,"\n"]],[27281,27281],[27282,27282]]],[1543116264020,["gjx16@GJXAIOU",[[1,27262,"\n"]],[27262,27262],[27263,27263]]],[1543116291812,["gjx16@GJXAIOU",[[1,27283,"delete:不仅释放了内存，而且调用了析构函数"]],[27283,27283],[27307,27307]]],[1543116294905,["gjx16@GJXAIOU",[[1,27266,"："]],[27266,27266],[27267,27267]]],[1543116563488,["gjx16@GJXAIOU",[[1,28436," \n"]],[28435,28435],[28437,28437]]],[1543116563932,["gjx16@GJXAIOU",[[-1,28436," "],[1,28437,"\n"]],[28437,28437],[28437,28437]]],[1543116564294,["gjx16@GJXAIOU",[[1,28439,"\n"]],[28437,28437],[28438,28438]]],[1543116564671,["gjx16@GJXAIOU",[[1,28440,"\n"]],[28438,28438],[28439,28439]]],[1543116565026,["gjx16@GJXAIOU",[[1,28441,"\n"]],[28439,28439],[28440,28440]]],[1543116565436,["gjx16@GJXAIOU",[[1,28442,"\n"]],[28440,28440],[28441,28441]]],[1543116565922,["gjx16@GJXAIOU",[[1,28443,"\n"]],[28441,28441],[28442,28442]]],[1543116566309,["gjx16@GJXAIOU",[[1,28444,"\n"]],[28442,28442],[28443,28443]]],[1543116568449,["gjx16@GJXAIOU",[[1,28436," \n"]],[28435,28435],[28437,28437]]],[1543116568786,["gjx16@GJXAIOU",[[-1,28436," "],[1,28437,"\n"]],[28437,28437],[28437,28437]]],[1543116570321,["gjx16@GJXAIOU",[[1,28447,"\n"]],[28437,28437],[28438,28438]]],[1543116570604,["gjx16@GJXAIOU",[[1,28448,"\n"]],[28438,28438],[28439,28439]]],[1543116570931,["gjx16@GJXAIOU",[[1,28449,"\n"]],[28439,28439],[28440,28440]]],[1543116575841,["gjx16@GJXAIOU",[[1,28440,"## 四。"]],[28440,28440],[28445,28445]]],[1543116576430,["gjx16@GJXAIOU",[[-1,28444,"。"]],[28445,28445],[28444,28444]]],[1543116593958,["gjx16@GJXAIOU",[[1,28444,"、静态成员变量和成员函数"]],[28444,28444],[28456,28456]]],[1543116594514,["gjx16@GJXAIOU",[[1,28466,"\n"]],[28456,28456],[28457,28457]]],[1543116596442,["gjx16@GJXAIOU",[[1,28457,"**4****静态成员变量成员函数**\n\n思考：每个变量，拥有属性。有没有一些属性，归所有对象拥有？\n\n**4.1****静态成员变量**\n\n**1****）定义静态成员变量**\n\nØ 关键字 **static**  可以用于说明一个类的成员，\n\n  静态成员提供了一个同类对象的共享机制\n\nØ  把一个类的成员说明为 **static**  时，这个类无论有多少个对象被创建，这些对象共享这个 **static**  成员\n\nØ  静态成员局部于类，它不是对象成员\n\n例如：\n\n#include<iostream>\n\nusing namespace std;\n\nclass counter\n\n{    \n\nstatic int num ; //**声明与定义静态数据成员**\n\n public :\n\n void setnum ( int i ) { num = i ; } //成员函数访问静态数据成员\n\n void shownum() { cout << num << '\\t' ; }\n\n} ;\n\nint counter :: num = 0 ;//**声明与定义静态数据成员**\n\nvoid main ()\n\n{  counter  a , b ;\n\n a.shownum() ; //调用成员函数访问私有静态数据成员\n\n b.shownum() ;\n\n a.setnum(10) ;\n\n a.shownum() ;\n\n b.shownum() ;\n\n}\n\n从结果可以看出，**访问的是同一个静态数据成员**\n\n**2****）使用静态成员变量**\n\n**_//_** **_例5-14_** **_使用公有静态数据成员_**\n\n#include<iostream.h>\n\nclass counter\n\n{ public :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n\n**4.2****静态成员函数**\n\n1）概念\n\nØ 静态成员函数数冠以关键字static\n\nØ  静态成员函数提供不依赖于类数据结构的共同操作，它没有this指针\n\nØ  在类外调用静态成员函数用 “**_类名_ ::** ”作限定词，或通过对象调用\n\n2）案例\n\n3）疑难问题：静态成员函数中，不能使用普通变量。\n\n //静态成员变量属于整个类的，分不清楚，是那个具体对象的属性。\n\n**4.3****综合训练**"]],[28457,28457],[29857,29857]]],[1543116600787,["gjx16@GJXAIOU",[[-1,28457,"**4****静态成员变量成员函数**"]],[28457,28476],[28457,28457]]],[1543116774877,["gjx16@GJXAIOU",[[-1,28678,"#include<iostream>\n\nusing namespace std;\n\nclass counter\n\n{    \n\nstatic int num ; //**声明与定义静态数据成员**\n\n public :\n\n void setnum ( int i ) { num = i ; } //成员函数访问静态数据成员\n\n void shownum() { cout << num << '\\t' ; }\n\n} ;\n\nint counter :: num = 0 ;//**声明与定义静态数据成员**\n\nvoid main ()\n\n{  counter  a , b ;\n\n a.shownum() ; //调用成员函数访问私有静态数据成员\n\n b.shownum() ;\n\n a.setnum(10) ;\n\n a.shownum() ;\n\n b.shownum() ;\n\n}"]],[28678,29069],[28678,28678]]],[1543116777328,["gjx16@GJXAIOU",[[-1,28586," "],[1,28587," "],[-1,28654," "],[1,28655," "],[-1,28678,""],[1,28678,"·"],[-1,28988," "],[1,28989," "],[-1,29287," "],[1,29288," "],[-1,29324," "],[1,29325," "]],[28678,28678],[28679,28679]]],[1543116778503,["gjx16@GJXAIOU",[[-1,28678,"·"]],[28679,28679],[28678,28678]]],[1543116779697,["gjx16@GJXAIOU",[[1,28678,"```"]],[28678,28678],[28681,28681]]],[1543116779976,["gjx16@GJXAIOU",[[1,28681,"language\n```\n"]],[28681,28681],[28681,28689]]],[1543116780545,["gjx16@GJXAIOU",[[-1,28681,"language"],[1,28689,"c"]],[28681,28689],[28682,28682]]],[1543116781162,["gjx16@GJXAIOU",[[1,28682,"pp"]],[28682,28682],[28684,28684]]],[1543116781829,["gjx16@GJXAIOU",[[1,28685,"\n"]],[28684,28684],[28685,28685]]],[1543117020711,["gjx16@GJXAIOU",[[1,28686,"/*\n静态成员变量\n*/\n\n#include<iostream>\nusing namespace std;\n\nclass counter\n{\n\n\tstatic int num; //**声明与定义静态数据成员**\n\npublic:\n\n\tvoid setnum(int i) \n\t{ \n\t\tnum = i; \n\t} //成员函数访问静态数据成员\n\n\tvoid shownum() \n\t{ \n\t\tcout << num << endl;\n\t}\n\n};\n\nint counter::num = 0;//**声明与定义静态数据成员**\n\nvoid main()\n{\n\tcounter a, b;\n\n\ta.shownum(); //调用成员函数访问私有静态数据成员\n\n\tb.shownum();\n\n\ta.setnum(10);\n\n\ta.shownum();\n\n\tb.shownum();\n\n}\n\n"]],[28685,28685],[29078,29078]]]],null,"gjx16@GJXAIOU"],["dec82f23-be7d-4c21-a767-b17468a48ea7",1543121889591,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁;\n   * c++面向对象模型初探;  \n   * c++面向对象多态原理探究;\n   * 操作符重载;\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;//定义两个对象c1和c2\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”，\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n\t\n};\n\n```\nTeacher.cpp\n//具体实现函数内容，在函数名前面加上`类名::`\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1:设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)//因为类的成员变量这里都是private:\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n###  (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n###  (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//需要重载=号操作符，才能解决带来的浅拷贝问题\n\n\tobj2 = obj3; //=号操作，也是一种浅拷贝\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++的默认copy构造函数是浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n\n---\n\n\n### （五）多个对象构造和析构\n\n**1.对象初始化列表**\n\n- 1）对象初始化列表出现原因\n程序本身是有问题的\n```cpp\n\n/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B   //在一个类里面组合了一个带有参数的构造函数的类，因为C++编译器要确定分配给B多大的内存，但是没法初始化A定义的两个对象（因为需要调用有参的构造函数）\n{\npublic:   //没有写B的构造函数，按理说应该调用默认的构造函数\n\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  //主要是因为没有方法和没有机会去初始化这两个A定义的对象\n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB;\n\treturn 0;\n\n}\n\n```\n\n解决方法：\n```cpp\n/*\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n};\n\n\nclass B  \n{\npublic:   \n//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）\n\tB(int _a, int _b) : a1(1), a2(3)  \n\t{\n\n\t}\n//第二种参数传递的方法：\n/*\nB(int _a, int _b,int m,int n) : a1(m), a2(n)  \n\t{\n      a = _a;\n      b = _b;\n\t}\n\t\n*/\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  \n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB(1,2);\n\t//第二种方式：B objB(1,2,4,3)\n\treturn 0;\n\n}\n\n```\n\n**以上程序的操作顺序：**\n首先执行被组合对象的构造函数（a1,a2），如果有多个组合对象，则按照定义的顺序，而不是按照初始化列表的顺序（：后面的顺序）\n析构函数：和构造函数的调用顺序相反\n\n  - 1.必须这样做：\n    - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    - 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n  - 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    - 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    - 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n- 2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n```cpp\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n{\n // some other assignment operation\n}\n```\n\n\n- 3）注意概念\n  - 初始化：被初始化的对象正在创建\n  - 赋值：被赋值的对象已经存在\n\n- 4）注意：\n  - 成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n  - 初始化列表先于构造函数的函数体执行\n\n**说明：**\n\n* 1 C++中提供了初始化列表对成员变量进行初始化\n* 2 使用初始化列表出现原因：\n  * 1.必须这样做：\n    * 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n    * 而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    * 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n  * 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    * 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    * 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n```cpp\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n ABC(int a, int b, int c)\n {\n this->a = a;\n this->b = b;\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"ABC construct ..\\n\");\n }\n\n ~ABC()\n {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n }\n\nprotected:\nprivate:\n int a;\n int b;\n int c;\n};\n\nclass MyD\n{\npublic:\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n {\n cout<<\"MyD()\"<<endl;\n }\n\n ~MyD()\n {\n cout<<\"~MyD()\"<<endl;\n }\n\nprotected:\nprivate:\n ABC abc1; //c++编译器不知道如何构造abc1\n ABC abc2;\n const int m;\n};\n\nint run()\n{\n MyD myD;\n return 0;\n}\n\nint main_dem03()\n{\n run();\n system(\"pause\");\n return 0;\n}\n\n```\n\n\n\n\n### （六）构造函数和析构函数的调用顺序研究\n\n**构造函数与析构函数的调用顺序**\n\n- 1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n- 2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n### （七）构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1构造析构综合训练**\n```cpp\n\n/*\n\n总结 构造和析构的调用顺序\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n\tABC(int a, int b, int c)   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\n\t}\n\n\t~ABC()\n\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\n\nclass MyD \n{\npublic:\n\tMyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~MyD()\n\t{\n\t\tcout << \"~MyD()\" << endl;\n\t}\n\n\tMyD(const MyD & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\tcout << \"MyD(const MyD &obj)\" << endl;\n\t}\n\nprotected:\nprivate:\n\tABC abc1; //c++编译器不知道如何构造abc1//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\tABC abc2;\n\tconst int m;//因为是const m,所以上面所有的m都进行了赋值\n};\n\n\nint doThing(MyD myel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;\n}\n\n\nint run2()//二\n{\n\tMyD myD;//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\treturn 0;\n}\n\nint run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main()\n{\n\trun2();//一\n\t//run3();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n\n\n```\n\n\n**2匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3匿名对象强化训练**\n\n3） 构造中调用构造\n\n```cpp\n/*\n\n构造中调用构造\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass MyTest\n{\npublic:\n\tMyTest(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t}\n\n\tMyTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\n\t\tMyTest(a, b, 10);\n\t}\n\n\t~MyTest()\n\t{\n\t\tcout << \"MyTest is ...\" << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n\n\npublic:\n\tint getC() const { return c; }\n\n\tvoid setC(int val) { c = val; }\n};\n\nint main()\n{\n\tMyTest t1(1, 2);\n\tcout << t1.getC() << endl;\n\tsystem(\"pause\");\n\treturn 0;\n\t\n}\n\n\n```\n\n 结论： 构造函数中调用构造函数，是一个蹩脚的行为。\n程序内存图：\n![搜狗截图20181124125452]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181124125452.png)\n\n### （八）对象的动态建立和释放\n\n**1.new和delete基本语法**\n```cpp\n/*\n\nnew 和delete的使用\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nvoid main()\n{\n\t//先分配内存然后赋值\n\tint *p = new int;  //分配基础类型\n\t*p = 20;  \n\n\t//在定义的时候直接分配内存\n\tint *p1 = new int(30);\n\tcout << *p1 << endl;\n\n\tsystem(\"pause\");\n\treturn; \n}\n\n```\n\n- 1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n  **注意： new和delete是运算符，不是函数，因此执行效率高。**\n\n- 2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： \nnew int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 \nnew char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址    new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n- 3）new和delete运算符使用的一般格式为：\n  用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n![new运算符动态]($resource/new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%A8%E6%80%81.png)\n```cpp\n\n/*\n使用malloc /free 与new /delete的区别\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest();\n\t~Test();\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\nTest::Test()\n{\n\tcout << \"执行了构造函数\" << endl;\n}\n\nTest::~Test()\n{\n\tcout << \"执行了析构函数\" << endl;\n}\n\n\n\nint main()\n{\n\t//基础类型\n\tint *p1 = (int *)malloc(sizeof(int));\n\t*p1 = 10;\n\tdelete p1;\n\n\tint *p2 = new int;\n\t*p2 = 20;\n\tfree(p2);\n\n\n\n\t//数组类型（元素为基础类型）\n\tint *p3 = (int *)malloc(sizeof(int)*10);\n\tp3[0] = 1;\n\tdelete[]p3;\n\n\tint *p4 = new int[10];\n\tp4[1] = 2;\n\tfree(p4);\n\n\n\t//类\n\tTest *p5 = (Test *)malloc(sizeof(Test));\n\tdelete p5;\n\n\tTest *p6 = new Test(10);\n\tfree(p6);\n}\n\n\n```\n**结论：** \nnew：不仅分配内存，而且调用了构造函数\ndelete:不仅释放了内存，而且调用了析构函数\n\n- 4） 应用举例\n\n![5]($resource/5.png)\n\n**2类对象的动态建立和释放**\n\n- 使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n-  C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n  比如：\n\n  Box *pt;  //定义一个指向Box类对象的指针变量pt\n      pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n   这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n  新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n   在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3.编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n\n\n\n## 四、静态成员变量和成员函数\n\n\n思考：每个变量，拥有属性。有没有一些属性，归所有对象拥有？\n\n**4.1****静态成员变量**\n\n**1****）定义静态成员变量**\n\nØ 关键字 **static**  可以用于说明一个类的成员，\n\n  静态成员提供了一个同类对象的共享机制\n\nØ  把一个类的成员说明为 **static**  时，这个类无论有多少个对象被创建，这些对象共享这个 **static**  成员\n\nØ  静态成员局部于类，它不是对象成员\n\n例如：\n\n```cpp\n\n/*\n静态成员变量\n*/\n\n#include<iostream>\nusing namespace std;\n\nclass counter\n{\n\n\tstatic int num; //**声明与定义静态数据成员**\n\npublic:\n\n\tvoid setnum(int i) \n\t{ \n\t\tnum = i; \n\t} //成员函数访问静态数据成员\n\n\tvoid shownum() \n\t{ \n\t\tcout << num << endl;\n\t}\n\n};\n\nint counter::num = 0;//**声明与定义静态数据成员**\n\nvoid main()\n{\n\tcounter a, b;\n\n\ta.shownum(); //调用成员函数访问私有静态数据成员\n\n\tb.shownum();\n\n\ta.setnum(10);\n\n\ta.shownum();\n\n\tb.shownum();\n\n}\n\n```\n\n\n从结果可以看出，**访问的是同一个静态数据成员**\n\n**2****）使用静态成员变量**\n\n**_//_** **_例5-14_** **_使用公有静态数据成员_**\n\n#include<iostream.h>\n\nclass counter\n\n{ public :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n\n**4.2****静态成员函数**\n\n1）概念\n\nØ 静态成员函数数冠以关键字static\n\nØ  静态成员函数提供不依赖于类数据结构的共同操作，它没有this指针\n\nØ  在类外调用静态成员函数用 “**_类名_ ::** ”作限定词，或通过对象调用\n\n2）案例\n\n3）疑难问题：静态成员函数中，不能使用普通变量。\n\n //静态成员变量属于整个类的，分不清楚，是那个具体对象的属性。\n\n**4.3****综合训练**\n\n\n\n\n\n\n\n\n\n",[[1543121829490,["gjx16@GJXAIOU",[[-1,29093,"**"]],[29095,29095],[29093,29093]]],[1543121832517,["gjx16@GJXAIOU",[[-1,29106,"**"]],[29106,29108],[29106,29106]]],[1543123026596,["gjx16@GJXAIOU",[[-1,28490,"**4.1****"]],[28492,28499],[28490,28490]]],[1543123029339,["gjx16@GJXAIOU",[[1,28492,"#"]],[28492,28492],[28493,28493]]],[1543123149213,[null,[[1,28490,"###"],[-1,28492,"#"]],[28490,28490],[28492,28492]]],[1543123149213,[null,[[-1,28490,"###"],[1,28495,"#"]],[28492,28492],[28490,28490]]],[1543123148736,["gjx16@GJXAIOU",[[1,28493," （）"]],[28493,28493],[28496,28496]]],[1543123209164,[null,[[-1,28490,"静态"],[1,28492,"##"],[1,28496,"静态"]],[28490,28490],[28498,28498]]],[1543123209164,[null,[[1,28490,"静态"],[-1,28490,"##"],[-1,28496,"静态"]],[28498,28498],[28490,28490]]],[1543123152899,["gjx16@GJXAIOU",[[1,28495,"一"]],[28495,28495],[28496,28496]]],[1543123155848,["gjx16@GJXAIOU",[[-1,28503,"**"]],[28505,28505],[28503,28503]]],[1543123329207,[null,[[-1,28490,"静态"],[1,28492,"##"],[1,28497,"静态"],[-1,28501,"**"],[1,28503,"\n\n"]],[28490,28490],[28505,28505]]],[1543123329207,[null,[[1,28490,"静态"],[-1,28490,"##"],[-1,28497,"静态"],[1,28503,"**"],[-1,28503,"\n\n"]],[28505,28505],[28490,28490]]],[1543123278732,["gjx16@GJXAIOU",[[-1,28508,"****）"]],[28508,28513],[28508,28508]]],[1543123281405,["gjx16@GJXAIOU",[[1,28505,"- "]],[28505,28505],[28507,28507]]],[1543123288739,["gjx16@GJXAIOU",[[-1,28522,"Ø "]],[28522,28524],[28522,28522]]],[1543123291035,["gjx16@GJXAIOU",[[1,28522,"  - "]],[28522,28522],[28526,28526]]],[1543123294302,["gjx16@GJXAIOU",[[1,28559,"  "]],[28559,28559],[28561,28561]]],[1543123296066,["gjx16@GJXAIOU",[[-1,28556,"\n"]],[28556,28556],[28555,28555]]],[1543123306169,["gjx16@GJXAIOU",[[-1,28580,"Ø  "]],[28580,28583],[28580,28580]]],[1543123308621,["gjx16@GJXAIOU",[[1,28580,"  - "]],[28580,28580],[28584,28584]]],[1543123316754,["gjx16@GJXAIOU",[[-1,28649,"Ø  "]],[28649,28652],[28649,28649]]],[1543123318579,["gjx16@GJXAIOU",[[1,28649,"  - "]],[28649,28649],[28653,28653]]],[1543123323325,["gjx16@GJXAIOU",[[-1,28521,"\n"]],[28521,28521],[28520,28520]]],[1543123389230,[null,[[-1,28490,"静态"],[1,28492,"##"],[1,28497,"静态"],[-1,28501,"****"],[1,28505,"\n\n"],[-1,28507,"1"],[1,28510,"1定义"],[-1,28519,"\nØ"],[1,28525,"关键"],[-1,28553,"\n"],[1,28554,"   "],[-1,28557,"  "],[-1,28577,"Ø "],[1,28583,"把一"],[-1,28646,"Ø "],[1,28652,"静态"]],[28490,28490],[28654,28654]]],[1543123389230,[null,[[1,28490,"静态"],[-1,28490,"##"],[-1,28497,"静态"],[1,28503,"****"],[-1,28503,"\n\n"],[1,28507,"1"],[-1,28509,"1定义"],[1,28521,"\nØ"],[-1,28525,"关键"],[1,28555,"\n"],[-1,28555,"   "],[1,28561,"  "],[1,28579,"Ø "],[-1,28583,"把一"],[1,28648,"Ø "],[-1,28652,"静态"]],[28654,28654],[28490,28490]]],[1543123333393,["gjx16@GJXAIOU",[[-1,28931,"**"]],[28933,28933],[28931,28931]]],[1543123334944,["gjx16@GJXAIOU",[[-1,28942,"**"]],[28944,28944],[28942,28942]]],[1543123338141,["gjx16@GJXAIOU",[[-1,29077,"\n"]],[29077,29077],[29076,29076]]],[1543123341818,["gjx16@GJXAIOU",[[1,29077,"**"],[1,29098,"**"]],[29077,29098],[29077,29102]]],[1543123345864,["gjx16@GJXAIOU",[[-1,29107,"****）"]],[29107,29112],[29107,29107]]],[1543123348988,["gjx16@GJXAIOU",[[1,29104,"- "]],[29104,29104],[29106,29106]]],[1543123369313,["gjx16@GJXAIOU",[[1,28670,"\n"]],[28669,28669],[28670,28670]]],[1543123379940,["gjx16@GJXAIOU",[[1,28670,"![1]($resource/1.png)"]],[28670,28670],[28692,28692]]],[1543123383630,["gjx16@GJXAIOU",[[1,28692,"\n"]],[28691,28691],[28692,28692]]],[1543123449255,[null,[[-1,28490,"静态"],[1,28492,"##"],[1,28497,"静态"],[-1,28501,"****"],[1,28505,"\n\n"],[-1,28507,"1"],[1,28510,"1定义"],[-1,28519,"\nØ"],[1,28525,"关键"],[-1,28553,"\n 静态"],[1,28557,"  "],[1,28559,"静态"],[-1,28577,"Ø "],[1,28583,"把一"],[-1,28646,"Ø "],[1,28652,"静态"],[-1,28668,"例如"],[1,28693,"例如"],[-1,28952,"**"],[1,28954,"声明"],[-1,28963,"**"],[1,28965,"\n\n"],[-1,29098,"\n从"],[1,29102,"从结"],[-1,29121,"\n\n"],[-1,29125,"**"],[1,29127,"\n\n"],[-1,29129,"2"],[1,29132,"2使用"]],[28490,28490],[29135,29135]]],[1543123449255,[null,[[1,28490,"静态"],[-1,28490,"##"],[-1,28497,"静态"],[1,28503,"****"],[-1,28503,"\n\n"],[1,28507,"1"],[-1,28509,"1定义"],[1,28521,"\nØ"],[-1,28525,"关键"],[1,28555,"\n 静态"],[-1,28555,"  "],[-1,28559,"静态"],[1,28579,"Ø "],[-1,28583,"把一"],[1,28648,"Ø "],[-1,28652,"静态"],[1,28670,"例如"],[-1,28693,"例如"],[1,28954,"**"],[-1,28954,"声明"],[1,28965,"**"],[-1,28965,"\n\n"],[1,29100,"\n从"],[-1,29102,"从结"],[1,29123,"\n\n"],[1,29125,"**"],[-1,29125,"\n\n"],[1,29129,"2"],[-1,29131,"2使用"]],[29135,29135],[28490,28490]]],[1543123402029,["gjx16@GJXAIOU",[[1,29100,"\n"]],[29099,29099],[29100,29100]]],[1543123402377,["gjx16@GJXAIOU",[[1,29100,"、"]],[29100,29100],[29101,29101]]],[1543123404369,["gjx16@GJXAIOU",[[-1,29100,"、"]],[29101,29101],[29100,29100]]],[1543123429052,["gjx16@GJXAIOU",[[1,29100,"![6]($resource/6.png)"]],[29100,29100],[29122,29122]]],[1543123431632,["gjx16@GJXAIOU",[[1,29122,"\n"]],[29121,29121],[29122,29122]]],[1543123509391,[null,[[-1,28490,"静态"],[1,28492,"##"],[1,28497,"静态"],[-1,28501,"****"],[1,28505,"\n\n"],[-1,28507,"1"],[1,28510,"1定义"],[-1,28519,"\nØ"],[1,28525,"关键"],[-1,28553,"\n 静态"],[1,28557,"  "],[1,28559,"静态"],[-1,28577,"Ø "],[1,28583,"把一"],[-1,28646,"Ø "],[1,28652,"静态"],[-1,28668,"例如"],[1,28693,"例如"],[-1,28952,"**"],[1,28954,"声明"],[-1,28963,"**"],[1,28965,"\n\n"],[-1,29098,"\n从"],[1,29125,"从结"],[-1,29144,"\n\n*"],[-1,29149,"*"],[1,29150,"\n\n"],[-1,29152,"2"],[1,29155,"2使用"]],[28490,28490],[29158,29158]]],[1543123509391,[null,[[1,28490,"静态"],[-1,28490,"##"],[-1,28497,"静态"],[1,28503,"****"],[-1,28503,"\n\n"],[1,28507,"1"],[-1,28509,"1定义"],[1,28521,"\nØ"],[-1,28525,"关键"],[1,28555,"\n 静态"],[-1,28555,"  "],[-1,28559,"静态"],[1,28579,"Ø "],[-1,28583,"把一"],[1,28648,"Ø "],[-1,28652,"静态"],[1,28670,"例如"],[-1,28693,"例如"],[1,28954,"**"],[-1,28954,"声明"],[1,28965,"**"],[-1,28965,"\n\n"],[1,29100,"\n从"],[-1,29125,"从结"],[1,29146,"\n\n*"],[1,29148,"*"],[-1,29148,"\n\n"],[1,29152,"2"],[-1,29154,"2使用"]],[29158,29158],[28490,28490]]],[1543123498162,["gjx16@GJXAIOU",[[1,29166,"·"]],[29166,29166],[29167,29167]]],[1543123499398,["gjx16@GJXAIOU",[[-1,29166,"·"]],[29167,29167],[29166,29166]]],[1543123500968,["gjx16@GJXAIOU",[[1,29166,"```"]],[29166,29166],[29169,29169]]],[1543123501066,["gjx16@GJXAIOU",[[1,29169,"language\n```\n"]],[29169,29169],[29169,29177]]],[1543123502613,["gjx16@GJXAIOU",[[-1,29169,"language"],[1,29177,"c"]],[29169,29177],[29170,29170]]],[1543123503234,["gjx16@GJXAIOU",[[1,29170,"pp"]],[29170,29170],[29172,29172]]],[1543123503758,["gjx16@GJXAIOU",[[1,29173,"\n"]],[29172,29172],[29173,29173]]],[1543123569486,[null,[[-1,28490,"静态"],[1,28492,"##"],[1,28497,"静态"],[-1,28501,"****"],[1,28505,"\n\n"],[-1,28507,"1"],[1,28510,"1定义"],[-1,28519,"\nØ"],[1,28525,"关键"],[-1,28553,"\n 静态"],[1,28557,"  "],[1,28559,"静态"],[-1,28577,"Ø "],[1,28583,"把一"],[-1,28646,"Ø "],[1,28652,"静态"],[-1,28668,"例如"],[1,28693,"例如"],[-1,28952,"**"],[1,28954,"声明"],[-1,28963,"**"],[1,28965,"\n\n"],[-1,29098,"\n从"],[1,29125,"从结"],[-1,29144,"\n\n**"],[1,29150,"\n\n"],[-1,29152,"2"],[1,29155,"2使用"],[-1,29164,"\n*"],[1,29178,"\n*"]],[28490,28490],[29180,29180]]],[1543123569486,[null,[[1,28490,"静态"],[-1,28490,"##"],[-1,28497,"静态"],[1,28503,"****"],[-1,28503,"\n\n"],[1,28507,"1"],[-1,28509,"1定义"],[1,28521,"\nØ"],[-1,28525,"关键"],[1,28555,"\n 静态"],[-1,28555,"  "],[-1,28559,"静态"],[1,28579,"Ø "],[-1,28583,"把一"],[1,28648,"Ø "],[-1,28652,"静态"],[1,28670,"例如"],[-1,28693,"例如"],[1,28954,"**"],[-1,28954,"声明"],[1,28965,"**"],[-1,28965,"\n\n"],[1,29100,"\n从"],[-1,29125,"从结"],[1,29146,"\n\n**"],[-1,29148,"\n\n"],[1,29152,"2"],[-1,29154,"2使用"],[1,29166,"\n*"],[-1,29178,"\n*"]],[29180,29180],[28490,28490]]],[1543123520920,["gjx16@GJXAIOU",[[-1,29179,"**_//_** **_例5-14_** **_使用公有静态数据成员_**\n\n#include<iostream.h>\n\nclass counter\n\n{ public :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n"]],[29179,29689],[29179,29179]]],[1543123524955,["gjx16@GJXAIOU",[[1,29173,"**_//_** **_例5-14_** **_使用公有静态数据成员_**\n\n#include<iostream.h>\n\nclass counter\n\n{ public :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n"]],[29173,29173],[29683,29683]]],[1543123531099,["gjx16@GJXAIOU",[[-1,29173,"**_"],[-1,29177,"/_** **_"]],[29173,29185],[29174,29174]]],[1543123531424,["gjx16@GJXAIOU",[[1,29174,"/"]],[29174,29174],[29175,29175]]],[1543123535797,["gjx16@GJXAIOU",[[-1,29181,"** **_"]],[29180,29186],[29180,29180]]],[1543123539068,["gjx16@GJXAIOU",[[-1,29191,"_**"]],[29191,29194],[29191,29191]]],[1543123547050,["gjx16@GJXAIOU",[[1,29232,"\n"]],[29232,29232],[29233,29233]]],[1543123548146,["gjx16@GJXAIOU",[[-1,29229,"\n"]],[29229,29229],[29228,29228]]],[1543123563127,["gjx16@GJXAIOU",[[-1,29673,"4.2****"]],[29672,29679],[29672,29672]]],[1543123564695,["gjx16@GJXAIOU",[[-1,29671,"**"]],[29673,29673],[29671,29671]]],[1543123568895,["gjx16@GJXAIOU",[[1,29671,"### ()"]],[29671,29671],[29677,29677]]],[1543123629501,[null,[[-1,28490,"静态"],[1,28492,"##"],[1,28497,"静态"],[-1,28501,"****"],[1,28505,"\n\n"],[-1,28507,"1"],[1,28510,"1定义"],[-1,28519,"\nØ"],[1,28525,"关键"],[-1,28553,"\n 静态"],[1,28557,"  "],[1,28559,"静态"],[-1,28577,"Ø "],[1,28583,"把一"],[-1,28646,"Ø "],[1,28652,"静态"],[-1,28668,"例如"],[1,28693,"例如"],[-1,28952,"**"],[1,28954,"声明"],[-1,28963,"**"],[1,28965,"\n\n"],[-1,29098,"\n从"],[1,29125,"从结"],[-1,29144,"\n\n**"],[1,29150,"\n\n"],[-1,29152,"2"],[1,29155,"2使用"],[-1,29164,"\n*"],[-1,29669,"**"],[1,29671,"\n\n"],[1,29677,"静态"]],[28490,28490],[29679,29679]]],[1543123629501,[null,[[1,28490,"静态"],[-1,28490,"##"],[-1,28497,"静态"],[1,28503,"****"],[-1,28503,"\n\n"],[1,28507,"1"],[-1,28509,"1定义"],[1,28521,"\nØ"],[-1,28525,"关键"],[1,28555,"\n 静态"],[-1,28555,"  "],[-1,28559,"静态"],[1,28579,"Ø "],[-1,28583,"把一"],[1,28648,"Ø "],[-1,28652,"静态"],[1,28670,"例如"],[-1,28693,"例如"],[1,28954,"**"],[-1,28954,"声明"],[1,28965,"**"],[-1,28965,"\n\n"],[1,29100,"\n从"],[-1,29125,"从结"],[1,29146,"\n\n**"],[-1,29148,"\n\n"],[1,29152,"2"],[-1,29154,"2使用"],[1,29166,"\n*"],[1,29669,"**"],[-1,29669,"\n\n"],[-1,29677,"静态"]],[29679,29679],[28490,28490]]],[1543123570488,["gjx16@GJXAIOU",[[1,29676,"er"]],[29676,29676],[29678,29678]]],[1543123573133,["gjx16@GJXAIOU",[[-1,29676,"er"]],[29678,29678],[29676,29676]]],[1543123574600,["gjx16@GJXAIOU",[[1,29676,"二"]],[29676,29676],[29677,29677]]],[1543123577866,["gjx16@GJXAIOU",[[-1,29684,"**"]],[29686,29686],[29684,29684]]],[1543123583250,["gjx16@GJXAIOU",[[1,29686,"**"],[1,29690,"**"]],[29686,29690],[29686,29694]]],[1543123585617,["gjx16@GJXAIOU",[[1,29686,"- "]],[29686,29686],[29688,29688]]],[1543123590375,["gjx16@GJXAIOU",[[-1,29698,"Ø "]],[29698,29700],[29698,29698]]],[1543123592045,["gjx16@GJXAIOU",[[-1,29718,"Ø  "]],[29718,29721],[29718,29718]]],[1543123594798,["gjx16@GJXAIOU",[[-1,29752,"Ø  "]],[29752,29754],[29752,29752]]],[1543123597386,["gjx16@GJXAIOU",[[1,29698,"  - "]],[29698,29698],[29702,29702]]],[1543123599872,["gjx16@GJXAIOU",[[1,29722,"  - "]],[29722,29722],[29726,29726]]],[1543123602115,["gjx16@GJXAIOU",[[1,29760,"  - "]],[29760,29760],[29764,29764]]],[1543123608625,["gjx16@GJXAIOU",[[-1,29777,"“**"],[1,29780,"·"]],[29777,29777],[29778,29778]]],[1543123610135,["gjx16@GJXAIOU",[[-1,29777,"·"]],[29778,29778],[29777,29777]]],[1543123610568,["gjx16@GJXAIOU",[[1,29777,"`"]],[29777,29777],[29778,29778]]],[1543123614928,["gjx16@GJXAIOU",[[1,29785,"`"],[1,29789,"`"]],[29785,29789],[29785,29791]]],[1543123618679,["gjx16@GJXAIOU",[[-1,29786,"** ”`"]],[29786,29791],[29786,29786]]],[1543123625589,["gjx16@GJXAIOU",[[1,29800,"- "]],[29800,29800],[29802,29802]]],[1543123628494,["gjx16@GJXAIOU",[[1,29802,"**"],[1,29806,"**"]],[29802,29806],[29802,29810]]],[1543123689530,[null,[[-1,28490,"静态"],[1,28492,"##"],[1,28497,"静态"],[-1,28501,"****"],[1,28505,"\n\n"],[-1,28507,"1"],[1,28510,"1定义"],[-1,28519,"\nØ"],[1,28525,"关键"],[-1,28553,"\n 静态"],[1,28557,"  "],[1,28559,"静态"],[-1,28577,"Ø "],[1,28583,"把一"],[-1,28646,"Ø "],[1,28652,"静态"],[-1,28668,"例如"],[1,28693,"例如"],[-1,28952,"**"],[1,28954,"声明"],[-1,28963,"**"],[1,28965,"\n\n"],[-1,29098,"\n从"],[1,29125,"从结"],[-1,29144,"\n\n**"],[1,29150,"\n\n"],[-1,29152,"2"],[1,29155,"2使用"],[-1,29164,"\n*"],[-1,29669,"**"],[1,29671,"\n\n"],[1,29678,"静态"],[1,29682,"\n\n- "],[-1,29686,"- "],[1,29688,"概念"],[-1,29690,"概念"],[-1,29694,"**Ø "],[1,29702,"静态"],[-1,29720,"Ø"],[-1,29723," "],[1,29726,"静态"],[-1,29758,"Ø "],[1,29764,"在类"],[-1,29775,"“*"],[1,29778,"_类"],[-1,29783,"**"],[1,29786,"作限"],[-1,29798,"2）"],[1,29804,"2）"],[1,29806,"**"],[-1,29808,"**"]],[28490,28490],[29808,29808]]],[1543123689530,[null,[[1,28490,"静态"],[-1,28490,"##"],[-1,28497,"静态"],[1,28503,"****"],[-1,28503,"\n\n"],[1,28507,"1"],[-1,28509,"1定义"],[1,28521,"\nØ"],[-1,28525,"关键"],[1,28555,"\n 静态"],[-1,28555,"  "],[-1,28559,"静态"],[1,28579,"Ø "],[-1,28583,"把一"],[1,28648,"Ø "],[-1,28652,"静态"],[1,28670,"例如"],[-1,28693,"例如"],[1,28954,"**"],[-1,28954,"声明"],[1,28965,"**"],[-1,28965,"\n\n"],[1,29100,"\n从"],[-1,29125,"从结"],[1,29146,"\n\n**"],[-1,29148,"\n\n"],[1,29152,"2"],[-1,29154,"2使用"],[1,29166,"\n*"],[1,29669,"**"],[-1,29669,"\n\n"],[-1,29678,"静态"],[-1,29684,"\n\n- "],[1,29692,"- "],[-1,29692,"概念"],[1,29696,"概念"],[1,29698,"**Ø "],[-1,29702,"静态"],[1,29722,"Ø"],[1,29724," "],[-1,29726,"静态"],[1,29760,"Ø "],[-1,29764,"在类"],[1,29777,"“*"],[-1,29778,"_类"],[1,29785,"**"],[-1,29786,"作限"],[1,29800,"2）"],[-1,29804,"2）"],[-1,29808,"**"],[1,29812,"**"]],[29808,29808],[28490,28490]]],[1543123630806,["gjx16@GJXAIOU",[[1,29812,"- "]],[29812,29812],[29814,29814]]],[1543123635205,["gjx16@GJXAIOU",[[1,29814,"**"],[1,29821,"**"]],[29814,29821],[29814,29825]]],[1543123638179,["gjx16@GJXAIOU",[[1,29825,"\n"]],[29825,29825],[29826,29826]]],[1543123640718,["gjx16@GJXAIOU",[[-1,29844,"\n"]],[29844,29844],[29843,29843]]],[1543123643481,["gjx16@GJXAIOU",[[-1,29844," "]],[29845,29845],[29844,29844]]],[1543123646328,["gjx16@GJXAIOU",[[1,29826,"\n"]],[29826,29826],[29827,29827]]],[1543123649359,["gjx16@GJXAIOU",[[-1,29826,"\n"]],[29827,29827],[29826,29826]]],[1543123675979,["gjx16@GJXAIOU",[[1,29811,"![7]($resource/7.png)"]],[29811,29811],[29833,29833]]],[1543123736562,[null,[[-1,28490,"静态"],[1,28492,"##"],[1,28497,"静态"],[-1,28501,"****"],[1,28505,"\n\n"],[-1,28507,"1"],[1,28510,"1定义"],[-1,28519,"\nØ"],[1,28525,"关键"],[-1,28553,"\n 静态"],[1,28557,"  "],[1,28559,"静态"],[-1,28577,"Ø "],[1,28583,"把一"],[-1,28646,"Ø "],[1,28652,"静态"],[-1,28668,"例如"],[1,28693,"例如"],[-1,28952,"**"],[1,28954,"声明"],[-1,28963,"**"],[1,28965,"\n\n"],[-1,29098,"\n从"],[1,29125,"从结"],[-1,29144,"\n\n**"],[1,29150,"\n\n"],[-1,29152,"2"],[1,29155,"2使用"],[-1,29164,"\n*"],[-1,29669,"**"],[1,29671,"\n\n"],[1,29678,"静态"],[1,29682,"\n\n- "],[-1,29686,"- "],[1,29688,"概念"],[-1,29690,"概念"],[-1,29694,"**Ø"],[-1,29699," "],[1,29702,"静态"],[-1,29720,"Ø "],[1,29726,"静态"],[-1,29758,"Ø "],[1,29764,"在类"],[-1,29775,"“*"],[1,29778,"_类"],[-1,29783,"**"],[1,29786,"作限"],[-1,29798,"2）"],[1,29804,"2）"],[-1,29806,"\n\n"],[-1,29810,"3"],[1,29811,"\n"],[-1,29832,"）"],[1,29833,"\n"],[1,29837,"3）"],[-1,29842,"静态"],[1,29847,"静态"],[-1,29863,"\n "],[1,29865,"//"]],[28490,28490],[29867,29867]]],[1543123736562,[null,[[1,28490,"静态"],[-1,28490,"##"],[-1,28497,"静态"],[1,28503,"****"],[-1,28503,"\n\n"],[1,28507,"1"],[-1,28509,"1定义"],[1,28521,"\nØ"],[-1,28525,"关键"],[1,28555,"\n 静态"],[-1,28555,"  "],[-1,28559,"静态"],[1,28579,"Ø "],[-1,28583,"把一"],[1,28648,"Ø "],[-1,28652,"静态"],[1,28670,"例如"],[-1,28693,"例如"],[1,28954,"**"],[-1,28954,"声明"],[1,28965,"**"],[-1,28965,"\n\n"],[1,29100,"\n从"],[-1,29125,"从结"],[1,29146,"\n\n**"],[-1,29148,"\n\n"],[1,29152,"2"],[-1,29154,"2使用"],[1,29166,"\n*"],[1,29669,"**"],[-1,29669,"\n\n"],[-1,29678,"静态"],[-1,29684,"\n\n- "],[1,29692,"- "],[-1,29692,"概念"],[1,29696,"概念"],[1,29698,"**Ø"],[1,29700," "],[-1,29702,"静态"],[1,29722,"Ø "],[-1,29726,"静态"],[1,29760,"Ø "],[-1,29764,"在类"],[1,29777,"“*"],[-1,29778,"_类"],[1,29785,"**"],[-1,29786,"作限"],[1,29800,"2）"],[-1,29804,"2）"],[1,29808,"\n\n"],[1,29810,"3"],[-1,29810,"\n"],[1,29832,"）"],[-1,29832,"\n"],[-1,29837,"3）"],[1,29844,"静态"],[-1,29847,"静态"],[1,29865,"\n "],[-1,29865,"//"]],[29867,29867],[28490,28490]]],[1543123717296,["gjx16@GJXAIOU",[[1,29898,"\n"]],[29897,29897],[29898,29898]]],[1543123725670,["gjx16@GJXAIOU",[[1,29897,"![成员函数中的疑难问题]($resource/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98.png)"]],[29897,29897],[30017,30017]]],[1543123734646,["gjx16@GJXAIOU",[[-1,30023,"****"]],[30027,30027],[30023,30023]]],[1543123735760,["gjx16@GJXAIOU",[[1,30023," "]],[30023,30023],[30024,30024]]],[1543123796597,[null,[[-1,28490,"静态"],[1,28492,"##"],[1,28497,"静态"],[-1,28501,"****"],[1,28505,"\n\n"],[-1,28507,"1"],[1,28510,"1定义"],[-1,28519,"\nØ"],[1,28525,"关键"],[-1,28553,"\n 静态"],[1,28557,"  "],[1,28559,"静态"],[-1,28577,"Ø "],[1,28583,"把一"],[-1,28646,"Ø "],[1,28652,"静态"],[-1,28668,"例如"],[1,28693,"例如"],[-1,28952,"**"],[1,28954,"声明"],[-1,28963,"**"],[1,28965,"\n\n"],[-1,29098,"\n从"],[1,29125,"从结"],[-1,29144,"\n\n**"],[1,29150,"\n\n"],[-1,29152,"2"],[1,29155,"2使用"],[-1,29164,"\n*"],[-1,29669,"**"],[1,29671,"\n\n"],[1,29678,"静态"],[1,29682,"\n\n- "],[-1,29686,"- **"],[-1,29692,"\n\n"],[-1,29696,"Ø "],[1,29698,"\n\n"],[1,29702,"静态"],[-1,29720,"Ø "],[1,29726,"静态"],[-1,29758,"Ø "],[1,29764,"在类"],[-1,29775,"“*"],[1,29778,"_类"],[-1,29783,"**"],[1,29786,"作限"],[-1,29798,"2）"],[1,29804,"2）"],[-1,29806,"\n\n"],[-1,29810,"3"],[1,29811,"\n"],[-1,29832,"）"],[1,29833,"\n"],[1,29837,"3）"],[-1,29842,"静态"],[1,29847,"静态"],[-1,29863,"\n "],[1,29865,"//"],[-1,29895,"\n*"],[-1,30016,"*\n"],[1,30018,"\n\n**"],[-1,30021,"**"],[1,30024,"综合"]],[28490,28490],[30026,30026]]],[1543123796597,[null,[[1,28490,"静态"],[-1,28490,"##"],[-1,28497,"静态"],[1,28503,"****"],[-1,28503,"\n\n"],[1,28507,"1"],[-1,28509,"1定义"],[1,28521,"\nØ"],[-1,28525,"关键"],[1,28555,"\n 静态"],[-1,28555,"  "],[-1,28559,"静态"],[1,28579,"Ø "],[-1,28583,"把一"],[1,28648,"Ø "],[-1,28652,"静态"],[1,28670,"例如"],[-1,28693,"例如"],[1,28954,"**"],[-1,28954,"声明"],[1,28965,"**"],[-1,28965,"\n\n"],[1,29100,"\n从"],[-1,29125,"从结"],[1,29146,"\n\n**"],[-1,29148,"\n\n"],[1,29152,"2"],[-1,29154,"2使用"],[1,29166,"\n*"],[1,29669,"**"],[-1,29669,"\n\n"],[-1,29678,"静态"],[-1,29684,"\n\n- "],[1,29692,"- **"],[1,29694,"\n\n"],[1,29696,"Ø "],[-1,29696,"\n\n"],[-1,29702,"静态"],[1,29722,"Ø "],[-1,29726,"静态"],[1,29760,"Ø "],[-1,29764,"在类"],[1,29777,"“*"],[-1,29778,"_类"],[1,29785,"**"],[-1,29786,"作限"],[1,29800,"2）"],[-1,29804,"2）"],[1,29808,"\n\n"],[1,29810,"3"],[-1,29810,"\n"],[1,29832,"）"],[-1,29832,"\n"],[-1,29837,"3）"],[1,29844,"静态"],[-1,29847,"静态"],[1,29865,"\n "],[-1,29865,"//"],[1,29897,"\n*"],[1,30016,"*\n"],[-1,30016,"\n\n**"],[1,30023,"**"],[-1,30024,"综合"]],[30026,30026],[28490,28490]]],[1543123776966,["gjx16@GJXAIOU",[[-1,29030,"\n"]],[29030,29030],[29029,29029]]],[1543123778088,["gjx16@GJXAIOU",[[-1,29044,"\n"]],[29044,29044],[29043,29043]]],[1543123779654,["gjx16@GJXAIOU",[[-1,29059,"\n"]],[29059,29059],[29058,29058]]],[1543123780758,["gjx16@GJXAIOU",[[-1,29073,"\n"]],[29073,29073],[29072,29072]]],[1543123788568,["gjx16@GJXAIOU",[[1,30036,"\n"]],[30026,30026],[30027,30027]]],[1543123788905,["gjx16@GJXAIOU",[[1,30037,"\n"]],[30027,30027],[30028,30028]]],[1543123856594,[null,[[-1,28490,"静态"],[1,28492,"##"],[1,28497,"静态"],[-1,28501,"****"],[1,28505,"\n\n"],[-1,28507,"1"],[1,28510,"1定义"],[-1,28519,"\nØ"],[1,28525,"关键"],[-1,28553,"\n 静态"],[1,28557,"  "],[1,28559,"静态"],[-1,28577,"Ø "],[1,28583,"把一"],[-1,28646,"Ø "],[1,28652,"静态"],[-1,28668,"例如"],[1,28693,"例如"],[-1,28952,"**"],[1,28954,"声明"],[-1,28963,"**"],[1,28965,"\n\n"],[-1,29028,"\n"],[1,29030,"b"],[-1,29041,"\n"],[1,29044,"a"],[-1,29057,"\n"],[1,29059,"a"],[-1,29071,"\n"],[1,29073,"b"],[-1,29094,"\n从"],[1,29121,"从结"],[-1,29140,"\n\n*"],[-1,29145,"*"],[1,29146,"\n\n"],[-1,29148,"2"],[1,29151,"2使用"],[-1,29160,"\n*"],[-1,29665,"**"],[1,29667,"\n\n"],[1,29674,"静态"],[1,29678,"\n\n- "],[-1,29682,"- **"],[-1,29688,"\n\n"],[-1,29692,"Ø "],[1,29694,"\n\n"],[1,29698,"静态"],[-1,29716,"Ø "],[1,29722,"静态"],[-1,29754,"Ø "],[1,29760,"在类"],[-1,29771,"“*"],[1,29774,"_类"],[-1,29779,"**"],[1,29782,"作限"],[-1,29794,"2）"],[1,29800,"2）"],[-1,29802,"\n\n"],[-1,29806,"3"],[1,29807,"\n"],[-1,29828,"）"],[1,29829,"\n"],[1,29833,"3）"],[-1,29838,"静态"],[1,29843,"静态"],[-1,29859,"\n "],[1,29861,"//"],[-1,29891,"\n*"],[-1,30012,"*\n"],[1,30014,"\n\n**"],[-1,30017,"**"],[1,30020,"综合"]],[28490,28490],[30022,30022]]],[1543123856594,[null,[[1,28490,"静态"],[-1,28490,"##"],[-1,28497,"静态"],[1,28503,"****"],[-1,28503,"\n\n"],[1,28507,"1"],[-1,28509,"1定义"],[1,28521,"\nØ"],[-1,28525,"关键"],[1,28555,"\n 静态"],[-1,28555,"  "],[-1,28559,"静态"],[1,28579,"Ø "],[-1,28583,"把一"],[1,28648,"Ø "],[-1,28652,"静态"],[1,28670,"例如"],[-1,28693,"例如"],[1,28954,"**"],[-1,28954,"声明"],[1,28965,"**"],[-1,28965,"\n\n"],[1,29030,"\n"],[-1,29031,"b"],[1,29043,"\n"],[-1,29045,"a"],[1,29059,"\n"],[-1,29060,"a"],[1,29073,"\n"],[-1,29074,"b"],[1,29096,"\n从"],[-1,29121,"从结"],[1,29142,"\n\n*"],[1,29144,"*"],[-1,29144,"\n\n"],[1,29148,"2"],[-1,29150,"2使用"],[1,29162,"\n*"],[1,29665,"**"],[-1,29665,"\n\n"],[-1,29674,"静态"],[-1,29680,"\n\n- "],[1,29688,"- **"],[1,29690,"\n\n"],[1,29692,"Ø "],[-1,29692,"\n\n"],[-1,29698,"静态"],[1,29718,"Ø "],[-1,29722,"静态"],[1,29756,"Ø "],[-1,29760,"在类"],[1,29773,"“*"],[-1,29774,"_类"],[1,29781,"**"],[-1,29782,"作限"],[1,29796,"2）"],[-1,29800,"2）"],[1,29804,"\n\n"],[1,29806,"3"],[-1,29806,"\n"],[1,29828,"）"],[-1,29828,"\n"],[-1,29833,"3）"],[1,29840,"静态"],[-1,29843,"静态"],[1,29861,"\n "],[-1,29861,"//"],[1,29893,"\n*"],[1,30012,"*\n"],[-1,30012,"\n\n**"],[1,30019,"**"],[-1,30020,"综合"]],[30022,30022],[28490,28490]]],[1543123830106,["gjx16@GJXAIOU",[[1,30038,"\n"]],[30028,30028],[30029,30029]]],[1543123830369,["gjx16@GJXAIOU",[[1,30039,"\n"]],[30029,30029],[30030,30030]]],[1543123831300,["gjx16@GJXAIOU",[[1,30030,"**5 C++****面向对象模型初探**\n\n**前言**\n\nC++对象模型可以概括为以下2部分：\n\n1\\. 语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等等。\n\n2\\. 对于各种支持的底层实现机制。\n\n在c语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。在c++中，通过抽象数据类型（abstract data type，ADT），在类中定义数据和函数，来实现数据和函数直接的绑定。\n\n概括来说，在C++类中有两种成员数据：static、nonstatic；三种成员函数：static、nonstatic、virtual。\n\n**5.1****基础知识**\n\n| \n\nC++中的class从面向对象理论出发，将变量(属性)和函数(方法)集中定义在一起，用于描述现实世界中的类。从计算机的角度，程序依然由数据段和代码段构成。\n\n**C++****编译器如何完成面向对象理论到计算机程序的转化？**\n\n换句话：C++编译器是如何管理类、对象、类和对象之间的关系\n\n具体的说：具体对象调用类中的方法，那，c++编译器是如何区分，是那个具体的类，调用这个方法那?\n\n |\n| \n\n思考一下程序结果\n\n |\n| \n\n#include \"iostream\"\n\nusing namespace std;\n\nclass C1\n\n{\n\npublic:\n\n int i; //4\n\n int j; //4\n\n int k; //4\n\nprotected:\n\nprivate:\n\n}; //12\n\nclass C2\n\n{\n\npublic:\n\n int i; //4\n\n int j; //4\n\n int k; //4\n\n static int m; //4\n\npublic:\n\n int getK() const { return k; } //4\n\n void setK(int val) { k = val; } //4\n\nprotected:\n\nprivate:\n\n}; //12 16 24\n\nstruct S1\n\n{\n\n int i;\n\n int j;\n\n int k;\n\n}; //\n\nstruct S2\n\n{\n\n int i;\n\n int j;\n\n int k;\n\n static int m;\n\n}; //\n\nint main()\n\n{\n\n printf(\"c1:%d \\n\", sizeof(C1));\n\n printf(\"c2:%d \\n\", sizeof(C2));\n\n printf(\"s1:%d \\n\", sizeof(S1));\n\n printf(\"s2:%d \\n\", sizeof(S2));\n\n system(\"pause\");\n\n}\n\n |\n|  |\n\n**5.2****编译器对属性和方法的处理机制**\n\n| \n\n通过上面的案例，我们可以的得出：\n\n1）C++类对象中的成员变量和成员函数是分开存储的\n\n成员变量：\n\n普通成员变量：存储于对象中，与struct变量有相同的内存布局和字节对齐方式\n\n静态成员变量：存储于全局数据区中\n\n成员函数：存储于代码段中。\n\n问题出来了：很多对象共用一块代码？代码是如何区分具体对象的那？\n\n换句话说：int getK() const { return k; }，代码是如何区分，具体obj1、obj2、obj3对象的k值？\n\n |\n| \n\n2）C++编译器对普通成员函数的内部处理\n\n |\n|  |\n| \n\n请仔细思考，并说出你的总结！\n\n |\n\n**5.3****总结**\n\n| \n\n**1****、**C++类对象中的成员变量和成员函数是分开存储的。C语言中的内存四区模型仍然有效！\n\n**2****、C++****中类的普通成员函数都隐式包含一个指向当前对象的this****指针。**\n\n3、静态成员函数、成员变量属于类\n\n静态成员函数与普通成员函数的区别\n\n静态成员函数不包含指向具体对象的指针\n\n普通成员函数包含一个指向具体对象的指针\n\n |\n\n**5.4 this****指针**\n\n实验1：若类成员函数的形参 和 类的属性，名字相同，通过this指针来解决。\n\n实验2：类的成员函数可通过const修饰，请问const修饰的是谁\n\n**5.5****全局函数****PK****成员函数**\n\n 1、把全局函数转化成成员函数，通过this指针隐藏左操作数\n\n Test add(Test &t1, Test &t2)===》Test add( Test &t2)\n\n 2、把成员函数转换成全局函数，多了一个参数\n\n void printAB()===》void printAB(Test *pthis)\n\n 3、函数返回元素和返回引用\n\n Test& add(Test &t2) //*this //函数返回引用\n\n {\n\n this->a = this->a + t2.getA();\n\n this->b = this->b + t2.getB();\n\n return *this; //*操作让this指针回到元素状态\n\n }\n\n Test add2(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n return t3;\n\n }\n\n void add3(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n //return t3;\n\n }"]],[30030,30030],[32450,32450]]],[1543123841607,["gjx16@GJXAIOU",[[-1,30030,"**5"],[1,30033,"#"]],[30030,30033],[30031,30031]]],[1543123841955,["gjx16@GJXAIOU",[[1,30031,"#"]],[30031,30031],[30032,30032]]],[1543123842804,["gjx16@GJXAIOU",[[1,30033," "]],[30032,30032],[30033,30033]]],[1543123843854,["gjx16@GJXAIOU",[[1,30033,"weu"]],[30033,30033],[30036,30036]]],[1543123846000,["gjx16@GJXAIOU",[[-1,30033,"weu"]],[30036,30036],[30033,30033]]],[1543123848878,["gjx16@GJXAIOU",[[1,30033,"五、"]],[30033,30033],[30035,30035]]],[1543123852499,["gjx16@GJXAIOU",[[-1,30039,"****"]],[30039,30043],[30039,30039]]],[1543123854311,["gjx16@GJXAIOU",[[-1,30047,"**"]],[30047,30049],[30047,30047]]],[1543123916607,[null,[[-1,28490,"静态"],[1,28492,"##"],[1,28497,"静态"],[-1,28501,"****"],[1,28505,"\n\n"],[-1,28507,"1"],[1,28510,"1定义"],[-1,28519,"\nØ"],[1,28525,"关键"],[-1,28553,"\n 静态"],[1,28557,"  "],[1,28559,"静态"],[-1,28577,"Ø "],[1,28583,"把一"],[-1,28646,"Ø "],[1,28652,"静态"],[-1,28668,"例如"],[1,28693,"例如"],[-1,28952,"**"],[1,28954,"声明"],[-1,28963,"**"],[1,28965,"\n\n"],[-1,29028,"\n"],[1,29030,"b"],[-1,29041,"\n"],[1,29044,"a"],[-1,29057,"\n"],[1,29059,"a"],[-1,29071,"\n"],[1,29073,"b"],[-1,29094,"\n从"],[1,29121,"从结"],[-1,29140,"\n\n*"],[-1,29145,"*"],[1,29146,"\n\n"],[-1,29148,"2"],[1,29151,"2使用"],[-1,29160,"\n*"],[-1,29665,"**"],[1,29667,"\n\n"],[1,29674,"静态"],[-1,29678,"**1）"],[1,29682,"\n\n"],[1,29686,"1）"],[1,29688,"**"],[-1,29690,"**Ø "],[1,29698,"静态"],[-1,29716,"Ø "],[1,29722,"静态"],[-1,29754,"Ø"],[-1,29757," "],[1,29760,"在类"],[-1,29771,"“*"],[1,29774,"_类"],[-1,29779,"**"],[1,29782,"作限"],[-1,29794,"2）"],[1,29800,"2）"],[-1,29802,"\n\n"],[-1,29806,"3"],[1,29807,"\n"],[-1,29828,"）"],[1,29829,"\n"],[1,29833,"3）"],[-1,29838,"静态"],[1,29843,"静态"],[-1,29859,"\n "],[1,29861,"//"],[-1,29891,"\n*"],[1,30012,"\n\n*"],[-1,30013,"\n"],[-1,30017,"**"],[1,30020,"综合"],[-1,30024,"\n\n"],[1,32446,"\n\n"]],[28490,28490],[32448,32448]]],[1543123916607,[null,[[1,28490,"静态"],[-1,28490,"##"],[-1,28497,"静态"],[1,28503,"****"],[-1,28503,"\n\n"],[1,28507,"1"],[-1,28509,"1定义"],[1,28521,"\nØ"],[-1,28525,"关键"],[1,28555,"\n 静态"],[-1,28555,"  "],[-1,28559,"静态"],[1,28579,"Ø "],[-1,28583,"把一"],[1,28648,"Ø "],[-1,28652,"静态"],[1,28670,"例如"],[-1,28693,"例如"],[1,28954,"**"],[-1,28954,"声明"],[1,28965,"**"],[-1,28965,"\n\n"],[1,29030,"\n"],[-1,29031,"b"],[1,29043,"\n"],[-1,29045,"a"],[1,29059,"\n"],[-1,29060,"a"],[1,29073,"\n"],[-1,29074,"b"],[1,29096,"\n从"],[-1,29121,"从结"],[1,29142,"\n\n*"],[1,29144,"*"],[-1,29144,"\n\n"],[1,29148,"2"],[-1,29150,"2使用"],[1,29162,"\n*"],[1,29665,"**"],[-1,29665,"\n\n"],[-1,29674,"静态"],[1,29680,"**1）"],[-1,29680,"\n\n"],[-1,29686,"1）"],[-1,29690,"**"],[1,29694,"**Ø "],[-1,29698,"静态"],[1,29718,"Ø "],[-1,29722,"静态"],[1,29756,"Ø"],[1,29758," "],[-1,29760,"在类"],[1,29773,"“*"],[-1,29774,"_类"],[1,29781,"**"],[-1,29782,"作限"],[1,29796,"2）"],[-1,29800,"2）"],[1,29804,"\n\n"],[1,29806,"3"],[-1,29806,"\n"],[1,29828,"）"],[-1,29828,"\n"],[-1,29833,"3）"],[1,29840,"静态"],[-1,29843,"静态"],[1,29861,"\n "],[-1,29861,"//"],[1,29893,"\n*"],[-1,30012,"\n\n*"],[1,30016,"\n"],[1,30019,"**"],[-1,30020,"综合"],[1,30026,"\n\n"],[-1,32446,"\n\n"]],[32448,32448],[28490,28490]]],[1543123866260,["gjx16@GJXAIOU",[[-1,30358,"**5.1****"],[1,30367,"#"]],[30358,30358],[30359,30359]]],[1543123869482,["gjx16@GJXAIOU",[[1,30359,"## （）"]],[30359,30359],[30364,30364]]],[1543123871264,["gjx16@GJXAIOU",[[1,30363,"一"]],[30363,30363],[30364,30364]]],[1543123875841,["gjx16@GJXAIOU",[[-1,30369,"**"]],[30369,30371],[30369,30369]]],[1543123892652,["gjx16@GJXAIOU",[[-1,30371,"| "]],[30371,30373],[30371,30371]]],[1543123964068,[null,[[-1,28490,"静态"],[1,28492,"##"],[1,28497,"静态"],[-1,28501,"****"],[1,28505,"\n\n"],[-1,28507,"1"],[1,28510,"1定义"],[-1,28519,"\nØ"],[1,28525,"关键"],[-1,28553,"\n 静态"],[1,28557,"  "],[1,28559,"静态"],[-1,28577,"Ø "],[1,28583,"把一"],[-1,28646,"Ø "],[1,28652,"静态"],[-1,28668,"例如"],[1,28693,"例如"],[-1,28952,"**"],[1,28954,"声明"],[-1,28963,"**"],[1,28965,"\n\n"],[-1,29028,"\n"],[1,29030,"b"],[-1,29041,"\n"],[1,29044,"a"],[-1,29057,"\n"],[1,29059,"a"],[-1,29071,"\n"],[1,29073,"b"],[-1,29094,"\n从"],[1,29121,"从结"],[-1,29140,"\n\n*"],[-1,29145,"*"],[1,29146,"\n\n"],[-1,29148,"2"],[1,29151,"2使用"],[-1,29160,"\n*"],[-1,29665,"**"],[1,29667,"\n\n"],[1,29674,"静态"],[-1,29678,"**1）"],[1,29682,"\n\n"],[1,29686,"1）"],[1,29688,"**"],[-1,29690,"**Ø "],[1,29698,"静态"],[-1,29716,"Ø "],[1,29722,"静态"],[-1,29754,"Ø"],[-1,29757," "],[1,29760,"在类"],[-1,29771,"“*"],[1,29774,"_类"],[-1,29779,"**"],[1,29782,"作限"],[-1,29794,"2）"],[1,29800,"2）"],[-1,29802,"\n\n"],[-1,29806,"3"],[1,29807,"\n"],[-1,29828,"）"],[1,29829,"\n"],[1,29833,"3）"],[-1,29838,"静态"],[1,29843,"静态"],[-1,29859,"\n "],[1,29861,"//"],[-1,29891,"\n*"],[1,30012,"\n\n*"],[-1,30013,"\n"],[-1,30017,"**"],[1,30020,"综合"],[-1,30024,"\n\n"],[1,32440,"\n\n"]],[28490,28490],[32442,32442]]],[1543123964068,[null,[[1,28490,"静态"],[-1,28490,"##"],[-1,28497,"静态"],[1,28503,"****"],[-1,28503,"\n\n"],[1,28507,"1"],[-1,28509,"1定义"],[1,28521,"\nØ"],[-1,28525,"关键"],[1,28555,"\n 静态"],[-1,28555,"  "],[-1,28559,"静态"],[1,28579,"Ø "],[-1,28583,"把一"],[1,28648,"Ø "],[-1,28652,"静态"],[1,28670,"例如"],[-1,28693,"例如"],[1,28954,"**"],[-1,28954,"声明"],[1,28965,"**"],[-1,28965,"\n\n"],[1,29030,"\n"],[-1,29031,"b"],[1,29043,"\n"],[-1,29045,"a"],[1,29059,"\n"],[-1,29060,"a"],[1,29073,"\n"],[-1,29074,"b"],[1,29096,"\n从"],[-1,29121,"从结"],[1,29142,"\n\n*"],[1,29144,"*"],[-1,29144,"\n\n"],[1,29148,"2"],[-1,29150,"2使用"],[1,29162,"\n*"],[1,29665,"**"],[-1,29665,"\n\n"],[-1,29674,"静态"],[1,29680,"**1）"],[-1,29680,"\n\n"],[-1,29686,"1）"],[-1,29690,"**"],[1,29694,"**Ø "],[-1,29698,"静态"],[1,29718,"Ø "],[-1,29722,"静态"],[1,29756,"Ø"],[1,29758," "],[-1,29760,"在类"],[1,29773,"“*"],[-1,29774,"_类"],[1,29781,"**"],[-1,29782,"作限"],[1,29796,"2）"],[-1,29800,"2）"],[1,29804,"\n\n"],[1,29806,"3"],[-1,29806,"\n"],[1,29828,"）"],[-1,29828,"\n"],[-1,29833,"3）"],[1,29840,"静态"],[-1,29843,"静态"],[1,29861,"\n "],[-1,29861,"//"],[1,29893,"\n*"],[-1,30012,"\n\n*"],[1,30016,"\n"],[1,30019,"**"],[-1,30020,"综合"],[1,30026,"\n\n"],[-1,32440,"\n\n"]],[32442,32442],[28490,28490]]],[1543123942501,["gjx16@GJXAIOU",[[-1,30372,"\n"]],[30371,30371],[30370,30370]]],[1543123943268,["gjx16@GJXAIOU",[[-1,30371,"\n"]],[30370,30370],[30369,30369]]]],null,"gjx16@GJXAIOU"],["83fdc7b1-37cb-4fa5-b42b-8b810c2dfbbf",1543141398278,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁;\n   * c++面向对象模型初探;  \n   * c++面向对象多态原理探究;\n   * 操作符重载;\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;//定义两个对象c1和c2\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”，\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n\t\n};\n\n```\nTeacher.cpp\n//具体实现函数内容，在函数名前面加上`类名::`\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1:设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)//因为类的成员变量这里都是private:\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n###  (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n###  (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//需要重载=号操作符，才能解决带来的浅拷贝问题\n\n\tobj2 = obj3; //=号操作，也是一种浅拷贝\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++的默认copy构造函数是浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n\n---\n\n\n### （五）多个对象构造和析构\n\n**1.对象初始化列表**\n\n- 1）对象初始化列表出现原因\n程序本身是有问题的\n```cpp\n\n/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B   //在一个类里面组合了一个带有参数的构造函数的类，因为C++编译器要确定分配给B多大的内存，但是没法初始化A定义的两个对象（因为需要调用有参的构造函数）\n{\npublic:   //没有写B的构造函数，按理说应该调用默认的构造函数\n\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  //主要是因为没有方法和没有机会去初始化这两个A定义的对象\n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB;\n\treturn 0;\n\n}\n\n```\n\n解决方法：\n```cpp\n/*\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n};\n\n\nclass B  \n{\npublic:   \n//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）\n\tB(int _a, int _b) : a1(1), a2(3)  \n\t{\n\n\t}\n//第二种参数传递的方法：\n/*\nB(int _a, int _b,int m,int n) : a1(m), a2(n)  \n\t{\n      a = _a;\n      b = _b;\n\t}\n\t\n*/\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  \n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB(1,2);\n\t//第二种方式：B objB(1,2,4,3)\n\treturn 0;\n\n}\n\n```\n\n**以上程序的操作顺序：**\n首先执行被组合对象的构造函数（a1,a2），如果有多个组合对象，则按照定义的顺序，而不是按照初始化列表的顺序（：后面的顺序）\n析构函数：和构造函数的调用顺序相反\n\n  - 1.必须这样做：\n    - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    - 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n  - 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    - 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    - 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n- 2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n```cpp\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n{\n // some other assignment operation\n}\n```\n\n\n- 3）注意概念\n  - 初始化：被初始化的对象正在创建\n  - 赋值：被赋值的对象已经存在\n\n- 4）注意：\n  - 成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n  - 初始化列表先于构造函数的函数体执行\n\n**说明：**\n\n* 1 C++中提供了初始化列表对成员变量进行初始化\n* 2 使用初始化列表出现原因：\n  * 1.必须这样做：\n    * 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n    * 而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    * 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n  * 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    * 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    * 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n```cpp\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n ABC(int a, int b, int c)\n {\n this->a = a;\n this->b = b;\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"ABC construct ..\\n\");\n }\n\n ~ABC()\n {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n }\n\nprotected:\nprivate:\n int a;\n int b;\n int c;\n};\n\nclass MyD\n{\npublic:\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n {\n cout<<\"MyD()\"<<endl;\n }\n\n ~MyD()\n {\n cout<<\"~MyD()\"<<endl;\n }\n\nprotected:\nprivate:\n ABC abc1; //c++编译器不知道如何构造abc1\n ABC abc2;\n const int m;\n};\n\nint run()\n{\n MyD myD;\n return 0;\n}\n\nint main_dem03()\n{\n run();\n system(\"pause\");\n return 0;\n}\n\n```\n\n\n\n\n### （六）构造函数和析构函数的调用顺序研究\n\n**构造函数与析构函数的调用顺序**\n\n- 1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n- 2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n### （七）构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1构造析构综合训练**\n```cpp\n\n/*\n\n总结 构造和析构的调用顺序\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n\tABC(int a, int b, int c)   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\n\t}\n\n\t~ABC()\n\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\n\nclass MyD \n{\npublic:\n\tMyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~MyD()\n\t{\n\t\tcout << \"~MyD()\" << endl;\n\t}\n\n\tMyD(const MyD & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\tcout << \"MyD(const MyD &obj)\" << endl;\n\t}\n\nprotected:\nprivate:\n\tABC abc1; //c++编译器不知道如何构造abc1//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\tABC abc2;\n\tconst int m;//因为是const m,所以上面所有的m都进行了赋值\n};\n\n\nint doThing(MyD myel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;\n}\n\n\nint run2()//二\n{\n\tMyD myD;//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\treturn 0;\n}\n\nint run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main()\n{\n\trun2();//一\n\t//run3();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n\n\n```\n\n\n**2匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3匿名对象强化训练**\n\n3） 构造中调用构造\n\n```cpp\n/*\n\n构造中调用构造\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass MyTest\n{\npublic:\n\tMyTest(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t}\n\n\tMyTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\n\t\tMyTest(a, b, 10);\n\t}\n\n\t~MyTest()\n\t{\n\t\tcout << \"MyTest is ...\" << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n\n\npublic:\n\tint getC() const { return c; }\n\n\tvoid setC(int val) { c = val; }\n};\n\nint main()\n{\n\tMyTest t1(1, 2);\n\tcout << t1.getC() << endl;\n\tsystem(\"pause\");\n\treturn 0;\n\t\n}\n\n\n```\n\n 结论： 构造函数中调用构造函数，是一个蹩脚的行为。\n程序内存图：\n![搜狗截图20181124125452]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181124125452.png)\n\n### （八）对象的动态建立和释放\n\n**1.new和delete基本语法**\n```cpp\n/*\n\nnew 和delete的使用\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nvoid main()\n{\n\t//先分配内存然后赋值\n\tint *p = new int;  //分配基础类型\n\t*p = 20;  \n\n\t//在定义的时候直接分配内存\n\tint *p1 = new int(30);\n\tcout << *p1 << endl;\n\n\tsystem(\"pause\");\n\treturn; \n}\n\n```\n\n- 1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n  **注意： new和delete是运算符，不是函数，因此执行效率高。**\n\n- 2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： \nnew int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 \nnew char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址    new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n- 3）new和delete运算符使用的一般格式为：\n  用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n![new运算符动态]($resource/new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%A8%E6%80%81.png)\n```cpp\n\n/*\n使用malloc /free 与new /delete的区别\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest();\n\t~Test();\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\nTest::Test()\n{\n\tcout << \"执行了构造函数\" << endl;\n}\n\nTest::~Test()\n{\n\tcout << \"执行了析构函数\" << endl;\n}\n\n\n\nint main()\n{\n\t//基础类型\n\tint *p1 = (int *)malloc(sizeof(int));\n\t*p1 = 10;\n\tdelete p1;\n\n\tint *p2 = new int;\n\t*p2 = 20;\n\tfree(p2);\n\n\n\n\t//数组类型（元素为基础类型）\n\tint *p3 = (int *)malloc(sizeof(int)*10);\n\tp3[0] = 1;\n\tdelete[]p3;\n\n\tint *p4 = new int[10];\n\tp4[1] = 2;\n\tfree(p4);\n\n\n\t//类\n\tTest *p5 = (Test *)malloc(sizeof(Test));\n\tdelete p5;\n\n\tTest *p6 = new Test(10);\n\tfree(p6);\n}\n\n\n```\n**结论：** \nnew：不仅分配内存，而且调用了构造函数\ndelete:不仅释放了内存，而且调用了析构函数\n\n- 4） 应用举例\n\n![5]($resource/5.png)\n\n**2类对象的动态建立和释放**\n\n- 使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n-  C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n  比如：\n\n  Box *pt;  //定义一个指向Box类对象的指针变量pt\n      pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n   这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n  新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n   在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3.编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n\n\n\n## 四、静态成员变量和成员函数\n\n\n思考：每个变量，拥有属性。有没有一些属性，归所有对象拥有？\n\n### （一）静态成员变量\n\n- **1定义静态成员变量**\n  - 关键字 **static**  可以用于说明一个类的成员，\n    静态成员提供了一个同类对象的共享机制\n\n  - 把一个类的成员说明为 **static**  时，这个类无论有多少个对象被创建，这些对象共享这个 **static**  成员\n\n  - 静态成员局部于类，它不是对象成员\n\n![1]($resource/1.png)\n\n例如：\n\n```cpp\n\n/*\n静态成员变量\n*/\n\n#include<iostream>\nusing namespace std;\n\nclass counter\n{\n\n\tstatic int num; //**声明与定义静态数据成员**\n\npublic:\n\n\tvoid setnum(int i) \n\t{ \n\t\tnum = i; \n\t} //成员函数访问静态数据成员\n\n\tvoid shownum() \n\t{ \n\t\tcout << num << endl;\n\t}\n\n};\n\nint counter::num = 0;//声明与定义静态数据成员\n\nvoid main()\n{\n\tcounter a, b;\n\n\ta.shownum(); //调用成员函数访问私有静态数据成员\n\tb.shownum();\n\ta.setnum(10);\n\ta.shownum();\n\tb.shownum();\n\n}\n\n```\n\n![6]($resource/6.png)\n\n**从结果可以看出，访问的是同一个静态数据成员**\n\n- **2使用静态成员变量**\n```cpp\n//例5-14_使用公有静态数据成员\n\n#include<iostream.h>\n\nclass counter\n{ \npublic :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n\n```\n\n\n### (二)静态成员函数\n\n- **1）概念**\n\n  - 静态成员函数数冠以关键字static\n\n  - 静态成员函数提供不依赖于类数据结构的共同操作，它没有this指针\n\n  - 在类外调用静态成员函数用 `_类名_ ::`作限定词，或通过对象调用\n\n- **2）案例**\n![7]($resource/7.png)\n- **3）疑难问题：**\n静态成员函数中，不能使用普通变量。\n//静态成员变量属于整个类的，分不清楚，是那个具体对象的属性。\n![成员函数中的疑难问题]($resource/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98.png)\n\n**4.3 综合训练**\n\n\n\n## 五、 C++面向对象模型初探\n\n**前言**\n\nC++对象模型可以概括为以下2部分：\n\n1\\. 语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等等。\n\n2\\. 对于各种支持的底层实现机制。\n\n在c语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。在c++中，通过抽象数据类型（abstract data type，ADT），在类中定义数据和函数，来实现数据和函数直接的绑定。\n\n概括来说，在C++类中有两种成员数据：static、nonstatic；三种成员函数：static、nonstatic、virtual。\n\n### （一）基础知识\n\nC++中的class从面向对象理论出发，将变量(属性)和函数(方法)集中定义在一起，用于描述现实世界中的类。从计算机的角度，程序依然由数据段和代码段构成。\n\n**C++****编译器如何完成面向对象理论到计算机程序的转化？**\n\n换句话：C++编译器是如何管理类、对象、类和对象之间的关系\n\n具体的说：具体对象调用类中的方法，那，c++编译器是如何区分，是那个具体的类，调用这个方法那?\n\n |\n| \n\n思考一下程序结果\n\n |\n| \n\n#include \"iostream\"\n\nusing namespace std;\n\nclass C1\n\n{\n\npublic:\n\n int i; //4\n\n int j; //4\n\n int k; //4\n\nprotected:\n\nprivate:\n\n}; //12\n\nclass C2\n\n{\n\npublic:\n\n int i; //4\n\n int j; //4\n\n int k; //4\n\n static int m; //4\n\npublic:\n\n int getK() const { return k; } //4\n\n void setK(int val) { k = val; } //4\n\nprotected:\n\nprivate:\n\n}; //12 16 24\n\nstruct S1\n\n{\n\n int i;\n\n int j;\n\n int k;\n\n}; //\n\nstruct S2\n\n{\n\n int i;\n\n int j;\n\n int k;\n\n static int m;\n\n}; //\n\nint main()\n\n{\n\n printf(\"c1:%d \\n\", sizeof(C1));\n\n printf(\"c2:%d \\n\", sizeof(C2));\n\n printf(\"s1:%d \\n\", sizeof(S1));\n\n printf(\"s2:%d \\n\", sizeof(S2));\n\n system(\"pause\");\n\n}\n\n |\n|  |\n\n**5.2****编译器对属性和方法的处理机制**\n\n| \n\n通过上面的案例，我们可以的得出：\n\n1）C++类对象中的成员变量和成员函数是分开存储的\n\n成员变量：\n\n普通成员变量：存储于对象中，与struct变量有相同的内存布局和字节对齐方式\n\n静态成员变量：存储于全局数据区中\n\n成员函数：存储于代码段中。\n\n问题出来了：很多对象共用一块代码？代码是如何区分具体对象的那？\n\n换句话说：int getK() const { return k; }，代码是如何区分，具体obj1、obj2、obj3对象的k值？\n\n |\n| \n\n2）C++编译器对普通成员函数的内部处理\n\n |\n|  |\n| \n\n请仔细思考，并说出你的总结！\n\n |\n\n**5.3****总结**\n\n| \n\n**1****、**C++类对象中的成员变量和成员函数是分开存储的。C语言中的内存四区模型仍然有效！\n\n**2****、C++****中类的普通成员函数都隐式包含一个指向当前对象的this****指针。**\n\n3、静态成员函数、成员变量属于类\n\n静态成员函数与普通成员函数的区别\n\n静态成员函数不包含指向具体对象的指针\n\n普通成员函数包含一个指向具体对象的指针\n\n |\n\n**5.4 this****指针**\n\n实验1：若类成员函数的形参 和 类的属性，名字相同，通过this指针来解决。\n\n实验2：类的成员函数可通过const修饰，请问const修饰的是谁\n\n**5.5****全局函数****PK****成员函数**\n\n 1、把全局函数转化成成员函数，通过this指针隐藏左操作数\n\n Test add(Test &t1, Test &t2)===》Test add( Test &t2)\n\n 2、把成员函数转换成全局函数，多了一个参数\n\n void printAB()===》void printAB(Test *pthis)\n\n 3、函数返回元素和返回引用\n\n Test& add(Test &t2) //*this //函数返回引用\n\n {\n\n this->a = this->a + t2.getA();\n\n this->b = this->b + t2.getB();\n\n return *this; //*操作让this指针回到元素状态\n\n }\n\n Test add2(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n return t3;\n\n }\n\n void add3(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n //return t3;\n\n }\n\n\n\n\n\n\n\n\n\n",[[1543141396593,["gjx16@GJXAIOU",[[-1,30456,"***"]],[30459,30459],[30456,30456]]]],null,"gjx16@GJXAIOU"],["1f7acc94-12ba-4fe4-a161-6d1cd93d9417",1543220378027,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁;\n   * c++面向对象模型初探;  \n   * c++面向对象多态原理探究;\n   * 操作符重载;\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;//定义两个对象c1和c2\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”，\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n\t\n};\n\n```\nTeacher.cpp\n//具体实现函数内容，在函数名前面加上`类名::`\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1:设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)//因为类的成员变量这里都是private:\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n###  (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n###  (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//需要重载=号操作符，才能解决带来的浅拷贝问题\n\n\tobj2 = obj3; //=号操作，也是一种浅拷贝\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++的默认copy构造函数是浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n\n---\n\n\n### （五）多个对象构造和析构\n\n**1.对象初始化列表**\n\n- 1）对象初始化列表出现原因\n程序本身是有问题的\n```cpp\n\n/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B   //在一个类里面组合了一个带有参数的构造函数的类，因为C++编译器要确定分配给B多大的内存，但是没法初始化A定义的两个对象（因为需要调用有参的构造函数）\n{\npublic:   //没有写B的构造函数，按理说应该调用默认的构造函数\n\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  //主要是因为没有方法和没有机会去初始化这两个A定义的对象\n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB;\n\treturn 0;\n\n}\n\n```\n\n解决方法：\n```cpp\n/*\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n};\n\n\nclass B  \n{\npublic:   \n//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）\n\tB(int _a, int _b) : a1(1), a2(3)  \n\t{\n\n\t}\n//第二种参数传递的方法：\n/*\nB(int _a, int _b,int m,int n) : a1(m), a2(n)  \n\t{\n      a = _a;\n      b = _b;\n\t}\n\t\n*/\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  \n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB(1,2);\n\t//第二种方式：B objB(1,2,4,3)\n\treturn 0;\n\n}\n\n```\n\n**以上程序的操作顺序：**\n首先执行被组合对象的构造函数（a1,a2），如果有多个组合对象，则按照定义的顺序，而不是按照初始化列表的顺序（：后面的顺序）\n析构函数：和构造函数的调用顺序相反\n\n  - 1.必须这样做：\n    - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    - 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n  - 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    - 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    - 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n- 2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n```cpp\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n{\n // some other assignment operation\n}\n```\n\n\n- 3）注意概念\n  - 初始化：被初始化的对象正在创建\n  - 赋值：被赋值的对象已经存在\n\n- 4）注意：\n  - 成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n  - 初始化列表先于构造函数的函数体执行\n\n**说明：**\n\n* 1 C++中提供了初始化列表对成员变量进行初始化\n* 2 使用初始化列表出现原因：\n  * 1.必须这样做：\n    * 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n    * 而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    * 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n  * 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    * 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    * 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n```cpp\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n ABC(int a, int b, int c)\n {\n this->a = a;\n this->b = b;\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"ABC construct ..\\n\");\n }\n\n ~ABC()\n {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n }\n\nprotected:\nprivate:\n int a;\n int b;\n int c;\n};\n\nclass MyD\n{\npublic:\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n {\n cout<<\"MyD()\"<<endl;\n }\n\n ~MyD()\n {\n cout<<\"~MyD()\"<<endl;\n }\n\nprotected:\nprivate:\n ABC abc1; //c++编译器不知道如何构造abc1\n ABC abc2;\n const int m;\n};\n\nint run()\n{\n MyD myD;\n return 0;\n}\n\nint main_dem03()\n{\n run();\n system(\"pause\");\n return 0;\n}\n\n```\n\n\n\n\n### （六）构造函数和析构函数的调用顺序研究\n\n**构造函数与析构函数的调用顺序**\n\n- 1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n- 2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n### （七）构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1构造析构综合训练**\n```cpp\n\n/*\n\n总结 构造和析构的调用顺序\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n\tABC(int a, int b, int c)   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\n\t}\n\n\t~ABC()\n\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\n\nclass MyD \n{\npublic:\n\tMyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~MyD()\n\t{\n\t\tcout << \"~MyD()\" << endl;\n\t}\n\n\tMyD(const MyD & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\tcout << \"MyD(const MyD &obj)\" << endl;\n\t}\n\nprotected:\nprivate:\n\tABC abc1; //c++编译器不知道如何构造abc1//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\tABC abc2;\n\tconst int m;//因为是const m,所以上面所有的m都进行了赋值\n};\n\n\nint doThing(MyD myel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;\n}\n\n\nint run2()//二\n{\n\tMyD myD;//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\treturn 0;\n}\n\nint run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main()\n{\n\trun2();//一\n\t//run3();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n\n\n```\n\n\n**2匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3匿名对象强化训练**\n\n3） 构造中调用构造\n\n```cpp\n/*\n\n构造中调用构造\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass MyTest\n{\npublic:\n\tMyTest(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t}\n\n\tMyTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\n\t\tMyTest(a, b, 10);\n\t}\n\n\t~MyTest()\n\t{\n\t\tcout << \"MyTest is ...\" << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n\n\npublic:\n\tint getC() const { return c; }\n\n\tvoid setC(int val) { c = val; }\n};\n\nint main()\n{\n\tMyTest t1(1, 2);\n\tcout << t1.getC() << endl;\n\tsystem(\"pause\");\n\treturn 0;\n\t\n}\n\n\n```\n\n 结论： 构造函数中调用构造函数，是一个蹩脚的行为。\n程序内存图：\n![搜狗截图20181124125452]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181124125452.png)\n\n### （八）对象的动态建立和释放\n\n**1.new和delete基本语法**\n```cpp\n/*\n\nnew 和delete的使用\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nvoid main()\n{\n\t//先分配内存然后赋值\n\tint *p = new int;  //分配基础类型\n\t*p = 20;  \n\n\t//在定义的时候直接分配内存\n\tint *p1 = new int(30);\n\tcout << *p1 << endl;\n\n\tsystem(\"pause\");\n\treturn; \n}\n\n```\n\n- 1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n  **注意： new和delete是运算符，不是函数，因此执行效率高。**\n\n- 2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： \nnew int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 \nnew char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址    new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n- 3）new和delete运算符使用的一般格式为：\n  用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n![new运算符动态]($resource/new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%A8%E6%80%81.png)\n```cpp\n\n/*\n使用malloc /free 与new /delete的区别\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest();\n\t~Test();\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\nTest::Test()\n{\n\tcout << \"执行了构造函数\" << endl;\n}\n\nTest::~Test()\n{\n\tcout << \"执行了析构函数\" << endl;\n}\n\n\n\nint main()\n{\n\t//基础类型\n\tint *p1 = (int *)malloc(sizeof(int));\n\t*p1 = 10;\n\tdelete p1;\n\n\tint *p2 = new int;\n\t*p2 = 20;\n\tfree(p2);\n\n\n\n\t//数组类型（元素为基础类型）\n\tint *p3 = (int *)malloc(sizeof(int)*10);\n\tp3[0] = 1;\n\tdelete[]p3;\n\n\tint *p4 = new int[10];\n\tp4[1] = 2;\n\tfree(p4);\n\n\n\t//类\n\tTest *p5 = (Test *)malloc(sizeof(Test));\n\tdelete p5;\n\n\tTest *p6 = new Test(10);\n\tfree(p6);\n}\n\n\n```\n**结论：** \nnew：不仅分配内存，而且调用了构造函数\ndelete:不仅释放了内存，而且调用了析构函数\n\n- 4） 应用举例\n\n![5]($resource/5.png)\n\n**2类对象的动态建立和释放**\n\n- 使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n-  C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n  比如：\n\n  Box *pt;  //定义一个指向Box类对象的指针变量pt\n      pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n   这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n  新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n   在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3.编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n\n\n\n## 四、静态成员变量和成员函数\n\n\n思考：每个变量，拥有属性。有没有一些属性，归所有对象拥有？\n\n### （一）静态成员变量\n\n- **1定义静态成员变量**\n  - 关键字 **static**  可以用于说明一个类的成员，\n    静态成员提供了一个同类对象的共享机制\n\n  - 把一个类的成员说明为 **static**  时，这个类无论有多少个对象被创建，这些对象共享这个 **static**  成员\n\n  - 静态成员局部于类，它不是对象成员\n\n![1]($resource/1.png)\n\n例如：\n\n```cpp\n\n/*\n静态成员变量\n*/\n\n#include<iostream>\nusing namespace std;\n\nclass counter\n{\n\n\tstatic int num; //**声明与定义静态数据成员**\n\npublic:\n\n\tvoid setnum(int i) \n\t{ \n\t\tnum = i; \n\t} //成员函数访问静态数据成员\n\n\tvoid shownum() \n\t{ \n\t\tcout << num << endl;\n\t}\n\n};\n\nint counter::num = 0;//声明与定义静态数据成员\n\nvoid main()\n{\n\tcounter a, b;\n\n\ta.shownum(); //调用成员函数访问私有静态数据成员\n\tb.shownum();\n\ta.setnum(10);\n\ta.shownum();\n\tb.shownum();\n\n}\n\n```\n\n![6]($resource/6.png)\n\n**从结果可以看出，访问的是同一个静态数据成员**\n\n- **2使用静态成员变量**\n```cpp\n//例5-14_使用公有静态数据成员\n\n#include<iostream.h>\n\nclass counter\n{ \npublic :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n\n```\n\n\n### (二)静态成员函数\n\n- **1）概念**\n\n  - 静态成员函数数冠以关键字static\n\n  - 静态成员函数提供不依赖于类数据结构的共同操作，它没有this指针\n\n  - 在类外调用静态成员函数用 `_类名_ ::`作限定词，或通过对象调用\n\n- **2）案例**\n![7]($resource/7.png)\n- **3）疑难问题：**\n静态成员函数中，不能使用普通变量。\n//静态成员变量属于整个类的，分不清楚，是那个具体对象的属性。\n![成员函数中的疑难问题]($resource/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98.png)\n\n**4.3 综合训练**\n\n\n\n## 五、 C++面向对象模型初探\n\n**前言**\n\nC++对象模型可以概括为以下2部分：\n\n1\\. 语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等等。\n\n2\\. 对于各种支持的底层实现机制。\n\n在c语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。在c++中，通过抽象数据类型（abstract data type，ADT），在类中定义数据和函数，来实现数据和函数直接的绑定。\n\n概括来说，在C++类中有两种成员数据：static、nonstatic；三种成员函数：static、nonstatic、virtual。\n\n### （一）基础知识\n\nC++中的class从面向对象理论出发，将变量(属性)和函数(方法)集中定义在一起，用于描述现实世界中的类。从计算机的角度，程序依然由数据段和代码段构成。\n\n**C++*编译器如何完成面向对象理论到计算机程序的转化？**\n\n换句话：C++编译器是如何管理类、对象、类和对象之间的关系\n\n具体的说：具体对象调用类中的方法，那，c++编译器是如何区分，是那个具体的类，调用这个方法那?\n\n |\n| \n\n思考一下程序结果\n\n |\n| \n\n#include \"iostream\"\n\nusing namespace std;\n\nclass C1\n\n{\n\npublic:\n\n int i; //4\n\n int j; //4\n\n int k; //4\n\nprotected:\n\nprivate:\n\n}; //12\n\nclass C2\n\n{\n\npublic:\n\n int i; //4\n\n int j; //4\n\n int k; //4\n\n static int m; //4\n\npublic:\n\n int getK() const { return k; } //4\n\n void setK(int val) { k = val; } //4\n\nprotected:\n\nprivate:\n\n}; //12 16 24\n\nstruct S1\n\n{\n\n int i;\n\n int j;\n\n int k;\n\n}; //\n\nstruct S2\n\n{\n\n int i;\n\n int j;\n\n int k;\n\n static int m;\n\n}; //\n\nint main()\n\n{\n\n printf(\"c1:%d \\n\", sizeof(C1));\n\n printf(\"c2:%d \\n\", sizeof(C2));\n\n printf(\"s1:%d \\n\", sizeof(S1));\n\n printf(\"s2:%d \\n\", sizeof(S2));\n\n system(\"pause\");\n\n}\n\n |\n|  |\n\n**5.2****编译器对属性和方法的处理机制**\n\n| \n\n通过上面的案例，我们可以的得出：\n\n1）C++类对象中的成员变量和成员函数是分开存储的\n\n成员变量：\n\n普通成员变量：存储于对象中，与struct变量有相同的内存布局和字节对齐方式\n\n静态成员变量：存储于全局数据区中\n\n成员函数：存储于代码段中。\n\n问题出来了：很多对象共用一块代码？代码是如何区分具体对象的那？\n\n换句话说：int getK() const { return k; }，代码是如何区分，具体obj1、obj2、obj3对象的k值？\n\n |\n| \n\n2）C++编译器对普通成员函数的内部处理\n\n |\n|  |\n| \n\n请仔细思考，并说出你的总结！\n\n |\n\n**5.3****总结**\n\n| \n\n**1****、**C++类对象中的成员变量和成员函数是分开存储的。C语言中的内存四区模型仍然有效！\n\n**2****、C++****中类的普通成员函数都隐式包含一个指向当前对象的this****指针。**\n\n3、静态成员函数、成员变量属于类\n\n静态成员函数与普通成员函数的区别\n\n静态成员函数不包含指向具体对象的指针\n\n普通成员函数包含一个指向具体对象的指针\n\n |\n\n**5.4 this****指针**\n\n实验1：若类成员函数的形参 和 类的属性，名字相同，通过this指针来解决。\n\n实验2：类的成员函数可通过const修饰，请问const修饰的是谁\n\n**5.5****全局函数****PK****成员函数**\n\n 1、把全局函数转化成成员函数，通过this指针隐藏左操作数\n\n Test add(Test &t1, Test &t2)===》Test add( Test &t2)\n\n 2、把成员函数转换成全局函数，多了一个参数\n\n void printAB()===》void printAB(Test *pthis)\n\n 3、函数返回元素和返回引用\n\n Test& add(Test &t2) //*this //函数返回引用\n\n {\n\n this->a = this->a + t2.getA();\n\n this->b = this->b + t2.getB();\n\n return *this; //*操作让this指针回到元素状态\n\n }\n\n Test add2(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n return t3;\n\n }\n\n void add3(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n //return t3;\n\n }\n\n\n\n\n\n\n\n\n\n",[[1543220342883,["gjx16@GJXAIOU",[[1,29666,"··"]],[29666,29666],[29668,29668]]],[1543220344810,["gjx16@GJXAIOU",[[-1,29666,"··"]],[29668,29668],[29666,29666]]],[1543220346418,["gjx16@GJXAIOU",[[1,29666,"```"]],[29666,29666],[29669,29669]]],[1543220346727,["gjx16@GJXAIOU",[[1,29669,"language\n```\n"]],[29669,29669],[29669,29677]]],[1543220349471,["gjx16@GJXAIOU",[[-1,29669,"language"],[1,29677,"c"]],[29669,29677],[29670,29670]]],[1543220350272,["gjx16@GJXAIOU",[[1,29670,"pp"]],[29670,29670],[29672,29672]]],[1543220350967,["gjx16@GJXAIOU",[[1,29673,"\n"]],[29672,29672],[29673,29673]]],[1543220351583,["gjx16@GJXAIOU",[[1,29673,"/*\n静态成员函数\n*/\n// 结论：在静态成员函数中可以使用静态成员变量，但是不能使用类中普通的成员变量\n\n#include\"iostream\"\nusing namespace std;\n\nclass BB\n{\npublic:\n\tint printC()\n\t{\n\t\tcout << \"c:\" << c << endl;\n\t\treturn c;\n\t}\n\n\tint addC()\n\t{\n\t\tc = c+1;\n\t}\n\n\n\tstatic void getC()\n\t{\n\t\tcout << \"c\" << c << endl;  //可以直接在静态成员函数中使用静态成员变量，但是不能直接使用一般变量\n\t}\nprivate:\n\tint a;\n\tint b;\n\tstatic int c;\n\n};\n\n\n\n\nint BB::c = 10;  //初始化成员变量值\n\nvoid main()\n{\n\tBB b1, b2, b3;\n\tb1.printC();//10\n\tb2.addC();//11\n\tb3.printC();//11\n\n\t//调用成员函数两种方法；\n\tb3.getC();//使用对象.\n\tBB::getC();//使用类::\n\n\n\n}\n"]],[29673,29673],[30191,30191]]],[1543220353838,["gjx16@GJXAIOU",[[1,29666,"\n"]],[29665,29665],[29666,29666]]],[1543220357082,["gjx16@GJXAIOU",[[1,29666,"shiyong "]],[29666,29666],[29674,29674]]],[1543220362250,["gjx16@GJXAIOU",[[-1,29666,"shiyong "]],[29674,29674],[29666,29666]]],[1543220362941,["gjx16@GJXAIOU",[[-1,29666,"\n"]],[29666,29666],[29665,29665]]],[1543220369674,["gjx16@GJXAIOU",[[1,29665,"使用今天"]],[29665,29665],[29669,29669]]],[1543220371093,["gjx16@GJXAIOU",[[-1,29667,"今天"]],[29669,29669],[29667,29667]]],[1543220373231,["gjx16@GJXAIOU",[[1,29667,"静态"]],[29667,29667],[29669,29669]]],[1543220397010,["gjx16@GJXAIOU",[[1,29669,"成员函数调用静态成员变量"]],[29669,29669],[29681,29681]]],[1543220454221,["gjx16@GJXAIOU",[[-1,30624,"\\"]],[30625,30625],[30624,30624]]],[1543220457950,["gjx16@GJXAIOU",[[1,30603,"- "]],[30603,30603],[30605,30605]]],[1543220460574,["gjx16@GJXAIOU",[[1,30625,"·"]],[30625,30625],[30626,30626]]],[1543220461378,["gjx16@GJXAIOU",[[-1,30625,"·"]],[30626,30626],[30625,30625]]],[1543220462963,["gjx16@GJXAIOU",[[1,30625,"  0"]],[30625,30625],[30628,30628]]],[1543220463500,["gjx16@GJXAIOU",[[-1,30627,"0"]],[30628,30628],[30627,30627]]],[1543220465320,["gjx16@GJXAIOU",[[1,30627,"- "]],[30627,30627],[30629,30629]]],[1543220469139,["gjx16@GJXAIOU",[[-1,30694,"\\"]],[30695,30695],[30694,30694]]],[1543220472084,["gjx16@GJXAIOU",[[1,30693,"  - "]],[30693,30693],[30697,30697]]],[1543220507293,["gjx16@GJXAIOU",[[-1,31117," |\n| "]],[31117,31122],[31117,31117]]],[1543220530311,["gjx16@GJXAIOU",[[-1,31009,"*"]],[31010,31010],[31009,31009]]],[1543220544915,["gjx16@GJXAIOU",[[-1,31128," |\n| \n"]],[31128,31134],[31128,31128]]],[1543220713236,["gjx16@GJXAIOU",[[1,31128," "]],[31128,31128],[31129,31129]]],[1543220887523,["gjx16@GJXAIOU",[[-1,31752," |\n|  |"]],[31752,31759],[31752,31752]]],[1543220888331,["gjx16@GJXAIOU",[[-1,31753,"\n"]],[31752,31752],[31751,31751]]],[1543220895759,["gjx16@GJXAIOU",[[-1,31130,"#include \"iostream\"\n\nusing namespace std;\n\nclass C1\n\n{\n\npublic:\n\n int i; //4\n\n int j; //4\n\n int k; //4\n\nprotected:\n\nprivate:\n\n}; //12\n\nclass C2\n\n{\n\npublic:\n\n int i; //4\n\n int j; //4\n\n int k; //4\n\n static int m; //4\n\npublic:\n\n int getK() const { return k; } //4\n\n void setK(int val) { k = val; } //4\n\nprotected:\n\nprivate:\n\n}; //12 16 24\n\nstruct S1\n\n{\n\n int i;\n\n int j;\n\n int k;\n\n}; //\n\nstruct S2\n\n{\n\n int i;\n\n int j;\n\n int k;\n\n static int m;\n\n}; //\n\nint main()\n\n{\n\n printf(\"c1:%d \\n\", sizeof(C1));\n\n printf(\"c2:%d \\n\", sizeof(C2));\n\n printf(\"s1:%d \\n\", sizeof(S1));\n\n printf(\"s2:%d \\n\", sizeof(S2));\n\n system(\"pause\");\n\n}"]],[31130,31750],[31130,31130]]],[1543220898379,["gjx16@GJXAIOU",[[-1,31130,"\n\n\n"]],[31129,31132],[31129,31129]]],[1543220899388,["gjx16@GJXAIOU",[[-1,31117,"\n"]],[31117,31117],[31116,31116]]],[1543220899731,["gjx16@GJXAIOU",[[-1,31116,"\n"]],[31116,31116],[31115,31115]]],[1543220903362,["gjx16@GJXAIOU",[[1,31125,"```"]],[31125,31125],[31128,31128]]],[1543220903652,["gjx16@GJXAIOU",[[1,31128,"language\n```\n"]],[31128,31128],[31128,31136]]],[1543220904945,["gjx16@GJXAIOU",[[-1,31128,"language"],[1,31136,"v"]],[31128,31136],[31129,31129]]],[1543220905438,["gjx16@GJXAIOU",[[-1,31128,"v"]],[31129,31129],[31128,31128]]],[1543220906781,["gjx16@GJXAIOU",[[1,31128,"cpp"]],[31128,31128],[31131,31131]]],[1543220907121,["gjx16@GJXAIOU",[[1,31132,"\n"]],[31131,31131],[31132,31132]]],[1543221005156,["gjx16@GJXAIOU",[[1,31132,"/*\n面向对象模型初探\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass C1\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\nprotected:\n\nprivate:\n\n}; //12\n\nclass C2\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\n\tstatic int m; //4\n\npublic:\n\n\tint getK() const { return k; } //4\n\n\tvoid setK(int val) { k = val; } //4\n\nprotected:\n\nprivate:\n}; //12 16 24\n\nstruct S1\n{\n\tint i;\n\tint j;\n\tint k;\n}; //\n\nstruct S2\n{\n\tint i;\n\tint j;\n\tint k;\n\tstatic int m;\n\n}; //\n\nint main()\n{\n\n\tprintf(\"c1:%d \\n\", sizeof(C1));\n\tprintf(\"c2:%d \\n\", sizeof(C2));\n\tprintf(\"s1:%d \\n\", sizeof(S1));\n\tprintf(\"s2:%d \\n\", sizeof(S2));\n\tsystem(\"pause\");\n\n}"]],[31132,31132],[31743,31743]]],[1543221009911,["gjx16@GJXAIOU",[[1,31749,"\n"]],[31747,31747],[31748,31748]]],[1543221011413,["gjx16@GJXAIOU",[[1,31748,"jie"]],[31748,31748],[31751,31751]]],[1543221013750,["gjx16@GJXAIOU",[[-1,31748,"jie"]],[31751,31751],[31748,31748]]],[1543221018508,["gjx16@GJXAIOU",[[1,31748,"程序运行结果；"]],[31748,31748],[31755,31755]]],[1543221019644,["gjx16@GJXAIOU",[[-1,31754,"；"]],[31755,31755],[31754,31754]]],[1543221020608,["gjx16@GJXAIOU",[[1,31754,"："]],[31754,31754],[31755,31755]]],[1543221021287,["gjx16@GJXAIOU",[[1,31757,"\n"]],[31755,31755],[31756,31756]]],[1543221055121,["gjx16@GJXAIOU",[[1,31756,"c1:12\nc2:12\ns1:12\ns2:12"]],[31756,31756],[31779,31779]]],[1543221056953,["gjx16@GJXAIOU",[[1,31756,"·"]],[31756,31756],[31757,31757]]],[1543221058180,["gjx16@GJXAIOU",[[-1,31756,"·"]],[31757,31757],[31756,31756]]],[1543221058711,["gjx16@GJXAIOU",[[1,31756,"`"]],[31756,31756],[31757,31757]]],[1543221059978,["gjx16@GJXAIOU",[[1,31763,"`"]],[31763,31763],[31764,31764]]],[1543221060688,["gjx16@GJXAIOU",[[1,31770,"`"]],[31770,31770],[31771,31771]]],[1543221061440,["gjx16@GJXAIOU",[[1,31777,"`"]],[31777,31777],[31778,31778]]],[1543221063097,["gjx16@GJXAIOU",[[1,31783,"`"]],[31783,31783],[31784,31784]]],[1543221063520,["gjx16@GJXAIOU",[[1,31776,"`"]],[31776,31776],[31777,31777]]],[1543221064121,["gjx16@GJXAIOU",[[1,31769,"`"]],[31769,31769],[31770,31770]]],[1543221064829,["gjx16@GJXAIOU",[[1,31762,"`"]],[31762,31762],[31763,31763]]],[1543221073999,["gjx16@GJXAIOU",[[-1,31400,"\n"]],[31400,31400],[31399,31399]]],[1543221076149,["gjx16@GJXAIOU",[[-1,31396,"//4"]],[31396,31399],[31396,31396]]],[1543221077749,["gjx16@GJXAIOU",[[-1,31430,"//4"]],[31430,31433],[31430,31430]]],[1543221079827,["gjx16@GJXAIOU",[[-1,31350,"//4"]],[31350,31353],[31350,31350]]],[1543221082004,["gjx16@GJXAIOU",[[-1,31453,"//12 16 24"]],[31453,31463],[31453,31453]]],[1543221084287,["gjx16@GJXAIOU",[[-1,31494,"//"]],[31496,31496],[31494,31494]]],[1543221086716,["gjx16@GJXAIOU",[[-1,31551,"//"]],[31551,31553],[31551,31551]]],[1543221088645,["gjx16@GJXAIOU",[[-1,31547,"\n"]],[31547,31547],[31546,31546]]],[1543221092287,["gjx16@GJXAIOU",[[1,31393,"//"]],[31393,31393],[31395,31395]]],[1543221112048,["gjx16@GJXAIOU",[[1,31395,"方法是属于代码，应该放在代码区"]],[31395,31395],[31410,31410]]],[1543221119263,["gjx16@GJXAIOU",[[-1,32040," |\n| \n"]],[32040,32046],[32040,32040]]],[1543221120756,["gjx16@GJXAIOU",[[-1,32063," |\n|  |\n| \n"]],[32063,32074],[32063,32063]]],[1543221122303,["gjx16@GJXAIOU",[[-1,32080," |"]],[32080,32082],[32080,32080]]],[1543221200675,["gjx16@GJXAIOU",[[-1,31810,"| \n\n"]],[31809,31813],[31809,31809]]],[1543221206457,["gjx16@GJXAIOU",[[1,31855,"- "]],[31855,31855],[31857,31857]]],[1543221211044,["gjx16@GJXAIOU",[[-1,31903,"\n"]],[31903,31903],[31902,31902]]],[1543221213642,["gjx16@GJXAIOU",[[-1,31935,"\n"]],[31935,31935],[31934,31934]]],[1543221216294,["gjx16@GJXAIOU",[[1,31921,"- "]],[31921,31921],[31923,31923]]],[1543221219243,["gjx16@GJXAIOU",[[1,31864,"  - "]],[31864,31864],[31868,31868]]],[1543221221859,["gjx16@GJXAIOU",[[1,31907,"  - "]],[31907,31907],[31911,31911]]],[1543221224552,["gjx16@GJXAIOU",[[-1,31863,"\n"]],[31863,31863],[31862,31862]]],[1543221383998,["gjx16@GJXAIOU",[[-1,32200,"****"]],[32200,32204],[32200,32200]]],[1543221388531,["gjx16@GJXAIOU",[[-1,32169,"****"]],[32169,32173],[32169,32169]]],[1543221392372,["gjx16@GJXAIOU",[[-1,32161,"****"]],[32161,32165],[32161,32161]]],[1543221396412,["gjx16@GJXAIOU",[[-1,32109,"****"]],[32109,32113],[32109,32109]]],[1543221399686,["gjx16@GJXAIOU",[[-1,32110,"**"]],[32110,32112],[32110,32110]]],[1543221405691,["gjx16@GJXAIOU",[[-1,32106,"**"]],[32106,32108],[32106,32106]]],[1543222157185,["gjx16@GJXAIOU",[[1,32331,"```"]],[32331,32331],[32334,32334]]],[1543222157521,["gjx16@GJXAIOU",[[1,32334,"language\n```\n"]],[32334,32334],[32334,32342]]],[1543222158823,["gjx16@GJXAIOU",[[-1,32334,"language"],[1,32342,"c"]],[32334,32342],[32335,32335]]],[1543222159585,["gjx16@GJXAIOU",[[1,32335,"pp"]],[32335,32335],[32337,32337]]],[1543222160366,["gjx16@GJXAIOU",[[1,32338,"\n"]],[32337,32337],[32338,32338]]],[1543222161373,["gjx16@GJXAIOU",[[1,32339,"/*\nthis 指针\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass Test\n{\npublic:\n\tTest( int a, int b)//Test(Test *this, int a, int b)//因为这里成员函数的形参和成员变量一样，不用this指针会出现：a = a ,b = b;\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printT()\n\t{\n\t\tcout << \"a; \" << a << endl;\n\t\tcout << \"b: \" << this->b << endl;\n\t}\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\nint  main()\n{\n\tTest t1(1, 2);\n\tt1.printT();\n\tsystem(\"pause\");\n\treturn 0;\n}\n"]],[32338,32338],[32753,32753]]],[1543222165448,["gjx16@GJXAIOU",[[1,32759,"\n"]],[32757,32757],[32758,32758]]],[1543222168977,["gjx16@GJXAIOU",[[1,32758,"chengxu"]],[32758,32758],[32765,32765]]],[1543222174379,["gjx16@GJXAIOU",[[-1,32758,"chengxu"]],[32765,32765],[32758,32758]]],[1543222180560,["gjx16@GJXAIOU",[[1,32758,"程序运行而就哦"]],[32758,32758],[32765,32765]]],[1543222182428,["gjx16@GJXAIOU",[[-1,32762,"而就哦"]],[32765,32765],[32762,32762]]],[1543222184240,["gjx16@GJXAIOU",[[1,32762,"结果："]],[32762,32762],[32765,32765]]],[1543222185036,["gjx16@GJXAIOU",[[1,32767,"\n"]],[32765,32765],[32766,32766]]],[1543222187155,["gjx16@GJXAIOU",[[1,32766,"``"]],[32766,32766],[32768,32768]]],[1543222189081,["gjx16@GJXAIOU",[[1,32769,"``"]],[32769,32769],[32771,32771]]],[1543222192569,["gjx16@GJXAIOU",[[1,32767,"a = "]],[32767,32767],[32771,32771]]],[1543222196435,["gjx16@GJXAIOU",[[-1,32768," = "]],[32771,32771],[32768,32768]]],[1543222198465,["gjx16@GJXAIOU",[[1,32768,":1"]],[32768,32768],[32770,32770]]],[1543222203810,["gjx16@GJXAIOU",[[1,32773,"b:2"]],[32773,32773],[32776,32776]]],[1543222326063,["gjx16@GJXAIOU",[[1,30375,"\n"]],[30374,30374],[30375,30375]]],[1543222356072,["gjx16@GJXAIOU",[[1,30717,"  "]],[30717,30717],[30719,30719]]],[1543222357337,["gjx16@GJXAIOU",[[1,30845,"  "]],[30845,30845],[30847,30847]]],[1543222371496,["gjx16@GJXAIOU",[[1,30917,"\n"]],[30916,30916],[30917,30917]]],[1543222409066,["gjx16@GJXAIOU",[[1,30917,"![C++类的组成]($resource/C++%E7%B1%BB%E7%9A%84%E7%BB%84%E6%88%90.png)"]],[30917,30917],[30983,30983]]],[1543222412109,["gjx16@GJXAIOU",[[1,30983,"\n"]],[30983,30983],[30984,30984]]],[1543222422621,["gjx16@GJXAIOU",[[-1,31138,"\n"]],[31138,31138],[31137,31137]]],[1543222424019,["gjx16@GJXAIOU",[[-1,31107,"\n"]],[31107,31107],[31106,31106]]],[1543222447990,["gjx16@GJXAIOU",[[-1,31853,"**5.2****"],[1,31862,"#"]],[31853,31862],[31854,31854]]],[1543222451066,["gjx16@GJXAIOU",[[1,31854,"## ()"]],[31854,31854],[31859,31859]]],[1543222452713,["gjx16@GJXAIOU",[[1,31858,"e"]],[31858,31858],[31859,31859]]],[1543222453236,["gjx16@GJXAIOU",[[-1,31858,"e"]],[31859,31859],[31858,31858]]],[1543222454739,["gjx16@GJXAIOU",[[1,31858,"二"]],[31858,31858],[31859,31859]]],[1543222458173,["gjx16@GJXAIOU",[[-1,31874,"**"]],[31874,31876],[31874,31874]]],[1543222469724,["gjx16@GJXAIOU",[[-1,31893,"\n"]],[31893,31893],[31892,31892]]],[1543222470805,["gjx16@GJXAIOU",[[-1,31919,"\n"]],[31919,31919],[31918,31918]]],[1543222474777,["gjx16@GJXAIOU",[[1,32110,"- "]],[32110,32110],[32112,32112]]],[1543222479236,["gjx16@GJXAIOU",[[-1,32110,"- "]],[32112,32112],[32110,32110]]],[1543222480612,["gjx16@GJXAIOU",[[-1,32109,"\n"]],[32109,32109],[32108,32108]]],[1543222482756,["gjx16@GJXAIOU",[[-1,32040,"\n"]],[32040,32040],[32039,32039]]],[1543222515290,["gjx16@GJXAIOU",[[-1,32149,"**5.3****"],[1,32158,"#"]],[32149,32149],[32150,32150]]],[1543222518168,["gjx16@GJXAIOU",[[1,32150,"## （）"]],[32150,32150],[32155,32155]]],[1543222520184,["gjx16@GJXAIOU",[[1,32154,"三"]],[32154,32154],[32155,32155]]],[1543222523573,["gjx16@GJXAIOU",[[-1,32158,"**"]],[32160,32160],[32158,32158]]],[1543222526017,["gjx16@GJXAIOU",[[-1,32160,"| "]],[32160,32162],[32160,32160]]],[1543222527128,["gjx16@GJXAIOU",[[-1,32161,"\n"]],[32161,32161],[32160,32160]]],[1543222527880,["gjx16@GJXAIOU",[[-1,32160,"\n"]],[32160,32160],[32159,32159]]],[1543222574953,["gjx16@GJXAIOU",[[1,32131,"\n"]],[32129,32129],[32130,32130]]],[1543222581913,["gjx16@GJXAIOU",[[1,32130,"![C++编译器对普通成员函数的内部处理]($resource/C++%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E9%83%A8%E5%A4%84%E7%90%86.png)"]],[32130,32130],[32306,32306]]],[1543222590332,["gjx16@GJXAIOU",[[-1,32379,"\n"]],[32379,32379],[32378,32378]]],[1543222591395,["gjx16@GJXAIOU",[[-1,32419,"\n"]],[32419,32419],[32418,32418]]],[1543222606820,["gjx16@GJXAIOU",[[-1,32510,"****"]],[32510,32514],[32510,32510]]],[1543222608612,["gjx16@GJXAIOU",[[-1,32512,"**"]],[32512,32514],[32512,32512]]],[1543222611792,["gjx16@GJXAIOU",[[-1,32500,"**5.4 "],[1,32506,"#"]],[32500,32500],[32501,32501]]],[1543222615088,["gjx16@GJXAIOU",[[1,32501,"## （）"]],[32501,32501],[32506,32506]]],[1543222616653,["gjx16@GJXAIOU",[[1,32505,"四"]],[32505,32505],[32506,32506]]],[1543222639368,["gjx16@GJXAIOU",[[1,32515,"\n"]],[32514,32514],[32515,32515]]],[1543222641435,["gjx16@GJXAIOU",[[-1,32496," |\n"]],[32496,32499],[32496,32496]]],[1543222643511,["gjx16@GJXAIOU",[[1,32513,"\n"]],[32511,32511],[32512,32512]]],[1543222651520,["gjx16@GJXAIOU",[[1,32512,"![this指针图示]($resource/this%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png)"]],[32512,32512],[32580,32580]]],[1543222662003,["gjx16@GJXAIOU",[[1,33102,"\n"]],[33101,33101],[33102,33102]]],[1543222663067,["gjx16@GJXAIOU",[[1,33067,"\n"]],[33066,33066],[33067,33067]]],[1543222663462,["gjx16@GJXAIOU",[[1,33068,"\n"]],[33067,33067],[33068,33068]]],[1543222669585,["gjx16@GJXAIOU",[[-1,33105,"**5.5****"],[1,33114,"#"]],[33105,33105],[33106,33106]]],[1543222672427,["gjx16@GJXAIOU",[[1,33106,"## （）"]],[33106,33106],[33111,33111]]],[1543222674283,["gjx16@GJXAIOU",[[1,33110,"五"]],[33110,33110],[33111,33111]]],[1543222682147,["gjx16@GJXAIOU",[[-1,33114,"函数****"]],[33120,33120],[33114,33114]]],[1543222683643,["gjx16@GJXAIOU",[[1,33114,"函数"]],[33114,33114],[33116,33116]]],[1543222689089,["gjx16@GJXAIOU",[[-1,33118,"****"]],[33122,33122],[33118,33118]]],[1543222694645,["gjx16@GJXAIOU",[[-1,33122,"**"]],[33124,33124],[33122,33122]]],[1543222701926,["gjx16@GJXAIOU",[[1,33157,"  "]],[33157,33157],[33159,33159]]],[1543222704387,["gjx16@GJXAIOU",[[1,33237,"  "]],[33237,33237],[33239,33239]]],[1543222710036,["gjx16@GJXAIOU",[[1,33299,"·"]],[33299,33299],[33300,33300]]],[1543222711455,["gjx16@GJXAIOU",[[-1,33299,"·"]],[33300,33300],[33299,33299]]],[1543222712709,["gjx16@GJXAIOU",[[1,33299,"```"]],[33299,33299],[33302,33302]]],[1543222713039,["gjx16@GJXAIOU",[[1,33302,"language\n```\n"]],[33302,33302],[33302,33310]]],[1543222714657,["gjx16@GJXAIOU",[[-1,33302,"language"],[1,33310,"c"]],[33302,33310],[33303,33303]]],[1543222715388,["gjx16@GJXAIOU",[[1,33303,"pp"]],[33303,33303],[33305,33305]]],[1543222716278,["gjx16@GJXAIOU",[[1,33306,"\n"]],[33305,33305],[33306,33306]]],[1543222721829,["gjx16@GJXAIOU",[[-1,33313,"Test& add(Test &t2) //*this //函数返回引用\n\n {\n\n this->a = this->a + t2.getA();\n\n this->b = this->b + t2.getB();\n\n return *this; //*操作让this指针回到元素状态\n\n }\n\n Test add2(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n return t3;\n\n }\n\n void add3(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n //return t3;\n\n }\n\n"]],[33313,33710],[33313,33313]]],[1543222725020,["gjx16@GJXAIOU",[[1,33306,"Test& add(Test &t2) //*this //函数返回引用\n\n {\n\n this->a = this->a + t2.getA();\n\n this->b = this->b + t2.getB();\n\n return *this; //*操作让this指针回到元素状态\n\n }\n\n Test add2(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n return t3;\n\n }\n\n void add3(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n //return t3;\n\n }\n\n"]],[33306,33306],[33703,33703]]],[1543222727629,["gjx16@GJXAIOU",[[-1,33343,"\n"]],[33343,33343],[33342,33342]]],[1543222728764,["gjx16@GJXAIOU",[[-1,33346,"\n"]],[33346,33346],[33345,33345]]],[1543222730585,["gjx16@GJXAIOU",[[1,33347,"  "]],[33347,33347],[33349,33349]]],[1543222731754,["gjx16@GJXAIOU",[[1,33382,"  "]],[33382,33382],[33384,33384]]],[1543222732598,["gjx16@GJXAIOU",[[1,33417,"  "]],[33417,33417],[33419,33419]]],[1543222736247,["gjx16@GJXAIOU",[[-1,33457," "]],[33458,33458],[33457,33457]]],[1543222739525,["gjx16@GJXAIOU",[[-1,33494,"\n"]],[33494,33494],[33493,33493]]],[1543232605733,["gjx16@GJXAIOU",[[-1,2821,"，"]],[2822,2822],[2821,2821]]],[1543232623013,["gjx16@GJXAIOU",[[-1,3097,"\t"]],[3098,3098],[3097,3097]]],[1543232623402,["gjx16@GJXAIOU",[[-1,3097,"\n"]],[3097,3097],[3096,3096]]],[1543232624220,["gjx16@GJXAIOU",[[-1,3095,";"]],[3096,3096],[3095,3095]]],[1543232625537,["gjx16@GJXAIOU",[[1,3095,";"]],[3095,3095],[3096,3096]]]],null,"gjx16@GJXAIOU"],["023cee4e-af7d-4db9-b5ce-75ee65d285d6",1543488456096,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁;\n   * c++面向对象模型初探;  \n   * c++面向对象多态原理探究;\n   * 操作符重载;\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;//定义两个对象c1和c2\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n};\n\n```\nTeacher.cpp\n//具体实现函数内容，在函数名前面加上`类名::`\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1:设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)//因为类的成员变量这里都是private:\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n###  (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n###  (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//需要重载=号操作符，才能解决带来的浅拷贝问题\n\n\tobj2 = obj3; //=号操作，也是一种浅拷贝\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++的默认copy构造函数是浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n\n---\n\n\n### （五）多个对象构造和析构\n\n**1.对象初始化列表**\n\n- 1）对象初始化列表出现原因\n程序本身是有问题的\n```cpp\n\n/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B   //在一个类里面组合了一个带有参数的构造函数的类，因为C++编译器要确定分配给B多大的内存，但是没法初始化A定义的两个对象（因为需要调用有参的构造函数）\n{\npublic:   //没有写B的构造函数，按理说应该调用默认的构造函数\n\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  //主要是因为没有方法和没有机会去初始化这两个A定义的对象\n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB;\n\treturn 0;\n\n}\n\n```\n\n解决方法：\n```cpp\n/*\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n};\n\n\nclass B  \n{\npublic:   \n//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）\n\tB(int _a, int _b) : a1(1), a2(3)  \n\t{\n\n\t}\n//第二种参数传递的方法：\n/*\nB(int _a, int _b,int m,int n) : a1(m), a2(n)  \n\t{\n      a = _a;\n      b = _b;\n\t}\n\t\n*/\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  \n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB(1,2);\n\t//第二种方式：B objB(1,2,4,3)\n\treturn 0;\n\n}\n\n```\n\n**以上程序的操作顺序：**\n首先执行被组合对象的构造函数（a1,a2），如果有多个组合对象，则按照定义的顺序，而不是按照初始化列表的顺序（：后面的顺序）\n析构函数：和构造函数的调用顺序相反\n\n  - 1.必须这样做：\n    - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    - 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n  - 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    - 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    - 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n- 2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n```cpp\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n{\n // some other assignment operation\n}\n```\n\n\n- 3）注意概念\n  - 初始化：被初始化的对象正在创建\n  - 赋值：被赋值的对象已经存在\n\n- 4）注意：\n  - 成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n  - 初始化列表先于构造函数的函数体执行\n\n**说明：**\n\n* 1 C++中提供了初始化列表对成员变量进行初始化\n* 2 使用初始化列表出现原因：\n  * 1.必须这样做：\n    * 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n    * 而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    * 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n  * 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    * 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    * 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n```cpp\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n ABC(int a, int b, int c)\n {\n this->a = a;\n this->b = b;\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"ABC construct ..\\n\");\n }\n\n ~ABC()\n {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n }\n\nprotected:\nprivate:\n int a;\n int b;\n int c;\n};\n\nclass MyD\n{\npublic:\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n {\n cout<<\"MyD()\"<<endl;\n }\n\n ~MyD()\n {\n cout<<\"~MyD()\"<<endl;\n }\n\nprotected:\nprivate:\n ABC abc1; //c++编译器不知道如何构造abc1\n ABC abc2;\n const int m;\n};\n\nint run()\n{\n MyD myD;\n return 0;\n}\n\nint main_dem03()\n{\n run();\n system(\"pause\");\n return 0;\n}\n\n```\n\n\n\n\n### （六）构造函数和析构函数的调用顺序研究\n\n**构造函数与析构函数的调用顺序**\n\n- 1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n- 2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n### （七）构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1构造析构综合训练**\n```cpp\n\n/*\n\n总结 构造和析构的调用顺序\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n\tABC(int a, int b, int c)   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\n\t}\n\n\t~ABC()\n\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\n\nclass MyD \n{\npublic:\n\tMyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~MyD()\n\t{\n\t\tcout << \"~MyD()\" << endl;\n\t}\n\n\tMyD(const MyD & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\tcout << \"MyD(const MyD &obj)\" << endl;\n\t}\n\nprotected:\nprivate:\n\tABC abc1; //c++编译器不知道如何构造abc1//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\tABC abc2;\n\tconst int m;//因为是const m,所以上面所有的m都进行了赋值\n};\n\n\nint doThing(MyD myel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;\n}\n\n\nint run2()//二\n{\n\tMyD myD;//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\treturn 0;\n}\n\nint run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main()\n{\n\trun2();//一\n\t//run3();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n\n\n```\n\n\n**2匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3匿名对象强化训练**\n\n3） 构造中调用构造\n\n```cpp\n/*\n\n构造中调用构造\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass MyTest\n{\npublic:\n\tMyTest(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t}\n\n\tMyTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\n\t\tMyTest(a, b, 10);\n\t}\n\n\t~MyTest()\n\t{\n\t\tcout << \"MyTest is ...\" << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n\n\npublic:\n\tint getC() const { return c; }\n\n\tvoid setC(int val) { c = val; }\n};\n\nint main()\n{\n\tMyTest t1(1, 2);\n\tcout << t1.getC() << endl;\n\tsystem(\"pause\");\n\treturn 0;\n\t\n}\n\n\n```\n\n 结论： 构造函数中调用构造函数，是一个蹩脚的行为。\n程序内存图：\n![搜狗截图20181124125452]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181124125452.png)\n\n### （八）对象的动态建立和释放\n\n**1.new和delete基本语法**\n```cpp\n/*\n\nnew 和delete的使用\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nvoid main()\n{\n\t//先分配内存然后赋值\n\tint *p = new int;  //分配基础类型\n\t*p = 20;  \n\n\t//在定义的时候直接分配内存\n\tint *p1 = new int(30);\n\tcout << *p1 << endl;\n\n\tsystem(\"pause\");\n\treturn; \n}\n\n```\n\n- 1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n  **注意： new和delete是运算符，不是函数，因此执行效率高。**\n\n- 2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： \nnew int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 \nnew char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址    new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n- 3）new和delete运算符使用的一般格式为：\n  用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n![new运算符动态]($resource/new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%A8%E6%80%81.png)\n```cpp\n\n/*\n使用malloc /free 与new /delete的区别\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest();\n\t~Test();\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\nTest::Test()\n{\n\tcout << \"执行了构造函数\" << endl;\n}\n\nTest::~Test()\n{\n\tcout << \"执行了析构函数\" << endl;\n}\n\n\n\nint main()\n{\n\t//基础类型\n\tint *p1 = (int *)malloc(sizeof(int));\n\t*p1 = 10;\n\tdelete p1;\n\n\tint *p2 = new int;\n\t*p2 = 20;\n\tfree(p2);\n\n\n\n\t//数组类型（元素为基础类型）\n\tint *p3 = (int *)malloc(sizeof(int)*10);\n\tp3[0] = 1;\n\tdelete[]p3;\n\n\tint *p4 = new int[10];\n\tp4[1] = 2;\n\tfree(p4);\n\n\n\t//类\n\tTest *p5 = (Test *)malloc(sizeof(Test));\n\tdelete p5;\n\n\tTest *p6 = new Test(10);\n\tfree(p6);\n}\n\n\n```\n**结论：** \nnew：不仅分配内存，而且调用了构造函数\ndelete:不仅释放了内存，而且调用了析构函数\n\n- 4） 应用举例\n\n![5]($resource/5.png)\n\n**2类对象的动态建立和释放**\n\n- 使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n-  C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n  比如：\n\n  Box *pt;  //定义一个指向Box类对象的指针变量pt\n      pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n   这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n  新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n   在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3.编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n\n\n\n## 四、静态成员变量和成员函数\n\n\n思考：每个变量，拥有属性。有没有一些属性，归所有对象拥有？\n\n### （一）静态成员变量\n\n- **1定义静态成员变量**\n  - 关键字 **static**  可以用于说明一个类的成员，\n    静态成员提供了一个同类对象的共享机制\n\n  - 把一个类的成员说明为 **static**  时，这个类无论有多少个对象被创建，这些对象共享这个 **static**  成员\n\n  - 静态成员局部于类，它不是对象成员\n\n![1]($resource/1.png)\n\n例如：\n\n```cpp\n\n/*\n静态成员变量\n*/\n\n#include<iostream>\nusing namespace std;\n\nclass counter\n{\n\n\tstatic int num; //**声明与定义静态数据成员**\n\npublic:\n\n\tvoid setnum(int i) \n\t{ \n\t\tnum = i; \n\t} //成员函数访问静态数据成员\n\n\tvoid shownum() \n\t{ \n\t\tcout << num << endl;\n\t}\n\n};\n\nint counter::num = 0;//声明与定义静态数据成员\n\nvoid main()\n{\n\tcounter a, b;\n\n\ta.shownum(); //调用成员函数访问私有静态数据成员\n\tb.shownum();\n\ta.setnum(10);\n\ta.shownum();\n\tb.shownum();\n\n}\n\n```\n\n![6]($resource/6.png)\n\n**从结果可以看出，访问的是同一个静态数据成员**\n\n- **2使用静态成员变量**\n```cpp\n//例5-14_使用公有静态数据成员\n\n#include<iostream.h>\n\nclass counter\n{ \npublic :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n\n```\n使用静态成员函数调用静态成员变量\n```cpp\n/*\n静态成员函数\n*/\n// 结论：在静态成员函数中可以使用静态成员变量，但是不能使用类中普通的成员变量\n\n#include\"iostream\"\nusing namespace std;\n\nclass BB\n{\npublic:\n\tint printC()\n\t{\n\t\tcout << \"c:\" << c << endl;\n\t\treturn c;\n\t}\n\n\tint addC()\n\t{\n\t\tc = c+1;\n\t}\n\n\n\tstatic void getC()\n\t{\n\t\tcout << \"c\" << c << endl;  //可以直接在静态成员函数中使用静态成员变量，但是不能直接使用一般变量\n\t}\nprivate:\n\tint a;\n\tint b;\n\tstatic int c;\n\n};\n\n\n\n\nint BB::c = 10;  //初始化成员变量值\n\nvoid main()\n{\n\tBB b1, b2, b3;\n\tb1.printC();//10\n\tb2.addC();//11\n\tb3.printC();//11\n\n\t//调用成员函数两种方法；\n\tb3.getC();//使用对象.\n\tBB::getC();//使用类::\n\n\n\n}\n\n```\n\n### (二)静态成员函数\n\n- **1）概念**\n\n  - 静态成员函数数冠以关键字static\n\n  - 静态成员函数提供不依赖于类数据结构的共同操作，它没有this指针\n\n  - 在类外调用静态成员函数用 `_类名_ ::`作限定词，或通过对象调用\n\n- **2）案例**\n![7]($resource/7.png)\n\n- **3）疑难问题：**\n静态成员函数中，不能使用普通变量。\n//静态成员变量属于整个类的，分不清楚，是那个具体对象的属性。\n![成员函数中的疑难问题]($resource/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98.png)\n\n**4.3 综合训练**\n\n\n\n## 五、 C++面向对象模型初探\n\n**前言**\n\n- C++对象模型可以概括为以下2部分：\n\n  - 1. 语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等等。\n\n  - 2. 对于各种支持的底层实现机制。\n\n  在c语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。在c++中，通过抽象数据类型（abstract data type，ADT），在类中定义数据和函数，来实现数据和函数直接的绑定。\n\n  概括来说，在C++类中有两种成员数据：static、nonstatic；三种成员函数：static、nonstatic、virtual。\n\n![C++类的组成]($resource/C++%E7%B1%BB%E7%9A%84%E7%BB%84%E6%88%90.png)\n\n### （一）基础知识\n\nC++中的class从面向对象理论出发，将变量(属性)和函数(方法)集中定义在一起，用于描述现实世界中的类。从计算机的角度，程序依然由数据段和代码段构成。\n\n**C++编译器如何完成面向对象理论到计算机程序的转化？**\n换句话：C++编译器是如何管理类、对象、类和对象之间的关系\n具体的说：具体对象调用类中的方法，那，c++编译器是如何区分，是那个具体的类，调用这个方法那?\n\n思考一下程序结果\n```cpp\n/*\n面向对象模型初探\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass C1\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\nprotected:\n\nprivate:\n\n}; //12\n\nclass C2\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\n\tstatic int m; \n\npublic:\n\n\tint getK() const { return k; } //方法是属于代码，应该放在代码区\n\tvoid setK(int val) { k = val; } \n\nprotected:\n\nprivate:\n}; \n\nstruct S1\n{\n\tint i;\n\tint j;\n\tint k;\n}; \n\nstruct S2\n{\n\tint i;\n\tint j;\n\tint k;\n\tstatic int m;\n}; \n\nint main()\n{\n\n\tprintf(\"c1:%d \\n\", sizeof(C1));\n\tprintf(\"c2:%d \\n\", sizeof(C2));\n\tprintf(\"s1:%d \\n\", sizeof(S1));\n\tprintf(\"s2:%d \\n\", sizeof(S2));\n\tsystem(\"pause\");\n\n}\n```\n程序运行结果：\n`c1:12`\n`c2:12`\n`s1:12`\n`s2:12`\n\n \n### (二)编译器对属性和方法的处理机制\n\n通过上面的案例，我们可以的得出：\n1）C++类对象中的成员变量和成员函数是分开存储的\n- 成员变量：\n  - 普通成员变量：存储于对象中，与struct变量有相同的内存布局和字节对齐方式\n  - 静态成员变量：存储于全局数据区中\n\n- 成员函数：存储于代码段中。\n问题出来了：很多对象共用一块代码？代码是如何区分具体对象的那？\n换句话说：int getK() const { return k; }，代码是如何区分，具体obj1、obj2、obj3对象的k值？\n\n2）C++编译器对普通成员函数的内部处理\n\n![C++编译器对普通成员函数的内部处理]($resource/C++%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E9%83%A8%E5%A4%84%E7%90%86.png)\n\n请仔细思考，并说出你的总结！\n\n\n\n### （三）总结\n\n1、C++类对象中的成员变量和成员函数是分开存储的。C语言中的内存四区模型仍然有效！\n**2、C++中类的普通成员函数都隐式包含一个指向当前对象的this指针。**\n3、静态成员函数、成员变量属于类\n\n静态成员函数与普通成员函数的区别\n\n静态成员函数不包含指向具体对象的指针\n\n普通成员函数包含一个指向具体对象的指针\n\n\n### （四）this指针\n\n![this指针图示]($resource/this%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png)\n\n实验1：若类成员函数的形参 和 类的属性，名字相同，通过this指针来解决。\n```cpp\n\n/*\nthis 指针\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass Test\n{\npublic:\n\tTest( int a, int b)//Test(Test *this, int a, int b)//因为这里成员函数的形参和成员变量一样，不用this指针会出现：a = a ,b = b;\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printT()\n\t{\n\t\tcout << \"a; \" << a << endl;\n\t\tcout << \"b: \" << this->b << endl;\n\t}\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\nint  main()\n{\n\tTest t1(1, 2);\n\tt1.printT();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`a:1`\n`b:2`\n\n\n实验2：类的成员函数可通过const修饰，请问const修饰的是谁\n\n\n### （五）全局函数PK成员函数\n\n 1、把全局函数转化成成员函数，通过this指针隐藏左操作数\n\n   Test add(Test &t1, Test &t2)===》Test add( Test &t2)\n\n 2、把成员函数转换成全局函数，多了一个参数\n\n   void printAB()===》void printAB(Test *pthis)\n\n 3、函数返回元素和返回引用\n```cpp\nTest& add(Test &t2) //*this //函数返回引用\n {\n   this->a = this->a + t2.getA();\n\n   this->b = this->b + t2.getB();\n\n   return *this; //*操作让this指针回到元素状态\n\n }\n\nTest add2(Test &t2) //*this //函数返回元素\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n return t3;\n\n }\n\n void add3(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n //return t3;\n\n }\n\n\n```\n\n \n\n\n\n\n\n\n\n",[[1543488417864,["gjx16@GJXAIOU",[[-1,30032,"\n"]],[30031,30031],[30030,30030]]],[1543488418550,["gjx16@GJXAIOU",[[-1,30031,"\n"]],[30030,30030],[30029,30029]]],[1543488442104,["gjx16@GJXAIOU",[[-1,30296,"\n"]],[30294,30294],[30294,30294]]],[1543488479123,["gjx16@GJXAIOU",[[-1,32595,"，"]],[32596,32596],[32595,32595]]],[1543488481428,["gjx16@GJXAIOU",[[1,32595,"（）"]],[32595,32595],[32597,32597]]],[1543488486763,["gjx16@GJXAIOU",[[1,32596,"成员变量"]],[32596,32596],[32600,32600]]],[1543489007070,["gjx16@GJXAIOU",[[-1,33710," "],[1,33711,"\n"]],[33711,33711],[33711,33711]]],[1543489007578,["gjx16@GJXAIOU",[[1,33719,"\n"]],[33711,33711],[33712,33712]]],[1543489008003,["gjx16@GJXAIOU",[[1,33720,"\n"]],[33712,33712],[33713,33713]]],[1543489008415,["gjx16@GJXAIOU",[[1,33721,"\n"]],[33713,33713],[33714,33714]]],[1543489073365,["gjx16@GJXAIOU",[[1,33710,"**6****友元**\n\n**6.1****友元函数**\n\n例如\n\n| \n\nclass A1\n\n{\n\npublic:\n\n A1()\n\n {\n\n a1 = 100;\n\n a2 = 200;\n\n }\n\n int getA1()\n\n {\n\n return this->a1;\n\n }\n\n //声明一个友元函数\n\n friend void setA1(A1 *p, int a1); //这个函数是这个类的好朋友\n\nprotected:\n\nprivate:\n\n int a1;\n\n int a2;\n\n};\n\nvoid setA1(A1 *p, int a1)\n\n{\n\n p->a1 = a1;\n\n}\n\nvoid main()\n\n{\n\n A1 mya1;\n\n cout<<mya1.getA1()<<endl;\n\n setA1(&mya1, 300); //通过友元函数 修改A类的私有属性\n\n cout<<mya1.getA1()<<endl;\n\n system(\"pause\");\n\n}\n\n |\n\n**6.2****友元类**\n\nØ 若B类是A类的友员类，则B类的所有成员函数都是A类的友员函数\n\nØ 友员类通常设计为一种对数据操作或类之间传递消息的辅助类\n\n**7****强化训练**\n\n**1 static****关键字强化训练题**\n\nØ 某商店经销一种货物。货物购进和卖出时以箱为单位，各箱的重量不一样，因此，商店需要记录目前库存的总重量。现在用C++模拟商店货物购进和卖出的情况。\n\n| \n\n#include \"iostream\"\n\nusing namespace std;\n\nclass Goods\n\n{\n\npublic :\n\n Goods ( int w) { weight = w ; total_weight += w ; }\n\n ~ Goods() { total_weight -= weight ; }\n\n int Weight() { return weight ; } ;\n\n static int TotalWeight() { return total_weight ; }\n\n Goods *next ;\n\nprivate :\n\n int weight ;\n\n static int total_weight ;\n\n} ;\n\nint Goods::total_weight = 0 ;\n\n//r尾部指针\n\nvoid purchase( Goods * &f, Goods *& r, int w )\n\n{\n\n Goods *p = new Goods(w) ;\n\n p -> next = NULL ;\n\n if ( f == NULL ) f = r = p ;\n\n else { r -> next = p ; r = r -> next ; } //尾部指针下移或新结点变成尾部结点\n\n}\n\nvoid sale( Goods * & f , Goods * & r )\n\n{\n\n if ( f == NULL ) { cout << \"No any goods!\\n\" ; return ; }\n\n Goods *q = f ; f = f -> next ; delete q ;\n\n cout << \"saled.\\n\" ;\n\n}\n\nvoid main()\n\n{\n\n Goods * front = NULL , * rear = NULL ;\n\n int w ; int choice ;\n\n do\n\n {\n\n cout << \"Please choice:\\n\" ;\n\n cout << \"Key in 1 is purchase,\\nKey in 2 is sale,\\nKey in 0 is over.\\n\" ;\n\n cin >> choice ;\n\n switch ( choice ) // 操作选择\n\n {\n\n case 1 : // 键入1，购进1箱货物\n\n { cout << \"Input weight: \" ;\n\n cin >> w ;\n\n purchase( front, rear, w ) ; // 从表尾插入1个结点\n\n break ;\n\n }\n\n case 2 :              // 键入2，售出1箱货物\n\n { sale( front, rear ) ; break ; } // 从表头删除1个结点\n\n case 0 : break ;              // 键入0，结束\n\n }\n\n cout << \"Now total weight is:\" << Goods::TotalWeight() << endl ;\n\n } while ( choice ) ;\n\n}\n\n |\n\n**2** **数组类封装**\n\n目标：解决实际问题，训练构造函数、copy构造函数等，为操作符重载做准备\n\n数组类的测试\n\n| \n\n#include \"iostream\"\n\n#include \"Array.h\"\n\nusing namespace std;\n\nint main()\n\n{\n\n Array a1(10);\n\n for(int i=0; i<a1.length(); i++)\n\n {\n\n a1.setData(i, i);\n\n }\n\n for(int i=0; i<a1.length(); i++)\n\n {\n\n printf(\"array %d: %d\\n\", i, a1.getData(i));\n\n }\n\n Array a2 = a1;\n\n for(int i=0; i<a2.length(); i++)\n\n {\n\n printf(\"array %d: %d\\n\", i, a2.getData(i));\n\n }\n\n system(\"pause\");\n\n return 0;\n\n}\n\n |\n\n数组类的头文件\n\n| \n\n#ifndef _MYARRAY_H_\n\n#define _MYARRAY_H_\n\nclass Array\n\n{\n\nprivate:\n\n int mLength;\n\nint* mSpace;\n\npublic:\n\n Array(int length);\n\n Array(const Array& obj);\n\n int length();\n\n void setData(int index, int value);\n\n int getData(int index);\n\n ~Array();\n\n};\n\n#endif\n\n |\n\n**3****小结**\n\nØ 类通常用关键字class定义。类是数据成员和成员函数的封装。类的实例称为对象。\n\nØ 结构类型用关键字struct定义，是由不同类型数据组成的数据类型。\n\nØ  类成员由private, protected, public决定访问特性。public成员集称为接口。\n\nØ  构造函数在创建和初始化对象时自动调用。析构函数则在对象作用域结束时自动调用。\n\nØ  重载构造函数和复制构造函数提供了创建对象的不同初始化方式。\n\nØ  静态成员是局部于类的成员，提供一种同类对象的共享机制。\n\nØ 友员用关键字friend声明。友员是对类操作的一种辅助手段。一个类的友员可以访问该类各种性质的成员**。**\n\nØ 链表是一种重要的动态数据结构，可以在程序运行时创建或撤消数据元素。\n\n**8****运算符重载**\n\n**8.1****概念**\n\n**什么是运算符重载**\n\n所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是”一名多用”。\n\n运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重载。例如，大 家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行加法运算，如5+8， 5.8 +3.67等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的， 但由于C++已经对运算符”+”进行了重载，所以就能适用于int, float, doUble类型的运算。\n\n又如”<<“是C++的位运算中的位移运算符（左移），但在输出操作中又是与流对 象cout 配合使用的流插入运算符，”>>“也是位移运算符(右移），但在输入操作中又是与流对象 cin 配合使用的流提取运算符。这就是运算符重载(operator overloading)。C++系统对”<<“和”>>“进行了重载，用户在不同的场合下使用它们时，作用是不同 的。对”<<“和”>>“的重载处理是放在头文件stream中的。因此，如果要在程序中用”<< “和”>>”作流插入运算符和流提取运算符，必须在本文件模块中包含头文件stream(当然还应当包括”using namespace std“)。\n\n现在要讨论的问题是：用户能否根据自己的需要对C++已提供的运算符进行重载，赋予它们新的含义，使之一名多用。？\n\n**运算符重载入门技术推演**\n\n1为什么会用运算符重载机制\n\n  用复数类举例\n\n//Complex c3 = c1 + c2;\n\n//原因 Complex是用户自定义类型，编译器根本不知道如何进行加减\n\n //编译器给提供了一种机制，让用户自己去完成，自定义类型的加减操作。。。。。\n\n //这个机制就是运算符重载机制\n\n2 运算符重载的本质是一个函数\n\n| \n\nclass Complex\n\n{\n\npublic:\n\n int a;\n\n int b;\n\n friend Complex operator+(Complex &c1, Complex &c2);\n\npublic:\n\n Complex(int a=0, int b=0)\n\n {\n\n this->a = a;\n\n this->b = b;\n\n }\n\npublic:\n\n void printCom()\n\n {\n\n cout<<a<<\" + \"<<b<<\"i \"<<endl;\n\n }\n\nprivate:\n\n};\n\n/*\n\nComplex myAdd(Complex &c1, Complex &c2)\n\n{\n\n Complex tmp(c1.a+ c2.a, c1.b + c2.b);\n\n return tmp;\n\n}\n\n*/\n\nComplex operator+(Complex &c1, Complex &c2)\n\n{\n\n Complex tmp(c1.a+ c2.a, c1.b + c2.b);\n\n return tmp;\n\n}\n\nvoid main()\n\n{\n\n Complex c1(1, 2), c2(3, 4);\n\n //Complex c3 = c1 + c2; //用户自定义类型 编译器无法让变量相加\n\n //Complex myAdd(Complex &c1, Complex &c2);\n\n //1 普通函数\n\n //Complex c3 = myAdd(c1, c2);\n\n //c3.printCom();\n\n //2 operator+ 函数名称\n\n //Complex c3 = operator+(c1, c2);\n\n //c3.printCom();\n\n //3 +替换 函数名\n\n Complex c3 = c1 + c2; **//****思考C++****编译器如何支持操作符重载机制的** (**根据类型**)\n\n c3.printCom();\n\n{\n\nint a =0, b = 0, c; //**基础类型C++****编译器知道如何加减**\n\nc = a +b;\n\n}\n\n //4 把Complex类变成私有属性\n\n //友元函数的应用场景\n\n //friend Complex operator+(Complex &c1, Complex &c2);\n\n cout<<\"hello...\"<<endl;\n\n system(\"pause\");\n\n return ;\n\n}\n\n |\n\n**8.2****运算符重载的限制**\n\n**8.3****运算符重载编程基础**\n\n例如:\n\n //全局函数  完成 +操作符  重载\n\nComplex operator+(Complex &c1, Complex &c2)\n\n//类成员函数  完成 -操作符  重载\n\nComplex operator-(Complex &c2)\n\n**运算符重载的两种方法**\n\n例如1:\n\n//通过类成员函数完成-操作符重载\n\n//函数声明 Complex operator-(Complex &c2)\n\n//函数调用分析\n\n//用类成员函数实现-运算符重载\n\n Complex c4 = c1 - c2;\n\n c4.printCom();\n\n //c1.operator-(c2);\n\n例如2:\n\n//通过全局函数方法完成+操作符重载\n\n//函数声明 Complex operator+(Complex &c1, Complex &c2)\n\n//函数调用分析\n\nint main()\n\n{\n\n Complex c1(1, 2), c2(3, 4);\n\n //Complex c31 = operator+(c1, c2);\n\nComplex c3 = c1 + c2;\n\nc3.printCom();\n\n}\n\n例如3: 学员自己练习  实现 * /\n\n例如3\n\n//前置++操作符 用全局函数实现\n\nComplex& operator++(Complex &c1)\n\n{\n\n c1.a ++;\n\n c1.b ++;\n\n return c1;\n\n}\n\n//调用方法\n\n ++c1 ; //=è需要写出操作符重载函数原形\n\n c1.printCom();\n\n//运算符重载函数名定义\n\n //首先承认操作符重载是一个函数 定义函数名èoperator++\n\n //分析函数参数 根据左右操作数的个数,èoperator++(Complex &c1)\n\n //分析函数返回值è Complex& operator++(Complex &c1) 返回它自身\n\n例如4\n\n//4.1前置—操作符 成员函数实现\n\nComplex& operator--()\n\n{\n\n this->a--;\n\n this->b--;\n\n return *this;\n\n}\n\n //4.2调用方法\n\n --c1;\n\n c1.printCom();\n\n //4.3前置—运算符重载函数名定义\n\n //c1.operator--()\n\n例如5\n\n //5.1 //后置++ 操作符 用全局函数实现\n\nComplex operator++(Complex &c1, int)\n\n{\n\n Complex tmp = c1;\n\n c1.a++;\n\n c1.b++;\n\n return tmp;\n\n}\n\n//5.2 调用方法\n\nc1 ++ ; //先使用 后++\n\n//5.3 后置++运算符重载函数名定义\n\n Complex operator++(Complex &c1, int) //函数占位参数 和 前置++ 相区别\n\n例如6\n\n//6.1 后置— 操作符 用类成员函数实现\n\n Complex operator--(int)\n\n {\n\n Complex tmp = *this;\n\n this->a--;\n\n this->b--;\n\n return tmp;\n\n }\n\n//6.2 调用方法\n\nc1 ++ ; //先使用 后++\n\n//6.3 后置--运算符重载函数名定义\n\n Complex operator--(int) //函数占位参数 和 前置-- 相区别\n\n前置和后置运算符总结\n\n**C++****中通过一个占位参数来区分前置运算和后置运算**\n\n**定义运算符重载函数名的步骤**\n\n全局函数、类成员函数方法实现运算符重载步骤\n\n 1）要承认操作符重载是一个函数，写出函数名称operator+ ()\n\n 2）根据操作数，写出函数参数\n\n 3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n\n**友元函数实现操作符重载的应用场景**\n\n**1****）友元函数和成员函数选择方法**\n\nØ 当无法修改左操作数的类时，使用全局函数进行重载\n\nØ =, [], ()和->操作符只能通过成员函数进行重载\n\n**2****）用友元函数** **重载 << >>****操作符**\n\nØ istream 和 ostream 是 C++ 的预定义流类\n\nØ cin 是 istream 的对象，cout 是 ostream 的对象\n\nØ 运算符 << 由ostream 重载为插入操作，用于输出基本类型数据\n\nØ 运算符 >> 由 istream 重载为提取操作，用于输入基本类型数据\n\nØ 用友员函数重载 << 和 >> ，输出和输入用户自定义的数据类型\n\na）用全局函数方法实现 << 操作符\n\nostream& operator<<(ostream &out, Complex &c1)\n\n{\n\n //out<<\"12345，生活真是苦\"<<endl;\n\n out<<c1.a<<\" + \"<<c1.b<<\"i \"<<endl;\n\n return out;\n\n}\n\n//调用方法\n\ncout<<c1;\n\n//链式编程支持\n\ncout<<c1<<\"abcc\";\n\n//cout.operator<<(c1).operator<<(\"abcd\");\n\n//函数返回值充当左值 需要返回一个引用\n\nb）类成员函数方法无法实现 << 操作符重载\n\n //因拿到cout这个类的源码\n\n //cout.operator<<(c1);\n\n**3）** **友元函数重载操作符使用注意点**\n\na） 友员函数重载运算符常用于运算符的左右操作数类型不同的情况\n\nb）其他\n\nØ 在第一个参数需要隐式转换的情形下，使用友员函数重载运算符是正确的选择\n\nØ  友员函数没有 this 指针，所需操作数都必须在参数表显式声明，很容易实现类型的隐式转换\n\nØ  C++中不能用友员函数重载的运算符有\n\n = （）  ［］  －>\n\n**4** **）友元函数案例vector****类**\n\n| \n\n#include <iostream>\n\nusing namespace std;\n\n//为vector类重载流插入运算符和提取运算符\n\nclass vector\n\n{\n\npublic :\n\n vector( int size =1 ) ;\n\n ~vector() ;\n\n int & operator[]( int i ) ;\n\n friend ostream & operator << ( ostream & output , vector & ) ;\n\n friend istream & operator >> ( istream & input, vector & ) ;\n\nprivate : \n\n int * v ;\n\n int len ;\n\n};\n\nvector::vector( int size )\n\n{\n\n if (size <= 0 || size > 100 )\n\n {\n\n cout << \"The size of \" << size << \" is null !\\n\" ; abort() ;\n\n }\n\n v = new int[ size ] ; len = size ;\n\n}\n\nvector :: ~vector()\n\n{\n\n delete[] v ;\n\n len = 0 ;\n\n}\n\nint &vector::operator[]( int i )                \n\n{\n\n if( i >=0 && i < len ) return v[ i ] ;\n\n cout << \"The subscript \" << i << \" is outside !\\n\" ; abort() ;\n\n}\n\nostream & operator << ( ostream & output, vector & ary )\n\n{\n\n for(int i = 0 ; i < ary.len ; i ++ )\n\n output << ary[ i ] << \" \" ;\n\n output << endl ;\n\n return output ;\n\n}\n\nistream & operator >> ( istream & input, vector & ary )\n\n{\n\n for( int i = 0 ; i < ary.len ; i ++ )\n\n input >> ary[ i ] ;\n\n return input ;\n\n}\n\nvoid main()\n\n{\n\n int k ;\n\n cout << \"Input the length of vector A :\\n\" ;\n\n cin >> k ;\n\n vector A( k ) ;\n\n cout << \"Input the elements of vector A :\\n\" ;\n\n cin >> A ;\n\n cout << \"Output the elements of vector A :\\n\" ;\n\n cout << A ;\n\n system(\"pause\");\n\n}\n\n |\n\n**8.4****运算符重载提高**\n\n**1****运算符重载机制**\n\nC++编译器是如何支持操作符重载机制的?\n\n**2****重载赋值运算符****=**\n\nØ 赋值运算符重载用于对象数据的复制\n\nØ operator= 必须重载为成员函数\n\nØ 重载函数原型为：\n\n  **_类型_ &** **_类名_ :: operator= ( const** **_类名_ & ) ;**\n\n案例：完善Name类，支持=号操作。\n\n  结论:\n\n 1 //先释放旧的内存\n\n 2 返回一个引用\n\n 3 =操作符 从右向左\n\n| \n\n //obj3 = obj1; // C++编译器提供的  等号操作  也属  浅拷贝\n\n// obj4 = obj3 = obj1\n\n //obj3.operator=(obj1)\n\n Name& operator=(Name &obj1)\n\n {\n\n //1 先释放obj3旧的内存\n\n if (this->m_p != NULL)\n\n {\n\n delete[] m_p;\n\n m_len = 0;\n\n }\n\n //2 根据obj1分配内存大小\n\n this->m_len = obj1.m_len;\n\n this->m_p = new char [m_len+1];\n\n //3把obj1赋值给obj3\n\n strcpy(m_p, obj1.m_p);\n\n return *this;\n\n }\n\n |\n\n**3****重载数组下表运算符****[]**\n\n重载[]和()运算符\n\nØ 运算符 [] 和 () 是二元运算符\n\nØ [] 和 () 只能用成员函数重载，不能用友元函数重载\n\n**_重载下标运算符 []_**\n\n[] 运算符用于访问数据对象的元素\n\n重载格式  _类型_ **_类_** :: operator[] ( _类型_ ) ；\n\n设 x 是类 X 的一个对象，则表达式\n\n **x [ y ]**\n\n  可被解释为\n\n **x . operator [ ] ( y )**\n\n**4****重载函数调用符** **()**\n\n() 运算符用于函数调用\n\n重载格式  _类型_ _类_ :: operator() ( _表达式表_ ) ；\n\n**_例1_**\n\n**设 x** **是类 X** **的一个对象，则表达式**\n\n **x ( arg1, arg2, … )**\n\n**可被解释为**\n\n **x . operator () (arg1, arg2, … )**\n\n案例：\n\n**_//_****_例2_****_：用重载()_****_运算符实现数学函数的抽象_**\n\n#include <iostream>\n\nclass F\n\n { public :\n\n double operator ( )  ( double x , double y ) ;\n\n } ;\n\ndouble F :: operator ( )  ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\nf.getA();\n\n cout << f ( 5.2 , 2.5 ) << endl ; // **f . _operator()_ (5.2, 2.5)**\n\n}\n\n比较普通成员函数\n\n**_//_****_例3_** **_用重载()_****_运算符实现 pk_** **_成员函数_**\n\n#include <iostream.h>\n\nclass F\n\n { public :\n\n double **memFun** ( double x , double y ) ;\n\n } ;\n\ndouble F :: **memFun** ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\n cout << f.**memFun** ( 5.2 , 2.5 ) << endl ;\n\n}\n\n**5****为什么不要重载****&&****和****||****操作符**\n\n理论知识：\n\n1）&&和||是C++中非常特殊的操作符\n\n2）&&和||内置实现了短路规则\n\n3）操作符重载是靠函数重载来完成的\n\n4）操作数作为函数参数传递\n\n5）C++的函数参数都会被求值，无法实现短路规则\n\n| \n\n#include <cstdlib>\n\n#include <iostream>\n\nusing namespace std;\n\nclass Test\n\n{\n\n int i;\n\npublic:\n\n Test(int i)\n\n {\n\n this->i = i;\n\n }\n\n Test operator+ (const Test& obj)\n\n {\n\n Test ret(0);\n\n cout<<\"执行+号重载函数\"<<endl;\n\n ret.i = i + obj.i;\n\n return ret;\n\n }\n\n bool operator&& (const Test& obj)\n\n {\n\n cout<<\"执行&&重载函数\"<<endl;\n\n return i && obj.i;\n\n }\n\n};\n\n// && 从左向右\n\nvoid main()\n\n{\n\n int a1 = 0;\n\n int a2 = 1;\n\n cout<<\"注意：&&操作符的结合顺序是从左向右\"<<endl;\n\n if( a1 && (a1 + a2) )\n\n {\n\n cout<<\"有一个是假，则不在执行下一个表达式的计算\"<<endl;\n\n }\n\n Test t1 = 0;\n\n Test t2 = 1;\n\n If ( t1 && (t1 + t2) )\n\n {\n\n=è\n\n T1.operator&&( t1 + t2) )\n\nT1.operator&&( t1.operator+(t2) )\n\n //t1 && t1.operator+(t2)\n\n // t1.operator( t1.operator(t2) )\n\n cout<<\"两个函数都被执行了，而且是先执行了+\"<<endl;\n\n }\n\n system(\"pause\");\n\n return ;\n\n}\n\n |\n|  |\n\n**8.5****运算符重载在项目开发中的应用**\n\n**1****实现一个数组类**\n\n添加<< >>\n\n**2****实现一个字符串类**\n\n构造函数要求\n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串类 以零结尾的字符串\n\n//若len为0,表示空串\n\nMyString a; //空串 “”\n\nMyString a(“dddd”);\n\nMyString b = a;\n\nb = “aaaaaa” \n\nb = a;\n\nif (a > b)\n\nif (a == b)\n\nb[i] = ‘a’;\n\n常用的操作符\n\n<< >> != == > < =\n\n| \n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串 以零结尾的字符串\n\nclass MyString\n\n{\n\n friend ostream& operator<<(ostream &out, const MyString &s);\n\npublic: //构造和析构\n\n MyString(int len = 0);\n\n MyString(const char *p);\n\n MyString(const MyString& obj);\n\n ~MyString();\n\npublic: //操作符重载\n\n MyString& operator=(const char *p);\n\n MyString& operator=(const MyString& obj);\n\n char& operator[](int index) const;\n\npublic:\n\n bool operator==(const char* p) const;\n\n bool operator!=(const char* p) const;\n\n bool operator==(const MyString& s) const;\n\n bool operator!=(const MyString& s) const;\n\npublic: //string to c\n\n char *c_str();\n\n const char* c_str() const;\n\n int length()\n\n {\n\n return m_len;\n\n }\n\npublic:\n\n int operator<(const char *p);\n\n int operator>(const char *p);\n\n int operator<(const MyString &s);\n\n int operator>(const MyString &s);\n\nprivate:\n\n int m_len;\n\n char  *m_p;\n\n};\n\n |\n\n**3****智能指针类编写**\n\n1问题抛出\n\n  指针使用过程中，经常会出现内存泄漏和内存多次被释放常\n\n2 解决方案：例如：boost库的智能指针\n\n  项目开发中，要求开发者使用预先编写的智能指针类对象代替C语言中的原生指针\n\n3 智能指针思想\n\n工程中的智能指针是一个类模板\n\n  通过构造函数接管申请的内存\n\n  通过析构函数确保堆内存被及时释放\n\n  通过重载指针运算符* 和 -> 来模拟指针的行为\n\n  通过重载比较运算符 == 和 != 来模拟指针的比较\n\n| \n\nclass Test\n\n{\n\npublic:\n\n Test()\n\n {\n\n this->a = 10;\n\n }\n\n void printT()\n\n {\n\n cout<<a<<endl;\n\n }\n\nprivate:\n\n int a;\n\n};\n\nclass MyTestPointer\n\n{\n\npublic:\n\npublic:\n\n MyTestPointer()\n\n {\n\n p = NULL;\n\n }\n\n MyTestPointer(Test* p)\n\n {\n\n this->p = p;\n\n }\n\n ~MyTestPointer()\n\n {\n\n delete p;\n\n }\n\n Test* operator->()\n\n {\n\n return p;\n\n }\n\n Test& operator*()\n\n {\n\n return *p;\n\n }\n\nprotected:\n\n Test *p;\n\n};\n\nvoid main01_classp()\n\n{\n\n Test *p = new Test;\n\n p->printT();\n\n delete p;\n\n MyTestPointer myp = new Test; //构造函数\n\n myp->printT(); //重载操作符 ->\n\n};\n\n |\n\n| \n\nclass MyIntPointer\n\n{\n\npublic:\n\npublic:\n\n MyIntPointer()\n\n {\n\n p = NULL;\n\n }\n\n MyIntPointer(int* p)\n\n {\n\n this->p = p;\n\n }\n\n ~MyIntPointer()\n\n {\n\n delete p;\n\n }\n\n int* operator->()\n\n {\n\n return p;\n\n }\n\n int& operator*()\n\n {\n\n return *p;\n\n }\n\nprotected:\n\n int *p;\n\n};\n\nvoid main02_intp()\n\n{\n\n int *p = new int(100);\n\n cout<<*p<<endl;\n\n delete p;\n\n MyIntPointer myp = new int(200);\n\n cout<<*myp<<endl; //重载*操作符\n\n};\n\n |\n\n**8.7****附录：运算符和结合性**\n\n总结\n\n操作符重载是C++的强大特性之一\n\n操作符重载的本质是通过函数扩展操作符的语义\n\noperator关键字是操作符重载的关键\n\nfriend关键字可以对函数或类开发访问权限\n\n操作符重载遵循函数重载的规则\n\n操作符重载可以直接使用类的成员函数实现\n\n=, [], ()和->操作符只能通过成员函数进行重载\n\n++操作符通过一个int参数进行前置与后置的重载\n\nC++中不要重载&&和||操作符"]],[33710,33710],[47877,47877]]],[1543489095453,["gjx16@GJXAIOU",[[-1,33710,"**6****友元**"],[1,33721,"#"],[-1,35480,"            "],[1,35492,"            "],[-1,35575,"            "],[1,35587,"            "],[-1,36526," "],[1,36527," "],[-1,36582," "],[1,36583," "],[-1,36625," "],[1,36626," "],[-1,36659," "],[1,36660," "],[-1,39920," "],[1,39921," "],[-1,40158," "],[1,40159," "],[-1,41160," "],[1,41161," "],[-1,41209," "],[1,41210," "],[-1,41582," "],[1,41583," "],[-1,41874,"               "],[1,41889,"               "],[-1,43757," "],[1,43758," "],[-1,43816," "],[1,43817," "],[-1,43884,"                     "],[1,43905,"                     "],[-1,44254,"                     "],[1,44275,"                     "],[-1,45496," "],[1,45497," "]],[33710,33710],[33711,33711]]],[1543489100240,["gjx16@GJXAIOU",[[1,33711,"# 六。"]],[33711,33711],[33715,33715]]],[1543489100969,["gjx16@GJXAIOU",[[-1,33714,"。"]],[33715,33715],[33714,33714]]],[1543489110232,["gjx16@GJXAIOU",[[1,33714,"、友元"]],[33714,33714],[33717,33717]]],[1543489114682,["gjx16@GJXAIOU",[[-1,33719,"**6.1****"],[1,33728,"#"]],[33719,33719],[33720,33720]]],[1543489116376,["gjx16@GJXAIOU",[[1,33720,"## "]],[33720,33720],[33723,33723]]],[1543489119081,["gjx16@GJXAIOU",[[1,33723,"（）"]],[33723,33723],[33725,33725]]],[1543489120906,["gjx16@GJXAIOU",[[1,33724,"一"]],[33724,33724],[33725,33725]]],[1543489124867,["gjx16@GJXAIOU",[[-1,33730,"**"]],[33732,33732],[33730,33730]]],[1543489128498,["gjx16@GJXAIOU",[[-1,33739,"\n"]],[33739,33739],[33738,33738]]],[1543489130085,["gjx16@GJXAIOU",[[-1,33736,"| "]],[33738,33738],[33736,33736]]],[1543489130820,["gjx16@GJXAIOU",[[-1,33736,"\n"]],[33736,33736],[33735,33735]]],[1543489151332,["gjx16@GJXAIOU",[[1,33732,"\n"]],[33731,33731],[33732,33732]]],[1543489197234,["gjx16@GJXAIOU",[[1,33732,"![8]($resource/8.png)"]],[33732,33732],[33754,33754]]],[1543489208807,["gjx16@GJXAIOU",[[-1,34166,"**6.2****"],[1,34175,"#"]],[34166,34166],[34167,34167]]],[1543489212264,["gjx16@GJXAIOU",[[1,34167,"## （）"]],[34167,34167],[34172,34172]]],[1543489217061,["gjx16@GJXAIOU",[[1,34171,"二"]],[34171,34171],[34172,34172]]],[1543489314438,["gjx16@GJXAIOU",[[-1,34162," |"]],[34162,34164],[34162,34162]]],[1543489332261,["gjx16@GJXAIOU",[[1,34162,"![9]($resource/9.png)"]],[34162,34162],[34184,34184]]],[1543489402514,["gjx16@GJXAIOU",[[1,34264,"\n"]],[34263,34263],[34264,34264]]],[1543489403242,["gjx16@GJXAIOU",[[1,34265,"\n"]],[34264,34264],[34265,34265]]],[1543489411664,["gjx16@GJXAIOU",[[1,34264,"![10]($resource/10.png)"]],[34264,34264],[34288,34288]]],[1543489424528,["gjx16@GJXAIOU",[[-1,34289,"**7****"],[1,34296,"#"]],[34289,34289],[34290,34290]]],[1543489428208,["gjx16@GJXAIOU",[[1,34290,"# 七、"]],[34290,34290],[34294,34294]]],[1543489431870,["gjx16@GJXAIOU",[[-1,34298,"**"]],[34300,34300],[34298,34298]]],[1543489433866,["gjx16@GJXAIOU",[[1,34289,"\n"]],[34287,34287],[34288,34288]]],[1543489434439,["gjx16@GJXAIOU",[[1,34290,"\n"]],[34288,34288],[34289,34289]]],[1543492421947,["gjx16@GJXAIOU",[[1,33703,"  "]],[33703,33703],[33705,33705]]],[1543493304244,["gjx16@GJXAIOU",[[1,32928,"\t\n"]],[32927,32927],[32929,32929]]],[1543493304836,["gjx16@GJXAIOU",[[-1,32928,"\t"],[1,32929,"\n"]],[32929,32929],[32929,32929]]],[1543493318591,["gjx16@GJXAIOU",[[1,32929,"    const vois"]],[32929,32929],[32943,32943]]],[1543493320164,["gjx16@GJXAIOU",[[-1,32942,"s"]],[32943,32943],[32942,32942]]],[1543493327983,["gjx16@GJXAIOU",[[1,32942,"d hello()"]],[32942,32942],[32951,32951]]],[1543493336229,["gjx16@GJXAIOU",[[1,32950,"int a,int b "]],[32950,32950],[32962,32962]]],[1543493340360,["gjx16@GJXAIOU",[[1,32964,"    \n"]],[32963,32963],[32968,32968]]],[1543493342736,["gjx16@GJXAIOU",[[1,32968,"{"]],[32968,32968],[32969,32969]]],[1543493343289,["gjx16@GJXAIOU",[[1,32970,"    \n"]],[32969,32969],[32974,32974]]],[1543493363769,["gjx16@GJXAIOU",[[1,32974,"  this->a = 100;"]],[32974,32974],[32990,32990]]],[1543493366207,["gjx16@GJXAIOU",[[1,32929,"\n"]],[32928,32928],[32929,32929]]],[1543493369861,["gjx16@GJXAIOU",[[1,32992,"      \n"]],[32991,32991],[32998,32998]]],[1543493370824,["gjx16@GJXAIOU",[[1,32998,"  "]],[32998,32998],[33000,33000]]],[1543493373328,["gjx16@GJXAIOU",[[-1,32998,"  "]],[33000,33000],[32998,32998]]],[1543493379725,["gjx16@GJXAIOU",[[1,32998,"this ->b "]],[32998,32998],[33007,33007]]],[1543493383848,["gjx16@GJXAIOU",[[1,33009,"200;"]],[33009,33009],[33013,33013]]],[1543493386276,["gjx16@GJXAIOU",[[1,33014,"      \n"]],[33013,33013],[33020,33020]]],[1543493389158,["gjx16@GJXAIOU",[[-1,33018,"  "]],[33020,33020],[33018,33018]]],[1543493391018,["gjx16@GJXAIOU",[[1,33018,"?"]],[33018,33018],[33019,33019]]],[1543493392282,["gjx16@GJXAIOU",[[-1,33018,"?"]],[33019,33019],[33018,33018]]],[1543493393961,["gjx16@GJXAIOU",[[1,33018,"}"]],[33018,33018],[33019,33019]]],[1543493396834,["gjx16@GJXAIOU",[[1,32975,"\n    "]],[32970,32970],[32975,32975]]],[1543493420186,["gjx16@GJXAIOU",[[1,32975,"  //下面这两个语句都是错误的"]],[32975,32975],[32991,32991]]],[1543493423748,["gjx16@GJXAIOU",[[1,33041,"    \n"]],[33040,33040],[33045,33045]]],[1543493427928,["gjx16@GJXAIOU",[[1,33045,"congst"]],[33045,33045],[33051,33051]]],[1543493432640,["gjx16@GJXAIOU",[[-1,33044," congst"]],[33051,33051],[33044,33044]]],[1543493437905,["gjx16@GJXAIOU",[[1,33044,"//const"]],[33044,33044],[33051,33051]]],[1543493500549,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[1,33052,"pr"]],[33028,33028],[33054,33054]]],[1543493500549,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[-1,33052,"pr"]],[33054,33054],[33028,33028]]],[1543493492238,["gjx16@GJXAIOU",[[1,33053,"的this指针，即相当于"]],[33053,33053],[33065,33065]]],[1543494886145,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[-1,33051,"\no"],[1,33053,"修饰"],[1,33065,"\npro"]],[33028,33028],[33069,33069]]],[1543494886145,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[1,33051,"\no"],[-1,33051,"修饰"],[-1,33065,"\npro"]],[33069,33069],[33028,33028]]],[1543494873096,["gjx16@GJXAIOU",[[1,33065,"this指针指向的内存空间不能被修改"]],[33065,33065],[33083,33083]]],[1543494880853,["gjx16@GJXAIOU",[[1,33084,"   \n"]],[33083,33083],[33087,33087]]],[1543494885251,["gjx16@GJXAIOU",[[1,33087,"//以为"]],[33087,33087],[33091,33091]]],[1543494948647,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[-1,33051,"\no"],[1,33053,"修饰"],[-1,33083,"t"],[1,33084,"\n"],[1,33092,"prot"]],[33028,33028],[33096,33096]]],[1543494948647,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[1,33051,"\no"],[-1,33051,"修饰"],[1,33083,"t"],[-1,33083,"\n"],[-1,33092,"prot"]],[33096,33096],[33028,33028]]],[1543494886840,["gjx16@GJXAIOU",[[-1,33089,"以为"]],[33091,33091],[33089,33089]]],[1543494909014,["gjx16@GJXAIOU",[[1,33089,"因为上面的函数会别C++编译器解析为：const "]],[33089,33089],[33114,33114]]],[1543494915293,["gjx16@GJXAIOU",[[-1,33107,"：const "]],[33114,33114],[33107,33107]]],[1543494926113,["gjx16@GJXAIOU",[[1,33107,":vois hello"]],[33107,33107],[33118,33118]]],[1543494929487,["gjx16@GJXAIOU",[[-1,33114,"ello"]],[33118,33118],[33114,33114]]],[1543494933208,["gjx16@GJXAIOU",[[-1,33111,"s h"],[1,33114,"d"]],[33111,33114],[33112,33112]]],[1543494940581,["gjx16@GJXAIOU",[[1,33112," hello()"]],[33112,33112],[33120,33120]]],[1543494947411,["gjx16@GJXAIOU",[[1,33119,"const "]],[33119,33119],[33125,33125]]],[1543495008630,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[-1,33051,"\no"],[1,33053,"修饰"],[-1,33083,"t"],[1,33084,"\n"],[1,33127,"prot"]],[33028,33028],[33131,33131]]],[1543495008630,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[1,33051,"\no"],[-1,33051,"修饰"],[1,33083,"t"],[-1,33083,"\n"],[-1,33127,"prot"]],[33131,33131],[33028,33028]]],[1543494957479,["gjx16@GJXAIOU",[[1,33125,"TR"]],[33125,33125],[33127,33127]]],[1543494958585,["gjx16@GJXAIOU",[[-1,33126,"R"]],[33127,33127],[33126,33126]]],[1543494965303,["gjx16@GJXAIOU",[[1,33126,"est * eh"]],[33126,33126],[33134,33134]]],[1543494966467,["gjx16@GJXAIOU",[[-1,33132,"eh"]],[33134,33134],[33132,33132]]],[1543494977272,["gjx16@GJXAIOU",[[1,33132,"this, inta ,int b"]],[33132,33132],[33149,33149]]],[1543494985360,["gjx16@GJXAIOU",[[-1,33131," "]],[33132,33132],[33131,33131]]],[1543494989035,["gjx16@GJXAIOU",[[1,33140," "]],[33140,33140],[33141,33141]]],[1543494993191,["gjx16@GJXAIOU",[[1,33151,"   \n"]],[33150,33150],[33154,33154]]],[1543495002080,["gjx16@GJXAIOU",[[1,33154,"//"]],[33154,33154],[33156,33156]]],[1543495002638,["gjx16@GJXAIOU",[[-1,33155,"/"]],[33156,33156],[33155,33155]]],[1543495006578,["gjx16@GJXAIOU",[[1,33155,"/同时"]],[33155,33155],[33158,33158]]],[1543495068643,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[-1,33051,"\no"],[1,33053,"修饰"],[-1,33083,"t"],[1,33084,"\n"],[1,33159,"prot"]],[33028,33028],[33163,33163]]],[1543495068643,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[1,33051,"\no"],[-1,33051,"修饰"],[1,33083,"t"],[-1,33083,"\n"],[-1,33159,"prot"]],[33163,33163],[33028,33028]]],[1543495019245,["gjx16@GJXAIOU",[[1,33158,"上面的const其实卸载"]],[33158,33158],[33170,33170]]],[1543495020790,["gjx16@GJXAIOU",[[-1,33168,"卸载"]],[33170,33170],[33168,33168]]],[1543495032081,["gjx16@GJXAIOU",[[1,33168,"下载函数（）卫冕的额"]],[33168,33168],[33178,33178]]],[1543495035198,["gjx16@GJXAIOU",[[-1,33173,"）卫冕的额"]],[33178,33178],[33173,33173]]],[1543495045768,["gjx16@GJXAIOU",[[1,33173,"）外面的任何位置都行"]],[33173,33173],[33183,33183]]],[1543495047066,["gjx16@GJXAIOU",[[1,33184,"   \n"]],[33183,33183],[33187,33187]]],[1543496950943,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[-1,33051,"\no"],[1,33053,"修饰"],[-1,33083,"t"],[1,33084,"\n"],[1,33188,"prot"]],[33028,33028],[33192,33192]]],[1543496950943,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[1,33051,"\no"],[-1,33051,"修饰"],[1,33083,"t"],[-1,33083,"\n"],[-1,33188,"prot"]],[33192,33192],[33028,33028]]],[1543496937712,["gjx16@GJXAIOU",[[1,33470,"```cpp"]],[33470,33470],[33476,33476]]],[1543496938332,["gjx16@GJXAIOU",[[1,33477,"\n"]],[33476,33476],[33477,33477]]],[1543496938955,["gjx16@GJXAIOU",[[1,33478,"\n"]],[33477,33477],[33478,33478]]],[1543496941436,["gjx16@GJXAIOU",[[1,33478,"```"]],[33478,33478],[33481,33481]]],[1543496944069,["gjx16@GJXAIOU",[[1,33477,"/*\n全局函数与成员函数\n*/\n\n\n//使用全局函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\t\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nTest Testadd(Test &t1, Test &t2)\n{\n\tTest tmp(3,4);\n\treturn tmp;\n}\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3(2, 3);\n\tt3= Testadd(t1, t2);\n}"]],[33477,33477],[33819,33819]]],[1543496949420,["gjx16@GJXAIOU",[[1,33824,"\n"]],[33823,33823],[33824,33824]]],[1543496950012,["gjx16@GJXAIOU",[[1,33825,"\n"]],[33824,33824],[33825,33825]]],[1543497010929,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[-1,33051,"\no"],[1,33053,"修饰"],[-1,33083,"t"],[1,33084,"\n"],[1,33188,"prot"],[-1,33195,""],[-1,33466,"\n 2、"],[-1,33476,"把"],[1,33477,"\n"],[1,33826," 2、把"]],[33028,33028],[33830,33830]]],[1543497010929,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[1,33051,"\no"],[-1,33051,"修饰"],[1,33083,"t"],[-1,33083,"\n"],[-1,33188,"prot"],[1,33199,""],[1,33470,"\n 2、"],[1,33476,"把"],[-1,33476,"\n"],[-1,33826," 2、把"]],[33830,33830],[33028,33028]]],[1543496953996,["gjx16@GJXAIOU",[[1,33825,"···"]],[33825,33825],[33828,33828]]],[1543496956465,["gjx16@GJXAIOU",[[-1,33825,"···"]],[33828,33828],[33825,33825]]],[1543496962310,["gjx16@GJXAIOU",[[1,33825,"```cpp"]],[33825,33825],[33831,33831]]],[1543496962916,["gjx16@GJXAIOU",[[1,33832,"\n"]],[33831,33831],[33832,33832]]],[1543496963463,["gjx16@GJXAIOU",[[1,33833,"\n"]],[33832,33832],[33833,33833]]],[1543496964113,["gjx16@GJXAIOU",[[1,33834,"\n"]],[33833,33833],[33834,33834]]],[1543496966025,["gjx16@GJXAIOU",[[1,33834,"```"]],[33834,33834],[33837,33837]]],[1543497311902,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[-1,33051,"\no"],[1,33053,"修饰"],[-1,33083,"t"],[1,33084,"\n"],[1,33188,"prot"],[-1,33195,""],[-1,33466,"\n 2、"],[-1,33476,"把"],[1,33477,"\n"],[1,33838," 2、把"]],[33028,33028],[33842,33842]]],[1543497311902,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[1,33051,"\no"],[-1,33051,"修饰"],[1,33083,"t"],[-1,33083,"\n"],[-1,33188,"prot"],[1,33199,""],[1,33470,"\n 2、"],[1,33476,"把"],[-1,33476,"\n"],[-1,33838," 2、把"]],[33842,33842],[33028,33028]]],[1543497256420,["gjx16@GJXAIOU",[[1,33832,"//使用成员函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\tTest Testadd(Test &t2)\n\t{\n\t\tTest tmp(this->a + t2.a, this->b + t2.b);\n\t\treturn tmp;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3 = t1.Testadd(t2);\n}\n"]],[33832,33832],[34167,34167]]],[1543497554947,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[-1,33051,"\no"],[1,33053,"修饰"],[-1,33083,"t"],[1,33084,"\n"],[1,33188,"prot"],[-1,33466,"\n 2、"],[-1,33476,"把"],[1,33477,"\n"],[1,34173," 2、把"]],[33028,33028],[34177,34177]]],[1543497554947,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[1,33051,"\no"],[-1,33051,"修饰"],[1,33083,"t"],[-1,33083,"\n"],[-1,33188,"prot"],[1,33470,"\n 2、"],[1,33476,"把"],[-1,33476,"\n"],[-1,34173," 2、把"]],[34177,34177],[33028,33028]]],[1543497553912,["gjx16@GJXAIOU",[[1,34164,"//匿名对象"]],[34164,34164],[34170,34170]]],[1543497615394,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[-1,33051,"\no"],[1,33053,"修饰"],[-1,33083,"t"],[1,33084,"\n"],[1,33188,"prot"],[-1,33466,"\n 2、"],[-1,33476,"把"],[1,33477,"\n"],[1,34179," 2、把"]],[33028,33028],[34183,34183]]],[1543497615394,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[1,33051,"\no"],[-1,33051,"修饰"],[1,33083,"t"],[-1,33083,"\n"],[-1,33188,"prot"],[1,33470,"\n 2、"],[1,33476,"把"],[-1,33476,"\n"],[-1,34179," 2、把"]],[34183,34183],[33028,33028]]],[1543497563924,["gjx16@GJXAIOU",[[1,34170,"直接转化成t4;"]],[34170,34170],[34178,34178]]],[1543497565349,["gjx16@GJXAIOU",[[-1,34177,";"]],[34178,34178],[34177,34177]]],[1543497566825,["gjx16@GJXAIOU",[[1,34178,"\t\n"]],[34177,34177],[34179,34179]]],[1543497572444,["gjx16@GJXAIOU",[[1,34179,"Test头"]],[34179,34179],[34184,34184]]],[1543497573704,["gjx16@GJXAIOU",[[-1,34183,"头"]],[34184,34184],[34183,34183]]],[1543497578350,["gjx16@GJXAIOU",[[1,34183," t4()"]],[34183,34183],[34188,34188]]],[1543497581766,["gjx16@GJXAIOU",[[1,34187,"3,5"]],[34187,34187],[34190,34190]]],[1543497583240,["gjx16@GJXAIOU",[[1,34191,";"]],[34191,34191],[34192,34192]]],[1543497583816,["gjx16@GJXAIOU",[[1,34193,"\t\n"]],[34192,34192],[34194,34194]]],[1543497598430,["gjx16@GJXAIOU",[[1,34194,"t4 = t1.Testadd()"]],[34194,34194],[34211,34211]]],[1543497602398,["gjx16@GJXAIOU",[[1,34210,"t2"]],[34210,34210],[34212,34212]]],[1543497607818,["gjx16@GJXAIOU",[[1,34213,";  、、"]],[34213,34213],[34218,34218]]],[1543497609698,["gjx16@GJXAIOU",[[-1,34216,"、、"]],[34218,34218],[34216,34216]]],[1543497614647,["gjx16@GJXAIOU",[[1,34216,"//匿名对象"]],[34216,34216],[34222,34222]]],[1543497675345,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[-1,33051,"\no"],[1,33053,"修饰"],[-1,33083,"t"],[1,33084,"\n"],[1,33188,"prot"],[-1,33466,"\n 2、"],[-1,33476,"把"],[1,33477,"\n"],[1,34231," 2、把"]],[33028,33028],[34235,34235]]],[1543497675345,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[1,33051,"\no"],[-1,33051,"修饰"],[1,33083,"t"],[-1,33083,"\n"],[-1,33188,"prot"],[1,33470,"\n 2、"],[1,33476,"把"],[-1,33476,"\n"],[-1,34231," 2、把"]],[34235,34235],[33028,33028]]],[1543497615681,["gjx16@GJXAIOU",[[1,34222,"赋值"]],[34222,34222],[34224,34224]]],[1543497617215,["gjx16@GJXAIOU",[[-1,34222,"赋值"]],[34224,34224],[34222,34222]]],[1543497624914,["gjx16@GJXAIOU",[[1,34222,"复制给t5"]],[34222,34222],[34227,34227]]],[1543499535380,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[-1,33051,"\no"],[1,33053,"修饰"],[-1,33083,"t"],[1,33084,"\n"],[1,33188,"prot"],[-1,33466,"\n 2、"],[-1,33476,"把"],[1,33477,"\n"],[1,34236," 2、把"]],[33028,33028],[34240,34240]]],[1543499535380,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[1,33051,"\no"],[-1,33051,"修饰"],[1,33083,"t"],[-1,33083,"\n"],[-1,33188,"prot"],[1,33470,"\n 2、"],[1,33476,"把"],[-1,33476,"\n"],[-1,34236," 2、把"]],[34240,34240],[33028,33028]]],[1543499489491,["gjx16@GJXAIOU",[[1,34366,",xiangt"]],[34366,34366],[34373,34373]]],[1543499492973,["gjx16@GJXAIOU",[[-1,34369,"angt"]],[34373,34373],[34369,34369]]],[1543499496739,["gjx16@GJXAIOU",[[1,34369,"相当于"]],[34369,34369],[34372,34372]]],[1543499500272,["gjx16@GJXAIOU",[[-1,34367,"xi"]],[34369,34369],[34367,34367]]],[1543499505379,["gjx16@GJXAIOU",[[1,34370,"返回自身"]],[34370,34370],[34374,34374]]],[1543499523280,["gjx16@GJXAIOU",[[-1,34357," //函数返回引用,相当于返回自身"]],[34374,34374],[34357,34357]]],[1543499529020,["gjx16@GJXAIOU",[[1,34357," //函数返回引用,相当于返回自身"]],[34357,34357],[34374,34374]]],[1543499655400,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[-1,33051,"\no"],[1,33053,"修饰"],[-1,33083,"t"],[1,33084,"\n"],[1,33188,"prot"],[-1,33466,"\n 2、"],[-1,33476,"把"],[1,33477,"\n"],[1,34236," 2、把"],[-1,34357," //函"],[1,34374,"\n {\n"]],[33028,33028],[34378,34378]]],[1543499655400,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[1,33051,"\no"],[-1,33051,"修饰"],[1,33083,"t"],[-1,33083,"\n"],[-1,33188,"prot"],[1,33470,"\n 2、"],[1,33476,"把"],[-1,33476,"\n"],[-1,34236," 2、把"],[1,34361," //函"],[-1,34374,"\n {\n"]],[34378,34378],[33028,33028]]],[1543499653639,["gjx16@GJXAIOU",[[1,34377,"      京东方科技点开了房间的路口附近的路口"]],[34377,34377],[34401,34401]]],[1543499715421,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[-1,33051,"\no"],[1,33053,"修饰"],[-1,33083,"t"],[1,33084,"\n"],[1,33188,"prot"],[-1,33466,"\n 2、"],[-1,33476,"把"],[1,33477,"\n"],[1,34236," 2、把"],[-1,34357," //函"],[-1,34374,"   "],[1,34377,"\n {"],[1,34401,"\n   "]],[33028,33028],[34405,34405]]],[1543499715421,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[1,33051,"\no"],[-1,33051,"修饰"],[1,33083,"t"],[-1,33083,"\n"],[-1,33188,"prot"],[1,33470,"\n 2、"],[1,33476,"把"],[-1,33476,"\n"],[-1,34236," 2、把"],[1,34361," //函"],[1,34374,"   "],[-1,34374,"\n {"],[-1,34401,"\n   "]],[34405,34405],[33028,33028]]],[1543499656871,["gjx16@GJXAIOU",[[1,34401,"就打开房间打开了房间"]],[34401,34401],[34411,34411]]],[1543499662842,["gjx16@GJXAIOU",[[-1,34404,"房间打开了房间"]],[34411,34411],[34404,34404]]],[1543499775390,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[-1,33051,"\no"],[1,33053,"修饰"],[-1,33083,"t"],[1,33084,"\n"],[1,33188,"prot"],[-1,33466,"\n 2、"],[-1,33476,"把"],[1,33477,"\n"],[1,34236," 2、把"],[-1,34357," //函"],[-1,34374,"   "],[1,34377,"\n {"],[1,34404,"\n   "]],[33028,33028],[34408,34408]]],[1543499775390,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[1,33051,"\no"],[-1,33051,"修饰"],[1,33083,"t"],[-1,33083,"\n"],[-1,33188,"prot"],[1,33470,"\n 2、"],[1,33476,"把"],[-1,33476,"\n"],[-1,34236," 2、把"],[1,34361," //函"],[1,34374,"   "],[-1,34374,"\n {"],[-1,34404,"\n   "]],[34408,34408],[33028,33028]]],[1543499773919,["gjx16@GJXAIOU",[[1,34374,"，谁电泳"]],[34374,34374],[34378,34378]]],[1543499835396,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[-1,33051,"\no"],[1,33053,"修饰"],[-1,33083,"t"],[1,33084,"\n"],[1,33188,"prot"],[-1,33466,"\n 2、"],[-1,33476,"把"],[1,33477,"\n"],[1,34236," 2、把"],[-1,34357," //函"],[-1,34378,"   "],[1,34381,"\n {"],[1,34408,"\n   "]],[33028,33028],[34412,34412]]],[1543499835396,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[1,33051,"\no"],[-1,33051,"修饰"],[1,33083,"t"],[-1,33083,"\n"],[-1,33188,"prot"],[1,33470,"\n 2、"],[1,33476,"把"],[-1,33476,"\n"],[-1,34236," 2、把"],[1,34361," //函"],[1,34378,"   "],[-1,34378,"\n {"],[-1,34408,"\n   "]],[34412,34412],[33028,33028]]],[1543499777574,["gjx16@GJXAIOU",[[-1,34376,"电泳"]],[34378,34378],[34376,34376]]],[1543499782599,["gjx16@GJXAIOU",[[1,34376,"调用返回谁"]],[34376,34376],[34381,34381]]],[1543499955406,[null,[[-1,33028,"\np"],[1,33030,"= "],[-1,33034,"r"],[1,33035,"\n"],[-1,33051,"\no"],[1,33053,"修饰"],[-1,33083,"t"],[1,33084,"\n"],[1,33188,"prot"],[-1,33466,"\n 2、"],[-1,33476,"把"],[1,33477,"\n"],[1,34236," 2、把"],[-1,34357," //函"],[-1,34381,"   "],[1,34384,"\n {"],[1,34411,"\n   "]],[33028,33028],[34415,34415]]],[1543499955406,[null,[[1,33028,"\np"],[-1,33028,"= "],[1,33034,"r"],[-1,33034,"\n"],[1,33051,"\no"],[-1,33051,"修饰"],[1,33083,"t"],[-1,33083,"\n"],[-1,33188,"prot"],[1,33470,"\n 2、"],[1,33476,"把"],[-1,33476,"\n"],[-1,34236," 2、把"],[1,34361," //函"],[1,34381,"   "],[-1,34381,"\n {"],[-1,34411,"\n   "]],[34415,34415],[33028,33028]]],[1543499908430,["gjx16@GJXAIOU",[[-1,34390,"京东方科技点开了房间的路口附近的路口就打开"]],[34390,34411],[34390,34390]]]],null,"gjx16@GJXAIOU"],["02fbd053-c7b5-4030-8275-b265b1226ee2",1543540155978,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁;\n   * c++面向对象模型初探;  \n   * c++面向对象多态原理探究;\n   * 操作符重载;\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;//定义两个对象c1和c2\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n};\n\n```\nTeacher.cpp\n//具体实现函数内容，在函数名前面加上`类名::`\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1:设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)//因为类的成员变量这里都是private:\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n###  (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n###  (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//需要重载=号操作符，才能解决带来的浅拷贝问题\n\n\tobj2 = obj3; //=号操作，也是一种浅拷贝\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++的默认copy构造函数是浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n\n---\n\n\n### （五）多个对象构造和析构\n\n**1.对象初始化列表**\n\n- 1）对象初始化列表出现原因\n程序本身是有问题的\n```cpp\n\n/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B   //在一个类里面组合了一个带有参数的构造函数的类，因为C++编译器要确定分配给B多大的内存，但是没法初始化A定义的两个对象（因为需要调用有参的构造函数）\n{\npublic:   //没有写B的构造函数，按理说应该调用默认的构造函数\n\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  //主要是因为没有方法和没有机会去初始化这两个A定义的对象\n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB;\n\treturn 0;\n\n}\n\n```\n\n解决方法：\n```cpp\n/*\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n};\n\n\nclass B  \n{\npublic:   \n//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）\n\tB(int _a, int _b) : a1(1), a2(3)  \n\t{\n\n\t}\n//第二种参数传递的方法：\n/*\nB(int _a, int _b,int m,int n) : a1(m), a2(n)  \n\t{\n      a = _a;\n      b = _b;\n\t}\n\t\n*/\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  \n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB(1,2);\n\t//第二种方式：B objB(1,2,4,3)\n\treturn 0;\n\n}\n\n```\n\n**以上程序的操作顺序：**\n首先执行被组合对象的构造函数（a1,a2），如果有多个组合对象，则按照定义的顺序，而不是按照初始化列表的顺序（：后面的顺序）\n析构函数：和构造函数的调用顺序相反\n\n  - 1.必须这样做：\n    - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    - 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n  - 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    - 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    - 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n- 2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n```cpp\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n{\n // some other assignment operation\n}\n```\n\n\n- 3）注意概念\n  - 初始化：被初始化的对象正在创建\n  - 赋值：被赋值的对象已经存在\n\n- 4）注意：\n  - 成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n  - 初始化列表先于构造函数的函数体执行\n\n**说明：**\n\n* 1 C++中提供了初始化列表对成员变量进行初始化\n* 2 使用初始化列表出现原因：\n  * 1.必须这样做：\n    * 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n    * 而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    * 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n  * 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    * 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    * 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n```cpp\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n ABC(int a, int b, int c)\n {\n this->a = a;\n this->b = b;\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"ABC construct ..\\n\");\n }\n\n ~ABC()\n {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n }\n\nprotected:\nprivate:\n int a;\n int b;\n int c;\n};\n\nclass MyD\n{\npublic:\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n {\n cout<<\"MyD()\"<<endl;\n }\n\n ~MyD()\n {\n cout<<\"~MyD()\"<<endl;\n }\n\nprotected:\nprivate:\n ABC abc1; //c++编译器不知道如何构造abc1\n ABC abc2;\n const int m;\n};\n\nint run()\n{\n MyD myD;\n return 0;\n}\n\nint main_dem03()\n{\n run();\n system(\"pause\");\n return 0;\n}\n\n```\n\n\n\n\n### （六）构造函数和析构函数的调用顺序研究\n\n**构造函数与析构函数的调用顺序**\n\n- 1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n- 2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n### （七）构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1构造析构综合训练**\n```cpp\n\n/*\n\n总结 构造和析构的调用顺序\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n\tABC(int a, int b, int c)   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\n\t}\n\n\t~ABC()\n\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\n\nclass MyD \n{\npublic:\n\tMyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~MyD()\n\t{\n\t\tcout << \"~MyD()\" << endl;\n\t}\n\n\tMyD(const MyD & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\tcout << \"MyD(const MyD &obj)\" << endl;\n\t}\n\nprotected:\nprivate:\n\tABC abc1; //c++编译器不知道如何构造abc1//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\tABC abc2;\n\tconst int m;//因为是const m,所以上面所有的m都进行了赋值\n};\n\n\nint doThing(MyD myel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;\n}\n\n\nint run2()//二\n{\n\tMyD myD;//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\treturn 0;\n}\n\nint run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main()\n{\n\trun2();//一\n\t//run3();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n\n\n```\n\n\n**2匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3匿名对象强化训练**\n\n3） 构造中调用构造\n\n```cpp\n/*\n\n构造中调用构造\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass MyTest\n{\npublic:\n\tMyTest(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t}\n\n\tMyTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\n\t\tMyTest(a, b, 10);\n\t}\n\n\t~MyTest()\n\t{\n\t\tcout << \"MyTest is ...\" << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n\n\npublic:\n\tint getC() const { return c; }\n\n\tvoid setC(int val) { c = val; }\n};\n\nint main()\n{\n\tMyTest t1(1, 2);\n\tcout << t1.getC() << endl;\n\tsystem(\"pause\");\n\treturn 0;\n\t\n}\n\n\n```\n\n 结论： 构造函数中调用构造函数，是一个蹩脚的行为。\n程序内存图：\n![搜狗截图20181124125452]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181124125452.png)\n\n### （八）对象的动态建立和释放\n\n**1.new和delete基本语法**\n```cpp\n/*\n\nnew 和delete的使用\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nvoid main()\n{\n\t//先分配内存然后赋值\n\tint *p = new int;  //分配基础类型\n\t*p = 20;  \n\n\t//在定义的时候直接分配内存\n\tint *p1 = new int(30);\n\tcout << *p1 << endl;\n\n\tsystem(\"pause\");\n\treturn; \n}\n\n```\n\n- 1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n  **注意： new和delete是运算符，不是函数，因此执行效率高。**\n\n- 2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： \nnew int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 \nnew char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址    new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n- 3）new和delete运算符使用的一般格式为：\n  用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n![new运算符动态]($resource/new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%A8%E6%80%81.png)\n```cpp\n\n/*\n使用malloc /free 与new /delete的区别\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest();\n\t~Test();\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\nTest::Test()\n{\n\tcout << \"执行了构造函数\" << endl;\n}\n\nTest::~Test()\n{\n\tcout << \"执行了析构函数\" << endl;\n}\n\n\n\nint main()\n{\n\t//基础类型\n\tint *p1 = (int *)malloc(sizeof(int));\n\t*p1 = 10;\n\tdelete p1;\n\n\tint *p2 = new int;\n\t*p2 = 20;\n\tfree(p2);\n\n\n\n\t//数组类型（元素为基础类型）\n\tint *p3 = (int *)malloc(sizeof(int)*10);\n\tp3[0] = 1;\n\tdelete[]p3;\n\n\tint *p4 = new int[10];\n\tp4[1] = 2;\n\tfree(p4);\n\n\n\t//类\n\tTest *p5 = (Test *)malloc(sizeof(Test));\n\tdelete p5;\n\n\tTest *p6 = new Test(10);\n\tfree(p6);\n}\n\n\n```\n**结论：** \nnew：不仅分配内存，而且调用了构造函数\ndelete:不仅释放了内存，而且调用了析构函数\n\n- 4） 应用举例\n\n![5]($resource/5.png)\n\n**2类对象的动态建立和释放**\n\n- 使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n-  C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n  比如：\n\n  Box *pt;  //定义一个指向Box类对象的指针变量pt\n      pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n   这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n  新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n   在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3.编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n\n\n\n## 四、静态成员变量和成员函数\n\n\n思考：每个变量，拥有属性。有没有一些属性，归所有对象拥有？\n\n### （一）静态成员变量\n\n- **1定义静态成员变量**\n  - 关键字 **static**  可以用于说明一个类的成员，\n    静态成员提供了一个同类对象的共享机制\n\n  - 把一个类的成员说明为 **static**  时，这个类无论有多少个对象被创建，这些对象共享这个 **static**  成员\n\n  - 静态成员局部于类，它不是对象成员\n\n![1]($resource/1.png)\n\n例如：\n\n```cpp\n\n/*\n静态成员变量\n*/\n\n#include<iostream>\nusing namespace std;\n\nclass counter\n{\n\n\tstatic int num; //**声明与定义静态数据成员**\n\npublic:\n\n\tvoid setnum(int i) \n\t{ \n\t\tnum = i; \n\t} //成员函数访问静态数据成员\n\n\tvoid shownum() \n\t{ \n\t\tcout << num << endl;\n\t}\n\n};\n\nint counter::num = 0;//声明与定义静态数据成员\n\nvoid main()\n{\n\tcounter a, b;\n\n\ta.shownum(); //调用成员函数访问私有静态数据成员\n\tb.shownum();\n\ta.setnum(10);\n\ta.shownum();\n\tb.shownum();\n\n}\n\n```\n\n![6]($resource/6.png)\n\n**从结果可以看出，访问的是同一个静态数据成员**\n\n- **2使用静态成员变量**\n```cpp\n//例5-14_使用公有静态数据成员\n\n#include<iostream.h>\n\nclass counter\n{ \npublic :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n\n```\n使用静态成员函数调用静态成员变量\n```cpp\n/*\n静态成员函数\n*/\n// 结论：在静态成员函数中可以使用静态成员变量，但是不能使用类中普通的成员变量\n\n#include\"iostream\"\nusing namespace std;\n\nclass BB\n{\npublic:\n\tint printC()\n\t{\n\t\tcout << \"c:\" << c << endl;\n\t\treturn c;\n\t}\n\n\tint addC()\n\t{\n\t\tc = c+1;\n\t}\n\n\n\tstatic void getC()\n\t{\n\t\tcout << \"c\" << c << endl;  //可以直接在静态成员函数中使用静态成员变量，但是不能直接使用一般变量\n\t}\nprivate:\n\tint a;\n\tint b;\n\tstatic int c;\n\n};\n\n\nint BB::c = 10;  //初始化成员变量值\n\nvoid main()\n{\n\tBB b1, b2, b3;\n\tb1.printC();//10\n\tb2.addC();//11\n\tb3.printC();//11\n\n\t//调用成员函数两种方法；\n\tb3.getC();//使用对象.\n\tBB::getC();//使用类::\n\n\n\n}\n\n```\n\n### (二)静态成员函数\n\n- **1）概念**\n\n  - 静态成员函数数冠以关键字static\n\n  - 静态成员函数提供不依赖于类数据结构的共同操作，它没有this指针\n  - 在类外调用静态成员函数用 `_类名_ ::`作限定词，或通过对象调用\n\n- **2）案例**\n![7]($resource/7.png)\n\n- **3）疑难问题：**\n静态成员函数中，不能使用普通变量。\n//静态成员变量属于整个类的，分不清楚，是那个具体对象的属性。\n![成员函数中的疑难问题]($resource/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98.png)\n\n**4.3 综合训练**\n\n\n\n## 五、 C++面向对象模型初探\n\n**前言**\n\n- C++对象模型可以概括为以下2部分：\n\n  - 1. 语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等等。\n\n  - 2. 对于各种支持的底层实现机制。\n\n  在c语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。在c++中，通过抽象数据类型（abstract data type，ADT），在类中定义数据和函数，来实现数据和函数直接的绑定。\n\n  概括来说，在C++类中有两种成员数据：static、nonstatic；三种成员函数：static、nonstatic、virtual。\n\n![C++类的组成]($resource/C++%E7%B1%BB%E7%9A%84%E7%BB%84%E6%88%90.png)\n\n### （一）基础知识\n\nC++中的class从面向对象理论出发，将变量(属性)和函数(方法)集中定义在一起，用于描述现实世界中的类。从计算机的角度，程序依然由数据段和代码段构成。\n\n**C++编译器如何完成面向对象理论到计算机程序的转化？**\n换句话：C++编译器是如何管理类、对象、类和对象之间的关系\n具体的说：具体对象调用类中的方法，那，c++编译器是如何区分，是那个具体的类，调用这个方法那?\n\n思考一下程序结果\n```cpp\n/*\n面向对象模型初探\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass C1\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\nprotected:\n\nprivate:\n\n}; //12\n\nclass C2\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\n\tstatic int m; \n\npublic:\n\n\tint getK() const { return k; } //方法是属于代码，应该放在代码区\n\tvoid setK(int val) { k = val; } \n\nprotected:\n\nprivate:\n}; \n\nstruct S1\n{\n\tint i;\n\tint j;\n\tint k;\n}; \n\nstruct S2\n{\n\tint i;\n\tint j;\n\tint k;\n\tstatic int m;\n}; \n\nint main()\n{\n\n\tprintf(\"c1:%d \\n\", sizeof(C1));\n\tprintf(\"c2:%d \\n\", sizeof(C2));\n\tprintf(\"s1:%d \\n\", sizeof(S1));\n\tprintf(\"s2:%d \\n\", sizeof(S2));\n\tsystem(\"pause\");\n\n}\n```\n程序运行结果：\n`c1:12`\n`c2:12`\n`s1:12`\n`s2:12`\n\n \n### (二)编译器对属性和方法的处理机制\n\n通过上面的案例，我们可以的得出：\n1）C++类对象中的成员变量和成员函数是分开存储的\n- 成员变量：\n  - 普通成员变量：存储于对象中，与struct变量有相同的内存布局和字节对齐方式\n  - 静态成员变量：存储于全局数据区中\n\n- 成员函数：存储于代码段中。\n问题出来了：很多对象共用一块代码？代码是如何区分具体对象的那？\n换句话说：int getK() const { return k; }，代码是如何区分，具体obj1、obj2、obj3对象的k值？\n\n2）C++编译器对普通成员函数的内部处理\n\n![C++编译器对普通成员函数的内部处理]($resource/C++%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E9%83%A8%E5%A4%84%E7%90%86.png)\n\n请仔细思考，并说出你的总结！\n\n\n\n### （三）总结\n\n1、C++类对象中的成员变量和成员函数是分开存储的。C语言中的内存四区模型仍然有效！\n**2、C++中类的普通成员函数都隐式包含一个指向当前对象的this指针。**\n3、静态成员函数、成员变量属于类\n\n静态成员函数与普通成员函数的区别\n\n静态成员函数不包含指向具体对象的指针\n\n普通成员函数包含一个指向具体对象的指针\n\n\n### （四）this指针\n\n![this指针图示]($resource/this%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png)\n\n实验1：若类成员函数的形参 和 类的属性（成员变量）名字相同，通过this指针来解决。\n```cpp\n\n/*\nthis 指针\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass Test\n{\npublic:\n\tTest( int a, int b)//Test(Test *this, int a, int b)//因为这里成员函数的形参和成员变量一样，不用this指针会出现：a = a ,b = b;\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printT()\n\t{\n\t\tcout << \"a; \" << a << endl;\n\t\tcout << \"b: \" << this->b << endl;\n\t}\n\n\n    const void hello(int a,int b )\n    {\n      //下面这两个语句都是错误的\n      this->a = 100;\n      this ->b = 200;\n    }\n   //const修饰的this指针，即相当于this指针指向的内存空间不能被修改\n   //因为上面的函数会别C++编译器解析为:void hello(const Test *this, int a ,int b)\n   //同时上面的const其实下载函数（）外面的任何位置都行\n   \nprotected:\nprivate:\n\tint a;\n\tint b;\n};\nint  main()\n{\n\tTest t1(1, 2);\n\tt1.printT();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`a:1`\n`b:2`\n\n\n实验2：类的成员函数可通过const修饰，请问const修饰的是谁\n\n\n### （五）全局函数PK成员函数\n\n 1、把全局函数转化成成员函数，通过this指针隐藏左操作数\n\n   Test add(Test &t1, Test &t2)===》Test add( Test &t2)\n```cpp\n/*\n全局函数与成员函数\n*/\n\n\n//使用全局函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\t\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nTest Testadd(Test &t1, Test &t2)\n{\n\tTest tmp(3,4);\n\treturn tmp;\n}\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3(2, 3);\n\tt3= Testadd(t1, t2);\n}\n```\n\n```cpp\n//使用成员函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\tTest Testadd(Test &t2)\n\t{\n\t\tTest tmp(this->a + t2.a, this->b + t2.b);\n\t\treturn tmp;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3 = t1.Testadd(t2);//匿名对象直接转化成t4\n\tTest t4(3,5);\n\tt4 = t1.Testadd(t2);  //匿名对象复制给t5\n}\n\n\n```\n 2、把成员函数转换成全局函数，多了一个参数\n\n   void printAB()===》void printAB(Test *pthis)\n\n 3、函数返回元素和返回引用\n```cpp\nTest& add(Test &t2) //*this //函数返回引用,相当于返回自身，谁调用返回谁\n {      \n   this->a = this->a + t2.getA();\n\n   this->b = this->b + t2.getB();\n\n   return *this; //*操作让this指针回到元素状态\n\n }\n\nTest add2(Test &t2) //*this //函数返回元素\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n return t3;\n\n }\n\n void add3(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n //return t3;\n\n }\n  \n\n```\n\n## 六、友元\n\n### （一）友元函数\n\n![8]($resource/8.png)\n例如\n\nclass A1\n\n{\n\npublic:\n\n A1()\n\n {\n\n a1 = 100;\n\n a2 = 200;\n\n }\n\n int getA1()\n\n {\n\n return this->a1;\n\n }\n\n //声明一个友元函数\n\n friend void setA1(A1 *p, int a1); //这个函数是这个类的好朋友\n\nprotected:\n\nprivate:\n\n int a1;\n\n int a2;\n\n};\n\nvoid setA1(A1 *p, int a1)\n\n{\n\n p->a1 = a1;\n\n}\n\nvoid main()\n\n{\n\n A1 mya1;\n\n cout<<mya1.getA1()<<endl;\n\n setA1(&mya1, 300); //通过友元函数 修改A类的私有属性\n\n cout<<mya1.getA1()<<endl;\n\n system(\"pause\");\n\n}\n\n![9]($resource/9.png)\n\n### （二）友元类**\n\nØ 若B类是A类的友员类，则B类的所有成员函数都是A类的友员函数\n\nØ 友员类通常设计为一种对数据操作或类之间传递消息的辅助类\n\n![10]($resource/10.png)\n\n\n\n## 七、强化训练\n\n**1 static****关键字强化训练题**\n\nØ 某商店经销一种货物。货物购进和卖出时以箱为单位，各箱的重量不一样，因此，商店需要记录目前库存的总重量。现在用C++模拟商店货物购进和卖出的情况。\n\n| \n\n#include \"iostream\"\n\nusing namespace std;\n\nclass Goods\n\n{\n\npublic :\n\n Goods ( int w) { weight = w ; total_weight += w ; }\n\n ~ Goods() { total_weight -= weight ; }\n\n int Weight() { return weight ; } ;\n\n static int TotalWeight() { return total_weight ; }\n\n Goods *next ;\n\nprivate :\n\n int weight ;\n\n static int total_weight ;\n\n} ;\n\nint Goods::total_weight = 0 ;\n\n//r尾部指针\n\nvoid purchase( Goods * &f, Goods *& r, int w )\n\n{\n\n Goods *p = new Goods(w) ;\n\n p -> next = NULL ;\n\n if ( f == NULL ) f = r = p ;\n\n else { r -> next = p ; r = r -> next ; } //尾部指针下移或新结点变成尾部结点\n\n}\n\nvoid sale( Goods * & f , Goods * & r )\n\n{\n\n if ( f == NULL ) { cout << \"No any goods!\\n\" ; return ; }\n\n Goods *q = f ; f = f -> next ; delete q ;\n\n cout << \"saled.\\n\" ;\n\n}\n\nvoid main()\n\n{\n\n Goods * front = NULL , * rear = NULL ;\n\n int w ; int choice ;\n\n do\n\n {\n\n cout << \"Please choice:\\n\" ;\n\n cout << \"Key in 1 is purchase,\\nKey in 2 is sale,\\nKey in 0 is over.\\n\" ;\n\n cin >> choice ;\n\n switch ( choice ) // 操作选择\n\n {\n\n case 1 : // 键入1，购进1箱货物\n\n { cout << \"Input weight: \" ;\n\n cin >> w ;\n\n purchase( front, rear, w ) ; // 从表尾插入1个结点\n\n break ;\n\n }\n\n case 2 :              // 键入2，售出1箱货物\n\n { sale( front, rear ) ; break ; } // 从表头删除1个结点\n\n case 0 : break ;              // 键入0，结束\n\n }\n\n cout << \"Now total weight is:\" << Goods::TotalWeight() << endl ;\n\n } while ( choice ) ;\n\n}\n\n |\n\n**2** **数组类封装**\n\n目标：解决实际问题，训练构造函数、copy构造函数等，为操作符重载做准备\n\n数组类的测试\n\n| \n\n#include \"iostream\"\n\n#include \"Array.h\"\n\nusing namespace std;\n\nint main()\n\n{\n\n Array a1(10);\n\n for(int i=0; i<a1.length(); i++)\n\n {\n\n a1.setData(i, i);\n\n }\n\n for(int i=0; i<a1.length(); i++)\n\n {\n\n printf(\"array %d: %d\\n\", i, a1.getData(i));\n\n }\n\n Array a2 = a1;\n\n for(int i=0; i<a2.length(); i++)\n\n {\n\n printf(\"array %d: %d\\n\", i, a2.getData(i));\n\n }\n\n system(\"pause\");\n\n return 0;\n\n}\n\n |\n\n数组类的头文件\n\n| \n\n#ifndef _MYARRAY_H_\n\n#define _MYARRAY_H_\n\nclass Array\n\n{\n\nprivate:\n\n int mLength;\n\nint* mSpace;\n\npublic:\n\n Array(int length);\n\n Array(const Array& obj);\n\n int length();\n\n void setData(int index, int value);\n\n int getData(int index);\n\n ~Array();\n\n};\n\n#endif\n\n |\n\n**3****小结**\n\nØ 类通常用关键字class定义。类是数据成员和成员函数的封装。类的实例称为对象。\n\nØ 结构类型用关键字struct定义，是由不同类型数据组成的数据类型。\n\nØ  类成员由private, protected, public决定访问特性。public成员集称为接口。\n\nØ  构造函数在创建和初始化对象时自动调用。析构函数则在对象作用域结束时自动调用。\n\nØ  重载构造函数和复制构造函数提供了创建对象的不同初始化方式。\n\nØ  静态成员是局部于类的成员，提供一种同类对象的共享机制。\n\nØ 友员用关键字friend声明。友员是对类操作的一种辅助手段。一个类的友员可以访问该类各种性质的成员**。**\n\nØ 链表是一种重要的动态数据结构，可以在程序运行时创建或撤消数据元素。\n\n**8****运算符重载**\n\n**8.1****概念**\n\n**什么是运算符重载**\n\n所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是”一名多用”。\n\n运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重载。例如，大 家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行加法运算，如5+8， 5.8 +3.67等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的， 但由于C++已经对运算符”+”进行了重载，所以就能适用于int, float, doUble类型的运算。\n\n又如”<<“是C++的位运算中的位移运算符（左移），但在输出操作中又是与流对 象cout 配合使用的流插入运算符，”>>“也是位移运算符(右移），但在输入操作中又是与流对象 cin 配合使用的流提取运算符。这就是运算符重载(operator overloading)。C++系统对”<<“和”>>“进行了重载，用户在不同的场合下使用它们时，作用是不同 的。对”<<“和”>>“的重载处理是放在头文件stream中的。因此，如果要在程序中用”<< “和”>>”作流插入运算符和流提取运算符，必须在本文件模块中包含头文件stream(当然还应当包括”using namespace std“)。\n\n现在要讨论的问题是：用户能否根据自己的需要对C++已提供的运算符进行重载，赋予它们新的含义，使之一名多用。？\n\n**运算符重载入门技术推演**\n\n1为什么会用运算符重载机制\n\n  用复数类举例\n\n//Complex c3 = c1 + c2;\n\n//原因 Complex是用户自定义类型，编译器根本不知道如何进行加减\n\n //编译器给提供了一种机制，让用户自己去完成，自定义类型的加减操作。。。。。\n\n //这个机制就是运算符重载机制\n\n2 运算符重载的本质是一个函数\n\n| \n\nclass Complex\n\n{\n\npublic:\n\n int a;\n\n int b;\n\n friend Complex operator+(Complex &c1, Complex &c2);\n\npublic:\n\n Complex(int a=0, int b=0)\n\n {\n\n this->a = a;\n\n this->b = b;\n\n }\n\npublic:\n\n void printCom()\n\n {\n\n cout<<a<<\" + \"<<b<<\"i \"<<endl;\n\n }\n\nprivate:\n\n};\n\n/*\n\nComplex myAdd(Complex &c1, Complex &c2)\n\n{\n\n Complex tmp(c1.a+ c2.a, c1.b + c2.b);\n\n return tmp;\n\n}\n\n*/\n\nComplex operator+(Complex &c1, Complex &c2)\n\n{\n\n Complex tmp(c1.a+ c2.a, c1.b + c2.b);\n\n return tmp;\n\n}\n\nvoid main()\n\n{\n\n Complex c1(1, 2), c2(3, 4);\n\n //Complex c3 = c1 + c2; //用户自定义类型 编译器无法让变量相加\n\n //Complex myAdd(Complex &c1, Complex &c2);\n\n //1 普通函数\n\n //Complex c3 = myAdd(c1, c2);\n\n //c3.printCom();\n\n //2 operator+ 函数名称\n\n //Complex c3 = operator+(c1, c2);\n\n //c3.printCom();\n\n //3 +替换 函数名\n\n Complex c3 = c1 + c2; **//****思考C++****编译器如何支持操作符重载机制的** (**根据类型**)\n\n c3.printCom();\n\n{\n\nint a =0, b = 0, c; //**基础类型C++****编译器知道如何加减**\n\nc = a +b;\n\n}\n\n //4 把Complex类变成私有属性\n\n //友元函数的应用场景\n\n //friend Complex operator+(Complex &c1, Complex &c2);\n\n cout<<\"hello...\"<<endl;\n\n system(\"pause\");\n\n return ;\n\n}\n\n |\n\n**8.2****运算符重载的限制**\n\n**8.3****运算符重载编程基础**\n\n例如:\n\n //全局函数  完成 +操作符  重载\n\nComplex operator+(Complex &c1, Complex &c2)\n\n//类成员函数  完成 -操作符  重载\n\nComplex operator-(Complex &c2)\n\n**运算符重载的两种方法**\n\n例如1:\n\n//通过类成员函数完成-操作符重载\n\n//函数声明 Complex operator-(Complex &c2)\n\n//函数调用分析\n\n//用类成员函数实现-运算符重载\n\n Complex c4 = c1 - c2;\n\n c4.printCom();\n\n //c1.operator-(c2);\n\n例如2:\n\n//通过全局函数方法完成+操作符重载\n\n//函数声明 Complex operator+(Complex &c1, Complex &c2)\n\n//函数调用分析\n\nint main()\n\n{\n\n Complex c1(1, 2), c2(3, 4);\n\n //Complex c31 = operator+(c1, c2);\n\nComplex c3 = c1 + c2;\n\nc3.printCom();\n\n}\n\n例如3: 学员自己练习  实现 * /\n\n例如3\n\n//前置++操作符 用全局函数实现\n\nComplex& operator++(Complex &c1)\n\n{\n\n c1.a ++;\n\n c1.b ++;\n\n return c1;\n\n}\n\n//调用方法\n\n ++c1 ; //=è需要写出操作符重载函数原形\n\n c1.printCom();\n\n//运算符重载函数名定义\n\n //首先承认操作符重载是一个函数 定义函数名èoperator++\n\n //分析函数参数 根据左右操作数的个数,èoperator++(Complex &c1)\n\n //分析函数返回值è Complex& operator++(Complex &c1) 返回它自身\n\n例如4\n\n//4.1前置—操作符 成员函数实现\n\nComplex& operator--()\n\n{\n\n this->a--;\n\n this->b--;\n\n return *this;\n\n}\n\n //4.2调用方法\n\n --c1;\n\n c1.printCom();\n\n //4.3前置—运算符重载函数名定义\n\n //c1.operator--()\n\n例如5\n\n //5.1 //后置++ 操作符 用全局函数实现\n\nComplex operator++(Complex &c1, int)\n\n{\n\n Complex tmp = c1;\n\n c1.a++;\n\n c1.b++;\n\n return tmp;\n\n}\n\n//5.2 调用方法\n\nc1 ++ ; //先使用 后++\n\n//5.3 后置++运算符重载函数名定义\n\n Complex operator++(Complex &c1, int) //函数占位参数 和 前置++ 相区别\n\n例如6\n\n//6.1 后置— 操作符 用类成员函数实现\n\n Complex operator--(int)\n\n {\n\n Complex tmp = *this;\n\n this->a--;\n\n this->b--;\n\n return tmp;\n\n }\n\n//6.2 调用方法\n\nc1 ++ ; //先使用 后++\n\n//6.3 后置--运算符重载函数名定义\n\n Complex operator--(int) //函数占位参数 和 前置-- 相区别\n\n前置和后置运算符总结\n\n**C++****中通过一个占位参数来区分前置运算和后置运算**\n\n**定义运算符重载函数名的步骤**\n\n全局函数、类成员函数方法实现运算符重载步骤\n\n 1）要承认操作符重载是一个函数，写出函数名称operator+ ()\n\n 2）根据操作数，写出函数参数\n\n 3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n\n**友元函数实现操作符重载的应用场景**\n\n**1****）友元函数和成员函数选择方法**\n\nØ 当无法修改左操作数的类时，使用全局函数进行重载\n\nØ =, [], ()和->操作符只能通过成员函数进行重载\n\n**2****）用友元函数** **重载 << >>****操作符**\n\nØ istream 和 ostream 是 C++ 的预定义流类\n\nØ cin 是 istream 的对象，cout 是 ostream 的对象\n\nØ 运算符 << 由ostream 重载为插入操作，用于输出基本类型数据\n\nØ 运算符 >> 由 istream 重载为提取操作，用于输入基本类型数据\n\nØ 用友员函数重载 << 和 >> ，输出和输入用户自定义的数据类型\n\na）用全局函数方法实现 << 操作符\n\nostream& operator<<(ostream &out, Complex &c1)\n\n{\n\n //out<<\"12345，生活真是苦\"<<endl;\n\n out<<c1.a<<\" + \"<<c1.b<<\"i \"<<endl;\n\n return out;\n\n}\n\n//调用方法\n\ncout<<c1;\n\n//链式编程支持\n\ncout<<c1<<\"abcc\";\n\n//cout.operator<<(c1).operator<<(\"abcd\");\n\n//函数返回值充当左值 需要返回一个引用\n\nb）类成员函数方法无法实现 << 操作符重载\n\n //因拿到cout这个类的源码\n\n //cout.operator<<(c1);\n\n**3）** **友元函数重载操作符使用注意点**\n\na） 友员函数重载运算符常用于运算符的左右操作数类型不同的情况\n\nb）其他\n\nØ 在第一个参数需要隐式转换的情形下，使用友员函数重载运算符是正确的选择\n\nØ  友员函数没有 this 指针，所需操作数都必须在参数表显式声明，很容易实现类型的隐式转换\n\nØ  C++中不能用友员函数重载的运算符有\n\n = （）  ［］  －>\n\n**4** **）友元函数案例vector****类**\n\n| \n\n#include <iostream>\n\nusing namespace std;\n\n//为vector类重载流插入运算符和提取运算符\n\nclass vector\n\n{\n\npublic :\n\n vector( int size =1 ) ;\n\n ~vector() ;\n\n int & operator[]( int i ) ;\n\n friend ostream & operator << ( ostream & output , vector & ) ;\n\n friend istream & operator >> ( istream & input, vector & ) ;\n\nprivate : \n\n int * v ;\n\n int len ;\n\n};\n\nvector::vector( int size )\n\n{\n\n if (size <= 0 || size > 100 )\n\n {\n\n cout << \"The size of \" << size << \" is null !\\n\" ; abort() ;\n\n }\n\n v = new int[ size ] ; len = size ;\n\n}\n\nvector :: ~vector()\n\n{\n\n delete[] v ;\n\n len = 0 ;\n\n}\n\nint &vector::operator[]( int i )                \n\n{\n\n if( i >=0 && i < len ) return v[ i ] ;\n\n cout << \"The subscript \" << i << \" is outside !\\n\" ; abort() ;\n\n}\n\nostream & operator << ( ostream & output, vector & ary )\n\n{\n\n for(int i = 0 ; i < ary.len ; i ++ )\n\n output << ary[ i ] << \" \" ;\n\n output << endl ;\n\n return output ;\n\n}\n\nistream & operator >> ( istream & input, vector & ary )\n\n{\n\n for( int i = 0 ; i < ary.len ; i ++ )\n\n input >> ary[ i ] ;\n\n return input ;\n\n}\n\nvoid main()\n\n{\n\n int k ;\n\n cout << \"Input the length of vector A :\\n\" ;\n\n cin >> k ;\n\n vector A( k ) ;\n\n cout << \"Input the elements of vector A :\\n\" ;\n\n cin >> A ;\n\n cout << \"Output the elements of vector A :\\n\" ;\n\n cout << A ;\n\n system(\"pause\");\n\n}\n\n |\n\n**8.4****运算符重载提高**\n\n**1****运算符重载机制**\n\nC++编译器是如何支持操作符重载机制的?\n\n**2****重载赋值运算符****=**\n\nØ 赋值运算符重载用于对象数据的复制\n\nØ operator= 必须重载为成员函数\n\nØ 重载函数原型为：\n\n  **_类型_ &** **_类名_ :: operator= ( const** **_类名_ & ) ;**\n\n案例：完善Name类，支持=号操作。\n\n  结论:\n\n 1 //先释放旧的内存\n\n 2 返回一个引用\n\n 3 =操作符 从右向左\n\n| \n\n //obj3 = obj1; // C++编译器提供的  等号操作  也属  浅拷贝\n\n// obj4 = obj3 = obj1\n\n //obj3.operator=(obj1)\n\n Name& operator=(Name &obj1)\n\n {\n\n //1 先释放obj3旧的内存\n\n if (this->m_p != NULL)\n\n {\n\n delete[] m_p;\n\n m_len = 0;\n\n }\n\n //2 根据obj1分配内存大小\n\n this->m_len = obj1.m_len;\n\n this->m_p = new char [m_len+1];\n\n //3把obj1赋值给obj3\n\n strcpy(m_p, obj1.m_p);\n\n return *this;\n\n }\n\n |\n\n**3****重载数组下表运算符****[]**\n\n重载[]和()运算符\n\nØ 运算符 [] 和 () 是二元运算符\n\nØ [] 和 () 只能用成员函数重载，不能用友元函数重载\n\n**_重载下标运算符 []_**\n\n[] 运算符用于访问数据对象的元素\n\n重载格式  _类型_ **_类_** :: operator[] ( _类型_ ) ；\n\n设 x 是类 X 的一个对象，则表达式\n\n **x [ y ]**\n\n  可被解释为\n\n **x . operator [ ] ( y )**\n\n**4****重载函数调用符** **()**\n\n() 运算符用于函数调用\n\n重载格式  _类型_ _类_ :: operator() ( _表达式表_ ) ；\n\n**_例1_**\n\n**设 x** **是类 X** **的一个对象，则表达式**\n\n **x ( arg1, arg2, … )**\n\n**可被解释为**\n\n **x . operator () (arg1, arg2, … )**\n\n案例：\n\n**_//_****_例2_****_：用重载()_****_运算符实现数学函数的抽象_**\n\n#include <iostream>\n\nclass F\n\n { public :\n\n double operator ( )  ( double x , double y ) ;\n\n } ;\n\ndouble F :: operator ( )  ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\nf.getA();\n\n cout << f ( 5.2 , 2.5 ) << endl ; // **f . _operator()_ (5.2, 2.5)**\n\n}\n\n比较普通成员函数\n\n**_//_****_例3_** **_用重载()_****_运算符实现 pk_** **_成员函数_**\n\n#include <iostream.h>\n\nclass F\n\n { public :\n\n double **memFun** ( double x , double y ) ;\n\n } ;\n\ndouble F :: **memFun** ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\n cout << f.**memFun** ( 5.2 , 2.5 ) << endl ;\n\n}\n\n**5****为什么不要重载****&&****和****||****操作符**\n\n理论知识：\n\n1）&&和||是C++中非常特殊的操作符\n\n2）&&和||内置实现了短路规则\n\n3）操作符重载是靠函数重载来完成的\n\n4）操作数作为函数参数传递\n\n5）C++的函数参数都会被求值，无法实现短路规则\n\n| \n\n#include <cstdlib>\n\n#include <iostream>\n\nusing namespace std;\n\nclass Test\n\n{\n\n int i;\n\npublic:\n\n Test(int i)\n\n {\n\n this->i = i;\n\n }\n\n Test operator+ (const Test& obj)\n\n {\n\n Test ret(0);\n\n cout<<\"执行+号重载函数\"<<endl;\n\n ret.i = i + obj.i;\n\n return ret;\n\n }\n\n bool operator&& (const Test& obj)\n\n {\n\n cout<<\"执行&&重载函数\"<<endl;\n\n return i && obj.i;\n\n }\n\n};\n\n// && 从左向右\n\nvoid main()\n\n{\n\n int a1 = 0;\n\n int a2 = 1;\n\n cout<<\"注意：&&操作符的结合顺序是从左向右\"<<endl;\n\n if( a1 && (a1 + a2) )\n\n {\n\n cout<<\"有一个是假，则不在执行下一个表达式的计算\"<<endl;\n\n }\n\n Test t1 = 0;\n\n Test t2 = 1;\n\n If ( t1 && (t1 + t2) )\n\n {\n\n=è\n\n T1.operator&&( t1 + t2) )\n\nT1.operator&&( t1.operator+(t2) )\n\n //t1 && t1.operator+(t2)\n\n // t1.operator( t1.operator(t2) )\n\n cout<<\"两个函数都被执行了，而且是先执行了+\"<<endl;\n\n }\n\n system(\"pause\");\n\n return ;\n\n}\n\n |\n|  |\n\n**8.5****运算符重载在项目开发中的应用**\n\n**1****实现一个数组类**\n\n添加<< >>\n\n**2****实现一个字符串类**\n\n构造函数要求\n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串类 以零结尾的字符串\n\n//若len为0,表示空串\n\nMyString a; //空串 “”\n\nMyString a(“dddd”);\n\nMyString b = a;\n\nb = “aaaaaa” \n\nb = a;\n\nif (a > b)\n\nif (a == b)\n\nb[i] = ‘a’;\n\n常用的操作符\n\n<< >> != == > < =\n\n| \n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串 以零结尾的字符串\n\nclass MyString\n\n{\n\n friend ostream& operator<<(ostream &out, const MyString &s);\n\npublic: //构造和析构\n\n MyString(int len = 0);\n\n MyString(const char *p);\n\n MyString(const MyString& obj);\n\n ~MyString();\n\npublic: //操作符重载\n\n MyString& operator=(const char *p);\n\n MyString& operator=(const MyString& obj);\n\n char& operator[](int index) const;\n\npublic:\n\n bool operator==(const char* p) const;\n\n bool operator!=(const char* p) const;\n\n bool operator==(const MyString& s) const;\n\n bool operator!=(const MyString& s) const;\n\npublic: //string to c\n\n char *c_str();\n\n const char* c_str() const;\n\n int length()\n\n {\n\n return m_len;\n\n }\n\npublic:\n\n int operator<(const char *p);\n\n int operator>(const char *p);\n\n int operator<(const MyString &s);\n\n int operator>(const MyString &s);\n\nprivate:\n\n int m_len;\n\n char  *m_p;\n\n};\n\n |\n\n**3****智能指针类编写**\n\n1问题抛出\n\n  指针使用过程中，经常会出现内存泄漏和内存多次被释放常\n\n2 解决方案：例如：boost库的智能指针\n\n  项目开发中，要求开发者使用预先编写的智能指针类对象代替C语言中的原生指针\n\n3 智能指针思想\n\n工程中的智能指针是一个类模板\n\n  通过构造函数接管申请的内存\n\n  通过析构函数确保堆内存被及时释放\n\n  通过重载指针运算符* 和 -> 来模拟指针的行为\n\n  通过重载比较运算符 == 和 != 来模拟指针的比较\n\n| \n\nclass Test\n\n{\n\npublic:\n\n Test()\n\n {\n\n this->a = 10;\n\n }\n\n void printT()\n\n {\n\n cout<<a<<endl;\n\n }\n\nprivate:\n\n int a;\n\n};\n\nclass MyTestPointer\n\n{\n\npublic:\n\npublic:\n\n MyTestPointer()\n\n {\n\n p = NULL;\n\n }\n\n MyTestPointer(Test* p)\n\n {\n\n this->p = p;\n\n }\n\n ~MyTestPointer()\n\n {\n\n delete p;\n\n }\n\n Test* operator->()\n\n {\n\n return p;\n\n }\n\n Test& operator*()\n\n {\n\n return *p;\n\n }\n\nprotected:\n\n Test *p;\n\n};\n\nvoid main01_classp()\n\n{\n\n Test *p = new Test;\n\n p->printT();\n\n delete p;\n\n MyTestPointer myp = new Test; //构造函数\n\n myp->printT(); //重载操作符 ->\n\n};\n\n |\n\n| \n\nclass MyIntPointer\n\n{\n\npublic:\n\npublic:\n\n MyIntPointer()\n\n {\n\n p = NULL;\n\n }\n\n MyIntPointer(int* p)\n\n {\n\n this->p = p;\n\n }\n\n ~MyIntPointer()\n\n {\n\n delete p;\n\n }\n\n int* operator->()\n\n {\n\n return p;\n\n }\n\n int& operator*()\n\n {\n\n return *p;\n\n }\n\nprotected:\n\n int *p;\n\n};\n\nvoid main02_intp()\n\n{\n\n int *p = new int(100);\n\n cout<<*p<<endl;\n\n delete p;\n\n MyIntPointer myp = new int(200);\n\n cout<<*myp<<endl; //重载*操作符\n\n};\n\n |\n\n**8.7****附录：运算符和结合性**\n\n总结\n\n操作符重载是C++的强大特性之一\n\n操作符重载的本质是通过函数扩展操作符的语义\n\noperator关键字是操作符重载的关键\n\nfriend关键字可以对函数或类开发访问权限\n\n操作符重载遵循函数重载的规则\n\n操作符重载可以直接使用类的成员函数实现\n\n=, [], ()和->操作符只能通过成员函数进行重载\n\n++操作符通过一个int参数进行前置与后置的重载\n\nC++中不要重载&&和||操作符\n\n\n\n\n\n\n\n\n\n\n\n",[[1543540115381,["gjx16@GJXAIOU",[[-1,37263,"| \n\n#ifndef _MYARRAY_H_\n\n#define _MYARRAY_H_\n\nclass Array\n\n{\n\nprivate:\n\n int mLength;\n\nint* mSpace;\n\npublic:\n\n Array(int length);\n\n Array(const Array& obj);\n\n int length();\n\n void setData(int index, int value);\n\n int getData(int index);\n\n ~Array();\n\n};\n\n#endif\n\n |\n"]],[37263,37528],[37263,37263]]],[1543540120541,["gjx16@GJXAIOU",[[1,37263,"```"]],[37263,37263],[37266,37266]]],[1543540121072,["gjx16@GJXAIOU",[[1,37266,"language\n```\n"]],[37266,37266],[37266,37274]]],[1543540122816,["gjx16@GJXAIOU",[[-1,37266,"language"],[1,37274,"c"]],[37266,37274],[37267,37267]]],[1543540123895,["gjx16@GJXAIOU",[[1,37267,"pp"]],[37267,37267],[37269,37269]]],[1543540124455,["gjx16@GJXAIOU",[[1,37270,"\n"]],[37269,37269],[37270,37270]]],[1543540125485,["gjx16@GJXAIOU",[[1,37270,"#pragma once\nclass Array\n{\npublic:\n\tArray(int length);\n\tArray(const Array&obj);\n\t~Array();\npublic:\n\tint length();\n\n\tvoid setData(int index, int value);\n\n\tint getData(int index);\nprivate:\n\tint m_length;\n\tchar *m_space;\n};"]],[37270,37270],[37490,37490]]],[1543540136486,["gjx16@GJXAIOU",[[-1,36860,"| \n\n#include \"iostream\"\n\n#include \"Array.h\"\n\nusing namespace std;\n\nint main()\n\n{\n\n Array a1(10);\n\n for(int i=0; i<a1.length(); i++)\n\n {\n\n a1.setData(i, i);\n\n }\n\n for(int i=0; i<a1.length(); i++)\n\n {\n\n printf(\"array %d: %d\\n\", i, a1.getData(i));\n\n }\n\n Array a2 = a1;\n\n for(int i=0; i<a2.length(); i++)\n\n {\n\n printf(\"array %d: %d\\n\", i, a2.getData(i));\n\n }\n\n system(\"pause\");\n\n return 0;\n\n}\n\n |\n"]],[36860,37253],[36860,36860]]],[1543540140528,["gjx16@GJXAIOU",[[-1,36860,"\n"]],[36860,36860],[36859,36859]]],[1543540143530,["gjx16@GJXAIOU",[[-1,36852,"数组类的测试"]],[36852,36858],[36852,36852]]],[1543540147746,["gjx16@GJXAIOU",[[1,37096,"\n"]],[37094,37094],[37095,37095]]],[1543540148843,["gjx16@GJXAIOU",[[1,37097,"\n"]],[37095,37095],[37096,37096]]],[1543540149393,["gjx16@GJXAIOU",[[1,37098,"\n"]],[37096,37096],[37097,37097]]],[1543540149956,["gjx16@GJXAIOU",[[1,37097,"数组类的测试"]],[37097,37097],[37103,37103]]],[1543540152236,["gjx16@GJXAIOU",[[1,37097,"\n"]],[37095,37095],[37096,37096]]],[1543540154162,["gjx16@GJXAIOU",[[1,37096,"shu"]],[37096,37096],[37099,37099]]],[1543540162273,["gjx16@GJXAIOU",[[-1,37096,"shuzu"]],[37101,37101],[37096,37096]]],[1543540166925,["gjx16@GJXAIOU",[[1,37096,"书序"]],[37096,37096],[37098,37098]]],[1543540169250,["gjx16@GJXAIOU",[[-1,37096,"书序"]],[37098,37098],[37096,37096]]],[1543540172907,["gjx16@GJXAIOU",[[1,37096,"书序类的"]],[37096,37096],[37100,37100]]],[1543540176799,["gjx16@GJXAIOU",[[-1,37096,"书序类的"]],[37100,37100],[37096,37096]]],[1543540178378,["gjx16@GJXAIOU",[[1,37096,"书序"]],[37096,37096],[37098,37098]]],[1543540180071,["gjx16@GJXAIOU",[[-1,37096,"书序"]],[37098,37098],[37096,37096]]],[1543540190967,["gjx16@GJXAIOU",[[1,37096,"数组类的头文件的实现："]],[37096,37096],[37107,37107]]],[1543540191531,["gjx16@GJXAIOU",[[1,37109,"\n"]],[37107,37107],[37108,37108]]],[1543540194118,["gjx16@GJXAIOU",[[1,37108,"```"]],[37108,37108],[37111,37111]]],[1543540194521,["gjx16@GJXAIOU",[[1,37111,"language\n```\n"]],[37111,37111],[37111,37119]]],[1543540195234,["gjx16@GJXAIOU",[[-1,37111,"language"],[1,37119,"c"]],[37111,37119],[37112,37112]]],[1543540196945,["gjx16@GJXAIOU",[[1,37112,"ppp"]],[37112,37112],[37115,37115]]],[1543540197479,["gjx16@GJXAIOU",[[1,37116,"\n"]],[37115,37115],[37116,37116]]],[1543540212039,["gjx16@GJXAIOU",[[1,37116,"#include \"Array.h\"\nusing namespace std;\n#include\"iostream\"\n\nArray::Array(int length)\n{\n\tif (length < 0)\n\t{\n\t\tm_length = 0;\n\t}\n\telse\n\t{\n\t\tm_length = length;\n\t\tm_space = new char[m_length];\n\t}\n}\n\nArray::Array(const Array&obj)\n{\n\n}\n\nArray::~Array()\n{\n\tif (m_space != NULL)\n\t{\n\t\tdelete[] m_space;\n\t\tm_length = 0;\n\t}\n}\n\nvoid Array::setData(int index, int valude)\n{\n\tm_space[index] = valude;\n}\n\nint Array::getData(int index)\n{\n\treturn m_space[index];\n}\n\nint Array::length()\n{\n\treturn m_length; \n}"]],[37116,37116],[37606,37606]]],[1543540275141,[null,[[-1,37107,"数"],[1,37108,"\n"],[-1,37611,"组\n"],[1,37613,"\n\n数组"]],[37107,37107],[37617,37617]]],[1543540275141,[null,[[1,37107,"数"],[-1,37107,"\n"],[1,37611,"组\n"],[-1,37611,"\n\n数组"]],[37617,37617],[37107,37107]]],[1543540216466,["gjx16@GJXAIOU",[[-1,37612,"\n"]],[37612,37612],[37611,37611]]],[1543540221541,["gjx16@GJXAIOU",[[1,37619,"···"]],[37619,37619],[37622,37622]]],[1543540222969,["gjx16@GJXAIOU",[[-1,37620,"··"]],[37622,37622],[37620,37620]]],[1543540225001,["gjx16@GJXAIOU",[[1,37620,"```"]],[37620,37620],[37623,37623]]],[1543540228881,["gjx16@GJXAIOU",[[-1,37619,"·```"]],[37623,37623],[37619,37619]]],[1543540231818,["gjx16@GJXAIOU",[[1,37619,"```"]],[37619,37619],[37622,37622]]],[1543540232320,["gjx16@GJXAIOU",[[1,37622,"language\n```\n"]],[37622,37622],[37622,37630]]],[1543540233329,["gjx16@GJXAIOU",[[-1,37622,"language"],[1,37630,"c"]],[37622,37630],[37623,37623]]],[1543540234414,["gjx16@GJXAIOU",[[1,37623,"pp"]],[37623,37623],[37625,37625]]],[1543540235061,["gjx16@GJXAIOU",[[1,37626,"\n"]],[37625,37625],[37626,37626]]],[1543540248286,["gjx16@GJXAIOU",[[1,37626,"#include \"iostream\"\n\n#include \"Array.h\"\n\nusing namespace std;\n\nint main()\n\n{\n\n\tArray a1(10);\n\n\tfor (int i = 0; i < a1.length(); i++)\n\n\t{\n\n\t\ta1.setData(i, i);\n\n\t}\n\n\tfor (int i = 0; i < a1.length(); i++)\n\n\t{\n\n\t\tprintf(\"array %d: %d\\n\", i, a1.getData(i));\n\n\t}\n\n\tArray a2 = a1;\n\n\tfor (int i = 0; i < a2.length(); i++)\n\n\t{\n\n\t\tprintf(\"array %d: %d\\n\", i, a2.getData(i));\n\n\t}\n\n\tsystem(\"pause\");\n\n\treturn 0;\n\n}"]],[37626,37626],[38028,38028]]],[1543540250919,["gjx16@GJXAIOU",[[-1,37666,"\n"]],[37666,37666],[37665,37665]]],[1543540252248,["gjx16@GJXAIOU",[[-1,37646,"\n"]],[37646,37646],[37645,37645]]],[1543540253935,["gjx16@GJXAIOU",[[-1,37698,"\n"]],[37698,37698],[37697,37697]]],[1543540256216,["gjx16@GJXAIOU",[[-1,37700,"\n"]],[37700,37700],[37699,37699]]],[1543540257446,["gjx16@GJXAIOU",[[-1,37715,"\n"]],[37715,37715],[37714,37714]]],[1543540258782,["gjx16@GJXAIOU",[[-1,37754,"\n"]],[37754,37754],[37753,37753]]],[1543540260046,["gjx16@GJXAIOU",[[-1,37757,"\n"]],[37757,37757],[37756,37756]]],[1543540261859,["gjx16@GJXAIOU",[[-1,37777,"\n"]],[37777,37777],[37776,37776]]],[1543540263154,["gjx16@GJXAIOU",[[-1,37780,"\n"]],[37780,37780],[37779,37779]]],[1543540264512,["gjx16@GJXAIOU",[[-1,37819,"\n"]],[37819,37819],[37818,37818]]],[1543540266545,["gjx16@GJXAIOU",[[-1,37822,"\n"]],[37822,37822],[37821,37821]]],[1543540267950,["gjx16@GJXAIOU",[[-1,37868,"\n"]],[37868,37868],[37867,37867]]],[1543540271064,["gjx16@GJXAIOU",[[-1,37928,"\n"]],[37928,37928],[37927,37927]]],[1543540273159,["gjx16@GJXAIOU",[[-1,37931,"\n"]],[37931,37931],[37930,37930]]],[1543540274318,["gjx16@GJXAIOU",[[-1,37977,"\n"]],[37977,37977],[37976,37976]]],[1543540335130,[null,[[-1,37107,"数"],[1,37108,"\n"],[1,37611,"\n数"],[-1,37617,"\n*"],[1,38018,"\n*"]],[37107,37107],[38020,38020]]],[1543540335130,[null,[[1,37107,"数"],[-1,37107,"\n"],[-1,37611,"\n数"],[1,37619,"\n*"],[-1,38018,"\n*"]],[38020,38020],[37107,37107]]],[1543540275582,["gjx16@GJXAIOU",[[-1,37980,"\n"]],[37980,37980],[37979,37979]]],[1543540276829,["gjx16@GJXAIOU",[[-1,37998,"\n"]],[37998,37998],[37997,37997]]],[1543540278126,["gjx16@GJXAIOU",[[-1,38009,"\n"]],[38009,38009],[38008,38008]]],[1543540395140,[null,[[-1,37107,"数"],[1,37108,"\n"],[1,37611,"\n数"],[-1,37617,"\n*"],[1,38015,"\n*"]],[37107,37107],[38017,38017]]],[1543540395140,[null,[[1,37107,"数"],[-1,37107,"\n"],[-1,37611,"\n数"],[1,37619,"\n*"],[-1,38015,"\n*"]],[38017,38017],[37107,37107]]],[1543540389729,["gjx16@GJXAIOU",[[1,37801," "]],[37800,37800],[37801,37801]]],[1543540515140,[null,[[-1,37107,"数"],[1,37108,"\n"],[1,37611,"\n数"],[-1,37617,"\n*"],[1,38016,"\n*"]],[37107,37107],[38018,38018]]],[1543540515140,[null,[[1,37107,"数"],[-1,37107,"\n"],[-1,37611,"\n数"],[1,37619,"\n*"],[-1,38016,"\n*"]],[38018,38018],[37107,37107]]],[1543540484056,["gjx16@GJXAIOU",[[1,37342,"   "]],[37342,37342],[37345,37345]]],[1543540575134,[null,[[-1,37107,"数"],[1,37108,"\n"],[1,37614,"\n数"],[-1,37620,"\n*"],[1,38019,"\n*"]],[37107,37107],[38021,38021]]],[1543540575134,[null,[[1,37107,"数"],[-1,37107,"\n"],[-1,37614,"\n数"],[1,37622,"\n*"],[-1,38019,"\n*"]],[38021,38021],[37107,37107]]],[1543540546461,["gjx16@GJXAIOU",[[1,37345,"this->m_legth = obj.m_length;"]],[37345,37345],[37374,37374]]],[1543540551689,["gjx16@GJXAIOU",[[1,37355,"n"]],[37355,37355],[37356,37356]]],[1543540558242,["gjx16@GJXAIOU",[[1,37376,"   \n"]],[37375,37375],[37379,37379]]],[1543540565025,["gjx16@GJXAIOU",[[1,37379,"this ->"]],[37379,37379],[37386,37386]]],[1543540569006,["gjx16@GJXAIOU",[[-1,37383," ->"]],[37386,37386],[37383,37383]]],[1543540571087,["gjx16@GJXAIOU",[[1,37383,"->"]],[37383,37383],[37385,37385]]],[1543540635139,[null,[[-1,37107,"数"],[1,37108,"\n"],[1,37654,"\n数"],[-1,37660,"\n*"],[1,38059,"\n*"]],[37107,37107],[38061,38061]]],[1543540635139,[null,[[1,37107,"数"],[-1,37107,"\n"],[-1,37654,"\n数"],[1,37662,"\n*"],[-1,38059,"\n*"]],[38061,38061],[37107,37107]]],[1543540601699,["gjx16@GJXAIOU",[[1,37385,"m_space = new ingt[this->m_length]"]],[37385,37385],[37419,37419]]],[1543540605709,["gjx16@GJXAIOU",[[-1,37401,"gt"]],[37403,37403],[37401,37401]]],[1543540607409,["gjx16@GJXAIOU",[[1,37401,"t"]],[37401,37401],[37402,37402]]],[1543540620061,["gjx16@GJXAIOU",[[1,37418,";//jin"]],[37418,37418],[37424,37424]]],[1543540621701,["gjx16@GJXAIOU",[[-1,37421,"jin"]],[37424,37424],[37421,37421]]],[1543540624524,["gjx16@GJXAIOU",[[1,37421,"进行裴斐"]],[37421,37421],[37425,37425]]],[1543540626653,["gjx16@GJXAIOU",[[-1,37423,"裴斐"]],[37425,37425],[37423,37423]]],[1543540629082,["gjx16@GJXAIOU",[[1,37423,"分配"]],[37423,37423],[37425,37425]]],[1543540695143,[null,[[-1,37107,"数"],[1,37108,"\n"],[1,37694,"\n数"],[-1,37700,"\n*"],[1,38099,"\n*"]],[37107,37107],[38101,38101]]],[1543540695143,[null,[[1,37107,"数"],[-1,37107,"\n"],[-1,37694,"\n数"],[1,37702,"\n*"],[-1,38099,"\n*"]],[38101,38101],[37107,37107]]],[1543540636342,["gjx16@GJXAIOU",[[1,37425,"内存空间"]],[37425,37425],[37429,37429]]],[1543540637729,["gjx16@GJXAIOU",[[1,37430,"   \n"]],[37429,37429],[37433,37433]]],[1543540639617,["gjx16@GJXAIOU",[[-1,37430,"   "],[1,37433,"\n"]],[37433,37433],[37431,37431]]],[1543540643027,["gjx16@GJXAIOU",[[1,37431,"for()"]],[37431,37431],[37436,37436]]],[1543540646477,["gjx16@GJXAIOU",[[1,37435,"int  "]],[37435,37435],[37440,37440]]],[1543540646992,["gjx16@GJXAIOU",[[-1,37439," "]],[37440,37440],[37439,37439]]],[1543540658384,["gjx16@GJXAIOU",[[1,37439,"i= 0; i < obj.n"]],[37439,37439],[37454,37454]]],[1543540658951,["gjx16@GJXAIOU",[[-1,37453,"n"]],[37454,37454],[37453,37453]]],[1543540671514,["gjx16@GJXAIOU",[[1,37453,"m_length;i++"]],[37453,37453],[37465,37465]]],[1543540678064,["gjx16@GJXAIOU",[[1,37467,"\n"]],[37466,37466],[37467,37467]]],[1543540680047,["gjx16@GJXAIOU",[[1,37467,"{"]],[37467,37467],[37468,37468]]],[1543540680602,["gjx16@GJXAIOU",[[1,37469,"\n"]],[37468,37468],[37469,37469]]],[1543540682695,["gjx16@GJXAIOU",[[1,37469,"}"]],[37469,37469],[37470,37470]]],[1543540685344,["gjx16@GJXAIOU",[[1,37467,"\n"]],[37467,37467],[37468,37468]]],[1543540687015,["gjx16@GJXAIOU",[[-1,37467,"\n"]],[37468,37468],[37467,37467]]],[1543540688737,["gjx16@GJXAIOU",[[1,37469,"\n"]],[37468,37468],[37469,37469]]],[1543540691571,["gjx16@GJXAIOU",[[1,37431,"  "]],[37431,37431],[37433,37433]]],[1543540693273,["gjx16@GJXAIOU",[[1,37469,"  "]],[37469,37469],[37471,37471]]],[1543540756734,[null,[[-1,37107,"数"],[1,37108,"\n"],[1,37744,"\n数"],[-1,37750,"\n*"],[1,38149,"\n*"]],[37107,37107],[38151,38151]]],[1543540756734,[null,[[1,37107,"数"],[-1,37107,"\n"],[-1,37744,"\n数"],[1,37752,"\n*"],[-1,38149,"\n*"]],[38151,38151],[37107,37107]]],[1543540703178,["gjx16@GJXAIOU",[[1,37474,"  "]],[37474,37474],[37476,37476]]],[1543540755888,["gjx16@GJXAIOU",[[1,37473,"    this ->m_space[i] = obj.m_space{"]],[37473,37473],[37509,37509]]],[1543540816727,[null,[[-1,37107,"数"],[1,37108,"\n"],[1,37782,"\n数"],[-1,37788,"\n*"],[1,38187,"\n*"]],[37107,37107],[38189,38189]]],[1543540816727,[null,[[1,37107,"数"],[-1,37107,"\n"],[-1,37782,"\n数"],[1,37790,"\n*"],[-1,38187,"\n*"]],[38189,38189],[37107,37107]]],[1543540757206,["gjx16@GJXAIOU",[[-1,37508,"{"]],[37509,37509],[37508,37508]]],[1543540760258,["gjx16@GJXAIOU",[[1,37508,"[i];"]],[37508,37508],[37512,37512]]],[1543540767350,["gjx16@GJXAIOU",[[-1,37481," "]],[37482,37482],[37481,37481]]],[1543540876721,[null,[[-1,37107,"数"],[1,37108,"\n"],[1,37784,"\n数"],[-1,37790,"\n*"],[1,38189,"\n*"]],[37107,37107],[38191,38191]]],[1543540876721,[null,[[1,37107,"数"],[-1,37107,"\n"],[-1,37784,"\n数"],[1,37792,"\n*"],[-1,38189,"\n*"]],[38191,38191],[37107,37107]]],[1543540839586,["gjx16@GJXAIOU",[[-1,37399,"int"]],[37402,37402],[37399,37399]]],[1543540842441,["gjx16@GJXAIOU",[[1,37399,"char"]],[37399,37399],[37403,37403]]],[1543540996741,[null,[[-1,37107,"数"],[1,37108,"\n"],[1,37785,"\n数"],[-1,37791,"\n*"],[1,38190,"\n*"]],[37107,37107],[38192,38192]]],[1543540996741,[null,[[1,37107,"数"],[-1,37107,"\n"],[-1,37785,"\n数"],[1,37793,"\n*"],[-1,38190,"\n*"]],[38192,38192],[37107,37107]]],[1543540983852,["gjx16@GJXAIOU",[[1,37403," "]],[37403,37403],[37404,37404]]],[1543541057228,[null,[[-1,37107,"数"],[1,37108,"\n"],[1,37786,"\n数"],[-1,37792,"\n*"],[1,38191,"\n*"]],[37107,37107],[38193,38193]]],[1543541057228,[null,[[1,37107,"数"],[-1,37107,"\n"],[-1,37786,"\n数"],[1,37794,"\n*"],[-1,38191,"\n*"]],[38193,38193],[37107,37107]]],[1543541056252,["gjx16@GJXAIOU",[[1,37470,"//数组元素复制， 这里的obj."]],[37470,37470],[37487,37487]]],[1543541117214,[null,[[-1,37107,"数"],[1,37108,"\n"],[1,37803,"\n数"],[-1,37809,"\n*"],[1,38208,"\n*"]],[37107,37107],[38210,38210]]],[1543541117214,[null,[[1,37107,"数"],[-1,37107,"\n"],[-1,37803,"\n数"],[1,37811,"\n*"],[-1,38208,"\n*"]],[38210,38210],[37107,37107]]],[1543541061913,["gjx16@GJXAIOU",[[1,37490,"ength"]],[37490,37490],[37495,37495]]],[1543541067788,["gjx16@GJXAIOU",[[-1,37487,"M-"]],[37489,37489],[37487,37487]]],[1543541069315,["gjx16@GJXAIOU",[[1,37487,"m_"]],[37487,37487],[37489,37489]]],[1543541073111,["gjx16@GJXAIOU",[[1,37495,"k"]],[37495,37495],[37496,37496]]],[1543541073675,["gjx16@GJXAIOU",[[-1,37495,"k"]],[37496,37496],[37495,37495]]],[1543541084103,["gjx16@GJXAIOU",[[1,37495,"可以直接替换成m_length"]],[37495,37495],[37510,37510]]],[1543541177235,[null,[[-1,37107,"数"],[1,37108,"\n"],[-1,37489," "],[1,37490,"l"],[1,37510,"\n  "],[1,37823,"\n数"],[-1,37829,"\n*"],[1,38228,"\n*"]],[37107,37107],[38230,38230]]],[1543541177235,[null,[[1,37107,"数"],[-1,37107,"\n"],[1,37489," "],[-1,37489,"l"],[-1,37510,"\n  "],[-1,37826,"\n数"],[1,37834,"\n*"],[-1,38231,"\n*"]],[38230,38230],[37107,37107]]],[1543541138837,["gjx16@GJXAIOU",[[-1,37225,"m_"]],[37227,37227],[37225,37225]]],[1543541237216,[null,[[-1,37107,"数"],[1,37108,"\n"],[-1,37487," "],[1,37488,"l"],[1,37508,"\n  "],[1,37821,"\n数"],[-1,37827,"\n*"],[1,38226,"\n*"]],[37107,37107],[38228,38228]]],[1543541237216,[null,[[1,37107,"数"],[-1,37107,"\n"],[1,37487," "],[-1,37487,"l"],[-1,37508,"\n  "],[-1,37824,"\n数"],[1,37832,"\n*"],[-1,38229,"\n*"]],[38228,38228],[37107,37107]]],[1543541210344,["gjx16@GJXAIOU",[[1,34758,"\n"]],[34757,34757],[34758,34758]]],[1543541210971,["gjx16@GJXAIOU",[[1,34759,"\n"]],[34758,34758],[34759,34759]]],[1543541211504,["gjx16@GJXAIOU",[[1,34760,"\n"]],[34759,34759],[34760,34760]]],[1543541213407,["gjx16@GJXAIOU",[[1,34760,"---"]],[34760,34760],[34763,34763]]],[1543541213968,["gjx16@GJXAIOU",[[1,34764,"\n"]],[34763,34763],[34764,34764]]],[1543542737848,[null,[[-1,37114,"数"],[1,37115,"\n"],[-1,37494," "],[1,37495,"l"],[1,37515,"\n  "],[1,37828,"\n数"],[-1,37834,"\n*"],[1,38233,"\n*"]],[37114,37114],[38235,38235]]],[1543542737848,[null,[[1,37114,"数"],[-1,37114,"\n"],[1,37494," "],[-1,37494,"l"],[-1,37515,"\n  "],[-1,37831,"\n数"],[1,37839,"\n*"],[-1,38236,"\n*"]],[38235,38235],[37114,37114]]],[1543542679208,["gjx16@GJXAIOU",[[-1,34809,"例如\n\nclass A1\n\n{\n\npublic:\n\n A1()\n\n {\n\n a1 = 100;\n\n a2 = 200;\n\n }\n\n int getA1()\n\n {\n\n return this->a1;\n\n }\n\n //声明一个友元函数\n\n friend void setA1(A1 *p, int a1); //这个函数是这个类的好朋友\n\nprotected:\n\nprivate:\n\n int a1;\n\n int a2;\n\n};\n\nvoid setA1(A1 *p, int a1)\n\n{\n\n p->a1 = a1;\n\n}\n\nvoid main()\n\n{\n\n A1 mya1;\n\n cout<<mya1.getA1()<<endl;\n\n setA1(&mya1, 300); //通过友元函数 修改A类的私有属性\n\n cout<<mya1.getA1()<<endl;\n\n system(\"pause\");\n\n}\n"]],[34809,35216],[34809,34809]]],[1543542685896,["gjx16@GJXAIOU",[[1,34809,"```cpp"]],[34809,34809],[34815,34815]]],[1543542686480,["gjx16@GJXAIOU",[[1,34816,"\n"]],[34815,34815],[34816,34816]]],[1543542687624,["gjx16@GJXAIOU",[[1,34817,"\n"]],[34816,34816],[34817,34817]]],[1543542689793,["gjx16@GJXAIOU",[[1,34817,"```"]],[34817,34817],[34820,34820]]],[1543542692355,["gjx16@GJXAIOU",[[1,34816,"//友元函数：\n\n//首先友元函数是全局函数，在友元函数中可以修改类的私有属性\n//友元函数在类中的声明位置位于public或者private只下均可；\n\n#include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend void modify(A *PA,int _a);  //友元函数的声明\n\n\tA(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\n\nprivate:\n\tint a;\n\tint b;\n};\n\nvoid modify(A *PA,int _a)//后面的参数可加可不加\n{\n\t//PA->a = 100;//可以这样直接修改值\n\tPA->a = _a;  //通过传递的值进行修改\n}\n\n\nint main()\n{\n\tA a1(1, 2);\n\tcout << \"a:\" << a1.getA() << endl;\n\tmodify(&a1,20);\n\n\tint aa = a1.getA();\n\n\tcout << \"aa:\" << aa << endl;\n}"]],[34816,34816],[35353,35353]]],[1543544568768,[null,[[-1,37255,"数"],[1,37256,"\n"],[-1,37635," "],[1,37636,"l"],[1,37656,"\n  "],[1,37969,"\n数"],[-1,37975,"\n*"],[1,38374,"\n*"]],[37255,37255],[38376,38376]]],[1543544568768,[null,[[1,37255,"数"],[-1,37255,"\n"],[1,37635," "],[-1,37635,"l"],[-1,37656,"\n  "],[-1,37972,"\n数"],[1,37980,"\n*"],[-1,38377,"\n*"]],[38376,38376],[37255,37255]]],[1543544542571,["gjx16@GJXAIOU",[[1,35459,"```cpp"]],[35459,35459],[35465,35465]]],[1543544543153,["gjx16@GJXAIOU",[[1,35466,"\n"]],[35465,35465],[35466,35466]]],[1543544543714,["gjx16@GJXAIOU",[[1,35467,"\n"]],[35466,35466],[35467,35467]]],[1543544544260,["gjx16@GJXAIOU",[[1,35468,"\n"]],[35467,35467],[35468,35468]]],[1543544546436,["gjx16@GJXAIOU",[[1,35468,"```"]],[35468,35468],[35471,35471]]],[1543544549404,["gjx16@GJXAIOU",[[1,35466,"//友元类\n #include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend class B;//将B 声明为A的友元类，这样B 可以直接修改A的成员变量和成员函数 \n\n\tA(int a=0, int b=0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B\n{\npublic:\n\n\tvoid set(int a)\n\t{\n\t\tobjA.a = a;\n\t}\n\n\tvoid printa()\n\t{\n\t\tcout << objA.a << endl;\n\t}\n\nprivate:\n\tA objA;\n};\n\n\nint main()\n{\n\tB b1;\n\tb1.set(200);\n\tb1.printa();\n\tsystem(\"pause\");\n\treturn 0;\n}\n"]],[35466,35466],[35919,35919]]],[1543544559380,["gjx16@GJXAIOU",[[-1,35920,"\n"]],[35920,35920],[35919,35919]]],[1543544560331,["gjx16@GJXAIOU",[[-1,35919,"\n"]],[35919,35919],[35918,35918]]],[1543544562609,["gjx16@GJXAIOU",[[1,35923,"\n"]],[35922,35922],[35923,35923]]],[1543544567468,["gjx16@GJXAIOU",[[1,35923,"chengxu "]],[35923,35923],[35931,35931]]],[1543544628752,[null,[[-1,37727,"数"],[1,37728,"\n"],[-1,38107," "],[1,38108,"l"],[1,38128,"\n  "],[1,38441,"\n数"],[-1,38447,"\n*"],[1,38846,"\n*"]],[37727,37727],[38848,38848]]],[1543544628752,[null,[[1,37727,"数"],[-1,37727,"\n"],[1,38107," "],[-1,38107,"l"],[-1,38128,"\n  "],[-1,38444,"\n数"],[1,38452,"\n*"],[-1,38849,"\n*"]],[38848,38848],[37727,37727]]],[1543544575760,["gjx16@GJXAIOU",[[-1,35923,"che"]],[35926,35926],[35923,35923]]],[1543544579765,["gjx16@GJXAIOU",[[1,35923,"程序运行耳机有"]],[35923,35923],[35930,35930]]],[1543544582315,["gjx16@GJXAIOU",[[-1,35927,"耳机有"]],[35930,35930],[35927,35927]]],[1543544584931,["gjx16@GJXAIOU",[[1,35927,"结果；"]],[35927,35927],[35930,35930]]],[1543544586420,["gjx16@GJXAIOU",[[-1,35929,"；"]],[35930,35930],[35929,35929]]],[1543544590329,["gjx16@GJXAIOU",[[1,35929,"：200"]],[35929,35929],[35933,35933]]],[1543544595177,["gjx16@GJXAIOU",[[1,35934,"\n"]],[35933,35933],[35934,35934]]],[1543544751064,[null,[[-1,35933,"n"],[-1,35935,"gxu "],[-1,37735,"数"],[1,37736,"\n"],[-1,38115," "],[1,38116,"l"],[1,38136,"\n  "],[1,38449,"\n数"],[-1,38455,"\n*"],[1,38854,"\n*"]],[35933,35933],[38856,38856]]],[1543544751064,[null,[[1,35933,"n"],[1,35934,"gxu "],[1,37730,"数"],[-1,37730,"\n"],[1,38110," "],[-1,38110,"l"],[-1,38131,"\n  "],[-1,38447,"\n数"],[1,38455,"\n*"],[-1,38852,"\n*"]],[38856,38856],[35933,35933]]],[1543544701230,["gjx16@GJXAIOU",[[-1,35983,"****"]],[35987,35987],[35983,35983]]],[1543544714274,["gjx16@GJXAIOU",[[1,39202,"\n"]],[39201,39201],[39202,39202]]],[1543544714834,["gjx16@GJXAIOU",[[1,39203,"\n"]],[39202,39202],[39203,39203]]],[1543544715353,["gjx16@GJXAIOU",[[1,39204,"\n"]],[39203,39203],[39204,39204]]],[1543544715907,["gjx16@GJXAIOU",[[1,39205,"\n"]],[39204,39204],[39205,39205]]],[1543544716456,["gjx16@GJXAIOU",[[1,39206,"\n"]],[39205,39205],[39206,39206]]],[1543544725043,["gjx16@GJXAIOU",[[1,39204,"---"]],[39204,39204],[39207,39207]]],[1543544730710,["gjx16@GJXAIOU",[[-1,39210,"**8****"],[1,39217,"#"]],[39210,39210],[39211,39211]]],[1543544732168,["gjx16@GJXAIOU",[[1,39211,"##"]],[39211,39211],[39213,39213]]],[1543544735707,["gjx16@GJXAIOU",[[-1,39212,"#"]],[39213,39213],[39212,39212]]],[1543544739889,["gjx16@GJXAIOU",[[1,39212," 八、"]],[39212,39212],[39215,39215]]],[1543544743359,["gjx16@GJXAIOU",[[-1,39220,"**"]],[39222,39222],[39220,39220]]],[1543544747910,["gjx16@GJXAIOU",[[-1,39221,"\n**8.1****概念**"],[1,39235,"#"]],[39221,39221],[39222,39222]]],[1543544750192,["gjx16@GJXAIOU",[[1,39222,"### "]],[39222,39222],[39226,39226]]],[1543544812255,[null,[[-1,35933,"n"],[-1,35935,"gxu "],[1,35983,"tati"],[-1,35984,"****"],[-1,37731,"数"],[1,37732,"\n"],[-1,38111," "],[1,38112,"l"],[1,38132,"\n  "],[1,38445,"\n数"],[-1,38451,"\n*"],[1,38850,"\n*"]],[35933,35933],[38852,38852]]],[1543544812255,[null,[[1,35933,"n"],[1,35934,"gxu "],[-1,35978,"tati"],[1,35983,"****"],[1,37726,"数"],[-1,37726,"\n"],[1,38106," "],[-1,38106,"l"],[-1,38127,"\n  "],[-1,38443,"\n数"],[1,38451,"\n*"],[-1,38848,"\n*"]],[38852,38852],[35933,35933]]],[1543544752747,["gjx16@GJXAIOU",[[1,39226,"（）"]],[39226,39226],[39228,39228]]],[1543544754282,["gjx16@GJXAIOU",[[1,39227,"一"]],[39227,39227],[39228,39228]]],[1543544758267,["gjx16@GJXAIOU",[[1,39229,"概念"]],[39229,39229],[39231,39231]]],[1543544760927,["gjx16@GJXAIOU",[[1,39221,"\n"]],[39220,39220],[39221,39221]]],[1543544768779,["gjx16@GJXAIOU",[[1,39247,"1."]],[39247,39247],[39249,39249]]],[1543544771014,["gjx16@GJXAIOU",[[-1,39247,"1."]],[39249,39249],[39247,39247]]],[1543544773931,["gjx16@GJXAIOU",[[1,39236,"1."]],[39236,39236],[39238,39238]]],[1543544781542,["gjx16@GJXAIOU",[[1,39862,"2，。"]],[39862,39862],[39865,39865]]],[1543544783676,["gjx16@GJXAIOU",[[-1,39863,"，。"]],[39865,39865],[39863,39863]]],[1543544784291,["gjx16@GJXAIOU",[[1,39863,"."]],[39863,39863],[39864,39864]]],[1543544804706,["gjx16@GJXAIOU",[[-1,41113,"**8.2****"],[1,41122,"@"]],[41113,41113],[41114,41114]]],[1543544806262,["gjx16@GJXAIOU",[[-1,41113,"@"]],[41114,41114],[41113,41113]]],[1543544810556,["gjx16@GJXAIOU",[[1,41113,"### （）"]],[41113,41113],[41119,41119]]],[1543544811151,["gjx16@GJXAIOU",[[1,41118,"二"]],[41118,41118],[41119,41119]]],[1543544872377,[null,[[-1,35933,"n"],[-1,35935,"gxu "],[1,35983,"tati"],[-1,35984,"****"],[-1,37731,"数"],[1,37732,"\n"],[-1,38111," "],[1,38112,"l"],[1,38132,"\n  "],[1,38445,"\n数"],[-1,38451,"\n*"],[1,38850,"\n*"]],[35933,35933],[38852,38852]]],[1543544872378,[null,[[1,35933,"n"],[1,35934,"gxu "],[-1,35978,"tati"],[1,35983,"****"],[1,37726,"数"],[-1,37726,"\n"],[1,38106," "],[-1,38106,"l"],[-1,38127,"\n  "],[-1,38443,"\n数"],[1,38451,"\n*"],[-1,38848,"\n*"]],[38852,38852],[35933,35933]]],[1543544817062,["gjx16@GJXAIOU",[[-1,41128,"**"]],[41130,41130],[41128,41128]]],[1543544819864,["gjx16@GJXAIOU",[[1,41130,"\n"]],[41129,41129],[41130,41130]]],[1543544820436,["gjx16@GJXAIOU",[[1,41131,"\n"]],[41130,41130],[41131,41131]]],[1543544820973,["gjx16@GJXAIOU",[[1,41132,"\n"]],[41131,41131],[41132,41132]]],[1543544822745,["gjx16@GJXAIOU",[[1,41113,"\n"]],[41112,41112],[41113,41113]]],[1543544823301,["gjx16@GJXAIOU",[[1,41114,"\n"]],[41113,41113],[41114,41114]]],[1543544823815,["gjx16@GJXAIOU",[[1,41115,"\n"]],[41114,41114],[41115,41115]]],[1543544826837,["gjx16@GJXAIOU",[[1,41115,"---"]],[41115,41115],[41118,41118]]],[1543544827427,["gjx16@GJXAIOU",[[1,41119,"\n"]],[41118,41118],[41119,41119]]],[1543544832605,["gjx16@GJXAIOU",[[1,41138,"---"]],[41138,41138],[41141,41141]]],[1543544836639,["gjx16@GJXAIOU",[[-1,41143,"**8.3****"],[1,41152,"#"]],[41143,41143],[41144,41144]]],[1543544863659,["gjx16@GJXAIOU",[[1,41144,"## （）"]],[41144,41144],[41149,41149]]],[1543544865241,["gjx16@GJXAIOU",[[1,41148,"三"]],[41148,41148],[41149,41149]]],[1543544869755,["gjx16@GJXAIOU",[[-1,41159,"**"]],[41161,41161],[41159,41159]]],[1543545172299,[null,[[-1,35933,"n"],[-1,35935,"gxu "],[1,35983,"tati"],[-1,35984,"****"],[-1,37731,"数"],[1,37732,"\n"],[-1,38111," "],[1,38112,"l"],[1,38132,"\n  "],[1,38445,"\n数"],[-1,38451,"\n*"],[1,38850,"\n*"]],[35933,35933],[38852,38852]]],[1543545172299,[null,[[1,35933,"n"],[1,35934,"gxu "],[-1,35978,"tati"],[1,35983,"****"],[1,37726,"数"],[-1,37726,"\n"],[1,38106," "],[-1,38106,"l"],[-1,38127,"\n  "],[-1,38443,"\n数"],[1,38451,"\n*"],[-1,38848,"\n*"]],[38852,38852],[35933,35933]]],[1543545130997,["gjx16@GJXAIOU",[[-1,41109," |"]],[41109,41111],[41109,41109]]],[1543545232318,[null,[[-1,35933,"n"],[-1,35935,"gxu "],[1,35983,"tati"],[-1,35984,"****"],[-1,37731,"数"],[1,37732,"\n"],[-1,38111," "],[1,38112,"l"],[1,38132,"\n  "],[1,38445,"\n数"],[-1,38451,"\n*"],[1,38850,"\n*"]],[35933,35933],[38852,38852]]],[1543545232318,[null,[[1,35933,"n"],[1,35934,"gxu "],[-1,35978,"tati"],[1,35983,"****"],[1,37726,"数"],[-1,37726,"\n"],[1,38106," "],[-1,38106,"l"],[-1,38127,"\n  "],[-1,38443,"\n数"],[1,38451,"\n*"],[-1,38848,"\n*"]],[38852,38852],[35933,35933]]],[1543545207987,["gjx16@GJXAIOU",[[-1,44997,"**8.4****"]],[44997,45006],[44997,44997]]],[1543545212491,["gjx16@GJXAIOU",[[1,44997,"### （）"]],[44997,44997],[45003,45003]]],[1543545213092,["gjx16@GJXAIOU",[[1,45002,"四"]],[45002,45002],[45003,45003]]],[1543545216987,["gjx16@GJXAIOU",[[-1,45011,"**"]],[45013,45013],[45011,45011]]],[1543545292325,[null,[[-1,35933,"n"],[-1,35935,"gxu "],[1,35983,"tati"],[-1,35984,"****"],[-1,37731,"数"],[1,37732,"\n"],[-1,38111," "],[1,38112,"l"],[1,38132,"\n  "],[1,38445,"\n数"],[-1,38451,"\n*"],[1,38850,"\n*"]],[35933,35933],[38852,38852]]],[1543545292325,[null,[[1,35933,"n"],[1,35934,"gxu "],[-1,35978,"tati"],[1,35983,"****"],[1,37726,"数"],[-1,37726,"\n"],[1,38106," "],[-1,38106,"l"],[-1,38127,"\n  "],[-1,38443,"\n数"],[1,38451,"\n*"],[-1,38848,"\n*"]],[38852,38852],[35933,35933]]],[1543545245269,["gjx16@GJXAIOU",[[-1,47701,"运算符重载在项目开发中的应用**\n"],[1,47718,"#"]],[47701,47701],[47702,47702]]],[1543545246467,["gjx16@GJXAIOU",[[1,47702,"##"]],[47702,47702],[47704,47704]]],[1543545249012,["gjx16@GJXAIOU",[[-1,47702,"##"]],[47704,47704],[47702,47702]]],[1543545257363,["gjx16@GJXAIOU",[[1,47701,"运算符重载在项目开发中的应用**\n"],[-1,47692,"**8.5****#"]],[47702,47702],[47692,47692]]],[1543545257936,["gjx16@GJXAIOU",[[-1,47691,"\n"]],[47692,47692],[47691,47691]]],[1543545259388,["gjx16@GJXAIOU",[[1,47691,"\n"]],[47691,47691],[47692,47692]]],[1543545265807,["gjx16@GJXAIOU",[[1,47692,"### （）"]],[47692,47692],[47698,47698]]],[1543545267069,["gjx16@GJXAIOU",[[1,47697,"五"]],[47697,47697],[47698,47698]]],[1543545271667,["gjx16@GJXAIOU",[[-1,47713,"**"]],[47715,47715],[47713,47713]]],[1543545281083,["gjx16@GJXAIOU",[[-1,47686,"|  |"]],[47690,47690],[47686,47686]]],[1543545281876,["gjx16@GJXAIOU",[[-1,47687,"\n"]],[47686,47686],[47685,47685]]],[1543545283069,["gjx16@GJXAIOU",[[-1,47683," |"]],[47685,47685],[47683,47683]]],[1543545284636,["gjx16@GJXAIOU",[[-1,47684,"\n"]],[47683,47683],[47682,47682]]],[1543545289506,["gjx16@GJXAIOU",[[-1,47710,"****"]],[47710,47714],[47710,47710]]],[1543545352320,[null,[[-1,35933,"n"],[-1,35935,"gxu "],[1,35983,"tati"],[-1,35984,"****"],[-1,37731,"数"],[1,37732,"\n"],[-1,38111," "],[1,38112,"l"],[1,38132,"\n  "],[1,38445,"\n数"],[-1,38451,"\n*"],[1,38850,"\n*"],[-1,47691,"**8.5****"],[1,47705,"在项"],[1,47710,"应用"],[-1,47715,"****"]],[35933,35933],[47715,47715]]],[1543545352320,[null,[[1,35933,"n"],[1,35934,"gxu "],[-1,35978,"tati"],[1,35983,"****"],[1,37726,"数"],[-1,37726,"\n"],[1,38106," "],[-1,38106,"l"],[-1,38127,"\n  "],[-1,38443,"\n数"],[1,38451,"\n*"],[-1,38848,"\n*"],[1,47691,"**8.5****"],[-1,47696,"在项"],[-1,47703,"应用"],[1,47710,"****"]],[47715,47715],[35933,35933]]],[1543545294044,["gjx16@GJXAIOU",[[-1,47733,"****"]],[47733,47737],[47733,47733]]],[1543545772442,[null,[[-1,35933,"n"],[-1,35935,"gxu "],[1,35983,"tati"],[-1,35984,"****"],[-1,37731,"数"],[1,37732,"\n"],[-1,38111," "],[1,38112,"l"],[1,38132,"\n  "],[1,38445,"\n数"],[-1,38451,"\n*"],[1,38850,"\n*"],[-1,47691,"**8.5****"],[1,47705,"在项"],[1,47710,"应用"],[-1,47715,"****"],[1,47733,"< >>"],[-1,47738,"****"]],[35933,35933],[47738,47738]]],[1543545772442,[null,[[1,35933,"n"],[1,35934,"gxu "],[-1,35978,"tati"],[1,35983,"****"],[1,37726,"数"],[-1,37726,"\n"],[1,38106," "],[-1,38106,"l"],[-1,38127,"\n  "],[-1,38443,"\n数"],[1,38451,"\n*"],[-1,38848,"\n*"],[1,47691,"**8.5****"],[-1,47696,"在项"],[-1,47703,"应用"],[1,47710,"****"],[-1,47724,"< >>"],[1,47733,"****"]],[47738,47738],[35933,35933]]],[1543545770265,["gjx16@GJXAIOU",[[1,39249,"![11]($resource/11.png)"]],[39249,39249],[39273,39273]]],[1543545832442,[null,[[-1,35933,"n"],[-1,35935,"gxu "],[1,35983,"tati"],[-1,35984,"****"],[-1,37731,"数"],[1,37732,"\n"],[-1,38111," "],[1,38112,"l"],[1,38132,"\n  "],[1,38445,"\n数"],[-1,38451,"\n*"],[1,38850,"\n*"],[-1,47714,"**8.5****"],[1,47728,"在项"],[1,47733,"应用"],[-1,47738,"****"],[1,47756,"< >>"],[-1,47761,"****"]],[35933,35933],[47761,47761]]],[1543545832442,[null,[[1,35933,"n"],[1,35934,"gxu "],[-1,35978,"tati"],[1,35983,"****"],[1,37726,"数"],[-1,37726,"\n"],[1,38106," "],[-1,38106,"l"],[-1,38127,"\n  "],[-1,38443,"\n数"],[1,38451,"\n*"],[-1,38848,"\n*"],[1,47714,"**8.5****"],[-1,47719,"在项"],[-1,47726,"应用"],[1,47733,"****"],[-1,47747,"< >>"],[1,47756,"****"]],[47761,47761],[35933,35933]]],[1543545794408,["gjx16@GJXAIOU",[[1,41157,"![12]($resource/12.png)\n![13]($resource/13.png)"]],[41157,41157],[41205,41205]]],[1543545813437,["gjx16@GJXAIOU",[[1,41370,"![14]($resource/14.png)"]],[41370,41370],[41394,41394]]],[1543545892419,[null,[[-1,35933,"n"],[-1,35935,"gxu "],[1,35983,"tati"],[-1,35984,"****"],[-1,37731,"数"],[1,37732,"\n"],[-1,38111," "],[1,38112,"l"],[1,38132,"\n  "],[1,38445,"\n数"],[-1,38451,"\n*"],[1,38850,"\n*"],[-1,47784,"**8.5****"],[1,47798,"在项"],[1,47803,"应用"],[-1,47808,"****"],[1,47826,"< >>"],[-1,47831,"****"]],[35933,35933],[47831,47831]]],[1543545892419,[null,[[1,35933,"n"],[1,35934,"gxu "],[-1,35978,"tati"],[1,35983,"****"],[1,37726,"数"],[-1,37726,"\n"],[1,38106," "],[-1,38106,"l"],[-1,38127,"\n  "],[-1,38443,"\n数"],[1,38451,"\n*"],[-1,38848,"\n*"],[1,47784,"**8.5****"],[-1,47789,"在项"],[-1,47796,"应用"],[1,47803,"****"],[-1,47817,"< >>"],[1,47826,"****"]],[47831,47831],[35933,35933]]],[1543545839194,["gjx16@GJXAIOU",[[-1,41370,"![14]($resource/14.png)"]],[41370,41393],[41370,41370]]],[1543545843145,["gjx16@GJXAIOU",[[1,41228,"![14]($resource/14.png)"]],[41228,41228],[41251,41251]]],[1543545852864,["gjx16@GJXAIOU",[[1,41393,"![15]($resource/15.png)"]],[41393,41393],[41417,41417]]],[1543545873510,["gjx16@GJXAIOU",[[1,41417,"\n"]],[41416,41416],[41417,41417]]],[1543545880372,["gjx16@GJXAIOU",[[1,41417,"![16]($resource/16.png)"]],[41417,41417],[41441,41441]]],[1543545952798,[null,[[-1,35933,"n"],[-1,35935,"gxu "],[1,35983,"tati"],[-1,35984,"****"],[-1,37731,"数"],[1,37732,"\n"],[-1,38111," "],[1,38112,"l"],[1,38132,"\n  "],[1,38445,"\n数"],[-1,38451,"\n*"],[1,38850,"\n*"],[-1,47831,"**8.5****"],[1,47845,"在项"],[1,47850,"应用"],[-1,47855,"****"],[1,47873,"< >>"],[-1,47878,"****"]],[35933,35933],[47878,47878]]],[1543545952798,[null,[[1,35933,"n"],[1,35934,"gxu "],[-1,35978,"tati"],[1,35983,"****"],[1,37726,"数"],[-1,37726,"\n"],[1,38106," "],[-1,38106,"l"],[-1,38127,"\n  "],[-1,38443,"\n数"],[1,38451,"\n*"],[-1,38848,"\n*"],[1,47831,"**8.5****"],[-1,47836,"在项"],[-1,47843,"应用"],[1,47850,"****"],[-1,47864,"< >>"],[1,47873,"****"]],[47878,47878],[35933,35933]]],[1543545913772,["gjx16@GJXAIOU",[[1,41828,"![17]($resource/17.png)"]],[41828,41828],[41852,41852]]],[1543545951833,["gjx16@GJXAIOU",[[1,42838,"![18]($resource/18.png)"]],[42838,42838],[42862,42862]]],[1543546432788,[null,[[-1,35933,"n"],[-1,35935,"gxu "],[1,35983,"tati"],[-1,35984,"****"],[-1,37731,"数"],[1,37732,"\n"],[-1,38111," "],[1,38112,"l"],[1,38132,"\n  "],[1,38445,"\n数"],[-1,38451,"\n*"],[1,38850,"\n*"],[-1,47877,"**8.5****"],[1,47891,"在项"],[1,47896,"应用"],[-1,47901,"****"],[1,47919,"< >>"],[-1,47924,"****"]],[35933,35933],[47924,47924]]],[1543546432788,[null,[[1,35933,"n"],[1,35934,"gxu "],[-1,35978,"tati"],[1,35983,"****"],[1,37726,"数"],[-1,37726,"\n"],[1,38106," "],[-1,38106,"l"],[-1,38127,"\n  "],[-1,38443,"\n数"],[1,38451,"\n*"],[-1,38848,"\n*"],[1,47877,"**8.5****"],[-1,47882,"在项"],[-1,47889,"应用"],[1,47896,"****"],[-1,47910,"< >>"],[1,47919,"****"]],[47924,47924],[35933,35933]]],[1543546396730,["gjx16@GJXAIOU",[[-1,40065,"| \n"]],[40065,40068],[40065,40065]]],[1543547752811,[null,[[-1,35933,"n"],[-1,35935,"gxu "],[1,35983,"tati"],[-1,35984,"****"],[-1,37731,"数"],[1,37732,"\n"],[-1,38111," "],[1,38112,"l"],[1,38132,"\n  "],[1,38445,"\n数"],[-1,38451,"\n*"],[1,38850,"\n*"],[-1,47874,"**8.5****"],[1,47888,"在项"],[1,47893,"应用"],[-1,47898,"****"],[1,47916,"< >>"],[-1,47921,"****"]],[35933,35933],[47921,47921]]],[1543547752811,[null,[[1,35933,"n"],[1,35934,"gxu "],[-1,35978,"tati"],[1,35983,"****"],[1,37726,"数"],[-1,37726,"\n"],[1,38106," "],[-1,38106,"l"],[-1,38127,"\n  "],[-1,38443,"\n数"],[1,38451,"\n*"],[-1,38848,"\n*"],[1,47874,"**8.5****"],[-1,47879,"在项"],[-1,47886,"应用"],[1,47893,"****"],[-1,47907,"< >>"],[1,47916,"****"]],[47921,47921],[35933,35933]]],[1543547711562,["gjx16@GJXAIOU",[[1,40065,"//七、操作符重载\n/*对于基础数据类型，C++编译器知道如何进行运算，但是对于用户自定义的类型编译器提供了一种\n让自定义数据类型进行运算符操作的机制,=》运算符重载机制\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n"],[-1,40079,"\n"],[-1,40092,"\n "],[1,40094,"\t"],[-1,40101,"\n "],[1,40103,"\t"],[-1,40111," "],[1,40112,"\t"],[-1,40174," "],[1,40175,"\t"],[1,40188," "],[1,40189," "],[1,40197," "],[1,40198," "],[-1,40202," {\n\n "],[1,40207,"\t{\n\n\t\t"],[-1,40221," "],[1,40222,"\t\t"],[-1,40236," "],[1,40237,"\t"],[-1,40249," "],[1,40250,"\t"],[-1,40266,"\n {\n\n "],[1,40272,"\t{\n\t\t"],[1,40276," "],[1,40278," "],[1,40279," "],[1,40281," "],[1,40286," "],[1,40288," "],[1,40289," "],[1,40291," "],[1,40295," "],[1,40297," "],[-1,40303,"\n "],[1,40305,"\t"],[1,40324,"使用全局函数，通过调用全局函数实现"],[-1,40366,"\n"],[1,40431,"\n//可以想象为将函数名替换为operator+\n"],[-1,40475,"\n"],[-1,40478,"\n "],[1,40480,"\t"],[1,40496," "],[-1,40519," "],[1,40520,"\t"],[-1,40532,"\n"],[-1,40552," "],[1,40553,"\t"],[-1,40582," //Complex c3 = c1 + c2; //用户自定义类型 编译器无法让变量相加\n\n //Complex myAdd(Complex &c1, Complex &c2);\n\n //1 "],[1,40679,"\n\t//方法1： 通过调用"],[1,40683,"实现"],[-1,40685," "],[1,40686,"\t"],[-1,40717," "],[1,40718,"\t"],[-1,40736," "],[1,40737,"\n\n\n\n\t"],[1,40739,"方法"],[1,40741," 将函数名称替换为："],[-1,40751,"函数名称\n\n "],[1,40758,"\n\t//使用以下方式进行调用\n\n\t"],[-1,40792,"\n "],[1,40794,"\t"],[-1,40812," //3 +替换 函数名\n\n "],[1,40827,"\n\t//最常用的调用方式\n\n\t"],[-1,40849,"**//****思考C++****编译器如何支持操作符重载机制的** (**根据类型**)\n\n "],[1,40897,"\n\t"],[-1,40912,"\n{"],[-1,40916,"int a =0, b = 0, c; //**基础类型C++****编译器知道如何加减**\n\nc = a +b;\n\n}\n\n "],[1,40979,"\t"],[-1,41000," "],[1,41001,"\t"],[-1,41014," "],[1,41015,"\t"],[-1,41070," cout<<\"hello...\"<<endl;\n\n "],[1,41097,"\t"],[-1,41115," "],[1,41116,"\t"],[-1,41122," "]],[40065,41127],[41115,41115]]],[1543547718013,["gjx16@GJXAIOU",[[-1,40065,"//七、操作符重载"]],[40065,40074],[40065,40065]]],[1543547719173,["gjx16@GJXAIOU",[[-1,40065,"\n"]],[40065,40065],[40064,40064]]],[1543547721595,["gjx16@GJXAIOU",[[1,40064,"·"]],[40064,40064],[40065,40065]]],[1543547723076,["gjx16@GJXAIOU",[[-1,40064,"·"]],[40065,40065],[40064,40064]]],[1543547724976,["gjx16@GJXAIOU",[[1,40064,"```"]],[40064,40064],[40067,40067]]],[1543547725458,["gjx16@GJXAIOU",[[1,40067,"language\n```\n"]],[40067,40067],[40067,40075]]],[1543547726039,["gjx16@GJXAIOU",[[-1,40067,"language"],[1,40075,"c"]],[40067,40075],[40068,40068]]],[1543547727194,["gjx16@GJXAIOU",[[1,40068,"pp"]],[40068,40068],[40070,40070]]],[1543547729968,["gjx16@GJXAIOU",[[-1,40071,"```"]],[40071,40074],[40071,40071]]],[1543547737856,["gjx16@GJXAIOU",[[1,41114,"```"]],[41114,41114],[41117,41117]]],[1543547743941,["gjx16@GJXAIOU",[[-1,40728,"\n"]],[40728,40728],[40727,40727]]],[1543547745101,["gjx16@GJXAIOU",[[-1,40730,"\n"]],[40730,40730],[40729,40729]]],[1543547746373,["gjx16@GJXAIOU",[[-1,40760,"\n"]],[40759,40759],[40758,40758]]],[1543547812809,[null,[[-1,35933,"n"],[-1,35935,"gxu "],[1,35983,"tati"],[-1,35984,"****"],[-1,37731,"数"],[1,37732,"\n"],[-1,38111," "],[1,38112,"l"],[1,38132,"\n  "],[1,38445,"\n数"],[-1,38451,"\n*"],[1,38850,"\n*"],[-1,47860,"**8.5****"],[1,47874,"在项"],[1,47879,"应用"],[-1,47884,"****"],[1,47902,"< >>"],[-1,47907,"****"]],[35933,35933],[47907,47907]]],[1543547812810,[null,[[1,35933,"n"],[1,35934,"gxu "],[-1,35978,"tati"],[1,35983,"****"],[1,37726,"数"],[-1,37726,"\n"],[1,38106," "],[-1,38106,"l"],[-1,38127,"\n  "],[-1,38443,"\n数"],[1,38451,"\n*"],[-1,38848,"\n*"],[1,47860,"**8.5****"],[-1,47865,"在项"],[-1,47872,"应用"],[1,47879,"****"],[-1,47893,"< >>"],[1,47902,"****"]],[47907,47907],[35933,35933]]],[1543547763388,["gjx16@GJXAIOU",[[-1,41118,"\n"]],[41117,41117],[41116,41116]]],[1543547765189,["gjx16@GJXAIOU",[[-1,41117,"\n"]],[41116,41116],[41115,41115]]],[1543548352819,[null,[[-1,35933,"n"],[-1,35935,"gxu "],[1,35983,"tati"],[-1,35984,"****"],[-1,37731,"数"],[1,37732,"\n"],[-1,38111," "],[1,38112,"l"],[1,38132,"\n  "],[1,38445,"\n数"],[-1,38451,"\n*"],[1,38850,"\n*"],[-1,47858,"**8.5****"],[1,47872,"在项"],[1,47877,"应用"],[-1,47882,"****"],[1,47900,"< >>"],[-1,47905,"****"]],[35933,35933],[47905,47905]]],[1543548352819,[null,[[1,35933,"n"],[1,35934,"gxu "],[-1,35978,"tati"],[1,35983,"****"],[1,37726,"数"],[-1,37726,"\n"],[1,38106," "],[-1,38106,"l"],[-1,38127,"\n  "],[-1,38443,"\n数"],[1,38451,"\n*"],[-1,38848,"\n*"],[1,47858,"**8.5****"],[-1,47863,"在项"],[-1,47870,"应用"],[1,47877,"****"],[-1,47891,"< >>"],[1,47900,"****"]],[47905,47905],[35933,35933]]],[1543548332642,["gjx16@GJXAIOU",[[1,41304," "]],[41304,41304],[41305,41305]]]],null,"gjx16@GJXAIOU"],["eb44cc80-34ae-4eba-b10b-7dde1c4d1a02",1543557102437,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁;\n   * c++面向对象模型初探;  \n   * c++面向对象多态原理探究;\n   * 操作符重载;\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;//定义两个对象c1和c2\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n};\n\n```\nTeacher.cpp\n//具体实现函数内容，在函数名前面加上`类名::`\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1:设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)//因为类的成员变量这里都是private:\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n###  (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n###  (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//需要重载=号操作符，才能解决带来的浅拷贝问题\n\n\tobj2 = obj3; //=号操作，也是一种浅拷贝\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++的默认copy构造函数是浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n\n---\n\n\n### （五）多个对象构造和析构\n\n**1.对象初始化列表**\n\n- 1）对象初始化列表出现原因\n程序本身是有问题的\n```cpp\n\n/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B   //在一个类里面组合了一个带有参数的构造函数的类，因为C++编译器要确定分配给B多大的内存，但是没法初始化A定义的两个对象（因为需要调用有参的构造函数）\n{\npublic:   //没有写B的构造函数，按理说应该调用默认的构造函数\n\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  //主要是因为没有方法和没有机会去初始化这两个A定义的对象\n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB;\n\treturn 0;\n\n}\n\n```\n\n解决方法：\n```cpp\n/*\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n};\n\n\nclass B  \n{\npublic:   \n//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）\n\tB(int _a, int _b) : a1(1), a2(3)  \n\t{\n\n\t}\n//第二种参数传递的方法：\n/*\nB(int _a, int _b,int m,int n) : a1(m), a2(n)  \n\t{\n      a = _a;\n      b = _b;\n\t}\n\t\n*/\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  \n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB(1,2);\n\t//第二种方式：B objB(1,2,4,3)\n\treturn 0;\n\n}\n\n```\n\n**以上程序的操作顺序：**\n首先执行被组合对象的构造函数（a1,a2），如果有多个组合对象，则按照定义的顺序，而不是按照初始化列表的顺序（：后面的顺序）\n析构函数：和构造函数的调用顺序相反\n\n  - 1.必须这样做：\n    - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    - 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n  - 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    - 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    - 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n- 2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n```cpp\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n{\n // some other assignment operation\n}\n```\n\n\n- 3）注意概念\n  - 初始化：被初始化的对象正在创建\n  - 赋值：被赋值的对象已经存在\n\n- 4）注意：\n  - 成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n  - 初始化列表先于构造函数的函数体执行\n\n**说明：**\n\n* 1 C++中提供了初始化列表对成员变量进行初始化\n* 2 使用初始化列表出现原因：\n  * 1.必须这样做：\n    * 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n    * 而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    * 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n  * 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    * 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    * 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n```cpp\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n ABC(int a, int b, int c)\n {\n this->a = a;\n this->b = b;\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"ABC construct ..\\n\");\n }\n\n ~ABC()\n {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n }\n\nprotected:\nprivate:\n int a;\n int b;\n int c;\n};\n\nclass MyD\n{\npublic:\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n {\n cout<<\"MyD()\"<<endl;\n }\n\n ~MyD()\n {\n cout<<\"~MyD()\"<<endl;\n }\n\nprotected:\nprivate:\n ABC abc1; //c++编译器不知道如何构造abc1\n ABC abc2;\n const int m;\n};\n\nint run()\n{\n MyD myD;\n return 0;\n}\n\nint main_dem03()\n{\n run();\n system(\"pause\");\n return 0;\n}\n\n```\n\n\n\n\n### （六）构造函数和析构函数的调用顺序研究\n\n**构造函数与析构函数的调用顺序**\n\n- 1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n- 2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n### （七）构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1构造析构综合训练**\n```cpp\n\n/*\n\n总结 构造和析构的调用顺序\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n\tABC(int a, int b, int c)   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\n\t}\n\n\t~ABC()\n\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\n\nclass MyD \n{\npublic:\n\tMyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~MyD()\n\t{\n\t\tcout << \"~MyD()\" << endl;\n\t}\n\n\tMyD(const MyD & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\tcout << \"MyD(const MyD &obj)\" << endl;\n\t}\n\nprotected:\nprivate:\n\tABC abc1; //c++编译器不知道如何构造abc1//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\tABC abc2;\n\tconst int m;//因为是const m,所以上面所有的m都进行了赋值\n};\n\n\nint doThing(MyD myel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;\n}\n\n\nint run2()//二\n{\n\tMyD myD;//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\treturn 0;\n}\n\nint run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main()\n{\n\trun2();//一\n\t//run3();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n\n\n```\n\n\n**2匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3匿名对象强化训练**\n\n3） 构造中调用构造\n\n```cpp\n/*\n\n构造中调用构造\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass MyTest\n{\npublic:\n\tMyTest(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t}\n\n\tMyTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\n\t\tMyTest(a, b, 10);\n\t}\n\n\t~MyTest()\n\t{\n\t\tcout << \"MyTest is ...\" << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n\n\npublic:\n\tint getC() const { return c; }\n\n\tvoid setC(int val) { c = val; }\n};\n\nint main()\n{\n\tMyTest t1(1, 2);\n\tcout << t1.getC() << endl;\n\tsystem(\"pause\");\n\treturn 0;\n\t\n}\n\n\n```\n\n 结论： 构造函数中调用构造函数，是一个蹩脚的行为。\n程序内存图：\n![搜狗截图20181124125452]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181124125452.png)\n\n### （八）对象的动态建立和释放\n\n**1.new和delete基本语法**\n```cpp\n/*\n\nnew 和delete的使用\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nvoid main()\n{\n\t//先分配内存然后赋值\n\tint *p = new int;  //分配基础类型\n\t*p = 20;  \n\n\t//在定义的时候直接分配内存\n\tint *p1 = new int(30);\n\tcout << *p1 << endl;\n\n\tsystem(\"pause\");\n\treturn; \n}\n\n```\n\n- 1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n  **注意： new和delete是运算符，不是函数，因此执行效率高。**\n\n- 2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： \nnew int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 \nnew char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址    new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n- 3）new和delete运算符使用的一般格式为：\n  用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n![new运算符动态]($resource/new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%A8%E6%80%81.png)\n```cpp\n\n/*\n使用malloc /free 与new /delete的区别\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest();\n\t~Test();\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\nTest::Test()\n{\n\tcout << \"执行了构造函数\" << endl;\n}\n\nTest::~Test()\n{\n\tcout << \"执行了析构函数\" << endl;\n}\n\n\n\nint main()\n{\n\t//基础类型\n\tint *p1 = (int *)malloc(sizeof(int));\n\t*p1 = 10;\n\tdelete p1;\n\n\tint *p2 = new int;\n\t*p2 = 20;\n\tfree(p2);\n\n\n\n\t//数组类型（元素为基础类型）\n\tint *p3 = (int *)malloc(sizeof(int)*10);\n\tp3[0] = 1;\n\tdelete[]p3;\n\n\tint *p4 = new int[10];\n\tp4[1] = 2;\n\tfree(p4);\n\n\n\t//类\n\tTest *p5 = (Test *)malloc(sizeof(Test));\n\tdelete p5;\n\n\tTest *p6 = new Test(10);\n\tfree(p6);\n}\n\n\n```\n**结论：** \nnew：不仅分配内存，而且调用了构造函数\ndelete:不仅释放了内存，而且调用了析构函数\n\n- 4） 应用举例\n\n![5]($resource/5.png)\n\n**2类对象的动态建立和释放**\n\n- 使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n-  C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n  比如：\n\n  Box *pt;  //定义一个指向Box类对象的指针变量pt\n      pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n   这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n  新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n   在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3.编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n\n\n\n## 四、静态成员变量和成员函数\n\n\n思考：每个变量，拥有属性。有没有一些属性，归所有对象拥有？\n\n### （一）静态成员变量\n\n- **1定义静态成员变量**\n  - 关键字 **static**  可以用于说明一个类的成员，\n    静态成员提供了一个同类对象的共享机制\n\n  - 把一个类的成员说明为 **static**  时，这个类无论有多少个对象被创建，这些对象共享这个 **static**  成员\n\n  - 静态成员局部于类，它不是对象成员\n\n![1]($resource/1.png)\n\n例如：\n\n```cpp\n\n/*\n静态成员变量\n*/\n\n#include<iostream>\nusing namespace std;\n\nclass counter\n{\n\n\tstatic int num; //**声明与定义静态数据成员**\n\npublic:\n\n\tvoid setnum(int i) \n\t{ \n\t\tnum = i; \n\t} //成员函数访问静态数据成员\n\n\tvoid shownum() \n\t{ \n\t\tcout << num << endl;\n\t}\n\n};\n\nint counter::num = 0;//声明与定义静态数据成员\n\nvoid main()\n{\n\tcounter a, b;\n\n\ta.shownum(); //调用成员函数访问私有静态数据成员\n\tb.shownum();\n\ta.setnum(10);\n\ta.shownum();\n\tb.shownum();\n\n}\n\n```\n\n![6]($resource/6.png)\n\n**从结果可以看出，访问的是同一个静态数据成员**\n\n- **2使用静态成员变量**\n```cpp\n//例5-14_使用公有静态数据成员\n\n#include<iostream.h>\n\nclass counter\n{ \npublic :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n\n```\n使用静态成员函数调用静态成员变量\n```cpp\n/*\n静态成员函数\n*/\n// 结论：在静态成员函数中可以使用静态成员变量，但是不能使用类中普通的成员变量\n\n#include\"iostream\"\nusing namespace std;\n\nclass BB\n{\npublic:\n\tint printC()\n\t{\n\t\tcout << \"c:\" << c << endl;\n\t\treturn c;\n\t}\n\n\tint addC()\n\t{\n\t\tc = c+1;\n\t}\n\n\n\tstatic void getC()\n\t{\n\t\tcout << \"c\" << c << endl;  //可以直接在静态成员函数中使用静态成员变量，但是不能直接使用一般变量\n\t}\nprivate:\n\tint a;\n\tint b;\n\tstatic int c;\n\n};\n\n\nint BB::c = 10;  //初始化成员变量值\n\nvoid main()\n{\n\tBB b1, b2, b3;\n\tb1.printC();//10\n\tb2.addC();//11\n\tb3.printC();//11\n\n\t//调用成员函数两种方法；\n\tb3.getC();//使用对象.\n\tBB::getC();//使用类::\n\n\n\n}\n\n```\n\n### (二)静态成员函数\n\n- **1）概念**\n\n  - 静态成员函数数冠以关键字static\n\n  - 静态成员函数提供不依赖于类数据结构的共同操作，它没有this指针\n  - 在类外调用静态成员函数用 `_类名_ ::`作限定词，或通过对象调用\n\n- **2）案例**\n![7]($resource/7.png)\n\n- **3）疑难问题：**\n静态成员函数中，不能使用普通变量。\n//静态成员变量属于整个类的，分不清楚，是那个具体对象的属性。\n![成员函数中的疑难问题]($resource/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98.png)\n\n**4.3 综合训练**\n\n\n\n## 五、 C++面向对象模型初探\n\n**前言**\n\n- C++对象模型可以概括为以下2部分：\n\n  - 1. 语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等等。\n\n  - 2. 对于各种支持的底层实现机制。\n\n  在c语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。在c++中，通过抽象数据类型（abstract data type，ADT），在类中定义数据和函数，来实现数据和函数直接的绑定。\n\n  概括来说，在C++类中有两种成员数据：static、nonstatic；三种成员函数：static、nonstatic、virtual。\n\n![C++类的组成]($resource/C++%E7%B1%BB%E7%9A%84%E7%BB%84%E6%88%90.png)\n\n### （一）基础知识\n\nC++中的class从面向对象理论出发，将变量(属性)和函数(方法)集中定义在一起，用于描述现实世界中的类。从计算机的角度，程序依然由数据段和代码段构成。\n\n**C++编译器如何完成面向对象理论到计算机程序的转化？**\n换句话：C++编译器是如何管理类、对象、类和对象之间的关系\n具体的说：具体对象调用类中的方法，那，c++编译器是如何区分，是那个具体的类，调用这个方法那?\n\n思考一下程序结果\n```cpp\n/*\n面向对象模型初探\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass C1\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\nprotected:\n\nprivate:\n\n}; //12\n\nclass C2\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\n\tstatic int m; \n\npublic:\n\n\tint getK() const { return k; } //方法是属于代码，应该放在代码区\n\tvoid setK(int val) { k = val; } \n\nprotected:\n\nprivate:\n}; \n\nstruct S1\n{\n\tint i;\n\tint j;\n\tint k;\n}; \n\nstruct S2\n{\n\tint i;\n\tint j;\n\tint k;\n\tstatic int m;\n}; \n\nint main()\n{\n\n\tprintf(\"c1:%d \\n\", sizeof(C1));\n\tprintf(\"c2:%d \\n\", sizeof(C2));\n\tprintf(\"s1:%d \\n\", sizeof(S1));\n\tprintf(\"s2:%d \\n\", sizeof(S2));\n\tsystem(\"pause\");\n\n}\n```\n程序运行结果：\n`c1:12`\n`c2:12`\n`s1:12`\n`s2:12`\n\n \n### (二)编译器对属性和方法的处理机制\n\n通过上面的案例，我们可以的得出：\n1）C++类对象中的成员变量和成员函数是分开存储的\n- 成员变量：\n  - 普通成员变量：存储于对象中，与struct变量有相同的内存布局和字节对齐方式\n  - 静态成员变量：存储于全局数据区中\n\n- 成员函数：存储于代码段中。\n问题出来了：很多对象共用一块代码？代码是如何区分具体对象的那？\n换句话说：int getK() const { return k; }，代码是如何区分，具体obj1、obj2、obj3对象的k值？\n\n2）C++编译器对普通成员函数的内部处理\n\n![C++编译器对普通成员函数的内部处理]($resource/C++%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E9%83%A8%E5%A4%84%E7%90%86.png)\n\n请仔细思考，并说出你的总结！\n\n\n\n### （三）总结\n\n1、C++类对象中的成员变量和成员函数是分开存储的。C语言中的内存四区模型仍然有效！\n**2、C++中类的普通成员函数都隐式包含一个指向当前对象的this指针。**\n3、静态成员函数、成员变量属于类\n\n静态成员函数与普通成员函数的区别\n\n静态成员函数不包含指向具体对象的指针\n\n普通成员函数包含一个指向具体对象的指针\n\n\n### （四）this指针\n\n![this指针图示]($resource/this%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png)\n\n实验1：若类成员函数的形参 和 类的属性（成员变量）名字相同，通过this指针来解决。\n```cpp\n\n/*\nthis 指针\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass Test\n{\npublic:\n\tTest( int a, int b)//Test(Test *this, int a, int b)//因为这里成员函数的形参和成员变量一样，不用this指针会出现：a = a ,b = b;\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printT()\n\t{\n\t\tcout << \"a; \" << a << endl;\n\t\tcout << \"b: \" << this->b << endl;\n\t}\n\n\n    const void hello(int a,int b )\n    {\n      //下面这两个语句都是错误的\n      this->a = 100;\n      this ->b = 200;\n    }\n   //const修饰的this指针，即相当于this指针指向的内存空间不能被修改\n   //因为上面的函数会别C++编译器解析为:void hello(const Test *this, int a ,int b)\n   //同时上面的const其实下载函数（）外面的任何位置都行\n   \nprotected:\nprivate:\n\tint a;\n\tint b;\n};\nint  main()\n{\n\tTest t1(1, 2);\n\tt1.printT();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`a:1`\n`b:2`\n\n\n实验2：类的成员函数可通过const修饰，请问const修饰的是谁\n\n\n### （五）全局函数PK成员函数\n\n 1、把全局函数转化成成员函数，通过this指针隐藏左操作数\n\n   Test add(Test &t1, Test &t2)===》Test add( Test &t2)\n```cpp\n/*\n全局函数与成员函数\n*/\n\n\n//使用全局函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\t\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nTest Testadd(Test &t1, Test &t2)\n{\n\tTest tmp(3,4);\n\treturn tmp;\n}\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3(2, 3);\n\tt3= Testadd(t1, t2);\n}\n```\n\n```cpp\n//使用成员函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\tTest Testadd(Test &t2)\n\t{\n\t\tTest tmp(this->a + t2.a, this->b + t2.b);\n\t\treturn tmp;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3 = t1.Testadd(t2);//匿名对象直接转化成t4\n\tTest t4(3,5);\n\tt4 = t1.Testadd(t2);  //匿名对象复制给t5\n}\n\n\n```\n 2、把成员函数转换成全局函数，多了一个参数\n\n   void printAB()===》void printAB(Test *pthis)\n\n 3、函数返回元素和返回引用\n```cpp\nTest& add(Test &t2) //*this //函数返回引用,相当于返回自身，谁调用返回谁\n {      \n   this->a = this->a + t2.getA();\n\n   this->b = this->b + t2.getB();\n\n   return *this; //*操作让this指针回到元素状态\n\n }\n\nTest add2(Test &t2) //*this //函数返回元素\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n return t3;\n\n }\n\n void add3(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n //return t3;\n\n }\n  \n\n```\n\n\n\n---\n\n## 六、友元\n\n### （一）友元函数\n\n![8]($resource/8.png)\n```cpp\n//友元函数：\n\n//首先友元函数是全局函数，在友元函数中可以修改类的私有属性\n//友元函数在类中的声明位置位于public或者private只下均可；\n\n#include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend void modify(A *PA,int _a);  //友元函数的声明\n\n\tA(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\n\nprivate:\n\tint a;\n\tint b;\n};\n\nvoid modify(A *PA,int _a)//后面的参数可加可不加\n{\n\t//PA->a = 100;//可以这样直接修改值\n\tPA->a = _a;  //通过传递的值进行修改\n}\n\n\nint main()\n{\n\tA a1(1, 2);\n\tcout << \"a:\" << a1.getA() << endl;\n\tmodify(&a1,20);\n\n\tint aa = a1.getA();\n\n\tcout << \"aa:\" << aa << endl;\n}\n```\n![9]($resource/9.png)\n\n### （二）友元类**\n\nØ 若B类是A类的友员类，则B类的所有成员函数都是A类的友员函数\n\nØ 友员类通常设计为一种对数据操作或类之间传递消息的辅助类\n```cpp\n//友元类\n #include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend class B;//将B 声明为A的友元类，这样B 可以直接修改A的成员变量和成员函数 \n\n\tA(int a=0, int b=0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B\n{\npublic:\n\n\tvoid set(int a)\n\t{\n\t\tobjA.a = a;\n\t}\n\n\tvoid printa()\n\t{\n\t\tcout << objA.a << endl;\n\t}\n\nprivate:\n\tA objA;\n};\n\n\nint main()\n{\n\tB b1;\n\tb1.set(200);\n\tb1.printa();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：200\n\n![10]($resource/10.png)\n\n\n\n## 七、强化训练\n\n**1 static关键字强化训练题**\n\nØ 某商店经销一种货物。货物购进和卖出时以箱为单位，各箱的重量不一样，因此，商店需要记录目前库存的总重量。现在用C++模拟商店货物购进和卖出的情况。\n\n| \n\n#include \"iostream\"\n\nusing namespace std;\n\nclass Goods\n\n{\n\npublic :\n\n Goods ( int w) { weight = w ; total_weight += w ; }\n\n ~ Goods() { total_weight -= weight ; }\n\n int Weight() { return weight ; } ;\n\n static int TotalWeight() { return total_weight ; }\n\n Goods *next ;\n\nprivate :\n\n int weight ;\n\n static int total_weight ;\n\n} ;\n\nint Goods::total_weight = 0 ;\n\n//r尾部指针\n\nvoid purchase( Goods * &f, Goods *& r, int w )\n\n{\n\n Goods *p = new Goods(w) ;\n\n p -> next = NULL ;\n\n if ( f == NULL ) f = r = p ;\n\n else { r -> next = p ; r = r -> next ; } //尾部指针下移或新结点变成尾部结点\n\n}\n\nvoid sale( Goods * & f , Goods * & r )\n\n{\n\n if ( f == NULL ) { cout << \"No any goods!\\n\" ; return ; }\n\n Goods *q = f ; f = f -> next ; delete q ;\n\n cout << \"saled.\\n\" ;\n\n}\n\nvoid main()\n\n{\n\n Goods * front = NULL , * rear = NULL ;\n\n int w ; int choice ;\n\n do\n\n {\n\n cout << \"Please choice:\\n\" ;\n\n cout << \"Key in 1 is purchase,\\nKey in 2 is sale,\\nKey in 0 is over.\\n\" ;\n\n cin >> choice ;\n\n switch ( choice ) // 操作选择\n\n {\n\n case 1 : // 键入1，购进1箱货物\n\n { cout << \"Input weight: \" ;\n\n cin >> w ;\n\n purchase( front, rear, w ) ; // 从表尾插入1个结点\n\n break ;\n\n }\n\n case 2 :              // 键入2，售出1箱货物\n\n { sale( front, rear ) ; break ; } // 从表头删除1个结点\n\n case 0 : break ;              // 键入0，结束\n\n }\n\n cout << \"Now total weight is:\" << Goods::TotalWeight() << endl ;\n\n } while ( choice ) ;\n\n}\n\n |\n\n**2** **数组类封装**\n\n目标：解决实际问题，训练构造函数、copy构造函数等，为操作符重载做准备\n\n\n\n数组类的头文件\n\n```cpp\n#pragma once\nclass Array\n{\npublic:\n\tArray(int length);\n\tArray(const Array&obj);\n\t~Array();\npublic:\n\tint length();\n\n\tvoid setData(int index, int value);\n\n\tint getData(int index);\nprivate:\n\tint m_length;\n\tchar *m_space;\n};\n```\n\n数组类的头文件的实现：\n```cppp\n#include \"Array.h\"\nusing namespace std;\n#include\"iostream\"\n\nArray::Array(int length)\n{\n\tif (length < 0)\n\t{\n\t\tlength = 0;\n\t}\n\telse\n\t{\n\t\tm_length = length;\n\t\tm_space = new char[m_length];\n\t}\n}\n\nArray::Array(const Array&obj)\n{\n   this->m_length = obj.m_length;\n   this->m_space = new char [this->m_length];//进行分配内存空间\n\n  for(int i= 0; i < obj.m_length;i++)//数组元素复制， 这里的obj.m_length可以直接替换成m_length\n  {\n    this->m_space[i] = obj.m_space[i];\n  }\n}\n\nArray::~Array()\n{\n\tif (m_space != NULL)\n\t{\n\t\tdelete[] m_space;\n\t\tm_length = 0;\n\t}\n}\n\nvoid Array::setData(int index, int valude)\n{\n\tm_space[index] = valude;\n}\n\nint Array::getData(int index)\n{\n\treturn m_space[index];\n}\n\nint Array::length()\n{\n\treturn m_length; \n}\n```\n\n数组类的测试\n```cpp\n#include \"iostream\"\n#include \"Array.h\"\nusing namespace std;\n\nint main()\n{\n\tArray a1(10);\n\tfor (int i = 0; i < a1.length(); i++)\n\t{\n\t\ta1.setData(i, i);\n\t}\n\tfor (int i = 0; i <  a1.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a1.getData(i));\n\t}\n\n\tArray a2 = a1;\n\n\tfor (int i = 0; i < a2.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a2.getData(i));\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**3****小结**\n\nØ 类通常用关键字class定义。类是数据成员和成员函数的封装。类的实例称为对象。\n\nØ 结构类型用关键字struct定义，是由不同类型数据组成的数据类型。\n\nØ  类成员由private, protected, public决定访问特性。public成员集称为接口。\n\nØ  构造函数在创建和初始化对象时自动调用。析构函数则在对象作用域结束时自动调用。\n\nØ  重载构造函数和复制构造函数提供了创建对象的不同初始化方式。\n\nØ  静态成员是局部于类的成员，提供一种同类对象的共享机制。\n\nØ 友员用关键字friend声明。友员是对类操作的一种辅助手段。一个类的友员可以访问该类各种性质的成员**。**\n\nØ 链表是一种重要的动态数据结构，可以在程序运行时创建或撤消数据元素。\n\n\n\n---\n\n\n## 八、运算符重载\n\n#### （一）概念\n\n**1.什么是运算符重载**\n![11]($resource/11.png)\n所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是”一名多用”。\n\n运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重载。例如，大 家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行加法运算，如5+8， 5.8 +3.67等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的， 但由于C++已经对运算符”+”进行了重载，所以就能适用于int, float, doUble类型的运算。\n\n又如”<<“是C++的位运算中的位移运算符（左移），但在输出操作中又是与流对 象cout 配合使用的流插入运算符，”>>“也是位移运算符(右移），但在输入操作中又是与流对象 cin 配合使用的流提取运算符。这就是运算符重载(operator overloading)。C++系统对”<<“和”>>“进行了重载，用户在不同的场合下使用它们时，作用是不同 的。对”<<“和”>>“的重载处理是放在头文件stream中的。因此，如果要在程序中用”<< “和”>>”作流插入运算符和流提取运算符，必须在本文件模块中包含头文件stream(当然还应当包括”using namespace std“)。\n\n现在要讨论的问题是：用户能否根据自己的需要对C++已提供的运算符进行重载，赋予它们新的含义，使之一名多用。？\n\n**2.运算符重载入门技术推演**\n\n1为什么会用运算符重载机制\n\n  用复数类举例\n\n//Complex c3 = c1 + c2;\n\n//原因 Complex是用户自定义类型，编译器根本不知道如何进行加减\n\n //编译器给提供了一种机制，让用户自己去完成，自定义类型的加减操作。。。。。\n\n //这个机制就是运算符重载机制\n\n2 运算符重载的本质是一个函数\n```cpp\n\n\n/*对于基础数据类型，C++编译器知道如何进行运算，但是对于用户自定义的类型编译器提供了一种\n让自定义数据类型进行运算符操作的机制,=》运算符重载机制\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\n\npublic:\n\tint a;\n\tint b;\n\n\tfriend Complex operator+(Complex &c1, Complex &c2);\n\npublic:\n\n\tComplex(int a = 0, int b = 0)\n\n\t{\n\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\n\t}\n\npublic:\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\nprivate:\n\n};\n\n/*使用全局函数，通过调用全局函数实现\n\nComplex myAdd(Complex &c1, Complex &c2)\n{\n\n Complex tmp(c1.a+ c2.a, c1.b + c2.b);\n\n return tmp;\n\n}\n\n*/\n\n\n//可以想象为将函数名替换为operator+\nComplex operator+(Complex &c1, Complex &c2)\n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\n\treturn tmp;\n}\n\nvoid main()\n{\n\tComplex c1(1, 2), c2(3, 4);\n\n\t//方法1： 通过调用普通函数实现\n\n\t//Complex c3 = myAdd(c1, c2);\n\n\t//c3.printCom();\n\n\n\n\n\n\t//方法2  将函数名称替换为：operator+ \n\t//使用以下方式进行调用\n\n\t//Complex c3 = operator+(c1, c2);\n\t//c3.printCom();\n\n\n\t//最常用的调用方式\n\n\tComplex c3 = c1 + c2; \n\tc3.printCom();\n\n\n\t//4 把Complex类变成私有属性\n\n\t//友元函数的应用场景\n\n\t//friend Complex operator+(Complex &c1, Complex &c2);\n\n\tsystem(\"pause\");\n\n\treturn;\n\n}\n```\n\n\n---\n\n### （二）运算符重载的限制\n![12]($resource/12.png)\n![13]($resource/13.png)\n\n---\n\n### （三）运算符重载编程基础\n![14]($resource/14.png)\n例如:\n\n //全局函数  完成 +操作符  重载\n\nComplex operator+(Complex &c1, Complex &c2)\n \n//类成员函数  完成 -操作符  重载\n\nComplex operator-(Complex &c2)\n\n**运算符重载的两种方法**\n![15]($resource/15.png)\n![16]($resource/16.png)\n例如1:\n\n//通过类成员函数完成-操作符重载\n\n//函数声明 Complex operator-(Complex &c2)\n\n//函数调用分析\n\n//用类成员函数实现-运算符重载\n\n Complex c4 = c1 - c2;\n\n c4.printCom();\n\n //c1.operator-(c2);\n\n例如2:\n\n//通过全局函数方法完成+操作符重载\n\n//函数声明 Complex operator+(Complex &c1, Complex &c2)\n\n//函数调用分析\n\nint main()\n\n{\n\n Complex c1(1, 2), c2(3, 4);\n\n //Complex c31 = operator+(c1, c2);\n\nComplex c3 = c1 + c2;\n\nc3.printCom();\n\n}\n\n例如3: 学员自己练习  实现 * /\n![17]($resource/17.png)\n例如3\n\n//前置++操作符 用全局函数实现\n\nComplex& operator++(Complex &c1)\n\n{\n\n c1.a ++;\n\n c1.b ++;\n\n return c1;\n\n}\n\n//调用方法\n\n ++c1 ; //=è需要写出操作符重载函数原形\n\n c1.printCom();\n\n//运算符重载函数名定义\n\n //首先承认操作符重载是一个函数 定义函数名èoperator++\n\n //分析函数参数 根据左右操作数的个数,èoperator++(Complex &c1)\n\n //分析函数返回值è Complex& operator++(Complex &c1) 返回它自身\n\n例如4\n\n//4.1前置—操作符 成员函数实现\n\nComplex& operator--()\n\n{\n\n this->a--;\n\n this->b--;\n\n return *this;\n\n}\n\n //4.2调用方法\n\n --c1;\n\n c1.printCom();\n\n //4.3前置—运算符重载函数名定义\n\n //c1.operator--()\n\n例如5\n\n //5.1 //后置++ 操作符 用全局函数实现\n\nComplex operator++(Complex &c1, int)\n\n{\n\n Complex tmp = c1;\n\n c1.a++;\n\n c1.b++;\n\n return tmp;\n\n}\n\n//5.2 调用方法\n\nc1 ++ ; //先使用 后++\n\n//5.3 后置++运算符重载函数名定义\n\n Complex operator++(Complex &c1, int) //函数占位参数 和 前置++ 相区别\n\n例如6\n\n//6.1 后置— 操作符 用类成员函数实现\n\n Complex operator--(int)\n\n {\n\n Complex tmp = *this;\n\n this->a--;\n\n this->b--;\n\n return tmp;\n\n }\n\n//6.2 调用方法\n\nc1 ++ ; //先使用 后++\n\n//6.3 后置--运算符重载函数名定义\n\n Complex operator--(int) //函数占位参数 和 前置-- 相区别\n\n前置和后置运算符总结\n\n**C++****中通过一个占位参数来区分前置运算和后置运算**\n![18]($resource/18.png)\n**定义运算符重载函数名的步骤**\n\n全局函数、类成员函数方法实现运算符重载步骤\n\n 1）要承认操作符重载是一个函数，写出函数名称operator+ ()\n\n 2）根据操作数，写出函数参数\n\n 3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n\n**友元函数实现操作符重载的应用场景**\n\n**1****）友元函数和成员函数选择方法**\n\nØ 当无法修改左操作数的类时，使用全局函数进行重载\n\nØ =, [], ()和->操作符只能通过成员函数进行重载\n\n**2****）用友元函数** **重载 << >>****操作符**\n\nØ istream 和 ostream 是 C++ 的预定义流类\n\nØ cin 是 istream 的对象，cout 是 ostream 的对象\n\nØ 运算符 << 由ostream 重载为插入操作，用于输出基本类型数据\n\nØ 运算符 >> 由 istream 重载为提取操作，用于输入基本类型数据\n\nØ 用友员函数重载 << 和 >> ，输出和输入用户自定义的数据类型\n\na）用全局函数方法实现 << 操作符\n\nostream& operator<<(ostream &out, Complex &c1)\n\n{\n\n //out<<\"12345，生活真是苦\"<<endl;\n\n out<<c1.a<<\" + \"<<c1.b<<\"i \"<<endl;\n\n return out;\n\n}\n\n//调用方法\n\ncout<<c1;\n\n//链式编程支持\n\ncout<<c1<<\"abcc\";\n\n//cout.operator<<(c1).operator<<(\"abcd\");\n\n//函数返回值充当左值 需要返回一个引用\n\nb）类成员函数方法无法实现 << 操作符重载\n\n //因拿到cout这个类的源码\n\n //cout.operator<<(c1);\n\n**3）** **友元函数重载操作符使用注意点**\n\na） 友员函数重载运算符常用于运算符的左右操作数类型不同的情况\n\nb）其他\n\nØ 在第一个参数需要隐式转换的情形下，使用友员函数重载运算符是正确的选择\n\nØ  友员函数没有 this 指针，所需操作数都必须在参数表显式声明，很容易实现类型的隐式转换\n\nØ  C++中不能用友员函数重载的运算符有\n\n = （）  ［］  －>\n\n**4** **）友元函数案例vector****类**\n\n| \n\n#include <iostream>\n\nusing namespace std;\n\n//为vector类重载流插入运算符和提取运算符\n\nclass vector\n\n{\n\npublic :\n\n vector( int size =1 ) ;\n\n ~vector() ;\n\n int & operator[]( int i ) ;\n\n friend ostream & operator << ( ostream & output , vector & ) ;\n\n friend istream & operator >> ( istream & input, vector & ) ;\n\nprivate : \n\n int * v ;\n\n int len ;\n\n};\n\nvector::vector( int size )\n\n{\n\n if (size <= 0 || size > 100 )\n\n {\n\n cout << \"The size of \" << size << \" is null !\\n\" ; abort() ;\n\n }\n\n v = new int[ size ] ; len = size ;\n\n}\n\nvector :: ~vector()\n\n{\n\n delete[] v ;\n\n len = 0 ;\n\n}\n\nint &vector::operator[]( int i )                \n\n{\n\n if( i >=0 && i < len ) return v[ i ] ;\n\n cout << \"The subscript \" << i << \" is outside !\\n\" ; abort() ;\n\n}\n\nostream & operator << ( ostream & output, vector & ary )\n\n{\n\n for(int i = 0 ; i < ary.len ; i ++ )\n\n output << ary[ i ] << \" \" ;\n\n output << endl ;\n\n return output ;\n\n}\n\nistream & operator >> ( istream & input, vector & ary )\n\n{\n\n for( int i = 0 ; i < ary.len ; i ++ )\n\n input >> ary[ i ] ;\n\n return input ;\n\n}\n\nvoid main()\n\n{\n\n int k ;\n\n cout << \"Input the length of vector A :\\n\" ;\n\n cin >> k ;\n\n vector A( k ) ;\n\n cout << \"Input the elements of vector A :\\n\" ;\n\n cin >> A ;\n\n cout << \"Output the elements of vector A :\\n\" ;\n\n cout << A ;\n\n system(\"pause\");\n\n}\n\n |\n\n### （四）运算符重载提高\n\n**1****运算符重载机制**\n\nC++编译器是如何支持操作符重载机制的?\n\n**2****重载赋值运算符****=**\n\nØ 赋值运算符重载用于对象数据的复制\n\nØ operator= 必须重载为成员函数\n\nØ 重载函数原型为：\n\n  **_类型_ &** **_类名_ :: operator= ( const** **_类名_ & ) ;**\n\n案例：完善Name类，支持=号操作。\n\n  结论:\n\n 1 //先释放旧的内存\n\n 2 返回一个引用\n\n 3 =操作符 从右向左\n\n| \n\n //obj3 = obj1; // C++编译器提供的  等号操作  也属  浅拷贝\n\n// obj4 = obj3 = obj1\n\n //obj3.operator=(obj1)\n\n Name& operator=(Name &obj1)\n\n {\n\n //1 先释放obj3旧的内存\n\n if (this->m_p != NULL)\n\n {\n\n delete[] m_p;\n\n m_len = 0;\n\n }\n\n //2 根据obj1分配内存大小\n\n this->m_len = obj1.m_len;\n\n this->m_p = new char [m_len+1];\n\n //3把obj1赋值给obj3\n\n strcpy(m_p, obj1.m_p);\n\n return *this;\n\n }\n\n |\n\n**3****重载数组下表运算符****[]**\n\n重载[]和()运算符\n\nØ 运算符 [] 和 () 是二元运算符\n\nØ [] 和 () 只能用成员函数重载，不能用友元函数重载\n\n**_重载下标运算符 []_**\n\n[] 运算符用于访问数据对象的元素\n\n重载格式  _类型_ **_类_** :: operator[] ( _类型_ ) ；\n\n设 x 是类 X 的一个对象，则表达式\n\n **x [ y ]**\n\n  可被解释为\n\n **x . operator [ ] ( y )**\n\n**4****重载函数调用符** **()**\n\n() 运算符用于函数调用\n\n重载格式  _类型_ _类_ :: operator() ( _表达式表_ ) ；\n\n**_例1_**\n\n**设 x** **是类 X** **的一个对象，则表达式**\n\n **x ( arg1, arg2, … )**\n\n**可被解释为**\n\n **x . operator () (arg1, arg2, … )**\n\n案例：\n\n**_//_****_例2_****_：用重载()_****_运算符实现数学函数的抽象_**\n\n#include <iostream>\n\nclass F\n\n { public :\n\n double operator ( )  ( double x , double y ) ;\n\n } ;\n\ndouble F :: operator ( )  ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\nf.getA();\n\n cout << f ( 5.2 , 2.5 ) << endl ; // **f . _operator()_ (5.2, 2.5)**\n\n}\n\n比较普通成员函数\n\n**_//_****_例3_** **_用重载()_****_运算符实现 pk_** **_成员函数_**\n\n#include <iostream.h>\n\nclass F\n\n { public :\n\n double **memFun** ( double x , double y ) ;\n\n } ;\n\ndouble F :: **memFun** ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\n cout << f.**memFun** ( 5.2 , 2.5 ) << endl ;\n\n}\n\n**5****为什么不要重载****&&****和****||****操作符**\n\n理论知识：\n\n1）&&和||是C++中非常特殊的操作符\n\n2）&&和||内置实现了短路规则\n\n3）操作符重载是靠函数重载来完成的\n\n4）操作数作为函数参数传递\n\n5）C++的函数参数都会被求值，无法实现短路规则\n\n| \n\n#include <cstdlib>\n\n#include <iostream>\n\nusing namespace std;\n\nclass Test\n\n{\n\n int i;\n\npublic:\n\n Test(int i)\n\n {\n\n this->i = i;\n\n }\n\n Test operator+ (const Test& obj)\n\n {\n\n Test ret(0);\n\n cout<<\"执行+号重载函数\"<<endl;\n\n ret.i = i + obj.i;\n\n return ret;\n\n }\n\n bool operator&& (const Test& obj)\n\n {\n\n cout<<\"执行&&重载函数\"<<endl;\n\n return i && obj.i;\n\n }\n\n};\n\n// && 从左向右\n\nvoid main()\n\n{\n\n int a1 = 0;\n\n int a2 = 1;\n\n cout<<\"注意：&&操作符的结合顺序是从左向右\"<<endl;\n\n if( a1 && (a1 + a2) )\n\n {\n\n cout<<\"有一个是假，则不在执行下一个表达式的计算\"<<endl;\n\n }\n\n Test t1 = 0;\n\n Test t2 = 1;\n\n If ( t1 && (t1 + t2) )\n\n {\n\n=è\n\n T1.operator&&( t1 + t2) )\n\nT1.operator&&( t1.operator+(t2) )\n\n //t1 && t1.operator+(t2)\n\n // t1.operator( t1.operator(t2) )\n\n cout<<\"两个函数都被执行了，而且是先执行了+\"<<endl;\n\n }\n\n system(\"pause\");\n\n return ;\n\n}\n\n\n### （五）运算符重载在项目开发中的应用\n\n**1实现一个数组类**\n\n添加<< >>\n\n**2实现一个字符串类**\n\n构造函数要求\n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串类 以零结尾的字符串\n\n//若len为0,表示空串\n\nMyString a; //空串 “”\n\nMyString a(“dddd”);\n\nMyString b = a;\n\nb = “aaaaaa” \n\nb = a;\n\nif (a > b)\n\nif (a == b)\n\nb[i] = ‘a’;\n\n常用的操作符\n\n<< >> != == > < =\n\n| \n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串 以零结尾的字符串\n\nclass MyString\n\n{\n\n friend ostream& operator<<(ostream &out, const MyString &s);\n\npublic: //构造和析构\n\n MyString(int len = 0);\n\n MyString(const char *p);\n\n MyString(const MyString& obj);\n\n ~MyString();\n\npublic: //操作符重载\n\n MyString& operator=(const char *p);\n\n MyString& operator=(const MyString& obj);\n\n char& operator[](int index) const;\n\npublic:\n\n bool operator==(const char* p) const;\n\n bool operator!=(const char* p) const;\n\n bool operator==(const MyString& s) const;\n\n bool operator!=(const MyString& s) const;\n\npublic: //string to c\n\n char *c_str();\n\n const char* c_str() const;\n\n int length()\n\n {\n\n return m_len;\n\n }\n\npublic:\n\n int operator<(const char *p);\n\n int operator>(const char *p);\n\n int operator<(const MyString &s);\n\n int operator>(const MyString &s);\n\nprivate:\n\n int m_len;\n\n char  *m_p;\n\n};\n\n |\n\n**3****智能指针类编写**\n\n1问题抛出\n\n  指针使用过程中，经常会出现内存泄漏和内存多次被释放常\n\n2 解决方案：例如：boost库的智能指针\n\n  项目开发中，要求开发者使用预先编写的智能指针类对象代替C语言中的原生指针\n\n3 智能指针思想\n\n工程中的智能指针是一个类模板\n\n  通过构造函数接管申请的内存\n\n  通过析构函数确保堆内存被及时释放\n\n  通过重载指针运算符* 和 -> 来模拟指针的行为\n\n  通过重载比较运算符 == 和 != 来模拟指针的比较\n\n| \n\nclass Test\n\n{\n\npublic:\n\n Test()\n\n {\n\n this->a = 10;\n\n }\n\n void printT()\n\n {\n\n cout<<a<<endl;\n\n }\n\nprivate:\n\n int a;\n\n};\n\nclass MyTestPointer\n\n{\n\npublic:\n\npublic:\n\n MyTestPointer()\n\n {\n\n p = NULL;\n\n }\n\n MyTestPointer(Test* p)\n\n {\n\n this->p = p;\n\n }\n\n ~MyTestPointer()\n\n {\n\n delete p;\n\n }\n\n Test* operator->()\n\n {\n\n return p;\n\n }\n\n Test& operator*()\n\n {\n\n return *p;\n\n }\n\nprotected:\n\n Test *p;\n\n};\n\nvoid main01_classp()\n\n{\n\n Test *p = new Test;\n\n p->printT();\n\n delete p;\n\n MyTestPointer myp = new Test; //构造函数\n\n myp->printT(); //重载操作符 ->\n\n};\n\n |\n\n| \n\nclass MyIntPointer\n\n{\n\npublic:\n\npublic:\n\n MyIntPointer()\n\n {\n\n p = NULL;\n\n }\n\n MyIntPointer(int* p)\n\n {\n\n this->p = p;\n\n }\n\n ~MyIntPointer()\n\n {\n\n delete p;\n\n }\n\n int* operator->()\n\n {\n\n return p;\n\n }\n\n int& operator*()\n\n {\n\n return *p;\n\n }\n\nprotected:\n\n int *p;\n\n};\n\nvoid main02_intp()\n\n{\n\n int *p = new int(100);\n\n cout<<*p<<endl;\n\n delete p;\n\n MyIntPointer myp = new int(200);\n\n cout<<*myp<<endl; //重载*操作符\n\n};\n\n |\n\n**8.7****附录：运算符和结合性**\n\n总结\n\n操作符重载是C++的强大特性之一\n\n操作符重载的本质是通过函数扩展操作符的语义\n\noperator关键字是操作符重载的关键\n\nfriend关键字可以对函数或类开发访问权限\n\n操作符重载遵循函数重载的规则\n\n操作符重载可以直接使用类的成员函数实现\n\n=, [], ()和->操作符只能通过成员函数进行重载\n\n++操作符通过一个int参数进行前置与后置的重载\n\nC++中不要重载&&和||操作符\n\n\n\n\n\n\n\n\n\n\n\n",[[1543557049479,["gjx16@GJXAIOU",[[1,34760,"\n"]],[34759,34759],[34760,34760]]],[1543557065883,["gjx16@GJXAIOU",[[1,34810,"\n"]],[34809,34809],[34810,34810]]],[1543557077259,["gjx16@GJXAIOU",[[-1,34827,"//首先友元函数是全局函数，在友元函数中可以修改类的私有属性\n//友元函数在类中的声明位置位于public或者private只下均可；"]],[34827,34894],[34827,34827]]],[1543557079492,["gjx16@GJXAIOU",[[-1,34828,"\n"]],[34828,34828],[34827,34827]]],[1543557080013,["gjx16@GJXAIOU",[[-1,34827,"\n"]],[34827,34827],[34826,34826]]],[1543557085300,["gjx16@GJXAIOU",[[1,34787,"//首先友元函数是全局函数，在友元函数中可以修改类的私有属性\n//友元函数在类中的声明位置位于public或者private只下均可；"]],[34787,34787],[34854,34854]]],[1543557088215,["gjx16@GJXAIOU",[[-1,34787,"//"],[1,34789,"-"]],[34787,34787],[34788,34788]]],[1543557088911,["gjx16@GJXAIOU",[[1,34788," "]],[34788,34788],[34789,34789]]],[1543557091227,["gjx16@GJXAIOU",[[-1,34818,"//"],[1,34820,"-"]],[34818,34818],[34819,34819]]],[1543557091831,["gjx16@GJXAIOU",[[1,34819," "]],[34819,34819],[34820,34820]]],[1543557095500,["gjx16@GJXAIOU",[[1,34817,"；"]],[34817,34817],[34818,34818]]],[1543557103548,["gjx16@GJXAIOU",[[-1,35392,"**"]],[35392,35394],[35392,35392]]],[1543557105629,["gjx16@GJXAIOU",[[1,35382,"\n"]],[35381,35381],[35382,35382]]],[1543557109267,["gjx16@GJXAIOU",[[-1,35395,"Ø "]],[35397,35397],[35395,35395]]],[1543557111359,["gjx16@GJXAIOU",[[1,35395,"- "]],[35395,35395],[35397,35397]]],[1543557120700,["gjx16@GJXAIOU",[[-1,35429,"Ø "],[1,35431,"-"]],[35429,35429],[35430,35430]]],[1543557121230,["gjx16@GJXAIOU",[[1,35430," "]],[35430,35430],[35431,35431]]],[1543557126841,["gjx16@GJXAIOU",[[1,35428,"- \n"]],[35427,35427],[35430,35430]]],[1543557143162,["gjx16@GJXAIOU",[[1,35430,"若"]],[35430,35430],[35431,35431]]],[1543558049350,["gjx16@GJXAIOU",[[1,35431,"B类是A类的友元类，则B类可以直接修改A的成员变量和成员函数"]],[35431,35431],[35461,35461]]],[1543558053452,["gjx16@GJXAIOU",[[-1,35462,"\n"]],[35462,35462],[35461,35461]]],[1543558057581,["gjx16@GJXAIOU",[[1,35492,"- \n"]],[35491,35491],[35494,35494]]],[1543558058242,["gjx16@GJXAIOU",[[-1,35493," "]],[35494,35494],[35493,35493]]]],null,"gjx16@GJXAIOU"],["ae8745e5-4061-48c4-b2f6-a104b2e75f89",1543558344383,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁;\n   * c++面向对象模型初探;  \n   * c++面向对象多态原理探究;\n   * 操作符重载;\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;//定义两个对象c1和c2\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n};\n\n```\nTeacher.cpp\n//具体实现函数内容，在函数名前面加上`类名::`\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1:设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)//因为类的成员变量这里都是private:\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n###  (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n###  (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//需要重载=号操作符，才能解决带来的浅拷贝问题\n\n\tobj2 = obj3; //=号操作，也是一种浅拷贝\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++的默认copy构造函数是浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n\n---\n\n\n### （五）多个对象构造和析构\n\n**1.对象初始化列表**\n\n- 1）对象初始化列表出现原因\n程序本身是有问题的\n```cpp\n\n/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B   //在一个类里面组合了一个带有参数的构造函数的类，因为C++编译器要确定分配给B多大的内存，但是没法初始化A定义的两个对象（因为需要调用有参的构造函数）\n{\npublic:   //没有写B的构造函数，按理说应该调用默认的构造函数\n\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  //主要是因为没有方法和没有机会去初始化这两个A定义的对象\n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB;\n\treturn 0;\n\n}\n\n```\n\n解决方法：\n```cpp\n/*\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n};\n\n\nclass B  \n{\npublic:   \n//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）\n\tB(int _a, int _b) : a1(1), a2(3)  \n\t{\n\n\t}\n//第二种参数传递的方法：\n/*\nB(int _a, int _b,int m,int n) : a1(m), a2(n)  \n\t{\n      a = _a;\n      b = _b;\n\t}\n\t\n*/\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  \n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB(1,2);\n\t//第二种方式：B objB(1,2,4,3)\n\treturn 0;\n\n}\n\n```\n\n**以上程序的操作顺序：**\n首先执行被组合对象的构造函数（a1,a2），如果有多个组合对象，则按照定义的顺序，而不是按照初始化列表的顺序（：后面的顺序）\n析构函数：和构造函数的调用顺序相反\n\n  - 1.必须这样做：\n    - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    - 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n  - 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    - 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    - 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n- 2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n```cpp\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n{\n // some other assignment operation\n}\n```\n\n\n- 3）注意概念\n  - 初始化：被初始化的对象正在创建\n  - 赋值：被赋值的对象已经存在\n\n- 4）注意：\n  - 成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n  - 初始化列表先于构造函数的函数体执行\n\n**说明：**\n\n* 1 C++中提供了初始化列表对成员变量进行初始化\n* 2 使用初始化列表出现原因：\n  * 1.必须这样做：\n    * 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n    * 而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    * 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n  * 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    * 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    * 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n```cpp\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n ABC(int a, int b, int c)\n {\n this->a = a;\n this->b = b;\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"ABC construct ..\\n\");\n }\n\n ~ABC()\n {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n }\n\nprotected:\nprivate:\n int a;\n int b;\n int c;\n};\n\nclass MyD\n{\npublic:\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n {\n cout<<\"MyD()\"<<endl;\n }\n\n ~MyD()\n {\n cout<<\"~MyD()\"<<endl;\n }\n\nprotected:\nprivate:\n ABC abc1; //c++编译器不知道如何构造abc1\n ABC abc2;\n const int m;\n};\n\nint run()\n{\n MyD myD;\n return 0;\n}\n\nint main_dem03()\n{\n run();\n system(\"pause\");\n return 0;\n}\n\n```\n\n\n\n\n### （六）构造函数和析构函数的调用顺序研究\n\n**构造函数与析构函数的调用顺序**\n\n- 1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n- 2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n### （七）构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1构造析构综合训练**\n```cpp\n\n/*\n\n总结 构造和析构的调用顺序\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n\tABC(int a, int b, int c)   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\n\t}\n\n\t~ABC()\n\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\n\nclass MyD \n{\npublic:\n\tMyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~MyD()\n\t{\n\t\tcout << \"~MyD()\" << endl;\n\t}\n\n\tMyD(const MyD & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\tcout << \"MyD(const MyD &obj)\" << endl;\n\t}\n\nprotected:\nprivate:\n\tABC abc1; //c++编译器不知道如何构造abc1//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\tABC abc2;\n\tconst int m;//因为是const m,所以上面所有的m都进行了赋值\n};\n\n\nint doThing(MyD myel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;\n}\n\n\nint run2()//二\n{\n\tMyD myD;//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\treturn 0;\n}\n\nint run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main()\n{\n\trun2();//一\n\t//run3();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n\n\n```\n\n\n**2匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3匿名对象强化训练**\n\n3） 构造中调用构造\n\n```cpp\n/*\n\n构造中调用构造\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass MyTest\n{\npublic:\n\tMyTest(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t}\n\n\tMyTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\n\t\tMyTest(a, b, 10);\n\t}\n\n\t~MyTest()\n\t{\n\t\tcout << \"MyTest is ...\" << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n\n\npublic:\n\tint getC() const { return c; }\n\n\tvoid setC(int val) { c = val; }\n};\n\nint main()\n{\n\tMyTest t1(1, 2);\n\tcout << t1.getC() << endl;\n\tsystem(\"pause\");\n\treturn 0;\n\t\n}\n\n\n```\n\n 结论： 构造函数中调用构造函数，是一个蹩脚的行为。\n程序内存图：\n![搜狗截图20181124125452]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181124125452.png)\n\n### （八）对象的动态建立和释放\n\n**1.new和delete基本语法**\n```cpp\n/*\n\nnew 和delete的使用\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nvoid main()\n{\n\t//先分配内存然后赋值\n\tint *p = new int;  //分配基础类型\n\t*p = 20;  \n\n\t//在定义的时候直接分配内存\n\tint *p1 = new int(30);\n\tcout << *p1 << endl;\n\n\tsystem(\"pause\");\n\treturn; \n}\n\n```\n\n- 1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n  **注意： new和delete是运算符，不是函数，因此执行效率高。**\n\n- 2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： \nnew int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 \nnew char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址    new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n- 3）new和delete运算符使用的一般格式为：\n  用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n![new运算符动态]($resource/new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%A8%E6%80%81.png)\n```cpp\n\n/*\n使用malloc /free 与new /delete的区别\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest();\n\t~Test();\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\nTest::Test()\n{\n\tcout << \"执行了构造函数\" << endl;\n}\n\nTest::~Test()\n{\n\tcout << \"执行了析构函数\" << endl;\n}\n\n\n\nint main()\n{\n\t//基础类型\n\tint *p1 = (int *)malloc(sizeof(int));\n\t*p1 = 10;\n\tdelete p1;\n\n\tint *p2 = new int;\n\t*p2 = 20;\n\tfree(p2);\n\n\n\n\t//数组类型（元素为基础类型）\n\tint *p3 = (int *)malloc(sizeof(int)*10);\n\tp3[0] = 1;\n\tdelete[]p3;\n\n\tint *p4 = new int[10];\n\tp4[1] = 2;\n\tfree(p4);\n\n\n\t//类\n\tTest *p5 = (Test *)malloc(sizeof(Test));\n\tdelete p5;\n\n\tTest *p6 = new Test(10);\n\tfree(p6);\n}\n\n\n```\n**结论：** \nnew：不仅分配内存，而且调用了构造函数\ndelete:不仅释放了内存，而且调用了析构函数\n\n- 4） 应用举例\n\n![5]($resource/5.png)\n\n**2类对象的动态建立和释放**\n\n- 使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n-  C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n  比如：\n\n  Box *pt;  //定义一个指向Box类对象的指针变量pt\n      pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n   这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n  新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n   在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3.编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n\n\n\n## 四、静态成员变量和成员函数\n\n\n思考：每个变量，拥有属性。有没有一些属性，归所有对象拥有？\n\n### （一）静态成员变量\n\n- **1定义静态成员变量**\n  - 关键字 **static**  可以用于说明一个类的成员，\n    静态成员提供了一个同类对象的共享机制\n\n  - 把一个类的成员说明为 **static**  时，这个类无论有多少个对象被创建，这些对象共享这个 **static**  成员\n\n  - 静态成员局部于类，它不是对象成员\n\n![1]($resource/1.png)\n\n例如：\n\n```cpp\n\n/*\n静态成员变量\n*/\n\n#include<iostream>\nusing namespace std;\n\nclass counter\n{\n\n\tstatic int num; //**声明与定义静态数据成员**\n\npublic:\n\n\tvoid setnum(int i) \n\t{ \n\t\tnum = i; \n\t} //成员函数访问静态数据成员\n\n\tvoid shownum() \n\t{ \n\t\tcout << num << endl;\n\t}\n\n};\n\nint counter::num = 0;//声明与定义静态数据成员\n\nvoid main()\n{\n\tcounter a, b;\n\n\ta.shownum(); //调用成员函数访问私有静态数据成员\n\tb.shownum();\n\ta.setnum(10);\n\ta.shownum();\n\tb.shownum();\n\n}\n\n```\n\n![6]($resource/6.png)\n\n**从结果可以看出，访问的是同一个静态数据成员**\n\n- **2使用静态成员变量**\n```cpp\n//例5-14_使用公有静态数据成员\n\n#include<iostream.h>\n\nclass counter\n{ \npublic :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n\n```\n使用静态成员函数调用静态成员变量\n```cpp\n/*\n静态成员函数\n*/\n// 结论：在静态成员函数中可以使用静态成员变量，但是不能使用类中普通的成员变量\n\n#include\"iostream\"\nusing namespace std;\n\nclass BB\n{\npublic:\n\tint printC()\n\t{\n\t\tcout << \"c:\" << c << endl;\n\t\treturn c;\n\t}\n\n\tint addC()\n\t{\n\t\tc = c+1;\n\t}\n\n\n\tstatic void getC()\n\t{\n\t\tcout << \"c\" << c << endl;  //可以直接在静态成员函数中使用静态成员变量，但是不能直接使用一般变量\n\t}\nprivate:\n\tint a;\n\tint b;\n\tstatic int c;\n\n};\n\n\nint BB::c = 10;  //初始化成员变量值\n\nvoid main()\n{\n\tBB b1, b2, b3;\n\tb1.printC();//10\n\tb2.addC();//11\n\tb3.printC();//11\n\n\t//调用成员函数两种方法；\n\tb3.getC();//使用对象.\n\tBB::getC();//使用类::\n\n\n\n}\n\n```\n\n### (二)静态成员函数\n\n- **1）概念**\n\n  - 静态成员函数数冠以关键字static\n\n  - 静态成员函数提供不依赖于类数据结构的共同操作，它没有this指针\n  - 在类外调用静态成员函数用 `_类名_ ::`作限定词，或通过对象调用\n\n- **2）案例**\n![7]($resource/7.png)\n\n- **3）疑难问题：**\n静态成员函数中，不能使用普通变量。\n//静态成员变量属于整个类的，分不清楚，是那个具体对象的属性。\n![成员函数中的疑难问题]($resource/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98.png)\n\n**4.3 综合训练**\n\n\n\n## 五、 C++面向对象模型初探\n\n**前言**\n\n- C++对象模型可以概括为以下2部分：\n\n  - 1. 语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等等。\n\n  - 2. 对于各种支持的底层实现机制。\n\n  在c语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。在c++中，通过抽象数据类型（abstract data type，ADT），在类中定义数据和函数，来实现数据和函数直接的绑定。\n\n  概括来说，在C++类中有两种成员数据：static、nonstatic；三种成员函数：static、nonstatic、virtual。\n\n![C++类的组成]($resource/C++%E7%B1%BB%E7%9A%84%E7%BB%84%E6%88%90.png)\n\n### （一）基础知识\n\nC++中的class从面向对象理论出发，将变量(属性)和函数(方法)集中定义在一起，用于描述现实世界中的类。从计算机的角度，程序依然由数据段和代码段构成。\n\n**C++编译器如何完成面向对象理论到计算机程序的转化？**\n换句话：C++编译器是如何管理类、对象、类和对象之间的关系\n具体的说：具体对象调用类中的方法，那，c++编译器是如何区分，是那个具体的类，调用这个方法那?\n\n思考一下程序结果\n```cpp\n/*\n面向对象模型初探\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass C1\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\nprotected:\n\nprivate:\n\n}; //12\n\nclass C2\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\n\tstatic int m; \n\npublic:\n\n\tint getK() const { return k; } //方法是属于代码，应该放在代码区\n\tvoid setK(int val) { k = val; } \n\nprotected:\n\nprivate:\n}; \n\nstruct S1\n{\n\tint i;\n\tint j;\n\tint k;\n}; \n\nstruct S2\n{\n\tint i;\n\tint j;\n\tint k;\n\tstatic int m;\n}; \n\nint main()\n{\n\n\tprintf(\"c1:%d \\n\", sizeof(C1));\n\tprintf(\"c2:%d \\n\", sizeof(C2));\n\tprintf(\"s1:%d \\n\", sizeof(S1));\n\tprintf(\"s2:%d \\n\", sizeof(S2));\n\tsystem(\"pause\");\n\n}\n```\n程序运行结果：\n`c1:12`\n`c2:12`\n`s1:12`\n`s2:12`\n\n \n### (二)编译器对属性和方法的处理机制\n\n通过上面的案例，我们可以的得出：\n1）C++类对象中的成员变量和成员函数是分开存储的\n- 成员变量：\n  - 普通成员变量：存储于对象中，与struct变量有相同的内存布局和字节对齐方式\n  - 静态成员变量：存储于全局数据区中\n\n- 成员函数：存储于代码段中。\n问题出来了：很多对象共用一块代码？代码是如何区分具体对象的那？\n换句话说：int getK() const { return k; }，代码是如何区分，具体obj1、obj2、obj3对象的k值？\n\n2）C++编译器对普通成员函数的内部处理\n\n![C++编译器对普通成员函数的内部处理]($resource/C++%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E9%83%A8%E5%A4%84%E7%90%86.png)\n\n请仔细思考，并说出你的总结！\n\n\n\n### （三）总结\n\n1、C++类对象中的成员变量和成员函数是分开存储的。C语言中的内存四区模型仍然有效！\n**2、C++中类的普通成员函数都隐式包含一个指向当前对象的this指针。**\n3、静态成员函数、成员变量属于类\n\n静态成员函数与普通成员函数的区别\n\n静态成员函数不包含指向具体对象的指针\n\n普通成员函数包含一个指向具体对象的指针\n\n\n### （四）this指针\n\n![this指针图示]($resource/this%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png)\n\n实验1：若类成员函数的形参 和 类的属性（成员变量）名字相同，通过this指针来解决。\n```cpp\n\n/*\nthis 指针\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass Test\n{\npublic:\n\tTest( int a, int b)//Test(Test *this, int a, int b)//因为这里成员函数的形参和成员变量一样，不用this指针会出现：a = a ,b = b;\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printT()\n\t{\n\t\tcout << \"a; \" << a << endl;\n\t\tcout << \"b: \" << this->b << endl;\n\t}\n\n\n    const void hello(int a,int b )\n    {\n      //下面这两个语句都是错误的\n      this->a = 100;\n      this ->b = 200;\n    }\n   //const修饰的this指针，即相当于this指针指向的内存空间不能被修改\n   //因为上面的函数会别C++编译器解析为:void hello(const Test *this, int a ,int b)\n   //同时上面的const其实下载函数（）外面的任何位置都行\n   \nprotected:\nprivate:\n\tint a;\n\tint b;\n};\nint  main()\n{\n\tTest t1(1, 2);\n\tt1.printT();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`a:1`\n`b:2`\n\n\n实验2：类的成员函数可通过const修饰，请问const修饰的是谁\n\n\n### （五）全局函数PK成员函数\n\n 1、把全局函数转化成成员函数，通过this指针隐藏左操作数\n\n   Test add(Test &t1, Test &t2)===》Test add( Test &t2)\n```cpp\n/*\n全局函数与成员函数\n*/\n\n\n//使用全局函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\t\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nTest Testadd(Test &t1, Test &t2)\n{\n\tTest tmp(3,4);\n\treturn tmp;\n}\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3(2, 3);\n\tt3= Testadd(t1, t2);\n}\n```\n\n```cpp\n//使用成员函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\tTest Testadd(Test &t2)\n\t{\n\t\tTest tmp(this->a + t2.a, this->b + t2.b);\n\t\treturn tmp;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3 = t1.Testadd(t2);//匿名对象直接转化成t4\n\tTest t4(3,5);\n\tt4 = t1.Testadd(t2);  //匿名对象复制给t5\n}\n\n\n```\n 2、把成员函数转换成全局函数，多了一个参数\n\n   void printAB()===》void printAB(Test *pthis)\n\n 3、函数返回元素和返回引用\n```cpp\nTest& add(Test &t2) //*this //函数返回引用,相当于返回自身，谁调用返回谁\n {      \n   this->a = this->a + t2.getA();\n\n   this->b = this->b + t2.getB();\n\n   return *this; //*操作让this指针回到元素状态\n\n }\n\nTest add2(Test &t2) //*this //函数返回元素\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n return t3;\n\n }\n\n void add3(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n //return t3;\n\n }\n  \n\n```\n\n\n\n\n---\n\n## 六、友元\n\n### （一）友元函数\n- 首先友元函数是全局函数，在友元函数中可以修改类的私有属性；\n- 友元函数在类中的声明位置位于public或者private只下均可；\n![8]($resource/8.png)\n\n```cpp\n//友元函数：\n\n#include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend void modify(A *PA,int _a);  //友元函数的声明\n\n\tA(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\n\nprivate:\n\tint a;\n\tint b;\n};\n\nvoid modify(A *PA,int _a)//后面的参数可加可不加\n{\n\t//PA->a = 100;//可以这样直接修改值\n\tPA->a = _a;  //通过传递的值进行修改\n}\n\n\nint main()\n{\n\tA a1(1, 2);\n\tcout << \"a:\" << a1.getA() << endl;\n\tmodify(&a1,20);\n\n\tint aa = a1.getA();\n\n\tcout << \"aa:\" << aa << endl;\n}\n```\n![9]($resource/9.png)\n\n\n### （二）友元类\n\n- 若B类是A类的友员类，则B类的所有成员函数都是A类的友员函数\n- 若B类是A类的友元类，则B类可以直接修改A的成员变量和成员函数\n- 友员类通常设计为一种对数据操作或类之间传递消息的辅助类\n-\n```cpp\n//友元类\n #include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend class B;//将B 声明为A的友元类，这样B 可以直接修改A的成员变量和成员函数 \n\n\tA(int a=0, int b=0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B\n{\npublic:\n\n\tvoid set(int a)\n\t{\n\t\tobjA.a = a;\n\t}\n\n\tvoid printa()\n\t{\n\t\tcout << objA.a << endl;\n\t}\n\nprivate:\n\tA objA;\n};\n\n\nint main()\n{\n\tB b1;\n\tb1.set(200);\n\tb1.printa();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：200\n\n![10]($resource/10.png)\n\n\n\n## 七、强化训练\n\n**1 static关键字强化训练题**\n\nØ 某商店经销一种货物。货物购进和卖出时以箱为单位，各箱的重量不一样，因此，商店需要记录目前库存的总重量。现在用C++模拟商店货物购进和卖出的情况。\n\n| \n\n#include \"iostream\"\n\nusing namespace std;\n\nclass Goods\n\n{\n\npublic :\n\n Goods ( int w) { weight = w ; total_weight += w ; }\n\n ~ Goods() { total_weight -= weight ; }\n\n int Weight() { return weight ; } ;\n\n static int TotalWeight() { return total_weight ; }\n\n Goods *next ;\n\nprivate :\n\n int weight ;\n\n static int total_weight ;\n\n} ;\n\nint Goods::total_weight = 0 ;\n\n//r尾部指针\n\nvoid purchase( Goods * &f, Goods *& r, int w )\n\n{\n\n Goods *p = new Goods(w) ;\n\n p -> next = NULL ;\n\n if ( f == NULL ) f = r = p ;\n\n else { r -> next = p ; r = r -> next ; } //尾部指针下移或新结点变成尾部结点\n\n}\n\nvoid sale( Goods * & f , Goods * & r )\n\n{\n\n if ( f == NULL ) { cout << \"No any goods!\\n\" ; return ; }\n\n Goods *q = f ; f = f -> next ; delete q ;\n\n cout << \"saled.\\n\" ;\n\n}\n\nvoid main()\n\n{\n\n Goods * front = NULL , * rear = NULL ;\n\n int w ; int choice ;\n\n do\n\n {\n\n cout << \"Please choice:\\n\" ;\n\n cout << \"Key in 1 is purchase,\\nKey in 2 is sale,\\nKey in 0 is over.\\n\" ;\n\n cin >> choice ;\n\n switch ( choice ) // 操作选择\n\n {\n\n case 1 : // 键入1，购进1箱货物\n\n { cout << \"Input weight: \" ;\n\n cin >> w ;\n\n purchase( front, rear, w ) ; // 从表尾插入1个结点\n\n break ;\n\n }\n\n case 2 :              // 键入2，售出1箱货物\n\n { sale( front, rear ) ; break ; } // 从表头删除1个结点\n\n case 0 : break ;              // 键入0，结束\n\n }\n\n cout << \"Now total weight is:\" << Goods::TotalWeight() << endl ;\n\n } while ( choice ) ;\n\n}\n\n |\n\n**2** **数组类封装**\n\n目标：解决实际问题，训练构造函数、copy构造函数等，为操作符重载做准备\n\n\n\n数组类的头文件\n\n```cpp\n#pragma once\nclass Array\n{\npublic:\n\tArray(int length);\n\tArray(const Array&obj);\n\t~Array();\npublic:\n\tint length();\n\n\tvoid setData(int index, int value);\n\n\tint getData(int index);\nprivate:\n\tint m_length;\n\tchar *m_space;\n};\n```\n\n数组类的头文件的实现：\n```cppp\n#include \"Array.h\"\nusing namespace std;\n#include\"iostream\"\n\nArray::Array(int length)\n{\n\tif (length < 0)\n\t{\n\t\tlength = 0;\n\t}\n\telse\n\t{\n\t\tm_length = length;\n\t\tm_space = new char[m_length];\n\t}\n}\n\nArray::Array(const Array&obj)\n{\n   this->m_length = obj.m_length;\n   this->m_space = new char [this->m_length];//进行分配内存空间\n\n  for(int i= 0; i < obj.m_length;i++)//数组元素复制， 这里的obj.m_length可以直接替换成m_length\n  {\n    this->m_space[i] = obj.m_space[i];\n  }\n}\n\nArray::~Array()\n{\n\tif (m_space != NULL)\n\t{\n\t\tdelete[] m_space;\n\t\tm_length = 0;\n\t}\n}\n\nvoid Array::setData(int index, int valude)\n{\n\tm_space[index] = valude;\n}\n\nint Array::getData(int index)\n{\n\treturn m_space[index];\n}\n\nint Array::length()\n{\n\treturn m_length; \n}\n```\n\n数组类的测试\n```cpp\n#include \"iostream\"\n#include \"Array.h\"\nusing namespace std;\n\nint main()\n{\n\tArray a1(10);\n\tfor (int i = 0; i < a1.length(); i++)\n\t{\n\t\ta1.setData(i, i);\n\t}\n\tfor (int i = 0; i <  a1.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a1.getData(i));\n\t}\n\n\tArray a2 = a1;\n\n\tfor (int i = 0; i < a2.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a2.getData(i));\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**3****小结**\n\nØ 类通常用关键字class定义。类是数据成员和成员函数的封装。类的实例称为对象。\n\nØ 结构类型用关键字struct定义，是由不同类型数据组成的数据类型。\n\nØ  类成员由private, protected, public决定访问特性。public成员集称为接口。\n\nØ  构造函数在创建和初始化对象时自动调用。析构函数则在对象作用域结束时自动调用。\n\nØ  重载构造函数和复制构造函数提供了创建对象的不同初始化方式。\n\nØ  静态成员是局部于类的成员，提供一种同类对象的共享机制。\n\nØ 友员用关键字friend声明。友员是对类操作的一种辅助手段。一个类的友员可以访问该类各种性质的成员**。**\n\nØ 链表是一种重要的动态数据结构，可以在程序运行时创建或撤消数据元素。\n\n\n\n---\n\n\n## 八、运算符重载\n\n#### （一）概念\n\n**1.什么是运算符重载**\n![11]($resource/11.png)\n所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是”一名多用”。\n\n运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重载。例如，大 家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行加法运算，如5+8， 5.8 +3.67等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的， 但由于C++已经对运算符”+”进行了重载，所以就能适用于int, float, doUble类型的运算。\n\n又如”<<“是C++的位运算中的位移运算符（左移），但在输出操作中又是与流对 象cout 配合使用的流插入运算符，”>>“也是位移运算符(右移），但在输入操作中又是与流对象 cin 配合使用的流提取运算符。这就是运算符重载(operator overloading)。C++系统对”<<“和”>>“进行了重载，用户在不同的场合下使用它们时，作用是不同 的。对”<<“和”>>“的重载处理是放在头文件stream中的。因此，如果要在程序中用”<< “和”>>”作流插入运算符和流提取运算符，必须在本文件模块中包含头文件stream(当然还应当包括”using namespace std“)。\n\n现在要讨论的问题是：用户能否根据自己的需要对C++已提供的运算符进行重载，赋予它们新的含义，使之一名多用。？\n\n**2.运算符重载入门技术推演**\n\n1为什么会用运算符重载机制\n\n  用复数类举例\n\n//Complex c3 = c1 + c2;\n\n//原因 Complex是用户自定义类型，编译器根本不知道如何进行加减\n\n //编译器给提供了一种机制，让用户自己去完成，自定义类型的加减操作。。。。。\n\n //这个机制就是运算符重载机制\n\n2 运算符重载的本质是一个函数\n```cpp\n\n\n/*对于基础数据类型，C++编译器知道如何进行运算，但是对于用户自定义的类型编译器提供了一种\n让自定义数据类型进行运算符操作的机制,=》运算符重载机制\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\n\npublic:\n\tint a;\n\tint b;\n\n\tfriend Complex operator+(Complex &c1, Complex &c2);\n\npublic:\n\n\tComplex(int a = 0, int b = 0)\n\n\t{\n\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\n\t}\n\npublic:\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\nprivate:\n\n};\n\n/*使用全局函数，通过调用全局函数实现\n\nComplex myAdd(Complex &c1, Complex &c2)\n{\n\n Complex tmp(c1.a+ c2.a, c1.b + c2.b);\n\n return tmp;\n\n}\n\n*/\n\n\n//可以想象为将函数名替换为operator+\nComplex operator+(Complex &c1, Complex &c2)\n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\n\treturn tmp;\n}\n\nvoid main()\n{\n\tComplex c1(1, 2), c2(3, 4);\n\n\t//方法1： 通过调用普通函数实现\n\n\t//Complex c3 = myAdd(c1, c2);\n\n\t//c3.printCom();\n\n\n\n\n\n\t//方法2  将函数名称替换为：operator+ \n\t//使用以下方式进行调用\n\n\t//Complex c3 = operator+(c1, c2);\n\t//c3.printCom();\n\n\n\t//最常用的调用方式\n\n\tComplex c3 = c1 + c2; \n\tc3.printCom();\n\n\n\t//4 把Complex类变成私有属性\n\n\t//友元函数的应用场景\n\n\t//friend Complex operator+(Complex &c1, Complex &c2);\n\n\tsystem(\"pause\");\n\n\treturn;\n\n}\n```\n\n\n---\n\n### （二）运算符重载的限制\n![12]($resource/12.png)\n![13]($resource/13.png)\n\n---\n\n### （三）运算符重载编程基础\n![14]($resource/14.png)\n例如:\n\n //全局函数  完成 +操作符  重载\n\nComplex operator+(Complex &c1, Complex &c2)\n \n//类成员函数  完成 -操作符  重载\n\nComplex operator-(Complex &c2)\n\n**运算符重载的两种方法**\n![15]($resource/15.png)\n![16]($resource/16.png)\n例如1:\n\n//通过类成员函数完成-操作符重载\n\n//函数声明 Complex operator-(Complex &c2)\n\n//函数调用分析\n\n//用类成员函数实现-运算符重载\n\n Complex c4 = c1 - c2;\n\n c4.printCom();\n\n //c1.operator-(c2);\n\n例如2:\n\n//通过全局函数方法完成+操作符重载\n\n//函数声明 Complex operator+(Complex &c1, Complex &c2)\n\n//函数调用分析\n\nint main()\n\n{\n\n Complex c1(1, 2), c2(3, 4);\n\n //Complex c31 = operator+(c1, c2);\n\nComplex c3 = c1 + c2;\n\nc3.printCom();\n\n}\n\n例如3: 学员自己练习  实现 * /\n![17]($resource/17.png)\n例如3\n\n//前置++操作符 用全局函数实现\n\nComplex& operator++(Complex &c1)\n\n{\n\n c1.a ++;\n\n c1.b ++;\n\n return c1;\n\n}\n\n//调用方法\n\n ++c1 ; //=è需要写出操作符重载函数原形\n\n c1.printCom();\n\n//运算符重载函数名定义\n\n //首先承认操作符重载是一个函数 定义函数名èoperator++\n\n //分析函数参数 根据左右操作数的个数,èoperator++(Complex &c1)\n\n //分析函数返回值è Complex& operator++(Complex &c1) 返回它自身\n\n例如4\n\n//4.1前置—操作符 成员函数实现\n\nComplex& operator--()\n\n{\n\n this->a--;\n\n this->b--;\n\n return *this;\n\n}\n\n //4.2调用方法\n\n --c1;\n\n c1.printCom();\n\n //4.3前置—运算符重载函数名定义\n\n //c1.operator--()\n\n例如5\n\n //5.1 //后置++ 操作符 用全局函数实现\n\nComplex operator++(Complex &c1, int)\n\n{\n\n Complex tmp = c1;\n\n c1.a++;\n\n c1.b++;\n\n return tmp;\n\n}\n\n//5.2 调用方法\n\nc1 ++ ; //先使用 后++\n\n//5.3 后置++运算符重载函数名定义\n\n Complex operator++(Complex &c1, int) //函数占位参数 和 前置++ 相区别\n\n例如6\n\n//6.1 后置— 操作符 用类成员函数实现\n\n Complex operator--(int)\n\n {\n\n Complex tmp = *this;\n\n this->a--;\n\n this->b--;\n\n return tmp;\n\n }\n\n//6.2 调用方法\n\nc1 ++ ; //先使用 后++\n\n//6.3 后置--运算符重载函数名定义\n\n Complex operator--(int) //函数占位参数 和 前置-- 相区别\n\n前置和后置运算符总结\n\n**C++****中通过一个占位参数来区分前置运算和后置运算**\n![18]($resource/18.png)\n**定义运算符重载函数名的步骤**\n\n全局函数、类成员函数方法实现运算符重载步骤\n\n 1）要承认操作符重载是一个函数，写出函数名称operator+ ()\n\n 2）根据操作数，写出函数参数\n\n 3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n\n**友元函数实现操作符重载的应用场景**\n\n**1****）友元函数和成员函数选择方法**\n\nØ 当无法修改左操作数的类时，使用全局函数进行重载\n\nØ =, [], ()和->操作符只能通过成员函数进行重载\n\n**2****）用友元函数** **重载 << >>****操作符**\n\nØ istream 和 ostream 是 C++ 的预定义流类\n\nØ cin 是 istream 的对象，cout 是 ostream 的对象\n\nØ 运算符 << 由ostream 重载为插入操作，用于输出基本类型数据\n\nØ 运算符 >> 由 istream 重载为提取操作，用于输入基本类型数据\n\nØ 用友员函数重载 << 和 >> ，输出和输入用户自定义的数据类型\n\na）用全局函数方法实现 << 操作符\n\nostream& operator<<(ostream &out, Complex &c1)\n\n{\n\n //out<<\"12345，生活真是苦\"<<endl;\n\n out<<c1.a<<\" + \"<<c1.b<<\"i \"<<endl;\n\n return out;\n\n}\n\n//调用方法\n\ncout<<c1;\n\n//链式编程支持\n\ncout<<c1<<\"abcc\";\n\n//cout.operator<<(c1).operator<<(\"abcd\");\n\n//函数返回值充当左值 需要返回一个引用\n\nb）类成员函数方法无法实现 << 操作符重载\n\n //因拿到cout这个类的源码\n\n //cout.operator<<(c1);\n\n**3）** **友元函数重载操作符使用注意点**\n\na） 友员函数重载运算符常用于运算符的左右操作数类型不同的情况\n\nb）其他\n\nØ 在第一个参数需要隐式转换的情形下，使用友员函数重载运算符是正确的选择\n\nØ  友员函数没有 this 指针，所需操作数都必须在参数表显式声明，很容易实现类型的隐式转换\n\nØ  C++中不能用友员函数重载的运算符有\n\n = （）  ［］  －>\n\n**4** **）友元函数案例vector****类**\n\n| \n\n#include <iostream>\n\nusing namespace std;\n\n//为vector类重载流插入运算符和提取运算符\n\nclass vector\n\n{\n\npublic :\n\n vector( int size =1 ) ;\n\n ~vector() ;\n\n int & operator[]( int i ) ;\n\n friend ostream & operator << ( ostream & output , vector & ) ;\n\n friend istream & operator >> ( istream & input, vector & ) ;\n\nprivate : \n\n int * v ;\n\n int len ;\n\n};\n\nvector::vector( int size )\n\n{\n\n if (size <= 0 || size > 100 )\n\n {\n\n cout << \"The size of \" << size << \" is null !\\n\" ; abort() ;\n\n }\n\n v = new int[ size ] ; len = size ;\n\n}\n\nvector :: ~vector()\n\n{\n\n delete[] v ;\n\n len = 0 ;\n\n}\n\nint &vector::operator[]( int i )                \n\n{\n\n if( i >=0 && i < len ) return v[ i ] ;\n\n cout << \"The subscript \" << i << \" is outside !\\n\" ; abort() ;\n\n}\n\nostream & operator << ( ostream & output, vector & ary )\n\n{\n\n for(int i = 0 ; i < ary.len ; i ++ )\n\n output << ary[ i ] << \" \" ;\n\n output << endl ;\n\n return output ;\n\n}\n\nistream & operator >> ( istream & input, vector & ary )\n\n{\n\n for( int i = 0 ; i < ary.len ; i ++ )\n\n input >> ary[ i ] ;\n\n return input ;\n\n}\n\nvoid main()\n\n{\n\n int k ;\n\n cout << \"Input the length of vector A :\\n\" ;\n\n cin >> k ;\n\n vector A( k ) ;\n\n cout << \"Input the elements of vector A :\\n\" ;\n\n cin >> A ;\n\n cout << \"Output the elements of vector A :\\n\" ;\n\n cout << A ;\n\n system(\"pause\");\n\n}\n\n |\n\n### （四）运算符重载提高\n\n**1****运算符重载机制**\n\nC++编译器是如何支持操作符重载机制的?\n\n**2****重载赋值运算符****=**\n\nØ 赋值运算符重载用于对象数据的复制\n\nØ operator= 必须重载为成员函数\n\nØ 重载函数原型为：\n\n  **_类型_ &** **_类名_ :: operator= ( const** **_类名_ & ) ;**\n\n案例：完善Name类，支持=号操作。\n\n  结论:\n\n 1 //先释放旧的内存\n\n 2 返回一个引用\n\n 3 =操作符 从右向左\n\n| \n\n //obj3 = obj1; // C++编译器提供的  等号操作  也属  浅拷贝\n\n// obj4 = obj3 = obj1\n\n //obj3.operator=(obj1)\n\n Name& operator=(Name &obj1)\n\n {\n\n //1 先释放obj3旧的内存\n\n if (this->m_p != NULL)\n\n {\n\n delete[] m_p;\n\n m_len = 0;\n\n }\n\n //2 根据obj1分配内存大小\n\n this->m_len = obj1.m_len;\n\n this->m_p = new char [m_len+1];\n\n //3把obj1赋值给obj3\n\n strcpy(m_p, obj1.m_p);\n\n return *this;\n\n }\n\n |\n\n**3****重载数组下表运算符****[]**\n\n重载[]和()运算符\n\nØ 运算符 [] 和 () 是二元运算符\n\nØ [] 和 () 只能用成员函数重载，不能用友元函数重载\n\n**_重载下标运算符 []_**\n\n[] 运算符用于访问数据对象的元素\n\n重载格式  _类型_ **_类_** :: operator[] ( _类型_ ) ；\n\n设 x 是类 X 的一个对象，则表达式\n\n **x [ y ]**\n\n  可被解释为\n\n **x . operator [ ] ( y )**\n\n**4****重载函数调用符** **()**\n\n() 运算符用于函数调用\n\n重载格式  _类型_ _类_ :: operator() ( _表达式表_ ) ；\n\n**_例1_**\n\n**设 x** **是类 X** **的一个对象，则表达式**\n\n **x ( arg1, arg2, … )**\n\n**可被解释为**\n\n **x . operator () (arg1, arg2, … )**\n\n案例：\n\n**_//_****_例2_****_：用重载()_****_运算符实现数学函数的抽象_**\n\n#include <iostream>\n\nclass F\n\n { public :\n\n double operator ( )  ( double x , double y ) ;\n\n } ;\n\ndouble F :: operator ( )  ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\nf.getA();\n\n cout << f ( 5.2 , 2.5 ) << endl ; // **f . _operator()_ (5.2, 2.5)**\n\n}\n\n比较普通成员函数\n\n**_//_****_例3_** **_用重载()_****_运算符实现 pk_** **_成员函数_**\n\n#include <iostream.h>\n\nclass F\n\n { public :\n\n double **memFun** ( double x , double y ) ;\n\n } ;\n\ndouble F :: **memFun** ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\n cout << f.**memFun** ( 5.2 , 2.5 ) << endl ;\n\n}\n\n**5****为什么不要重载****&&****和****||****操作符**\n\n理论知识：\n\n1）&&和||是C++中非常特殊的操作符\n\n2）&&和||内置实现了短路规则\n\n3）操作符重载是靠函数重载来完成的\n\n4）操作数作为函数参数传递\n\n5）C++的函数参数都会被求值，无法实现短路规则\n\n| \n\n#include <cstdlib>\n\n#include <iostream>\n\nusing namespace std;\n\nclass Test\n\n{\n\n int i;\n\npublic:\n\n Test(int i)\n\n {\n\n this->i = i;\n\n }\n\n Test operator+ (const Test& obj)\n\n {\n\n Test ret(0);\n\n cout<<\"执行+号重载函数\"<<endl;\n\n ret.i = i + obj.i;\n\n return ret;\n\n }\n\n bool operator&& (const Test& obj)\n\n {\n\n cout<<\"执行&&重载函数\"<<endl;\n\n return i && obj.i;\n\n }\n\n};\n\n// && 从左向右\n\nvoid main()\n\n{\n\n int a1 = 0;\n\n int a2 = 1;\n\n cout<<\"注意：&&操作符的结合顺序是从左向右\"<<endl;\n\n if( a1 && (a1 + a2) )\n\n {\n\n cout<<\"有一个是假，则不在执行下一个表达式的计算\"<<endl;\n\n }\n\n Test t1 = 0;\n\n Test t2 = 1;\n\n If ( t1 && (t1 + t2) )\n\n {\n\n=è\n\n T1.operator&&( t1 + t2) )\n\nT1.operator&&( t1.operator+(t2) )\n\n //t1 && t1.operator+(t2)\n\n // t1.operator( t1.operator(t2) )\n\n cout<<\"两个函数都被执行了，而且是先执行了+\"<<endl;\n\n }\n\n system(\"pause\");\n\n return ;\n\n}\n\n\n### （五）运算符重载在项目开发中的应用\n\n**1实现一个数组类**\n\n添加<< >>\n\n**2实现一个字符串类**\n\n构造函数要求\n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串类 以零结尾的字符串\n\n//若len为0,表示空串\n\nMyString a; //空串 “”\n\nMyString a(“dddd”);\n\nMyString b = a;\n\nb = “aaaaaa” \n\nb = a;\n\nif (a > b)\n\nif (a == b)\n\nb[i] = ‘a’;\n\n常用的操作符\n\n<< >> != == > < =\n\n| \n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串 以零结尾的字符串\n\nclass MyString\n\n{\n\n friend ostream& operator<<(ostream &out, const MyString &s);\n\npublic: //构造和析构\n\n MyString(int len = 0);\n\n MyString(const char *p);\n\n MyString(const MyString& obj);\n\n ~MyString();\n\npublic: //操作符重载\n\n MyString& operator=(const char *p);\n\n MyString& operator=(const MyString& obj);\n\n char& operator[](int index) const;\n\npublic:\n\n bool operator==(const char* p) const;\n\n bool operator!=(const char* p) const;\n\n bool operator==(const MyString& s) const;\n\n bool operator!=(const MyString& s) const;\n\npublic: //string to c\n\n char *c_str();\n\n const char* c_str() const;\n\n int length()\n\n {\n\n return m_len;\n\n }\n\npublic:\n\n int operator<(const char *p);\n\n int operator>(const char *p);\n\n int operator<(const MyString &s);\n\n int operator>(const MyString &s);\n\nprivate:\n\n int m_len;\n\n char  *m_p;\n\n};\n\n |\n\n**3****智能指针类编写**\n\n1问题抛出\n\n  指针使用过程中，经常会出现内存泄漏和内存多次被释放常\n\n2 解决方案：例如：boost库的智能指针\n\n  项目开发中，要求开发者使用预先编写的智能指针类对象代替C语言中的原生指针\n\n3 智能指针思想\n\n工程中的智能指针是一个类模板\n\n  通过构造函数接管申请的内存\n\n  通过析构函数确保堆内存被及时释放\n\n  通过重载指针运算符* 和 -> 来模拟指针的行为\n\n  通过重载比较运算符 == 和 != 来模拟指针的比较\n\n| \n\nclass Test\n\n{\n\npublic:\n\n Test()\n\n {\n\n this->a = 10;\n\n }\n\n void printT()\n\n {\n\n cout<<a<<endl;\n\n }\n\nprivate:\n\n int a;\n\n};\n\nclass MyTestPointer\n\n{\n\npublic:\n\npublic:\n\n MyTestPointer()\n\n {\n\n p = NULL;\n\n }\n\n MyTestPointer(Test* p)\n\n {\n\n this->p = p;\n\n }\n\n ~MyTestPointer()\n\n {\n\n delete p;\n\n }\n\n Test* operator->()\n\n {\n\n return p;\n\n }\n\n Test& operator*()\n\n {\n\n return *p;\n\n }\n\nprotected:\n\n Test *p;\n\n};\n\nvoid main01_classp()\n\n{\n\n Test *p = new Test;\n\n p->printT();\n\n delete p;\n\n MyTestPointer myp = new Test; //构造函数\n\n myp->printT(); //重载操作符 ->\n\n};\n\n |\n\n| \n\nclass MyIntPointer\n\n{\n\npublic:\n\npublic:\n\n MyIntPointer()\n\n {\n\n p = NULL;\n\n }\n\n MyIntPointer(int* p)\n\n {\n\n this->p = p;\n\n }\n\n ~MyIntPointer()\n\n {\n\n delete p;\n\n }\n\n int* operator->()\n\n {\n\n return p;\n\n }\n\n int& operator*()\n\n {\n\n return *p;\n\n }\n\nprotected:\n\n int *p;\n\n};\n\nvoid main02_intp()\n\n{\n\n int *p = new int(100);\n\n cout<<*p<<endl;\n\n delete p;\n\n MyIntPointer myp = new int(200);\n\n cout<<*myp<<endl; //重载*操作符\n\n};\n\n |\n\n**8.7****附录：运算符和结合性**\n\n总结\n\n操作符重载是C++的强大特性之一\n\n操作符重载的本质是通过函数扩展操作符的语义\n\noperator关键字是操作符重载的关键\n\nfriend关键字可以对函数或类开发访问权限\n\n操作符重载遵循函数重载的规则\n\n操作符重载可以直接使用类的成员函数实现\n\n=, [], ()和->操作符只能通过成员函数进行重载\n\n++操作符通过一个int参数进行前置与后置的重载\n\nC++中不要重载&&和||操作符\n\n\n\n\n\n\n\n\n\n\n\n",[[1543558299377,["gjx16@GJXAIOU",[[-1,35492,"-"]],[35493,35493],[35492,35492]]],[1543558324042,["gjx16@GJXAIOU",[[1,35492,"程序示例："]],[35492,35492],[35497,35497]]],[1543559862508,["gjx16@GJXAIOU",[[-1,36034,"Ø "]],[36034,36036],[36034,36034]]],[1543559863230,["gjx16@GJXAIOU",[[1,36034,"-"]],[36034,36034],[36035,36035]]],[1543559865906,["gjx16@GJXAIOU",[[-1,36034,"-"]],[36035,36035],[36034,36034]]],[1543559869036,["gjx16@GJXAIOU",[[-1,36108,"| \n"]],[36108,36111],[36108,36108]]],[1543559871189,["gjx16@GJXAIOU",[[-1,36108,"\n"]],[36108,36108],[36107,36107]]],[1543559871718,["gjx16@GJXAIOU",[[-1,36107,"\n"]],[36107,36107],[36106,36106]]],[1543559873346,["gjx16@GJXAIOU",[[1,36107,"\n"]],[36106,36106],[36107,36107]]],[1543559876034,["gjx16@GJXAIOU",[[1,36073,"```"]],[36073,36073],[36076,36076]]],[1543559878027,["gjx16@GJXAIOU",[[-1,36073,"```"]],[36076,36076],[36073,36073]]],[1543559882202,["gjx16@GJXAIOU",[[1,36107,"```cpp"]],[36107,36107],[36113,36113]]],[1543559892663,["gjx16@GJXAIOU",[[1,37454,"```"]],[37454,37454],[37457,37457]]],[1543559909920,["gjx16@GJXAIOU",[[-1,36114,"#include \"iostream\"\n\nusing namespace std;\n\nclass Goods\n\n{\n\npublic :\n\n Goods ( int w) { weight = w ; total_weight += w ; }\n\n ~ Goods() { total_weight -= weight ; }\n\n int Weight() { return weight ; } ;\n\n static int TotalWeight() { return total_weight ; }\n\n Goods *next ;\n\nprivate :\n\n int weight ;\n\n static int total_weight ;\n\n} ;\n\nint Goods::total_weight = 0 ;\n\n//r尾部指针\n\nvoid purchase( Goods * &f, Goods *& r, int w )\n\n{\n\n Goods *p = new Goods(w) ;\n\n p -> next = NULL ;\n\n if ( f == NULL ) f = r = p ;\n\n else { r -> next = p ; r = r -> next ; } //尾部指针下移或新结点变成尾部结点\n\n}\n\nvoid sale( Goods * & f , Goods * & r )\n\n{\n\n if ( f == NULL ) { cout << \"No any goods!\\n\" ; return ; }\n\n Goods *q = f ; f = f -> next ; delete q ;\n\n cout << \"saled.\\n\" ;\n\n}\n\nvoid main()\n\n{\n\n Goods * front = NULL , * rear = NULL ;\n\n int w ; int choice ;\n\n do\n\n {\n\n cout << \"Please choice:\\n\" ;\n\n cout << \"Key in 1 is purchase,\\nKey in 2 is sale,\\nKey in 0 is over.\\n\" ;\n\n cin >> choice ;\n\n switch ( choice ) // 操作选择\n\n {\n\n case 1 : // 键入1，购进1箱货物\n\n { cout << \"Input weight: \" ;\n\n cin >> w ;\n\n purchase( front, rear, w ) ; // 从表尾插入1个结点\n\n break ;\n\n }\n\n case 2 :              // 键入2，售出1箱货物\n\n { sale( front, rear ) ; break ; } // 从表头删除1个结点\n\n case 0 : break ;              // 键入0，结束\n\n }\n\n cout << \"Now total weight is:\" << Goods::TotalWeight() << endl ;\n\n } while ( choice ) ;\n\n}\n\n |"]],[36114,37453],[36114,36114]]],[1543559981269,["gjx16@GJXAIOU",[[1,36114,"#include \"iostream\"\nusing namespace std;\n\nclass Goods\n{\npublic:\n\n\tGoods(int w) { weight = w; total_weight += w; }\n\n\t~Goods() { total_weight -= weight; }\n\n\tint Weight() { return weight; };\n\n\tstatic int TotalWeight() { return total_weight; }\n\n\tGoods *next;\n\nprivate:\n\n\tint weight;\n\tstatic int total_weight;\n\n};\n\nint Goods::total_weight = 0;\n\n//r尾部指针\n\nvoid purchase(Goods * &f, Goods *& r, int w)\n{\n\n\tGoods *p = new Goods(w);\n\n\tp->next = NULL;\n\n\tif (f == NULL) f = r = p;\n\n\telse { r->next = p; r = r->next; } //尾部指针下移或新结点变成尾部结点\n\n}\n\nvoid sale(Goods * & f, Goods * & r)\n{\n\n\tif (f == NULL) { cout << \"No any goods!\\n\"; return; }\n\n\tGoods *q = f; f = f->next; delete q;\n\n\tcout << \"saled.\\n\";\n\n}\n\nvoid main()\n{\n\tGoods * front = NULL, *rear = NULL;\n\n\tint w; int choice;\n\n\tdo\n\t{\n\t\tcout << \"Please choice:\\n\";\n\n\t\tcout << \"Key in 1 is purchase,\\nKey in 2 is sale,\\nKey in 0 is over.\\n\";\n\n\t\tcin >> choice;\n\n\t\tswitch (choice) // 操作选择\n\t\t{\n\t\tcase 1: // 键入1，购进1箱货物\n\t\t{ cout << \"Input weight: \";\n\t\tcin >> w;\n\n\t\tpurchase(front, rear, w); // 从表尾插入1个结点\n\n\t\tbreak;\n\t\t}\n\n\t\tcase 2:              // 键入2，售出1箱货物\n\t\t{ sale(front, rear); break; } // 从表头删除1个结点\n\n\t\tcase 0: break;              // 键入0，结束\n\t\t}\n\n\t\tcout << \"Now total weight is:\" << Goods::TotalWeight() << endl;\n\n\t} while (choice);\n}"]],[36114,36114],[37375,37375]]],[1543559994332,["gjx16@GJXAIOU",[[-1,37436,"\n"]],[37436,37436],[37435,37435]]],[1543559995295,["gjx16@GJXAIOU",[[-1,37435,"\n"]],[37435,37435],[37434,37434]]],[1543559995836,["gjx16@GJXAIOU",[[-1,37434,"\n"]],[37434,37434],[37433,37433]]],[1543559999617,["gjx16@GJXAIOU",[[1,37434,"\n"]],[37434,37434],[37435,37435]]],[1543560007544,["gjx16@GJXAIOU",[[1,37442,":``"]],[37442,37442],[37445,37445]]],[1543560013766,["gjx16@GJXAIOU",[[1,37444,"Array.h"]],[37444,37444],[37451,37451]]],[1543560016157,["gjx16@GJXAIOU",[[-1,37453,"\n"]],[37453,37453],[37452,37452]]],[1543560022869,["gjx16@GJXAIOU",[[1,37697,"``"]],[37697,37697],[37699,37699]]],[1543560030018,["gjx16@GJXAIOU",[[1,37698,"Array.cpp"]],[37698,37698],[37707,37707]]],[1543560045640,["gjx16@GJXAIOU",[[-1,38834,"****"]],[38834,38838],[38834,38834]]],[1543560046917,["gjx16@GJXAIOU",[[1,38834,"."]],[38834,38834],[38835,38835]]],[1543560051165,["gjx16@GJXAIOU",[[-1,38841,"Ø "]],[38841,38843],[38841,38841]]],[1543560054956,["gjx16@GJXAIOU",[[-1,38882,"Ø "]],[38882,38884],[38882,38882]]],[1543560058013,["gjx16@GJXAIOU",[[-1,38881,"\n"]],[38881,38881],[38880,38880]]],[1543560063018,["gjx16@GJXAIOU",[[-1,38881,"结"]],[38882,38882],[38881,38881]]],[1543560066825,["gjx16@GJXAIOU",[[1,38881,"结"]],[38881,38881],[38882,38882]]],[1543560068382,["gjx16@GJXAIOU",[[-1,38880,"\n"]],[38881,38881],[38880,38880]]],[1543560070126,["gjx16@GJXAIOU",[[1,38880,"\n"]],[38880,38880],[38881,38881]]],[1543560073067,["gjx16@GJXAIOU",[[-1,38915,"\nØ  "]],[38915,38919],[38915,38915]]],[1543560077714,["gjx16@GJXAIOU",[[-1,38967,"\nØ  "]],[38967,38971],[38967,38967]]],[1543560081755,["gjx16@GJXAIOU",[[-1,39006,"\nØ  "]],[39006,39010],[39006,39006]]],[1543560085527,["gjx16@GJXAIOU",[[-1,39036,"\nØ "]],[39036,39039],[39036,39036]]],[1543560089180,["gjx16@GJXAIOU",[[-1,39065,"\nØ "]],[39065,39068],[39065,39065]]],[1543560091841,["gjx16@GJXAIOU",[[-1,39036," "]],[39037,39037],[39036,39036]]],[1543560095092,["gjx16@GJXAIOU",[[-1,39113,"**。**"]],[39113,39118],[39113,39113]]],[1543560098553,["gjx16@GJXAIOU",[[-1,39114,"\nØ"]],[39114,39116],[39114,39114]]],[1543560106378,["gjx16@GJXAIOU",[[-1,38841,"类通常用关键字class定义。类是数据成员和成员函数的封装。类的实例称为对象。\n结构类型用关键字struct定义，是由不同类型数据组成的数据类型。\n类成员由private, protected, public决定访问特性。public成员集称为接口。\n构造函数在创建和初始化对象时自动调用。析构函数则在对象作用域结束时自动调用。\n重载构造函数和复制构造函数提供了创建对象的不同初始化方式。\n静态成员是局部于类的成员，提供一种同类对象的共享机制。\n友员用关键字friend声明。友员是对类操作的一种辅助手段。一个类的友员可以访问该类各种性质的成员\n 链表是一种重要的动态数据结构，可以在程序运行时创建或撤消数据元素。"],[1,39148,"-"]],[38841,39148],[38842,38842]]],[1543560108311,["gjx16@GJXAIOU",[[-1,38841,"-"]],[38842,38842],[38841,38841]]],[1543560110453,["gjx16@GJXAIOU",[[1,38841,"-"]],[38841,38841],[38842,38842]]],[1543560111460,["gjx16@GJXAIOU",[[1,38841,"类通常用关键字class定义。类是数据成员和成员函数的封装。类的实例称为对象。\n结构类型用关键字struct定义，是由不同类型数据组成的数据类型。\n类成员由private, protected, public决定访问特性。public成员集称为接口。\n构造函数在创建和初始化对象时自动调用。析构函数则在对象作用域结束时自动调用。\n重载构造函数和复制构造函数提供了创建对象的不同初始化方式。\n静态成员是局部于类的成员，提供一种同类对象的共享机制。\n友员用关键字friend声明。友员是对类操作的一种辅助手段。一个类的友员可以访问该类各种性质的成员\n 链表是一种重要的动态数据结构，可以在程序运行时创建或撤消数据元素。"],[-1,38841,"-"]],[38842,38842],[38841,39148]]],[1543560113203,["gjx16@GJXAIOU",[[1,38841,"* "],[1,38881,"* "],[1,38915,"* "],[1,38967,"* "],[1,39006,"* "],[1,39036,"* "],[1,39064,"* "],[1,39114,"*"]],[38841,39148],[38843,39163]]],[1543560252602,["gjx16@GJXAIOU",[[-1,40035,"\n"]],[40035,40035],[40034,40034]]],[1543560256141,["gjx16@GJXAIOU",[[-1,40111,"\n"]],[40111,40111],[40110,40110]]],[1543560704133,["gjx16@GJXAIOU",[[-1,41198,"\n"]],[41198,41198],[41197,41197]]],[1543560706242,["gjx16@GJXAIOU",[[1,41199,"  "]],[41198,41198],[41200,41200]]],[1543560707482,["gjx16@GJXAIOU",[[1,41222,"  "]],[41222,41222],[41224,41224]]],[1543560708919,["gjx16@GJXAIOU",[[-1,41221,"\n"]],[41221,41221],[41220,41220]]],[1543560709858,["gjx16@GJXAIOU",[[1,41220,"  "]],[41220,41220],[41222,41222]]],[1543560711682,["gjx16@GJXAIOU",[[1,41225,"  "]],[41225,41225],[41227,41227]]],[1543560713703,["gjx16@GJXAIOU",[[-1,41271," "]],[41272,41272],[41271,41271]]],[1543560716322,["gjx16@GJXAIOU",[[1,41272,"  "]],[41272,41272],[41274,41274]]],[1543560717909,["gjx16@GJXAIOU",[[1,41296,"    "]],[41296,41296],[41300,41300]]],[1543560719772,["gjx16@GJXAIOU",[[-1,41295,"\n"]],[41295,41295],[41294,41294]]],[1543560733555,["gjx16@GJXAIOU",[[1,41343,":"]],[41343,41343],[41344,41344]]],[1543560736760,["gjx16@GJXAIOU",[[1,41395,"\n"]],[41394,41394],[41395,41395]]],[1543560761327,["gjx16@GJXAIOU",[[-1,41420,"\n"]],[41420,41420],[41419,41419]]],[1543560763340,["gjx16@GJXAIOU",[[-1,41458,"\n"]],[41458,41458],[41457,41457]]],[1543560766374,["gjx16@GJXAIOU",[[-1,41467,"\n"]],[41467,41467],[41466,41466]]],[1543560768931,["gjx16@GJXAIOU",[[1,41420,"  "]],[41420,41420],[41422,41422]]],[1543560769973,["gjx16@GJXAIOU",[[1,41460,"  "]],[41460,41460],[41462,41462]]],[1543560770942,["gjx16@GJXAIOU",[[1,41471,"  "]],[41471,41471],[41473,41473]]],[1543560774183,["gjx16@GJXAIOU",[[1,41490,"·"]],[41490,41490],[41491,41491]]],[1543560775133,["gjx16@GJXAIOU",[[-1,41490,"·"]],[41491,41491],[41490,41490]]],[1543560776951,["gjx16@GJXAIOU",[[1,41490,"```"]],[41490,41490],[41493,41493]]],[1543560777100,["gjx16@GJXAIOU",[[1,41493,"language\n```\n"]],[41493,41493],[41493,41501]]],[1543560778072,["gjx16@GJXAIOU",[[-1,41493,"language"],[1,41501,"c"]],[41493,41501],[41494,41494]]],[1543560779182,["gjx16@GJXAIOU",[[1,41494,"pp"]],[41494,41494],[41496,41496]]],[1543560784217,["gjx16@GJXAIOU",[[-1,41503,"Complex c4 = c1 - c2;\n\n c4.printCom();\n\n //c1.operator-(c2);"]],[41503,41563],[41503,41503]]],[1543560785712,["gjx16@GJXAIOU",[[1,41497,"\n"]],[41496,41496],[41497,41497]]],[1543560786247,["gjx16@GJXAIOU",[[1,41497,"Complex c4 = c1 - c2;\n\n c4.printCom();\n\n //c1.operator-(c2);"]],[41497,41497],[41557,41557]]],[1543560788756,["gjx16@GJXAIOU",[[-1,41565,"\n"]],[41565,41565],[41564,41564]]],[1543560797524,["gjx16@GJXAIOU",[[-1,41590,"\n"]],[41590,41590],[41589,41589]]],[1543560798724,["gjx16@GJXAIOU",[[-1,41641,"\n"]],[41641,41641],[41640,41640]]],[1543560802604,["gjx16@GJXAIOU",[[1,41650,"```"]],[41650,41650],[41653,41653]]],[1543560802756,["gjx16@GJXAIOU",[[1,41653,"language\n```\n"]],[41653,41653],[41653,41661]]],[1543560803550,["gjx16@GJXAIOU",[[-1,41653,"language"],[1,41661,"c"]],[41653,41661],[41654,41654]]],[1543560804639,["gjx16@GJXAIOU",[[1,41654,"pp"]],[41654,41654],[41656,41656]]],[1543560805229,["gjx16@GJXAIOU",[[1,41657,"\n"]],[41656,41656],[41657,41657]]],[1543560809482,["gjx16@GJXAIOU",[[-1,41663,"int main()\n\n{\n\n Complex c1(1, 2), c2(3, 4);\n\n //Complex c31 = operator+(c1, c2);\n\nComplex c3 = c1 + c2;\n\nc3.printCom();\n\n}"]],[41663,41785],[41663,41663]]],[1543560812316,["gjx16@GJXAIOU",[[1,41657,"int main()\n\n{\n\n Complex c1(1, 2), c2(3, 4);\n\n //Complex c31 = operator+(c1, c2);\n\nComplex c3 = c1 + c2;\n\nc3.printCom();\n\n}"]],[41657,41657],[41779,41779]]],[1543560814750,["gjx16@GJXAIOU",[[-1,41668,"\n"]],[41668,41668],[41667,41667]]],[1543560815972,["gjx16@GJXAIOU",[[-1,41670,"\n"]],[41670,41670],[41669,41669]]],[1543560825734,["gjx16@GJXAIOU",[[-1,41800," * /"]],[41800,41804],[41800,41800]]],[1543560830772,["gjx16@GJXAIOU",[[1,41801,"\n"]],[41800,41800],[41801,41801]]],[1543560831312,["gjx16@GJXAIOU",[[1,41802,"\n"]],[41801,41801],[41802,41802]]],[1543560831836,["gjx16@GJXAIOU",[[1,41803,"\n"]],[41802,41802],[41803,41803]]],[1543560833540,["gjx16@GJXAIOU",[[-1,41784,"\n"]],[41784,41784],[41783,41783]]],[1543560834064,["gjx16@GJXAIOU",[[-1,41783,"\n"]],[41783,41783],[41782,41782]]],[1543560839184,["gjx16@GJXAIOU",[[1,41371,"\n"]],[41370,41370],[41371,41371]]],[1543560839776,["gjx16@GJXAIOU",[[1,41372,"\n"]],[41371,41371],[41372,41372]]],[1543560844914,["gjx16@GJXAIOU",[[1,41372,"- eryuan"]],[41372,41372],[41380,41380]]],[1543560849277,["gjx16@GJXAIOU",[[-1,41374,"eryuan"]],[41380,41380],[41374,41374]]],[1543560851283,["gjx16@GJXAIOU",[[1,41374,"二院"]],[41374,41374],[41376,41376]]],[1543560852522,["gjx16@GJXAIOU",[[-1,41374,"二院"]],[41376,41376],[41374,41374]]],[1543560864689,["gjx16@GJXAIOU",[[1,41374,"二元操作符虫子"]],[41374,41374],[41381,41381]]],[1543560867860,["gjx16@GJXAIOU",[[-1,41379,"虫子"]],[41381,41381],[41379,41379]]],[1543560873753,["gjx16@GJXAIOU",[[1,41379,"重载是"]],[41379,41379],[41382,41382]]],[1543560876189,["gjx16@GJXAIOU",[[-1,41381,"是"]],[41382,41382],[41381,41381]]],[1543560880232,["gjx16@GJXAIOU",[[1,41381,"的实现："]],[41381,41381],[41385,41385]]],[1543560887506,["gjx16@GJXAIOU",[[1,41816,"- 医院"]],[41816,41816],[41820,41820]]],[1543560889020,["gjx16@GJXAIOU",[[-1,41818,"医院"]],[41820,41820],[41818,41818]]],[1543560902463,["gjx16@GJXAIOU",[[1,41818,"一元函数操作符重载的实现："]],[41818,41818],[41831,41831]]],[1543562272117,["gjx16@GJXAIOU",[[1,41411,"\n"]],[41410,41410],[41411,41411]]],[1543562281328,["gjx16@GJXAIOU",[[1,41411,"使用全局函数法："]],[41411,41411],[41419,41419]]],[1543562282330,["gjx16@GJXAIOU",[[1,41420,"\n"]],[41419,41419],[41420,41420]]],[1543562287170,["gjx16@GJXAIOU",[[1,41420,"```cpp"]],[41420,41420],[41426,41426]]],[1543562287783,["gjx16@GJXAIOU",[[1,41427,"\n"]],[41426,41426],[41427,41427]]],[1543562288327,["gjx16@GJXAIOU",[[1,41428,"\n"]],[41427,41427],[41428,41428]]],[1543562290082,["gjx16@GJXAIOU",[[1,41428,"```"]],[41428,41428],[41431,41431]]],[1543562292325,["gjx16@GJXAIOU",[[1,41427,"//二元函数操作符的重载的两种方法\n//使用全局函数法：\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\n\npublic:\n\tint a;\n\tint b;\n\n\tfriend Complex operator+(Complex &c1, Complex &c2);\n\npublic:\n\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\n\t}\n\npublic:\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\nprivate:\n\n};\n\n//使用全局函数，通过调用全局函数实现\n/*全局函数、类成员函数方法实现运算符重载步骤\n\n1）要承认操作符重载是一个函数，写出函数名称operator + ()\n\n2）根据操作数，写出函数参数\n\n3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n*/\nComplex operator+(Complex &c1, Complex &c2)  \n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\n\treturn tmp;\n}\n\nvoid main()\n{\n\n\tComplex c1(1, 2), c2(3, 4);\n\tComplex c3 = c1 + c2;\n\n\n\tsystem(\"pause\");\n\n}\n"]],[41427,41427],[42100,42100]]],[1543562306104,["gjx16@GJXAIOU",[[1,42105,"\n"]],[42104,42104],[42105,42105]]],[1543562306695,["gjx16@GJXAIOU",[[1,42106,"\n"]],[42105,42105],[42106,42106]]],[1543562307255,["gjx16@GJXAIOU",[[1,42107,"\n"]],[42106,42106],[42107,42107]]],[1543562311679,["gjx16@GJXAIOU",[[1,42107,"shiyong"]],[42107,42107],[42114,42114]]],[1543562317702,["gjx16@GJXAIOU",[[-1,42107,"shiyong"]],[42114,42114],[42107,42107]]],[1543562323085,["gjx16@GJXAIOU",[[1,42106,"sjioyop"]],[42106,42106],[42113,42113]]],[1543562325967,["gjx16@GJXAIOU",[[-1,42109,"oyop"]],[42113,42113],[42109,42109]]],[1543562329251,["gjx16@GJXAIOU",[[-1,42106,"sji"]],[42109,42109],[42106,42106]]],[1543562337363,["gjx16@GJXAIOU",[[1,42106,"使用成员函数法："]],[42106,42106],[42114,42114]]],[1543562338245,["gjx16@GJXAIOU",[[1,42116,"\n"]],[42114,42114],[42115,42115]]],[1543562342303,["gjx16@GJXAIOU",[[1,42115,"```cpp"]],[42115,42115],[42121,42121]]],[1543562342929,["gjx16@GJXAIOU",[[1,42123,"\n"]],[42121,42121],[42122,42122]]],[1543562345796,["gjx16@GJXAIOU",[[1,42122,"```"]],[42122,42122],[42125,42125]]],[1543562348920,["gjx16@GJXAIOU",[[1,42122,"\n"]],[42121,42121],[42122,42122]]],[1543564742952,["gjx16@GJXAIOU",[[-1,41445,"//使用"],[1,41449,"\n\n/*"],[-1,41453,"法："],[1,41455,"、类成员函数方法实现运算符重载步骤\n\n1）要承认操作符重载是一个函数，写出函数名称operator + ()\n\n2）根据操作数，写出函数参数\n\n3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n*/\n"],[-1,41514,"\npublic"],[1,41521,"private"],[-1,41592,""],[1,41592," //这里主要是针对全局函数"],[-1,41749,"private:\n\n};\n\n"],[1,41763,"\t"],[-1,41765,"使用全局函数，通过调用全局函数实现\n/*全局函数、类"],[-1,41795,"方法"],[1,41799," - "],[-1,41804,"步骤\n\n1）要承认操作符重载是一个函数，写出函数名称"],[1,41830," \n\tComplex "],[-1,41838," + ()\n\n2）根据操作数，写出函数参数\n\n3）根据业务，完善"],[1,41870,"-(Complex &c2)\n\t{\n\t\tComplex tmp(this->a - c2.a, this->b -  c2.b);\n\n\t\treturn tmp;\n\t}\n\nprivate:\n\n};\n\n\n//全局"],[-1,41872,"返回值(看函数是返回引用 还是指针 元素)，及"],[-1,41897,"函数业务\n*/"],[1,41904,"  + 运算符重载"],[-1,41948,"  "],[-1,42010,"void"],[1,42014,"int "],[1,42054,"\n\t//使用 全局函数\n\n"],[-1,42077,""],[1,42077,"\tc3.printCom();\n\n\t//使用成员函数\n\tComplex c4 = c1.operator-(c2);\n\tc4.printCom();"],[1,42097,"\treturn 0;"]],[41427,42099],[42320,42320]]],[1543564749032,["gjx16@GJXAIOU",[[-1,42327,"使用成员函数法：\n```cpp\n\n```\n"]],[42326,42347],[42326,42326]]],[1543564760682,["gjx16@GJXAIOU",[[-1,41411,"使用全局函数法："]],[41411,41419],[41411,41411]]],[1543564761734,["gjx16@GJXAIOU",[[-1,41411,"\n"]],[41411,41411],[41410,41410]]],[1543564854221,["gjx16@GJXAIOU",[[1,41410," "]],[41410,41410],[41411,41411]]],[1543565111925,["gjx16@GJXAIOU",[[1,42765,"\n"]],[42764,42764],[42765,42765]]],[1543565112526,["gjx16@GJXAIOU",[[1,42766,"\n"]],[42765,42765],[42766,42766]]],[1543565118857,["gjx16@GJXAIOU",[[1,42766,"```"]],[42766,42766],[42769,42769]]],[1543565118978,["gjx16@GJXAIOU",[[1,42769,"language\n```\n"]],[42769,42769],[42769,42777]]],[1543565120504,["gjx16@GJXAIOU",[[-1,42769,"language"],[1,42777,"c"]],[42769,42777],[42770,42770]]],[1543565121610,["gjx16@GJXAIOU",[[1,42770,"pp"]],[42770,42770],[42772,42772]]],[1543565122205,["gjx16@GJXAIOU",[[1,42773,"\n"]],[42772,42772],[42773,42773]]],[1543566416580,["gjx16@GJXAIOU",[[1,42773,"//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现前置++和前置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex& operator++(Complex &c1); //这里主要是针对全局函数\n\npublic:\n\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\tComplex& operator--()\n\t{\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn *this;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  + 运算符重载\nComplex& operator++(Complex &c1)\n{\n\tc1.a++;\n\tc1.b++;\n\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1,c2;\n\n\t//使用全局函数实现前置++操作符的重置\n\t++c1;\n\tc1.printCom();\n\n\t//使用成员函数实现前置--操作符的重置\n\n\t--c2;\n\tc2.printCom();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n"]],[42773,42773],[43458,43458]]],[1543566423460,["gjx16@GJXAIOU",[[1,42765,"- shi"]],[42765,42765],[42770,42770]]],[1543566425747,["gjx16@GJXAIOU",[[-1,42767,"shi"]],[42770,42770],[42767,42767]]],[1543566430820,["gjx16@GJXAIOU",[[1,42767,"实现前置++ 和"]],[42767,42767],[42775,42775]]],[1543566431459,["gjx16@GJXAIOU",[[-1,42773," 和"],[1,42775,"++"]],[42775,42775],[42773,42773]]],[1543566437319,["gjx16@GJXAIOU",[[-1,42773,"++"]],[42775,42775],[42773,42773]]],[1543566442146,["gjx16@GJXAIOU",[[1,42773,"和前置--"]],[42773,42773],[42778,42778]]],[1543566449676,["gjx16@GJXAIOU",[[1,43477,"\n"]],[43475,43475],[43476,43476]]],[1543566450235,["gjx16@GJXAIOU",[[1,43478,"\n"]],[43476,43476],[43477,43477]]],[1543566458180,["gjx16@GJXAIOU",[[1,43477,"- 实现后置===="]],[43477,43477],[43485,43485]]],[1543566459762,["gjx16@GJXAIOU",[[-1,43485,"=="]],[43485,43485],[43483,43483]]],[1543566461522,["gjx16@GJXAIOU",[[-1,43483,"=="]],[43485,43485],[43483,43483]]],[1543566465694,["gjx16@GJXAIOU",[[1,43483,"++++"]],[43483,43483],[43485,43485]]],[1543566467769,["gjx16@GJXAIOU",[[-1,43485,"++"]],[43485,43485],[43483,43483]]],[1543566475361,["gjx16@GJXAIOU",[[1,43485,"和后置--"]],[43485,43485],[43490,43490]]],[1543566476353,["gjx16@GJXAIOU",[[1,43491,"- \n"]],[43490,43490],[43493,43493]]],[1543566478908,["gjx16@GJXAIOU",[[-1,43491,"- "]],[43493,43493],[43491,43491]]],[1543566482130,["gjx16@GJXAIOU",[[1,43491,"```"]],[43491,43491],[43494,43494]]],[1543566482276,["gjx16@GJXAIOU",[[1,43494,"language\n```\n"]],[43494,43494],[43494,43502]]],[1543566484944,["gjx16@GJXAIOU",[[-1,43494,"language"],[1,43502,"c"]],[43494,43502],[43495,43495]]],[1543566486034,["gjx16@GJXAIOU",[[1,43495,"pp"]],[43495,43495],[43497,43497]]],[1543566486698,["gjx16@GJXAIOU",[[1,43498,"\n"]],[43497,43497],[43498,43498]]],[1543567915357,["gjx16@GJXAIOU",[[1,43498,"//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现后置++ 和后置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex operator++(Complex &c1, int); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\t//成员函数实现后置--\n\tComplex operator--(int)\n\t{\n\t\tComplex tmp = *this;\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn tmp;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  ++ 运算符重载\nComplex operator++(Complex &c1,int)  //为了和前置++的函数能够共同存在，参数中加了一个占位符从而实现函数重载\n{\n\t//前置++是先使用后++ ，所以应该先返回c1,但是直接使用return c1.会造成程序的直接退出，后面的++无法实现，所以使用临时变量\n\n\tComplex tmp = c1;\n\tc1.a++;\n\tc1.b++;\n\treturn tmp;\n\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1, c2;\n\n\t//使用全局函数实现后置++操作符的重置\n\n\tc1++;\n\tc1.printCom();\n\n\t//使用成员函数实现后置--操作符的重置\n\n\tc2--;\n\tc2.printCom();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n"]],[43498,43498],[44373,44373]]],[1543570311439,["gjx16@GJXAIOU",[[1,45877,"···"]],[45877,45877],[45880,45880]]],[1543570314256,["gjx16@GJXAIOU",[[-1,45877,"···"]],[45880,45880],[45877,45877]]],[1543570316579,["gjx16@GJXAIOU",[[1,45877,"```c"]],[45877,45877],[45881,45881]]],[1543570317160,["gjx16@GJXAIOU",[[-1,45880,"c"],[1,45881,"language\n```\n"]],[45881,45881],[45880,45888]]],[1543570317811,["gjx16@GJXAIOU",[[-1,45880,"language"],[1,45888,"p"]],[45880,45888],[45881,45881]]],[1543570318362,["gjx16@GJXAIOU",[[1,45881,"p"]],[45881,45881],[45882,45882]]],[1543570318905,["gjx16@GJXAIOU",[[1,45883,"\n"]],[45882,45882],[45883,45883]]],[1543570321583,["gjx16@GJXAIOU",[[1,45883,"//实现<<运算符的重载\n\n//注释内部是一套完整的程序，但是只能实现一次打印输出，新的一套程序可以实现链式输出\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\t//friend  void operator<<(ostream &cout, Complex &c1); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n};\n\n/*这里类似于cout只能有全局函数加上友元函数实现，因为如果要使用成员函数实现，需要在cout 的类：ostream中定义成员函数，\n但是这个ostream类是系统隐藏的，不现实；\nvoid operator<<(ostream &cout, Complex &c1)\n{\n\tcout << c1.a << \" + \" << c1.b << \"i\" << endl;\n}\n*/\n\nostream& operator<<(ostream &cout, Complex &c2)  //要想实现函数返回值当左值，需要返回一个引用\n{\n\tcout << c2.a << \" + \" << c2.b << \"i\" << endl;\n\treturn cout;\n}\n\n\n \nint  main()\n{\n\tComplex c1, c2;\n\t//cout << c1;  //实现将c1中两个元素以a+bi的形式直接打印输出；\n\t/*\n\t首先承认运算符重载是函数，所以函数名为：operator<<\n\t其次因为有左右参数，分别为ostream 和Complex类，所有函数头为：operator<<(ostream&cout,Complex c1)\n\t然后根据返回值确定最前面的返回值类型\n\t*/\n\n\n\n\n\tcout << c2 << \"kdjfkdjfkd\";\n\t//因为<<操作符是从左到右，所以左边执行返回值要当左值再次执行这个函数\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n"]],[45883,45883],[46890,46890]]],[1543574616833,["gjx16@GJXAIOU",[[-1,42320,"例如1:\n\n//通过类成员函数完成-操作符重载\n  //函数声明 Complex operator-(Complex &c2)\n  //函数调用分析\n  //用类成员函数实现-运算符重载\n```cpp\nComplex c4 = c1 - c2;\n\n c4.printCom();\n\n //c1.operator-(c2);\n```\n\n \n例如2:\n\n//通过全局函数方法完成+操作符重载\n//函数声明 Complex operator+(Complex &c1, Complex &c2)\n//函数调用分析\n```cpp\nint main()\n{\n Complex c1(1, 2), c2(3, 4);\n\n //Complex c31 = operator+(c1, c2);\n\nComplex c3 = c1 + c2;\n\nc3.printCom();\n\n}\n```\n\n例如3: 学员自己练习  实现\n"]],[42320,42723],[42320,42320]]],[1543574619861,["gjx16@GJXAIOU",[[-1,42321,"\n"]],[42320,42320],[42319,42319]]],[1543574620557,["gjx16@GJXAIOU",[[-1,42320,"\n"]],[42319,42319],[42318,42318]]],[1543574621683,["gjx16@GJXAIOU",[[-1,42319,"\n"]],[42318,42318],[42317,42317]]],[1543574721305,["gjx16@GJXAIOU",[[-1,43979,"//前置++操作符 用全局函数实现\n\nComplex& operator++(Complex &c1)\n\n{\n\n c1.a ++;\n\n c1.b ++;\n\n return c1;\n\n}\n\n//调用方法\n\n ++c1 ; //=è需要写出操作符重载函数原形\n\n c1.printCom();\n\n//运算符重载函数名定义\n\n //首先承认操作符重载是一个函数 定义函数名èoperator++\n\n //分析函数参数 根据左右操作数的个数,èoperator++(Complex &c1)\n\n //分析函数返回值è Complex& operator++(Complex &c1) 返回它自身\n\n例如4\n\n//4.1前置—操作符 成员函数实现\n\nComplex& operator--()\n\n{\n\n this->a--;\n\n this->b--;\n\n return *this;\n\n}\n\n //4.2调用方法\n\n --c1;\n\n c1.printCom();\n\n //4.3前置—运算符重载函数名定义\n\n //c1.operator--()\n\n例如5\n\n //5.1 //后置++ 操作符 用全局函数实现\n\nComplex operator++(Complex &c1, int)\n\n{\n\n Complex tmp = c1;\n\n c1.a++;\n\n c1.b++;\n\n return tmp;\n\n}\n\n//5.2 调用方法\n\nc1 ++ ; //先使用 后++\n\n//5.3 后置++运算符重载函数名定义\n\n Complex operator++(Complex &c1, int) //函数占位参数 和 前置++ 相区别\n\n例如6\n\n//6.1 后置— 操作符 用类成员函数实现\n\n Complex operator--(int)\n\n {\n\n Complex tmp = *this;\n\n this->a--;\n\n this->b--;\n\n return tmp;\n\n }\n\n//6.2 调用方法\n\nc1 ++ ; //先使用 后++\n\n//6.3 后置--运算符重载函数名定义\n\n Complex operator--(int) //函数占位参数 和 前置-- 相区别\n"]],[43979,44914],[43979,43979]]],[1543574725720,["gjx16@GJXAIOU",[[-1,43974,"例如3\n\n"]],[43973,43978],[43973,43973]]],[1543574726569,["gjx16@GJXAIOU",[[-1,43974,"\n"]],[43973,43973],[43972,43972]]],[1543574733097,["gjx16@GJXAIOU",[[-1,43991,"****"]],[43995,43995],[43991,43991]]],[1543574737673,["gjx16@GJXAIOU",[[-1,44080,"\n"]],[44080,44080],[44079,44079]]],[1543574739337,["gjx16@GJXAIOU",[[-1,44118,"2"]],[44119,44119],[44118,44118]]],[1543574742831,["gjx16@GJXAIOU",[[1,44118,"2"]],[44118,44118],[44119,44119]]],[1543574744313,["gjx16@GJXAIOU",[[-1,44116,"\n"]],[44116,44116],[44115,44115]]],[1543574745898,["gjx16@GJXAIOU",[[-1,44132,"\n"]],[44132,44132],[44131,44131]]],[1543574752467,["gjx16@GJXAIOU",[[-1,44200,"****"]],[44200,44204],[44200,44200]]],[1543574758961,["gjx16@GJXAIOU",[[-1,44218,"Ø "]],[44218,44220],[44218,44218]]],[1543574760800,["gjx16@GJXAIOU",[[-1,44242,"\n"]],[44242,44242],[44241,44241]]],[1543574763241,["gjx16@GJXAIOU",[[-1,44242,"Ø "]],[44242,44244],[44242,44242]]],[1543574775081,["gjx16@GJXAIOU",[[1,44244,"-      "]],[44244,44244],[44251,44251]]],[1543574778179,["gjx16@GJXAIOU",[[1,44287,"     "]],[44251,44251],[44292,44292]]],[1543574778740,["gjx16@GJXAIOU",[[-1,44291," "]],[44292,44292],[44291,44291]]],[1543574786707,["gjx16@GJXAIOU",[[-1,44246,"     "]],[44250,44250],[44245,44245]]],[1543574798530,["gjx16@GJXAIOU",[[-1,44278,"****    "]],[44286,44286],[44278,44278]]],[1543574806305,["gjx16@GJXAIOU",[[-1,44284,"** **"]],[44289,44289],[44284,44284]]],[1543574812817,["gjx16@GJXAIOU",[[-1,44292,"****"]],[44296,44296],[44292,44292]]],[1543574820800,["gjx16@GJXAIOU",[[-1,44299,"Ø "]],[44301,44301],[44299,44299]]],[1543574822579,["gjx16@GJXAIOU",[[-1,44331,"Ø "]],[44331,44333],[44331,44331]]],[1543574824898,["gjx16@GJXAIOU",[[-1,44369,"Ø "]],[44369,44371],[44369,44369]]],[1543574885684,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44299,"is"],[-1,44329,"Ø "],[1,44331,"ci"],[-1,44367,"Ø "],[1,44369,"运算"]],[44218,44218],[44371,44371]]],[1543574885684,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44299,"is"],[1,44331,"Ø "],[-1,44331,"ci"],[1,44369,"Ø "],[-1,44369,"运算"]],[44371,44371],[44218,44218]]],[1543574826392,["gjx16@GJXAIOU",[[-1,44330,"\n"]],[44331,44331],[44330,44330]]],[1543574828848,["gjx16@GJXAIOU",[[-1,44367,"\n"]],[44368,44368],[44367,44367]]],[1543574832256,["gjx16@GJXAIOU",[[-1,44403,"Ø "]],[44403,44405],[44403,44403]]],[1543574833265,["gjx16@GJXAIOU",[[-1,44402,"\n"]],[44403,44403],[44402,44402]]],[1543574863553,["gjx16@GJXAIOU",[[-1,44438,"\n"]],[44438,44438],[44437,44437]]],[1543574865579,["gjx16@GJXAIOU",[[-1,44438,"Ø "]],[44438,44440],[44438,44438]]],[1543574871337,["gjx16@GJXAIOU",[[1,44299,"* "],[1,44330,"* "],[1,44367,"* "],[1,44402,"* "],[1,44438,"* "]],[44299,44471],[44301,44481]]],[1543574945700,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"]],[44218,44218],[44450,44450]]],[1543574945700,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"]],[44450,44450],[44218,44218]]],[1543574905320,["gjx16@GJXAIOU",[[-1,45520,"ostream& operator<<(ostream &out, Complex &c1)\n\n{\n\n //out<<\"12345，生活真是苦\"<<endl;\n\n out<<c1.a<<\" + \"<<c1.b<<\"i \"<<endl;\n\n return out;\n\n}\n\n//调用方法\n\ncout<<c1;\n\n//链式编程支持\n\ncout<<c1<<\"abcc\";\n\n//cout.operator<<(c1).operator<<(\"abcd\");\n\n//函数返回值充当左值 需要返回一个引用\n\nb）类成员函数方法无法实现 << 操作符重载\n\n //因拿到cout这个类的源码\n\n //cout.operator<<(c1);\n"]],[45520,45835],[45520,45520]]],[1543574908304,["gjx16@GJXAIOU",[[-1,45520,"\n"]],[45520,45520],[45519,45519]]],[1543574909369,["gjx16@GJXAIOU",[[-1,45519,"\n"]],[45519,45519],[45518,45518]]],[1543574911325,["gjx16@GJXAIOU",[[1,45519,"\n"]],[45518,45518],[45519,45519]]],[1543574915468,["gjx16@GJXAIOU",[[-1,45524,"** **"]],[45524,45529],[45524,45524]]],[1543574918697,["gjx16@GJXAIOU",[[-1,45574,"\n"]],[45574,45574],[45573,45573]]],[1543574920065,["gjx16@GJXAIOU",[[-1,45579,"\n"]],[45579,45579],[45578,45578]]],[1543574923514,["gjx16@GJXAIOU",[[-1,45580," "]],[45581,45581],[45580,45580]]],[1543574927941,["gjx16@GJXAIOU",[[1,45542,"- "]],[45542,45542],[45544,45544]]],[1543574930516,["gjx16@GJXAIOU",[[1,45576,"- "]],[45576,45576],[45578,45578]]],[1543574932561,["gjx16@GJXAIOU",[[-1,45583,"Ø"]],[45583,45584],[45583,45583]]],[1543574936210,["gjx16@GJXAIOU",[[-1,45619,"Ø  "]],[45619,45621],[45619,45619]]],[1543574937385,["gjx16@GJXAIOU",[[-1,45618,"\n"]],[45618,45618],[45617,45617]]],[1543574943796,["gjx16@GJXAIOU",[[-1,45664,"Ø  "]],[45667,45667],[45664,45664]]],[1543574944845,["gjx16@GJXAIOU",[[-1,45663,"\n"]],[45664,45664],[45663,45663]]],[1543575005766,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45578,"b）"],[-1,45581,"\nØ"],[1,45583,"在第"],[-1,45616,"\nØ"],[1,45618,"友员"],[-1,45661,"\nØ"],[1,45663,"C+"]],[44218,44218],[45665,45665]]],[1543575005766,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45578,"b）"],[1,45583,"\nØ"],[-1,45583,"在第"],[1,45618,"\nØ"],[-1,45618,"友员"],[1,45663,"\nØ"],[-1,45663,"C+"]],[45665,45665],[44218,44218]]],[1543574984705,["gjx16@GJXAIOU",[[1,45578,"\n- "]],[45575,45575],[45578,45578]]],[1543574985953,["gjx16@GJXAIOU",[[-1,45576,"- "]],[45578,45578],[45576,45576]]],[1543575065720,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45579,"b）"],[-1,45582,"\nØ"],[1,45584,"在第"],[-1,45617,"\nØ"],[1,45619,"友员"],[-1,45662,"\nØ"],[1,45664,"C+"]],[44218,44218],[45666,45666]]],[1543575065720,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45579,"b）"],[1,45584,"\nØ"],[-1,45584,"在第"],[1,45619,"\nØ"],[-1,45619,"友员"],[1,45664,"\nØ"],[-1,45664,"C+"]],[45666,45666],[44218,44218]]],[1543575008152,["gjx16@GJXAIOU",[[1,45576,"![19]($resource/19.png)"]],[45576,45576],[45600,45600]]],[1543575027601,["gjx16@GJXAIOU",[[1,45607,"- "],[1,45642,"- "],[1,45687,"- "]],[45607,45705],[45609,45711]]],[1543575030226,["gjx16@GJXAIOU",[[1,45607,"  "],[1,45644,"  "],[1,45691,"  "]],[45609,45711],[45611,45717]]],[1543575034420,["gjx16@GJXAIOU",[[-1,45718,"\n"]],[45718,45718],[45717,45717]]],[1543575039584,["gjx16@GJXAIOU",[[1,45719,"    "]],[45719,45719],[45723,45723]]],[1543575049583,["gjx16@GJXAIOU",[[-1,45740,"** **"]],[45745,45745],[45740,45740]]],[1543575056565,["gjx16@GJXAIOU",[[-1,45753,"****"]],[45757,45757],[45753,45753]]],[1543575059194,["gjx16@GJXAIOU",[[-1,45761,"\n"]],[45760,45761],[45760,45760]]],[1543575060783,["gjx16@GJXAIOU",[[-1,45758,"| "]],[45760,45760],[45758,45758]]],[1543575061906,["gjx16@GJXAIOU",[[-1,45758,"\n"]],[45758,45758],[45757,45757]]],[1543575064230,["gjx16@GJXAIOU",[[1,45757,"`"]],[45757,45757],[45758,45758]]],[1543575125706,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45716,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n`\n#i"]],[44218,44218],[45767,45767]]],[1543575125706,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45718,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n`\n#i"]],[45767,45767],[44218,44218]]],[1543575066507,["gjx16@GJXAIOU",[[1,45759,"`"]],[45759,45759],[45760,45760]]],[1543575066729,["gjx16@GJXAIOU",[[1,45760,"language\n```\n"]],[45760,45760],[45760,45768]]],[1543575067898,["gjx16@GJXAIOU",[[-1,45760,"language"],[1,45768,"c"]],[45760,45768],[45761,45761]]],[1543575069226,["gjx16@GJXAIOU",[[1,45761,"[["]],[45761,45761],[45763,45763]]],[1543575072158,["gjx16@GJXAIOU",[[-1,45761,"[["]],[45763,45763],[45761,45761]]],[1543575077788,["gjx16@GJXAIOU",[[1,45761,"pp"]],[45761,45761],[45763,45763]]],[1543575080716,["gjx16@GJXAIOU",[[-1,45764,"```"]],[45764,45767],[45764,45764]]],[1543575094601,["gjx16@GJXAIOU",[[-1,47054," |"],[1,47056,"```"]],[47054,47056],[47057,47057]]],[1543575245718,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[-1,45540,"a）"],[1,45544,"a）"],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45716,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45765,"\n#i"],[-1,47051," |\n"],[1,47057,"\n\n#"]],[44218,44218],[47060,47060]]],[1543575245718,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[1,45542,"a）"],[-1,45544,"a）"],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45718,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45765,"\n#i"],[1,47054," |\n"],[-1,47057,"\n\n#"]],[47060,47060],[44218,44218]]],[1543575215880,["gjx16@GJXAIOU",[[-1,45764,"\n\n"],[-1,45786,"\n"],[-1,45848,"\n"],[-1,45851,"\n"],[-1,45858," "],[-1,45861,"\n "],[1,45863,"\t"],[-1,45870," "],[-1,45881,"1"],[1,45883,"1"],[-1,45884," "],[-1,45888," "],[1,45889,"\t"],[-1,45898," "],[-1,45902," "],[1,45903,"\t"],[-1,45920," "],[-1,45926," "],[-1,45928," "],[-1,45932," "],[1,45933,"\t"],[-1,45963," "],[-1,45980," "],[-1,45991," "],[-1,45993," "],[-1,45997," "],[1,45998,"\t"],[-1,46028," "],[-1,46054," "],[-1,46056," "],[-1,46067," : \n\n "],[1,46073,":\n\t"],[-1,46080," "],[-1,46084," "],[1,46085,"\t"],[-1,46092," "],[-1,46115," "],[-1,46124," "],[-1,46126,"\n"],[-1,46130,"\n "],[1,46132,"\t"],[-1,46159," "],[-1,46162,"\n {\n\n "],[1,46168,"\t{\n\t\t"],[-1,46216," "],[-1,46226," "],[-1,46229,"\n }\n\n "],[1,46235,"\t}\n\n\t"],[-1,46247," "],[-1,46252," "],[-1,46254," "],[-1,46267," "],[-1,46269,"\n"],[-1,46294,"\n"],[-1,46297,"\n "],[1,46299,"\t"],[-1,46309," "],[-1,46313," "],[1,46314,"\t"],[-1,46321," "],[-1,46323,"\n"],[-1,46352," "],[-1,46358," "],[-1,46360,"                \n"],[-1,46380,"\n "],[1,46382,"\t"],[1,46384," "],[-1,46385," "],[1,46390," "],[-1,46402," "],[-1,46414," "],[-1,46416," "],[-1,46418," "],[-1,46422," "],[1,46423,"\t"],[-1,46473," "],[-1,46483," "],[-1,46486,"\n"],[-1,46513," "],[-1,46544," "],[-1,46547,"\n"],[-1,46550,"\n "],[1,46552,"\t"],[1,46555," "],[-1,46565," "],[-1,46579," "],[-1,46583," "],[-1,46586," "],[-1,46589,"\n "],[1,46591,"\t\t"],[-1,46605," "],[-1,46607," "],[-1,46616," "],[-1,46620," "],[1,46621,"\t"],[-1,46635," "],[-1,46638,"\n "],[1,46640,"\t"],[-1,46653," "],[-1,46655,"\n"],[-1,46683," "],[-1,46713," "],[-1,46715,"\n"],[-1,46719,"\n "],[1,46721,"\t"],[1,46724," "],[-1,46725," "],[-1,46735," "],[-1,46749," "],[-1,46753," "],[-1,46756," "],[-1,46759,"\n "],[1,46761,"\t\t"],[-1,46774," "],[-1,46776," "],[-1,46778," "],[-1,46782," "],[1,46783,"\t"],[-1,46795," "],[-1,46797,"\n"],[-1,46814,"\n"],[-1,46817,"\n "],[1,46819,"\t"],[-1,46824," "],[-1,46827,"\n "],[1,46829,"\t"],[-1,46871," "],[-1,46874,"\n "],[1,46876,"\t"],[-1,46884," "],[-1,46887,"\n "],[1,46889,"\t"],[-1,46898," "],[-1,46900," "],[-1,46902," "],[-1,46905,"\n "],[1,46907,"\t"],[-1,46951," "],[-1,46954,"\n "],[1,46956,"\t"],[-1,46964," "],[-1,46967,"\n "],[1,46969,"\t"],[-1,47014," "],[-1,47017,"\n "],[1,47019,"\t"],[-1,47028," "],[-1,47031,"\n "],[1,47033,"\t"],[-1,47049,"\n"]],[45764,47052],[46934,46934]]],[1543575228059,["gjx16@GJXAIOU",[[-1,46960,"****"],[1,46964,"."]],[46960,46964],[46961,46961]]],[1543575232362,["gjx16@GJXAIOU",[[-1,46997,"****"],[1,47001,"."]],[46997,47001],[46998,46998]]],[1543575236304,["gjx16@GJXAIOU",[[-1,47005,"****"]],[47005,47009],[47005,47005]]],[1543575241912,["gjx16@GJXAIOU",[[-1,47010,"Ø "]],[47010,47012],[47010,47010]]],[1543575243752,["gjx16@GJXAIOU",[[-1,47028,"Ø "]],[47028,47030],[47028,47028]]],[1543575305734,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[-1,45540,"a）"],[1,45544,"a）"],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45716,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45780,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v\t"],[1,45856,"\tvec"],[-1,45860," "],[1,45863,"t"],[1,45870," "],[-1,45871," "],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[-1,46100," i\t"],[1,46103,"\tif "],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46252,"\n"],[-1,46255," d"],[1,46258,"del"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46280,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t i  ="],[1,46323,")\n{\n\tif (i >= "],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46416,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[1,46475,"\tfor"],[-1,46476,"f\t"],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i  "],[1,46529,"i] <"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r\t"],[1,46558,"\tret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46701,"\n"],[-1,46714,"\n"],[-1,46717," i"],[1,46720,"int"],[-1,46722," "],[-1,46725," c"],[1,46728,"cou"],[-1,46767," "],[-1,46770," c\t"],[1,46773,"\tcin"],[-1,46778," "],[-1,46781," v\t"],[1,46784,"\tvec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c\t"],[1,46845,"\tcin"],[-1,46850," "],[-1,46853," c"],[1,46856,"cou"],[-1,46898," "],[-1,46901," c"],[1,46904,"cou"],[-1,46910," "],[-1,46913," s"],[1,46916,"sys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø "],[1,47010,"值运"],[-1,47025,"Ø "],[1,47028,"pe"]],[44218,44218],[47030,47030]]],[1543575305734,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[1,45542,"a）"],[-1,45544,"a）"],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45718,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45783,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v\t"],[-1,45855,"\tvec"],[1,45863," "],[-1,45865,"t"],[-1,45873," "],[1,45875," "],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[1,46102," i\t"],[-1,46102,"\tif "],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46255,"\n"],[1,46257," d"],[-1,46258,"del"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46282,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t i  ="],[-1,46313,")\n{\n\tif (i >= "],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46418,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[-1,46477,"\tfor"],[1,46482,"f\t"],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i  "],[-1,46528,"i] <"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r\t"],[-1,46557,"\tret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46703,"\n"],[1,46717,"\n"],[1,46719," i"],[-1,46720,"int"],[1,46725," "],[1,46727," c"],[-1,46728,"cou"],[1,46770," "],[1,46772," c\t"],[-1,46772,"\tcin"],[1,46781," "],[1,46783," v\t"],[-1,46783,"\tvec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c\t"],[-1,46844,"\tcin"],[1,46853," "],[1,46855," c"],[-1,46856,"cou"],[1,46901," "],[1,46903," c"],[-1,46904,"cou"],[1,46913," "],[1,46915," s"],[-1,46916,"sys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø "],[-1,47011,"值运"],[1,47028,"Ø "],[-1,47029,"pe"]],[47030,47030],[44218,44218]]],[1543575247403,["gjx16@GJXAIOU",[[-1,47027,"\n"]],[47027,47027],[47026,47026]]],[1543575248984,["gjx16@GJXAIOU",[[-1,47047,"\n"]],[47047,47047],[47046,47046]]],[1543575253457,["gjx16@GJXAIOU",[[1,47010,"* "],[1,47027,"* "],[1,47047,"* "]],[47010,47056],[47012,47062]]],[1543575605820,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45715,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v"],[1,45856,"vec"],[-1,45860," "],[1,45863,"t"],[-1,45870,"1"],[1,45872,"1"],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46252,"\n"],[-1,46255," d\t"],[1,46258,"\tdel"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46281,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t i  ="],[1,46323,")\n{\n\tif (i >= "],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46417,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[1,46475,"\tfor"],[-1,46476,"f\t"],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i "],[1,46528,"i]"],[1,46530,"<"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r\t"],[1,46558,"\tret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46702,"\n"],[-1,46714,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c\t"],[1,46773,"\tcin"],[-1,46778," "],[-1,46781," v\t"],[1,46784,"\tvec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c\t"],[1,46845,"\tcin"],[-1,46850," "],[-1,46853," c\t"],[1,46856,"\tcou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s"],[1,46916,"sys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋* "],[1,47012,"* 赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"]],[44218,44218],[47054,47054]]],[1543575605820,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45717,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v"],[-1,45856,"vec"],[1,45863," "],[-1,45865,"t"],[1,45873,"1"],[-1,45874,"1"],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46255,"\n"],[1,46257," d\t"],[-1,46257,"\tdel"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46283,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t i  ="],[-1,46313,")\n{\n\tif (i >= "],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46419,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[-1,46477,"\tfor"],[1,46482,"f\t"],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i "],[-1,46528,"i]"],[-1,46532,"<"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r\t"],[-1,46557,"\tret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46704,"\n"],[1,46717,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c\t"],[-1,46772,"\tcin"],[1,46781," "],[1,46783," v\t"],[-1,46783,"\tvec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c\t"],[-1,46844,"\tcin"],[1,46853," "],[1,46855," c\t"],[-1,46855,"\tcou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s"],[-1,46916,"sys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋* "],[-1,47010,"* 赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"]],[47054,47054],[44218,44218]]],[1543575561337,["gjx16@GJXAIOU",[[-1,47073,"** **_"]],[47073,47078],[47073,47073]]],[1543575563531,["gjx16@GJXAIOU",[[-1,47075,"_ "]],[47077,47077],[47075,47075]]],[1543575566648,["gjx16@GJXAIOU",[[-1,47070,"_ "]],[47072,47072],[47070,47070]]],[1543575568634,["gjx16@GJXAIOU",[[-1,47066,"*_"]],[47068,47068],[47066,47066]]],[1543575574515,["gjx16@GJXAIOU",[[-1,47091,"** **_"]],[47091,47097],[47091,47091]]],[1543575576619,["gjx16@GJXAIOU",[[1,47091,"  "]],[47091,47091],[47093,47093]]],[1543575579772,["gjx16@GJXAIOU",[[-1,47095,"_ "]],[47095,47097],[47095,47095]]],[1543575580422,["gjx16@GJXAIOU",[[1,47095," "]],[47095,47095],[47096,47096]]],[1543575584435,["gjx16@GJXAIOU",[[-1,47101,"**"]],[47101,47103],[47101,47101]]],[1543575592204,["gjx16@GJXAIOU",[[-1,47063,"  *"]],[47066,47066],[47063,47063]]],[1543575593425,["gjx16@GJXAIOU",[[-1,47062,"\n"]],[47063,47063],[47062,47062]]],[1543575594998,["gjx16@GJXAIOU",[[1,47062,"  "]],[47062,47062],[47064,47064]]],[1543575665754,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45715,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[1,45751,"类"],[-1,45753,"*\n\n|` "],[1,45759,"\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45841,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v\t"],[1,45856,"\tvec"],[-1,45860," "],[1,45863,"t"],[-1,45870,"1"],[1,45872,"1"],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46068,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[-1,46100," i"],[1,46103,"if "],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46252,"\n"],[-1,46255," d"],[1,46258,"del"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46280,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t "],[1,46319,")\n{\n\tif ("],[1,46321,">="],[-1,46322,"="],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46416,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[-1,46475," f\t"],[1,46478,"\tfor "],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i "],[1,46528,"i]"],[1,46530,"<"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r\t"],[1,46558,"\tret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46701,"\n"],[-1,46714,"\n"],[-1,46717," i"],[1,46720,"int"],[-1,46722," "],[-1,46725," c"],[1,46728,"cou"],[-1,46767," "],[-1,46770," c\t"],[1,46773,"\tcin"],[-1,46778," "],[-1,46781," v\t"],[1,46784,"\tvec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c"],[1,46856,"cou"],[-1,46898," "],[-1,46901," c"],[1,46904,"cou"],[-1,46910," "],[-1,46913," s"],[1,46916,"sys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n"],[1,46941,"#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋* "],[1,47012,"* 赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"]],[44218,44218],[47100,47100]]],[1543575665754,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45717,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[-1,45753,"类"],[1,45756,"*\n\n|` "],[-1,45756,"\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45844,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v\t"],[-1,45855,"\tvec"],[1,45863," "],[-1,45865,"t"],[1,45873,"1"],[-1,45874,"1"],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46070,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[1,46102," i"],[-1,46103,"if "],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46255,"\n"],[1,46257," d"],[-1,46258,"del"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46282,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t "],[-1,46313,")\n{\n\tif ("],[-1,46324,">="],[1,46327,"="],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46418,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[1,46477," f\t"],[-1,46477,"\tfor "],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i "],[-1,46528,"i]"],[-1,46532,"<"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r\t"],[-1,46557,"\tret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46703,"\n"],[1,46717,"\n"],[1,46719," i"],[-1,46720,"int"],[1,46725," "],[1,46727," c"],[-1,46728,"cou"],[1,46770," "],[1,46772," c\t"],[-1,46772,"\tcin"],[1,46781," "],[1,46783," v\t"],[-1,46783,"\tvec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c"],[-1,46856,"cou"],[1,46901," "],[1,46903," c"],[-1,46904,"cou"],[1,46913," "],[1,46915," s"],[-1,46916,"sys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n"],[-1,46943,"#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋* "],[-1,47010,"* 赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"]],[47100,47100],[44218,44218]]],[1543575624386,["gjx16@GJXAIOU",[[1,47120,"![22]($resource/22.png)"]],[47120,47120],[47144,47144]]],[1543575628162,["gjx16@GJXAIOU",[[1,47120,"\n"]],[47119,47119],[47120,47120]]],[1543575634693,["gjx16@GJXAIOU",[[1,47145,"\n"]],[47144,47144],[47145,47145]]],[1543575644545,["gjx16@GJXAIOU",[[-1,47152,"\n"]],[47152,47152],[47151,47151]]],[1543575646646,["gjx16@GJXAIOU",[[-1,47165,"\n"]],[47165,47165],[47164,47164]]],[1543575648156,["gjx16@GJXAIOU",[[-1,47175,"\n"]],[47175,47175],[47174,47174]]],[1543575725740,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45715,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v"],[1,45856,"vec"],[-1,45860," "],[1,45863,"t"],[-1,45870,"1"],[1,45872,"1"],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46252,"\n"],[-1,46255," d\t"],[1,46258,"\tdel"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46281,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t i  ="],[1,46323,")\n{\n\tif (i >= "],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46417,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[1,46475,"\tfor"],[-1,46476,"f\t"],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i "],[1,46528,"i]"],[1,46530,"<"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r\t"],[1,46558,"\tret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46702,"\n"],[-1,46714,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c"],[1,46773,"cin"],[-1,46778," "],[-1,46781," v"],[1,46784,"vec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c"],[1,46856,"cou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s\t"],[1,46916,"\tsys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋* "],[1,47012,"* 赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47120,"\n"],[-1,47144," "],[1,47145,"\n"],[1,47147," "],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "]],[44218,44218],[47176,47176]]],[1543575725740,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45717,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v"],[-1,45856,"vec"],[1,45863," "],[-1,45865,"t"],[1,45873,"1"],[-1,45874,"1"],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46255,"\n"],[1,46257," d\t"],[-1,46257,"\tdel"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46283,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t i  ="],[-1,46313,")\n{\n\tif (i >= "],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46419,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[-1,46477,"\tfor"],[1,46482,"f\t"],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i "],[-1,46528,"i]"],[-1,46532,"<"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r\t"],[-1,46557,"\tret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46704,"\n"],[1,46717,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c"],[-1,46773,"cin"],[1,46781," "],[1,46783," v"],[-1,46784,"vec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c"],[-1,46856,"cou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s\t"],[-1,46915,"\tsys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋* "],[-1,47010,"* 赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47121,"\n"],[1,47144," "],[-1,47144,"\n"],[-1,47147," "],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "]],[47176,47176],[44218,44218]]],[1543575669219,["gjx16@GJXAIOU",[[-1,47189,"| "]],[47189,47191],[47189,47189]]],[1543575670600,["gjx16@GJXAIOU",[[-1,47190,"\n"]],[47189,47189],[47188,47188]]],[1543575674646,["gjx16@GJXAIOU",[[1,47188,"```"]],[47188,47188],[47191,47191]]],[1543575674850,["gjx16@GJXAIOU",[[1,47191,"language\n```\n"]],[47191,47191],[47191,47199]]],[1543575676970,["gjx16@GJXAIOU",[[-1,47191,"language"],[1,47199,"c"]],[47191,47199],[47192,47192]]],[1543575678275,["gjx16@GJXAIOU",[[1,47192,"pp"]],[47192,47192],[47194,47194]]],[1543575678959,["gjx16@GJXAIOU",[[1,47195,"\n"]],[47194,47194],[47195,47195]]],[1543575684616,["gjx16@GJXAIOU",[[-1,47203,"//obj3 = obj1; // C++编译器提供的  等号操作  也属  浅拷贝\n\n// obj4 = obj3 = obj1\n\n //obj3.operator=(obj1)\n\n Name& operator=(Name &obj1)\n\n {\n\n //1 先释放obj3旧的内存\n\n if (this->m_p != NULL)\n\n {\n\n delete[] m_p;\n\n m_len = 0;\n\n }\n\n //2 根据obj1分配内存大小\n\n this->m_len = obj1.m_len;\n\n this->m_p = new char [m_len+1];\n\n //3把obj1赋值给obj3\n\n strcpy(m_p, obj1.m_p);\n\n return *this;\n\n }\n"]],[47203,47552],[47203,47203]]],[1543575687960,["gjx16@GJXAIOU",[[1,47195,"//obj3 = obj1; // C++编译器提供的  等号操作  也属  浅拷贝\n\n// obj4 = obj3 = obj1\n\n //obj3.operator=(obj1)\n\n Name& operator=(Name &obj1)\n\n {\n\n //1 先释放obj3旧的内存\n\n if (this->m_p != NULL)\n\n {\n\n delete[] m_p;\n\n m_len = 0;\n\n }\n\n //2 根据obj1分配内存大小\n\n this->m_len = obj1.m_len;\n\n this->m_p = new char [m_len+1];\n\n //3把obj1赋值给obj3\n\n strcpy(m_p, obj1.m_p);\n\n return *this;\n\n }\n"]],[47195,47195],[47544,47544]]],[1543575690945,["gjx16@GJXAIOU",[[-1,47238,"\n"]],[47238,47238],[47237,47237]]],[1543575691708,["gjx16@GJXAIOU",[[1,47237,"\\"]],[47237,47237],[47238,47238]]],[1543575693394,["gjx16@GJXAIOU",[[-1,47261,"\n"]],[47261,47261],[47260,47260]]],[1543575696627,["gjx16@GJXAIOU",[[-1,47261," "]],[47262,47262],[47261,47261]]],[1543575698912,["gjx16@GJXAIOU",[[-1,47314,"\n"]],[47314,47314],[47313,47313]]],[1543575700483,["gjx16@GJXAIOU",[[-1,47317,"\n"]],[47317,47317],[47316,47316]]],[1543575703057,["gjx16@GJXAIOU",[[-1,47359,"\n"]],[47359,47359],[47358,47358]]],[1543575704614,["gjx16@GJXAIOU",[[-1,47362,"\n"]],[47362,47362],[47361,47361]]],[1543575706048,["gjx16@GJXAIOU",[[-1,47377,"\n"]],[47377,47377],[47376,47376]]],[1543575965767,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45716,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v\t"],[1,45856,"\tvec"],[-1,45860," "],[1,45863,"t"],[-1,45870,"1"],[1,45872,"1"],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46251,"\n"],[-1,46255," d\t"],[1,46258,"\tdel"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46281,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t "],[1,46319,")\n{\n\tif ("],[1,46321,">="],[-1,46322,"="],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46416,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[-1,46475," f\t"],[1,46478,"\tfor "],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i "],[1,46528,"i]"],[1,46530,"<"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46702,"\n"],[-1,46714,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c\t"],[1,46773,"\tcin"],[-1,46778," "],[-1,46781," v\t"],[1,46784,"\tvec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c\t"],[1,46856,"\tcou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s"],[1,46916,"sys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋"],[1,47012,"赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47120,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,47542,"|\n/"],[1,47545,"\n\n \n"]],[44218,44218],[47549,47549]]],[1543575965767,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45718,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v\t"],[-1,45855,"\tvec"],[1,45863," "],[-1,45865,"t"],[1,45873,"1"],[-1,45874,"1"],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46254,"\n"],[1,46257," d\t"],[-1,46257,"\tdel"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46283,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t "],[-1,46313,")\n{\n\tif ("],[-1,46324,">="],[1,46327,"="],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46418,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[1,46477," f\t"],[-1,46477,"\tfor "],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i "],[-1,46528,"i]"],[-1,46532,"<"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46704,"\n"],[1,46717,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c\t"],[-1,46772,"\tcin"],[1,46781," "],[1,46783," v\t"],[-1,46783,"\tvec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c\t"],[-1,46855,"\tcou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s"],[-1,46916,"sys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋"],[-1,47012,"赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47121,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,47542,"|\n/"],[-1,47542,"\n\n \n"]],[47549,47549],[44218,44218]]],[1543575951315,["gjx16@GJXAIOU",[[-1,47440,"\n"]],[47440,47440],[47439,47439]]],[1543575953879,["gjx16@GJXAIOU",[[-1,47516,"\n"]],[47516,47516],[47515,47515]]],[1543575960435,["gjx16@GJXAIOU",[[-1,47551,"****"]],[47551,47555],[47551,47551]]],[1543575963204,["gjx16@GJXAIOU",[[-1,47560,"****"]],[47560,47564],[47560,47560]]],[1543576025765,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45716,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v\t"],[1,45856,"\tvec"],[-1,45860," "],[1,45863,"t"],[-1,45870,"1"],[1,45872,"1"],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46251,"\n"],[-1,46255," d\t"],[1,46258,"\tdel"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46281,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t "],[1,46319,")\n{\n\tif ("],[1,46321,">="],[-1,46322,"="],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46416,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[-1,46475," f\t"],[1,46478,"\tfor "],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i "],[1,46528,"i]"],[1,46530,"<"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46702,"\n"],[-1,46714,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c\t"],[1,46773,"\tcin"],[-1,46778," "],[-1,46781," v\t"],[1,46784,"\tvec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c\t"],[1,46856,"\tcou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s"],[1,46916,"sys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋"],[1,47012,"赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47120,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,47540,"|\n/"],[1,47543,"\n\n \n"],[-1,47550,"*"],[1,47551,"重"],[-1,47559,"*"],[1,47560,"["]],[44218,44218],[47561,47561]]],[1543576025765,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45718,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v\t"],[-1,45855,"\tvec"],[1,45863," "],[-1,45865,"t"],[1,45873,"1"],[-1,45874,"1"],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46254,"\n"],[1,46257," d\t"],[-1,46257,"\tdel"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46283,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t "],[-1,46313,")\n{\n\tif ("],[-1,46324,">="],[1,46327,"="],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46418,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[1,46477," f\t"],[-1,46477,"\tfor "],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i "],[-1,46528,"i]"],[-1,46532,"<"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46704,"\n"],[1,46717,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c\t"],[-1,46772,"\tcin"],[1,46781," "],[1,46783," v\t"],[-1,46783,"\tvec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c\t"],[-1,46855,"\tcou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s"],[-1,46916,"sys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋"],[-1,47012,"赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47121,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,47540,"|\n/"],[-1,47540,"\n\n \n"],[1,47551,"*"],[-1,47551,"重"],[1,47560,"*"],[-1,47560,"["]],[47561,47561],[44218,44218]]],[1543575966377,["gjx16@GJXAIOU",[[-1,47577,"\n"]],[47577,47577],[47576,47576]]],[1543575968399,["gjx16@GJXAIOU",[[-1,47577,"Ø "]],[47577,47579],[47577,47577]]],[1543575972879,["gjx16@GJXAIOU",[[-1,47597,"Ø "]],[47597,47598],[47597,47597]]],[1543575976065,["gjx16@GJXAIOU",[[1,47566,"- "]],[47566,47566],[47568,47568]]],[1543575981417,["gjx16@GJXAIOU",[[1,47579,"  "]],[47579,47579],[47581,47581]]],[1543575983832,["gjx16@GJXAIOU",[[-1,47600,"\n"]],[47600,47600],[47599,47599]]],[1543575988477,["gjx16@GJXAIOU",[[1,47600,"  "]],[47600,47600],[47602,47602]]],[1543575995499,["gjx16@GJXAIOU",[[-1,47631,"**_"]],[47631,47634],[47631,47631]]],[1543575998999,["gjx16@GJXAIOU",[[-1,47641,"_**"]],[47641,47644],[47641,47641]]],[1543576004138,["gjx16@GJXAIOU",[[1,47631,"- "]],[47631,47631],[47633,47633]]],[1543576007872,["gjx16@GJXAIOU",[[1,47581,"- "]],[47581,47581],[47583,47583]]],[1543576010873,["gjx16@GJXAIOU",[[1,47604,"- "]],[47604,47604],[47606,47606]]],[1543576015071,["gjx16@GJXAIOU",[[-1,47648,"\n"]],[47648,47648],[47647,47647]]],[1543576019814,["gjx16@GJXAIOU",[[1,47648,"  - "]],[47648,47648],[47652,47652]]],[1543576085979,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45715,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v"],[1,45856,"vec"],[-1,45860," "],[1,45863,"t"],[-1,45870,"1"],[1,45872,"1"],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46252,"\n"],[-1,46255," d\t"],[1,46258,"\tdel"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46281,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t i  ="],[1,46323,")\n{\n\tif (i >= "],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46417,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[1,46475,"\tfor"],[-1,46476,"f\t"],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i "],[1,46528,"i]"],[1,46530,"<"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r\t"],[1,46558,"\tret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46702,"\n"],[-1,46714,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c"],[1,46773,"cin"],[-1,46778," "],[-1,46781," v"],[1,46784,"vec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c"],[1,46856,"cou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s\t"],[1,46916,"\tsys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋* "],[1,47012,"* 赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47118,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,47540,"|\n/"],[1,47543,"\n\n \n"],[-1,47550,"*"],[1,47551,"重"],[-1,47559,"*"],[1,47560,"["],[-1,47565,"重"],[1,47568,"重"],[-1,47578,"\n"],[1,47583,"运"],[-1,47601,"\n"],[1,47606,"["],[-1,47634,"*"],[1,47637,"重"],[-1,47646,"_"],[1,47652,"["]],[44218,44218],[47653,47653]]],[1543576085979,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45717,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v"],[-1,45856,"vec"],[1,45863," "],[-1,45865,"t"],[1,45873,"1"],[-1,45874,"1"],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46255,"\n"],[1,46257," d\t"],[-1,46257,"\tdel"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46283,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t i  ="],[-1,46313,")\n{\n\tif (i >= "],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46419,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[-1,46477,"\tfor"],[1,46482,"f\t"],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i "],[-1,46528,"i]"],[-1,46532,"<"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r\t"],[-1,46557,"\tret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46704,"\n"],[1,46717,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c"],[-1,46773,"cin"],[1,46781," "],[1,46783," v"],[-1,46784,"vec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c"],[-1,46856,"cou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s\t"],[-1,46915,"\tsys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋* "],[-1,47010,"* 赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47119,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,47540,"|\n/"],[-1,47540,"\n\n \n"],[1,47551,"*"],[-1,47551,"重"],[1,47560,"*"],[-1,47560,"["],[1,47566,"重"],[-1,47568,"重"],[1,47579,"\n"],[-1,47583,"运"],[1,47602,"\n"],[-1,47606,"["],[1,47635,"*"],[-1,47637,"重"],[1,47647,"_"],[-1,47652,"["]],[47653,47653],[44218,44218]]],[1543576032649,["gjx16@GJXAIOU",[[-1,47792,"****"]],[47792,47796],[47792,47792]]],[1543576035759,["gjx16@GJXAIOU",[[-1,47799,"** **"]],[47799,47804],[47799,47799]]],[1543576045337,["gjx16@GJXAIOU",[[1,47788," \n"]],[47787,47787],[47789,47789]]],[1543576045995,["gjx16@GJXAIOU",[[-1,47788," "],[1,47789,"\n"]],[47789,47789],[47789,47789]]],[1543576046625,["gjx16@GJXAIOU",[[1,47791,"\n"]],[47789,47789],[47790,47790]]],[1543576082356,["gjx16@GJXAIOU",[[1,47789,"![33]($resource/33.png)\n![44]($resource/44.png)"]],[47789,47789],[47837,47837]]],[1543576205998,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[-1,45540,"a）"],[1,45544,"a）"],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45715,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v"],[1,45856,"vec"],[-1,45860," "],[1,45863,"t"],[1,45870," "],[-1,45871," "],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46232,"\n"],[-1,46252,"\n"],[-1,46255," d"],[1,46258,"del"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46280,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t i  ="],[1,46323,")\n{\n\tif (i >= "],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46417,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[1,46475,"\tfor"],[-1,46476,"f\t"],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i  "],[1,46529,"i] <"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46573,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[1,46630,"\tfor"],[-1,46631,"f\t"],[-1,46634," "],[-1,46636," "],[1,46638,"t"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46701,"\n"],[-1,46713,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c"],[1,46773,"cin"],[-1,46778," "],[-1,46781," v"],[1,46784,"vec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c"],[1,46856,"cou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s\t"],[1,46916,"\tsys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋* "],[1,47012,"* 赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47118,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,47540,"|\n/"],[1,47543,"\n\n \n"],[-1,47550,"*"],[1,47551,"重"],[-1,47559,"*"],[1,47560,"["],[-1,47565,"重"],[1,47568,"重"],[-1,47578,"\n"],[1,47583,"运"],[-1,47601,"\n"],[1,47606,"["],[-1,47634,"*"],[1,47637,"重"],[-1,47646,"_"],[1,47652,"["],[-1,47788,"\n"],[-1,47837,"*\n*4*"],[1,47842,"\n\n**4重"],[-1,47848,"*"],[1,47849,"("]],[44218,44218],[47850,47850]]],[1543576205998,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[1,45542,"a）"],[-1,45544,"a）"],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45717,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v"],[-1,45856,"vec"],[1,45863," "],[-1,45865,"t"],[-1,45873," "],[1,45875," "],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46234,"\n"],[1,46255,"\n"],[1,46257," d"],[-1,46258,"del"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46282,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t i  ="],[-1,46313,")\n{\n\tif (i >= "],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46419,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[-1,46477,"\tfor"],[1,46482,"f\t"],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i  "],[-1,46528,"i] <"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46575,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[-1,46632,"\tfor"],[1,46637,"f\t"],[1,46638," "],[1,46639," "],[-1,46640,"t"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46703,"\n"],[1,46716,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c"],[-1,46773,"cin"],[1,46781," "],[1,46783," v"],[-1,46784,"vec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c"],[-1,46856,"cou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s\t"],[-1,46915,"\tsys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋* "],[-1,47010,"* 赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47119,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,47540,"|\n/"],[-1,47540,"\n\n \n"],[1,47551,"*"],[-1,47551,"重"],[1,47560,"*"],[-1,47560,"["],[1,47566,"重"],[-1,47568,"重"],[1,47579,"\n"],[-1,47583,"运"],[1,47602,"\n"],[-1,47606,"["],[1,47635,"*"],[-1,47637,"重"],[1,47647,"_"],[-1,47652,"["],[1,47789,"\n"],[1,47837,"*\n*4*"],[-1,47837,"\n\n**4重"],[1,47849,"*"],[-1,47849,"("]],[47850,47850],[44218,44218]]],[1543576203111,["gjx16@GJXAIOU",[[1,52049,"\n"]],[52048,52048],[52049,52049]]],[1543576203993,["gjx16@GJXAIOU",[[1,52050,"\n"]],[52049,52049],[52050,52050]]],[1543576266471,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[-1,45540,"a）"],[1,45544,"a）"],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45715,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v"],[1,45856,"vec"],[-1,45860," "],[1,45863,"t"],[1,45870," "],[-1,45871," "],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46232,"\n"],[-1,46252,"\n"],[-1,46255," d"],[1,46258,"del"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46280,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t i  ="],[1,46323,")\n{\n\tif (i >= "],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46417,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[1,46475,"\tfor"],[-1,46476,"f\t"],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i  "],[1,46529,"i] <"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46573,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[1,46630,"\tfor"],[-1,46631,"f\t"],[-1,46634," "],[-1,46636," "],[1,46638,"t"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46701,"\n"],[-1,46713,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c"],[1,46773,"cin"],[-1,46778," "],[-1,46781," v"],[1,46784,"vec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c"],[1,46856,"cou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s\t"],[1,46916,"\tsys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋* "],[1,47012,"* 赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47118,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,47540,"|\n/"],[1,47543,"\n\n \n"],[-1,47550,"*"],[1,47551,"重"],[-1,47559,"*"],[1,47560,"["],[-1,47565,"重"],[1,47568,"重"],[-1,47578,"\n"],[1,47583,"运"],[-1,47601,"\n"],[1,47606,"["],[-1,47634,"*"],[1,47637,"重"],[-1,47646,"_"],[1,47652,"["],[-1,47788,"\n"],[-1,47837,"*\n*4*"],[1,47842,"\n\n**4重"],[-1,47848,"*"],[1,47849,"("],[-1,52048,"总"],[1,52051,"总"]],[44218,44218],[52052,52052]]],[1543576266471,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[1,45542,"a）"],[-1,45544,"a）"],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45717,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v"],[-1,45856,"vec"],[1,45863," "],[-1,45865,"t"],[-1,45873," "],[1,45875," "],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46234,"\n"],[1,46255,"\n"],[1,46257," d"],[-1,46258,"del"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46282,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t i  ="],[-1,46313,")\n{\n\tif (i >= "],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46419,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[-1,46477,"\tfor"],[1,46482,"f\t"],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i  "],[-1,46528,"i] <"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46575,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[-1,46632,"\tfor"],[1,46637,"f\t"],[1,46638," "],[1,46639," "],[-1,46640,"t"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46703,"\n"],[1,46716,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c"],[-1,46773,"cin"],[1,46781," "],[1,46783," v"],[-1,46784,"vec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c"],[-1,46856,"cou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s\t"],[-1,46915,"\tsys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋* "],[-1,47010,"* 赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47119,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,47540,"|\n/"],[-1,47540,"\n\n \n"],[1,47551,"*"],[-1,47551,"重"],[1,47560,"*"],[-1,47560,"["],[1,47566,"重"],[-1,47568,"重"],[1,47579,"\n"],[-1,47583,"运"],[1,47602,"\n"],[-1,47606,"["],[1,47635,"*"],[-1,47637,"重"],[1,47647,"_"],[-1,47652,"["],[1,47789,"\n"],[1,47837,"*\n*4*"],[-1,47837,"\n\n**4重"],[1,47849,"*"],[-1,47849,"("],[1,52049,"总"],[-1,52051,"总"]],[52052,52052],[44218,44218]]],[1543576215199,["gjx16@GJXAIOU",[[1,52049,"![55]($resource/55.png)\n![66]($resource/66.png)"]],[52049,52049],[52097,52097]]],[1543576218014,["gjx16@GJXAIOU",[[1,52073,"\n"]],[52072,52072],[52073,52073]]],[1543576254249,["gjx16@GJXAIOU",[[-1,52120,"\n"]],[52120,52120],[52119,52119]]],[1543576255775,["gjx16@GJXAIOU",[[-1,52142,"\n"]],[52142,52142],[52141,52141]]],[1543576257410,["gjx16@GJXAIOU",[[-1,52163,"\n"]],[52163,52163],[52162,52162]]],[1543576259047,["gjx16@GJXAIOU",[[-1,52186,"\n"]],[52186,52186],[52185,52185]]],[1543576260610,["gjx16@GJXAIOU",[[-1,52201,"\n"]],[52201,52201],[52200,52200]]],[1543576262154,["gjx16@GJXAIOU",[[-1,52221,"\n"]],[52221,52221],[52220,52220]]],[1543576263880,["gjx16@GJXAIOU",[[-1,52249,"\n"]],[52249,52249],[52248,52248]]],[1543576265592,["gjx16@GJXAIOU",[[-1,52274,"\n"]],[52274,52274],[52273,52273]]],[1543576326924,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[-1,45540,"a）"],[1,45544,"a）"],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45715,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v"],[1,45856,"vec"],[-1,45860," "],[1,45863,"t"],[1,45870," "],[-1,45871," "],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46232,"\n"],[-1,46252,"\n"],[-1,46255," d"],[1,46258,"del"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46280,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t i  ="],[1,46323,")\n{\n\tif (i >= "],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46417,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[1,46475,"\tfor"],[-1,46476,"f\t"],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i  "],[1,46529,"i] <"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46573,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[1,46630,"\tfor"],[-1,46631,"f\t"],[-1,46634," "],[-1,46636," "],[1,46638,"t"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46701,"\n"],[-1,46713,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c"],[1,46773,"cin"],[-1,46778," "],[-1,46781," v"],[1,46784,"vec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c"],[1,46856,"cou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s\t"],[1,46916,"\tsys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋* "],[1,47012,"* 赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47118,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,47540,"|\n/"],[1,47543,"\n\n \n"],[-1,47550,"*"],[1,47551,"重"],[-1,47559,"*"],[1,47560,"["],[-1,47565,"重"],[1,47568,"重"],[-1,47578,"\n"],[1,47583,"运"],[-1,47601,"\n"],[1,47606,"["],[-1,47634,"*"],[1,47637,"重"],[-1,47646,"_"],[1,47652,"["],[-1,47788,"\n"],[-1,47837,"*\n*4*"],[1,47842,"\n\n**4重"],[-1,47848,"*"],[1,47849,"("],[-1,52048,"总"],[1,52073,""],[1,52099,"总"],[-1,52101,""],[-1,52119,"\n"],[1,52120,"操"],[-1,52141,"\n"],[1,52142,"o"],[-1,52162,"\n"],[1,52163,"f"],[-1,52185,"\n"],[1,52186,"操"],[-1,52200,"\n"],[1,52201,"操"],[-1,52220,"\n"],[1,52221,"="],[-1,52248,"\n"],[1,52249,"+"],[-1,52273,"\n"],[1,52274,"C"]],[44218,44218],[52275,52275]]],[1543576326925,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[1,45542,"a）"],[-1,45544,"a）"],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45717,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v"],[-1,45856,"vec"],[1,45863," "],[-1,45865,"t"],[-1,45873," "],[1,45875," "],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46234,"\n"],[1,46255,"\n"],[1,46257," d"],[-1,46258,"del"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46282,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t i  ="],[-1,46313,")\n{\n\tif (i >= "],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46419,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[-1,46477,"\tfor"],[1,46482,"f\t"],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i  "],[-1,46528,"i] <"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46575,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[-1,46632,"\tfor"],[1,46637,"f\t"],[1,46638," "],[1,46639," "],[-1,46640,"t"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46703,"\n"],[1,46716,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c"],[-1,46773,"cin"],[1,46781," "],[1,46783," v"],[-1,46784,"vec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c"],[-1,46856,"cou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s\t"],[-1,46915,"\tsys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋* "],[-1,47010,"* 赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47119,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,47540,"|\n/"],[-1,47540,"\n\n \n"],[1,47551,"*"],[-1,47551,"重"],[1,47560,"*"],[-1,47560,"["],[1,47566,"重"],[-1,47568,"重"],[1,47579,"\n"],[-1,47583,"运"],[1,47602,"\n"],[-1,47606,"["],[1,47635,"*"],[-1,47637,"重"],[1,47647,"_"],[-1,47652,"["],[1,47789,"\n"],[1,47837,"*\n*4*"],[-1,47837,"\n\n**4重"],[1,47849,"*"],[-1,47849,"("],[1,52049,"总"],[-1,52073,""],[-1,52099,"总"],[1,52102,""],[1,52120,"\n"],[-1,52120,"操"],[1,52142,"\n"],[-1,52142,"o"],[1,52163,"\n"],[-1,52163,"f"],[1,52186,"\n"],[-1,52186,"操"],[1,52201,"\n"],[-1,52201,"操"],[1,52221,"\n"],[-1,52221,"="],[1,52249,"\n"],[-1,52249,"+"],[1,52274,"\n"],[-1,52274,"C"]],[52275,52275],[44218,44218]]],[1543576269647,["gjx16@GJXAIOU",[[1,52103,"* "],[1,52120,"* "],[1,52142,"* "],[1,52163,"* "],[1,52186,"* "],[1,52201,"* "],[1,52221,"* "],[1,52249,"* "],[1,52274,"* "]],[52103,52290],[52105,52308]]],[1543576275204,["gjx16@GJXAIOU",[[1,52103,"  "],[1,52122,"  "],[1,52146,"  "],[1,52169,"  "],[1,52194,"  "],[1,52211,"  "],[1,52233,"  "],[1,52263,"  "],[1,52290,"  "]],[52103,52308],[52103,52326]]],[1543576277986,["gjx16@GJXAIOU",[[-1,52102,"\n"]],[52102,52102],[52101,52101]]],[1543576282212,["gjx16@GJXAIOU",[[1,52099,"- "]],[52099,52099],[52101,52101]]],[1543576322264,["gjx16@GJXAIOU",[[-1,51054,"| \n"]],[51054,51057],[51054,51054]]],[1543576325951,["gjx16@GJXAIOU",[[1,51054,"```"]],[51054,51054],[51057,51057]]],[1543576326093,["gjx16@GJXAIOU",[[1,51057,"language\n```\n"]],[51057,51057],[51057,51065]]],[1543576388165,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45716,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v\t"],[1,45856,"\tvec"],[-1,45860," "],[1,45863,"t"],[-1,45870,"1"],[1,45872,"1"],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46251,"\n"],[-1,46255," d\t"],[1,46258,"\tdel"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46281,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t "],[1,46319,")\n{\n\tif ("],[1,46321,">="],[-1,46322,"="],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46416,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[-1,46475," f\t"],[1,46478,"\tfor "],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i "],[1,46528,"i]"],[1,46530,"<"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46702,"\n"],[-1,46714,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c\t"],[1,46773,"\tcin"],[-1,46778," "],[-1,46781," v\t"],[1,46784,"\tvec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c\t"],[1,46856,"\tcou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s"],[1,46916,"sys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋"],[1,47012,"赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47120,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,47540,"|\n/"],[1,47543,"\n\n \n"],[-1,47550,"*"],[1,47551,"重"],[-1,47559,"*"],[1,47560,"["],[-1,47565,"重"],[1,47568,"重"],[-1,47578,"\n"],[1,47583,"运"],[-1,47601,"\n"],[1,47606,"["],[-1,47634,"*"],[1,47637,"重"],[-1,47646,"_"],[1,47652,"["],[-1,47788,"\n"],[-1,47837,"*\n*4*"],[1,47842,"\n\n**4重"],[-1,47848,"*"],[1,47849,"("],[-1,51053,"|"],[1,51054,""],[1,51070,"\n"],[-1,52061,"总"],[1,52062,""],[1,52114,"总"],[-1,52115,"\n"],[1,52121,"操"],[-1,52137,"\n"],[1,52142,"操"],[-1,52163,"\n"],[1,52168,"o"],[-1,52187,"\n"],[1,52193,"f"],[-1,52214,"\n"],[1,52220,"操"],[-1,52234,"\n"],[1,52239,"操"],[-1,52258,"\n"],[1,52263,"="],[-1,52290,"\n"],[1,52295,"+"],[-1,52319,"\n"],[1,52324,"C"]],[44218,44218],[52325,52325]]],[1543576388165,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45718,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v\t"],[-1,45855,"\tvec"],[1,45863," "],[-1,45865,"t"],[1,45873,"1"],[-1,45874,"1"],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46254,"\n"],[1,46257," d\t"],[-1,46257,"\tdel"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46283,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t "],[-1,46313,")\n{\n\tif ("],[-1,46324,">="],[1,46327,"="],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46418,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[1,46477," f\t"],[-1,46477,"\tfor "],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i "],[-1,46528,"i]"],[-1,46532,"<"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46704,"\n"],[1,46717,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c\t"],[-1,46772,"\tcin"],[1,46781," "],[1,46783," v\t"],[-1,46783,"\tvec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c\t"],[-1,46855,"\tcou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s"],[-1,46916,"sys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋"],[-1,47012,"赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47121,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,47540,"|\n/"],[-1,47540,"\n\n \n"],[1,47551,"*"],[-1,47551,"重"],[1,47560,"*"],[-1,47560,"["],[1,47566,"重"],[-1,47568,"重"],[1,47579,"\n"],[-1,47583,"运"],[1,47602,"\n"],[-1,47606,"["],[1,47635,"*"],[-1,47637,"重"],[1,47647,"_"],[-1,47652,"["],[1,47789,"\n"],[1,47837,"*\n*4*"],[-1,47837,"\n\n**4重"],[1,47849,"*"],[-1,47849,"("],[1,51054,"|"],[-1,51054,""],[-1,51070,"\n"],[1,52062,"总"],[-1,52062,""],[-1,52114,"总"],[1,52116,"\n"],[-1,52121,"操"],[1,52138,"\n"],[-1,52142,"操"],[1,52164,"\n"],[-1,52168,"o"],[1,52188,"\n"],[-1,52193,"f"],[1,52215,"\n"],[-1,52220,"操"],[1,52235,"\n"],[-1,52239,"操"],[1,52259,"\n"],[-1,52263,"="],[1,52291,"\n"],[-1,52295,"+"],[1,52320,"\n"],[-1,52324,"C"]],[52325,52325],[44218,44218]]],[1543576329189,["gjx16@GJXAIOU",[[1,51061,"\n"]],[51060,51060],[51061,51061]]],[1543576333767,["gjx16@GJXAIOU",[[-1,51062,"```\n"]],[51061,51065],[51061,51061]]],[1543576372267,["gjx16@GJXAIOU",[[-1,51605," |\n\n| "],[1,51611,"\n```"]],[51605,51611],[51609,51609]]],[1543576374769,["gjx16@GJXAIOU",[[-1,51605,"\n"]],[51605,51605],[51604,51604]]],[1543576377132,["gjx16@GJXAIOU",[[1,51610,"\n"]],[51609,51609],[51610,51610]]],[1543576379273,["gjx16@GJXAIOU",[[1,51610,"···"]],[51610,51610],[51613,51613]]],[1543576382830,["gjx16@GJXAIOU",[[-1,51610,"···"]],[51613,51613],[51610,51610]]],[1543576384876,["gjx16@GJXAIOU",[[1,51610,"```"]],[51610,51610],[51613,51613]]],[1543576385069,["gjx16@GJXAIOU",[[1,51613,"language\n```\n"]],[51613,51613],[51613,51621]]],[1543576385890,["gjx16@GJXAIOU",[[-1,51613,"language"],[1,51621,"c"]],[51613,51621],[51614,51614]]],[1543576387299,["gjx16@GJXAIOU",[[1,51614,"pp"]],[51614,51614],[51616,51616]]],[1543576448143,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45716,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v\t"],[1,45856,"\tvec"],[-1,45860," "],[1,45863,"t"],[-1,45870,"1"],[1,45872,"1"],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46251,"\n"],[-1,46255," d\t"],[1,46258,"\tdel"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46281,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t "],[1,46319,")\n{\n\tif ("],[1,46321,">="],[-1,46322,"="],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46416,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[-1,46475," f\t"],[1,46478,"\tfor "],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i "],[1,46528,"i]"],[1,46530,"<"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46702,"\n"],[-1,46714,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c\t"],[1,46773,"\tcin"],[-1,46778," "],[-1,46781," v\t"],[1,46784,"\tvec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c\t"],[1,46856,"\tcou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s"],[1,46916,"sys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋"],[1,47012,"赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47120,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,47540,"|\n/"],[1,47543,"\n\n \n"],[-1,47550,"*"],[1,47551,"重"],[-1,47559,"*"],[1,47560,"["],[-1,47565,"重"],[1,47568,"重"],[-1,47578,"\n"],[1,47583,"运"],[-1,47601,"\n"],[1,47606,"["],[-1,47634,"*"],[1,47637,"重"],[-1,47646,"_"],[1,47652,"["],[-1,47788,"\n"],[-1,47837,"*\n*4*"],[1,47842,"\n\n**4重"],[-1,47848,"*"],[1,47849,"("],[-1,51053,"|"],[-1,51057,"lang"],[1,51061,"cpp"],[-1,51063,"```"],[1,51605,"};\n\n"],[-1,51622,"| \n\n"],[-1,52067,"总"],[1,52068,""],[1,52120,"总"],[-1,52121,"\n"],[1,52127,"操"],[-1,52143,"\n"],[1,52148,"操"],[-1,52169,"\n"],[1,52174,"o"],[-1,52193,"\n"],[1,52199,"f"],[-1,52220,"\n"],[1,52226,"操"],[-1,52240,"\n"],[1,52245,"操"],[-1,52264,"\n"],[1,52269,"="],[-1,52296,"\n"],[1,52301,"+"],[-1,52325,"\n"],[1,52330,"C"]],[44218,44218],[52331,52331]]],[1543576448143,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45718,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v\t"],[-1,45855,"\tvec"],[1,45863," "],[-1,45865,"t"],[1,45873,"1"],[-1,45874,"1"],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46254,"\n"],[1,46257," d\t"],[-1,46257,"\tdel"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46283,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t "],[-1,46313,")\n{\n\tif ("],[-1,46324,">="],[1,46327,"="],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46418,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[1,46477," f\t"],[-1,46477,"\tfor "],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i "],[-1,46528,"i]"],[-1,46532,"<"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46704,"\n"],[1,46717,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c\t"],[-1,46772,"\tcin"],[1,46781," "],[1,46783," v\t"],[-1,46783,"\tvec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c\t"],[-1,46855,"\tcou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s"],[-1,46916,"sys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋"],[-1,47012,"赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47121,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,47540,"|\n/"],[-1,47540,"\n\n \n"],[1,47551,"*"],[-1,47551,"重"],[1,47560,"*"],[-1,47560,"["],[1,47566,"重"],[-1,47568,"重"],[1,47579,"\n"],[-1,47583,"运"],[1,47602,"\n"],[-1,47606,"["],[1,47635,"*"],[-1,47637,"重"],[1,47647,"_"],[-1,47652,"["],[1,47789,"\n"],[1,47837,"*\n*4*"],[-1,47837,"\n\n**4重"],[1,47849,"*"],[-1,47849,"("],[1,51054,"|"],[1,51057,"lang"],[-1,51057,"cpp"],[1,51062,"```"],[-1,51601,"};\n\n"],[1,51622,"| \n\n"],[1,52063,"总"],[-1,52063,""],[-1,52115,"总"],[1,52117,"\n"],[-1,52122,"操"],[1,52139,"\n"],[-1,52143,"操"],[1,52165,"\n"],[-1,52169,"o"],[1,52189,"\n"],[-1,52194,"f"],[1,52216,"\n"],[-1,52221,"操"],[1,52236,"\n"],[-1,52240,"操"],[1,52260,"\n"],[-1,52264,"="],[1,52292,"\n"],[-1,52296,"+"],[1,52321,"\n"],[-1,52325,"C"]],[52331,52331],[44218,44218]]],[1543576390139,["gjx16@GJXAIOU",[[-1,51617,"```"]],[51617,51620],[51617,51617]]],[1543576396450,["gjx16@GJXAIOU",[[-1,52032,"\n |"],[1,52035,"```"]],[52032,52035],[52035,52035]]],[1543578128225,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[-1,45540,"a）"],[1,45544,"a）"],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45715,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v"],[1,45856,"vec"],[-1,45860," "],[1,45863,"t"],[1,45870," "],[-1,45871," "],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46232,"\n"],[-1,46252,"\n"],[-1,46255," d"],[1,46258,"del"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46280,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t "],[1,46319,")\n{\n\tif ("],[1,46321,">="],[-1,46322,"="],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46416,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[-1,46475," f"],[1,46478,"for "],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i  "],[1,46529,"i] <"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46573,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[1,46630,"\tfor"],[-1,46631,"f\t"],[-1,46634," "],[-1,46636," "],[1,46638,"t"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46701,"\n"],[-1,46713,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c"],[1,46773,"cin"],[-1,46778," "],[-1,46781," v"],[1,46784,"vec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c"],[1,46856,"cou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s\t"],[1,46916,"\tsys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋* "],[1,47012,"* 赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47118,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,47540,"|\n/"],[1,47543,"\n\n \n"],[-1,47550,"*"],[1,47551,"重"],[-1,47559,"*"],[1,47560,"["],[-1,47565,"重"],[1,47568,"重"],[-1,47578,"\n"],[1,47583,"运"],[-1,47601,"\n"],[1,47606,"["],[-1,47634,"*"],[1,47637,"重"],[-1,47646,"_"],[1,47652,"["],[-1,47788,"\n"],[-1,47837,"*\n*4*"],[1,47842,"\n\n**4重"],[-1,47848,"*"],[1,47849,"("],[-1,51053,"|"],[-1,51057,"lang"],[1,51061,"cpp"],[-1,51063,"```"],[1,51605,"};\n\n"],[-1,51619,"| \n\n"],[1,52032,"\n};\n"],[-1,52035,"\n\n |"],[-1,52064,"总"],[1,52065,""],[1,52117,"总"],[-1,52118,"\n"],[1,52124,"操"],[-1,52140,"\n"],[1,52145,"操"],[-1,52166,"\n"],[1,52171,"o"],[-1,52190,"\n"],[1,52196,"f"],[-1,52217,"\n"],[1,52223,"操"],[-1,52237,"\n"],[1,52242,"操"],[-1,52261,"\n"],[1,52266,"="],[-1,52293,"\n"],[1,52298,"+"],[-1,52322,"\n"],[1,52327,"C"]],[44218,44218],[52328,52328]]],[1543578128225,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[1,45542,"a）"],[-1,45544,"a）"],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45717,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v"],[-1,45856,"vec"],[1,45863," "],[-1,45865,"t"],[-1,45873," "],[1,45875," "],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46234,"\n"],[1,46255,"\n"],[1,46257," d"],[-1,46258,"del"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46282,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t "],[-1,46313,")\n{\n\tif ("],[-1,46324,">="],[1,46327,"="],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46418,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[1,46477," f"],[-1,46478,"for "],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i  "],[-1,46528,"i] <"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46575,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[-1,46632,"\tfor"],[1,46637,"f\t"],[1,46638," "],[1,46639," "],[-1,46640,"t"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46703,"\n"],[1,46716,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c"],[-1,46773,"cin"],[1,46781," "],[1,46783," v"],[-1,46784,"vec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c"],[-1,46856,"cou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s\t"],[-1,46915,"\tsys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋* "],[-1,47010,"* 赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47119,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,47540,"|\n/"],[-1,47540,"\n\n \n"],[1,47551,"*"],[-1,47551,"重"],[1,47560,"*"],[-1,47560,"["],[1,47566,"重"],[-1,47568,"重"],[1,47579,"\n"],[-1,47583,"运"],[1,47602,"\n"],[-1,47606,"["],[1,47635,"*"],[-1,47637,"重"],[1,47647,"_"],[-1,47652,"["],[1,47789,"\n"],[1,47837,"*\n*4*"],[-1,47837,"\n\n**4重"],[1,47849,"*"],[-1,47849,"("],[1,51054,"|"],[1,51057,"lang"],[-1,51057,"cpp"],[1,51062,"```"],[-1,51601,"};\n\n"],[1,51619,"| \n\n"],[-1,52028,"\n};\n"],[1,52035,"\n\n |"],[1,52060,"总"],[-1,52060,""],[-1,52112,"总"],[1,52114,"\n"],[-1,52119,"操"],[1,52136,"\n"],[-1,52140,"操"],[1,52162,"\n"],[-1,52166,"o"],[1,52186,"\n"],[-1,52191,"f"],[1,52213,"\n"],[-1,52218,"操"],[1,52233,"\n"],[-1,52237,"操"],[1,52257,"\n"],[-1,52261,"="],[1,52289,"\n"],[-1,52293,"+"],[1,52318,"\n"],[-1,52322,"C"]],[52328,52328],[44218,44218]]],[1543578094680,["gjx16@GJXAIOU",[[1,47197,"重载 = 操作符\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\t//"],[1,47239,"\t"],[1,47261,"\t"],[-1,47285," "],[1,47286,"\t"],[-1,47314," {\n "],[1,47318,"\t{\n\t\t"],[-1,47335," "],[1,47336,"\t\t"],[-1,47346,"m_p"],[1,47349,"pName"],[-1,47359," {\n "],[1,47363,"\t\t{\n\t\t\t"],[-1,47372,"m_p;\n m_len"],[1,47383,"pName;\n\t\t\tsize"],[-1,47390," }\n\n "],[1,47395,"\t\t}\n\n\t\t"],[-1,47413," "],[1,47414,"\t\t"],[-1,47420,"m_len"],[1,47425,"size"],[-1,47433,"m_len;\n "],[1,47441,"size;\n\t\t"],[-1,47447,"m_"],[1,47450,"Name"],[-1,47461," [m_len+"],[1,47469,"[size + "],[-1,47474," "],[1,47475,"\t\t"],[-1,47492," "],[1,47493,"\t\t"],[-1,47500,"m_p"],[1,47503,"pName"],[-1,47510,"m_p);\n "],[1,47517,"pName);\n\t\t"],[1,47532,"\t}\n\nprotected:\n\nprivate:\n\n\tchar"],[1,47533,"*pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nint main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n"]],[47195,47534],[48371,48371]]],[1543578102252,["gjx16@GJXAIOU",[[-1,48384,"\n"]],[48384,48384],[48383,48383]]],[1543578103370,["gjx16@GJXAIOU",[[-1,48381," |"]],[48383,48383],[48381,48381]]],[1543578104908,["gjx16@GJXAIOU",[[-1,48381,"\n"]],[48381,48381],[48380,48380]]],[1543578106046,["gjx16@GJXAIOU",[[-1,48379," "]],[48380,48380],[48379,48379]]],[1543578107108,["gjx16@GJXAIOU",[[-1,48379,"\n"]],[48379,48379],[48378,48378]]],[1543578108173,["gjx16@GJXAIOU",[[-1,48378,"\n"]],[48378,48378],[48377,48377]]],[1543578112803,["gjx16@GJXAIOU",[[-1,48507,"_"]],[48507,48508],[48507,48507]]],[1543578114719,["gjx16@GJXAIOU",[[-1,48509,"_"]],[48509,48510],[48509,48509]]],[1543578116789,["gjx16@GJXAIOU",[[-1,48510,"**_"]],[48510,48513],[48510,48510]]],[1543578119317,["gjx16@GJXAIOU",[[-1,48511,"_**"]],[48511,48514],[48511,48511]]],[1543578120796,["gjx16@GJXAIOU",[[-1,48528,"_"]],[48529,48529],[48528,48528]]],[1543578122101,["gjx16@GJXAIOU",[[-1,48530,"_"]],[48531,48531],[48530,48530]]],[1543578368257,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45716,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v\t"],[1,45856,"\tvec"],[-1,45860," "],[1,45863,"t"],[-1,45870,"1"],[1,45872,"1"],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46251,"\n"],[-1,46255," d\t"],[1,46258,"\tdel"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46281,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t "],[1,46319,")\n{\n\tif ("],[1,46321,">="],[-1,46322,"="],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46416,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[-1,46475," f\t"],[1,46478,"\tfor "],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i "],[1,46528,"i]"],[1,46530,"<"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46702,"\n"],[-1,46714,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c\t"],[1,46773,"\tcin"],[-1,46778," "],[-1,46781," v\t"],[1,46784,"\tvec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c\t"],[1,46856,"\tcou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s"],[1,46916,"sys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋"],[1,47012,"赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47120,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,48377,"|*3*"],[1,48381,"\n**3重"],[-1,48389,"*"],[1,48390,"["],[-1,48395,"重"],[1,48398,"重"],[-1,48408,"\n"],[1,48413,"运"],[-1,48430,"\n"],[1,48436,"["],[-1,48464,"*"],[1,48467,"重"],[-1,48476,"_"],[1,48482,"["],[-1,48506,"_型_*_"],[1,48511,"类型 类 "],[-1,48527,"_型_"],[1,48530,"类型 "],[-1,48608,"\n"],[-1,48657,"*\n*4*"],[1,48662,"\n\n**4重"],[-1,48668,"*"],[1,48669,"("],[-1,51873,"|"],[-1,51877,"lang"],[1,51881,"cpp"],[-1,51883,"```"],[1,52425,"};\n\n"],[-1,52439,"| \n\n"],[1,52852,"\n};\n"],[-1,52855,"\n\n |"],[-1,52884,"总"],[1,52885,""],[1,52937,"总"],[-1,52938,"\n"],[1,52944,"操"],[-1,52960,"\n"],[1,52965,"操"],[-1,52986,"\n"],[1,52991,"o"],[-1,53010,"\n"],[1,53016,"f"],[-1,53037,"\n"],[1,53043,"操"],[-1,53057,"\n"],[1,53062,"操"],[-1,53081,"\n"],[1,53086,"="],[-1,53113,"\n"],[1,53118,"+"],[-1,53142,"\n"],[1,53147,"C"]],[44218,44218],[53148,53148]]],[1543578368257,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45718,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v\t"],[-1,45855,"\tvec"],[1,45863," "],[-1,45865,"t"],[1,45873,"1"],[-1,45874,"1"],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46254,"\n"],[1,46257," d\t"],[-1,46257,"\tdel"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46283,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t "],[-1,46313,")\n{\n\tif ("],[-1,46324,">="],[1,46327,"="],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46418,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[1,46477," f\t"],[-1,46477,"\tfor "],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i "],[-1,46528,"i]"],[-1,46532,"<"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46704,"\n"],[1,46717,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c\t"],[-1,46772,"\tcin"],[1,46781," "],[1,46783," v\t"],[-1,46783,"\tvec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c\t"],[-1,46855,"\tcou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s"],[-1,46916,"sys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋"],[-1,47012,"赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47121,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,48377,"|*3*"],[-1,48377,"\n**3重"],[1,48390,"*"],[-1,48390,"["],[1,48396,"重"],[-1,48398,"重"],[1,48409,"\n"],[-1,48413,"运"],[1,48431,"\n"],[-1,48436,"["],[1,48465,"*"],[-1,48467,"重"],[1,48477,"_"],[-1,48482,"["],[1,48507,"_型_*_"],[-1,48507,"类型 类 "],[1,48528,"_型_"],[-1,48528,"类型 "],[1,48609,"\n"],[1,48657,"*\n*4*"],[-1,48657,"\n\n**4重"],[1,48669,"*"],[-1,48669,"("],[1,51874,"|"],[1,51877,"lang"],[-1,51877,"cpp"],[1,51882,"```"],[-1,52421,"};\n\n"],[1,52439,"| \n\n"],[-1,52848,"\n};\n"],[1,52855,"\n\n |"],[1,52880,"总"],[-1,52880,""],[-1,52932,"总"],[1,52934,"\n"],[-1,52939,"操"],[1,52956,"\n"],[-1,52960,"操"],[1,52982,"\n"],[-1,52986,"o"],[1,53006,"\n"],[-1,53011,"f"],[1,53033,"\n"],[-1,53038,"操"],[1,53053,"\n"],[-1,53057,"操"],[1,53077,"\n"],[-1,53081,"="],[1,53109,"\n"],[-1,53113,"+"],[1,53138,"\n"],[-1,53142,"C"]],[53148,53148],[44218,44218]]],[1543578337628,["gjx16@GJXAIOU",[[-1,48747,"** **"]],[48747,48752],[48747,48747]]],[1543578339805,["gjx16@GJXAIOU",[[-1,48751,"** **"]],[48751,48756],[48751,48751]]],[1543578342554,["gjx16@GJXAIOU",[[-1,48767,"*"]],[48768,48768],[48767,48767]]],[1543578344630,["gjx16@GJXAIOU",[[-1,48786,"**"]],[48786,48788],[48786,48786]]],[1543578346469,["gjx16@GJXAIOU",[[-1,48765," *"]],[48765,48767],[48765,48765]]],[1543578347365,["gjx16@GJXAIOU",[[-1,48764,"\n"]],[48765,48765],[48764,48764]]],[1543578349597,["gjx16@GJXAIOU",[[-1,48762,"*"]],[48763,48763],[48762,48762]]],[1543578351713,["gjx16@GJXAIOU",[[-1,48742,"**"]],[48742,48744],[48742,48742]]],[1543578353977,["gjx16@GJXAIOU",[[-1,48739,"*"]],[48740,48740],[48739,48739]]],[1543578356691,["gjx16@GJXAIOU",[[-1,48732,"**_"]],[48735,48735],[48732,48732]]],[1543578359285,["gjx16@GJXAIOU",[[-1,48734,"_*"]],[48734,48736],[48734,48734]]],[1543578361829,["gjx16@GJXAIOU",[[-1,48776,"**"]],[48776,48778],[48776,48776]]],[1543578363861,["gjx16@GJXAIOU",[[-1,48781,"**"]],[48781,48783],[48781,48781]]],[1543578365429,["gjx16@GJXAIOU",[[-1,48775,"\n"]],[48775,48775],[48774,48774]]],[1543578367521,["gjx16@GJXAIOU",[[-1,48782," **"]],[48782,48785],[48782,48782]]],[1543578428253,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45716,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v\t"],[1,45856,"\tvec"],[-1,45860," "],[1,45863,"t"],[-1,45870,"1"],[1,45872,"1"],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46251,"\n"],[-1,46255," d\t"],[1,46258,"\tdel"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46281,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t "],[1,46319,")\n{\n\tif ("],[1,46321,">="],[-1,46322,"="],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46416,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[-1,46475," f\t"],[1,46478,"\tfor "],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i "],[1,46528,"i]"],[1,46530,"<"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46702,"\n"],[-1,46714,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c\t"],[1,46773,"\tcin"],[-1,46778," "],[-1,46781," v\t"],[1,46784,"\tvec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c\t"],[1,46856,"\tcou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s"],[1,46916,"sys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋"],[1,47012,"赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47120,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,48377,"|*3*"],[1,48381,"\n**3重"],[-1,48389,"*"],[1,48390,"["],[-1,48395,"重"],[1,48398,"重"],[-1,48408,"\n"],[1,48413,"运"],[-1,48430,"\n"],[1,48436,"["],[-1,48464,"*"],[1,48467,"重"],[-1,48476,"_"],[1,48482,"["],[-1,48506,"_型_*_"],[1,48511,"类型 类 "],[-1,48527,"_型_"],[1,48530,"类型 "],[-1,48608,"\n"],[-1,48657,"*\n*4*"],[1,48662,"\n\n**4重"],[-1,48668,"*"],[1,48669,"("],[-1,48731,"*1_\n* x*类 X*"],[1,48743,"例1\n\n设 x是类 X的"],[-1,48753,"*"],[1,48755,"x"],[-1,48773,"*"],[1,48775,"可"],[-1,48779,"*\n "],[1,48782,"\n\nx"],[-1,51840,"|"],[-1,51844,"lang"],[1,51848,"cpp"],[-1,51850,"```"],[1,52392,"};\n\n"],[-1,52406,"| \n\n"],[1,52819,"\n};\n"],[-1,52822,"\n\n |"],[-1,52851,"总"],[1,52852,""],[1,52904,"总"],[-1,52905,"\n"],[1,52911,"操"],[-1,52927,"\n"],[1,52932,"操"],[-1,52953,"\n"],[1,52958,"o"],[-1,52977,"\n"],[1,52983,"f"],[-1,53004,"\n"],[1,53010,"操"],[-1,53024,"\n"],[1,53029,"操"],[-1,53048,"\n"],[1,53053,"="],[-1,53080,"\n"],[1,53085,"+"],[-1,53109,"\n"],[1,53114,"C"]],[44218,44218],[53115,53115]]],[1543578428253,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45718,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v\t"],[-1,45855,"\tvec"],[1,45863," "],[-1,45865,"t"],[1,45873,"1"],[-1,45874,"1"],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46254,"\n"],[1,46257," d\t"],[-1,46257,"\tdel"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46283,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t "],[-1,46313,")\n{\n\tif ("],[-1,46324,">="],[1,46327,"="],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46418,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[1,46477," f\t"],[-1,46477,"\tfor "],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i "],[-1,46528,"i]"],[-1,46532,"<"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46704,"\n"],[1,46717,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c\t"],[-1,46772,"\tcin"],[1,46781," "],[1,46783," v\t"],[-1,46783,"\tvec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c\t"],[-1,46855,"\tcou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s"],[-1,46916,"sys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋"],[-1,47012,"赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47121,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,48377,"|*3*"],[-1,48377,"\n**3重"],[1,48390,"*"],[-1,48390,"["],[1,48396,"重"],[-1,48398,"重"],[1,48409,"\n"],[-1,48413,"运"],[1,48431,"\n"],[-1,48436,"["],[1,48465,"*"],[-1,48467,"重"],[1,48477,"_"],[-1,48482,"["],[1,48507,"_型_*_"],[-1,48507,"类型 类 "],[1,48528,"_型_"],[-1,48528,"类型 "],[1,48609,"\n"],[1,48657,"*\n*4*"],[-1,48657,"\n\n**4重"],[1,48669,"*"],[-1,48669,"("],[1,48732,"*1_\n* x*类 X*"],[-1,48732,"例1\n\n设 x是类 X的"],[1,48754,"*"],[-1,48755,"x"],[1,48774,"*"],[-1,48775,"可"],[1,48780,"*\n "],[-1,48780,"\n\nx"],[1,51841,"|"],[1,51844,"lang"],[-1,51844,"cpp"],[1,51849,"```"],[-1,52388,"};\n\n"],[1,52406,"| \n\n"],[-1,52815,"\n};\n"],[1,52822,"\n\n |"],[1,52847,"总"],[-1,52847,""],[-1,52899,"总"],[1,52901,"\n"],[-1,52906,"操"],[1,52923,"\n"],[-1,52927,"操"],[1,52949,"\n"],[-1,52953,"o"],[1,52973,"\n"],[-1,52978,"f"],[1,53000,"\n"],[-1,53005,"操"],[1,53020,"\n"],[-1,53024,"操"],[1,53044,"\n"],[-1,53048,"="],[1,53076,"\n"],[-1,53080,"+"],[1,53105,"\n"],[-1,53109,"C"]],[53115,53115],[44218,44218]]],[1543578370164,["gjx16@GJXAIOU",[[-1,48814,"**"]],[48814,48816],[48814,48814]]],[1543578371212,["gjx16@GJXAIOU",[[-1,48781,"\n"]],[48781,48781],[48780,48780]]],[1543579879950,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45716,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v\t"],[1,45856,"\tvec"],[-1,45860," "],[1,45863,"t"],[-1,45870,"1"],[1,45872,"1"],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46251,"\n"],[-1,46255," d\t"],[1,46258,"\tdel"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46281,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t "],[1,46319,")\n{\n\tif ("],[1,46321,">="],[-1,46322,"="],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46416,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[-1,46475," f\t"],[1,46478,"\tfor "],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i "],[1,46528,"i]"],[1,46530,"<"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46702,"\n"],[-1,46714,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c\t"],[1,46773,"\tcin"],[-1,46778," "],[-1,46781," v\t"],[1,46784,"\tvec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c\t"],[1,46856,"\tcou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s"],[1,46916,"sys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋"],[1,47012,"赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47120,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,48377,"|*3*"],[1,48381,"\n**3重"],[-1,48389,"*"],[1,48390,"["],[-1,48395,"重"],[1,48398,"重"],[-1,48408,"\n"],[1,48413,"运"],[-1,48430,"\n"],[1,48436,"["],[-1,48464,"*"],[1,48467,"重"],[-1,48476,"_"],[1,48482,"["],[-1,48506,"_型_*_"],[1,48511,"类型 类 "],[-1,48527,"_型_"],[1,48530,"类型 "],[-1,48608,"\n"],[-1,48657,"*\n*4*"],[1,48662,"\n\n**4重"],[-1,48668,"*"],[1,48669,"("],[-1,48731,"*1_\n* x*类 X*"],[1,48743,"例1\n\n设 x是类 X的"],[-1,48753,"*"],[1,48755,"x"],[-1,48773,"*"],[1,48775,"可"],[-1,48779,"*"],[1,48781,"x"],[-1,48812,"*"],[1,48813,"\n"],[-1,51837,"|"],[-1,51841,"lang"],[1,51845,"cpp"],[-1,51847,"```"],[1,52389,"};\n\n"],[-1,52403,"| \n\n"],[1,52816,"\n};\n"],[-1,52819,"\n\n |"],[-1,52848,"总"],[1,52849,""],[1,52901,"总"],[-1,52902,"\n"],[1,52908,"操"],[-1,52924,"\n"],[1,52929,"操"],[-1,52950,"\n"],[1,52955,"o"],[-1,52974,"\n"],[1,52980,"f"],[-1,53001,"\n"],[1,53007,"操"],[-1,53021,"\n"],[1,53026,"操"],[-1,53045,"\n"],[1,53050,"="],[-1,53077,"\n"],[1,53082,"+"],[-1,53106,"\n"],[1,53111,"C"]],[44218,44218],[53112,53112]]],[1543579879951,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45718,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v\t"],[-1,45855,"\tvec"],[1,45863," "],[-1,45865,"t"],[1,45873,"1"],[-1,45874,"1"],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46254,"\n"],[1,46257," d\t"],[-1,46257,"\tdel"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46283,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t "],[-1,46313,")\n{\n\tif ("],[-1,46324,">="],[1,46327,"="],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46418,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[1,46477," f\t"],[-1,46477,"\tfor "],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i "],[-1,46528,"i]"],[-1,46532,"<"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46704,"\n"],[1,46717,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c\t"],[-1,46772,"\tcin"],[1,46781," "],[1,46783," v\t"],[-1,46783,"\tvec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c\t"],[-1,46855,"\tcou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s"],[-1,46916,"sys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋"],[-1,47012,"赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47121,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,48377,"|*3*"],[-1,48377,"\n**3重"],[1,48390,"*"],[-1,48390,"["],[1,48396,"重"],[-1,48398,"重"],[1,48409,"\n"],[-1,48413,"运"],[1,48431,"\n"],[-1,48436,"["],[1,48465,"*"],[-1,48467,"重"],[1,48477,"_"],[-1,48482,"["],[1,48507,"_型_*_"],[-1,48507,"类型 类 "],[1,48528,"_型_"],[-1,48528,"类型 "],[1,48609,"\n"],[1,48657,"*\n*4*"],[-1,48657,"\n\n**4重"],[1,48669,"*"],[-1,48669,"("],[1,48732,"*1_\n* x*类 X*"],[-1,48732,"例1\n\n设 x是类 X的"],[1,48754,"*"],[-1,48755,"x"],[1,48774,"*"],[-1,48775,"可"],[1,48780,"*"],[-1,48781,"x"],[1,48813,"*"],[-1,48813,"\n"],[1,51838,"|"],[1,51841,"lang"],[-1,51841,"cpp"],[1,51846,"```"],[-1,52385,"};\n\n"],[1,52403,"| \n\n"],[-1,52812,"\n};\n"],[1,52819,"\n\n |"],[1,52844,"总"],[-1,52844,""],[-1,52896,"总"],[1,52898,"\n"],[-1,52903,"操"],[1,52920,"\n"],[-1,52924,"操"],[1,52946,"\n"],[-1,52950,"o"],[1,52970,"\n"],[-1,52975,"f"],[1,52997,"\n"],[-1,53002,"操"],[1,53017,"\n"],[-1,53021,"操"],[1,53041,"\n"],[-1,53045,"="],[1,53073,"\n"],[-1,53077,"+"],[1,53102,"\n"],[-1,53106,"C"]],[53112,53112],[44218,44218]]],[1543579842274,["gjx16@GJXAIOU",[[-1,49201,"** **_"]],[49201,49207],[49201,49201]]],[1543579844642,["gjx16@GJXAIOU",[[-1,49192,"_****_"]],[49192,49198],[49192,49192]]],[1543579847358,["gjx16@GJXAIOU",[[-1,49200,"_****_"]],[49200,49206],[49200,49200]]],[1543579850930,["gjx16@GJXAIOU",[[-1,49208,"_** **_"]],[49208,49215],[49208,49208]]],[1543579856883,["gjx16@GJXAIOU",[[-1,49212,"_"]],[49213,49213],[49212,49212]]],[1543579858292,["gjx16@GJXAIOU",[[-1,49189,"_"]],[49190,49190],[49189,49189]]],[1543579860074,["gjx16@GJXAIOU",[[-1,49193,"_"]],[49194,49194],[49193,49193]]],[1543579999961,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[-1,45540,"a）"],[1,45544,"a）"],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45715,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v"],[1,45856,"vec"],[-1,45860," "],[1,45863,"t"],[1,45870," "],[-1,45871," "],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46232,"\n"],[-1,46252,"\n"],[-1,46255," d"],[1,46258,"del"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46280,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t i  ="],[1,46323,")\n{\n\tif (i >= "],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46417,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[1,46475,"\tfor"],[-1,46476,"f\t"],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i  "],[1,46529,"i] <"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46573,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[1,46630,"\tfor"],[-1,46631,"f\t"],[-1,46634," "],[-1,46636," "],[1,46638,"t"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46701,"\n"],[-1,46713,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c"],[1,46773,"cin"],[-1,46778," "],[-1,46781," v"],[1,46784,"vec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c"],[1,46856,"cou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s\t"],[1,46916,"\tsys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋* "],[1,47012,"* 赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47118,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,48377,"|*3*"],[1,48381,"\n**3重"],[-1,48389,"*"],[1,48390,"["],[-1,48395,"重"],[1,48398,"重"],[-1,48408,"\n"],[1,48413,"运"],[-1,48430,"\n"],[1,48436,"["],[-1,48464,"*"],[1,48467,"重"],[-1,48476,"_"],[1,48482,"["],[-1,48506,"_型_*_"],[1,48511,"类型 类 "],[-1,48527,"_型_"],[1,48530,"类型 "],[-1,48608,"\n"],[-1,48657,"*\n*4*"],[1,48662,"\n\n**4重"],[-1,48668,"*"],[1,48669,"("],[-1,48731,"*1_\n* x*类 X*"],[1,48743,"例1\n\n设 x是类 X的"],[-1,48753,"*"],[1,48755,"x"],[-1,48773,"*"],[1,48775,"可"],[-1,48779,"*"],[1,48781,"x"],[-1,48812,"*"],[1,48813,"\n"],[-1,49188,"_/_3_"],[1,49193,"//例3用"],[-1,49197,"_"],[1,49198,"运"],[-1,49205,"_员函数_"],[1,49210,"成员函数*"],[-1,51809,"|"],[-1,51813,"lang"],[1,51817,"cpp"],[-1,51819,"```"],[1,52361,"};\n\n"],[-1,52375,"| \n\n"],[1,52788,"\n};\n"],[-1,52791,"\n\n |"],[-1,52820,"总"],[1,52821,""],[1,52873,"总"],[-1,52874,"\n"],[1,52880,"操"],[-1,52896,"\n"],[1,52901,"操"],[-1,52922,"\n"],[1,52927,"o"],[-1,52946,"\n"],[1,52952,"f"],[-1,52973,"\n"],[1,52979,"操"],[-1,52993,"\n"],[1,52998,"操"],[-1,53017,"\n"],[1,53022,"="],[-1,53049,"\n"],[1,53054,"+"],[-1,53078,"\n"],[1,53083,"C"]],[44218,44218],[53084,53084]]],[1543579999961,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[1,45542,"a）"],[-1,45544,"a）"],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45717,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v"],[-1,45856,"vec"],[1,45863," "],[-1,45865,"t"],[-1,45873," "],[1,45875," "],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46234,"\n"],[1,46255,"\n"],[1,46257," d"],[-1,46258,"del"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46282,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t i  ="],[-1,46313,")\n{\n\tif (i >= "],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46419,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[-1,46477,"\tfor"],[1,46482,"f\t"],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i  "],[-1,46528,"i] <"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46575,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[-1,46632,"\tfor"],[1,46637,"f\t"],[1,46638," "],[1,46639," "],[-1,46640,"t"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46703,"\n"],[1,46716,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c"],[-1,46773,"cin"],[1,46781," "],[1,46783," v"],[-1,46784,"vec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c"],[-1,46856,"cou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s\t"],[-1,46915,"\tsys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋* "],[-1,47010,"* 赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47119,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,48377,"|*3*"],[-1,48377,"\n**3重"],[1,48390,"*"],[-1,48390,"["],[1,48396,"重"],[-1,48398,"重"],[1,48409,"\n"],[-1,48413,"运"],[1,48431,"\n"],[-1,48436,"["],[1,48465,"*"],[-1,48467,"重"],[1,48477,"_"],[-1,48482,"["],[1,48507,"_型_*_"],[-1,48507,"类型 类 "],[1,48528,"_型_"],[-1,48528,"类型 "],[1,48609,"\n"],[1,48657,"*\n*4*"],[-1,48657,"\n\n**4重"],[1,48669,"*"],[-1,48669,"("],[1,48732,"*1_\n* x*类 X*"],[-1,48732,"例1\n\n设 x是类 X的"],[1,48754,"*"],[-1,48755,"x"],[1,48774,"*"],[-1,48775,"可"],[1,48780,"*"],[-1,48781,"x"],[1,48813,"*"],[-1,48813,"\n"],[1,49189,"_/_3_"],[-1,49189,"//例3用"],[1,49198,"_"],[-1,49198,"运"],[1,49206,"_员函数_"],[-1,49206,"成员函数*"],[1,51810,"|"],[1,51813,"lang"],[-1,51813,"cpp"],[1,51818,"```"],[-1,52357,"};\n\n"],[1,52375,"| \n\n"],[-1,52784,"\n};\n"],[1,52791,"\n\n |"],[1,52816,"总"],[-1,52816,""],[-1,52868,"总"],[1,52870,"\n"],[-1,52875,"操"],[1,52892,"\n"],[-1,52896,"操"],[1,52918,"\n"],[-1,52922,"o"],[1,52942,"\n"],[-1,52947,"f"],[1,52969,"\n"],[-1,52974,"操"],[1,52989,"\n"],[-1,52993,"操"],[1,53013,"\n"],[-1,53017,"="],[1,53045,"\n"],[-1,53049,"+"],[1,53074,"\n"],[-1,53078,"C"]],[53084,53084],[44218,44218]]],[1543579975258,["gjx16@GJXAIOU",[[-1,48395,"\n"]],[48395,48395],[48394,48394]]],[1543579982816,["gjx16@GJXAIOU",[[1,48394," v zheli "]],[48394,48394],[48403,48403]]],[1543579989262,["gjx16@GJXAIOU",[[-1,48394," v zheli "]],[48403,48403],[48394,48394]]],[1543579992863,["gjx16@GJXAIOU",[[1,48394," 这里"]],[48394,48394],[48397,48397]]],[1543579994127,["gjx16@GJXAIOU",[[-1,48395,"这里"]],[48397,48397],[48395,48395]]],[1543579995649,["gjx16@GJXAIOU",[[1,48395,"===="]],[48395,48395],[48397,48397]]],[1543579997808,["gjx16@GJXAIOU",[[1,48397,"这里的"]],[48397,48397],[48400,48400]]],[1543580059965,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45716,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v\t"],[1,45856,"\tvec"],[-1,45860," "],[1,45863,"t"],[-1,45870,"1"],[1,45872,"1"],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46251,"\n"],[-1,46255," d\t"],[1,46258,"\tdel"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46281,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t "],[1,46319,")\n{\n\tif ("],[1,46321,">="],[-1,46322,"="],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46416,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[-1,46475," f\t"],[1,46478,"\tfor "],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i "],[1,46528,"i]"],[1,46530,"<"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46702,"\n"],[-1,46714,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c\t"],[1,46773,"\tcin"],[-1,46778," "],[-1,46781," v\t"],[1,46784,"\tvec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c\t"],[1,46856,"\tcou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s"],[1,46916,"sys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋"],[1,47012,"赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47120,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,48377,"|*3*"],[1,48381,"\n**3重"],[-1,48389,"*"],[1,48390,"["],[-1,48393,"\n"],[1,48405,"重"],[-1,48415,"\n"],[1,48420,"运"],[-1,48437,"\n"],[1,48443,"["],[-1,48471,"*"],[1,48474,"重"],[-1,48483,"_"],[1,48489,"["],[-1,48513,"_型_*_"],[1,48518,"类型 类 "],[-1,48534,"_型_"],[1,48537,"类型 "],[-1,48615,"\n"],[-1,48664,"*\n*4*"],[1,48669,"\n\n**4重"],[-1,48675,"*"],[1,48676,"("],[-1,48738,"*1_\n* x*类 X*"],[1,48750,"例1\n\n设 x是类 X的"],[-1,48760,"*"],[1,48762,"x"],[-1,48780,"*"],[1,48782,"可"],[-1,48786,"*"],[1,48788,"x"],[-1,48819,"*"],[1,48820,"\n"],[-1,49195,"_/_3_"],[1,49200,"//例3用"],[-1,49204,"_"],[1,49205,"运"],[-1,49212,"_员函数_"],[1,49217,"成员函数*"],[-1,51816,"|"],[-1,51820,"lang"],[1,51824,"cpp"],[-1,51826,"```"],[1,52368,"};\n\n"],[-1,52382,"| \n\n"],[1,52795,"\n};\n"],[-1,52798,"\n\n |"],[-1,52827,"总"],[1,52828,""],[1,52880,"总"],[-1,52881,"\n"],[1,52887,"操"],[-1,52903,"\n"],[1,52908,"操"],[-1,52929,"\n"],[1,52934,"o"],[-1,52953,"\n"],[1,52959,"f"],[-1,52980,"\n"],[1,52986,"操"],[-1,53000,"\n"],[1,53005,"操"],[-1,53024,"\n"],[1,53029,"="],[-1,53056,"\n"],[1,53061,"+"],[-1,53085,"\n"],[1,53090,"C"]],[44218,44218],[53091,53091]]],[1543580059965,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45718,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v\t"],[-1,45855,"\tvec"],[1,45863," "],[-1,45865,"t"],[1,45873,"1"],[-1,45874,"1"],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46254,"\n"],[1,46257," d\t"],[-1,46257,"\tdel"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46283,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t "],[-1,46313,")\n{\n\tif ("],[-1,46324,">="],[1,46327,"="],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46418,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[1,46477," f\t"],[-1,46477,"\tfor "],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i "],[-1,46528,"i]"],[-1,46532,"<"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46704,"\n"],[1,46717,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c\t"],[-1,46772,"\tcin"],[1,46781," "],[1,46783," v\t"],[-1,46783,"\tvec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c\t"],[-1,46855,"\tcou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s"],[-1,46916,"sys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋"],[-1,47012,"赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47121,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,48377,"|*3*"],[-1,48377,"\n**3重"],[1,48390,"*"],[-1,48390,"["],[1,48394,"\n"],[-1,48405,"重"],[1,48416,"\n"],[-1,48420,"运"],[1,48438,"\n"],[-1,48443,"["],[1,48472,"*"],[-1,48474,"重"],[1,48484,"_"],[-1,48489,"["],[1,48514,"_型_*_"],[-1,48514,"类型 类 "],[1,48535,"_型_"],[-1,48535,"类型 "],[1,48616,"\n"],[1,48664,"*\n*4*"],[-1,48664,"\n\n**4重"],[1,48676,"*"],[-1,48676,"("],[1,48739,"*1_\n* x*类 X*"],[-1,48739,"例1\n\n设 x是类 X的"],[1,48761,"*"],[-1,48762,"x"],[1,48781,"*"],[-1,48782,"可"],[1,48787,"*"],[-1,48788,"x"],[1,48820,"*"],[-1,48820,"\n"],[1,49196,"_/_3_"],[-1,49196,"//例3用"],[1,49205,"_"],[-1,49205,"运"],[1,49213,"_员函数_"],[-1,49213,"成员函数*"],[1,51817,"|"],[1,51820,"lang"],[-1,51820,"cpp"],[1,51825,"```"],[-1,52364,"};\n\n"],[1,52382,"| \n\n"],[-1,52791,"\n};\n"],[1,52798,"\n\n |"],[1,52823,"总"],[-1,52823,""],[-1,52875,"总"],[1,52877,"\n"],[-1,52882,"操"],[1,52899,"\n"],[-1,52903,"操"],[1,52925,"\n"],[-1,52929,"o"],[1,52949,"\n"],[-1,52954,"f"],[1,52976,"\n"],[-1,52981,"操"],[1,52996,"\n"],[-1,53000,"操"],[1,53020,"\n"],[-1,53024,"="],[1,53052,"\n"],[-1,53056,"+"],[1,53081,"\n"],[-1,53085,"C"]],[53091,53091],[44218,44218]]],[1543580002880,["gjx16@GJXAIOU",[[1,48400,"视频再看一遍"]],[48400,48400],[48406,48406]]],[1543581499996,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45716,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v\t"],[1,45856,"\tvec"],[-1,45860," "],[1,45863,"t"],[-1,45870,"1"],[1,45872,"1"],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46251,"\n"],[-1,46255," d\t"],[1,46258,"\tdel"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46281,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t "],[1,46319,")\n{\n\tif ("],[1,46321,">="],[-1,46322,"="],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46416,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[-1,46475," f\t"],[1,46478,"\tfor "],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i "],[1,46528,"i]"],[1,46530,"<"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46702,"\n"],[-1,46714,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c\t"],[1,46773,"\tcin"],[-1,46778," "],[-1,46781," v\t"],[1,46784,"\tvec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c\t"],[1,46856,"\tcou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s"],[1,46916,"sys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋"],[1,47012,"赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47120,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,48377,"|*3*"],[1,48381,"\n**3重"],[-1,48389,"*"],[1,48390,"["],[-1,48393,"\n"],[1,48411,"重"],[-1,48421,"\n"],[1,48426,"运"],[-1,48443,"\n"],[1,48449,"["],[-1,48477,"*"],[1,48480,"重"],[-1,48489,"_"],[1,48495,"["],[-1,48519,"_型_*_"],[1,48524,"类型 类 "],[-1,48540,"_型_"],[1,48543,"类型 "],[-1,48621,"\n"],[-1,48670,"*\n*4*"],[1,48675,"\n\n**4重"],[-1,48681,"*"],[1,48682,"("],[-1,48744,"*1_\n* x*类 X*"],[1,48756,"例1\n\n设 x是类 X的"],[-1,48766,"*"],[1,48768,"x"],[-1,48786,"*"],[1,48788,"可"],[-1,48792,"*"],[1,48794,"x"],[-1,48825,"*"],[1,48826,"\n"],[-1,49201,"_/_3_"],[1,49206,"//例3用"],[-1,49210,"_"],[1,49211,"运"],[-1,49218,"_员函数_"],[1,49223,"成员函数*"],[-1,51822,"|"],[-1,51826,"lang"],[1,51830,"cpp"],[-1,51832,"```"],[1,52374,"};\n\n"],[-1,52388,"| \n\n"],[1,52801,"\n};\n"],[-1,52804,"\n\n |"],[-1,52833,"总"],[1,52834,""],[1,52886,"总"],[-1,52887,"\n"],[1,52893,"操"],[-1,52909,"\n"],[1,52914,"操"],[-1,52935,"\n"],[1,52940,"o"],[-1,52959,"\n"],[1,52965,"f"],[-1,52986,"\n"],[1,52992,"操"],[-1,53006,"\n"],[1,53011,"操"],[-1,53030,"\n"],[1,53035,"="],[-1,53062,"\n"],[1,53067,"+"],[-1,53091,"\n"],[1,53096,"C"]],[44218,44218],[53097,53097]]],[1543581499996,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45718,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v\t"],[-1,45855,"\tvec"],[1,45863," "],[-1,45865,"t"],[1,45873,"1"],[-1,45874,"1"],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46254,"\n"],[1,46257," d\t"],[-1,46257,"\tdel"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46283,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t "],[-1,46313,")\n{\n\tif ("],[-1,46324,">="],[1,46327,"="],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46418,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[1,46477," f\t"],[-1,46477,"\tfor "],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i "],[-1,46528,"i]"],[-1,46532,"<"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46704,"\n"],[1,46717,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c\t"],[-1,46772,"\tcin"],[1,46781," "],[1,46783," v\t"],[-1,46783,"\tvec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c\t"],[-1,46855,"\tcou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s"],[-1,46916,"sys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋"],[-1,47012,"赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47121,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,48377,"|*3*"],[-1,48377,"\n**3重"],[1,48390,"*"],[-1,48390,"["],[1,48394,"\n"],[-1,48411,"重"],[1,48422,"\n"],[-1,48426,"运"],[1,48444,"\n"],[-1,48449,"["],[1,48478,"*"],[-1,48480,"重"],[1,48490,"_"],[-1,48495,"["],[1,48520,"_型_*_"],[-1,48520,"类型 类 "],[1,48541,"_型_"],[-1,48541,"类型 "],[1,48622,"\n"],[1,48670,"*\n*4*"],[-1,48670,"\n\n**4重"],[1,48682,"*"],[-1,48682,"("],[1,48745,"*1_\n* x*类 X*"],[-1,48745,"例1\n\n设 x是类 X的"],[1,48767,"*"],[-1,48768,"x"],[1,48787,"*"],[-1,48788,"可"],[1,48793,"*"],[-1,48794,"x"],[1,48826,"*"],[-1,48826,"\n"],[1,49202,"_/_3_"],[-1,49202,"//例3用"],[1,49211,"_"],[-1,49211,"运"],[1,49219,"_员函数_"],[-1,49219,"成员函数*"],[1,51823,"|"],[1,51826,"lang"],[-1,51826,"cpp"],[1,51831,"```"],[-1,52370,"};\n\n"],[1,52388,"| \n\n"],[-1,52797,"\n};\n"],[1,52804,"\n\n |"],[1,52829,"总"],[-1,52829,""],[-1,52881,"总"],[1,52883,"\n"],[-1,52888,"操"],[1,52905,"\n"],[-1,52909,"操"],[1,52931,"\n"],[-1,52935,"o"],[1,52955,"\n"],[-1,52960,"f"],[1,52982,"\n"],[-1,52987,"操"],[1,53002,"\n"],[-1,53006,"操"],[1,53026,"\n"],[-1,53030,"="],[1,53058,"\n"],[-1,53062,"+"],[1,53087,"\n"],[-1,53091,"C"]],[53097,53097],[44218,44218]]],[1543581474997,["gjx16@GJXAIOU",[[1,48518,"："]],[48518,48518],[48519,48519]]],[1543581481332,["gjx16@GJXAIOU",[[1,48521,"返回值"]],[48521,48521],[48524,48524]]],[1543581499264,["gjx16@GJXAIOU",[[-1,48589," "]],[48590,48590],[48589,48589]]],[1543581559995,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45716,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v\t"],[1,45856,"\tvec"],[-1,45860," "],[1,45863,"t"],[-1,45870,"1"],[1,45872,"1"],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46251,"\n"],[-1,46255," d\t"],[1,46258,"\tdel"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46281,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t "],[1,46319,")\n{\n\tif ("],[1,46321,">="],[-1,46322,"="],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46416,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[-1,46475," f\t"],[1,46478,"\tfor "],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i "],[1,46528,"i]"],[1,46530,"<"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46702,"\n"],[-1,46714,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c\t"],[1,46773,"\tcin"],[-1,46778," "],[-1,46781," v\t"],[1,46784,"\tvec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c\t"],[1,46856,"\tcou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s"],[1,46916,"sys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋"],[1,47012,"赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47120,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,48377,"|*3*"],[1,48381,"\n**3重"],[-1,48389,"*"],[1,48390,"["],[-1,48393,"\n"],[1,48411,"重"],[-1,48421,"\n"],[1,48426,"运"],[-1,48443,"\n"],[1,48449,"["],[-1,48477,"*"],[1,48480,"重"],[-1,48489,"_"],[1,48495,"["],[-1,48517," "],[-1,48520,"_返回值型_*_"],[1,48528," 返回值类型 类 "],[-1,48544,"_型_"],[1,48547,"类型 "],[-1,48588," "],[1,48589,"可"],[-1,48624,"\n"],[-1,48673,"*\n*4*"],[1,48678,"\n\n**4重"],[-1,48684,"*"],[1,48685,"("],[-1,48747,"*1_\n* x*类 X*"],[1,48759,"例1\n\n设 x是类 X的"],[-1,48769,"*"],[1,48771,"x"],[-1,48789,"*"],[1,48791,"可"],[-1,48795,"*"],[1,48797,"x"],[-1,48828,"*"],[1,48829,"\n"],[-1,49204,"_/_3_"],[1,49209,"//例3用"],[-1,49213,"_"],[1,49214,"运"],[-1,49221,"_员函数_"],[1,49226,"成员函数*"],[-1,51825,"|"],[-1,51829,"lang"],[1,51833,"cpp"],[-1,51835,"```"],[1,52377,"};\n\n"],[-1,52391,"| \n\n"],[1,52804,"\n};\n"],[-1,52807,"\n\n |"],[-1,52836,"总"],[1,52837,""],[1,52889,"总"],[-1,52890,"\n"],[1,52896,"操"],[-1,52912,"\n"],[1,52917,"操"],[-1,52938,"\n"],[1,52943,"o"],[-1,52962,"\n"],[1,52968,"f"],[-1,52989,"\n"],[1,52995,"操"],[-1,53009,"\n"],[1,53014,"操"],[-1,53033,"\n"],[1,53038,"="],[-1,53065,"\n"],[1,53070,"+"],[-1,53094,"\n"],[1,53099,"C"]],[44218,44218],[53100,53100]]],[1543581559995,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45718,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v\t"],[-1,45855,"\tvec"],[1,45863," "],[-1,45865,"t"],[1,45873,"1"],[-1,45874,"1"],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46254,"\n"],[1,46257," d\t"],[-1,46257,"\tdel"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46283,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t "],[-1,46313,")\n{\n\tif ("],[-1,46324,">="],[1,46327,"="],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46418,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[1,46477," f\t"],[-1,46477,"\tfor "],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i "],[-1,46528,"i]"],[-1,46532,"<"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46704,"\n"],[1,46717,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c\t"],[-1,46772,"\tcin"],[1,46781," "],[1,46783," v\t"],[-1,46783,"\tvec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c\t"],[-1,46855,"\tcou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s"],[-1,46916,"sys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋"],[-1,47012,"赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47121,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,48377,"|*3*"],[-1,48377,"\n**3重"],[1,48390,"*"],[-1,48390,"["],[1,48394,"\n"],[-1,48411,"重"],[1,48422,"\n"],[-1,48426,"运"],[1,48444,"\n"],[-1,48449,"["],[1,48478,"*"],[-1,48480,"重"],[1,48490,"_"],[-1,48495,"["],[1,48518," "],[1,48520,"_返回值型_*_"],[-1,48520," 返回值类型 类 "],[1,48545,"_型_"],[-1,48545,"类型 "],[1,48589," "],[-1,48589,"可"],[1,48625,"\n"],[1,48673,"*\n*4*"],[-1,48673,"\n\n**4重"],[1,48685,"*"],[-1,48685,"("],[1,48748,"*1_\n* x*类 X*"],[-1,48748,"例1\n\n设 x是类 X的"],[1,48770,"*"],[-1,48771,"x"],[1,48790,"*"],[-1,48791,"可"],[1,48796,"*"],[-1,48797,"x"],[1,48829,"*"],[-1,48829,"\n"],[1,49205,"_/_3_"],[-1,49205,"//例3用"],[1,49214,"_"],[-1,49214,"运"],[1,49222,"_员函数_"],[-1,49222,"成员函数*"],[1,51826,"|"],[1,51829,"lang"],[-1,51829,"cpp"],[1,51834,"```"],[-1,52373,"};\n\n"],[1,52391,"| \n\n"],[-1,52800,"\n};\n"],[1,52807,"\n\n |"],[1,52832,"总"],[-1,52832,""],[-1,52884,"总"],[1,52886,"\n"],[-1,52891,"操"],[1,52908,"\n"],[-1,52912,"操"],[1,52934,"\n"],[-1,52938,"o"],[1,52958,"\n"],[-1,52963,"f"],[1,52985,"\n"],[-1,52990,"操"],[1,53005,"\n"],[-1,53009,"操"],[1,53029,"\n"],[-1,53033,"="],[1,53061,"\n"],[-1,53065,"+"],[1,53090,"\n"],[-1,53094,"C"]],[53100,53100],[44218,44218]]],[1543581500319,["gjx16@GJXAIOU",[[-1,48588," "]],[48589,48589],[48588,48588]]],[1543581501351,["gjx16@GJXAIOU",[[-1,48587,"\n"]],[48588,48588],[48587,48587]]],[1543581502299,["gjx16@GJXAIOU",[[-1,48586,"\n"]],[48587,48587],[48586,48586]]],[1543581503443,["gjx16@GJXAIOU",[[1,48586," "]],[48586,48586],[48587,48587]]],[1543581508224,["gjx16@GJXAIOU",[[-1,48594," **"]],[48595,48597],[48594,48594]]],[1543581509217,["gjx16@GJXAIOU",[[-1,48593,"\n"]],[48594,48594],[48593,48593]]],[1543581510158,["gjx16@GJXAIOU",[[-1,48592,"\n"]],[48593,48593],[48592,48592]]],[1543581511714,["gjx16@GJXAIOU",[[1,48592,"  "]],[48592,48592],[48594,48594]]],[1543581514699,["gjx16@GJXAIOU",[[-1,48616,"**"]],[48618,48618],[48616,48616]]],[1543581518010,["gjx16@GJXAIOU",[[-1,48584,"**"]],[48586,48586],[48584,48584]]],[1543581521012,["gjx16@GJXAIOU",[[-1,48575,"**"]],[48577,48577],[48575,48575]]],[1543581523493,["gjx16@GJXAIOU",[[1,48575,"`"]],[48575,48575],[48576,48576]]],[1543581525699,["gjx16@GJXAIOU",[[1,48583,"`"]],[48583,48583],[48584,48584]]],[1543581527905,["gjx16@GJXAIOU",[[1,48592,"`"]],[48592,48592],[48593,48593]]],[1543581532797,["gjx16@GJXAIOU",[[1,48615,"`"]],[48615,48615],[48616,48616]]],[1543581535312,["gjx16@GJXAIOU",[[-1,48611," "]],[48612,48612],[48611,48611]]],[1543581537235,["gjx16@GJXAIOU",[[-1,48612," "]],[48613,48613],[48612,48612]]],[1543581539041,["gjx16@GJXAIOU",[[-1,48607," "]],[48608,48608],[48607,48607]]],[1543581541139,["gjx16@GJXAIOU",[[-1,48605," "]],[48606,48606],[48605,48605]]],[1543581543328,["gjx16@GJXAIOU",[[-1,48607," "]],[48608,48608],[48607,48607]]],[1543581547032,["gjx16@GJXAIOU",[[-1,48596," "]],[48597,48597],[48596,48596]]],[1543581548844,["gjx16@GJXAIOU",[[-1,48594," "]],[48595,48595],[48594,48594]]],[1543581552403,["gjx16@GJXAIOU",[[-1,48581," "]],[48582,48582],[48581,48581]]],[1543581554249,["gjx16@GJXAIOU",[[-1,48579," "]],[48580,48580],[48579,48579]]],[1543581556057,["gjx16@GJXAIOU",[[-1,48577," "]],[48578,48578],[48577,48577]]],[1543581620059,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45716,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v\t"],[1,45856,"\tvec"],[-1,45860," "],[1,45863,"t"],[-1,45870,"1"],[1,45872,"1"],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46251,"\n"],[-1,46255," d\t"],[1,46258,"\tdel"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46281,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t "],[1,46319,")\n{\n\tif ("],[1,46321,">="],[-1,46322,"="],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46416,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[-1,46475," f\t"],[1,46478,"\tfor "],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i "],[1,46528,"i]"],[1,46530,"<"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46702,"\n"],[-1,46714,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c\t"],[1,46773,"\tcin"],[-1,46778," "],[-1,46781," v\t"],[1,46784,"\tvec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c\t"],[1,46856,"\tcou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s"],[1,46916,"sys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋"],[1,47012,"赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47120,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,48377,"|*3*"],[1,48381,"\n**3重"],[-1,48389,"*"],[1,48390,"["],[-1,48393,"\n"],[1,48411,"重"],[-1,48421,"\n"],[1,48426,"运"],[-1,48443,"\n"],[1,48449,"["],[-1,48477,"*"],[1,48480,"重"],[-1,48489,"_"],[1,48495,"["],[-1,48517," "],[-1,48520,"_返回值型_*_"],[1,48528," 返回值类型 类 "],[-1,48544,"_型_"],[1,48547,"类型 "],[-1,48574,"*`   *"],[1,48580,"`x[y]"],[1,48582,"可"],[-1,48586,"\n"],[-1,48590,"  "],[1,48592,"x.o"],[-1,48599,"     *"],[1,48605,"[](y)"],[-1,48656,"*\n*4*"],[1,48661,"\n\n**4重"],[-1,48667,"*"],[1,48668,"("],[-1,48730,"*1_\n* x*类 X*"],[1,48742,"例1\n\n设 x是类 X的"],[-1,48752,"*"],[1,48754,"x"],[-1,48772,"*"],[1,48774,"可"],[-1,48778,"*"],[1,48780,"x"],[-1,48811,"*"],[1,48812,"\n"],[-1,49187,"_/_3_"],[1,49192,"//例3用"],[-1,49196,"_"],[1,49197,"运"],[-1,49204,"_员函数_"],[1,49209,"成员函数*"],[-1,51808,"|"],[-1,51812,"lang"],[1,51816,"cpp"],[-1,51818,"```"],[1,52360,"};\n\n"],[-1,52374,"| \n\n"],[1,52787,"\n};\n"],[-1,52790,"\n\n |"],[-1,52819,"总"],[1,52820,""],[1,52872,"总"],[-1,52873,"\n"],[1,52879,"操"],[-1,52895,"\n"],[1,52900,"操"],[-1,52921,"\n"],[1,52926,"o"],[-1,52945,"\n"],[1,52951,"f"],[-1,52972,"\n"],[1,52978,"操"],[-1,52992,"\n"],[1,52997,"操"],[-1,53016,"\n"],[1,53021,"="],[-1,53048,"\n"],[1,53053,"+"],[-1,53077,"\n"],[1,53082,"C"]],[44218,44218],[53083,53083]]],[1543581620059,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45718,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v\t"],[-1,45855,"\tvec"],[1,45863," "],[-1,45865,"t"],[1,45873,"1"],[-1,45874,"1"],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46254,"\n"],[1,46257," d\t"],[-1,46257,"\tdel"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46283,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t "],[-1,46313,")\n{\n\tif ("],[-1,46324,">="],[1,46327,"="],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46418,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[1,46477," f\t"],[-1,46477,"\tfor "],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i "],[-1,46528,"i]"],[-1,46532,"<"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46704,"\n"],[1,46717,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c\t"],[-1,46772,"\tcin"],[1,46781," "],[1,46783," v\t"],[-1,46783,"\tvec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c\t"],[-1,46855,"\tcou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s"],[-1,46916,"sys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋"],[-1,47012,"赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47121,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,48377,"|*3*"],[-1,48377,"\n**3重"],[1,48390,"*"],[-1,48390,"["],[1,48394,"\n"],[-1,48411,"重"],[1,48422,"\n"],[-1,48426,"运"],[1,48444,"\n"],[-1,48449,"["],[1,48478,"*"],[-1,48480,"重"],[1,48490,"_"],[-1,48495,"["],[1,48518," "],[1,48520,"_返回值型_*_"],[-1,48520," 返回值类型 类 "],[1,48545,"_型_"],[-1,48545,"类型 "],[1,48575,"*`   *"],[-1,48575,"`x[y]"],[-1,48582,"可"],[1,48587,"\n"],[1,48590,"  "],[-1,48590,"x.o"],[1,48600,"     *"],[-1,48600,"[](y)"],[1,48656,"*\n*4*"],[-1,48656,"\n\n**4重"],[1,48668,"*"],[-1,48668,"("],[1,48731,"*1_\n* x*类 X*"],[-1,48731,"例1\n\n设 x是类 X的"],[1,48753,"*"],[-1,48754,"x"],[1,48773,"*"],[-1,48774,"可"],[1,48779,"*"],[-1,48780,"x"],[1,48812,"*"],[-1,48812,"\n"],[1,49188,"_/_3_"],[-1,49188,"//例3用"],[1,49197,"_"],[-1,49197,"运"],[1,49205,"_员函数_"],[-1,49205,"成员函数*"],[1,51809,"|"],[1,51812,"lang"],[-1,51812,"cpp"],[1,51817,"```"],[-1,52356,"};\n\n"],[1,52374,"| \n\n"],[-1,52783,"\n};\n"],[1,52790,"\n\n |"],[1,52815,"总"],[-1,52815,""],[-1,52867,"总"],[1,52869,"\n"],[-1,52874,"操"],[1,52891,"\n"],[-1,52895,"操"],[1,52917,"\n"],[-1,52921,"o"],[1,52941,"\n"],[-1,52946,"f"],[1,52968,"\n"],[-1,52973,"操"],[1,52988,"\n"],[-1,52992,"操"],[1,53012,"\n"],[-1,53016,"="],[1,53044,"\n"],[-1,53048,"+"],[1,53073,"\n"],[-1,53077,"C"]],[53083,53083],[44218,44218]]],[1543581571952,["gjx16@GJXAIOU",[[1,48514,"  "]],[48514,48514],[48516,48516]]],[1543581574625,["gjx16@GJXAIOU",[[-1,48513,"\n"]],[48513,48513],[48512,48512]]],[1543581583672,["gjx16@GJXAIOU",[[-1,48553,"\n"]],[48554,48554],[48553,48553]]],[1543581584209,["gjx16@GJXAIOU",[[1,48553,"  "]],[48553,48553],[48555,48555]]],[1543581610860,["gjx16@GJXAIOU",[[1,48661,"."]],[48661,48661],[48662,48662]]],[1543581615853,["gjx16@GJXAIOU",[[1,48381,"."]],[48381,48381],[48382,48382]]],[1543581617982,["gjx16@GJXAIOU",[[1,48378,"\n"]],[48377,48377],[48378,48378]]],[1543581680032,[null,[[1,44218,"- "],[-1,44242,"=,"],[1,44246,"=,"],[-1,44276,"**"],[1,44278,"）用"],[-1,44282,"**"],[1,44284,"重载"],[-1,44290,"**"],[1,44292,"操作"],[-1,44297,"Ø "],[1,44301,"is"],[-1,44330,"\nØ"],[1,44334,"ci"],[-1,44369,"\nØ"],[1,44373,"运算"],[-1,44406,"\nØ"],[1,44410,"运算"],[-1,44444,"\nØ"],[1,44448,"用友"],[-1,45518,"o\n3）"],[1,45524,"3）友元"],[1,45540,"- "],[-1,45542,"- "],[-1,45574,"\nb"],[1,45602,"b）"],[-1,45605,"\nØ"],[1,45611,"在第"],[-1,45644,"\nØ"],[1,45650,"友员"],[-1,45693,"\nØ"],[1,45699,"C+"],[-1,45716,"\n"],[1,45722,"="],[-1,45738,"**"],[1,45740,"）友"],[-1,45751,"***\n\n|` "],[1,45759,"类**\n``"],[1,45764,"#in"],[-1,45781,"\n"],[1,45784,"i"],[-1,45842,"\n"],[1,45847,"b"],[-1,45850," "],[-1,45853," v\t"],[1,45856,"\tvec"],[-1,45860," "],[1,45863,"t"],[-1,45870,"1"],[1,45872,"1"],[-1,45874,"1\n ~v\t"],[1,45880,"\n\n\t~ve"],[-1,45886," "],[-1,45889," in\t"],[1,45893,"\n\tint"],[-1,45907," "],[1,45910,"t"],[-1,45912," ) \n fr\t"],[1,45920,");\n\n\tfri"],[-1,45947," "],[1,45950,"t"],[-1,45963," "],[1,45966,"v"],[-1,45973," ) \n fr\t"],[1,45981,");\n\n\tfri"],[-1,46008," "],[1,46011,"t"],[-1,46033," ) "],[1,46036,");\n"],[-1,46044," : "],[1,46050,"int"],[-1,46054," "],[-1,46057," in\t"],[1,46061,"\n\tint"],[-1,46065," "],[1,46067,"\n"],[-1,46087," "],[1,46090,"t"],[-1,46095," "],[1,46100,"\tif"],[-1,46101,"i\t"],[-1,46127," "],[-1,46130," {"],[1,46137,"cou"],[-1,46182," "],[1,46185,"a"],[-1,46191," "],[-1,46194," }"],[1,46201,"v ="],[-1,46210," "],[-1,46213,"e ]  "],[1,46218,"ze]; l"],[-1,46227," "],[1,46231,"\n"],[-1,46251,"\n"],[-1,46255," d\t"],[1,46258,"\tdel"],[-1,46265," "],[-1,46268," le\t"],[1,46272,"\n\tlen"],[-1,46276," "],[1,46281,"\n"],[-1,46305," "],[1,46308,"t"],[-1,46310," )  \n i\t "],[1,46319,")\n{\n\tif ("],[1,46321,">="],[-1,46322,"="],[-1,46326," "],[-1,46336," "],[1,46339,"r"],[-1,46347," i  \n co\t"],[1,46356,"i];\n\n\tcou"],[-1,46403," "],[1,46406,"a"],[-1,46412," "],[1,46416,"\n"],[-1,46440," "],[1,46443,"t"],[-1,46470," "],[-1,46475," f\t"],[1,46478,"\tfor "],[-1,46481," "],[-1,46489," "],[1,46492,"i"],[-1,46502," "],[-1,46505," "],[1,46506,"i"],[-1,46510," o"],[1,46514,"out"],[-1,46525," i "],[1,46528,"i]"],[1,46530,"<"],[-1,46534," "],[-1,46537," ou\t"],[1,46541,"\n\tout"],[-1,46552," "],[-1,46555," r"],[1,46558,"ret"],[-1,46568," "],[1,46572,"\n"],[-1,46596," "],[1,46599,"t"],[-1,46625," "],[-1,46630," f\t( i n"],[1,46638,"\tfor (int"],[-1,46644," "],[1,46647,"i"],[-1,46657," "],[-1,46660," "],[1,46661,"i"],[-1,46665," i"],[1,46669,"inp"],[-1,46679," i  \n re\t"],[1,46688,"i];\n\n\tret"],[-1,46697," "],[1,46702,"\n"],[-1,46714,"\n"],[-1,46717," i\t"],[1,46720,"\tint"],[-1,46722," "],[-1,46725," c\t"],[1,46728,"\tcou"],[-1,46767," "],[-1,46770," c\t"],[1,46773,"\tcin"],[-1,46778," "],[-1,46781," v\t"],[1,46784,"\tvec"],[-1,46790," k  \n c\t"],[1,46798,"k);\n\tcou"],[-1,46839," "],[-1,46842," c"],[1,46845,"cin"],[-1,46850," "],[-1,46853," c\t"],[1,46856,"\tcou"],[-1,46898," "],[-1,46901," c\t"],[1,46904,"\tcou"],[-1,46910," "],[-1,46913," s"],[1,46916,"sys"],[-1,46930,"\n"],[-1,46933," |"],[1,46939,"\n\n#"],[-1,46957,"***"],[1,46961,"运算符"],[-1,46994,"***"],[1,46998,"重载赋"],[-1,47002,"*"],[1,47003,"="],[-1,47007,"Ø 赋"],[1,47012,"赋值运"],[-1,47026,"\nØ "],[1,47031,"ope"],[-1,47048,"\nØ "],[1,47053,"重"],[-1,47061,"\n"],[-1,47064,"型_*名_"],[1,47069,"类型&类名:"],[-1,47088,"*"],[1,47091,"类"],[-1,47092,"_"],[1,47094,"&"],[-1,47098,"*"],[1,47099,"\n"],[-1,47120,"\n"],[1,47144,"\n\n"],[-1,47145,"\n"],[-1,47151,"\n"],[1,47152," "],[-1,47164,"\n"],[1,47165," "],[-1,47174,"\n"],[1,47175," "],[-1,47186,"\n"],[-1,48377,"|\n"],[1,48379,"\n\n*"],[-1,48381,"*"],[1,48383,"重"],[-1,48391,"*"],[1,48392,"["],[-1,48395,"\n"],[1,48413,"重"],[-1,48423,"\n"],[1,48428,"运"],[-1,48445,"\n"],[1,48451,"["],[-1,48479,"*"],[1,48482,"重"],[-1,48491,"_"],[1,48497,"["],[-1,48513,"\n"],[1,48517,"重"],[-1,48520," "],[-1,48523,"_返回值型_*_"],[1,48531," 返回值类型 类 "],[-1,48547,"_型_"],[1,48550,"类型 "],[-1,48554,"\n"],[1,48557,"设"],[-1,48575,"\n\n *`   *"],[1,48584," `x[y]"],[1,48586,"可"],[-1,48590,"\n"],[-1,48594,"  "],[1,48596,"x.o"],[-1,48603,"     *"],[1,48609,"[](y)"],[-1,48660,"*\n*.4*"],[1,48666,"\n\n**4.重"],[-1,48672,"*"],[1,48673,"("],[-1,48735,"*1_\n* x*类 X*"],[1,48747,"例1\n\n设 x是类 X的"],[-1,48757,"*"],[1,48759,"x"],[-1,48777,"*"],[1,48779,"可"],[-1,48783,"*"],[1,48785,"x"],[-1,48816,"*"],[1,48817,"\n"],[-1,49192,"_/_3_"],[1,49197,"//例3用"],[-1,49201,"_"],[1,49202,"运"],[-1,49209,"_员函数_"],[1,49214,"成员函数*"],[-1,51813,"|"],[-1,51817,"lang"],[1,51821,"cpp"],[-1,51823,"```"],[1,52365,"};\n\n"],[-1,52379,"| \n\n"],[1,52792,"\n};\n"],[-1,52795,"\n\n |"],[-1,52824,"总"],[1,52825,""],[1,52877,"总"],[-1,52878,"\n"],[1,52884,"操"],[-1,52900,"\n"],[1,52905,"操"],[-1,52926,"\n"],[1,52931,"o"],[-1,52950,"\n"],[1,52956,"f"],[-1,52977,"\n"],[1,52983,"操"],[-1,52997,"\n"],[1,53002,"操"],[-1,53021,"\n"],[1,53026,"="],[-1,53053,"\n"],[1,53058,"+"],[-1,53082,"\n"],[1,53087,"C"]],[44218,44218],[53088,53088]]],[1543581680032,[null,[[-1,44218,"- "],[1,44244,"=,"],[-1,44246,"=,"],[1,44278,"**"],[-1,44278,"）用"],[1,44284,"**"],[-1,44284,"重载"],[1,44292,"**"],[-1,44292,"操作"],[1,44299,"Ø "],[-1,44301,"is"],[1,44332,"\nØ"],[-1,44334,"ci"],[1,44371,"\nØ"],[-1,44373,"运算"],[1,44408,"\nØ"],[-1,44410,"运算"],[1,44446,"\nØ"],[-1,44448,"用友"],[1,45520,"o\n3）"],[-1,45522,"3）友元"],[-1,45542,"- "],[1,45546,"- "],[1,45576,"\nb"],[-1,45602,"b）"],[1,45607,"\nØ"],[-1,45611,"在第"],[1,45646,"\nØ"],[-1,45650,"友员"],[1,45695,"\nØ"],[-1,45699,"C+"],[1,45718,"\n"],[-1,45723,"="],[1,45740,"**"],[-1,45740,"）友"],[1,45753,"***\n\n|` "],[-1,45753,"类**\n``"],[-1,45764,"#in"],[1,45784,"\n"],[-1,45786,"i"],[1,45845,"\n"],[-1,45849,"b"],[1,45853," "],[1,45855," v\t"],[-1,45855,"\tvec"],[1,45863," "],[-1,45865,"t"],[1,45873,"1"],[-1,45874,"1"],[1,45877,"1\n ~v\t"],[-1,45877,"\n\n\t~ve"],[1,45889," "],[1,45891," in\t"],[-1,45891,"\n\tint"],[1,45910," "],[-1,45912,"t"],[1,45915," ) \n fr\t"],[-1,45915,");\n\n\tfri"],[1,45950," "],[-1,45952,"t"],[1,45966," "],[-1,45968,"v"],[1,45976," ) \n fr\t"],[-1,45976,");\n\n\tfri"],[1,46011," "],[-1,46013,"t"],[1,46036," ) "],[-1,46036,");\n"],[1,46047," : "],[-1,46050,"int"],[1,46057," "],[1,46059," in\t"],[-1,46059,"\n\tint"],[1,46068," "],[-1,46069,"\n"],[1,46090," "],[-1,46092,"t"],[1,46098," "],[-1,46102,"\tif"],[1,46106,"i\t"],[1,46130," "],[1,46132," {"],[-1,46137,"cou"],[1,46185," "],[-1,46187,"a"],[1,46194," "],[1,46196," }"],[-1,46201,"v ="],[1,46213," "],[1,46215,"e ]  "],[-1,46215,"ze]; l"],[1,46230," "],[-1,46233,"\n"],[1,46254,"\n"],[1,46257," d\t"],[-1,46257,"\tdel"],[1,46268," "],[1,46270," le\t"],[-1,46270,"\n\tlen"],[1,46279," "],[-1,46283,"\n"],[1,46308," "],[-1,46310,"t"],[1,46313," )  \n i\t "],[-1,46313,")\n{\n\tif ("],[-1,46324,">="],[1,46327,"="],[1,46330," "],[1,46339," "],[-1,46341,"r"],[1,46350," i  \n co\t"],[-1,46350,"i];\n\n\tcou"],[1,46406," "],[-1,46408,"a"],[1,46415," "],[-1,46418,"\n"],[1,46443," "],[-1,46445,"t"],[1,46473," "],[1,46477," f\t"],[-1,46477,"\tfor "],[1,46485," "],[1,46492," "],[-1,46494,"i"],[1,46505," "],[1,46507," "],[-1,46507,"i"],[1,46512," o"],[-1,46514,"out"],[1,46528," i "],[-1,46528,"i]"],[-1,46532,"<"],[1,46537," "],[1,46539," ou\t"],[-1,46539,"\n\tout"],[1,46555," "],[1,46557," r"],[-1,46558,"ret"],[1,46571," "],[-1,46574,"\n"],[1,46599," "],[-1,46601,"t"],[1,46628," "],[1,46632," f\t( i n"],[-1,46632,"\tfor (int"],[1,46647," "],[-1,46649,"i"],[1,46660," "],[1,46662," "],[-1,46662,"i"],[1,46667," i"],[-1,46669,"inp"],[1,46682," i  \n re\t"],[-1,46682,"i];\n\n\tret"],[1,46700," "],[-1,46704,"\n"],[1,46717,"\n"],[1,46719," i\t"],[-1,46719,"\tint"],[1,46725," "],[1,46727," c\t"],[-1,46727,"\tcou"],[1,46770," "],[1,46772," c\t"],[-1,46772,"\tcin"],[1,46781," "],[1,46783," v\t"],[-1,46783,"\tvec"],[1,46793," k  \n c\t"],[-1,46793,"k);\n\tcou"],[1,46842," "],[1,46844," c"],[-1,46845,"cin"],[1,46853," "],[1,46855," c\t"],[-1,46855,"\tcou"],[1,46901," "],[1,46903," c\t"],[-1,46903,"\tcou"],[1,46913," "],[1,46915," s"],[-1,46916,"sys"],[1,46933,"\n"],[1,46935," |"],[-1,46939,"\n\n#"],[1,46960,"***"],[-1,46961,"运算符"],[1,46997,"***"],[-1,46998,"重载赋"],[1,47005,"*"],[-1,47005,"="],[1,47010,"Ø 赋"],[-1,47012,"赋值运"],[1,47029,"\nØ "],[-1,47031,"ope"],[1,47051,"\nØ "],[-1,47053,"重"],[1,47062,"\n"],[1,47064,"型_*名_"],[-1,47064,"类型&类名:"],[1,47089,"*"],[-1,47091,"类"],[1,47093,"_"],[-1,47094,"&"],[1,47099,"*"],[-1,47099,"\n"],[1,47121,"\n"],[-1,47144,"\n\n"],[1,47147,"\n"],[1,47152,"\n"],[-1,47152," "],[1,47165,"\n"],[-1,47165," "],[1,47175,"\n"],[-1,47175," "],[1,47187,"\n"],[1,48377,"|\n"],[-1,48377,"\n\n*"],[1,48382,"*"],[-1,48383,"重"],[1,48392,"*"],[-1,48392,"["],[1,48396,"\n"],[-1,48413,"重"],[1,48424,"\n"],[-1,48428,"运"],[1,48446,"\n"],[-1,48451,"["],[1,48480,"*"],[-1,48482,"重"],[1,48492,"_"],[-1,48497,"["],[1,48514,"\n"],[-1,48517,"重"],[1,48521," "],[1,48523,"_返回值型_*_"],[-1,48523," 返回值类型 类 "],[1,48548,"_型_"],[-1,48548,"类型 "],[1,48555,"\n"],[-1,48557,"设"],[1,48576,"\n\n *`   *"],[-1,48576," `x[y]"],[-1,48584,"可"],[1,48589,"\n"],[1,48592,"  "],[-1,48592,"x.o"],[1,48602,"     *"],[-1,48602,"[](y)"],[1,48658,"*\n*.4*"],[-1,48658,"\n\n**4.重"],[1,48671,"*"],[-1,48671,"("],[1,48734,"*1_\n* x*类 X*"],[-1,48734,"例1\n\n设 x是类 X的"],[1,48756,"*"],[-1,48757,"x"],[1,48776,"*"],[-1,48777,"可"],[1,48782,"*"],[-1,48783,"x"],[1,48815,"*"],[-1,48815,"\n"],[1,49191,"_/_3_"],[-1,49191,"//例3用"],[1,49200,"_"],[-1,49200,"运"],[1,49208,"_员函数_"],[-1,49208,"成员函数*"],[1,51812,"|"],[1,51815,"lang"],[-1,51815,"cpp"],[1,51820,"```"],[-1,52359,"};\n\n"],[1,52377,"| \n\n"],[-1,52786,"\n};\n"],[1,52793,"\n\n |"],[1,52818,"总"],[-1,52818,""],[-1,52870,"总"],[1,52872,"\n"],[-1,52877,"操"],[1,52894,"\n"],[-1,52898,"操"],[1,52920,"\n"],[-1,52924,"o"],[1,52944,"\n"],[-1,52949,"f"],[1,52971,"\n"],[-1,52976,"操"],[1,52991,"\n"],[-1,52995,"操"],[1,53015,"\n"],[-1,53019,"="],[1,53047,"\n"],[-1,53051,"+"],[1,53076,"\n"],[-1,53080,"C"]],[53088,53088],[44218,44218]]],[1543581644504,["gjx16@GJXAIOU",[[-1,39188,"#"]],[39189,39189],[39188,39188]]],[1543581651062,["gjx16@GJXAIOU",[[1,39196,"#### "]],[39196,39196],[39201,39201]]],[1543581655385,["gjx16@GJXAIOU",[[-1,39201,"**"]],[39201,39203],[39201,39201]]],[1543581660450,["gjx16@GJXAIOU",[[-1,39211,"**"]],[39213,39213],[39211,39211]]],[1543581664925,["gjx16@GJXAIOU",[[1,39201,"**"],[1,39211,"**"]],[39201,39211],[39201,39215]]],[1543581668475,["gjx16@GJXAIOU",[[1,39216,"\n"]],[39215,39215],[39216,39216]]],[1543581676119,["gjx16@GJXAIOU",[[1,39851,"#### "]],[39851,39851],[39856,39856]]],[1543581740029,[null,[[1,44228,"- "],[-1,44252,"=,"],[1,44256,"=,"],[-1,44286,"**"],[1,44288,"）用"],[-1,44292,"**"],[1,44294,"重载"],[-1,44300,"**"],[1,44302,"操作"],[-1,44307,"Ø "],[1,44311,"is"],[-1,44340,"\nØ"],[1,44344,"ci"],[-1,44379,"\nØ"],[1,44383,"运算"],[-1,44416,"\nØ"],[1,44420,"运算"],[-1,44454,"\nØ"],[1,44458,"用友"],[-1,45528,"o\n3）"],[1,45534,"3）友元"],[1,45550,"- "],[-1,45552,"- "],[-1,45584,"\nb"],[1,45612,"b）"],[-1,45615,"\nØ"],[1,45621,"在第"],[-1,45654,"\nØ"],[1,45660,"友员"],[-1,45703,"\nØ"],[1,45709,"C+"],[-1,45726,"\n"],[1,45732,"="],[-1,45748,"**"],[1,45750,"）友"],[-1,45761,"***\n\n|` "],[1,45769,"类**\n``"],[1,45774,"#in"],[-1,45791,"\n"],[1,45794,"i"],[-1,45852,"\n"],[1,45857,"b"],[-1,45860," "],[-1,45863," v\t"],[1,45866,"\tvec"],[-1,45870," "],[1,45873,"t"],[-1,45880,"1"],[1,45882,"1"],[-1,45884,"1\n ~v\t"],[1,45890,"\n\n\t~ve"],[-1,45896," "],[-1,45899," in\t"],[1,45903,"\n\tint"],[-1,45917," "],[1,45920,"t"],[-1,45922," ) \n fr\t"],[1,45930,");\n\n\tfri"],[-1,45957," "],[1,45960,"t"],[-1,45973," "],[1,45976,"v"],[-1,45983," ) \n fr\t"],[1,45991,");\n\n\tfri"],[-1,46018," "],[1,46021,"t"],[-1,46043," ) "],[1,46046,");\n"],[-1,46054," : "],[1,46060,"int"],[-1,46064," "],[-1,46067," in\t"],[1,46071,"\n\tint"],[-1,46075," "],[1,46077,"\n"],[-1,46097," "],[1,46100,"t"],[-1,46105," "],[1,46110,"\tif"],[-1,46111,"i\t"],[-1,46137," "],[-1,46140," {"],[1,46147,"cou"],[-1,46192," "],[1,46195,"a"],[-1,46201," "],[-1,46204," }"],[1,46211,"v ="],[-1,46220," "],[-1,46223,"e ]  "],[1,46228,"ze]; l"],[-1,46237," "],[1,46241,"\n"],[-1,46261,"\n"],[-1,46265," d\t"],[1,46268,"\tdel"],[-1,46275," "],[-1,46278," le\t"],[1,46282,"\n\tlen"],[-1,46286," "],[1,46291,"\n"],[-1,46315," "],[1,46318,"t"],[-1,46320," )  \n i\t "],[1,46329,")\n{\n\tif ("],[1,46331,">="],[-1,46332,"="],[-1,46336," "],[-1,46346," "],[1,46349,"r"],[-1,46357," i  \n co\t"],[1,46366,"i];\n\n\tcou"],[-1,46413," "],[1,46416,"a"],[-1,46422," "],[1,46426,"\n"],[-1,46450," "],[1,46453,"t"],[-1,46480," "],[-1,46485," f\t"],[1,46488,"\tfor "],[-1,46491," "],[-1,46499," "],[1,46502,"i"],[-1,46512," "],[-1,46515," "],[1,46516,"i"],[-1,46520," o"],[1,46524,"out"],[-1,46535," i "],[1,46538,"i]"],[1,46540,"<"],[-1,46544," "],[-1,46547," ou\t"],[1,46551,"\n\tout"],[-1,46562," "],[-1,46565," r"],[1,46568,"ret"],[-1,46578," "],[1,46582,"\n"],[-1,46606," "],[1,46609,"t"],[-1,46635," "],[-1,46640," f\t( i n"],[1,46648,"\tfor (int"],[-1,46654," "],[1,46657,"i"],[-1,46667," "],[-1,46670," "],[1,46671,"i"],[-1,46675," i"],[1,46679,"inp"],[-1,46689," i  \n re\t"],[1,46698,"i];\n\n\tret"],[-1,46707," "],[1,46712,"\n"],[-1,46724,"\n"],[-1,46727," i\t"],[1,46730,"\tint"],[-1,46732," "],[-1,46735," c\t"],[1,46738,"\tcou"],[-1,46777," "],[-1,46780," c\t"],[1,46783,"\tcin"],[-1,46788," "],[-1,46791," v\t"],[1,46794,"\tvec"],[-1,46800," k  \n c\t"],[1,46808,"k);\n\tcou"],[-1,46849," "],[-1,46852," c"],[1,46855,"cin"],[-1,46860," "],[-1,46863," c\t"],[1,46866,"\tcou"],[-1,46908," "],[-1,46911," c\t"],[1,46914,"\tcou"],[-1,46920," "],[-1,46923," s"],[1,46926,"sys"],[-1,46940,"\n"],[-1,46943," |"],[1,46949,"\n\n#"],[-1,46967,"***"],[1,46971,"运算符"],[-1,47004,"***"],[1,47008,"重载赋"],[-1,47012,"*"],[1,47013,"="],[-1,47017,"Ø 赋"],[1,47022,"赋值运"],[-1,47036,"\nØ "],[1,47041,"ope"],[-1,47058,"\nØ "],[1,47063,"重"],[-1,47071,"\n"],[-1,47074,"型_*名_"],[1,47079,"类型&类名:"],[-1,47098,"*"],[1,47101,"类"],[-1,47102,"_"],[1,47104,"&"],[-1,47108,"*"],[1,47109,"\n"],[-1,47130,"\n"],[1,47154,"\n\n"],[-1,47155,"\n"],[-1,47161,"\n"],[1,47162," "],[-1,47174,"\n"],[1,47175," "],[-1,47184,"\n"],[1,47185," "],[-1,47196,"\n"],[-1,48387,"|\n"],[1,48389,"\n\n*"],[-1,48391,"*"],[1,48393,"重"],[-1,48401,"*"],[1,48402,"["],[-1,48405,"\n"],[1,48423,"重"],[-1,48433,"\n"],[1,48438,"运"],[-1,48455,"\n"],[1,48461,"["],[-1,48489,"*"],[1,48492,"重"],[-1,48501,"_"],[1,48507,"["],[-1,48523,"\n"],[1,48527,"重"],[-1,48530," "],[-1,48533,"_返回值型_*_"],[1,48541," 返回值类型 类 "],[-1,48557,"_型_"],[1,48560,"类型 "],[-1,48564,"\n"],[1,48567,"设"],[-1,48585,"\n\n *`   *"],[1,48594," `x[y]"],[1,48596,"可"],[-1,48600,"\n"],[-1,48604,"  "],[1,48606,"x.o"],[-1,48613,"     *"],[1,48619,"[](y)"],[-1,48670,"*\n*.4*"],[1,48676,"\n\n**4.重"],[-1,48682,"*"],[1,48683,"("],[-1,48745,"*1_\n* x*类 X*"],[1,48757,"例1\n\n设 x是类 X的"],[-1,48767,"*"],[1,48769,"x"],[-1,48787,"*"],[1,48789,"可"],[-1,48793,"*"],[1,48795,"x"],[-1,48826,"*"],[1,48827,"\n"],[-1,49202,"_/_3_"],[1,49207,"//例3用"],[-1,49211,"_"],[1,49212,"运"],[-1,49219,"_员函数_"],[1,49224,"成员函数*"],[-1,51823,"|"],[-1,51827,"lang"],[1,51831,"cpp"],[-1,51833,"```"],[1,52375,"};\n\n"],[-1,52389,"| \n\n"],[1,52802,"\n};\n"],[-1,52805,"\n\n |"],[-1,52834,"总"],[1,52835,""],[1,52887,"总"],[-1,52888,"\n"],[1,52894,"操"],[-1,52910,"\n"],[1,52915,"操"],[-1,52936,"\n"],[1,52941,"o"],[-1,52960,"\n"],[1,52966,"f"],[-1,52987,"\n"],[1,52993,"操"],[-1,53007,"\n"],[1,53012,"操"],[-1,53031,"\n"],[1,53036,"="],[-1,53063,"\n"],[1,53068,"+"],[-1,53092,"\n"],[1,53097,"C"]],[44228,44228],[53098,53098]]],[1543581740029,[null,[[-1,44228,"- "],[1,44254,"=,"],[-1,44256,"=,"],[1,44288,"**"],[-1,44288,"）用"],[1,44294,"**"],[-1,44294,"重载"],[1,44302,"**"],[-1,44302,"操作"],[1,44309,"Ø "],[-1,44311,"is"],[1,44342,"\nØ"],[-1,44344,"ci"],[1,44381,"\nØ"],[-1,44383,"运算"],[1,44418,"\nØ"],[-1,44420,"运算"],[1,44456,"\nØ"],[-1,44458,"用友"],[1,45530,"o\n3）"],[-1,45532,"3）友元"],[-1,45552,"- "],[1,45556,"- "],[1,45586,"\nb"],[-1,45612,"b）"],[1,45617,"\nØ"],[-1,45621,"在第"],[1,45656,"\nØ"],[-1,45660,"友员"],[1,45705,"\nØ"],[-1,45709,"C+"],[1,45728,"\n"],[-1,45733,"="],[1,45750,"**"],[-1,45750,"）友"],[1,45763,"***\n\n|` "],[-1,45763,"类**\n``"],[-1,45774,"#in"],[1,45794,"\n"],[-1,45796,"i"],[1,45855,"\n"],[-1,45859,"b"],[1,45863," "],[1,45865," v\t"],[-1,45865,"\tvec"],[1,45873," "],[-1,45875,"t"],[1,45883,"1"],[-1,45884,"1"],[1,45887,"1\n ~v\t"],[-1,45887,"\n\n\t~ve"],[1,45899," "],[1,45901," in\t"],[-1,45901,"\n\tint"],[1,45920," "],[-1,45922,"t"],[1,45925," ) \n fr\t"],[-1,45925,");\n\n\tfri"],[1,45960," "],[-1,45962,"t"],[1,45976," "],[-1,45978,"v"],[1,45986," ) \n fr\t"],[-1,45986,");\n\n\tfri"],[1,46021," "],[-1,46023,"t"],[1,46046," ) "],[-1,46046,");\n"],[1,46057," : "],[-1,46060,"int"],[1,46067," "],[1,46069," in\t"],[-1,46069,"\n\tint"],[1,46078," "],[-1,46079,"\n"],[1,46100," "],[-1,46102,"t"],[1,46108," "],[-1,46112,"\tif"],[1,46116,"i\t"],[1,46140," "],[1,46142," {"],[-1,46147,"cou"],[1,46195," "],[-1,46197,"a"],[1,46204," "],[1,46206," }"],[-1,46211,"v ="],[1,46223," "],[1,46225,"e ]  "],[-1,46225,"ze]; l"],[1,46240," "],[-1,46243,"\n"],[1,46264,"\n"],[1,46267," d\t"],[-1,46267,"\tdel"],[1,46278," "],[1,46280," le\t"],[-1,46280,"\n\tlen"],[1,46289," "],[-1,46293,"\n"],[1,46318," "],[-1,46320,"t"],[1,46323," )  \n i\t "],[-1,46323,")\n{\n\tif ("],[-1,46334,">="],[1,46337,"="],[1,46340," "],[1,46349," "],[-1,46351,"r"],[1,46360," i  \n co\t"],[-1,46360,"i];\n\n\tcou"],[1,46416," "],[-1,46418,"a"],[1,46425," "],[-1,46428,"\n"],[1,46453," "],[-1,46455,"t"],[1,46483," "],[1,46487," f\t"],[-1,46487,"\tfor "],[1,46495," "],[1,46502," "],[-1,46504,"i"],[1,46515," "],[1,46517," "],[-1,46517,"i"],[1,46522," o"],[-1,46524,"out"],[1,46538," i "],[-1,46538,"i]"],[-1,46542,"<"],[1,46547," "],[1,46549," ou\t"],[-1,46549,"\n\tout"],[1,46565," "],[1,46567," r"],[-1,46568,"ret"],[1,46581," "],[-1,46584,"\n"],[1,46609," "],[-1,46611,"t"],[1,46638," "],[1,46642," f\t( i n"],[-1,46642,"\tfor (int"],[1,46657," "],[-1,46659,"i"],[1,46670," "],[1,46672," "],[-1,46672,"i"],[1,46677," i"],[-1,46679,"inp"],[1,46692," i  \n re\t"],[-1,46692,"i];\n\n\tret"],[1,46710," "],[-1,46714,"\n"],[1,46727,"\n"],[1,46729," i\t"],[-1,46729,"\tint"],[1,46735," "],[1,46737," c\t"],[-1,46737,"\tcou"],[1,46780," "],[1,46782," c\t"],[-1,46782,"\tcin"],[1,46791," "],[1,46793," v\t"],[-1,46793,"\tvec"],[1,46803," k  \n c\t"],[-1,46803,"k);\n\tcou"],[1,46852," "],[1,46854," c"],[-1,46855,"cin"],[1,46863," "],[1,46865," c\t"],[-1,46865,"\tcou"],[1,46911," "],[1,46913," c\t"],[-1,46913,"\tcou"],[1,46923," "],[1,46925," s"],[-1,46926,"sys"],[1,46943,"\n"],[1,46945," |"],[-1,46949,"\n\n#"],[1,46970,"***"],[-1,46971,"运算符"],[1,47007,"***"],[-1,47008,"重载赋"],[1,47015,"*"],[-1,47015,"="],[1,47020,"Ø 赋"],[-1,47022,"赋值运"],[1,47039,"\nØ "],[-1,47041,"ope"],[1,47061,"\nØ "],[-1,47063,"重"],[1,47072,"\n"],[1,47074,"型_*名_"],[-1,47074,"类型&类名:"],[1,47099,"*"],[-1,47101,"类"],[1,47103,"_"],[-1,47104,"&"],[1,47109,"*"],[-1,47109,"\n"],[1,47131,"\n"],[-1,47154,"\n\n"],[1,47157,"\n"],[1,47162,"\n"],[-1,47162," "],[1,47175,"\n"],[-1,47175," "],[1,47185,"\n"],[-1,47185," "],[1,47197,"\n"],[1,48387,"|\n"],[-1,48387,"\n\n*"],[1,48392,"*"],[-1,48393,"重"],[1,48402,"*"],[-1,48402,"["],[1,48406,"\n"],[-1,48423,"重"],[1,48434,"\n"],[-1,48438,"运"],[1,48456,"\n"],[-1,48461,"["],[1,48490,"*"],[-1,48492,"重"],[1,48502,"_"],[-1,48507,"["],[1,48524,"\n"],[-1,48527,"重"],[1,48531," "],[1,48533,"_返回值型_*_"],[-1,48533," 返回值类型 类 "],[1,48558,"_型_"],[-1,48558,"类型 "],[1,48565,"\n"],[-1,48567,"设"],[1,48586,"\n\n *`   *"],[-1,48586," `x[y]"],[-1,48594,"可"],[1,48599,"\n"],[1,48602,"  "],[-1,48602,"x.o"],[1,48612,"     *"],[-1,48612,"[](y)"],[1,48668,"*\n*.4*"],[-1,48668,"\n\n**4.重"],[1,48681,"*"],[-1,48681,"("],[1,48744,"*1_\n* x*类 X*"],[-1,48744,"例1\n\n设 x是类 X的"],[1,48766,"*"],[-1,48767,"x"],[1,48786,"*"],[-1,48787,"可"],[1,48792,"*"],[-1,48793,"x"],[1,48825,"*"],[-1,48825,"\n"],[1,49201,"_/_3_"],[-1,49201,"//例3用"],[1,49210,"_"],[-1,49210,"运"],[1,49218,"_员函数_"],[-1,49218,"成员函数*"],[1,51822,"|"],[1,51825,"lang"],[-1,51825,"cpp"],[1,51830,"```"],[-1,52369,"};\n\n"],[1,52387,"| \n\n"],[-1,52796,"\n};\n"],[1,52803,"\n\n |"],[1,52828,"总"],[-1,52828,""],[-1,52880,"总"],[1,52882,"\n"],[-1,52887,"操"],[1,52904,"\n"],[-1,52908,"操"],[1,52930,"\n"],[-1,52934,"o"],[1,52954,"\n"],[-1,52959,"f"],[1,52981,"\n"],[-1,52986,"操"],[1,53001,"\n"],[-1,53005,"操"],[1,53025,"\n"],[-1,53029,"="],[1,53057,"\n"],[-1,53061,"+"],[1,53086,"\n"],[-1,53090,"C"]],[53098,53098],[44228,44228]]],[1543581691416,["gjx16@GJXAIOU",[[1,41341,"#### "]],[41341,41341],[41346,41346]]],[1543581711601,["gjx16@GJXAIOU",[[1,44192,"####"]],[44192,44192],[44196,44196]]],[1543581714328,["gjx16@GJXAIOU",[[-1,44192,"####"]],[44196,44196],[44192,44192]]],[1543581719435,["gjx16@GJXAIOU",[[1,44190,"#### "]],[44190,44190],[44195,44195]]],[1543581800036,[null,[[1,44238,"- "],[-1,44262,"=,"],[1,44266,"=,"],[-1,44296,"**"],[1,44298,"）用"],[-1,44302,"**"],[1,44304,"重载"],[-1,44310,"**"],[1,44312,"操作"],[-1,44317,"Ø "],[1,44321,"is"],[-1,44350,"\nØ"],[1,44354,"ci"],[-1,44389,"\nØ"],[1,44393,"运算"],[-1,44426,"\nØ"],[1,44430,"运算"],[-1,44464,"\nØ"],[1,44468,"用友"],[-1,45538,"o\n3）"],[1,45544,"3）友元"],[1,45560,"- "],[-1,45562,"- "],[-1,45594,"\nb"],[1,45622,"b）"],[-1,45625,"\nØ"],[1,45631,"在第"],[-1,45664,"\nØ"],[1,45670,"友员"],[-1,45713,"\nØ"],[1,45719,"C+"],[-1,45736,"\n"],[1,45742,"="],[-1,45758,"**"],[1,45760,"）友"],[-1,45771,"***\n\n|` "],[1,45779,"类**\n``"],[1,45784,"#in"],[-1,45801,"\n"],[1,45804,"i"],[-1,45862,"\n"],[1,45867,"b"],[-1,45870," "],[-1,45873," v\t"],[1,45876,"\tvec"],[-1,45880," "],[1,45883,"t"],[-1,45890,"1"],[1,45892,"1"],[-1,45894,"1\n ~v\t"],[1,45900,"\n\n\t~ve"],[-1,45906," "],[-1,45909," in\t"],[1,45913,"\n\tint"],[-1,45927," "],[1,45930,"t"],[-1,45932," ) \n fr\t"],[1,45940,");\n\n\tfri"],[-1,45967," "],[1,45970,"t"],[-1,45983," "],[1,45986,"v"],[-1,45993," ) \n fr\t"],[1,46001,");\n\n\tfri"],[-1,46028," "],[1,46031,"t"],[-1,46053," ) "],[1,46056,");\n"],[-1,46064," : "],[1,46070,"int"],[-1,46074," "],[-1,46077," in\t"],[1,46081,"\n\tint"],[-1,46085," "],[1,46087,"\n"],[-1,46107," "],[1,46110,"t"],[-1,46115," "],[1,46120,"\tif"],[-1,46121,"i\t"],[-1,46147," "],[-1,46150," {"],[1,46157,"cou"],[-1,46202," "],[1,46205,"a"],[-1,46211," "],[-1,46214," }"],[1,46221,"v ="],[-1,46230," "],[-1,46233,"e ]  "],[1,46238,"ze]; l"],[-1,46247," "],[1,46251,"\n"],[-1,46271,"\n"],[-1,46275," d\t"],[1,46278,"\tdel"],[-1,46285," "],[-1,46288," le\t"],[1,46292,"\n\tlen"],[-1,46296," "],[1,46301,"\n"],[-1,46325," "],[1,46328,"t"],[-1,46330," )  \n i\t "],[1,46339,")\n{\n\tif ("],[1,46341,">="],[-1,46342,"="],[-1,46346," "],[-1,46356," "],[1,46359,"r"],[-1,46367," i  \n co\t"],[1,46376,"i];\n\n\tcou"],[-1,46423," "],[1,46426,"a"],[-1,46432," "],[1,46436,"\n"],[-1,46460," "],[1,46463,"t"],[-1,46490," "],[-1,46495," f\t"],[1,46498,"\tfor "],[-1,46501," "],[-1,46509," "],[1,46512,"i"],[-1,46522," "],[-1,46525," "],[1,46526,"i"],[-1,46530," o"],[1,46534,"out"],[-1,46545," i "],[1,46548,"i]"],[1,46550,"<"],[-1,46554," "],[-1,46557," ou\t"],[1,46561,"\n\tout"],[-1,46572," "],[-1,46575," r"],[1,46578,"ret"],[-1,46588," "],[1,46592,"\n"],[-1,46616," "],[1,46619,"t"],[-1,46645," "],[-1,46650," f\t( i n"],[1,46658,"\tfor (int"],[-1,46664," "],[1,46667,"i"],[-1,46677," "],[-1,46680," "],[1,46681,"i"],[-1,46685," i"],[1,46689,"inp"],[-1,46699," i  \n re\t"],[1,46708,"i];\n\n\tret"],[-1,46717," "],[1,46722,"\n"],[-1,46734,"\n"],[-1,46737," i\t"],[1,46740,"\tint"],[-1,46742," "],[-1,46745," c\t"],[1,46748,"\tcou"],[-1,46787," "],[-1,46790," c\t"],[1,46793,"\tcin"],[-1,46798," "],[-1,46801," v\t"],[1,46804,"\tvec"],[-1,46810," k  \n c\t"],[1,46818,"k);\n\tcou"],[-1,46859," "],[-1,46862," c"],[1,46865,"cin"],[-1,46870," "],[-1,46873," c\t"],[1,46876,"\tcou"],[-1,46918," "],[-1,46921," c\t"],[1,46924,"\tcou"],[-1,46930," "],[-1,46933," s"],[1,46936,"sys"],[-1,46950,"\n"],[-1,46953," |"],[1,46959,"\n\n#"],[-1,46977,"***"],[1,46981,"运算符"],[-1,47014,"***"],[1,47018,"重载赋"],[-1,47022,"*"],[1,47023,"="],[-1,47027,"Ø 赋"],[1,47032,"赋值运"],[-1,47046,"\nØ "],[1,47051,"ope"],[-1,47068,"\nØ "],[1,47073,"重"],[-1,47081,"\n"],[-1,47084,"型_*名_"],[1,47089,"类型&类名:"],[-1,47108,"*"],[1,47111,"类"],[-1,47112,"_"],[1,47114,"&"],[-1,47118,"*"],[1,47119,"\n"],[-1,47140,"\n"],[1,47164,"\n\n"],[-1,47165,"\n"],[-1,47171,"\n"],[1,47172," "],[-1,47184,"\n"],[1,47185," "],[-1,47194,"\n"],[1,47195," "],[-1,47206,"\n"],[-1,48397,"|\n"],[1,48399,"\n\n*"],[-1,48401,"*"],[1,48403,"重"],[-1,48411,"*"],[1,48412,"["],[-1,48415,"\n"],[1,48433,"重"],[-1,48443,"\n"],[1,48448,"运"],[-1,48465,"\n"],[1,48471,"["],[-1,48499,"*"],[1,48502,"重"],[-1,48511,"_"],[1,48517,"["],[-1,48533,"\n"],[1,48537,"重"],[-1,48540," "],[-1,48543,"_返回值型_*_"],[1,48551," 返回值类型 类 "],[-1,48567,"_型_"],[1,48570,"类型 "],[-1,48574,"\n"],[1,48577,"设"],[-1,48595,"\n\n *`   *"],[1,48604," `x[y]"],[1,48606,"可"],[-1,48610,"\n"],[-1,48614,"  "],[1,48616,"x.o"],[-1,48623,"     *"],[1,48629,"[](y)"],[-1,48680,"*\n*.4*"],[1,48686,"\n\n**4.重"],[-1,48692,"*"],[1,48693,"("],[-1,48755,"*1_\n* x*类 X*"],[1,48767,"例1\n\n设 x是类 X的"],[-1,48777,"*"],[1,48779,"x"],[-1,48797,"*"],[1,48799,"可"],[-1,48803,"*"],[1,48805,"x"],[-1,48836,"*"],[1,48837,"\n"],[-1,49212,"_/_3_"],[1,49217,"//例3用"],[-1,49221,"_"],[1,49222,"运"],[-1,49229,"_员函数_"],[1,49234,"成员函数*"],[-1,51833,"|"],[-1,51837,"lang"],[1,51841,"cpp"],[-1,51843,"```"],[1,52385,"};\n\n"],[-1,52399,"| \n\n"],[1,52812,"\n};\n"],[-1,52815,"\n\n |"],[-1,52844,"总"],[1,52845,""],[1,52897,"总"],[-1,52898,"\n"],[1,52904,"操"],[-1,52920,"\n"],[1,52925,"操"],[-1,52946,"\n"],[1,52951,"o"],[-1,52970,"\n"],[1,52976,"f"],[-1,52997,"\n"],[1,53003,"操"],[-1,53017,"\n"],[1,53022,"操"],[-1,53041,"\n"],[1,53046,"="],[-1,53073,"\n"],[1,53078,"+"],[-1,53102,"\n"],[1,53107,"C"]],[44238,44238],[53108,53108]]],[1543581800036,[null,[[-1,44238,"- "],[1,44264,"=,"],[-1,44266,"=,"],[1,44298,"**"],[-1,44298,"）用"],[1,44304,"**"],[-1,44304,"重载"],[1,44312,"**"],[-1,44312,"操作"],[1,44319,"Ø "],[-1,44321,"is"],[1,44352,"\nØ"],[-1,44354,"ci"],[1,44391,"\nØ"],[-1,44393,"运算"],[1,44428,"\nØ"],[-1,44430,"运算"],[1,44466,"\nØ"],[-1,44468,"用友"],[1,45540,"o\n3）"],[-1,45542,"3）友元"],[-1,45562,"- "],[1,45566,"- "],[1,45596,"\nb"],[-1,45622,"b）"],[1,45627,"\nØ"],[-1,45631,"在第"],[1,45666,"\nØ"],[-1,45670,"友员"],[1,45715,"\nØ"],[-1,45719,"C+"],[1,45738,"\n"],[-1,45743,"="],[1,45760,"**"],[-1,45760,"）友"],[1,45773,"***\n\n|` "],[-1,45773,"类**\n``"],[-1,45784,"#in"],[1,45804,"\n"],[-1,45806,"i"],[1,45865,"\n"],[-1,45869,"b"],[1,45873," "],[1,45875," v\t"],[-1,45875,"\tvec"],[1,45883," "],[-1,45885,"t"],[1,45893,"1"],[-1,45894,"1"],[1,45897,"1\n ~v\t"],[-1,45897,"\n\n\t~ve"],[1,45909," "],[1,45911," in\t"],[-1,45911,"\n\tint"],[1,45930," "],[-1,45932,"t"],[1,45935," ) \n fr\t"],[-1,45935,");\n\n\tfri"],[1,45970," "],[-1,45972,"t"],[1,45986," "],[-1,45988,"v"],[1,45996," ) \n fr\t"],[-1,45996,");\n\n\tfri"],[1,46031," "],[-1,46033,"t"],[1,46056," ) "],[-1,46056,");\n"],[1,46067," : "],[-1,46070,"int"],[1,46077," "],[1,46079," in\t"],[-1,46079,"\n\tint"],[1,46088," "],[-1,46089,"\n"],[1,46110," "],[-1,46112,"t"],[1,46118," "],[-1,46122,"\tif"],[1,46126,"i\t"],[1,46150," "],[1,46152," {"],[-1,46157,"cou"],[1,46205," "],[-1,46207,"a"],[1,46214," "],[1,46216," }"],[-1,46221,"v ="],[1,46233," "],[1,46235,"e ]  "],[-1,46235,"ze]; l"],[1,46250," "],[-1,46253,"\n"],[1,46274,"\n"],[1,46277," d\t"],[-1,46277,"\tdel"],[1,46288," "],[1,46290," le\t"],[-1,46290,"\n\tlen"],[1,46299," "],[-1,46303,"\n"],[1,46328," "],[-1,46330,"t"],[1,46333," )  \n i\t "],[-1,46333,")\n{\n\tif ("],[-1,46344,">="],[1,46347,"="],[1,46350," "],[1,46359," "],[-1,46361,"r"],[1,46370," i  \n co\t"],[-1,46370,"i];\n\n\tcou"],[1,46426," "],[-1,46428,"a"],[1,46435," "],[-1,46438,"\n"],[1,46463," "],[-1,46465,"t"],[1,46493," "],[1,46497," f\t"],[-1,46497,"\tfor "],[1,46505," "],[1,46512," "],[-1,46514,"i"],[1,46525," "],[1,46527," "],[-1,46527,"i"],[1,46532," o"],[-1,46534,"out"],[1,46548," i "],[-1,46548,"i]"],[-1,46552,"<"],[1,46557," "],[1,46559," ou\t"],[-1,46559,"\n\tout"],[1,46575," "],[1,46577," r"],[-1,46578,"ret"],[1,46591," "],[-1,46594,"\n"],[1,46619," "],[-1,46621,"t"],[1,46648," "],[1,46652," f\t( i n"],[-1,46652,"\tfor (int"],[1,46667," "],[-1,46669,"i"],[1,46680," "],[1,46682," "],[-1,46682,"i"],[1,46687," i"],[-1,46689,"inp"],[1,46702," i  \n re\t"],[-1,46702,"i];\n\n\tret"],[1,46720," "],[-1,46724,"\n"],[1,46737,"\n"],[1,46739," i\t"],[-1,46739,"\tint"],[1,46745," "],[1,46747," c\t"],[-1,46747,"\tcou"],[1,46790," "],[1,46792," c\t"],[-1,46792,"\tcin"],[1,46801," "],[1,46803," v\t"],[-1,46803,"\tvec"],[1,46813," k  \n c\t"],[-1,46813,"k);\n\tcou"],[1,46862," "],[1,46864," c"],[-1,46865,"cin"],[1,46873," "],[1,46875," c\t"],[-1,46875,"\tcou"],[1,46921," "],[1,46923," c\t"],[-1,46923,"\tcou"],[1,46933," "],[1,46935," s"],[-1,46936,"sys"],[1,46953,"\n"],[1,46955," |"],[-1,46959,"\n\n#"],[1,46980,"***"],[-1,46981,"运算符"],[1,47017,"***"],[-1,47018,"重载赋"],[1,47025,"*"],[-1,47025,"="],[1,47030,"Ø 赋"],[-1,47032,"赋值运"],[1,47049,"\nØ "],[-1,47051,"ope"],[1,47071,"\nØ "],[-1,47073,"重"],[1,47082,"\n"],[1,47084,"型_*名_"],[-1,47084,"类型&类名:"],[1,47109,"*"],[-1,47111,"类"],[1,47113,"_"],[-1,47114,"&"],[1,47119,"*"],[-1,47119,"\n"],[1,47141,"\n"],[-1,47164,"\n\n"],[1,47167,"\n"],[1,47172,"\n"],[-1,47172," "],[1,47185,"\n"],[-1,47185," "],[1,47195,"\n"],[-1,47195," "],[1,47207,"\n"],[1,48397,"|\n"],[-1,48397,"\n\n*"],[1,48402,"*"],[-1,48403,"重"],[1,48412,"*"],[-1,48412,"["],[1,48416,"\n"],[-1,48433,"重"],[1,48444,"\n"],[-1,48448,"运"],[1,48466,"\n"],[-1,48471,"["],[1,48500,"*"],[-1,48502,"重"],[1,48512,"_"],[-1,48517,"["],[1,48534,"\n"],[-1,48537,"重"],[1,48541," "],[1,48543,"_返回值型_*_"],[-1,48543," 返回值类型 类 "],[1,48568,"_型_"],[-1,48568,"类型 "],[1,48575,"\n"],[-1,48577,"设"],[1,48596,"\n\n *`   *"],[-1,48596," `x[y]"],[-1,48604,"可"],[1,48609,"\n"],[1,48612,"  "],[-1,48612,"x.o"],[1,48622,"     *"],[-1,48622,"[](y)"],[1,48678,"*\n*.4*"],[-1,48678,"\n\n**4.重"],[1,48691,"*"],[-1,48691,"("],[1,48754,"*1_\n* x*类 X*"],[-1,48754,"例1\n\n设 x是类 X的"],[1,48776,"*"],[-1,48777,"x"],[1,48796,"*"],[-1,48797,"可"],[1,48802,"*"],[-1,48803,"x"],[1,48835,"*"],[-1,48835,"\n"],[1,49211,"_/_3_"],[-1,49211,"//例3用"],[1,49220,"_"],[-1,49220,"运"],[1,49228,"_员函数_"],[-1,49228,"成员函数*"],[1,51832,"|"],[1,51835,"lang"],[-1,51835,"cpp"],[1,51840,"```"],[-1,52379,"};\n\n"],[1,52397,"| \n\n"],[-1,52806,"\n};\n"],[1,52813,"\n\n |"],[1,52838,"总"],[-1,52838,""],[-1,52890,"总"],[1,52892,"\n"],[-1,52897,"操"],[1,52914,"\n"],[-1,52918,"操"],[1,52940,"\n"],[-1,52944,"o"],[1,52964,"\n"],[-1,52969,"f"],[1,52991,"\n"],[-1,52996,"操"],[1,53011,"\n"],[-1,53015,"操"],[1,53035,"\n"],[-1,53039,"="],[1,53067,"\n"],[-1,53071,"+"],[1,53096,"\n"],[-1,53100,"C"]],[53108,53108],[44238,44238]]],[1543581778419,["gjx16@GJXAIOU",[[1,44054,"\n"]],[44054,44054],[44055,44055]]],[1543581782172,["gjx16@GJXAIOU",[[1,44055,"#### "]],[44055,44055],[44060,44060]]],[1543581860050,[null,[[1,44244,"- "],[-1,44268,"=,"],[1,44272,"=,"],[-1,44302,"**"],[1,44304,"）用"],[-1,44308,"**"],[1,44310,"重载"],[-1,44316,"**"],[1,44318,"操作"],[-1,44323,"Ø "],[1,44327,"is"],[-1,44356,"\nØ"],[1,44360,"ci"],[-1,44395,"\nØ"],[1,44399,"运算"],[-1,44432,"\nØ"],[1,44436,"运算"],[-1,44470,"\nØ"],[1,44474,"用友"],[-1,45544,"o\n3）"],[1,45550,"3）友元"],[1,45566,"- "],[-1,45568,"- "],[-1,45600,"\nb"],[1,45628,"b）"],[-1,45631,"\nØ"],[1,45637,"在第"],[-1,45670,"\nØ"],[1,45676,"友员"],[-1,45719,"\nØ"],[1,45725,"C+"],[-1,45742,"\n"],[1,45748,"="],[-1,45764,"**"],[1,45766,"）友"],[-1,45777,"***\n\n|` "],[1,45785,"类**\n``"],[1,45790,"#in"],[-1,45807,"\n"],[1,45810,"i"],[-1,45868,"\n"],[1,45873,"b"],[-1,45876," "],[-1,45879," v\t"],[1,45882,"\tvec"],[-1,45886," "],[1,45889,"t"],[-1,45896,"1"],[1,45898,"1"],[-1,45900,"1\n ~v\t"],[1,45906,"\n\n\t~ve"],[-1,45912," "],[-1,45915," in\t"],[1,45919,"\n\tint"],[-1,45933," "],[1,45936,"t"],[-1,45938," ) \n fr\t"],[1,45946,");\n\n\tfri"],[-1,45973," "],[1,45976,"t"],[-1,45989," "],[1,45992,"v"],[-1,45999," ) \n fr\t"],[1,46007,");\n\n\tfri"],[-1,46034," "],[1,46037,"t"],[-1,46059," ) "],[1,46062,");\n"],[-1,46070," : "],[1,46076,"int"],[-1,46080," "],[-1,46083," in\t"],[1,46087,"\n\tint"],[-1,46091," "],[1,46093,"\n"],[-1,46113," "],[1,46116,"t"],[-1,46121," "],[1,46126,"\tif"],[-1,46127,"i\t"],[-1,46153," "],[-1,46156," {"],[1,46163,"cou"],[-1,46208," "],[1,46211,"a"],[-1,46217," "],[-1,46220," }"],[1,46227,"v ="],[-1,46236," "],[-1,46239,"e ]  "],[1,46244,"ze]; l"],[-1,46253," "],[1,46257,"\n"],[-1,46277,"\n"],[-1,46281," d\t"],[1,46284,"\tdel"],[-1,46291," "],[-1,46294," le\t"],[1,46298,"\n\tlen"],[-1,46302," "],[1,46307,"\n"],[-1,46331," "],[1,46334,"t"],[-1,46336," )  \n i\t "],[1,46345,")\n{\n\tif ("],[1,46347,">="],[-1,46348,"="],[-1,46352," "],[-1,46362," "],[1,46365,"r"],[-1,46373," i  \n co\t"],[1,46382,"i];\n\n\tcou"],[-1,46429," "],[1,46432,"a"],[-1,46438," "],[1,46442,"\n"],[-1,46466," "],[1,46469,"t"],[-1,46496," "],[-1,46501," f\t"],[1,46504,"\tfor "],[-1,46507," "],[-1,46515," "],[1,46518,"i"],[-1,46528," "],[-1,46531," "],[1,46532,"i"],[-1,46536," o"],[1,46540,"out"],[-1,46551," i "],[1,46554,"i]"],[1,46556,"<"],[-1,46560," "],[-1,46563," ou\t"],[1,46567,"\n\tout"],[-1,46578," "],[-1,46581," r"],[1,46584,"ret"],[-1,46594," "],[1,46598,"\n"],[-1,46622," "],[1,46625,"t"],[-1,46651," "],[-1,46656," f\t( i n"],[1,46664,"\tfor (int"],[-1,46670," "],[1,46673,"i"],[-1,46683," "],[-1,46686," "],[1,46687,"i"],[-1,46691," i"],[1,46695,"inp"],[-1,46705," i  \n re\t"],[1,46714,"i];\n\n\tret"],[-1,46723," "],[1,46728,"\n"],[-1,46740,"\n"],[-1,46743," i\t"],[1,46746,"\tint"],[-1,46748," "],[-1,46751," c\t"],[1,46754,"\tcou"],[-1,46793," "],[-1,46796," c\t"],[1,46799,"\tcin"],[-1,46804," "],[-1,46807," v\t"],[1,46810,"\tvec"],[-1,46816," k  \n c\t"],[1,46824,"k);\n\tcou"],[-1,46865," "],[-1,46868," c"],[1,46871,"cin"],[-1,46876," "],[-1,46879," c\t"],[1,46882,"\tcou"],[-1,46924," "],[-1,46927," c\t"],[1,46930,"\tcou"],[-1,46936," "],[-1,46939," s"],[1,46942,"sys"],[-1,46956,"\n"],[-1,46959," |"],[1,46965,"\n\n#"],[-1,46983,"***"],[1,46987,"运算符"],[-1,47020,"***"],[1,47024,"重载赋"],[-1,47028,"*"],[1,47029,"="],[-1,47033,"Ø 赋"],[1,47038,"赋值运"],[-1,47052,"\nØ "],[1,47057,"ope"],[-1,47074,"\nØ "],[1,47079,"重"],[-1,47087,"\n"],[-1,47090,"型_*名_"],[1,47095,"类型&类名:"],[-1,47114,"*"],[1,47117,"类"],[-1,47118,"_"],[1,47120,"&"],[-1,47124,"*"],[1,47125,"\n"],[-1,47146,"\n"],[1,47170,"\n\n"],[-1,47171,"\n"],[-1,47177,"\n"],[1,47178," "],[-1,47190,"\n"],[1,47191," "],[-1,47200,"\n"],[1,47201," "],[-1,47212,"\n"],[-1,48403,"|\n"],[1,48405,"\n\n*"],[-1,48407,"*"],[1,48409,"重"],[-1,48417,"*"],[1,48418,"["],[-1,48421,"\n"],[1,48439,"重"],[-1,48449,"\n"],[1,48454,"运"],[-1,48471,"\n"],[1,48477,"["],[-1,48505,"*"],[1,48508,"重"],[-1,48517,"_"],[1,48523,"["],[-1,48539,"\n"],[1,48543,"重"],[-1,48546," "],[-1,48549,"_返回值型_*_"],[1,48557," 返回值类型 类 "],[-1,48573,"_型_"],[1,48576,"类型 "],[-1,48580,"\n"],[1,48583,"设"],[-1,48601,"\n\n *`   *"],[1,48610," `x[y]"],[1,48612,"可"],[-1,48616,"\n"],[-1,48620,"  "],[1,48622,"x.o"],[-1,48629,"     *"],[1,48635,"[](y)"],[-1,48686,"*\n*.4*"],[1,48692,"\n\n**4.重"],[-1,48698,"*"],[1,48699,"("],[-1,48761,"*1_\n* x*类 X*"],[1,48773,"例1\n\n设 x是类 X的"],[-1,48783,"*"],[1,48785,"x"],[-1,48803,"*"],[1,48805,"可"],[-1,48809,"*"],[1,48811,"x"],[-1,48842,"*"],[1,48843,"\n"],[-1,49218,"_/_3_"],[1,49223,"//例3用"],[-1,49227,"_"],[1,49228,"运"],[-1,49235,"_员函数_"],[1,49240,"成员函数*"],[-1,51839,"|"],[-1,51843,"lang"],[1,51847,"cpp"],[-1,51849,"```"],[1,52391,"};\n\n"],[-1,52405,"| \n\n"],[1,52818,"\n};\n"],[-1,52821,"\n\n |"],[-1,52850,"总"],[1,52851,""],[1,52903,"总"],[-1,52904,"\n"],[1,52910,"操"],[-1,52926,"\n"],[1,52931,"操"],[-1,52952,"\n"],[1,52957,"o"],[-1,52976,"\n"],[1,52982,"f"],[-1,53003,"\n"],[1,53009,"操"],[-1,53023,"\n"],[1,53028,"操"],[-1,53047,"\n"],[1,53052,"="],[-1,53079,"\n"],[1,53084,"+"],[-1,53108,"\n"],[1,53113,"C"]],[44244,44244],[53114,53114]]],[1543581860050,[null,[[-1,44244,"- "],[1,44270,"=,"],[-1,44272,"=,"],[1,44304,"**"],[-1,44304,"）用"],[1,44310,"**"],[-1,44310,"重载"],[1,44318,"**"],[-1,44318,"操作"],[1,44325,"Ø "],[-1,44327,"is"],[1,44358,"\nØ"],[-1,44360,"ci"],[1,44397,"\nØ"],[-1,44399,"运算"],[1,44434,"\nØ"],[-1,44436,"运算"],[1,44472,"\nØ"],[-1,44474,"用友"],[1,45546,"o\n3）"],[-1,45548,"3）友元"],[-1,45568,"- "],[1,45572,"- "],[1,45602,"\nb"],[-1,45628,"b）"],[1,45633,"\nØ"],[-1,45637,"在第"],[1,45672,"\nØ"],[-1,45676,"友员"],[1,45721,"\nØ"],[-1,45725,"C+"],[1,45744,"\n"],[-1,45749,"="],[1,45766,"**"],[-1,45766,"）友"],[1,45779,"***\n\n|` "],[-1,45779,"类**\n``"],[-1,45790,"#in"],[1,45810,"\n"],[-1,45812,"i"],[1,45871,"\n"],[-1,45875,"b"],[1,45879," "],[1,45881," v\t"],[-1,45881,"\tvec"],[1,45889," "],[-1,45891,"t"],[1,45899,"1"],[-1,45900,"1"],[1,45903,"1\n ~v\t"],[-1,45903,"\n\n\t~ve"],[1,45915," "],[1,45917," in\t"],[-1,45917,"\n\tint"],[1,45936," "],[-1,45938,"t"],[1,45941," ) \n fr\t"],[-1,45941,");\n\n\tfri"],[1,45976," "],[-1,45978,"t"],[1,45992," "],[-1,45994,"v"],[1,46002," ) \n fr\t"],[-1,46002,");\n\n\tfri"],[1,46037," "],[-1,46039,"t"],[1,46062," ) "],[-1,46062,");\n"],[1,46073," : "],[-1,46076,"int"],[1,46083," "],[1,46085," in\t"],[-1,46085,"\n\tint"],[1,46094," "],[-1,46095,"\n"],[1,46116," "],[-1,46118,"t"],[1,46124," "],[-1,46128,"\tif"],[1,46132,"i\t"],[1,46156," "],[1,46158," {"],[-1,46163,"cou"],[1,46211," "],[-1,46213,"a"],[1,46220," "],[1,46222," }"],[-1,46227,"v ="],[1,46239," "],[1,46241,"e ]  "],[-1,46241,"ze]; l"],[1,46256," "],[-1,46259,"\n"],[1,46280,"\n"],[1,46283," d\t"],[-1,46283,"\tdel"],[1,46294," "],[1,46296," le\t"],[-1,46296,"\n\tlen"],[1,46305," "],[-1,46309,"\n"],[1,46334," "],[-1,46336,"t"],[1,46339," )  \n i\t "],[-1,46339,")\n{\n\tif ("],[-1,46350,">="],[1,46353,"="],[1,46356," "],[1,46365," "],[-1,46367,"r"],[1,46376," i  \n co\t"],[-1,46376,"i];\n\n\tcou"],[1,46432," "],[-1,46434,"a"],[1,46441," "],[-1,46444,"\n"],[1,46469," "],[-1,46471,"t"],[1,46499," "],[1,46503," f\t"],[-1,46503,"\tfor "],[1,46511," "],[1,46518," "],[-1,46520,"i"],[1,46531," "],[1,46533," "],[-1,46533,"i"],[1,46538," o"],[-1,46540,"out"],[1,46554," i "],[-1,46554,"i]"],[-1,46558,"<"],[1,46563," "],[1,46565," ou\t"],[-1,46565,"\n\tout"],[1,46581," "],[1,46583," r"],[-1,46584,"ret"],[1,46597," "],[-1,46600,"\n"],[1,46625," "],[-1,46627,"t"],[1,46654," "],[1,46658," f\t( i n"],[-1,46658,"\tfor (int"],[1,46673," "],[-1,46675,"i"],[1,46686," "],[1,46688," "],[-1,46688,"i"],[1,46693," i"],[-1,46695,"inp"],[1,46708," i  \n re\t"],[-1,46708,"i];\n\n\tret"],[1,46726," "],[-1,46730,"\n"],[1,46743,"\n"],[1,46745," i\t"],[-1,46745,"\tint"],[1,46751," "],[1,46753," c\t"],[-1,46753,"\tcou"],[1,46796," "],[1,46798," c\t"],[-1,46798,"\tcin"],[1,46807," "],[1,46809," v\t"],[-1,46809,"\tvec"],[1,46819," k  \n c\t"],[-1,46819,"k);\n\tcou"],[1,46868," "],[1,46870," c"],[-1,46871,"cin"],[1,46879," "],[1,46881," c\t"],[-1,46881,"\tcou"],[1,46927," "],[1,46929," c\t"],[-1,46929,"\tcou"],[1,46939," "],[1,46941," s"],[-1,46942,"sys"],[1,46959,"\n"],[1,46961," |"],[-1,46965,"\n\n#"],[1,46986,"***"],[-1,46987,"运算符"],[1,47023,"***"],[-1,47024,"重载赋"],[1,47031,"*"],[-1,47031,"="],[1,47036,"Ø 赋"],[-1,47038,"赋值运"],[1,47055,"\nØ "],[-1,47057,"ope"],[1,47077,"\nØ "],[-1,47079,"重"],[1,47088,"\n"],[1,47090,"型_*名_"],[-1,47090,"类型&类名:"],[1,47115,"*"],[-1,47117,"类"],[1,47119,"_"],[-1,47120,"&"],[1,47125,"*"],[-1,47125,"\n"],[1,47147,"\n"],[-1,47170,"\n\n"],[1,47173,"\n"],[1,47178,"\n"],[-1,47178," "],[1,47191,"\n"],[-1,47191," "],[1,47201,"\n"],[-1,47201," "],[1,47213,"\n"],[1,48403,"|\n"],[-1,48403,"\n\n*"],[1,48408,"*"],[-1,48409,"重"],[1,48418,"*"],[-1,48418,"["],[1,48422,"\n"],[-1,48439,"重"],[1,48450,"\n"],[-1,48454,"运"],[1,48472,"\n"],[-1,48477,"["],[1,48506,"*"],[-1,48508,"重"],[1,48518,"_"],[-1,48523,"["],[1,48540,"\n"],[-1,48543,"重"],[1,48547," "],[1,48549,"_返回值型_*_"],[-1,48549," 返回值类型 类 "],[1,48574,"_型_"],[-1,48574,"类型 "],[1,48581,"\n"],[-1,48583,"设"],[1,48602,"\n\n *`   *"],[-1,48602," `x[y]"],[-1,48610,"可"],[1,48615,"\n"],[1,48618,"  "],[-1,48618,"x.o"],[1,48628,"     *"],[-1,48628,"[](y)"],[1,48684,"*\n*.4*"],[-1,48684,"\n\n**4.重"],[1,48697,"*"],[-1,48697,"("],[1,48760,"*1_\n* x*类 X*"],[-1,48760,"例1\n\n设 x是类 X的"],[1,48782,"*"],[-1,48783,"x"],[1,48802,"*"],[-1,48803,"可"],[1,48808,"*"],[-1,48809,"x"],[1,48841,"*"],[-1,48841,"\n"],[1,49217,"_/_3_"],[-1,49217,"//例3用"],[1,49226,"_"],[-1,49226,"运"],[1,49234,"_员函数_"],[-1,49234,"成员函数*"],[1,51838,"|"],[1,51841,"lang"],[-1,51841,"cpp"],[1,51846,"```"],[-1,52385,"};\n\n"],[1,52403,"| \n\n"],[-1,52812,"\n};\n"],[1,52819,"\n\n |"],[1,52844,"总"],[-1,52844,""],[-1,52896,"总"],[1,52898,"\n"],[-1,52903,"操"],[1,52920,"\n"],[-1,52924,"操"],[1,52946,"\n"],[-1,52950,"o"],[1,52970,"\n"],[-1,52975,"f"],[1,52997,"\n"],[-1,53002,"操"],[1,53017,"\n"],[-1,53021,"操"],[1,53041,"\n"],[-1,53045,"="],[1,53073,"\n"],[-1,53077,"+"],[1,53102,"\n"],[-1,53106,"C"]],[53114,53114],[44244,44244]]],[1543581811768,["gjx16@GJXAIOU",[[-1,45439,"\n"]],[45439,45439],[45438,45438]]],[1543581812362,["gjx16@GJXAIOU",[[-1,45438,"\n"]],[45438,45438],[45437,45437]]],[1543581813567,["gjx16@GJXAIOU",[[-1,45437,"\n"]],[45437,45437],[45436,45436]]],[1543581847732,["gjx16@GJXAIOU",[[1,46980,"#### "]],[46980,46980],[46985,46985]]],[1543581858429,["gjx16@GJXAIOU",[[1,47022,"#### "]],[47022,47022],[47027,47027]]],[1543581920039,[null,[[1,44244,"- "],[-1,44268,"=,"],[1,44272,"=,"],[-1,44302,"**"],[1,44304,"）用"],[-1,44308,"**"],[1,44310,"重载"],[-1,44316,"**"],[1,44318,"操作"],[-1,44323,"Ø "],[1,44327,"is"],[-1,44356,"\nØ"],[1,44360,"ci"],[-1,44395,"\nØ"],[1,44399,"运算"],[-1,44432,"\nØ"],[1,44436,"运算"],[-1,44470,"\nØ"],[1,44474,"用友"],[-1,45435,"\n\n"],[1,45437,"\tc"],[-1,45541,"o\n3）"],[1,45547,"3）友元"],[1,45563,"- "],[-1,45565,"- "],[-1,45597,"\nb"],[1,45625,"b）"],[-1,45628,"\nØ"],[1,45634,"在第"],[-1,45667,"\nØ"],[1,45673,"友员"],[-1,45716,"\nØ"],[1,45722,"C+"],[-1,45739,"\n"],[1,45745,"="],[-1,45761,"**"],[1,45763,"）友"],[-1,45774,"***\n\n|` "],[1,45782,"类**\n``"],[1,45787,"#in"],[-1,45804,"\n"],[1,45807,"i"],[-1,45865,"\n"],[1,45870,"b"],[-1,45873," "],[-1,45876," v\t"],[1,45879,"\tvec"],[-1,45883," "],[1,45886,"t"],[-1,45893,"1"],[1,45895,"1"],[-1,45897,"1\n ~v\t"],[1,45903,"\n\n\t~ve"],[-1,45909," "],[-1,45912," in\t"],[1,45916,"\n\tint"],[-1,45930," "],[1,45933,"t"],[-1,45935," ) \n fr\t"],[1,45943,");\n\n\tfri"],[-1,45970," "],[1,45973,"t"],[-1,45986," "],[1,45989,"v"],[-1,45996," ) \n fr\t"],[1,46004,");\n\n\tfri"],[-1,46031," "],[1,46034,"t"],[-1,46056," ) "],[1,46059,");\n"],[-1,46067," : "],[1,46073,"int"],[-1,46077," "],[-1,46080," in\t"],[1,46084,"\n\tint"],[-1,46088," "],[1,46090,"\n"],[-1,46110," "],[1,46113,"t"],[-1,46118," "],[1,46123,"\tif"],[-1,46124,"i\t"],[-1,46150," "],[-1,46153," {"],[1,46160,"cou"],[-1,46205," "],[1,46208,"a"],[-1,46214," "],[-1,46217," }"],[1,46224,"v ="],[-1,46233," "],[-1,46236,"e ]  "],[1,46241,"ze]; l"],[-1,46250," "],[1,46254,"\n"],[-1,46275,"\n"],[-1,46278," d\t"],[1,46281,"\tdel"],[-1,46288," "],[-1,46291," le\t"],[1,46295,"\n\tlen"],[-1,46299," "],[1,46303,"\n"],[-1,46328," "],[1,46331,"t"],[-1,46333," )  \n i\t i  ="],[1,46346,")\n{\n\tif (i >= "],[-1,46349," "],[-1,46359," "],[1,46362,"r"],[-1,46370," i  \n co\t"],[1,46379,"i];\n\n\tcou"],[-1,46426," "],[1,46429,"a"],[-1,46435," "],[1,46440,"\n"],[-1,46463," "],[1,46466,"t"],[-1,46493," "],[-1,46498," f\t"],[1,46501,"\tfor "],[-1,46504," "],[-1,46512," "],[1,46515,"i"],[-1,46525," "],[-1,46528," "],[1,46529,"i"],[-1,46533," o"],[1,46537,"out"],[-1,46548," i  "],[1,46552,"i] <"],[-1,46557," "],[-1,46560," ou\t"],[1,46564,"\n\tout"],[-1,46575," "],[-1,46578," r"],[1,46581,"ret"],[-1,46591," "],[1,46595,"\n"],[-1,46619," "],[1,46622,"t"],[-1,46648," "],[-1,46653," f\t( i n"],[1,46661,"\tfor (int"],[-1,46667," "],[1,46670,"i"],[-1,46680," "],[-1,46683," "],[1,46684,"i"],[-1,46688," i"],[1,46692,"inp"],[-1,46702," i  \n re\t"],[1,46711,"i];\n\n\tret"],[-1,46720," "],[1,46724,"\n"],[-1,46737,"\n"],[-1,46740," i"],[1,46743,"int"],[-1,46745," "],[-1,46748," c"],[1,46751,"cou"],[-1,46790," "],[-1,46793," c"],[1,46796,"cin"],[-1,46801," "],[-1,46804," v"],[1,46807,"vec"],[-1,46813," k  \n c\t"],[1,46821,"k);\n\tcou"],[-1,46862," "],[-1,46865," c"],[1,46868,"cin"],[-1,46873," "],[-1,46876," c"],[1,46879,"cou"],[-1,46921," "],[-1,46924," c"],[1,46927,"cou"],[-1,46933," "],[-1,46936," s"],[1,46939,"sys"],[-1,46953,"\n"],[-1,46956," |"],[1,46962,"\n\n#"],[-1,46977,"**1"],[-1,46987,"*."],[1,46989,"1.运算符"],[-1,47019,"**2"],[-1,47029,"*."],[1,47031,"2.重载赋"],[-1,47035,"*"],[1,47036,"="],[-1,47040,"Ø 赋"],[1,47045,"赋值运"],[-1,47059,"\nØ "],[1,47064,"ope"],[-1,47081,"\nØ "],[1,47086,"重"],[-1,47094,"\n"],[-1,47097,"型_*名_"],[1,47102,"类型&类名:"],[-1,47121,"*"],[1,47124,"类"],[-1,47125,"_"],[1,47127,"&"],[-1,47131,"*"],[1,47132,"\n"],[-1,47153,"\n"],[1,47177,"\n\n"],[-1,47178,"\n"],[-1,47184,"\n"],[1,47185," "],[-1,47197,"\n"],[1,47198," "],[-1,47207,"\n"],[1,47208," "],[-1,47219,"\n"],[-1,48410,"|\n"],[1,48412,"\n\n*"],[-1,48414,"*"],[1,48416,"重"],[-1,48424,"*"],[1,48425,"["],[-1,48428,"\n"],[1,48446,"重"],[-1,48456,"\n"],[1,48461,"运"],[-1,48478,"\n"],[1,48484,"["],[-1,48512,"*"],[1,48515,"重"],[-1,48524,"_"],[1,48530,"["],[-1,48546,"\n"],[1,48550,"重"],[-1,48553," "],[-1,48556,"_返回值型_*_"],[1,48564," 返回值类型 类 "],[-1,48580,"_型_"],[1,48583,"类型 "],[-1,48587,"\n"],[1,48590,"设"],[-1,48608,"\n\n *`   *"],[1,48617," `x[y]"],[1,48619,"可"],[-1,48623,"\n"],[-1,48627,"  "],[1,48629,"x.o"],[-1,48636,"     *"],[1,48642,"[](y)"],[-1,48693,"*\n*.4*"],[1,48699,"\n\n**4.重"],[-1,48705,"*"],[1,48706,"("],[-1,48768,"*1_\n* x*类 X*"],[1,48780,"例1\n\n设 x是类 X的"],[-1,48790,"*"],[1,48792,"x"],[-1,48810,"*"],[1,48812,"可"],[-1,48816,"*"],[1,48818,"x"],[-1,48849,"*"],[1,48850,"\n"],[-1,49225,"_/_3_"],[1,49230,"//例3用"],[-1,49234,"_"],[1,49235,"运"],[-1,49242,"_员函数_"],[1,49247,"成员函数*"],[-1,51846,"|"],[-1,51850,"lang"],[1,51854,"cpp"],[-1,51856,"```"],[1,52398,"};\n\n"],[-1,52412,"| \n\n"],[1,52825,"\n};\n"],[-1,52828,"\n\n |"],[-1,52857,"总"],[1,52858,""],[1,52910,"总"],[-1,52911,"\n"],[1,52917,"操"],[-1,52933,"\n"],[1,52938,"操"],[-1,52959,"\n"],[1,52964,"o"],[-1,52983,"\n"],[1,52989,"f"],[-1,53010,"\n"],[1,53016,"操"],[-1,53030,"\n"],[1,53035,"操"],[-1,53054,"\n"],[1,53059,"="],[-1,53086,"\n"],[1,53091,"+"],[-1,53115,"\n"],[1,53120,"C"]],[44244,44244],[53121,53121]]],[1543581920039,[null,[[-1,44244,"- "],[1,44270,"=,"],[-1,44272,"=,"],[1,44304,"**"],[-1,44304,"）用"],[1,44310,"**"],[-1,44310,"重载"],[1,44318,"**"],[-1,44318,"操作"],[1,44325,"Ø "],[-1,44327,"is"],[1,44358,"\nØ"],[-1,44360,"ci"],[1,44397,"\nØ"],[-1,44399,"运算"],[1,44434,"\nØ"],[-1,44436,"运算"],[1,44472,"\nØ"],[-1,44474,"用友"],[1,45437,"\n\n"],[-1,45437,"\tc"],[1,45543,"o\n3）"],[-1,45545,"3）友元"],[-1,45565,"- "],[1,45569,"- "],[1,45599,"\nb"],[-1,45625,"b）"],[1,45630,"\nØ"],[-1,45634,"在第"],[1,45669,"\nØ"],[-1,45673,"友员"],[1,45718,"\nØ"],[-1,45722,"C+"],[1,45741,"\n"],[-1,45746,"="],[1,45763,"**"],[-1,45763,"）友"],[1,45776,"***\n\n|` "],[-1,45776,"类**\n``"],[-1,45787,"#in"],[1,45807,"\n"],[-1,45809,"i"],[1,45868,"\n"],[-1,45872,"b"],[1,45876," "],[1,45878," v\t"],[-1,45878,"\tvec"],[1,45886," "],[-1,45888,"t"],[1,45896,"1"],[-1,45897,"1"],[1,45900,"1\n ~v\t"],[-1,45900,"\n\n\t~ve"],[1,45912," "],[1,45914," in\t"],[-1,45914,"\n\tint"],[1,45933," "],[-1,45935,"t"],[1,45938," ) \n fr\t"],[-1,45938,");\n\n\tfri"],[1,45973," "],[-1,45975,"t"],[1,45989," "],[-1,45991,"v"],[1,45999," ) \n fr\t"],[-1,45999,");\n\n\tfri"],[1,46034," "],[-1,46036,"t"],[1,46059," ) "],[-1,46059,");\n"],[1,46070," : "],[-1,46073,"int"],[1,46080," "],[1,46082," in\t"],[-1,46082,"\n\tint"],[1,46091," "],[-1,46092,"\n"],[1,46113," "],[-1,46115,"t"],[1,46121," "],[-1,46125,"\tif"],[1,46129,"i\t"],[1,46153," "],[1,46155," {"],[-1,46160,"cou"],[1,46208," "],[-1,46210,"a"],[1,46217," "],[1,46219," }"],[-1,46224,"v ="],[1,46236," "],[1,46238,"e ]  "],[-1,46238,"ze]; l"],[1,46253," "],[-1,46256,"\n"],[1,46278,"\n"],[1,46280," d\t"],[-1,46280,"\tdel"],[1,46291," "],[1,46293," le\t"],[-1,46293,"\n\tlen"],[1,46302," "],[-1,46305,"\n"],[1,46331," "],[-1,46333,"t"],[1,46336," )  \n i\t i  ="],[-1,46336,")\n{\n\tif (i >= "],[1,46353," "],[1,46362," "],[-1,46364,"r"],[1,46373," i  \n co\t"],[-1,46373,"i];\n\n\tcou"],[1,46429," "],[-1,46431,"a"],[1,46438," "],[-1,46442,"\n"],[1,46466," "],[-1,46468,"t"],[1,46496," "],[1,46500," f\t"],[-1,46500,"\tfor "],[1,46508," "],[1,46515," "],[-1,46517,"i"],[1,46528," "],[1,46530," "],[-1,46530,"i"],[1,46535," o"],[-1,46537,"out"],[1,46551," i  "],[-1,46551,"i] <"],[1,46560," "],[1,46562," ou\t"],[-1,46562,"\n\tout"],[1,46578," "],[1,46580," r"],[-1,46581,"ret"],[1,46594," "],[-1,46597,"\n"],[1,46622," "],[-1,46624,"t"],[1,46651," "],[1,46655," f\t( i n"],[-1,46655,"\tfor (int"],[1,46670," "],[-1,46672,"i"],[1,46683," "],[1,46685," "],[-1,46685,"i"],[1,46690," i"],[-1,46692,"inp"],[1,46705," i  \n re\t"],[-1,46705,"i];\n\n\tret"],[1,46723," "],[-1,46726,"\n"],[1,46740,"\n"],[1,46742," i"],[-1,46743,"int"],[1,46748," "],[1,46750," c"],[-1,46751,"cou"],[1,46793," "],[1,46795," c"],[-1,46796,"cin"],[1,46804," "],[1,46806," v"],[-1,46807,"vec"],[1,46816," k  \n c\t"],[-1,46816,"k);\n\tcou"],[1,46865," "],[1,46867," c"],[-1,46868,"cin"],[1,46876," "],[1,46878," c"],[-1,46879,"cou"],[1,46924," "],[1,46926," c"],[-1,46927,"cou"],[1,46936," "],[1,46938," s"],[-1,46939,"sys"],[1,46956,"\n"],[1,46958," |"],[-1,46962,"\n\n#"],[1,46980,"**1"],[1,46987,"*."],[-1,46987,"1.运算符"],[1,47022,"**2"],[1,47029,"*."],[-1,47029,"2.重载赋"],[1,47038,"*"],[-1,47038,"="],[1,47043,"Ø 赋"],[-1,47045,"赋值运"],[1,47062,"\nØ "],[-1,47064,"ope"],[1,47084,"\nØ "],[-1,47086,"重"],[1,47095,"\n"],[1,47097,"型_*名_"],[-1,47097,"类型&类名:"],[1,47122,"*"],[-1,47124,"类"],[1,47126,"_"],[-1,47127,"&"],[1,47132,"*"],[-1,47132,"\n"],[1,47154,"\n"],[-1,47177,"\n\n"],[1,47180,"\n"],[1,47185,"\n"],[-1,47185," "],[1,47198,"\n"],[-1,47198," "],[1,47208,"\n"],[-1,47208," "],[1,47220,"\n"],[1,48410,"|\n"],[-1,48410,"\n\n*"],[1,48415,"*"],[-1,48416,"重"],[1,48425,"*"],[-1,48425,"["],[1,48429,"\n"],[-1,48446,"重"],[1,48457,"\n"],[-1,48461,"运"],[1,48479,"\n"],[-1,48484,"["],[1,48513,"*"],[-1,48515,"重"],[1,48525,"_"],[-1,48530,"["],[1,48547,"\n"],[-1,48550,"重"],[1,48554," "],[1,48556,"_返回值型_*_"],[-1,48556," 返回值类型 类 "],[1,48581,"_型_"],[-1,48581,"类型 "],[1,48588,"\n"],[-1,48590,"设"],[1,48609,"\n\n *`   *"],[-1,48609," `x[y]"],[-1,48617,"可"],[1,48622,"\n"],[1,48625,"  "],[-1,48625,"x.o"],[1,48635,"     *"],[-1,48635,"[](y)"],[1,48691,"*\n*.4*"],[-1,48691,"\n\n**4.重"],[1,48704,"*"],[-1,48704,"("],[1,48767,"*1_\n* x*类 X*"],[-1,48767,"例1\n\n设 x是类 X的"],[1,48789,"*"],[-1,48790,"x"],[1,48809,"*"],[-1,48810,"可"],[1,48815,"*"],[-1,48816,"x"],[1,48848,"*"],[-1,48848,"\n"],[1,49224,"_/_3_"],[-1,49224,"//例3用"],[1,49233,"_"],[-1,49233,"运"],[1,49241,"_员函数_"],[-1,49241,"成员函数*"],[1,51845,"|"],[1,51848,"lang"],[-1,51848,"cpp"],[1,51853,"```"],[-1,52392,"};\n\n"],[1,52410,"| \n\n"],[-1,52819,"\n};\n"],[1,52826,"\n\n |"],[1,52851,"总"],[-1,52851,""],[-1,52903,"总"],[1,52905,"\n"],[-1,52910,"操"],[1,52927,"\n"],[-1,52931,"操"],[1,52953,"\n"],[-1,52957,"o"],[1,52977,"\n"],[-1,52982,"f"],[1,53004,"\n"],[-1,53009,"操"],[1,53024,"\n"],[-1,53028,"操"],[1,53048,"\n"],[-1,53052,"="],[1,53080,"\n"],[-1,53084,"+"],[1,53109,"\n"],[-1,53113,"C"]],[53121,53121],[44244,44244]]],[1543581866454,["gjx16@GJXAIOU",[[-1,47153,"\n"]],[47153,47153],[47152,47152]]],[1543581873055,["gjx16@GJXAIOU",[[-1,47239,"\n"]],[47239,47239],[47238,47238]]],[1543581880810,["gjx16@GJXAIOU",[[-1,47187,"//"]],[47189,47189],[47187,47187]]],[1543581896719,["gjx16@GJXAIOU",[[1,48408,"#### "]],[48408,48408],[48413,48413]]],[1543581909084,["gjx16@GJXAIOU",[[1,48694,"#### "]],[48694,48694],[48699,48699]]],[1543581980044,[null,[[1,44244,"- "],[-1,44268,"=,"],[1,44272,"=,"],[-1,44302,"**"],[1,44304,"）用"],[-1,44308,"**"],[1,44310,"重载"],[-1,44316,"**"],[1,44318,"操作"],[-1,44323,"Ø "],[1,44327,"is"],[-1,44356,"\nØ"],[1,44360,"ci"],[-1,44395,"\nØ"],[1,44399,"运算"],[-1,44432,"\nØ"],[1,44436,"运算"],[-1,44470,"\nØ"],[1,44474,"用友"],[-1,45435,"\n\n"],[1,45437,"\tc"],[-1,45541,"o\n3）"],[1,45547,"3）友元"],[1,45563,"- "],[-1,45565,"- "],[-1,45597,"\nb"],[1,45625,"b）"],[-1,45628,"\nØ"],[1,45634,"在第"],[-1,45667,"\nØ"],[1,45673,"友员"],[-1,45716,"\nØ"],[1,45722,"C+"],[-1,45739,"\n"],[1,45745,"="],[-1,45761,"**"],[1,45763,"）友"],[-1,45774,"***\n\n|` "],[1,45782,"类**\n``"],[1,45787,"#in"],[-1,45804,"\n"],[1,45807,"i"],[-1,45865,"\n"],[1,45870,"b"],[-1,45873," "],[-1,45876," v\t"],[1,45879,"\tvec"],[-1,45883," "],[1,45886,"t"],[-1,45893,"1"],[1,45895,"1"],[-1,45897,"1\n ~v\t"],[1,45903,"\n\n\t~ve"],[-1,45909," "],[-1,45912," in\t"],[1,45916,"\n\tint"],[-1,45930," "],[1,45933,"t"],[-1,45935," ) \n fr\t"],[1,45943,");\n\n\tfri"],[-1,45970," "],[1,45973,"t"],[-1,45986," "],[1,45989,"v"],[-1,45996," ) \n fr\t"],[1,46004,");\n\n\tfri"],[-1,46031," "],[1,46034,"t"],[-1,46056," ) "],[1,46059,");\n"],[-1,46067," : "],[1,46073,"int"],[-1,46077," "],[-1,46080," in\t"],[1,46084,"\n\tint"],[-1,46088," "],[1,46090,"\n"],[-1,46110," "],[1,46113,"t"],[-1,46118," "],[1,46123,"\tif"],[-1,46124,"i\t"],[-1,46150," "],[-1,46153," {"],[1,46160,"cou"],[-1,46205," "],[1,46208,"a"],[-1,46214," "],[-1,46217," }"],[1,46224,"v ="],[-1,46233," "],[-1,46236,"e ]  "],[1,46241,"ze]; l"],[-1,46250," "],[1,46254,"\n"],[-1,46275,"\n"],[-1,46278," d"],[1,46281,"del"],[-1,46288," "],[-1,46291," le\t"],[1,46295,"\n\tlen"],[-1,46299," "],[1,46303,"\n"],[-1,46328," "],[1,46331,"t"],[-1,46333," )  \n i\t i  ="],[1,46346,")\n{\n\tif (i >= "],[-1,46349," "],[-1,46359," "],[1,46362,"r"],[-1,46370," i  \n co\t"],[1,46379,"i];\n\n\tcou"],[-1,46426," "],[1,46429,"a"],[-1,46435," "],[1,46440,"\n"],[-1,46463," "],[1,46466,"t"],[-1,46493," "],[-1,46498," f"],[1,46501,"for "],[-1,46504," "],[-1,46512," "],[1,46515,"i"],[-1,46525," "],[-1,46528," "],[1,46529,"i"],[-1,46533," o"],[1,46537,"out"],[-1,46548," i "],[1,46551,"i]"],[1,46553,"<"],[-1,46557," "],[-1,46560," ou\t"],[1,46564,"\n\tout"],[-1,46575," "],[-1,46578," r\t"],[1,46581,"\tret"],[-1,46591," "],[1,46595,"\n"],[-1,46619," "],[1,46622,"t"],[-1,46648," "],[-1,46653," f\t( i n"],[1,46661,"\tfor (int"],[-1,46667," "],[1,46670,"i"],[-1,46680," "],[-1,46683," "],[1,46684,"i"],[-1,46688," i"],[1,46692,"inp"],[-1,46702," i  \n re\t"],[1,46711,"i];\n\n\tret"],[-1,46720," "],[1,46725,"\n"],[-1,46737,"\n"],[-1,46740," i\t"],[1,46743,"\tint"],[-1,46745," "],[-1,46748," c\t"],[1,46751,"\tcou"],[-1,46790," "],[-1,46793," c\t"],[1,46796,"\tcin"],[-1,46801," "],[-1,46804," v\t"],[1,46807,"\tvec"],[-1,46813," k  \n c\t"],[1,46821,"k);\n\tcou"],[-1,46862," "],[-1,46865," c\t"],[1,46868,"\tcin"],[-1,46873," "],[-1,46876," c\t"],[1,46879,"\tcou"],[-1,46921," "],[-1,46924," c\t"],[1,46927,"\tcou"],[-1,46933," "],[-1,46936," s\t"],[1,46939,"\tsys"],[-1,46952,"\n"],[-1,46956," |"],[1,46962,"\n\n#"],[-1,46977,"**1"],[-1,46987,"*."],[1,46989,"1.运算符"],[-1,47019,"**2"],[-1,47029,"*."],[1,47031,"2.重载赋"],[-1,47035,"*"],[1,47036,"="],[-1,47040,"Ø 赋* "],[1,47045,"* 赋值运"],[-1,47059,"\nØ "],[1,47064,"ope"],[-1,47081,"\nØ "],[1,47086,"重"],[-1,47094,"\n"],[-1,47097,"型_*名_"],[1,47102,"类型&类名:"],[-1,47121,"*"],[1,47124,"类"],[-1,47125,"_"],[1,47127,"&"],[-1,47131,"*"],[1,47132,"\n"],[-1,47151,"\n"],[1,47176,"\n\n"],[-1,47177,"\n"],[-1,47183,"\n1 /"],[1,47187," 1 先"],[-1,47194,"\n"],[1,47195," "],[-1,47204,"\n"],[1,47205," "],[-1,47216,"\n"],[-1,48406,"|"],[1,48407,"\n"],[-1,48414,"3"],[1,48416,"3"],[1,48417,"重"],[-1,48425,"*"],[1,48426,"["],[-1,48429,"\n"],[1,48447,"重"],[-1,48457,"\n"],[1,48462,"运"],[-1,48479,"\n"],[1,48485,"["],[-1,48513,"*"],[1,48516,"重"],[-1,48525,"_"],[1,48531,"["],[-1,48547,"\n"],[1,48551,"重"],[-1,48554," "],[-1,48557,"_返回值型_*_"],[1,48565," 返回值类型 类 "],[-1,48581,"_型_"],[1,48584,"类型 "],[-1,48588,"\n"],[1,48591,"设"],[-1,48609,"\n\n *`   *"],[1,48618," `x[y]"],[1,48620,"可"],[-1,48624,"\n"],[-1,48628,"  "],[1,48630,"x.o"],[-1,48637,"     *"],[1,48643,"[](y)"],[1,48694,"\n\n"],[-1,48700,"\n*.4*"],[1,48705,"*4.重"],[-1,48711,"*"],[1,48712,"("],[-1,48774,"*1_\n* x*类 X*"],[1,48786,"例1\n\n设 x是类 X的"],[-1,48796,"*"],[1,48798,"x"],[-1,48816,"*"],[1,48818,"可"],[-1,48822,"*"],[1,48824,"x"],[-1,48855,"*"],[1,48856,"\n"],[-1,49231,"_/_3_"],[1,49236,"//例3用"],[-1,49240,"_"],[1,49241,"运"],[-1,49248,"_员函数_"],[1,49253,"成员函数*"],[-1,51852,"|"],[-1,51856,"lang"],[1,51860,"cpp"],[-1,51862,"```"],[1,52404,"};\n\n"],[-1,52418,"| \n\n"],[1,52831,"\n};\n"],[-1,52834,"\n\n |"],[-1,52863,"总"],[1,52864,""],[1,52916,"总"],[-1,52917,"\n"],[1,52923,"操"],[-1,52939,"\n"],[1,52944,"操"],[-1,52965,"\n"],[1,52970,"o"],[-1,52989,"\n"],[1,52995,"f"],[-1,53016,"\n"],[1,53022,"操"],[-1,53036,"\n"],[1,53041,"操"],[-1,53060,"\n"],[1,53065,"="],[-1,53092,"\n"],[1,53097,"+"],[-1,53121,"\n"],[1,53126,"C"]],[44244,44244],[53127,53127]]],[1543581980044,[null,[[-1,44244,"- "],[1,44270,"=,"],[-1,44272,"=,"],[1,44304,"**"],[-1,44304,"）用"],[1,44310,"**"],[-1,44310,"重载"],[1,44318,"**"],[-1,44318,"操作"],[1,44325,"Ø "],[-1,44327,"is"],[1,44358,"\nØ"],[-1,44360,"ci"],[1,44397,"\nØ"],[-1,44399,"运算"],[1,44434,"\nØ"],[-1,44436,"运算"],[1,44472,"\nØ"],[-1,44474,"用友"],[1,45437,"\n\n"],[-1,45437,"\tc"],[1,45543,"o\n3）"],[-1,45545,"3）友元"],[-1,45565,"- "],[1,45569,"- "],[1,45599,"\nb"],[-1,45625,"b）"],[1,45630,"\nØ"],[-1,45634,"在第"],[1,45669,"\nØ"],[-1,45673,"友员"],[1,45718,"\nØ"],[-1,45722,"C+"],[1,45741,"\n"],[-1,45746,"="],[1,45763,"**"],[-1,45763,"）友"],[1,45776,"***\n\n|` "],[-1,45776,"类**\n``"],[-1,45787,"#in"],[1,45807,"\n"],[-1,45809,"i"],[1,45868,"\n"],[-1,45872,"b"],[1,45876," "],[1,45878," v\t"],[-1,45878,"\tvec"],[1,45886," "],[-1,45888,"t"],[1,45896,"1"],[-1,45897,"1"],[1,45900,"1\n ~v\t"],[-1,45900,"\n\n\t~ve"],[1,45912," "],[1,45914," in\t"],[-1,45914,"\n\tint"],[1,45933," "],[-1,45935,"t"],[1,45938," ) \n fr\t"],[-1,45938,");\n\n\tfri"],[1,45973," "],[-1,45975,"t"],[1,45989," "],[-1,45991,"v"],[1,45999," ) \n fr\t"],[-1,45999,");\n\n\tfri"],[1,46034," "],[-1,46036,"t"],[1,46059," ) "],[-1,46059,");\n"],[1,46070," : "],[-1,46073,"int"],[1,46080," "],[1,46082," in\t"],[-1,46082,"\n\tint"],[1,46091," "],[-1,46092,"\n"],[1,46113," "],[-1,46115,"t"],[1,46121," "],[-1,46125,"\tif"],[1,46129,"i\t"],[1,46153," "],[1,46155," {"],[-1,46160,"cou"],[1,46208," "],[-1,46210,"a"],[1,46217," "],[1,46219," }"],[-1,46224,"v ="],[1,46236," "],[1,46238,"e ]  "],[-1,46238,"ze]; l"],[1,46253," "],[-1,46256,"\n"],[1,46278,"\n"],[1,46280," d"],[-1,46281,"del"],[1,46291," "],[1,46293," le\t"],[-1,46293,"\n\tlen"],[1,46302," "],[-1,46305,"\n"],[1,46331," "],[-1,46333,"t"],[1,46336," )  \n i\t i  ="],[-1,46336,")\n{\n\tif (i >= "],[1,46353," "],[1,46362," "],[-1,46364,"r"],[1,46373," i  \n co\t"],[-1,46373,"i];\n\n\tcou"],[1,46429," "],[-1,46431,"a"],[1,46438," "],[-1,46442,"\n"],[1,46466," "],[-1,46468,"t"],[1,46496," "],[1,46500," f"],[-1,46501,"for "],[1,46508," "],[1,46515," "],[-1,46517,"i"],[1,46528," "],[1,46530," "],[-1,46530,"i"],[1,46535," o"],[-1,46537,"out"],[1,46551," i "],[-1,46551,"i]"],[-1,46555,"<"],[1,46560," "],[1,46562," ou\t"],[-1,46562,"\n\tout"],[1,46578," "],[1,46580," r\t"],[-1,46580,"\tret"],[1,46594," "],[-1,46597,"\n"],[1,46622," "],[-1,46624,"t"],[1,46651," "],[1,46655," f\t( i n"],[-1,46655,"\tfor (int"],[1,46670," "],[-1,46672,"i"],[1,46683," "],[1,46685," "],[-1,46685,"i"],[1,46690," i"],[-1,46692,"inp"],[1,46705," i  \n re\t"],[-1,46705,"i];\n\n\tret"],[1,46723," "],[-1,46727,"\n"],[1,46740,"\n"],[1,46742," i\t"],[-1,46742,"\tint"],[1,46748," "],[1,46750," c\t"],[-1,46750,"\tcou"],[1,46793," "],[1,46795," c\t"],[-1,46795,"\tcin"],[1,46804," "],[1,46806," v\t"],[-1,46806,"\tvec"],[1,46816," k  \n c\t"],[-1,46816,"k);\n\tcou"],[1,46865," "],[1,46867," c\t"],[-1,46867,"\tcin"],[1,46876," "],[1,46878," c\t"],[-1,46878,"\tcou"],[1,46924," "],[1,46926," c\t"],[-1,46926,"\tcou"],[1,46936," "],[1,46938," s\t"],[-1,46938,"\tsys"],[1,46955,"\n"],[1,46958," |"],[-1,46962,"\n\n#"],[1,46980,"**1"],[1,46987,"*."],[-1,46987,"1.运算符"],[1,47022,"**2"],[1,47029,"*."],[-1,47029,"2.重载赋"],[1,47038,"*"],[-1,47038,"="],[1,47043,"Ø 赋* "],[-1,47043,"* 赋值运"],[1,47062,"\nØ "],[-1,47064,"ope"],[1,47084,"\nØ "],[-1,47086,"重"],[1,47095,"\n"],[1,47097,"型_*名_"],[-1,47097,"类型&类名:"],[1,47122,"*"],[-1,47124,"类"],[1,47126,"_"],[-1,47127,"&"],[1,47132,"*"],[-1,47132,"\n"],[1,47152,"\n"],[-1,47176,"\n\n"],[1,47179,"\n"],[1,47184,"\n1 /"],[-1,47184," 1 先"],[1,47195,"\n"],[-1,47195," "],[1,47205,"\n"],[-1,47205," "],[1,47217,"\n"],[1,48406,"|"],[-1,48406,"\n"],[1,48414,"3"],[-1,48415,"3"],[-1,48417,"重"],[1,48426,"*"],[-1,48426,"["],[1,48430,"\n"],[-1,48447,"重"],[1,48458,"\n"],[-1,48462,"运"],[1,48480,"\n"],[-1,48485,"["],[1,48514,"*"],[-1,48516,"重"],[1,48526,"_"],[-1,48531,"["],[1,48548,"\n"],[-1,48551,"重"],[1,48555," "],[1,48557,"_返回值型_*_"],[-1,48557," 返回值类型 类 "],[1,48582,"_型_"],[-1,48582,"类型 "],[1,48589,"\n"],[-1,48591,"设"],[1,48610,"\n\n *`   *"],[-1,48610," `x[y]"],[-1,48618,"可"],[1,48623,"\n"],[1,48626,"  "],[-1,48626,"x.o"],[1,48636,"     *"],[-1,48636,"[](y)"],[-1,48692,"\n\n"],[1,48700,"\n*.4*"],[-1,48700,"*4.重"],[1,48710,"*"],[-1,48710,"("],[1,48773,"*1_\n* x*类 X*"],[-1,48773,"例1\n\n设 x是类 X的"],[1,48795,"*"],[-1,48796,"x"],[1,48815,"*"],[-1,48816,"可"],[1,48821,"*"],[-1,48822,"x"],[1,48854,"*"],[-1,48854,"\n"],[1,49230,"_/_3_"],[-1,49230,"//例3用"],[1,49239,"_"],[-1,49239,"运"],[1,49247,"_员函数_"],[-1,49247,"成员函数*"],[1,51851,"|"],[1,51854,"lang"],[-1,51854,"cpp"],[1,51859,"```"],[-1,52398,"};\n\n"],[1,52416,"| \n\n"],[-1,52825,"\n};\n"],[1,52832,"\n\n |"],[1,52857,"总"],[-1,52857,""],[-1,52909,"总"],[1,52911,"\n"],[-1,52916,"操"],[1,52933,"\n"],[-1,52937,"操"],[1,52959,"\n"],[-1,52963,"o"],[1,52983,"\n"],[-1,52988,"f"],[1,53010,"\n"],[-1,53015,"操"],[1,53030,"\n"],[-1,53034,"操"],[1,53054,"\n"],[-1,53058,"="],[1,53086,"\n"],[-1,53090,"+"],[1,53115,"\n"],[-1,53119,"C"]],[53127,53127],[44244,44244]]],[1543581924264,["gjx16@GJXAIOU",[[-1,48736,"_"]],[48737,48737],[48736,48736]]],[1543581925926,["gjx16@GJXAIOU",[[-1,48739," _"]],[48741,48741],[48739,48739]]],[1543581928191,["gjx16@GJXAIOU",[[-1,48741," :"]],[48743,48743],[48741,48741]]],[1543581930780,["gjx16@GJXAIOU",[[1,48742,":"]],[48741,48741],[48742,48742]]],[1543581932959,["gjx16@GJXAIOU",[[-1,48740,"_"]],[48741,48741],[48740,48740]]],[1543581934832,["gjx16@GJXAIOU",[[-1,48738,"_"]],[48739,48739],[48738,48738]]],[1543581938403,["gjx16@GJXAIOU",[[1,48738," "]],[48738,48738],[48739,48739]]],[1543581940336,["gjx16@GJXAIOU",[[1,48747," "]],[48747,48747],[48748,48748]]],[1543581943487,["gjx16@GJXAIOU",[[-1,48747," "]],[48748,48748],[48747,48747]]],[1543581947825,["gjx16@GJXAIOU",[[-1,48756,"_"]],[48757,48757],[48756,48756]]],[1543581951726,["gjx16@GJXAIOU",[[-1,48760,"_"]],[48761,48761],[48760,48760]]],[1543582100047,[null,[[1,44244,"- "],[-1,44268,"=,"],[1,44272,"=,"],[-1,44302,"**"],[1,44304,"）用"],[-1,44308,"**"],[1,44310,"重载"],[-1,44316,"**"],[1,44318,"操作"],[-1,44323,"Ø "],[1,44327,"is"],[-1,44356,"\nØ"],[1,44360,"ci"],[-1,44395,"\nØ"],[1,44399,"运算"],[-1,44432,"\nØ"],[1,44436,"运算"],[-1,44470,"\nØ"],[1,44474,"用友"],[-1,45435,"\n\n"],[1,45437,"\tc"],[-1,45541,"o\n3）"],[1,45547,"3）友元"],[1,45563,"- "],[-1,45565,"- "],[-1,45597,"\nb"],[1,45625,"b）"],[-1,45628,"\nØ"],[1,45634,"在第"],[-1,45667,"\nØ"],[1,45673,"友员"],[-1,45716,"\nØ"],[1,45722,"C+"],[-1,45739,"\n"],[1,45745,"="],[-1,45761,"**"],[1,45763,"）友"],[-1,45774,"***\n\n|` "],[1,45782,"类**\n``"],[1,45787,"#in"],[-1,45804,"\n"],[1,45807,"i"],[-1,45865,"\n"],[1,45870,"b"],[-1,45873," "],[-1,45876," v\t"],[1,45879,"\tvec"],[-1,45883," "],[1,45886,"t"],[-1,45893,"1"],[1,45895,"1"],[-1,45897,"1\n ~v\t"],[1,45903,"\n\n\t~ve"],[-1,45909," "],[-1,45912," in\t"],[1,45916,"\n\tint"],[-1,45930," "],[1,45933,"t"],[-1,45935," ) \n fr\t"],[1,45943,");\n\n\tfri"],[-1,45970," "],[1,45973,"t"],[-1,45986," "],[1,45989,"v"],[-1,45996," ) \n fr\t"],[1,46004,");\n\n\tfri"],[-1,46031," "],[1,46034,"t"],[-1,46056," ) "],[1,46059,");\n"],[-1,46067," : "],[1,46073,"int"],[-1,46077," "],[-1,46080," in\t"],[1,46084,"\n\tint"],[-1,46088," "],[1,46090,"\n"],[-1,46110," "],[1,46113,"t"],[-1,46118," "],[1,46123,"\tif"],[-1,46124,"i\t"],[-1,46150," "],[-1,46153," {"],[1,46160,"cou"],[-1,46205," "],[1,46208,"a"],[-1,46214," "],[-1,46217," }"],[1,46224,"v ="],[-1,46233," "],[-1,46236,"e ]  "],[1,46241,"ze]; l"],[-1,46250," "],[1,46254,"\n"],[-1,46275,"\n"],[-1,46278," d"],[1,46281,"del"],[-1,46288," "],[-1,46291," le\t"],[1,46295,"\n\tlen"],[-1,46299," "],[1,46303,"\n"],[-1,46328," "],[1,46331,"t"],[-1,46333," )  \n i\t i  ="],[1,46346,")\n{\n\tif (i >= "],[-1,46349," "],[-1,46359," "],[1,46362,"r"],[-1,46370," i  \n co\t"],[1,46379,"i];\n\n\tcou"],[-1,46426," "],[1,46429,"a"],[-1,46435," "],[1,46440,"\n"],[-1,46463," "],[1,46466,"t"],[-1,46493," "],[-1,46498," f"],[1,46501,"for "],[-1,46504," "],[-1,46512," "],[1,46515,"i"],[-1,46525," "],[-1,46528," "],[1,46529,"i"],[-1,46533," o"],[1,46537,"out"],[-1,46548," i "],[1,46551,"i]"],[1,46553,"<"],[-1,46557," "],[-1,46560," ou\t"],[1,46564,"\n\tout"],[-1,46575," "],[-1,46578," r\t"],[1,46581,"\tret"],[-1,46591," "],[1,46595,"\n"],[-1,46619," "],[1,46622,"t"],[-1,46648," "],[-1,46653," f\t( i n"],[1,46661,"\tfor (int"],[-1,46667," "],[1,46670,"i"],[-1,46680," "],[-1,46683," "],[1,46684,"i"],[-1,46688," i"],[1,46692,"inp"],[-1,46702," i  \n re\t"],[1,46711,"i];\n\n\tret"],[-1,46720," "],[1,46725,"\n"],[-1,46737,"\n"],[-1,46740," i\t"],[1,46743,"\tint"],[-1,46745," "],[-1,46748," c\t"],[1,46751,"\tcou"],[-1,46790," "],[-1,46793," c\t"],[1,46796,"\tcin"],[-1,46801," "],[-1,46804," v\t"],[1,46807,"\tvec"],[-1,46813," k  \n c\t"],[1,46821,"k);\n\tcou"],[-1,46862," "],[-1,46865," c\t"],[1,46868,"\tcin"],[-1,46873," "],[-1,46876," c\t"],[1,46879,"\tcou"],[-1,46921," "],[-1,46924," c\t"],[1,46927,"\tcou"],[-1,46933," "],[-1,46936," s\t"],[1,46939,"\tsys"],[-1,46952,"\n"],[-1,46956," |"],[1,46962,"\n\n#"],[-1,46977,"**1"],[-1,46987,"*."],[1,46989,"1.运算符"],[-1,47019,"**2"],[-1,47029,"*."],[1,47031,"2.重载赋"],[-1,47035,"*"],[1,47036,"="],[-1,47040,"Ø 赋* "],[1,47045,"* 赋值运"],[-1,47059,"\nØ "],[1,47064,"ope"],[-1,47081,"\nØ "],[1,47086,"重"],[-1,47094,"\n"],[-1,47097,"型_*名_"],[1,47102,"类型&类名:"],[-1,47121,"*"],[1,47124,"类"],[-1,47125,"_"],[1,47127,"&"],[-1,47131,"*"],[1,47132,"\n"],[-1,47151,"\n"],[1,47176,"\n\n"],[-1,47177,"\n"],[-1,47183,"\n1 /"],[1,47187," 1 先"],[-1,47194,"\n"],[1,47195," "],[-1,47204,"\n"],[1,47205," "],[-1,47216,"\n"],[-1,48406,"|"],[1,48407,"\n"],[-1,48414,"3"],[1,48416,"3"],[1,48417,"重"],[-1,48425,"*"],[1,48426,"["],[-1,48429,"\n"],[1,48447,"重"],[-1,48456,"\n"],[1,48462,"运"],[-1,48480,"\n"],[1,48485,"["],[-1,48513,"*"],[1,48516,"重"],[-1,48525,"_"],[1,48531,"["],[-1,48548,"\n"],[1,48551,"重"],[1,48554,"："],[-1,48555,"："],[-1,48557,"_"],[-1,48561,"型_*_"],[1,48565,"类型 类 "],[-1,48581,"_型_"],[1,48584,"类型 "],[-1,48588,"\n"],[1,48591,"设"],[-1,48609,"\n\n *`   *"],[1,48618," `x[y]"],[1,48620,"可"],[-1,48624,"\n"],[-1,48628,"  "],[1,48630,"x.o"],[-1,48637,"     *"],[1,48643,"[](y)"],[1,48694,"\n\n"],[-1,48700,"\n*.4*"],[1,48705,"*4.重"],[-1,48711,"*"],[1,48712,"("],[-1,48736,"_类 _:"],[1,48741," 类型 类"],[-1,48756,"_表达式_"],[1,48761," 表达式表"],[-1,48767,"*1_\n* x*类 X*"],[1,48779,"例1\n\n设 x是类 X的"],[-1,48789,"*"],[1,48791,"x"],[-1,48809,"*"],[1,48811,"可"],[-1,48815,"*"],[1,48817,"x"],[-1,48848,"*"],[1,48849,"\n"],[-1,49224,"_/_3_"],[1,49229,"//例3用"],[-1,49233,"_"],[1,49234,"运"],[-1,49241,"_员函数_"],[1,49246,"成员函数*"],[-1,51845,"|"],[-1,51849,"lang"],[1,51853,"cpp"],[-1,51855,"```"],[1,52397,"};\n\n"],[-1,52411,"| \n\n"],[1,52824,"\n};\n"],[-1,52827,"\n\n |"],[-1,52856,"总"],[1,52857,""],[1,52909,"总"],[-1,52910,"\n"],[1,52916,"操"],[-1,52932,"\n"],[1,52937,"操"],[-1,52958,"\n"],[1,52963,"o"],[-1,52982,"\n"],[1,52988,"f"],[-1,53009,"\n"],[1,53015,"操"],[-1,53029,"\n"],[1,53034,"操"],[-1,53053,"\n"],[1,53058,"="],[-1,53085,"\n"],[1,53090,"+"],[-1,53114,"\n"],[1,53119,"C"]],[44244,44244],[53120,53120]]],[1543582100047,[null,[[-1,44244,"- "],[1,44270,"=,"],[-1,44272,"=,"],[1,44304,"**"],[-1,44304,"）用"],[1,44310,"**"],[-1,44310,"重载"],[1,44318,"**"],[-1,44318,"操作"],[1,44325,"Ø "],[-1,44327,"is"],[1,44358,"\nØ"],[-1,44360,"ci"],[1,44397,"\nØ"],[-1,44399,"运算"],[1,44434,"\nØ"],[-1,44436,"运算"],[1,44472,"\nØ"],[-1,44474,"用友"],[1,45437,"\n\n"],[-1,45437,"\tc"],[1,45543,"o\n3）"],[-1,45545,"3）友元"],[-1,45565,"- "],[1,45569,"- "],[1,45599,"\nb"],[-1,45625,"b）"],[1,45630,"\nØ"],[-1,45634,"在第"],[1,45669,"\nØ"],[-1,45673,"友员"],[1,45718,"\nØ"],[-1,45722,"C+"],[1,45741,"\n"],[-1,45746,"="],[1,45763,"**"],[-1,45763,"）友"],[1,45776,"***\n\n|` "],[-1,45776,"类**\n``"],[-1,45787,"#in"],[1,45807,"\n"],[-1,45809,"i"],[1,45868,"\n"],[-1,45872,"b"],[1,45876," "],[1,45878," v\t"],[-1,45878,"\tvec"],[1,45886," "],[-1,45888,"t"],[1,45896,"1"],[-1,45897,"1"],[1,45900,"1\n ~v\t"],[-1,45900,"\n\n\t~ve"],[1,45912," "],[1,45914," in\t"],[-1,45914,"\n\tint"],[1,45933," "],[-1,45935,"t"],[1,45938," ) \n fr\t"],[-1,45938,");\n\n\tfri"],[1,45973," "],[-1,45975,"t"],[1,45989," "],[-1,45991,"v"],[1,45999," ) \n fr\t"],[-1,45999,");\n\n\tfri"],[1,46034," "],[-1,46036,"t"],[1,46059," ) "],[-1,46059,");\n"],[1,46070," : "],[-1,46073,"int"],[1,46080," "],[1,46082," in\t"],[-1,46082,"\n\tint"],[1,46091," "],[-1,46092,"\n"],[1,46113," "],[-1,46115,"t"],[1,46121," "],[-1,46125,"\tif"],[1,46129,"i\t"],[1,46153," "],[1,46155," {"],[-1,46160,"cou"],[1,46208," "],[-1,46210,"a"],[1,46217," "],[1,46219," }"],[-1,46224,"v ="],[1,46236," "],[1,46238,"e ]  "],[-1,46238,"ze]; l"],[1,46253," "],[-1,46256,"\n"],[1,46278,"\n"],[1,46280," d"],[-1,46281,"del"],[1,46291," "],[1,46293," le\t"],[-1,46293,"\n\tlen"],[1,46302," "],[-1,46305,"\n"],[1,46331," "],[-1,46333,"t"],[1,46336," )  \n i\t i  ="],[-1,46336,")\n{\n\tif (i >= "],[1,46353," "],[1,46362," "],[-1,46364,"r"],[1,46373," i  \n co\t"],[-1,46373,"i];\n\n\tcou"],[1,46429," "],[-1,46431,"a"],[1,46438," "],[-1,46442,"\n"],[1,46466," "],[-1,46468,"t"],[1,46496," "],[1,46500," f"],[-1,46501,"for "],[1,46508," "],[1,46515," "],[-1,46517,"i"],[1,46528," "],[1,46530," "],[-1,46530,"i"],[1,46535," o"],[-1,46537,"out"],[1,46551," i "],[-1,46551,"i]"],[-1,46555,"<"],[1,46560," "],[1,46562," ou\t"],[-1,46562,"\n\tout"],[1,46578," "],[1,46580," r\t"],[-1,46580,"\tret"],[1,46594," "],[-1,46597,"\n"],[1,46622," "],[-1,46624,"t"],[1,46651," "],[1,46655," f\t( i n"],[-1,46655,"\tfor (int"],[1,46670," "],[-1,46672,"i"],[1,46683," "],[1,46685," "],[-1,46685,"i"],[1,46690," i"],[-1,46692,"inp"],[1,46705," i  \n re\t"],[-1,46705,"i];\n\n\tret"],[1,46723," "],[-1,46727,"\n"],[1,46740,"\n"],[1,46742," i\t"],[-1,46742,"\tint"],[1,46748," "],[1,46750," c\t"],[-1,46750,"\tcou"],[1,46793," "],[1,46795," c\t"],[-1,46795,"\tcin"],[1,46804," "],[1,46806," v\t"],[-1,46806,"\tvec"],[1,46816," k  \n c\t"],[-1,46816,"k);\n\tcou"],[1,46865," "],[1,46867," c\t"],[-1,46867,"\tcin"],[1,46876," "],[1,46878," c\t"],[-1,46878,"\tcou"],[1,46924," "],[1,46926," c\t"],[-1,46926,"\tcou"],[1,46936," "],[1,46938," s\t"],[-1,46938,"\tsys"],[1,46955,"\n"],[1,46958," |"],[-1,46962,"\n\n#"],[1,46980,"**1"],[1,46987,"*."],[-1,46987,"1.运算符"],[1,47022,"**2"],[1,47029,"*."],[-1,47029,"2.重载赋"],[1,47038,"*"],[-1,47038,"="],[1,47043,"Ø 赋* "],[-1,47043,"* 赋值运"],[1,47062,"\nØ "],[-1,47064,"ope"],[1,47084,"\nØ "],[-1,47086,"重"],[1,47095,"\n"],[1,47097,"型_*名_"],[-1,47097,"类型&类名:"],[1,47122,"*"],[-1,47124,"类"],[1,47126,"_"],[-1,47127,"&"],[1,47132,"*"],[-1,47132,"\n"],[1,47152,"\n"],[-1,47176,"\n\n"],[1,47179,"\n"],[1,47184,"\n1 /"],[-1,47184," 1 先"],[1,47195,"\n"],[-1,47195," "],[1,47205,"\n"],[-1,47205," "],[1,47217,"\n"],[1,48406,"|"],[-1,48406,"\n"],[1,48414,"3"],[-1,48415,"3"],[-1,48417,"重"],[1,48426,"*"],[-1,48426,"["],[1,48430,"\n"],[-1,48447,"重"],[1,48457,"\n"],[-1,48462,"运"],[1,48481,"\n"],[-1,48485,"["],[1,48514,"*"],[-1,48516,"重"],[1,48526,"_"],[-1,48531,"["],[1,48549,"\n"],[-1,48551,"重"],[-1,48555,"："],[1,48557,"："],[1,48558,"_"],[1,48561,"型_*_"],[-1,48561,"类型 类 "],[1,48582,"_型_"],[-1,48582,"类型 "],[1,48589,"\n"],[-1,48591,"设"],[1,48610,"\n\n *`   *"],[-1,48610," `x[y]"],[-1,48618,"可"],[1,48623,"\n"],[1,48626,"  "],[-1,48626,"x.o"],[1,48636,"     *"],[-1,48636,"[](y)"],[-1,48692,"\n\n"],[1,48700,"\n*.4*"],[-1,48700,"*4.重"],[1,48710,"*"],[-1,48710,"("],[1,48735,"_类 _:"],[-1,48735," 类型 类"],[1,48755,"_表达式_"],[-1,48755," 表达式表"],[1,48766,"*1_\n* x*类 X*"],[-1,48766,"例1\n\n设 x是类 X的"],[1,48788,"*"],[-1,48789,"x"],[1,48808,"*"],[-1,48809,"可"],[1,48814,"*"],[-1,48815,"x"],[1,48847,"*"],[-1,48847,"\n"],[1,49223,"_/_3_"],[-1,49223,"//例3用"],[1,49232,"_"],[-1,49232,"运"],[1,49240,"_员函数_"],[-1,49240,"成员函数*"],[1,51844,"|"],[1,51847,"lang"],[-1,51847,"cpp"],[1,51852,"```"],[-1,52391,"};\n\n"],[1,52409,"| \n\n"],[-1,52818,"\n};\n"],[1,52825,"\n\n |"],[1,52850,"总"],[-1,52850,""],[-1,52902,"总"],[1,52904,"\n"],[-1,52909,"操"],[1,52926,"\n"],[-1,52930,"操"],[1,52952,"\n"],[-1,52956,"o"],[1,52976,"\n"],[-1,52981,"f"],[1,53003,"\n"],[-1,53008,"操"],[1,53023,"\n"],[-1,53027,"操"],[1,53047,"\n"],[-1,53051,"="],[1,53079,"\n"],[-1,53083,"+"],[1,53108,"\n"],[-1,53112,"C"]],[53120,53120],[44244,44244]]],[1543582053277,["gjx16@GJXAIOU",[[1,48734,":"]],[48734,48734],[48735,48735]]],[1543582058453,["gjx16@GJXAIOU",[[1,48737,"fanhi"]],[48737,48737],[48742,48742]]],[1543582065600,["gjx16@GJXAIOU",[[-1,48737,"fanhi"]],[48742,48742],[48737,48737]]],[1543582069567,["gjx16@GJXAIOU",[[1,48737,"返回值"]],[48737,48737],[48740,48740]]],[1543582079891,["gjx16@GJXAIOU",[[-1,48773,"\n"]],[48773,48773],[48772,48772]]],[1543582088088,["gjx16@GJXAIOU",[[-1,48857,"**_//_****_"]],[48857,48868],[48857,48857]]],[1543582088654,["gjx16@GJXAIOU",[[1,48857,"="]],[48857,48857],[48858,48858]]],[1543582090019,["gjx16@GJXAIOU",[[-1,48857,"="]],[48858,48858],[48857,48857]]],[1543582095336,["gjx16@GJXAIOU",[[-1,48859,"_****_"]],[48859,48865],[48859,48859]]],[1543582098721,["gjx16@GJXAIOU",[[-1,48865,"_****_"]],[48865,48871],[48865,48865]]],[1543582160037,[null,[[1,44244,"- "],[-1,44268,"=,"],[1,44272,"=,"],[-1,44302,"**"],[1,44304,"）用"],[-1,44308,"**"],[1,44310,"重载"],[-1,44316,"**"],[1,44318,"操作"],[-1,44323,"Ø "],[1,44327,"is"],[-1,44356,"\nØ"],[1,44360,"ci"],[-1,44395,"\nØ"],[1,44399,"运算"],[-1,44432,"\nØ"],[1,44436,"运算"],[-1,44470,"\nØ"],[1,44474,"用友"],[-1,45435,"\n\n"],[1,45437,"\tc"],[-1,45541,"o\n3）"],[1,45547,"3）友元"],[1,45563,"- "],[-1,45565,"- "],[-1,45597,"\nb"],[1,45625,"b）"],[-1,45628,"\nØ"],[1,45634,"在第"],[-1,45667,"\nØ"],[1,45673,"友员"],[-1,45716,"\nØ"],[1,45722,"C+"],[-1,45739,"\n"],[1,45745,"="],[-1,45761,"**"],[1,45763,"）友"],[-1,45774,"***\n\n|` "],[1,45782,"类**\n``"],[1,45787,"#in"],[-1,45804,"\n"],[1,45807,"i"],[-1,45865,"\n"],[1,45870,"b"],[-1,45873," "],[-1,45876," v\t"],[1,45879,"\tvec"],[-1,45883," "],[1,45886,"t"],[-1,45893,"1"],[1,45895,"1"],[-1,45897,"1\n ~v\t"],[1,45903,"\n\n\t~ve"],[-1,45909," "],[-1,45912," in\t"],[1,45916,"\n\tint"],[-1,45930," "],[1,45933,"t"],[-1,45935," ) \n fr\t"],[1,45943,");\n\n\tfri"],[-1,45970," "],[1,45973,"t"],[-1,45986," "],[1,45989,"v"],[-1,45996," ) \n fr\t"],[1,46004,");\n\n\tfri"],[-1,46031," "],[1,46034,"t"],[-1,46056," ) "],[1,46059,");\n"],[-1,46067," : "],[1,46073,"int"],[-1,46077," "],[-1,46080," in\t"],[1,46084,"\n\tint"],[-1,46088," "],[1,46090,"\n"],[-1,46110," "],[1,46113,"t"],[-1,46118," "],[1,46123,"\tif"],[-1,46124,"i\t"],[-1,46150," "],[-1,46153," {"],[1,46160,"cou"],[-1,46205," "],[1,46208,"a"],[-1,46214," "],[-1,46217," }"],[1,46224,"v ="],[-1,46233," "],[-1,46236,"e ]  "],[1,46241,"ze]; l"],[-1,46250," "],[1,46254,"\n"],[-1,46275,"\n"],[-1,46278," d"],[1,46281,"del"],[-1,46288," "],[-1,46291," le\t"],[1,46295,"\n\tlen"],[-1,46299," "],[1,46303,"\n"],[-1,46328," "],[1,46331,"t"],[-1,46333," )  \n i\t i  ="],[1,46346,")\n{\n\tif (i >= "],[-1,46349," "],[-1,46359," "],[1,46362,"r"],[-1,46370," i  \n co\t"],[1,46379,"i];\n\n\tcou"],[-1,46426," "],[1,46429,"a"],[-1,46435," "],[1,46440,"\n"],[-1,46463," "],[1,46466,"t"],[-1,46493," "],[-1,46498," f"],[1,46501,"for "],[-1,46504," "],[-1,46512," "],[1,46515,"i"],[-1,46525," "],[-1,46528," "],[1,46529,"i"],[-1,46533," o"],[1,46537,"out"],[-1,46548," i "],[1,46551,"i]"],[1,46553,"<"],[-1,46557," "],[-1,46560," ou\t"],[1,46564,"\n\tout"],[-1,46575," "],[-1,46578," r\t"],[1,46581,"\tret"],[-1,46591," "],[1,46595,"\n"],[-1,46619," "],[1,46622,"t"],[-1,46648," "],[-1,46653," f\t( i n"],[1,46661,"\tfor (int"],[-1,46667," "],[1,46670,"i"],[-1,46680," "],[-1,46683," "],[1,46684,"i"],[-1,46688," i"],[1,46692,"inp"],[-1,46702," i  \n re\t"],[1,46711,"i];\n\n\tret"],[-1,46720," "],[1,46725,"\n"],[-1,46737,"\n"],[-1,46740," i\t"],[1,46743,"\tint"],[-1,46745," "],[-1,46748," c\t"],[1,46751,"\tcou"],[-1,46790," "],[-1,46793," c\t"],[1,46796,"\tcin"],[-1,46801," "],[-1,46804," v\t"],[1,46807,"\tvec"],[-1,46813," k  \n c\t"],[1,46821,"k);\n\tcou"],[-1,46862," "],[-1,46865," c\t"],[1,46868,"\tcin"],[-1,46873," "],[-1,46876," c\t"],[1,46879,"\tcou"],[-1,46921," "],[-1,46924," c\t"],[1,46927,"\tcou"],[-1,46933," "],[-1,46936," s\t"],[1,46939,"\tsys"],[-1,46952,"\n"],[-1,46956," |"],[1,46962,"\n\n#"],[-1,46977,"**1"],[-1,46987,"*."],[1,46989,"1.运算符"],[-1,47019,"**2"],[-1,47029,"*."],[1,47031,"2.重载赋"],[-1,47035,"*"],[1,47036,"="],[-1,47040,"Ø 赋* "],[1,47045,"* 赋值运"],[-1,47059,"\nØ "],[1,47064,"ope"],[-1,47081,"\nØ "],[1,47086,"重"],[-1,47094,"\n"],[-1,47097,"型_*名_"],[1,47102,"类型&类名:"],[-1,47121,"*"],[1,47124,"类"],[-1,47125,"_"],[1,47127,"&"],[-1,47131,"*"],[1,47132,"\n"],[-1,47151,"\n"],[1,47176,"\n\n"],[-1,47177,"\n"],[-1,47183,"\n1 /"],[1,47187," 1 先"],[-1,47194,"\n"],[1,47195," "],[-1,47204,"\n"],[1,47205," "],[-1,47216,"\n"],[-1,48406,"|"],[1,48407,"\n"],[-1,48414,"3"],[1,48416,"3"],[1,48417,"重"],[-1,48425,"*"],[1,48426,"["],[-1,48429,"\n"],[1,48447,"重"],[-1,48457,"\n"],[1,48462,"运"],[-1,48480,"\n"],[1,48485,"["],[-1,48513,"*"],[1,48516,"重"],[-1,48525,"_"],[1,48531,"["],[-1,48547,"\n"],[1,48551,"重"],[-1,48554," "],[-1,48557,"_返回值型_*_"],[1,48565," 返回值类型 类 "],[-1,48581,"_型_"],[1,48584,"类型 "],[-1,48587,"\n"],[1,48591,"设"],[-1,48609,"\n\n *`   *"],[1,48618," `x[y]"],[1,48620,"可"],[-1,48624,"\n"],[-1,48628,"  "],[1,48630,"x.o"],[-1,48637,"     *"],[1,48643,"[](y)"],[1,48694,"\n\n"],[-1,48700,"\n*.4*"],[1,48705,"*4.重"],[-1,48711,"*"],[1,48712,"("],[-1,48734,":式"],[1,48736,"式: "],[-1,48740,"_类 _:"],[1,48745,"类型 类"],[-1,48760,"_表达式_"],[1,48765," 表达式表"],[-1,48771,"*1\n* x*类 X*"],[1,48782,"例1\n设 x是类 X的"],[-1,48791,"*"],[1,48794,"x"],[-1,48812,"*"],[1,48814,"可"],[-1,48818,"*"],[1,48820,"x"],[-1,48851,"*"],[1,48852,"\n"],[-1,48857,"_例_"],[1,48860,"\n例2"],[-1,48865,"_"],[1,48866,")"],[-1,49204,"_/_3_"],[1,49209,"//例3用"],[-1,49213,"_"],[1,49214,"运"],[-1,49221,"_员函数_"],[1,49226,"成员函数*"],[-1,51825,"|"],[-1,51829,"lang"],[1,51833,"cpp"],[-1,51835,"```"],[1,52377,"};\n\n"],[-1,52391,"| \n\n"],[1,52804,"\n};\n"],[-1,52807,"\n\n |"],[-1,52836,"总"],[1,52837,""],[1,52889,"总"],[-1,52890,"\n"],[1,52896,"操"],[-1,52912,"\n"],[1,52917,"操"],[-1,52938,"\n"],[1,52943,"o"],[-1,52962,"\n"],[1,52968,"f"],[-1,52989,"\n"],[1,52995,"操"],[-1,53009,"\n"],[1,53014,"操"],[-1,53033,"\n"],[1,53038,"="],[-1,53065,"\n"],[1,53070,"+"],[-1,53094,"\n"],[1,53099,"C"]],[44244,44244],[53100,53100]]],[1543582160037,[null,[[-1,44244,"- "],[1,44270,"=,"],[-1,44272,"=,"],[1,44304,"**"],[-1,44304,"）用"],[1,44310,"**"],[-1,44310,"重载"],[1,44318,"**"],[-1,44318,"操作"],[1,44325,"Ø "],[-1,44327,"is"],[1,44358,"\nØ"],[-1,44360,"ci"],[1,44397,"\nØ"],[-1,44399,"运算"],[1,44434,"\nØ"],[-1,44436,"运算"],[1,44472,"\nØ"],[-1,44474,"用友"],[1,45437,"\n\n"],[-1,45437,"\tc"],[1,45543,"o\n3）"],[-1,45545,"3）友元"],[-1,45565,"- "],[1,45569,"- "],[1,45599,"\nb"],[-1,45625,"b）"],[1,45630,"\nØ"],[-1,45634,"在第"],[1,45669,"\nØ"],[-1,45673,"友员"],[1,45718,"\nØ"],[-1,45722,"C+"],[1,45741,"\n"],[-1,45746,"="],[1,45763,"**"],[-1,45763,"）友"],[1,45776,"***\n\n|` "],[-1,45776,"类**\n``"],[-1,45787,"#in"],[1,45807,"\n"],[-1,45809,"i"],[1,45868,"\n"],[-1,45872,"b"],[1,45876," "],[1,45878," v\t"],[-1,45878,"\tvec"],[1,45886," "],[-1,45888,"t"],[1,45896,"1"],[-1,45897,"1"],[1,45900,"1\n ~v\t"],[-1,45900,"\n\n\t~ve"],[1,45912," "],[1,45914," in\t"],[-1,45914,"\n\tint"],[1,45933," "],[-1,45935,"t"],[1,45938," ) \n fr\t"],[-1,45938,");\n\n\tfri"],[1,45973," "],[-1,45975,"t"],[1,45989," "],[-1,45991,"v"],[1,45999," ) \n fr\t"],[-1,45999,");\n\n\tfri"],[1,46034," "],[-1,46036,"t"],[1,46059," ) "],[-1,46059,");\n"],[1,46070," : "],[-1,46073,"int"],[1,46080," "],[1,46082," in\t"],[-1,46082,"\n\tint"],[1,46091," "],[-1,46092,"\n"],[1,46113," "],[-1,46115,"t"],[1,46121," "],[-1,46125,"\tif"],[1,46129,"i\t"],[1,46153," "],[1,46155," {"],[-1,46160,"cou"],[1,46208," "],[-1,46210,"a"],[1,46217," "],[1,46219," }"],[-1,46224,"v ="],[1,46236," "],[1,46238,"e ]  "],[-1,46238,"ze]; l"],[1,46253," "],[-1,46256,"\n"],[1,46278,"\n"],[1,46280," d"],[-1,46281,"del"],[1,46291," "],[1,46293," le\t"],[-1,46293,"\n\tlen"],[1,46302," "],[-1,46305,"\n"],[1,46331," "],[-1,46333,"t"],[1,46336," )  \n i\t i  ="],[-1,46336,")\n{\n\tif (i >= "],[1,46353," "],[1,46362," "],[-1,46364,"r"],[1,46373," i  \n co\t"],[-1,46373,"i];\n\n\tcou"],[1,46429," "],[-1,46431,"a"],[1,46438," "],[-1,46442,"\n"],[1,46466," "],[-1,46468,"t"],[1,46496," "],[1,46500," f"],[-1,46501,"for "],[1,46508," "],[1,46515," "],[-1,46517,"i"],[1,46528," "],[1,46530," "],[-1,46530,"i"],[1,46535," o"],[-1,46537,"out"],[1,46551," i "],[-1,46551,"i]"],[-1,46555,"<"],[1,46560," "],[1,46562," ou\t"],[-1,46562,"\n\tout"],[1,46578," "],[1,46580," r\t"],[-1,46580,"\tret"],[1,46594," "],[-1,46597,"\n"],[1,46622," "],[-1,46624,"t"],[1,46651," "],[1,46655," f\t( i n"],[-1,46655,"\tfor (int"],[1,46670," "],[-1,46672,"i"],[1,46683," "],[1,46685," "],[-1,46685,"i"],[1,46690," i"],[-1,46692,"inp"],[1,46705," i  \n re\t"],[-1,46705,"i];\n\n\tret"],[1,46723," "],[-1,46727,"\n"],[1,46740,"\n"],[1,46742," i\t"],[-1,46742,"\tint"],[1,46748," "],[1,46750," c\t"],[-1,46750,"\tcou"],[1,46793," "],[1,46795," c\t"],[-1,46795,"\tcin"],[1,46804," "],[1,46806," v\t"],[-1,46806,"\tvec"],[1,46816," k  \n c\t"],[-1,46816,"k);\n\tcou"],[1,46865," "],[1,46867," c\t"],[-1,46867,"\tcin"],[1,46876," "],[1,46878," c\t"],[-1,46878,"\tcou"],[1,46924," "],[1,46926," c\t"],[-1,46926,"\tcou"],[1,46936," "],[1,46938," s\t"],[-1,46938,"\tsys"],[1,46955,"\n"],[1,46958," |"],[-1,46962,"\n\n#"],[1,46980,"**1"],[1,46987,"*."],[-1,46987,"1.运算符"],[1,47022,"**2"],[1,47029,"*."],[-1,47029,"2.重载赋"],[1,47038,"*"],[-1,47038,"="],[1,47043,"Ø 赋* "],[-1,47043,"* 赋值运"],[1,47062,"\nØ "],[-1,47064,"ope"],[1,47084,"\nØ "],[-1,47086,"重"],[1,47095,"\n"],[1,47097,"型_*名_"],[-1,47097,"类型&类名:"],[1,47122,"*"],[-1,47124,"类"],[1,47126,"_"],[-1,47127,"&"],[1,47132,"*"],[-1,47132,"\n"],[1,47152,"\n"],[-1,47176,"\n\n"],[1,47179,"\n"],[1,47184,"\n1 /"],[-1,47184," 1 先"],[1,47195,"\n"],[-1,47195," "],[1,47205,"\n"],[-1,47205," "],[1,47217,"\n"],[1,48406,"|"],[-1,48406,"\n"],[1,48414,"3"],[-1,48415,"3"],[-1,48417,"重"],[1,48426,"*"],[-1,48426,"["],[1,48430,"\n"],[-1,48447,"重"],[1,48458,"\n"],[-1,48462,"运"],[1,48481,"\n"],[-1,48485,"["],[1,48514,"*"],[-1,48516,"重"],[1,48526,"_"],[-1,48531,"["],[1,48548,"\n"],[-1,48551,"重"],[1,48555," "],[1,48557,"_返回值型_*_"],[-1,48557," 返回值类型 类 "],[1,48582,"_型_"],[-1,48582,"类型 "],[1,48588,"\n"],[-1,48591,"设"],[1,48610,"\n\n *`   *"],[-1,48610," `x[y]"],[-1,48618,"可"],[1,48623,"\n"],[1,48626,"  "],[-1,48626,"x.o"],[1,48636,"     *"],[-1,48636,"[](y)"],[-1,48692,"\n\n"],[1,48700,"\n*.4*"],[-1,48700,"*4.重"],[1,48710,"*"],[-1,48710,"("],[1,48733,":式"],[-1,48733,"式: "],[1,48740,"_类 _:"],[-1,48740,"类型 类"],[1,48759,"_表达式_"],[-1,48759," 表达式表"],[1,48770,"*1\n* x*类 X*"],[-1,48770,"例1\n设 x是类 X的"],[1,48790,"*"],[-1,48792,"x"],[1,48811,"*"],[-1,48812,"可"],[1,48817,"*"],[-1,48818,"x"],[1,48850,"*"],[-1,48850,"\n"],[1,48856,"_例_"],[-1,48856,"\n例2"],[1,48864,"_"],[-1,48864,")"],[1,49203,"_/_3_"],[-1,49203,"//例3用"],[1,49212,"_"],[-1,49212,"运"],[1,49220,"_员函数_"],[-1,49220,"成员函数*"],[1,51824,"|"],[1,51827,"lang"],[-1,51827,"cpp"],[1,51832,"```"],[-1,52371,"};\n\n"],[1,52389,"| \n\n"],[-1,52798,"\n};\n"],[1,52805,"\n\n |"],[1,52830,"总"],[-1,52830,""],[-1,52882,"总"],[1,52884,"\n"],[-1,52889,"操"],[1,52906,"\n"],[-1,52910,"操"],[1,52932,"\n"],[-1,52936,"o"],[1,52956,"\n"],[-1,52961,"f"],[1,52983,"\n"],[-1,52988,"操"],[1,53003,"\n"],[-1,53007,"操"],[1,53027,"\n"],[-1,53031,"="],[1,53059,"\n"],[-1,53063,"+"],[1,53088,"\n"],[-1,53092,"C"]],[53100,53100],[44244,44244]]],[1543582101695,["gjx16@GJXAIOU",[[-1,48877,"_**"]],[48877,48880],[48877,48877]]],[1543582106991,["gjx16@GJXAIOU",[[1,48878,"·"]],[48878,48878],[48879,48879]]],[1543582108336,["gjx16@GJXAIOU",[[-1,48878,"·"]],[48879,48879],[48878,48878]]],[1543582112445,["gjx16@GJXAIOU",[[1,48878,"```cpp"]],[48878,48878],[48884,48884]]],[1543582113039,["gjx16@GJXAIOU",[[1,48885,"\n"]],[48884,48884],[48885,48885]]],[1543582126908,["gjx16@GJXAIOU",[[1,49194,"```"]],[49194,49194],[49197,49197]]],[1543582135986,["gjx16@GJXAIOU",[[-1,48856,"\n"]],[48856,48856],[48855,48855]]],[1543582138416,["gjx16@GJXAIOU",[[1,48852,"**"],[1,48855,"**"]],[48852,48855],[48852,48859]]],[1543582146590,["gjx16@GJXAIOU",[[1,49237,"```cpp"]],[49237,49237],[49243,49243]]],[1543582154980,["gjx16@GJXAIOU",[[1,49513,"```"]],[49513,49513],[49516,49516]]],[1543582159040,["gjx16@GJXAIOU",[[-1,49475,"**"]],[49477,49477],[49475,49475]]],[1543582220037,[null,[[1,44244,"- "],[-1,44268,"=,"],[1,44272,"=,"],[-1,44302,"**"],[1,44304,"）用"],[-1,44308,"**"],[1,44310,"重载"],[-1,44316,"**"],[1,44318,"操作"],[-1,44323,"Ø "],[1,44327,"is"],[-1,44356,"\nØ"],[1,44360,"ci"],[-1,44395,"\nØ"],[1,44399,"运算"],[-1,44432,"\nØ"],[1,44436,"运算"],[-1,44470,"\nØ"],[1,44474,"用友"],[-1,45435,"\n\n"],[1,45437,"\tc"],[-1,45541,"o\n3）"],[1,45547,"3）友元"],[-1,45563,"a）"],[1,45567,"a）"],[-1,45597,"\nb"],[1,45625,"b）"],[-1,45628,"\nØ"],[1,45634,"在第"],[-1,45667,"\nØ"],[1,45673,"友员"],[-1,45716,"\nØ"],[1,45722,"C+"],[-1,45738,"\n"],[1,45745,"="],[-1,45761,"**"],[1,45763,"）友"],[-1,45774,"***\n\n|` "],[1,45782,"类**\n``"],[1,45787,"#in"],[-1,45804,"\n"],[1,45807,"i"],[-1,45865,"\n"],[1,45870,"b"],[-1,45873," "],[-1,45876," v"],[1,45879,"vec"],[-1,45883," "],[1,45886,"t"],[1,45893," "],[-1,45894," "],[-1,45897,"1\n ~v\t"],[1,45903,"\n\n\t~ve"],[-1,45909," "],[-1,45912," in\t"],[1,45916,"\n\tint"],[-1,45930," "],[1,45933,"t"],[-1,45935," ) \n fr\t"],[1,45943,");\n\n\tfri"],[-1,45970," "],[1,45973,"t"],[-1,45986," "],[1,45989,"v"],[-1,45996," ) \n fr\t"],[1,46004,");\n\n\tfri"],[-1,46031," "],[1,46034,"t"],[-1,46056," ) "],[1,46059,");\n"],[-1,46067," : "],[1,46073,"int"],[-1,46077," "],[-1,46080," in\t"],[1,46084,"\n\tint"],[-1,46088," "],[1,46090,"\n"],[-1,46110," "],[1,46113,"t"],[-1,46118," "],[1,46123,"\tif"],[-1,46124,"i\t"],[-1,46150," "],[-1,46153," {"],[1,46160,"cou"],[-1,46205," "],[1,46208,"a"],[-1,46214," "],[-1,46217," }"],[1,46224,"v ="],[-1,46233," "],[-1,46236,"e ]  "],[1,46241,"ze]; l"],[-1,46250," "],[1,46255,"\n"],[-1,46275,"\n"],[-1,46278," d"],[1,46281,"del"],[-1,46288," "],[-1,46291," le\t"],[1,46295,"\n\tlen"],[-1,46299," "],[1,46303,"\n"],[-1,46328," "],[1,46331,"t"],[-1,46333," )  \n i\t "],[1,46342,")\n{\n\tif ("],[1,46344,">="],[-1,46345,"="],[-1,46349," "],[-1,46359," "],[1,46362,"r"],[-1,46370," i  \n co\t"],[1,46379,"i];\n\n\tcou"],[-1,46426," "],[1,46429,"a"],[-1,46435," "],[1,46439,"\n"],[-1,46463," "],[1,46466,"t"],[-1,46493," "],[-1,46498," f\t"],[1,46501,"\tfor "],[-1,46504," "],[-1,46512," "],[1,46515,"i"],[-1,46525," "],[-1,46528," "],[1,46529,"i"],[-1,46533," o"],[1,46537,"out"],[-1,46548," i "],[1,46551,"i]"],[1,46553,"<"],[-1,46557," "],[-1,46560," ou\t"],[1,46564,"\n\tout"],[-1,46575," "],[-1,46578," r\t"],[1,46581,"\tret"],[-1,46591," "],[1,46595,"\n"],[-1,46619," "],[1,46622,"t"],[-1,46648," "],[-1,46653," f\t( i n"],[1,46661,"\tfor (int"],[-1,46667," "],[1,46670,"i"],[-1,46680," "],[-1,46683," "],[1,46684,"i"],[-1,46688," i"],[1,46692,"inp"],[-1,46702," i  \n re\t"],[1,46711,"i];\n\n\tret"],[-1,46720," "],[1,46725,"\n"],[-1,46736,"\n"],[-1,46740," i\t"],[1,46743,"\tint"],[-1,46745," "],[-1,46748," c"],[1,46751,"cou"],[-1,46790," "],[-1,46793," c"],[1,46796,"cin"],[-1,46801," "],[-1,46804," v\t"],[1,46807,"\tvec"],[-1,46813," k  \n c\t"],[1,46821,"k);\n\tcou"],[-1,46862," "],[-1,46865," c\t"],[1,46868,"\tcin"],[-1,46873," "],[-1,46876," c\t"],[1,46879,"\tcou"],[-1,46921," "],[-1,46924," c"],[1,46927,"cou"],[-1,46933," "],[-1,46936," s"],[1,46939,"sys"],[-1,46953,"\n"],[-1,46956," |"],[1,46962,"\n\n#"],[-1,46977,"**1"],[-1,46987,"*."],[1,46989,"1.运算符"],[-1,47019,"**2"],[-1,47029,"*."],[1,47031,"2.重载赋"],[-1,47035,"*"],[1,47036,"="],[-1,47040,"Ø 赋"],[1,47045,"赋值运"],[-1,47059,"\nØ "],[1,47064,"ope"],[-1,47081,"\nØ "],[1,47086,"重"],[-1,47093,"\n"],[-1,47097,"型_*名_"],[1,47102,"类型&类名:"],[-1,47121,"*"],[1,47124,"类"],[-1,47125,"_"],[1,47127,"&"],[-1,47131,"*"],[1,47132,"\n"],[-1,47151,"\n"],[-1,47176," "],[1,47178,"\n "],[-1,47183,"\n1 /"],[1,47187," 1 先"],[-1,47194,"\n"],[1,47195," "],[-1,47204,"\n"],[1,47205," "],[-1,47216,"\n"],[-1,48406,"|"],[1,48407,"\n"],[-1,48414,"3"],[1,48416,"3"],[1,48417,"重"],[-1,48425,"*"],[1,48426,"["],[-1,48429,"\n"],[1,48447,"重"],[-1,48457,"\n"],[1,48462,"运"],[-1,48479,"\n"],[1,48485,"["],[-1,48513,"*"],[1,48516,"重"],[-1,48525,"_"],[1,48531,"["],[-1,48548,"\n"],[1,48551,"重"],[1,48554,"："],[-1,48555,"："],[-1,48557,"_"],[-1,48561,"型_*_"],[1,48565,"类型 类 "],[-1,48581,"_型_"],[1,48584,"类型 "],[-1,48588,"\n"],[1,48591,"设"],[-1,48609,"\n\n *`   *"],[1,48618," `x[y]"],[1,48620,"可"],[-1,48624,"\n"],[-1,48628,"  "],[1,48630,"x.o"],[-1,48637,"     *"],[1,48643,"[](y)"],[1,48694,"\n\n"],[-1,48700,"\n*.4*"],[1,48705,"*4.重"],[-1,48711,"*"],[1,48712,"("],[-1,48734,":式"],[1,48736,"式: "],[-1,48740,"_类 _:"],[1,48745,"类型 类"],[-1,48760,"_表达式_"],[1,48765," 表达式表"],[-1,48771,"*1\n* x*类 X*"],[1,48782,"例1\n设 x是类 X的"],[-1,48791,"*"],[1,48794,"x"],[-1,48812,"*"],[1,48814,"可"],[-1,48818,"*"],[1,48820,"x"],[-1,48851,"*"],[1,48852,"\n\n"],[-1,48854,"\n"],[1,48857,"："],[-1,48859,"：_例_"],[1,48863,"\n例2"],[-1,48868,"_"],[1,48869,")"],[-1,48880,"*"],[1,48881,"象\n"],[-1,48887,"\n"],[1,49197,"\n"],[-1,49200,"\n"],[-1,49214,"_/_3_"],[1,49219,"//例3用"],[-1,49223,"_"],[1,49224,"运"],[-1,49231,"_员函数_*"],[1,49237,"成员函数**\n"],[-1,49243,"\n"],[-1,49475,"*"],[1,49476,"."],[1,49511,"\n"],[-1,49514,"\n"],[-1,51842,"|"],[-1,51846,"lang"],[1,51850,"cpp"],[-1,51852,"```"],[1,52394,"};\n\n"],[-1,52408,"| \n\n"],[1,52821,"\n};\n"],[-1,52824,"\n\n |"],[-1,52853,"总"],[1,52854,""],[1,52906,"总"],[-1,52907,"\n"],[1,52913,"操"],[-1,52929,"\n"],[1,52934,"操"],[-1,52955,"\n"],[1,52960,"o"],[-1,52979,"\n"],[1,52985,"f"],[-1,53006,"\n"],[1,53012,"操"],[-1,53026,"\n"],[1,53031,"操"],[-1,53050,"\n"],[1,53055,"="],[-1,53082,"\n"],[1,53087,"+"],[-1,53111,"\n"],[1,53116,"C"]],[44244,44244],[53117,53117]]],[1543582220037,[null,[[-1,44244,"- "],[1,44270,"=,"],[-1,44272,"=,"],[1,44304,"**"],[-1,44304,"）用"],[1,44310,"**"],[-1,44310,"重载"],[1,44318,"**"],[-1,44318,"操作"],[1,44325,"Ø "],[-1,44327,"is"],[1,44358,"\nØ"],[-1,44360,"ci"],[1,44397,"\nØ"],[-1,44399,"运算"],[1,44434,"\nØ"],[-1,44436,"运算"],[1,44472,"\nØ"],[-1,44474,"用友"],[1,45437,"\n\n"],[-1,45437,"\tc"],[1,45543,"o\n3）"],[-1,45545,"3）友元"],[1,45565,"a）"],[-1,45567,"a）"],[1,45599,"\nb"],[-1,45625,"b）"],[1,45630,"\nØ"],[-1,45634,"在第"],[1,45669,"\nØ"],[-1,45673,"友员"],[1,45718,"\nØ"],[-1,45722,"C+"],[1,45740,"\n"],[-1,45746,"="],[1,45763,"**"],[-1,45763,"）友"],[1,45776,"***\n\n|` "],[-1,45776,"类**\n``"],[-1,45787,"#in"],[1,45807,"\n"],[-1,45809,"i"],[1,45868,"\n"],[-1,45872,"b"],[1,45876," "],[1,45878," v"],[-1,45879,"vec"],[1,45886," "],[-1,45888,"t"],[-1,45896," "],[1,45898," "],[1,45900,"1\n ~v\t"],[-1,45900,"\n\n\t~ve"],[1,45912," "],[1,45914," in\t"],[-1,45914,"\n\tint"],[1,45933," "],[-1,45935,"t"],[1,45938," ) \n fr\t"],[-1,45938,");\n\n\tfri"],[1,45973," "],[-1,45975,"t"],[1,45989," "],[-1,45991,"v"],[1,45999," ) \n fr\t"],[-1,45999,");\n\n\tfri"],[1,46034," "],[-1,46036,"t"],[1,46059," ) "],[-1,46059,");\n"],[1,46070," : "],[-1,46073,"int"],[1,46080," "],[1,46082," in\t"],[-1,46082,"\n\tint"],[1,46091," "],[-1,46092,"\n"],[1,46113," "],[-1,46115,"t"],[1,46121," "],[-1,46125,"\tif"],[1,46129,"i\t"],[1,46153," "],[1,46155," {"],[-1,46160,"cou"],[1,46208," "],[-1,46210,"a"],[1,46217," "],[1,46219," }"],[-1,46224,"v ="],[1,46236," "],[1,46238,"e ]  "],[-1,46238,"ze]; l"],[1,46253," "],[-1,46257,"\n"],[1,46278,"\n"],[1,46280," d"],[-1,46281,"del"],[1,46291," "],[1,46293," le\t"],[-1,46293,"\n\tlen"],[1,46302," "],[-1,46305,"\n"],[1,46331," "],[-1,46333,"t"],[1,46336," )  \n i\t "],[-1,46336,")\n{\n\tif ("],[-1,46347,">="],[1,46350,"="],[1,46353," "],[1,46362," "],[-1,46364,"r"],[1,46373," i  \n co\t"],[-1,46373,"i];\n\n\tcou"],[1,46429," "],[-1,46431,"a"],[1,46438," "],[-1,46441,"\n"],[1,46466," "],[-1,46468,"t"],[1,46496," "],[1,46500," f\t"],[-1,46500,"\tfor "],[1,46508," "],[1,46515," "],[-1,46517,"i"],[1,46528," "],[1,46530," "],[-1,46530,"i"],[1,46535," o"],[-1,46537,"out"],[1,46551," i "],[-1,46551,"i]"],[-1,46555,"<"],[1,46560," "],[1,46562," ou\t"],[-1,46562,"\n\tout"],[1,46578," "],[1,46580," r\t"],[-1,46580,"\tret"],[1,46594," "],[-1,46597,"\n"],[1,46622," "],[-1,46624,"t"],[1,46651," "],[1,46655," f\t( i n"],[-1,46655,"\tfor (int"],[1,46670," "],[-1,46672,"i"],[1,46683," "],[1,46685," "],[-1,46685,"i"],[1,46690," i"],[-1,46692,"inp"],[1,46705," i  \n re\t"],[-1,46705,"i];\n\n\tret"],[1,46723," "],[-1,46727,"\n"],[1,46739,"\n"],[1,46742," i\t"],[-1,46742,"\tint"],[1,46748," "],[1,46750," c"],[-1,46751,"cou"],[1,46793," "],[1,46795," c"],[-1,46796,"cin"],[1,46804," "],[1,46806," v\t"],[-1,46806,"\tvec"],[1,46816," k  \n c\t"],[-1,46816,"k);\n\tcou"],[1,46865," "],[1,46867," c\t"],[-1,46867,"\tcin"],[1,46876," "],[1,46878," c\t"],[-1,46878,"\tcou"],[1,46924," "],[1,46926," c"],[-1,46927,"cou"],[1,46936," "],[1,46938," s"],[-1,46939,"sys"],[1,46956,"\n"],[1,46958," |"],[-1,46962,"\n\n#"],[1,46980,"**1"],[1,46987,"*."],[-1,46987,"1.运算符"],[1,47022,"**2"],[1,47029,"*."],[-1,47029,"2.重载赋"],[1,47038,"*"],[-1,47038,"="],[1,47043,"Ø 赋"],[-1,47045,"赋值运"],[1,47062,"\nØ "],[-1,47064,"ope"],[1,47084,"\nØ "],[-1,47086,"重"],[1,47094,"\n"],[1,47097,"型_*名_"],[-1,47097,"类型&类名:"],[1,47122,"*"],[-1,47124,"类"],[1,47126,"_"],[-1,47127,"&"],[1,47132,"*"],[-1,47132,"\n"],[1,47152,"\n"],[1,47176," "],[-1,47177,"\n "],[1,47184,"\n1 /"],[-1,47184," 1 先"],[1,47195,"\n"],[-1,47195," "],[1,47205,"\n"],[-1,47205," "],[1,47217,"\n"],[1,48406,"|"],[-1,48406,"\n"],[1,48414,"3"],[-1,48415,"3"],[-1,48417,"重"],[1,48426,"*"],[-1,48426,"["],[1,48430,"\n"],[-1,48447,"重"],[1,48458,"\n"],[-1,48462,"运"],[1,48480,"\n"],[-1,48485,"["],[1,48514,"*"],[-1,48516,"重"],[1,48526,"_"],[-1,48531,"["],[1,48549,"\n"],[-1,48551,"重"],[-1,48555,"："],[1,48557,"："],[1,48558,"_"],[1,48561,"型_*_"],[-1,48561,"类型 类 "],[1,48582,"_型_"],[-1,48582,"类型 "],[1,48589,"\n"],[-1,48591,"设"],[1,48610,"\n\n *`   *"],[-1,48610," `x[y]"],[-1,48618,"可"],[1,48623,"\n"],[1,48626,"  "],[-1,48626,"x.o"],[1,48636,"     *"],[-1,48636,"[](y)"],[-1,48692,"\n\n"],[1,48700,"\n*.4*"],[-1,48700,"*4.重"],[1,48710,"*"],[-1,48710,"("],[1,48733,":式"],[-1,48733,"式: "],[1,48740,"_类 _:"],[-1,48740,"类型 类"],[1,48759,"_表达式_"],[-1,48759," 表达式表"],[1,48770,"*1\n* x*类 X*"],[-1,48770,"例1\n设 x是类 X的"],[1,48790,"*"],[-1,48792,"x"],[1,48811,"*"],[-1,48812,"可"],[1,48817,"*"],[-1,48818,"x"],[1,48850,"*"],[-1,48850,"\n\n"],[1,48854,"\n"],[-1,48856,"："],[1,48859,"：_例_"],[-1,48859,"\n例2"],[1,48867,"_"],[-1,48867,")"],[1,48879,"*"],[-1,48879,"象\n"],[1,48887,"\n"],[-1,49196,"\n"],[1,49200,"\n"],[1,49213,"_/_3_"],[-1,49213,"//例3用"],[1,49222,"_"],[-1,49222,"运"],[1,49230,"_员函数_*"],[-1,49230,"成员函数**\n"],[1,49243,"\n"],[1,49474,"*"],[-1,49474,"."],[-1,49510,"\n"],[1,49514,"\n"],[1,51841,"|"],[1,51844,"lang"],[-1,51844,"cpp"],[1,51849,"```"],[-1,52388,"};\n\n"],[1,52406,"| \n\n"],[-1,52815,"\n};\n"],[1,52822,"\n\n |"],[1,52847,"总"],[-1,52847,""],[-1,52899,"总"],[1,52901,"\n"],[-1,52906,"操"],[1,52923,"\n"],[-1,52927,"操"],[1,52949,"\n"],[-1,52953,"o"],[1,52973,"\n"],[-1,52978,"f"],[1,53000,"\n"],[-1,53005,"操"],[1,53020,"\n"],[-1,53024,"操"],[1,53044,"\n"],[-1,53048,"="],[1,53076,"\n"],[-1,53080,"+"],[1,53105,"\n"],[-1,53109,"C"]],[53117,53117],[44244,44244]]],[1543582163321,["gjx16@GJXAIOU",[[-1,49481,"**"]],[49483,49483],[49481,49481]]],[1543582169228,["gjx16@GJXAIOU",[[-1,49353,"**"]],[49355,49355],[49353,49353]]],[1543582172518,["gjx16@GJXAIOU",[[-1,49359,"**"]],[49361,49361],[49359,49359]]],[1543582177461,["gjx16@GJXAIOU",[[-1,49297,"**"]],[49299,49299],[49297,49297]]],[1543582180561,["gjx16@GJXAIOU",[[-1,49303,"**"]],[49305,49305],[49303,49303]]],[1543582188360,["gjx16@GJXAIOU",[[-1,49508,"****"]],[49508,49512],[49508,49508]]],[1543582191473,["gjx16@GJXAIOU",[[-1,49515,"****"]],[49515,49519],[49515,49515]]],[1543582193906,["gjx16@GJXAIOU",[[-1,49517,"****"]],[49517,49521],[49517,49517]]],[1543582197433,["gjx16@GJXAIOU",[[-1,49518,"****"]],[49518,49522],[49518,49518]]],[1543582200158,["gjx16@GJXAIOU",[[-1,49520,"****"]],[49520,49524],[49520,49520]]],[1543582202287,["gjx16@GJXAIOU",[[1,49505,"\n"]],[49505,49505],[49506,49506]]],[1543582206635,["gjx16@GJXAIOU",[[1,49506,"#### "]],[49506,49506],[49511,49511]]],[1543582211273,["gjx16@GJXAIOU",[[1,49514,"."]],[49514,49514],[49515,49515]]],[1543582216715,["gjx16@GJXAIOU",[[1,49534,"- "]],[49534,49534],[49536,49536]]],[1543582218470,["gjx16@GJXAIOU",[[-1,49542,"\n"]],[49542,49542],[49541,49541]]],[1543582280052,[null,[[1,44244,"- "],[-1,44268,"=,"],[1,44272,"=,"],[-1,44302,"**"],[1,44304,"）用"],[-1,44308,"**"],[1,44310,"重载"],[-1,44316,"**"],[1,44318,"操作"],[-1,44323,"Ø "],[1,44327,"is"],[-1,44356,"\nØ"],[1,44360,"ci"],[-1,44395,"\nØ"],[1,44399,"运算"],[-1,44432,"\nØ"],[1,44436,"运算"],[-1,44470,"\nØ"],[1,44474,"用友"],[-1,45435,"\n\n"],[1,45437,"\tc"],[-1,45541,"o\n3）"],[1,45547,"3）友元"],[1,45563,"- "],[-1,45565,"- "],[-1,45597,"\nb"],[1,45625,"b）"],[-1,45628,"\nØ"],[1,45634,"在第"],[-1,45667,"\nØ"],[1,45673,"友员"],[-1,45716,"\nØ"],[1,45722,"C+"],[-1,45739,"\n"],[1,45745,"="],[-1,45761,"**"],[1,45763,"）友"],[-1,45774,"***\n\n|` "],[1,45782,"类**\n``"],[1,45787,"#in"],[-1,45804,"\n"],[1,45807,"i"],[-1,45865,"\n"],[1,45870,"b"],[-1,45873," "],[-1,45876," v\t"],[1,45879,"\tvec"],[-1,45883," "],[1,45886,"t"],[-1,45893,"1"],[1,45895,"1"],[-1,45897,"1\n ~v\t"],[1,45903,"\n\n\t~ve"],[-1,45909," "],[-1,45912," in\t"],[1,45916,"\n\tint"],[-1,45930," "],[1,45933,"t"],[-1,45935," ) \n fr\t"],[1,45943,");\n\n\tfri"],[-1,45970," "],[1,45973,"t"],[-1,45986," "],[1,45989,"v"],[-1,45996," ) \n fr\t"],[1,46004,");\n\n\tfri"],[-1,46031," "],[1,46034,"t"],[-1,46056," ) "],[1,46059,");\n"],[-1,46067," : "],[1,46073,"int"],[-1,46077," "],[-1,46080," in\t"],[1,46084,"\n\tint"],[-1,46088," "],[1,46090,"\n"],[-1,46110," "],[1,46113,"t"],[-1,46118," "],[1,46123,"\tif"],[-1,46124,"i\t"],[-1,46150," "],[-1,46153," {"],[1,46160,"cou"],[-1,46205," "],[1,46208,"a"],[-1,46214," "],[-1,46217," }"],[1,46224,"v ="],[-1,46233," "],[-1,46236,"e ]  "],[1,46241,"ze]; l"],[-1,46250," "],[1,46254,"\n"],[-1,46275,"\n"],[-1,46278," d"],[1,46281,"del"],[-1,46288," "],[-1,46291," le\t"],[1,46295,"\n\tlen"],[-1,46299," "],[1,46303,"\n"],[-1,46328," "],[1,46331,"t"],[-1,46333," )  \n i\t i  ="],[1,46346,")\n{\n\tif (i >= "],[-1,46349," "],[-1,46359," "],[1,46362,"r"],[-1,46370," i  \n co\t"],[1,46379,"i];\n\n\tcou"],[-1,46426," "],[1,46429,"a"],[-1,46435," "],[1,46440,"\n"],[-1,46463," "],[1,46466,"t"],[-1,46493," "],[-1,46498," f"],[1,46501,"for "],[-1,46504," "],[-1,46512," "],[1,46515,"i"],[-1,46525," "],[-1,46528," "],[1,46529,"i"],[-1,46533," o"],[1,46537,"out"],[-1,46548," i "],[1,46551,"i]"],[1,46553,"<"],[-1,46557," "],[-1,46560," ou\t"],[1,46564,"\n\tout"],[-1,46575," "],[-1,46578," r\t"],[1,46581,"\tret"],[-1,46591," "],[1,46595,"\n"],[-1,46619," "],[1,46622,"t"],[-1,46648," "],[-1,46653," f\t( i n"],[1,46661,"\tfor (int"],[-1,46667," "],[1,46670,"i"],[-1,46680," "],[-1,46683," "],[1,46684,"i"],[-1,46688," i"],[1,46692,"inp"],[-1,46702," i  \n re\t"],[1,46711,"i];\n\n\tret"],[-1,46720," "],[1,46725,"\n"],[-1,46737,"\n"],[-1,46740," i\t"],[1,46743,"\tint"],[-1,46745," "],[-1,46748," c\t"],[1,46751,"\tcou"],[-1,46790," "],[-1,46793," c\t"],[1,46796,"\tcin"],[-1,46801," "],[-1,46804," v\t"],[1,46807,"\tvec"],[-1,46813," k  \n c\t"],[1,46821,"k);\n\tcou"],[-1,46862," "],[-1,46865," c\t"],[1,46868,"\tcin"],[-1,46873," "],[-1,46876," c\t"],[1,46879,"\tcou"],[-1,46921," "],[-1,46924," c\t"],[1,46927,"\tcou"],[-1,46933," "],[-1,46936," s\t"],[1,46939,"\tsys"],[-1,46952,"\n"],[-1,46956," |"],[1,46962,"\n\n#"],[-1,46977,"**1"],[-1,46987,"*."],[1,46989,"1.运算符"],[-1,47019,"**2"],[-1,47029,"*."],[1,47031,"2.重载赋"],[-1,47035,"*"],[1,47036,"="],[-1,47040,"Ø 赋* "],[1,47045,"* 赋值运"],[-1,47059,"\nØ "],[1,47064,"ope"],[-1,47081,"\nØ "],[1,47086,"重"],[-1,47094,"\n"],[-1,47097,"型_*名_"],[1,47102,"类型&类名:"],[-1,47121,"*"],[1,47124,"类"],[-1,47125,"_"],[1,47127,"&"],[-1,47131,"*"],[1,47132,"\n"],[-1,47151,"\n"],[1,47176,"\n\n"],[-1,47177,"\n"],[-1,47183,"\n1 /"],[1,47187," 1 先"],[-1,47194,"\n"],[1,47195," "],[-1,47204,"\n"],[1,47205," "],[-1,47216,"\n"],[-1,48406,"|"],[1,48407,"\n"],[-1,48414,"3"],[1,48416,"3"],[1,48417,"重"],[-1,48425,"*"],[1,48426,"["],[-1,48429,"\n"],[1,48447,"重"],[-1,48457,"\n"],[1,48462,"运"],[-1,48479,"\n"],[1,48485,"["],[-1,48513,"*"],[1,48516,"重"],[-1,48525,"_"],[1,48531,"["],[-1,48548,"\n"],[1,48551,"重"],[1,48554,"："],[-1,48555,"："],[-1,48557,"_"],[-1,48561,"型_*_"],[1,48565,"类型 类 "],[-1,48581,"_型_"],[1,48584,"类型 "],[-1,48588,"\n"],[1,48591,"设"],[-1,48609,"\n\n *`   *"],[1,48618," `x[y]"],[1,48620,"可"],[-1,48624,"\n"],[-1,48628,"  "],[1,48630,"x.o"],[-1,48637,"     *"],[1,48643,"[](y)"],[1,48694,"\n\n"],[-1,48700,"\n*.4*"],[1,48705,"*4.重"],[-1,48711,"*"],[1,48712,"("],[-1,48734,":式"],[1,48736,"式: "],[-1,48740,"_类 _:"],[1,48745,"类型 类"],[-1,48760,"_表达式_"],[1,48765," 表达式表"],[-1,48771,"*1\n* x*类 X*"],[1,48782,"例1\n设 x是类 X的"],[-1,48791,"*"],[1,48794,"x"],[-1,48812,"*"],[1,48814,"可"],[-1,48818,"*"],[1,48820,"x"],[-1,48851,"*"],[1,48852,"\n\n"],[-1,48854,"\n"],[1,48857,"："],[-1,48859,"：_例_"],[1,48863,"\n例2"],[-1,48868,"_"],[1,48869,")"],[-1,48880,"*"],[1,48881,"象\n"],[-1,48887,"\n"],[1,49197,"\n"],[-1,49200,"\n"],[-1,49214,"_/_3_"],[1,49219,"//例3用"],[-1,49223,"_"],[1,49224,"运"],[-1,49231,"_员函数_*"],[1,49237,"成员函数**\n"],[-1,49243,"\n"],[-1,49297,"*"],[1,49298," "],[-1,49303,"*"],[1,49304,"n"],[-1,49349,"*"],[1,49350," "],[-1,49355,"*"],[1,49356,"n"],[-1,49467,"*"],[1,49468,"."],[-1,49473,"*"],[1,49474,"n"],[1,49501,"\n"],[-1,49511,"\n"],[1,49514,"5"],[-1,49515,"*"],[-1,49522,"*&**|*"],[1,49528,"载&&和||"],[1,49534,"\n"],[-1,49536,"\n"],[-1,51820,"|"],[-1,51824,"lang"],[1,51828,"cpp"],[-1,51830,"```"],[1,52372,"};\n\n"],[-1,52386,"| \n\n"],[1,52798,"\n\n};"],[-1,52804," |\n\n"],[-1,52831,"总"],[1,52832,""],[1,52884,"总"],[-1,52885,"\n"],[1,52891,"操"],[-1,52907,"\n"],[1,52912,"操"],[-1,52933,"\n"],[1,52938,"o"],[-1,52957,"\n"],[1,52963,"f"],[-1,52984,"\n"],[1,52990,"操"],[-1,53004,"\n"],[1,53009,"操"],[-1,53028,"\n"],[1,53033,"="],[-1,53060,"\n"],[1,53065,"+"],[-1,53089,"\n"],[1,53094,"C"]],[44244,44244],[53095,53095]]],[1543582280052,[null,[[-1,44244,"- "],[1,44270,"=,"],[-1,44272,"=,"],[1,44304,"**"],[-1,44304,"）用"],[1,44310,"**"],[-1,44310,"重载"],[1,44318,"**"],[-1,44318,"操作"],[1,44325,"Ø "],[-1,44327,"is"],[1,44358,"\nØ"],[-1,44360,"ci"],[1,44397,"\nØ"],[-1,44399,"运算"],[1,44434,"\nØ"],[-1,44436,"运算"],[1,44472,"\nØ"],[-1,44474,"用友"],[1,45437,"\n\n"],[-1,45437,"\tc"],[1,45543,"o\n3）"],[-1,45545,"3）友元"],[-1,45565,"- "],[1,45569,"- "],[1,45599,"\nb"],[-1,45625,"b）"],[1,45630,"\nØ"],[-1,45634,"在第"],[1,45669,"\nØ"],[-1,45673,"友员"],[1,45718,"\nØ"],[-1,45722,"C+"],[1,45741,"\n"],[-1,45746,"="],[1,45763,"**"],[-1,45763,"）友"],[1,45776,"***\n\n|` "],[-1,45776,"类**\n``"],[-1,45787,"#in"],[1,45807,"\n"],[-1,45809,"i"],[1,45868,"\n"],[-1,45872,"b"],[1,45876," "],[1,45878," v\t"],[-1,45878,"\tvec"],[1,45886," "],[-1,45888,"t"],[1,45896,"1"],[-1,45897,"1"],[1,45900,"1\n ~v\t"],[-1,45900,"\n\n\t~ve"],[1,45912," "],[1,45914," in\t"],[-1,45914,"\n\tint"],[1,45933," "],[-1,45935,"t"],[1,45938," ) \n fr\t"],[-1,45938,");\n\n\tfri"],[1,45973," "],[-1,45975,"t"],[1,45989," "],[-1,45991,"v"],[1,45999," ) \n fr\t"],[-1,45999,");\n\n\tfri"],[1,46034," "],[-1,46036,"t"],[1,46059," ) "],[-1,46059,");\n"],[1,46070," : "],[-1,46073,"int"],[1,46080," "],[1,46082," in\t"],[-1,46082,"\n\tint"],[1,46091," "],[-1,46092,"\n"],[1,46113," "],[-1,46115,"t"],[1,46121," "],[-1,46125,"\tif"],[1,46129,"i\t"],[1,46153," "],[1,46155," {"],[-1,46160,"cou"],[1,46208," "],[-1,46210,"a"],[1,46217," "],[1,46219," }"],[-1,46224,"v ="],[1,46236," "],[1,46238,"e ]  "],[-1,46238,"ze]; l"],[1,46253," "],[-1,46256,"\n"],[1,46278,"\n"],[1,46280," d"],[-1,46281,"del"],[1,46291," "],[1,46293," le\t"],[-1,46293,"\n\tlen"],[1,46302," "],[-1,46305,"\n"],[1,46331," "],[-1,46333,"t"],[1,46336," )  \n i\t i  ="],[-1,46336,")\n{\n\tif (i >= "],[1,46353," "],[1,46362," "],[-1,46364,"r"],[1,46373," i  \n co\t"],[-1,46373,"i];\n\n\tcou"],[1,46429," "],[-1,46431,"a"],[1,46438," "],[-1,46442,"\n"],[1,46466," "],[-1,46468,"t"],[1,46496," "],[1,46500," f"],[-1,46501,"for "],[1,46508," "],[1,46515," "],[-1,46517,"i"],[1,46528," "],[1,46530," "],[-1,46530,"i"],[1,46535," o"],[-1,46537,"out"],[1,46551," i "],[-1,46551,"i]"],[-1,46555,"<"],[1,46560," "],[1,46562," ou\t"],[-1,46562,"\n\tout"],[1,46578," "],[1,46580," r\t"],[-1,46580,"\tret"],[1,46594," "],[-1,46597,"\n"],[1,46622," "],[-1,46624,"t"],[1,46651," "],[1,46655," f\t( i n"],[-1,46655,"\tfor (int"],[1,46670," "],[-1,46672,"i"],[1,46683," "],[1,46685," "],[-1,46685,"i"],[1,46690," i"],[-1,46692,"inp"],[1,46705," i  \n re\t"],[-1,46705,"i];\n\n\tret"],[1,46723," "],[-1,46727,"\n"],[1,46740,"\n"],[1,46742," i\t"],[-1,46742,"\tint"],[1,46748," "],[1,46750," c\t"],[-1,46750,"\tcou"],[1,46793," "],[1,46795," c\t"],[-1,46795,"\tcin"],[1,46804," "],[1,46806," v\t"],[-1,46806,"\tvec"],[1,46816," k  \n c\t"],[-1,46816,"k);\n\tcou"],[1,46865," "],[1,46867," c\t"],[-1,46867,"\tcin"],[1,46876," "],[1,46878," c\t"],[-1,46878,"\tcou"],[1,46924," "],[1,46926," c\t"],[-1,46926,"\tcou"],[1,46936," "],[1,46938," s\t"],[-1,46938,"\tsys"],[1,46955,"\n"],[1,46958," |"],[-1,46962,"\n\n#"],[1,46980,"**1"],[1,46987,"*."],[-1,46987,"1.运算符"],[1,47022,"**2"],[1,47029,"*."],[-1,47029,"2.重载赋"],[1,47038,"*"],[-1,47038,"="],[1,47043,"Ø 赋* "],[-1,47043,"* 赋值运"],[1,47062,"\nØ "],[-1,47064,"ope"],[1,47084,"\nØ "],[-1,47086,"重"],[1,47095,"\n"],[1,47097,"型_*名_"],[-1,47097,"类型&类名:"],[1,47122,"*"],[-1,47124,"类"],[1,47126,"_"],[-1,47127,"&"],[1,47132,"*"],[-1,47132,"\n"],[1,47152,"\n"],[-1,47176,"\n\n"],[1,47179,"\n"],[1,47184,"\n1 /"],[-1,47184," 1 先"],[1,47195,"\n"],[-1,47195," "],[1,47205,"\n"],[-1,47205," "],[1,47217,"\n"],[1,48406,"|"],[-1,48406,"\n"],[1,48414,"3"],[-1,48415,"3"],[-1,48417,"重"],[1,48426,"*"],[-1,48426,"["],[1,48430,"\n"],[-1,48447,"重"],[1,48458,"\n"],[-1,48462,"运"],[1,48480,"\n"],[-1,48485,"["],[1,48514,"*"],[-1,48516,"重"],[1,48526,"_"],[-1,48531,"["],[1,48549,"\n"],[-1,48551,"重"],[-1,48555,"："],[1,48557,"："],[1,48558,"_"],[1,48561,"型_*_"],[-1,48561,"类型 类 "],[1,48582,"_型_"],[-1,48582,"类型 "],[1,48589,"\n"],[-1,48591,"设"],[1,48610,"\n\n *`   *"],[-1,48610," `x[y]"],[-1,48618,"可"],[1,48623,"\n"],[1,48626,"  "],[-1,48626,"x.o"],[1,48636,"     *"],[-1,48636,"[](y)"],[-1,48692,"\n\n"],[1,48700,"\n*.4*"],[-1,48700,"*4.重"],[1,48710,"*"],[-1,48710,"("],[1,48733,":式"],[-1,48733,"式: "],[1,48740,"_类 _:"],[-1,48740,"类型 类"],[1,48759,"_表达式_"],[-1,48759," 表达式表"],[1,48770,"*1\n* x*类 X*"],[-1,48770,"例1\n设 x是类 X的"],[1,48790,"*"],[-1,48792,"x"],[1,48811,"*"],[-1,48812,"可"],[1,48817,"*"],[-1,48818,"x"],[1,48850,"*"],[-1,48850,"\n\n"],[1,48854,"\n"],[-1,48856,"："],[1,48859,"：_例_"],[-1,48859,"\n例2"],[1,48867,"_"],[-1,48867,")"],[1,48879,"*"],[-1,48879,"象\n"],[1,48887,"\n"],[-1,49196,"\n"],[1,49200,"\n"],[1,49213,"_/_3_"],[-1,49213,"//例3用"],[1,49222,"_"],[-1,49222,"运"],[1,49230,"_员函数_*"],[-1,49230,"成员函数**\n"],[1,49243,"\n"],[1,49296,"*"],[-1,49296," "],[1,49302,"*"],[-1,49302,"n"],[1,49348,"*"],[-1,49348," "],[1,49354,"*"],[-1,49354,"n"],[1,49466,"*"],[-1,49466,"."],[1,49472,"*"],[-1,49472,"n"],[-1,49500,"\n"],[1,49511,"\n"],[-1,49513,"5"],[1,49515,"*"],[1,49521,"*&**|*"],[-1,49521,"载&&和||"],[-1,49533,"\n"],[1,49536,"\n"],[1,51819,"|"],[1,51822,"lang"],[-1,51822,"cpp"],[1,51827,"```"],[-1,52366,"};\n\n"],[1,52384,"| \n\n"],[-1,52792,"\n\n};"],[1,52802," |\n\n"],[1,52825,"总"],[-1,52825,""],[-1,52877,"总"],[1,52879,"\n"],[-1,52884,"操"],[1,52901,"\n"],[-1,52905,"操"],[1,52927,"\n"],[-1,52931,"o"],[1,52951,"\n"],[-1,52956,"f"],[1,52978,"\n"],[-1,52983,"操"],[1,52998,"\n"],[-1,53002,"操"],[1,53022,"\n"],[-1,53026,"="],[1,53054,"\n"],[-1,53058,"+"],[1,53083,"\n"],[-1,53087,"C"]],[53095,53095],[44244,44244]]],[1543582221422,["gjx16@GJXAIOU",[[-1,49580,"\n"]],[49580,49580],[49579,49579]]],[1543582222766,["gjx16@GJXAIOU",[[-1,49598,"\n"]],[49598,49598],[49597,49597]]],[1543582224102,["gjx16@GJXAIOU",[[-1,49612,"\n"]],[49612,49612],[49611,49611]]],[1543582228448,["gjx16@GJXAIOU",[[1,49542,"  "],[1,49563,"  "],[1,49580,"  "],[1,49598,"  "],[1,49612,"  "]],[49542,49636],[49542,49646]]],[1543582233784,["gjx16@GJXAIOU",[[-1,49542," "],[1,49543,"-"],[-1,49565," "],[1,49566,"-"],[-1,49584," "],[1,49585,"-"],[-1,49604," "],[1,49605,"-"],[-1,49620," "],[1,49621,"-"]],[49542,49646],[49542,49646]]],[1543582235550,["gjx16@GJXAIOU",[[1,49542,"  "],[1,49565,"  "],[1,49584,"  "],[1,49604,"  "],[1,49620,"  "]],[49542,49646],[49542,49656]]],[1543582247593,["gjx16@GJXAIOU",[[-1,49658,"| \n\n"]],[49657,49661],[49657,49657]]],[1543582253700,["gjx16@GJXAIOU",[[1,49657,"```cpp"]],[49657,49657],[49663,49663]]],[1543582340053,[null,[[1,44244,"- "],[-1,44268,"=,"],[1,44272,"=,"],[-1,44302,"**"],[1,44304,"）用"],[-1,44308,"**"],[1,44310,"重载"],[-1,44316,"**"],[1,44318,"操作"],[-1,44323,"Ø "],[1,44327,"is"],[-1,44356,"\nØ"],[1,44360,"ci"],[-1,44395,"\nØ"],[1,44399,"运算"],[-1,44432,"\nØ"],[1,44436,"运算"],[-1,44470,"\nØ"],[1,44474,"用友"],[-1,45435,"\n\n"],[1,45437,"\tc"],[-1,45541,"o\n3）"],[1,45547,"3）友元"],[1,45563,"- "],[-1,45565,"- "],[-1,45597,"\nb"],[1,45625,"b）"],[-1,45628,"\nØ"],[1,45634,"在第"],[-1,45667,"\nØ"],[1,45673,"友员"],[-1,45716,"\nØ"],[1,45722,"C+"],[-1,45739,"\n"],[1,45745,"="],[-1,45761,"**"],[1,45763,"）友"],[-1,45774,"***\n\n|` "],[1,45782,"类**\n``"],[1,45787,"#in"],[-1,45804,"\n"],[1,45807,"i"],[-1,45865,"\n"],[1,45870,"b"],[-1,45873," "],[-1,45876," v\t"],[1,45879,"\tvec"],[-1,45883," "],[1,45886,"t"],[-1,45893,"1"],[1,45895,"1"],[-1,45897,"1\n ~v\t"],[1,45903,"\n\n\t~ve"],[-1,45909," "],[-1,45912," in\t"],[1,45916,"\n\tint"],[-1,45930," "],[1,45933,"t"],[-1,45935," ) \n fr\t"],[1,45943,");\n\n\tfri"],[-1,45970," "],[1,45973,"t"],[-1,45986," "],[1,45989,"v"],[-1,45996," ) \n fr\t"],[1,46004,");\n\n\tfri"],[-1,46031," "],[1,46034,"t"],[-1,46056," ) "],[1,46059,");\n"],[-1,46067," : "],[1,46073,"int"],[-1,46077," "],[-1,46080," in\t"],[1,46084,"\n\tint"],[-1,46088," "],[1,46090,"\n"],[-1,46110," "],[1,46113,"t"],[-1,46118," "],[1,46123,"\tif"],[-1,46124,"i\t"],[-1,46150," "],[-1,46153," {"],[1,46160,"cou"],[-1,46205," "],[1,46208,"a"],[-1,46214," "],[-1,46217," }"],[1,46224,"v ="],[-1,46233," "],[-1,46236,"e ]  "],[1,46241,"ze]; l"],[-1,46250," "],[1,46254,"\n"],[-1,46275,"\n"],[-1,46278," d"],[1,46281,"del"],[-1,46288," "],[-1,46291," le\t"],[1,46295,"\n\tlen"],[-1,46299," "],[1,46303,"\n"],[-1,46328," "],[1,46331,"t"],[-1,46333," )  \n i\t i  ="],[1,46346,")\n{\n\tif (i >= "],[-1,46349," "],[-1,46359," "],[1,46362,"r"],[-1,46370," i  \n co\t"],[1,46379,"i];\n\n\tcou"],[-1,46426," "],[1,46429,"a"],[-1,46435," "],[1,46440,"\n"],[-1,46463," "],[1,46466,"t"],[-1,46493," "],[-1,46498," f"],[1,46501,"for "],[-1,46504," "],[-1,46512," "],[1,46515,"i"],[-1,46525," "],[-1,46528," "],[1,46529,"i"],[-1,46533," o"],[1,46537,"out"],[-1,46548," i "],[1,46551,"i]"],[1,46553,"<"],[-1,46557," "],[-1,46560," ou\t"],[1,46564,"\n\tout"],[-1,46575," "],[-1,46578," r\t"],[1,46581,"\tret"],[-1,46591," "],[1,46595,"\n"],[-1,46619," "],[1,46622,"t"],[-1,46648," "],[-1,46653," f\t( i n"],[1,46661,"\tfor (int"],[-1,46667," "],[1,46670,"i"],[-1,46680," "],[-1,46683," "],[1,46684,"i"],[-1,46688," i"],[1,46692,"inp"],[-1,46702," i  \n re\t"],[1,46711,"i];\n\n\tret"],[-1,46720," "],[1,46725,"\n"],[-1,46737,"\n"],[-1,46740," i\t"],[1,46743,"\tint"],[-1,46745," "],[-1,46748," c\t"],[1,46751,"\tcou"],[-1,46790," "],[-1,46793," c\t"],[1,46796,"\tcin"],[-1,46801," "],[-1,46804," v\t"],[1,46807,"\tvec"],[-1,46813," k  \n c\t"],[1,46821,"k);\n\tcou"],[-1,46862," "],[-1,46865," c\t"],[1,46868,"\tcin"],[-1,46873," "],[-1,46876," c\t"],[1,46879,"\tcou"],[-1,46921," "],[-1,46924," c\t"],[1,46927,"\tcou"],[-1,46933," "],[-1,46936," s\t"],[1,46939,"\tsys"],[-1,46952,"\n"],[-1,46956," |"],[1,46962,"\n\n#"],[-1,46977,"**1"],[-1,46987,"*."],[1,46989,"1.运算符"],[-1,47019,"**2"],[-1,47029,"*."],[1,47031,"2.重载赋"],[-1,47035,"*"],[1,47036,"="],[-1,47040,"Ø 赋* "],[1,47045,"* 赋值运"],[-1,47059,"\nØ "],[1,47064,"ope"],[-1,47081,"\nØ "],[1,47086,"重"],[-1,47094,"\n"],[-1,47097,"型_*名_"],[1,47102,"类型&类名:"],[-1,47121,"*"],[1,47124,"类"],[-1,47125,"_"],[1,47127,"&"],[-1,47131,"*"],[1,47132,"\n"],[-1,47151,"\n"],[1,47176,"\n\n"],[-1,47177,"\n"],[-1,47183,"\n1 /"],[1,47187," 1 先"],[-1,47194,"\n"],[1,47195," "],[-1,47204,"\n"],[1,47205," "],[-1,47216,"\n"],[-1,48406,"|"],[1,48407,"\n"],[-1,48414,"3"],[1,48416,"3"],[1,48417,"重"],[-1,48425,"*"],[1,48426,"["],[-1,48429,"\n"],[1,48447,"重"],[-1,48457,"\n"],[1,48462,"运"],[-1,48479,"\n"],[1,48485,"["],[-1,48513,"*"],[1,48516,"重"],[-1,48525,"_"],[1,48531,"["],[-1,48548,"\n"],[1,48551,"重"],[1,48554,"："],[-1,48555,"："],[-1,48557,"_"],[-1,48561,"型_*_"],[1,48565,"类型 类 "],[-1,48581,"_型_"],[1,48584,"类型 "],[-1,48588,"\n"],[1,48591,"设"],[-1,48609,"\n\n *`   *"],[1,48618," `x[y]"],[1,48620,"可"],[-1,48624,"\n"],[-1,48628,"  "],[1,48630,"x.o"],[-1,48637,"     *"],[1,48643,"[](y)"],[1,48694,"\n\n"],[-1,48700,"\n*.4*"],[1,48705,"*4.重"],[-1,48711,"*"],[1,48712,"("],[-1,48734,":式"],[1,48736,"式: "],[-1,48740,"_类 _:"],[1,48745,"类型 类"],[-1,48760,"_表达式_"],[1,48765," 表达式表"],[-1,48771,"*1\n* x*类 X*"],[1,48782,"例1\n设 x是类 X的"],[-1,48791,"*"],[1,48794,"x"],[-1,48812,"*"],[1,48814,"可"],[-1,48818,"*"],[1,48820,"x"],[-1,48851,"*"],[1,48852,"\n\n"],[-1,48854,"\n"],[1,48857,"："],[-1,48859,"：_例_"],[1,48863,"\n例2"],[-1,48868,"_"],[1,48869,")"],[-1,48880,"*"],[1,48881,"象\n"],[-1,48887,"\n"],[1,49197,"\n"],[-1,49200,"\n"],[-1,49214,"_/_3_"],[1,49219,"//例3用"],[-1,49223,"_"],[1,49224,"运"],[-1,49231,"_员函数_*"],[1,49237,"成员函数**\n"],[-1,49243,"\n"],[-1,49297,"*"],[1,49298," "],[-1,49303,"*"],[1,49304,"n"],[-1,49349,"*"],[1,49350," "],[-1,49355,"*"],[1,49356,"n"],[-1,49467,"*"],[1,49468,"."],[-1,49473,"*"],[1,49474,"n"],[1,49501,"\n"],[-1,49511,"\n"],[1,49514,"5"],[-1,49515,"*"],[-1,49522,"*&**|*"],[1,49528,"载&&和||"],[1,49534,"\n"],[-1,49536,"\n"],[1,49542,"\n"],[-1,49546,"\n"],[1,49567,"\n"],[-1,49571,"\n\n"],[1,49588,"则\n"],[-1,49592,"\n\n"],[1,49610,"的\n"],[-1,49614,"\n\n"],[1,49628,"递\n"],[-1,49632,"\n\n"],[1,49657,"则\n"],[-1,49663,"则\n"],[-1,51839,"|"],[-1,51843,"lang"],[1,51847,"cpp"],[-1,51849,"```"],[1,52391,"};\n\n"],[-1,52405,"| \n\n"],[1,52817,"\n\n};"],[-1,52823," |\n\n"],[-1,52850,"总"],[1,52851,""],[1,52903,"总"],[-1,52904,"\n"],[1,52910,"操"],[-1,52926,"\n"],[1,52931,"操"],[-1,52952,"\n"],[1,52957,"o"],[-1,52976,"\n"],[1,52982,"f"],[-1,53003,"\n"],[1,53009,"操"],[-1,53023,"\n"],[1,53028,"操"],[-1,53047,"\n"],[1,53052,"="],[-1,53079,"\n"],[1,53084,"+"],[-1,53108,"\n"],[1,53113,"C"]],[44244,44244],[53114,53114]]],[1543582340053,[null,[[-1,44244,"- "],[1,44270,"=,"],[-1,44272,"=,"],[1,44304,"**"],[-1,44304,"）用"],[1,44310,"**"],[-1,44310,"重载"],[1,44318,"**"],[-1,44318,"操作"],[1,44325,"Ø "],[-1,44327,"is"],[1,44358,"\nØ"],[-1,44360,"ci"],[1,44397,"\nØ"],[-1,44399,"运算"],[1,44434,"\nØ"],[-1,44436,"运算"],[1,44472,"\nØ"],[-1,44474,"用友"],[1,45437,"\n\n"],[-1,45437,"\tc"],[1,45543,"o\n3）"],[-1,45545,"3）友元"],[-1,45565,"- "],[1,45569,"- "],[1,45599,"\nb"],[-1,45625,"b）"],[1,45630,"\nØ"],[-1,45634,"在第"],[1,45669,"\nØ"],[-1,45673,"友员"],[1,45718,"\nØ"],[-1,45722,"C+"],[1,45741,"\n"],[-1,45746,"="],[1,45763,"**"],[-1,45763,"）友"],[1,45776,"***\n\n|` "],[-1,45776,"类**\n``"],[-1,45787,"#in"],[1,45807,"\n"],[-1,45809,"i"],[1,45868,"\n"],[-1,45872,"b"],[1,45876," "],[1,45878," v\t"],[-1,45878,"\tvec"],[1,45886," "],[-1,45888,"t"],[1,45896,"1"],[-1,45897,"1"],[1,45900,"1\n ~v\t"],[-1,45900,"\n\n\t~ve"],[1,45912," "],[1,45914," in\t"],[-1,45914,"\n\tint"],[1,45933," "],[-1,45935,"t"],[1,45938," ) \n fr\t"],[-1,45938,");\n\n\tfri"],[1,45973," "],[-1,45975,"t"],[1,45989," "],[-1,45991,"v"],[1,45999," ) \n fr\t"],[-1,45999,");\n\n\tfri"],[1,46034," "],[-1,46036,"t"],[1,46059," ) "],[-1,46059,");\n"],[1,46070," : "],[-1,46073,"int"],[1,46080," "],[1,46082," in\t"],[-1,46082,"\n\tint"],[1,46091," "],[-1,46092,"\n"],[1,46113," "],[-1,46115,"t"],[1,46121," "],[-1,46125,"\tif"],[1,46129,"i\t"],[1,46153," "],[1,46155," {"],[-1,46160,"cou"],[1,46208," "],[-1,46210,"a"],[1,46217," "],[1,46219," }"],[-1,46224,"v ="],[1,46236," "],[1,46238,"e ]  "],[-1,46238,"ze]; l"],[1,46253," "],[-1,46256,"\n"],[1,46278,"\n"],[1,46280," d"],[-1,46281,"del"],[1,46291," "],[1,46293," le\t"],[-1,46293,"\n\tlen"],[1,46302," "],[-1,46305,"\n"],[1,46331," "],[-1,46333,"t"],[1,46336," )  \n i\t i  ="],[-1,46336,")\n{\n\tif (i >= "],[1,46353," "],[1,46362," "],[-1,46364,"r"],[1,46373," i  \n co\t"],[-1,46373,"i];\n\n\tcou"],[1,46429," "],[-1,46431,"a"],[1,46438," "],[-1,46442,"\n"],[1,46466," "],[-1,46468,"t"],[1,46496," "],[1,46500," f"],[-1,46501,"for "],[1,46508," "],[1,46515," "],[-1,46517,"i"],[1,46528," "],[1,46530," "],[-1,46530,"i"],[1,46535," o"],[-1,46537,"out"],[1,46551," i "],[-1,46551,"i]"],[-1,46555,"<"],[1,46560," "],[1,46562," ou\t"],[-1,46562,"\n\tout"],[1,46578," "],[1,46580," r\t"],[-1,46580,"\tret"],[1,46594," "],[-1,46597,"\n"],[1,46622," "],[-1,46624,"t"],[1,46651," "],[1,46655," f\t( i n"],[-1,46655,"\tfor (int"],[1,46670," "],[-1,46672,"i"],[1,46683," "],[1,46685," "],[-1,46685,"i"],[1,46690," i"],[-1,46692,"inp"],[1,46705," i  \n re\t"],[-1,46705,"i];\n\n\tret"],[1,46723," "],[-1,46727,"\n"],[1,46740,"\n"],[1,46742," i\t"],[-1,46742,"\tint"],[1,46748," "],[1,46750," c\t"],[-1,46750,"\tcou"],[1,46793," "],[1,46795," c\t"],[-1,46795,"\tcin"],[1,46804," "],[1,46806," v\t"],[-1,46806,"\tvec"],[1,46816," k  \n c\t"],[-1,46816,"k);\n\tcou"],[1,46865," "],[1,46867," c\t"],[-1,46867,"\tcin"],[1,46876," "],[1,46878," c\t"],[-1,46878,"\tcou"],[1,46924," "],[1,46926," c\t"],[-1,46926,"\tcou"],[1,46936," "],[1,46938," s\t"],[-1,46938,"\tsys"],[1,46955,"\n"],[1,46958," |"],[-1,46962,"\n\n#"],[1,46980,"**1"],[1,46987,"*."],[-1,46987,"1.运算符"],[1,47022,"**2"],[1,47029,"*."],[-1,47029,"2.重载赋"],[1,47038,"*"],[-1,47038,"="],[1,47043,"Ø 赋* "],[-1,47043,"* 赋值运"],[1,47062,"\nØ "],[-1,47064,"ope"],[1,47084,"\nØ "],[-1,47086,"重"],[1,47095,"\n"],[1,47097,"型_*名_"],[-1,47097,"类型&类名:"],[1,47122,"*"],[-1,47124,"类"],[1,47126,"_"],[-1,47127,"&"],[1,47132,"*"],[-1,47132,"\n"],[1,47152,"\n"],[-1,47176,"\n\n"],[1,47179,"\n"],[1,47184,"\n1 /"],[-1,47184," 1 先"],[1,47195,"\n"],[-1,47195," "],[1,47205,"\n"],[-1,47205," "],[1,47217,"\n"],[1,48406,"|"],[-1,48406,"\n"],[1,48414,"3"],[-1,48415,"3"],[-1,48417,"重"],[1,48426,"*"],[-1,48426,"["],[1,48430,"\n"],[-1,48447,"重"],[1,48458,"\n"],[-1,48462,"运"],[1,48480,"\n"],[-1,48485,"["],[1,48514,"*"],[-1,48516,"重"],[1,48526,"_"],[-1,48531,"["],[1,48549,"\n"],[-1,48551,"重"],[-1,48555,"："],[1,48557,"："],[1,48558,"_"],[1,48561,"型_*_"],[-1,48561,"类型 类 "],[1,48582,"_型_"],[-1,48582,"类型 "],[1,48589,"\n"],[-1,48591,"设"],[1,48610,"\n\n *`   *"],[-1,48610," `x[y]"],[-1,48618,"可"],[1,48623,"\n"],[1,48626,"  "],[-1,48626,"x.o"],[1,48636,"     *"],[-1,48636,"[](y)"],[-1,48692,"\n\n"],[1,48700,"\n*.4*"],[-1,48700,"*4.重"],[1,48710,"*"],[-1,48710,"("],[1,48733,":式"],[-1,48733,"式: "],[1,48740,"_类 _:"],[-1,48740,"类型 类"],[1,48759,"_表达式_"],[-1,48759," 表达式表"],[1,48770,"*1\n* x*类 X*"],[-1,48770,"例1\n设 x是类 X的"],[1,48790,"*"],[-1,48792,"x"],[1,48811,"*"],[-1,48812,"可"],[1,48817,"*"],[-1,48818,"x"],[1,48850,"*"],[-1,48850,"\n\n"],[1,48854,"\n"],[-1,48856,"："],[1,48859,"：_例_"],[-1,48859,"\n例2"],[1,48867,"_"],[-1,48867,")"],[1,48879,"*"],[-1,48879,"象\n"],[1,48887,"\n"],[-1,49196,"\n"],[1,49200,"\n"],[1,49213,"_/_3_"],[-1,49213,"//例3用"],[1,49222,"_"],[-1,49222,"运"],[1,49230,"_员函数_*"],[-1,49230,"成员函数**\n"],[1,49243,"\n"],[1,49296,"*"],[-1,49296," "],[1,49302,"*"],[-1,49302,"n"],[1,49348,"*"],[-1,49348," "],[1,49354,"*"],[-1,49354,"n"],[1,49466,"*"],[-1,49466,"."],[1,49472,"*"],[-1,49472,"n"],[-1,49500,"\n"],[1,49511,"\n"],[-1,49513,"5"],[1,49515,"*"],[1,49521,"*&**|*"],[-1,49521,"载&&和||"],[-1,49533,"\n"],[1,49536,"\n"],[-1,49541,"\n"],[1,49546,"\n"],[-1,49566,"\n"],[1,49571,"\n\n"],[-1,49586,"则\n"],[1,49592,"\n\n"],[-1,49608,"的\n"],[1,49614,"\n\n"],[-1,49626,"递\n"],[1,49632,"\n\n"],[-1,49655,"则\n"],[1,49663,"则\n"],[1,51837,"|"],[1,51840,"lang"],[-1,51840,"cpp"],[1,51845,"```"],[-1,52384,"};\n\n"],[1,52402,"| \n\n"],[-1,52810,"\n\n};"],[1,52820," |\n\n"],[1,52843,"总"],[-1,52843,""],[-1,52895,"总"],[1,52897,"\n"],[-1,52902,"操"],[1,52919,"\n"],[-1,52923,"操"],[1,52945,"\n"],[-1,52949,"o"],[1,52969,"\n"],[-1,52974,"f"],[1,52996,"\n"],[-1,53001,"操"],[1,53016,"\n"],[-1,53020,"操"],[1,53040,"\n"],[-1,53044,"="],[1,53072,"\n"],[-1,53076,"+"],[1,53101,"\n"],[-1,53105,"C"]],[53114,53114],[44244,44244]]],[1543582285019,["gjx16@GJXAIOU",[[1,50435,"```"]],[50435,50435],[50438,50438]]],[1543582287667,["gjx16@GJXAIOU",[[1,50439,"\n"]],[50438,50438],[50439,50439]]],[1543582288216,["gjx16@GJXAIOU",[[1,50440,"\n"]],[50439,50439],[50440,50440]]],[1543582295859,["gjx16@GJXAIOU",[[1,50464,"#### "]],[50464,50464],[50469,50469]]],[1543582304693,["gjx16@GJXAIOU",[[1,50492,"#### "]],[50492,50492],[50497,50497]]],[1543582316189,["gjx16@GJXAIOU",[[1,50593,"```cpp"]],[50593,50593],[50599,50599]]],[1543582325274,["gjx16@GJXAIOU",[[1,50719,"```"]],[50719,50719],[50722,50722]]],[1543582329138,["gjx16@GJXAIOU",[[-1,50750,"| \n"]],[50750,50753],[50750,50750]]],[1543582333425,["gjx16@GJXAIOU",[[1,50750,"```cpp"]],[50750,50750],[50756,50756]]],[1543582400094,[null,[[1,44244,"- "],[-1,44268,"=,"],[1,44272,"=,"],[-1,44302,"**"],[1,44304,"）用"],[-1,44308,"**"],[1,44310,"重载"],[-1,44316,"**"],[1,44318,"操作"],[-1,44323,"Ø "],[1,44327,"is"],[-1,44356,"\nØ"],[1,44360,"ci"],[-1,44395,"\nØ"],[1,44399,"运算"],[-1,44432,"\nØ"],[1,44436,"运算"],[-1,44470,"\nØ"],[1,44474,"用友"],[-1,45435,"\n\n"],[1,45437,"\tc"],[-1,45541,"o\n3）"],[1,45547,"3）友元"],[1,45563,"- "],[-1,45565,"- "],[-1,45597,"\nb"],[1,45625,"b）"],[-1,45628,"\nØ"],[1,45634,"在第"],[-1,45667,"\nØ"],[1,45673,"友员"],[-1,45716,"\nØ"],[1,45722,"C+"],[-1,45738,"\n"],[1,45745,"="],[-1,45761,"**"],[1,45763,"）友"],[-1,45774,"***\n\n|` "],[1,45782,"类**\n``"],[1,45787,"#in"],[-1,45804,"\n"],[1,45807,"i"],[-1,45865,"\n"],[1,45870,"b"],[-1,45873," "],[-1,45876," v"],[1,45879,"vec"],[-1,45883," "],[1,45886,"t"],[-1,45893,"1"],[1,45895,"1"],[-1,45897,"1\n ~v\t"],[1,45903,"\n\n\t~ve"],[-1,45909," "],[-1,45912," in\t"],[1,45916,"\n\tint"],[-1,45930," "],[1,45933,"t"],[-1,45935," ) \n fr\t"],[1,45943,");\n\n\tfri"],[-1,45970," "],[1,45973,"t"],[-1,45986," "],[1,45989,"v"],[-1,45996," ) \n fr\t"],[1,46004,");\n\n\tfri"],[-1,46031," "],[1,46034,"t"],[-1,46056," ) "],[1,46059,");\n"],[-1,46067," : "],[1,46073,"int"],[-1,46077," "],[-1,46080," in\t"],[1,46084,"\n\tint"],[-1,46088," "],[1,46090,"\n"],[-1,46110," "],[1,46113,"t"],[-1,46118," "],[1,46123,"\tif"],[-1,46124,"i\t"],[-1,46150," "],[-1,46153," {"],[1,46160,"cou"],[-1,46205," "],[1,46208,"a"],[-1,46214," "],[-1,46217," }"],[1,46224,"v ="],[-1,46233," "],[-1,46236,"e ]  "],[1,46241,"ze]; l"],[-1,46250," "],[1,46254,"\n"],[-1,46275,"\n"],[-1,46278," d\t"],[1,46281,"\tdel"],[-1,46288," "],[-1,46291," le\t"],[1,46295,"\n\tlen"],[-1,46299," "],[1,46304,"\n"],[-1,46328," "],[1,46331,"t"],[-1,46333," )  \n i\t i  ="],[1,46346,")\n{\n\tif (i >= "],[-1,46349," "],[-1,46359," "],[1,46362,"r"],[-1,46370," i  \n co\t"],[1,46379,"i];\n\n\tcou"],[-1,46426," "],[1,46429,"a"],[-1,46435," "],[1,46440,"\n"],[-1,46463," "],[1,46466,"t"],[-1,46493," "],[1,46498,"\tfor"],[-1,46499,"f\t"],[-1,46504," "],[-1,46512," "],[1,46515,"i"],[-1,46525," "],[-1,46528," "],[1,46529,"i"],[-1,46533," o"],[1,46537,"out"],[-1,46548," i "],[1,46551,"i]"],[1,46553,"<"],[-1,46557," "],[-1,46560," ou\t"],[1,46564,"\n\tout"],[-1,46575," "],[-1,46578," r\t"],[1,46581,"\tret"],[-1,46591," "],[1,46595,"\n"],[-1,46619," "],[1,46622,"t"],[-1,46648," "],[-1,46653," f\t( i n"],[1,46661,"\tfor (int"],[-1,46667," "],[1,46670,"i"],[-1,46680," "],[-1,46683," "],[1,46684,"i"],[-1,46688," i"],[1,46692,"inp"],[-1,46702," i  \n re\t"],[1,46711,"i];\n\n\tret"],[-1,46720," "],[1,46725,"\n"],[-1,46737,"\n"],[-1,46740," i\t"],[1,46743,"\tint"],[-1,46745," "],[-1,46748," c\t"],[1,46751,"\tcou"],[-1,46790," "],[-1,46793," c\t"],[1,46796,"\tcin"],[-1,46801," "],[-1,46804," v"],[1,46807,"vec"],[-1,46813," k  \n c\t"],[1,46821,"k);\n\tcou"],[-1,46862," "],[-1,46865," c"],[1,46868,"cin"],[-1,46873," "],[-1,46876," c"],[1,46879,"cou"],[-1,46921," "],[-1,46924," c\t"],[1,46927,"\tcou"],[-1,46933," "],[-1,46936," s\t"],[1,46939,"\tsys"],[-1,46953,"\n"],[-1,46956," |"],[1,46962,"\n\n"],[1,46964,"#"],[-1,46977,"**1"],[-1,46987,"*."],[1,46989,"1.运算符"],[-1,47019,"**2"],[-1,47029,"*."],[1,47031,"2.重载赋"],[-1,47035,"*"],[1,47036,"="],[-1,47040,"Ø 赋* "],[1,47045,"* 赋值运"],[-1,47059,"\nØ "],[1,47064,"ope"],[-1,47081,"\nØ "],[1,47086,"重"],[-1,47094,"\n"],[-1,47097,"型_*名_"],[1,47102,"类型&类名:"],[-1,47121,"*"],[1,47124,"类"],[-1,47125,"_"],[1,47127,"&"],[-1,47131,"*"],[1,47132,"\n"],[-1,47151,"\n"],[-1,47176," "],[1,47178,"\n "],[-1,47183,"\n1 /"],[1,47187," 1 先"],[-1,47194,"\n"],[1,47195," "],[-1,47204,"\n"],[1,47205," "],[-1,47216,"\n"],[-1,48406,"|"],[1,48407,"\n"],[-1,48414,"3"],[1,48416,"3"],[1,48417,"重"],[-1,48425,"*"],[1,48426,"["],[-1,48429,"\n"],[1,48447,"重"],[-1,48457,"\n"],[1,48462,"运"],[-1,48479,"\n"],[1,48485,"["],[-1,48513,"*"],[1,48516,"重"],[-1,48525,"_"],[1,48531,"["],[-1,48548,"\n"],[1,48551,"重"],[1,48554,"："],[-1,48555,"："],[-1,48557,"_"],[-1,48561,"型_*_"],[1,48565,"类型 类 "],[-1,48581,"_型_"],[1,48584,"类型 "],[-1,48588,"\n"],[1,48591,"设"],[-1,48609,"\n\n *`   *"],[1,48618," `x[y]"],[1,48620,"可"],[-1,48624,"\n"],[-1,48628,"  "],[1,48630,"x.o"],[-1,48637,"     *"],[1,48643,"[](y)"],[1,48694,"\n\n"],[-1,48700,"\n*.4*"],[1,48705,"*4.重"],[-1,48711,"*"],[1,48712,"("],[-1,48734,":式"],[1,48736,"式: "],[-1,48740,"_类 _:"],[1,48745,"类型 类"],[-1,48760,"_表达式_"],[1,48765," 表达式表"],[-1,48771,"*1\n* x*类 X*"],[1,48782,"例1\n设 x是类 X的"],[-1,48791,"*"],[1,48794,"x"],[-1,48812,"*"],[1,48814,"可"],[-1,48818,"*"],[1,48820,"x"],[-1,48851,"*"],[1,48852,"\n\n"],[-1,48854,"\n"],[1,48857,"："],[-1,48859,"：_例_"],[1,48863,"\n例2"],[-1,48868,"_"],[1,48869,")"],[-1,48880,"*"],[1,48881,"象\n"],[-1,48887,"\n"],[1,49197,"\n"],[-1,49200,"\n"],[-1,49214,"_/_3_"],[1,49219,"//例3用"],[-1,49223,"_"],[1,49224,"运"],[-1,49231,"_员函数_*"],[1,49237,"成员函数**\n"],[-1,49243,"\n"],[-1,49297,"*"],[1,49298," "],[-1,49303,"*"],[1,49304,"n"],[-1,49349,"*"],[1,49350," "],[-1,49355,"*"],[1,49356,"n"],[-1,49467,"*"],[1,49468,"."],[-1,49473,"*"],[1,49474,"n"],[1,49501,"\n"],[-1,49511,"\n"],[1,49514,"5"],[-1,49515,"*"],[-1,49522,"*&**|*"],[1,49528,"载&&和||"],[1,49534,"\n"],[-1,49536,"\n"],[1,49542,"\n"],[-1,49546,"\n"],[1,49567,"\n"],[-1,49571,"\n\n"],[1,49588,"则\n"],[-1,49592,"\n\n"],[1,49610,"的\n"],[-1,49614,"\n\n"],[1,49628,"递\n"],[-1,49632,"\n\n"],[1,49657,"则\n"],[-1,49663,"则\n"],[1,50435,"\n\n"],[-1,50438,"\n\n"],[1,50464,"\n\n"],[-1,50469,"\n\n"],[1,50492,"\n\n"],[-1,50497,"\n\n"],[1,50593,"串\n"],[-1,50599,"串\n"],[1,50719,";\n"],[-1,50722,";\n"],[1,50750,"\n\n"],[-1,50756," \n"],[-1,51866,"|"],[-1,51870,"lang"],[1,51874,"cpp"],[-1,51876,"```"],[1,52418,"};\n\n"],[-1,52432,"| \n\n"],[1,52845,"\n};\n"],[-1,52848,"\n\n |"],[-1,52877,"总"],[1,52878,""],[1,52930,"总"],[-1,52931,"\n"],[1,52937,"操"],[-1,52953,"\n"],[1,52958,"操"],[-1,52979,"\n"],[1,52984,"o"],[-1,53003,"\n"],[1,53009,"f"],[-1,53030,"\n"],[1,53036,"操"],[-1,53050,"\n"],[1,53055,"操"],[-1,53074,"\n"],[1,53079,"="],[-1,53106,"\n"],[1,53111,"+"],[-1,53135,"\n"],[1,53140,"C"]],[44244,44244],[53141,53141]]],[1543582400094,[null,[[-1,44244,"- "],[1,44270,"=,"],[-1,44272,"=,"],[1,44304,"**"],[-1,44304,"）用"],[1,44310,"**"],[-1,44310,"重载"],[1,44318,"**"],[-1,44318,"操作"],[1,44325,"Ø "],[-1,44327,"is"],[1,44358,"\nØ"],[-1,44360,"ci"],[1,44397,"\nØ"],[-1,44399,"运算"],[1,44434,"\nØ"],[-1,44436,"运算"],[1,44472,"\nØ"],[-1,44474,"用友"],[1,45437,"\n\n"],[-1,45437,"\tc"],[1,45543,"o\n3）"],[-1,45545,"3）友元"],[-1,45565,"- "],[1,45569,"- "],[1,45599,"\nb"],[-1,45625,"b）"],[1,45630,"\nØ"],[-1,45634,"在第"],[1,45669,"\nØ"],[-1,45673,"友员"],[1,45718,"\nØ"],[-1,45722,"C+"],[1,45740,"\n"],[-1,45746,"="],[1,45763,"**"],[-1,45763,"）友"],[1,45776,"***\n\n|` "],[-1,45776,"类**\n``"],[-1,45787,"#in"],[1,45807,"\n"],[-1,45809,"i"],[1,45868,"\n"],[-1,45872,"b"],[1,45876," "],[1,45878," v"],[-1,45879,"vec"],[1,45886," "],[-1,45888,"t"],[1,45896,"1"],[-1,45897,"1"],[1,45900,"1\n ~v\t"],[-1,45900,"\n\n\t~ve"],[1,45912," "],[1,45914," in\t"],[-1,45914,"\n\tint"],[1,45933," "],[-1,45935,"t"],[1,45938," ) \n fr\t"],[-1,45938,");\n\n\tfri"],[1,45973," "],[-1,45975,"t"],[1,45989," "],[-1,45991,"v"],[1,45999," ) \n fr\t"],[-1,45999,");\n\n\tfri"],[1,46034," "],[-1,46036,"t"],[1,46059," ) "],[-1,46059,");\n"],[1,46070," : "],[-1,46073,"int"],[1,46080," "],[1,46082," in\t"],[-1,46082,"\n\tint"],[1,46091," "],[-1,46092,"\n"],[1,46113," "],[-1,46115,"t"],[1,46121," "],[-1,46125,"\tif"],[1,46129,"i\t"],[1,46153," "],[1,46155," {"],[-1,46160,"cou"],[1,46208," "],[-1,46210,"a"],[1,46217," "],[1,46219," }"],[-1,46224,"v ="],[1,46236," "],[1,46238,"e ]  "],[-1,46238,"ze]; l"],[1,46253," "],[-1,46256,"\n"],[1,46278,"\n"],[1,46280," d\t"],[-1,46280,"\tdel"],[1,46291," "],[1,46293," le\t"],[-1,46293,"\n\tlen"],[1,46302," "],[-1,46306,"\n"],[1,46331," "],[-1,46333,"t"],[1,46336," )  \n i\t i  ="],[-1,46336,")\n{\n\tif (i >= "],[1,46353," "],[1,46362," "],[-1,46364,"r"],[1,46373," i  \n co\t"],[-1,46373,"i];\n\n\tcou"],[1,46429," "],[-1,46431,"a"],[1,46438," "],[-1,46442,"\n"],[1,46466," "],[-1,46468,"t"],[1,46496," "],[-1,46500,"\tfor"],[1,46505,"f\t"],[1,46508," "],[1,46515," "],[-1,46517,"i"],[1,46528," "],[1,46530," "],[-1,46530,"i"],[1,46535," o"],[-1,46537,"out"],[1,46551," i "],[-1,46551,"i]"],[-1,46555,"<"],[1,46560," "],[1,46562," ou\t"],[-1,46562,"\n\tout"],[1,46578," "],[1,46580," r\t"],[-1,46580,"\tret"],[1,46594," "],[-1,46597,"\n"],[1,46622," "],[-1,46624,"t"],[1,46651," "],[1,46655," f\t( i n"],[-1,46655,"\tfor (int"],[1,46670," "],[-1,46672,"i"],[1,46683," "],[1,46685," "],[-1,46685,"i"],[1,46690," i"],[-1,46692,"inp"],[1,46705," i  \n re\t"],[-1,46705,"i];\n\n\tret"],[1,46723," "],[-1,46727,"\n"],[1,46740,"\n"],[1,46742," i\t"],[-1,46742,"\tint"],[1,46748," "],[1,46750," c\t"],[-1,46750,"\tcou"],[1,46793," "],[1,46795," c\t"],[-1,46795,"\tcin"],[1,46804," "],[1,46806," v"],[-1,46807,"vec"],[1,46816," k  \n c\t"],[-1,46816,"k);\n\tcou"],[1,46865," "],[1,46867," c"],[-1,46868,"cin"],[1,46876," "],[1,46878," c"],[-1,46879,"cou"],[1,46924," "],[1,46926," c\t"],[-1,46926,"\tcou"],[1,46936," "],[1,46938," s\t"],[-1,46938,"\tsys"],[1,46956,"\n"],[1,46958," |"],[-1,46962,"\n\n"],[-1,46966,"#"],[1,46980,"**1"],[1,46987,"*."],[-1,46987,"1.运算符"],[1,47022,"**2"],[1,47029,"*."],[-1,47029,"2.重载赋"],[1,47038,"*"],[-1,47038,"="],[1,47043,"Ø 赋* "],[-1,47043,"* 赋值运"],[1,47062,"\nØ "],[-1,47064,"ope"],[1,47084,"\nØ "],[-1,47086,"重"],[1,47095,"\n"],[1,47097,"型_*名_"],[-1,47097,"类型&类名:"],[1,47122,"*"],[-1,47124,"类"],[1,47126,"_"],[-1,47127,"&"],[1,47132,"*"],[-1,47132,"\n"],[1,47152,"\n"],[1,47176," "],[-1,47177,"\n "],[1,47184,"\n1 /"],[-1,47184," 1 先"],[1,47195,"\n"],[-1,47195," "],[1,47205,"\n"],[-1,47205," "],[1,47217,"\n"],[1,48406,"|"],[-1,48406,"\n"],[1,48414,"3"],[-1,48415,"3"],[-1,48417,"重"],[1,48426,"*"],[-1,48426,"["],[1,48430,"\n"],[-1,48447,"重"],[1,48458,"\n"],[-1,48462,"运"],[1,48480,"\n"],[-1,48485,"["],[1,48514,"*"],[-1,48516,"重"],[1,48526,"_"],[-1,48531,"["],[1,48549,"\n"],[-1,48551,"重"],[-1,48555,"："],[1,48557,"："],[1,48558,"_"],[1,48561,"型_*_"],[-1,48561,"类型 类 "],[1,48582,"_型_"],[-1,48582,"类型 "],[1,48589,"\n"],[-1,48591,"设"],[1,48610,"\n\n *`   *"],[-1,48610," `x[y]"],[-1,48618,"可"],[1,48623,"\n"],[1,48626,"  "],[-1,48626,"x.o"],[1,48636,"     *"],[-1,48636,"[](y)"],[-1,48692,"\n\n"],[1,48700,"\n*.4*"],[-1,48700,"*4.重"],[1,48710,"*"],[-1,48710,"("],[1,48733,":式"],[-1,48733,"式: "],[1,48740,"_类 _:"],[-1,48740,"类型 类"],[1,48759,"_表达式_"],[-1,48759," 表达式表"],[1,48770,"*1\n* x*类 X*"],[-1,48770,"例1\n设 x是类 X的"],[1,48790,"*"],[-1,48792,"x"],[1,48811,"*"],[-1,48812,"可"],[1,48817,"*"],[-1,48818,"x"],[1,48850,"*"],[-1,48850,"\n\n"],[1,48854,"\n"],[-1,48856,"："],[1,48859,"：_例_"],[-1,48859,"\n例2"],[1,48867,"_"],[-1,48867,")"],[1,48879,"*"],[-1,48879,"象\n"],[1,48887,"\n"],[-1,49196,"\n"],[1,49200,"\n"],[1,49213,"_/_3_"],[-1,49213,"//例3用"],[1,49222,"_"],[-1,49222,"运"],[1,49230,"_员函数_*"],[-1,49230,"成员函数**\n"],[1,49243,"\n"],[1,49296,"*"],[-1,49296," "],[1,49302,"*"],[-1,49302,"n"],[1,49348,"*"],[-1,49348," "],[1,49354,"*"],[-1,49354,"n"],[1,49466,"*"],[-1,49466,"."],[1,49472,"*"],[-1,49472,"n"],[-1,49500,"\n"],[1,49511,"\n"],[-1,49513,"5"],[1,49515,"*"],[1,49521,"*&**|*"],[-1,49521,"载&&和||"],[-1,49533,"\n"],[1,49536,"\n"],[-1,49541,"\n"],[1,49546,"\n"],[-1,49566,"\n"],[1,49571,"\n\n"],[-1,49586,"则\n"],[1,49592,"\n\n"],[-1,49608,"的\n"],[1,49614,"\n\n"],[-1,49626,"递\n"],[1,49632,"\n\n"],[-1,49655,"则\n"],[1,49663,"则\n"],[-1,50433,"\n\n"],[1,50438,"\n\n"],[-1,50462,"\n\n"],[1,50469,"\n\n"],[-1,50490,"\n\n"],[1,50497,"\n\n"],[-1,50591,"串\n"],[1,50599,"串\n"],[-1,50717,";\n"],[1,50722,";\n"],[-1,50748,"\n\n"],[1,50756," \n"],[1,51864,"|"],[1,51867,"lang"],[-1,51867,"cpp"],[1,51872,"```"],[-1,52411,"};\n\n"],[1,52429,"| \n\n"],[-1,52838,"\n};\n"],[1,52845,"\n\n |"],[1,52870,"总"],[-1,52870,""],[-1,52922,"总"],[1,52924,"\n"],[-1,52929,"操"],[1,52946,"\n"],[-1,52950,"操"],[1,52972,"\n"],[-1,52976,"o"],[1,52996,"\n"],[-1,53001,"f"],[1,53023,"\n"],[-1,53028,"操"],[1,53043,"\n"],[-1,53047,"操"],[1,53067,"\n"],[-1,53071,"="],[1,53099,"\n"],[-1,53103,"+"],[1,53128,"\n"],[-1,53132,"C"]],[53141,53141],[44244,44244]]],[1543582348251,["gjx16@GJXAIOU",[[-1,51621," |"]],[51621,51623],[51621,51621]]],[1543582349972,["gjx16@GJXAIOU",[[1,51621,"```"]],[51621,51621],[51624,51624]]],[1543582354923,["gjx16@GJXAIOU",[[-1,51629,"****"]],[51629,51633],[51629,51629]]],[1543582357281,["gjx16@GJXAIOU",[[1,51626,"\n"]],[51626,51626],[51627,51627]]],[1543582360078,["gjx16@GJXAIOU",[[1,51627,"#### "]],[51627,51627],[51632,51632]]],[1543582365890,["gjx16@GJXAIOU",[[-1,51652,"\n"]],[51652,51652],[51651,51651]]],[1543582370735,["gjx16@GJXAIOU",[[-1,51704,"\n"]],[51704,51704],[51703,51703]]],[1543582373001,["gjx16@GJXAIOU",[[-1,51753,"\n"]],[51753,51753],[51752,51752]]],[1543582377359,["gjx16@GJXAIOU",[[-1,51768,"\n"]],[51768,51768],[51767,51767]]],[1543582381479,["gjx16@GJXAIOU",[[1,51753,"  "]],[51753,51753],[51755,51755]]],[1543582383906,["gjx16@GJXAIOU",[[-1,51786,"\n"]],[51786,51786],[51785,51785]]],[1543582385271,["gjx16@GJXAIOU",[[-1,51805,"\n"]],[51805,51805],[51804,51804]]],[1543582386532,["gjx16@GJXAIOU",[[-1,51832,"\n"]],[51832,51832],[51831,51831]]],[1543582391049,["gjx16@GJXAIOU",[[-1,51870,"\n"]],[51869,51869],[51868,51868]]],[1543582392441,["gjx16@GJXAIOU",[[-1,51869,"\n"]],[51869,51869],[51868,51868]]]],null,"gjx16@GJXAIOU"],["03871549-afcc-4e71-b3a2-027476ac8a3e",1543583301016,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁;\n   * c++面向对象模型初探;  \n   * c++面向对象多态原理探究;\n   * 操作符重载;\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;//定义两个对象c1和c2\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n};\n\n```\nTeacher.cpp\n//具体实现函数内容，在函数名前面加上`类名::`\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1:设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)//因为类的成员变量这里都是private:\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n###  (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n###  (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//需要重载=号操作符，才能解决带来的浅拷贝问题\n\n\tobj2 = obj3; //=号操作，也是一种浅拷贝\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++的默认copy构造函数是浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n\n---\n\n\n### （五）多个对象构造和析构\n\n**1.对象初始化列表**\n\n- 1）对象初始化列表出现原因\n程序本身是有问题的\n```cpp\n\n/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B   //在一个类里面组合了一个带有参数的构造函数的类，因为C++编译器要确定分配给B多大的内存，但是没法初始化A定义的两个对象（因为需要调用有参的构造函数）\n{\npublic:   //没有写B的构造函数，按理说应该调用默认的构造函数\n\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  //主要是因为没有方法和没有机会去初始化这两个A定义的对象\n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB;\n\treturn 0;\n\n}\n\n```\n\n解决方法：\n```cpp\n/*\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n};\n\n\nclass B  \n{\npublic:   \n//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）\n\tB(int _a, int _b) : a1(1), a2(3)  \n\t{\n\n\t}\n//第二种参数传递的方法：\n/*\nB(int _a, int _b,int m,int n) : a1(m), a2(n)  \n\t{\n      a = _a;\n      b = _b;\n\t}\n\t\n*/\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  \n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB(1,2);\n\t//第二种方式：B objB(1,2,4,3)\n\treturn 0;\n\n}\n\n```\n\n**以上程序的操作顺序：**\n首先执行被组合对象的构造函数（a1,a2），如果有多个组合对象，则按照定义的顺序，而不是按照初始化列表的顺序（：后面的顺序）\n析构函数：和构造函数的调用顺序相反\n\n  - 1.必须这样做：\n    - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    - 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n  - 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    - 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    - 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n- 2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n```cpp\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n{\n // some other assignment operation\n}\n```\n\n\n- 3）注意概念\n  - 初始化：被初始化的对象正在创建\n  - 赋值：被赋值的对象已经存在\n\n- 4）注意：\n  - 成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n  - 初始化列表先于构造函数的函数体执行\n\n**说明：**\n\n* 1 C++中提供了初始化列表对成员变量进行初始化\n* 2 使用初始化列表出现原因：\n  * 1.必须这样做：\n    * 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n    * 而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    * 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n  * 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    * 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    * 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n```cpp\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n ABC(int a, int b, int c)\n {\n this->a = a;\n this->b = b;\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"ABC construct ..\\n\");\n }\n\n ~ABC()\n {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n }\n\nprotected:\nprivate:\n int a;\n int b;\n int c;\n};\n\nclass MyD\n{\npublic:\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n {\n cout<<\"MyD()\"<<endl;\n }\n\n ~MyD()\n {\n cout<<\"~MyD()\"<<endl;\n }\n\nprotected:\nprivate:\n ABC abc1; //c++编译器不知道如何构造abc1\n ABC abc2;\n const int m;\n};\n\nint run()\n{\n MyD myD;\n return 0;\n}\n\nint main_dem03()\n{\n run();\n system(\"pause\");\n return 0;\n}\n\n```\n\n\n\n\n### （六）构造函数和析构函数的调用顺序研究\n\n**构造函数与析构函数的调用顺序**\n\n- 1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n- 2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n### （七）构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1构造析构综合训练**\n```cpp\n\n/*\n\n总结 构造和析构的调用顺序\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n\tABC(int a, int b, int c)   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\n\t}\n\n\t~ABC()\n\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\n\nclass MyD \n{\npublic:\n\tMyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~MyD()\n\t{\n\t\tcout << \"~MyD()\" << endl;\n\t}\n\n\tMyD(const MyD & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\tcout << \"MyD(const MyD &obj)\" << endl;\n\t}\n\nprotected:\nprivate:\n\tABC abc1; //c++编译器不知道如何构造abc1//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\tABC abc2;\n\tconst int m;//因为是const m,所以上面所有的m都进行了赋值\n};\n\n\nint doThing(MyD myel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;\n}\n\n\nint run2()//二\n{\n\tMyD myD;//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\treturn 0;\n}\n\nint run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main()\n{\n\trun2();//一\n\t//run3();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n\n\n```\n\n\n**2匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3匿名对象强化训练**\n\n3） 构造中调用构造\n\n```cpp\n/*\n\n构造中调用构造\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass MyTest\n{\npublic:\n\tMyTest(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t}\n\n\tMyTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\n\t\tMyTest(a, b, 10);\n\t}\n\n\t~MyTest()\n\t{\n\t\tcout << \"MyTest is ...\" << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n\n\npublic:\n\tint getC() const { return c; }\n\n\tvoid setC(int val) { c = val; }\n};\n\nint main()\n{\n\tMyTest t1(1, 2);\n\tcout << t1.getC() << endl;\n\tsystem(\"pause\");\n\treturn 0;\n\t\n}\n\n\n```\n\n 结论： 构造函数中调用构造函数，是一个蹩脚的行为。\n程序内存图：\n![搜狗截图20181124125452]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181124125452.png)\n\n### （八）对象的动态建立和释放\n\n**1.new和delete基本语法**\n```cpp\n/*\n\nnew 和delete的使用\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nvoid main()\n{\n\t//先分配内存然后赋值\n\tint *p = new int;  //分配基础类型\n\t*p = 20;  \n\n\t//在定义的时候直接分配内存\n\tint *p1 = new int(30);\n\tcout << *p1 << endl;\n\n\tsystem(\"pause\");\n\treturn; \n}\n\n```\n\n- 1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n  **注意： new和delete是运算符，不是函数，因此执行效率高。**\n\n- 2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： \nnew int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 \nnew char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址    new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n- 3）new和delete运算符使用的一般格式为：\n  用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n![new运算符动态]($resource/new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%A8%E6%80%81.png)\n```cpp\n\n/*\n使用malloc /free 与new /delete的区别\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest();\n\t~Test();\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\nTest::Test()\n{\n\tcout << \"执行了构造函数\" << endl;\n}\n\nTest::~Test()\n{\n\tcout << \"执行了析构函数\" << endl;\n}\n\n\n\nint main()\n{\n\t//基础类型\n\tint *p1 = (int *)malloc(sizeof(int));\n\t*p1 = 10;\n\tdelete p1;\n\n\tint *p2 = new int;\n\t*p2 = 20;\n\tfree(p2);\n\n\n\n\t//数组类型（元素为基础类型）\n\tint *p3 = (int *)malloc(sizeof(int)*10);\n\tp3[0] = 1;\n\tdelete[]p3;\n\n\tint *p4 = new int[10];\n\tp4[1] = 2;\n\tfree(p4);\n\n\n\t//类\n\tTest *p5 = (Test *)malloc(sizeof(Test));\n\tdelete p5;\n\n\tTest *p6 = new Test(10);\n\tfree(p6);\n}\n\n\n```\n**结论：** \nnew：不仅分配内存，而且调用了构造函数\ndelete:不仅释放了内存，而且调用了析构函数\n\n- 4） 应用举例\n\n![5]($resource/5.png)\n\n**2类对象的动态建立和释放**\n\n- 使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n-  C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n  比如：\n\n  Box *pt;  //定义一个指向Box类对象的指针变量pt\n      pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n   这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n  新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n   在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3.编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n\n\n\n## 四、静态成员变量和成员函数\n\n\n思考：每个变量，拥有属性。有没有一些属性，归所有对象拥有？\n\n### （一）静态成员变量\n\n- **1定义静态成员变量**\n  - 关键字 **static**  可以用于说明一个类的成员，\n    静态成员提供了一个同类对象的共享机制\n\n  - 把一个类的成员说明为 **static**  时，这个类无论有多少个对象被创建，这些对象共享这个 **static**  成员\n\n  - 静态成员局部于类，它不是对象成员\n\n![1]($resource/1.png)\n\n例如：\n\n```cpp\n\n/*\n静态成员变量\n*/\n\n#include<iostream>\nusing namespace std;\n\nclass counter\n{\n\n\tstatic int num; //**声明与定义静态数据成员**\n\npublic:\n\n\tvoid setnum(int i) \n\t{ \n\t\tnum = i; \n\t} //成员函数访问静态数据成员\n\n\tvoid shownum() \n\t{ \n\t\tcout << num << endl;\n\t}\n\n};\n\nint counter::num = 0;//声明与定义静态数据成员\n\nvoid main()\n{\n\tcounter a, b;\n\n\ta.shownum(); //调用成员函数访问私有静态数据成员\n\tb.shownum();\n\ta.setnum(10);\n\ta.shownum();\n\tb.shownum();\n\n}\n\n```\n\n![6]($resource/6.png)\n\n**从结果可以看出，访问的是同一个静态数据成员**\n\n- **2使用静态成员变量**\n```cpp\n//例5-14_使用公有静态数据成员\n\n#include<iostream.h>\n\nclass counter\n{ \npublic :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n\n```\n使用静态成员函数调用静态成员变量\n```cpp\n/*\n静态成员函数\n*/\n// 结论：在静态成员函数中可以使用静态成员变量，但是不能使用类中普通的成员变量\n\n#include\"iostream\"\nusing namespace std;\n\nclass BB\n{\npublic:\n\tint printC()\n\t{\n\t\tcout << \"c:\" << c << endl;\n\t\treturn c;\n\t}\n\n\tint addC()\n\t{\n\t\tc = c+1;\n\t}\n\n\n\tstatic void getC()\n\t{\n\t\tcout << \"c\" << c << endl;  //可以直接在静态成员函数中使用静态成员变量，但是不能直接使用一般变量\n\t}\nprivate:\n\tint a;\n\tint b;\n\tstatic int c;\n\n};\n\n\nint BB::c = 10;  //初始化成员变量值\n\nvoid main()\n{\n\tBB b1, b2, b3;\n\tb1.printC();//10\n\tb2.addC();//11\n\tb3.printC();//11\n\n\t//调用成员函数两种方法；\n\tb3.getC();//使用对象.\n\tBB::getC();//使用类::\n\n\n\n}\n\n```\n\n### (二)静态成员函数\n\n- **1）概念**\n\n  - 静态成员函数数冠以关键字static\n\n  - 静态成员函数提供不依赖于类数据结构的共同操作，它没有this指针\n  - 在类外调用静态成员函数用 `_类名_ ::`作限定词，或通过对象调用\n\n- **2）案例**\n![7]($resource/7.png)\n\n- **3）疑难问题：**\n静态成员函数中，不能使用普通变量。\n//静态成员变量属于整个类的，分不清楚，是那个具体对象的属性。\n![成员函数中的疑难问题]($resource/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98.png)\n\n**4.3 综合训练**\n\n\n\n## 五、 C++面向对象模型初探\n\n**前言**\n\n- C++对象模型可以概括为以下2部分：\n\n  - 1. 语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等等。\n\n  - 2. 对于各种支持的底层实现机制。\n\n  在c语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。在c++中，通过抽象数据类型（abstract data type，ADT），在类中定义数据和函数，来实现数据和函数直接的绑定。\n\n  概括来说，在C++类中有两种成员数据：static、nonstatic；三种成员函数：static、nonstatic、virtual。\n\n![C++类的组成]($resource/C++%E7%B1%BB%E7%9A%84%E7%BB%84%E6%88%90.png)\n\n### （一）基础知识\n\nC++中的class从面向对象理论出发，将变量(属性)和函数(方法)集中定义在一起，用于描述现实世界中的类。从计算机的角度，程序依然由数据段和代码段构成。\n\n**C++编译器如何完成面向对象理论到计算机程序的转化？**\n换句话：C++编译器是如何管理类、对象、类和对象之间的关系\n具体的说：具体对象调用类中的方法，那，c++编译器是如何区分，是那个具体的类，调用这个方法那?\n\n思考一下程序结果\n```cpp\n/*\n面向对象模型初探\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass C1\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\nprotected:\n\nprivate:\n\n}; //12\n\nclass C2\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\n\tstatic int m; \n\npublic:\n\n\tint getK() const { return k; } //方法是属于代码，应该放在代码区\n\tvoid setK(int val) { k = val; } \n\nprotected:\n\nprivate:\n}; \n\nstruct S1\n{\n\tint i;\n\tint j;\n\tint k;\n}; \n\nstruct S2\n{\n\tint i;\n\tint j;\n\tint k;\n\tstatic int m;\n}; \n\nint main()\n{\n\n\tprintf(\"c1:%d \\n\", sizeof(C1));\n\tprintf(\"c2:%d \\n\", sizeof(C2));\n\tprintf(\"s1:%d \\n\", sizeof(S1));\n\tprintf(\"s2:%d \\n\", sizeof(S2));\n\tsystem(\"pause\");\n\n}\n```\n程序运行结果：\n`c1:12`\n`c2:12`\n`s1:12`\n`s2:12`\n\n \n### (二)编译器对属性和方法的处理机制\n\n通过上面的案例，我们可以的得出：\n1）C++类对象中的成员变量和成员函数是分开存储的\n- 成员变量：\n  - 普通成员变量：存储于对象中，与struct变量有相同的内存布局和字节对齐方式\n  - 静态成员变量：存储于全局数据区中\n\n- 成员函数：存储于代码段中。\n问题出来了：很多对象共用一块代码？代码是如何区分具体对象的那？\n换句话说：int getK() const { return k; }，代码是如何区分，具体obj1、obj2、obj3对象的k值？\n\n2）C++编译器对普通成员函数的内部处理\n\n![C++编译器对普通成员函数的内部处理]($resource/C++%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E9%83%A8%E5%A4%84%E7%90%86.png)\n\n请仔细思考，并说出你的总结！\n\n\n\n### （三）总结\n\n1、C++类对象中的成员变量和成员函数是分开存储的。C语言中的内存四区模型仍然有效！\n**2、C++中类的普通成员函数都隐式包含一个指向当前对象的this指针。**\n3、静态成员函数、成员变量属于类\n\n静态成员函数与普通成员函数的区别\n\n静态成员函数不包含指向具体对象的指针\n\n普通成员函数包含一个指向具体对象的指针\n\n\n### （四）this指针\n\n![this指针图示]($resource/this%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png)\n\n实验1：若类成员函数的形参 和 类的属性（成员变量）名字相同，通过this指针来解决。\n```cpp\n\n/*\nthis 指针\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass Test\n{\npublic:\n\tTest( int a, int b)//Test(Test *this, int a, int b)//因为这里成员函数的形参和成员变量一样，不用this指针会出现：a = a ,b = b;\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printT()\n\t{\n\t\tcout << \"a; \" << a << endl;\n\t\tcout << \"b: \" << this->b << endl;\n\t}\n\n\n    const void hello(int a,int b )\n    {\n      //下面这两个语句都是错误的\n      this->a = 100;\n      this ->b = 200;\n    }\n   //const修饰的this指针，即相当于this指针指向的内存空间不能被修改\n   //因为上面的函数会别C++编译器解析为:void hello(const Test *this, int a ,int b)\n   //同时上面的const其实下载函数（）外面的任何位置都行\n   \nprotected:\nprivate:\n\tint a;\n\tint b;\n};\nint  main()\n{\n\tTest t1(1, 2);\n\tt1.printT();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`a:1`\n`b:2`\n\n\n实验2：类的成员函数可通过const修饰，请问const修饰的是谁\n\n\n### （五）全局函数PK成员函数\n\n 1、把全局函数转化成成员函数，通过this指针隐藏左操作数\n\n   Test add(Test &t1, Test &t2)===》Test add( Test &t2)\n```cpp\n/*\n全局函数与成员函数\n*/\n\n\n//使用全局函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\t\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nTest Testadd(Test &t1, Test &t2)\n{\n\tTest tmp(3,4);\n\treturn tmp;\n}\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3(2, 3);\n\tt3= Testadd(t1, t2);\n}\n```\n\n```cpp\n//使用成员函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\tTest Testadd(Test &t2)\n\t{\n\t\tTest tmp(this->a + t2.a, this->b + t2.b);\n\t\treturn tmp;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3 = t1.Testadd(t2);//匿名对象直接转化成t4\n\tTest t4(3,5);\n\tt4 = t1.Testadd(t2);  //匿名对象复制给t5\n}\n\n\n```\n 2、把成员函数转换成全局函数，多了一个参数\n\n   void printAB()===》void printAB(Test *pthis)\n\n 3、函数返回元素和返回引用\n```cpp\nTest& add(Test &t2) //*this //函数返回引用,相当于返回自身，谁调用返回谁\n {      \n   this->a = this->a + t2.getA();\n\n   this->b = this->b + t2.getB();\n\n   return *this; //*操作让this指针回到元素状态\n\n }\n\nTest add2(Test &t2) //*this //函数返回元素\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n return t3;\n\n }\n\n void add3(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n //return t3;\n\n }\n  \n\n```\n\n\n\n\n---\n\n## 六、友元\n\n### （一）友元函数\n- 首先友元函数是全局函数，在友元函数中可以修改类的私有属性；\n- 友元函数在类中的声明位置位于public或者private只下均可；\n![8]($resource/8.png)\n\n```cpp\n//友元函数：\n\n#include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend void modify(A *PA,int _a);  //友元函数的声明\n\n\tA(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\n\nprivate:\n\tint a;\n\tint b;\n};\n\nvoid modify(A *PA,int _a)//后面的参数可加可不加\n{\n\t//PA->a = 100;//可以这样直接修改值\n\tPA->a = _a;  //通过传递的值进行修改\n}\n\n\nint main()\n{\n\tA a1(1, 2);\n\tcout << \"a:\" << a1.getA() << endl;\n\tmodify(&a1,20);\n\n\tint aa = a1.getA();\n\n\tcout << \"aa:\" << aa << endl;\n}\n```\n![9]($resource/9.png)\n\n\n### （二）友元类\n\n- 若B类是A类的友员类，则B类的所有成员函数都是A类的友员函数\n- 若B类是A类的友元类，则B类可以直接修改A的成员变量和成员函数\n- 友员类通常设计为一种对数据操作或类之间传递消息的辅助类\n程序示例：\n```cpp\n//友元类\n #include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend class B;//将B 声明为A的友元类，这样B 可以直接修改A的成员变量和成员函数 \n\n\tA(int a=0, int b=0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B\n{\npublic:\n\n\tvoid set(int a)\n\t{\n\t\tobjA.a = a;\n\t}\n\n\tvoid printa()\n\t{\n\t\tcout << objA.a << endl;\n\t}\n\nprivate:\n\tA objA;\n};\n\n\nint main()\n{\n\tB b1;\n\tb1.set(200);\n\tb1.printa();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：200\n\n![10]($resource/10.png)\n\n\n\n## 七、强化训练\n\n**1 static关键字强化训练题**\n\n某商店经销一种货物。货物购进和卖出时以箱为单位，各箱的重量不一样，因此，商店需要记录目前库存的总重量。现在用C++模拟商店货物购进和卖出的情况。\n```cpp\n#include \"iostream\"\nusing namespace std;\n\nclass Goods\n{\npublic:\n\n\tGoods(int w) { weight = w; total_weight += w; }\n\n\t~Goods() { total_weight -= weight; }\n\n\tint Weight() { return weight; };\n\n\tstatic int TotalWeight() { return total_weight; }\n\n\tGoods *next;\n\nprivate:\n\n\tint weight;\n\tstatic int total_weight;\n\n};\n\nint Goods::total_weight = 0;\n\n//r尾部指针\n\nvoid purchase(Goods * &f, Goods *& r, int w)\n{\n\n\tGoods *p = new Goods(w);\n\n\tp->next = NULL;\n\n\tif (f == NULL) f = r = p;\n\n\telse { r->next = p; r = r->next; } //尾部指针下移或新结点变成尾部结点\n\n}\n\nvoid sale(Goods * & f, Goods * & r)\n{\n\n\tif (f == NULL) { cout << \"No any goods!\\n\"; return; }\n\n\tGoods *q = f; f = f->next; delete q;\n\n\tcout << \"saled.\\n\";\n\n}\n\nvoid main()\n{\n\tGoods * front = NULL, *rear = NULL;\n\n\tint w; int choice;\n\n\tdo\n\t{\n\t\tcout << \"Please choice:\\n\";\n\n\t\tcout << \"Key in 1 is purchase,\\nKey in 2 is sale,\\nKey in 0 is over.\\n\";\n\n\t\tcin >> choice;\n\n\t\tswitch (choice) // 操作选择\n\t\t{\n\t\tcase 1: // 键入1，购进1箱货物\n\t\t{ cout << \"Input weight: \";\n\t\tcin >> w;\n\n\t\tpurchase(front, rear, w); // 从表尾插入1个结点\n\n\t\tbreak;\n\t\t}\n\n\t\tcase 2:              // 键入2，售出1箱货物\n\t\t{ sale(front, rear); break; } // 从表头删除1个结点\n\n\t\tcase 0: break;              // 键入0，结束\n\t\t}\n\n\t\tcout << \"Now total weight is:\" << Goods::TotalWeight() << endl;\n\n\t} while (choice);\n}\n```\n**2** **数组类封装**\n\n目标：解决实际问题，训练构造函数、copy构造函数等，为操作符重载做准备\n\n数组类的头文件:`Array.h`\n```cpp\n#pragma once\nclass Array\n{\npublic:\n\tArray(int length);\n\tArray(const Array&obj);\n\t~Array();\npublic:\n\tint length();\n\n\tvoid setData(int index, int value);\n\n\tint getData(int index);\nprivate:\n\tint m_length;\n\tchar *m_space;\n};\n```\n\n数组类的头文件的实现：`Array.cpp`\n```cppp\n#include \"Array.h\"\nusing namespace std;\n#include\"iostream\"\n\nArray::Array(int length)\n{\n\tif (length < 0)\n\t{\n\t\tlength = 0;\n\t}\n\telse\n\t{\n\t\tm_length = length;\n\t\tm_space = new char[m_length];\n\t}\n}\n\nArray::Array(const Array&obj)\n{\n   this->m_length = obj.m_length;\n   this->m_space = new char [this->m_length];//进行分配内存空间\n\n  for(int i= 0; i < obj.m_length;i++)//数组元素复制， 这里的obj.m_length可以直接替换成m_length\n  {\n    this->m_space[i] = obj.m_space[i];\n  }\n}\n\nArray::~Array()\n{\n\tif (m_space != NULL)\n\t{\n\t\tdelete[] m_space;\n\t\tm_length = 0;\n\t}\n}\n\nvoid Array::setData(int index, int valude)\n{\n\tm_space[index] = valude;\n}\n\nint Array::getData(int index)\n{\n\treturn m_space[index];\n}\n\nint Array::length()\n{\n\treturn m_length; \n}\n```\n\n数组类的测试\n```cpp\n#include \"iostream\"\n#include \"Array.h\"\nusing namespace std;\n\nint main()\n{\n\tArray a1(10);\n\tfor (int i = 0; i < a1.length(); i++)\n\t{\n\t\ta1.setData(i, i);\n\t}\n\tfor (int i = 0; i <  a1.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a1.getData(i));\n\t}\n\n\tArray a2 = a1;\n\n\tfor (int i = 0; i < a2.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a2.getData(i));\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**3.小结**\n\n* 类通常用关键字class定义。类是数据成员和成员函数的封装。类的实例称为对象。\n* 结构类型用关键字struct定义，是由不同类型数据组成的数据类型。\n* 类成员由private, protected, public决定访问特性。public成员集称为接口。\n* 构造函数在创建和初始化对象时自动调用。析构函数则在对象作用域结束时自动调用。\n* 重载构造函数和复制构造函数提供了创建对象的不同初始化方式。\n* 静态成员是局部于类的成员，提供一种同类对象的共享机制。\n* 友员用关键字friend声明。友员是对类操作的一种辅助手段。一个类的友员可以访问该类各种性质的成员\n* 链表是一种重要的动态数据结构，可以在程序运行时创建或撤消数据元素。\n\n\n\n---\n\n\n## 八、运算符重载\n\n### （一）概念\n\n#### **1.什么是运算符重载**\n\n![11]($resource/11.png)\n所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是”一名多用”。\n\n运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重载。例如，大 家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行加法运算，如5+8， 5.8 +3.67等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的， 但由于C++已经对运算符”+”进行了重载，所以就能适用于int, float, doUble类型的运算。\n\n又如”<<“是C++的位运算中的位移运算符（左移），但在输出操作中又是与流对 象cout 配合使用的流插入运算符，”>>“也是位移运算符(右移），但在输入操作中又是与流对象 cin 配合使用的流提取运算符。这就是运算符重载(operator overloading)。C++系统对”<<“和”>>“进行了重载，用户在不同的场合下使用它们时，作用是不同 的。对”<<“和”>>“的重载处理是放在头文件stream中的。因此，如果要在程序中用”<< “和”>>”作流插入运算符和流提取运算符，必须在本文件模块中包含头文件stream(当然还应当包括”using namespace std“)。\n\n现在要讨论的问题是：用户能否根据自己的需要对C++已提供的运算符进行重载，赋予它们新的含义，使之一名多用。？\n\n#### **2.运算符重载入门技术推演**\n\n1为什么会用运算符重载机制\n\n  用复数类举例\n\n//Complex c3 = c1 + c2;\n\n//原因 Complex是用户自定义类型，编译器根本不知道如何进行加减\n\n //编译器给提供了一种机制，让用户自己去完成，自定义类型的加减操作。。。。。\n\n //这个机制就是运算符重载机制\n\n2 运算符重载的本质是一个函数\n```cpp\n\n/*对于基础数据类型，C++编译器知道如何进行运算，但是对于用户自定义的类型编译器提供了一种\n让自定义数据类型进行运算符操作的机制,=》运算符重载机制\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\n\npublic:\n\tint a;\n\tint b;\n\n\tfriend Complex operator+(Complex &c1, Complex &c2);\n\npublic:\n\n\tComplex(int a = 0, int b = 0)\n\n\t{\n\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\n\t}\n\npublic:\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\nprivate:\n\n};\n\n/*使用全局函数，通过调用全局函数实现\n\nComplex myAdd(Complex &c1, Complex &c2)\n{\n\n Complex tmp(c1.a+ c2.a, c1.b + c2.b);\n\n return tmp;\n\n}\n\n*/\n\n\n//可以想象为将函数名替换为operator+\nComplex operator+(Complex &c1, Complex &c2)\n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\n\treturn tmp;\n}\n\nvoid main()\n{\n\tComplex c1(1, 2), c2(3, 4);\n\n\t//方法1： 通过调用普通函数实现\n\n\t//Complex c3 = myAdd(c1, c2);\n\n\t//c3.printCom();\n\n\n\n\n\n\t//方法2  将函数名称替换为：operator+ \n\t//使用以下方式进行调用\n\n\t//Complex c3 = operator+(c1, c2);\n\t//c3.printCom();\n\n\n\t//最常用的调用方式\n\n\tComplex c3 = c1 + c2; \n\tc3.printCom();\n\n\n\t//4 把Complex类变成私有属性\n\n\t//友元函数的应用场景\n\n\t//friend Complex operator+(Complex &c1, Complex &c2);\n\n\tsystem(\"pause\");\n\n\treturn;\n\n}\n```\n\n\n---\n\n### （二）运算符重载的限制\n![12]($resource/12.png)\n![13]($resource/13.png)\n\n---\n\n### （三）运算符重载编程基础\n![14]($resource/14.png)\n例如:\n   //全局函数  完成 +操作符  重载  \n    Complex operator+(Complex &c1, Complex &c2)\n\n  //类成员函数  完成 -操作符  重载\n    Complex operator-(Complex &c2)\n\n#### **运算符重载的两种方法:**\n![15]($resource/15.png)\n\n- 二元操作符重载的实现：\n![16]($resource/16.png)\n \n```cpp\n//二元函数操作符的重载的两种方法\n\n\n/*全局函数、类成员函数方法实现运算符重载步骤\n\n1）要承认操作符重载是一个函数，写出函数名称operator + ()\n\n2）根据操作数，写出函数参数\n\n3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex operator+(Complex &c1, Complex &c2); //这里主要是针对全局函数\n\npublic:\n\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\n\t}\n\npublic:\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\t//成员函数实现 - 运算符重载 \n\tComplex operator-(Complex &c2)\n\t{\n\t\tComplex tmp(this->a - c2.a, this->b -  c2.b);\n\n\t\treturn tmp;\n\t}\n\nprivate:\n\n};\n\n\n//全局函数实现  + 运算符重载\nComplex operator+(Complex &c1, Complex &c2)\n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\n\treturn tmp;\n}\n\nint  main()\n{\n\n\tComplex c1(1, 2), c2(3, 4);\n\n\t//使用 全局函数\n\n\tComplex c3 = c1 + c2;\n\tc3.printCom();\n\n\t//使用成员函数\n\tComplex c4 = c1.operator-(c2);\n\tc4.printCom();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n- 一元函数操作符重载的实现：\n![17]($resource/17.png)\n- 实现前置++和前置--\n```cpp\n//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现前置++和前置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex& operator++(Complex &c1); //这里主要是针对全局函数\n\npublic:\n\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\tComplex& operator--()\n\t{\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn *this;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  + 运算符重载\nComplex& operator++(Complex &c1)\n{\n\tc1.a++;\n\tc1.b++;\n\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1,c2;\n\n\t//使用全局函数实现前置++操作符的重置\n\t++c1;\n\tc1.printCom();\n\n\t//使用成员函数实现前置--操作符的重置\n\n\t--c2;\n\tc2.printCom();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n- 实现后置++和后置--\n```cpp\n//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现后置++ 和后置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex operator++(Complex &c1, int); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\t//成员函数实现后置--\n\tComplex operator--(int)\n\t{\n\t\tComplex tmp = *this;\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn tmp;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  ++ 运算符重载\nComplex operator++(Complex &c1,int)  //为了和前置++的函数能够共同存在，参数中加了一个占位符从而实现函数重载\n{\n\t//前置++是先使用后++ ，所以应该先返回c1,但是直接使用return c1.会造成程序的直接退出，后面的++无法实现，所以使用临时变量\n\n\tComplex tmp = c1;\n\tc1.a++;\n\tc1.b++;\n\treturn tmp;\n\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1, c2;\n\n\t//使用全局函数实现后置++操作符的重置\n\n\tc1++;\n\tc1.printCom();\n\n\t//使用成员函数实现后置--操作符的重置\n\n\tc2--;\n\tc2.printCom();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n\n前置和后置运算符总结\n\n**C++中通过一个占位参数来区分前置运算和后置运算**\n![18]($resource/18.png)\n\n#### **定义运算符重载函数名的步骤**\n\n全局函数、类成员函数方法实现运算符重载步骤\n 1）要承认操作符重载是一个函数，写出函数名称operator+ ()\n 2）根据操作数，写出函数参数\n 3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n\n#### **友元函数实现操作符重载的应用场景**\n\n**1）友元函数和成员函数选择方法**\n\n- 当无法修改左操作数的类时，使用全局函数进行重载\n- =, [], ()和->操作符只能通过成员函数进行重载\n\n**2）用友元函数重载 << >>操作符**\n\n* istream 和 ostream 是 C++ 的预定义流类\n* cin 是 istream 的对象，cout 是 ostream 的对象\n* 运算符 << 由ostream 重载为插入操作，用于输出基本类型数据\n* 运算符 >> 由 istream 重载为提取操作，用于输入基本类型数据\n* 用友员函数重载 << 和 >> ，输出和输入用户自定义的数据类型\n\na）用全局函数方法实现 << 操作符\n```pp\n//实现<<运算符的重载\n\n//注释内部是一套完整的程序，但是只能实现一次打印输出，新的一套程序可以实现链式输出\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\t//friend  void operator<<(ostream &cout, Complex &c1); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n};\n\n/*这里类似于cout只能有全局函数加上友元函数实现，因为如果要使用成员函数实现，需要在cout 的类：ostream中定义成员函数，\n但是这个ostream类是系统隐藏的，不现实；\nvoid operator<<(ostream &cout, Complex &c1)\n{\n\tcout << c1.a << \" + \" << c1.b << \"i\" << endl;\n}\n*/\n\nostream& operator<<(ostream &cout, Complex &c2)  //要想实现函数返回值当左值，需要返回一个引用\n{\n\tcout << c2.a << \" + \" << c2.b << \"i\" << endl;\n\treturn cout;\n}\n\n\n \nint  main()\n{\n\tComplex c1, c2;\n\t//cout << c1;  //实现将c1中两个元素以a+bi的形式直接打印输出；\n\t/*\n\t首先承认运算符重载是函数，所以函数名为：operator<<\n\t其次因为有左右参数，分别为ostream 和Complex类，所有函数头为：operator<<(ostream&cout,Complex c1)\n\t然后根据返回值确定最前面的返回值类型\n\t*/\n\n\tcout << c2 << \"kdjfkdjfkd\";\n\t//因为<<操作符是从左到右，所以左边执行返回值要当左值再次执行这个函数\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n**3）友元函数重载操作符使用注意点**\n\n- a） 友员函数重载运算符常用于运算符的左右操作数类型不同的情况\n![19]($resource/19.png)\n- b）其他\n  - 在第一个参数需要隐式转换的情形下，使用友员函数重载运算符是正确的选择\n  - 友员函数没有 this 指针，所需操作数都必须在参数表显式声明，很容易实现类型的隐式转换\n  - C++中不能用友员函数重载的运算符有\n     = （）  ［］  －>\n\n**4）友元函数案例vector类**\n```cpp\n#include <iostream>\nusing namespace std;\n\n//为vector类重载流插入运算符和提取运算符\n\nclass vector\n{\npublic:\n\tvector(int size = 1);\n\n\t~vector();\n\n\tint & operator[](int i);\n\n\tfriend ostream & operator << (ostream & output, vector &);\n\n\tfriend istream & operator >> (istream & input, vector &);\n\nprivate:\n\tint * v;\n\n\tint len;\n\n};\n\nvector::vector(int size)\n{\n\tif (size <= 0 || size > 100)\n\t{\n\t\tcout << \"The size of \" << size << \" is null !\\n\"; abort();\n\t}\n\n\tv = new int[size]; len = size;\n}\n\nvector :: ~vector()\n{\n\tdelete[] v;\n\n\tlen = 0;\n}\n\nint &vector::operator[](int i)\n{\n\tif (i >= 0 && i < len) return v[i];\n\n\tcout << \"The subscript \" << i << \" is outside !\\n\"; abort();\n}\n\nostream & operator << (ostream & output, vector & ary)\n{\n\tfor (int i = 0; i < ary.len; i++)\n\t\toutput << ary[i] << \" \";\n\n\toutput << endl;\n\treturn output;\n}\n\nistream & operator >> (istream & input, vector & ary)\n{\n\tfor (int i = 0; i < ary.len; i++)\n\t\tinput >> ary[i];\n\n\treturn input;\n}\n\nvoid main()\n{\n\tint k;\n\tcout << \"Input the length of vector A :\\n\";\n\tcin >> k;\n\tvector A(k);\n\tcout << \"Input the elements of vector A :\\n\";\n\tcin >> A;\n\tcout << \"Output the elements of vector A :\\n\";\n\tcout << A;\n\tsystem(\"pause\");\n}\n\n```\n\n### （四）运算符重载提高\n\n#### **1.运算符重载机制**\n\nC++编译器是如何支持操作符重载机制的?\n\n#### **2.重载赋值运算符=**\n\n* 赋值运算符重载用于对象数据的复制\n* operator= 必须重载为成员函数\n* 重载函数原型为：\n  类型&类名:: operator= ( const  类名 & ) ;\n\n案例：完善Name类，支持=号操作。\n![22]($resource/22.png)\n\n  结论:\n 1 先释放旧的内存\n 2 返回一个引用\n 3 =操作符 从右向左\n```cpp\n//重载 = 操作符\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\t//obj3 = obj1; // C++编译器提供的  等号操作  也属  浅拷贝\\\n\t// obj4 = obj3 = obj1\n\t//obj3.operator=(obj1)\n\n\tName& operator=(Name &obj1)\n\t{\n\t\t//1 先释放obj3旧的内存\n\n\t\tif (this->pName != NULL)\n\t\t{\n\t\t\tdelete[] pName;\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\t//2 根据obj1分配内存大小\n\n\t\tthis->size = obj1.size;\n\t\tthis->pName = new char[size + 1];\n\n\t\t//3把obj1赋值给obj3\n\n\t\tstrcpy(pName, obj1.pName);\n\t\treturn *this;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nint main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n\n#### **3.重载数组下表运算符[]** ==这里的视频再看一遍==\n- 重载[]和()运算符\n  - 运算符 [] 和 () 是二元运算符\n  - [] 和 () 只能用成员函数重载，不能用友元函数重载\n\n- 重载下标运算符 []\n  - [] 运算符用于访问数据对象的元素\n  重载格式：  返回值类型 类 :: operator[] ( 类型 ) ；\n  设 x 是类 X 的一个对象，则表达式 `x[y]` 可被解释为  `x.operator[](y)`\n\n![33]($resource/33.png)\n![44]($resource/44.png)\n\n\n#### **4.重载函数调用符()**\n\n() 运算符用于函数调用\n\n重载格式:  返回值类型 类:: operator() ( 表达式表 ) ；\n\n例1\n设 x是类 X的一个对象，则表达式*\nx ( arg1, arg2, … )\n可被解释为\nx . operator () (arg1, arg2, … )\n\n**案例：**\n例2：用重载()运算符实现数学函数的抽象\n```cpp\n\n#include <iostream>\n\nclass F\n\n { public :\n\n double operator ( )  ( double x , double y ) ;\n\n } ;\n\ndouble F :: operator ( )  ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\nf.getA();\n\n cout << f ( 5.2 , 2.5 ) << endl ; // **f . _operator()_ (5.2, 2.5)**\n\n}\n```\n比较普通成员函数\n\n**//例3用重载()运算符实现 pk成员函数**\n```cpp\n#include <iostream.h>\n\nclass F\n\n { public :\n\n double memFun ( double x , double y ) ;\n\n } ;\n\ndouble F :: memFun ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\n cout << f.memFun ( 5.2 , 2.5 ) << endl ;\n\n}\n```\n\n#### **5.为什么不要重载&&和||操作符**\n\n- 理论知识：\n  - 1）&&和||是C++中非常特殊的操作符\n  - 2）&&和||内置实现了短路规则\n  - 3）操作符重载是靠函数重载来完成的\n  - 4）操作数作为函数参数传递\n  - 5）C++的函数参数都会被求值，无法实现短路规则\n```cpp\n#include <cstdlib>\n\n#include <iostream>\n\nusing namespace std;\n\nclass Test\n\n{\n\n int i;\n\npublic:\n\n Test(int i)\n\n {\n\n this->i = i;\n\n }\n\n Test operator+ (const Test& obj)\n\n {\n\n Test ret(0);\n\n cout<<\"执行+号重载函数\"<<endl;\n\n ret.i = i + obj.i;\n\n return ret;\n\n }\n\n bool operator&& (const Test& obj)\n\n {\n\n cout<<\"执行&&重载函数\"<<endl;\n\n return i && obj.i;\n\n }\n\n};\n\n// && 从左向右\n\nvoid main()\n\n{\n\n int a1 = 0;\n\n int a2 = 1;\n\n cout<<\"注意：&&操作符的结合顺序是从左向右\"<<endl;\n\n if( a1 && (a1 + a2) )\n\n {\n\n cout<<\"有一个是假，则不在执行下一个表达式的计算\"<<endl;\n\n }\n\n Test t1 = 0;\n\n Test t2 = 1;\n\n If ( t1 && (t1 + t2) )\n\n {\n\n=è\n\n T1.operator&&( t1 + t2) )\n\nT1.operator&&( t1.operator+(t2) )\n\n //t1 && t1.operator+(t2)\n\n // t1.operator( t1.operator(t2) )\n\n cout<<\"两个函数都被执行了，而且是先执行了+\"<<endl;\n\n }\n\n system(\"pause\");\n\n return ;\n\n}\n\n```\n\n\n### （五）运算符重载在项目开发中的应用\n\n#### **1实现一个数组类**\n\n添加<< >>\n\n#### **2实现一个字符串类**\n\n构造函数要求\n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串类 以零结尾的字符串\n\n//若len为0,表示空串\n```cpp\nMyString a; //空串 “”\n\nMyString a(“dddd”);\n\nMyString b = a;\n\nb = “aaaaaa” \n\nb = a;\n\nif (a > b)\n\nif (a == b)\n\nb[i] = ‘a’;\n```\n常用的操作符\n\n<< >> != == > < =\n\n```cpp\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串 以零结尾的字符串\n\nclass MyString\n\n{\n\n friend ostream& operator<<(ostream &out, const MyString &s);\n\npublic: //构造和析构\n\n MyString(int len = 0);\n\n MyString(const char *p);\n\n MyString(const MyString& obj);\n\n ~MyString();\n\npublic: //操作符重载\n\n MyString& operator=(const char *p);\n\n MyString& operator=(const MyString& obj);\n\n char& operator[](int index) const;\n\npublic:\n\n bool operator==(const char* p) const;\n\n bool operator!=(const char* p) const;\n\n bool operator==(const MyString& s) const;\n\n bool operator!=(const MyString& s) const;\n\npublic: //string to c\n\n char *c_str();\n\n const char* c_str() const;\n\n int length()\n\n {\n\n return m_len;\n\n }\n\npublic:\n\n int operator<(const char *p);\n\n int operator>(const char *p);\n\n int operator<(const MyString &s);\n\n int operator>(const MyString &s);\n\nprivate:\n\n int m_len;\n\n char  *m_p;\n\n};\n\n```\n\n\n#### **3智能指针类编写**\n\n1问题抛出\n  指针使用过程中，经常会出现内存泄漏和内存多次被释放常\n\n2 解决方案：例如：boost库的智能指针\n  项目开发中，要求开发者使用预先编写的智能指针类对象代替C语言中的原生指针\n\n3 智能指针思想\n  工程中的智能指针是一个类模板\n  通过构造函数接管申请的内存\n  通过析构函数确保堆内存被及时释放\n  通过重载指针运算符* 和 -> 来模拟指针的行为\n  通过重载比较运算符 == 和 != 来模拟指针的比较\n\n```cpp\nclass Test\n\n{\n\npublic:\n\n Test()\n\n {\n\n this->a = 10;\n\n }\n\n void printT()\n\n {\n\n cout<<a<<endl;\n\n }\n\nprivate:\n\n int a;\n\n};\n\nclass MyTestPointer\n\n{\n\npublic:\n\npublic:\n\n MyTestPointer()\n\n {\n\n p = NULL;\n\n }\n\n MyTestPointer(Test* p)\n\n {\n\n this->p = p;\n\n }\n\n ~MyTestPointer()\n\n {\n\n delete p;\n\n }\n\n Test* operator->()\n\n {\n\n return p;\n\n }\n\n Test& operator*()\n\n {\n\n return *p;\n\n }\n\nprotected:\n\n Test *p;\n\n};\n\nvoid main01_classp()\n\n{\n\n Test *p = new Test;\n\n p->printT();\n\n delete p;\n\n MyTestPointer myp = new Test; //构造函数\n\n myp->printT(); //重载操作符 ->\n\n};\n\n```\n\n```cpp\n\n\nclass MyIntPointer\n\n{\n\npublic:\n\npublic:\n\n MyIntPointer()\n\n {\n\n p = NULL;\n\n }\n\n MyIntPointer(int* p)\n\n {\n\n this->p = p;\n\n }\n\n ~MyIntPointer()\n\n {\n\n delete p;\n\n }\n\n int* operator->()\n\n {\n\n return p;\n\n }\n\n int& operator*()\n\n {\n\n return *p;\n\n }\n\nprotected:\n\n int *p;\n\n};\n\nvoid main02_intp()\n\n{\n\n int *p = new int(100);\n\n cout<<*p<<endl;\n\n delete p;\n\n MyIntPointer myp = new int(200);\n\n cout<<*myp<<endl; //重载*操作符\n\n};\n```\n\n**8.7****附录：运算符和结合性**\n\n![55]($resource/55.png)\n\n![66]($resource/66.png)\n\n- 总结\n  * 操作符重载是C++的强大特性之一\n  * 操作符重载的本质是通过函数扩展操作符的语义\n  * operator关键字是操作符重载的关键\n  * friend关键字可以对函数或类开发访问权限\n  * 操作符重载遵循函数重载的规则\n  * 操作符重载可以直接使用类的成员函数实现\n  * =, [], ()和->操作符只能通过成员函数进行重载\n  * ++操作符通过一个int参数进行前置与后置的重载\n  * C++中不要重载&&和||操作符\n\n\n\n\n\n\n\n\n\n\n\n",[[1543583280763,["gjx16@GJXAIOU",[[1,39898,"，定义一个Complex类"]],[39898,39898],[39911,39911]]],[1543583302989,["gjx16@GJXAIOU",[[-1,39500,"”"]],[39501,39501],[39500,39500]]],[1543583305086,["gjx16@GJXAIOU",[[1,39500,"·`"]],[39500,39500],[39502,39502]]],[1543583307127,["gjx16@GJXAIOU",[[-1,39500,"·`"]],[39502,39502],[39500,39500]]],[1543583307761,["gjx16@GJXAIOU",[[1,39500,"`"]],[39500,39500],[39501,39501]]],[1543583310248,["gjx16@GJXAIOU",[[-1,39503,"“"]],[39504,39504],[39503,39503]]],[1543583311089,["gjx16@GJXAIOU",[[1,39503,"`"]],[39503,39503],[39504,39504]]],[1543583321864,["gjx16@GJXAIOU",[[-1,39638,"”<<“"],[1,39642,"`<<`"]],[39638,39642],[39642,39642]]],[1543583325489,["gjx16@GJXAIOU",[[-1,39677,"”<<“"],[1,39681,"`<<`"]],[39677,39681],[39681,39681]]],[1543583328823,["gjx16@GJXAIOU",[[-1,39717,"”<< “"],[1,39722,"`<<`"]],[39717,39722],[39721,39721]]],[1543583331345,["gjx16@GJXAIOU",[[-1,39725,"”"]],[39726,39726],[39725,39725]]],[1543583331975,["gjx16@GJXAIOU",[[1,39725,"`"]],[39725,39725],[39726,39726]]],[1543583334251,["gjx16@GJXAIOU",[[-1,39722,"”"]],[39723,39723],[39722,39722]]],[1543583334860,["gjx16@GJXAIOU",[[1,39722,"`"]],[39722,39722],[39723,39723]]],[1543583340750,["gjx16@GJXAIOU",[[-1,39682,"”>>“"],[1,39686,"`>>`"]],[39682,39686],[39686,39686]]],[1543583346829,["gjx16@GJXAIOU",[[-1,39643,"”>>“"],[1,39647,"`>>`"]],[39643,39647],[39647,39647]]],[1543583351936,["gjx16@GJXAIOU",[[-1,39846,"。"]],[39847,39847],[39846,39846]]],[1543583371930,["gjx16@GJXAIOU",[[-1,39506,"++"],[-1,39633,"++"]],[39508,39632],[39506,39631]]],[1543583377609,["gjx16@GJXAIOU",[[-1,39556,"“"]],[39557,39557],[39556,39556]]],[1543583378386,["gjx16@GJXAIOU",[[1,39556,"`"]],[39556,39556],[39557,39557]]],[1543583380545,["gjx16@GJXAIOU",[[-1,39553,"”"]],[39554,39554],[39553,39553]]],[1543583381228,["gjx16@GJXAIOU",[[1,39553,"`"]],[39553,39553],[39554,39554]]],[1543583395349,["gjx16@GJXAIOU",[[1,39905,",lij"]],[39905,39905],[39909,39909]]],[1543583398645,["gjx16@GJXAIOU",[[-1,39906,"lij"]],[39909,39909],[39906,39906]]],[1543583410379,["gjx16@GJXAIOU",[[1,39906,"有两个对象，每个对象由两个人"]],[39906,39906],[39920,39920]]],[1543583413112,["gjx16@GJXAIOU",[[-1,39919,"人"]],[39920,39920],[39919,39919]]],[1543583419187,["gjx16@GJXAIOU",[[1,39919,"属性，要求"]],[39919,39919],[39924,39924]]],[1543583424054,["gjx16@GJXAIOU",[[1,39924,"使用啦对象"]],[39924,39924],[39929,39929]]],[1543583428965,["gjx16@GJXAIOU",[[-1,39926,"啦对象"]],[39929,39929],[39926,39926]]],[1543583438190,["gjx16@GJXAIOU",[[1,39926,"对象直接的加法实现"]],[39926,39926],[39935,39935]]],[1543583444990,["gjx16@GJXAIOU",[[-1,39928,"直接"]],[39930,39930],[39928,39928]]],[1543583448133,["gjx16@GJXAIOU",[[1,39928,"之间"]],[39928,39928],[39930,39930]]],[1543583464145,["gjx16@GJXAIOU",[[1,39935,"对应属性的相加"]],[39935,39935],[39942,39942]]],[1543583472358,["gjx16@GJXAIOU",[[-1,39944,"//Complex c3 = c1 + c2;\n"]],[39943,39967],[39943,39943]]],[1543583475709,["gjx16@GJXAIOU",[[-1,39944,"\n"]],[39944,39944],[39943,39943]]],[1543583479841,["gjx16@GJXAIOU",[[-1,39982,"//"]],[39984,39984],[39982,39982]]],[1543583480940,["gjx16@GJXAIOU",[[-1,39981," "]],[39982,39982],[39981,39981]]],[1543583482015,["gjx16@GJXAIOU",[[-1,39980,"\n"]],[39981,39981],[39980,39980]]],[1543583483036,["gjx16@GJXAIOU",[[-1,39979,"\n"]],[39980,39980],[39979,39979]]],[1543583487834,["gjx16@GJXAIOU",[[1,39979,"，但是"]],[39979,39979],[39982,39982]]],[1543583491397,["gjx16@GJXAIOU",[[-1,40019,"\n //"]],[40019,40023],[40019,40019]]],[1543583492460,["gjx16@GJXAIOU",[[-1,40018,"\n"]],[40019,40019],[40018,40018]]],[1543583494290,["gjx16@GJXAIOU",[[-1,40016,"。。"]],[40018,40018],[40016,40016]]],[1543583505349,["gjx16@GJXAIOU",[[-1,39884,"  用复数类举例，定义一个Complex类,有两个对象，每个对象由两个属性，要求使用对象之间的加法实现对应属性的相加\n"]],[39883,39942],[39883,39883]]],[1543583508419,["gjx16@GJXAIOU",[[1,39988,"\n"]],[39987,39987],[39988,39988]]],[1543583509045,["gjx16@GJXAIOU",[[1,39989,"  用复数类举例，定义一个Complex类,有两个对象，每个对象由两个属性，要求使用对象之间的加法实现对应属性的相加\n"]],[39988,39988],[40047,40047]]],[1543583512036,["gjx16@GJXAIOU",[[-1,39884,"\n"]],[39884,39884],[39883,39883]]],[1543583512808,["gjx16@GJXAIOU",[[-1,39883,"\n"]],[39883,39883],[39882,39882]]],[1543583515773,["gjx16@GJXAIOU",[[-1,39970,"2 运算符重载的本质是一个函数\n"]],[39969,39985],[39969,39969]]],[1543583517165,["gjx16@GJXAIOU",[[-1,39970,"\n"]],[39969,39969],[39968,39968]]],[1543583522640,["gjx16@GJXAIOU",[[-1,39971," "]],[39972,39972],[39971,39971]]],[1543583534868,["gjx16@GJXAIOU",[[1,40027,"，示例程序如下："]],[40027,40027],[40035,40035]]],[1543583540300,["gjx16@GJXAIOU",[[-1,39970," "]],[39971,39971],[39970,39970]]],[1543583600868,["gjx16@GJXAIOU",[[-1,40181,"\n"]],[40181,40181],[40180,40180]]],[1543583606984,["gjx16@GJXAIOU",[[-1,40205,"\n"]],[40205,40205],[40204,40204]]],[1543583609644,["gjx16@GJXAIOU",[[-1,40258,"\n"]],[40258,40258],[40257,40257]]],[1543583622580,["gjx16@GJXAIOU",[[1,40257,"//友元函数声明"]],[40257,40257],[40265,40265]]],[1543583627030,["gjx16@GJXAIOU",[[-1,40274,"\n"]],[40274,40274],[40273,40273]]],[1543583630043,["gjx16@GJXAIOU",[[-1,40305,"\n"]],[40305,40305],[40304,40304]]],[1543583633295,["gjx16@GJXAIOU",[[-1,40308,"\n"]],[40308,40308],[40307,40307]]],[1543583636412,["gjx16@GJXAIOU",[[-1,40323,"\n"]],[40323,40323],[40322,40322]]],[1543583638644,["gjx16@GJXAIOU",[[-1,40338,"\n"]],[40338,40338],[40337,40337]]],[1543583643533,["gjx16@GJXAIOU",[[1,40304,"、、"]],[40304,40304],[40306,40306]]],[1543583649352,["gjx16@GJXAIOU",[[-1,40304,"、、"]],[40306,40306],[40304,40304]]],[1543583652319,["gjx16@GJXAIOU",[[1,40304,"//"]],[40304,40304],[40306,40306]]],[1543583828158,["gjx16@GJXAIOU",[[1,40306,"gouzoq"]],[40306,40306],[40312,40312]]],[1543583833020,["gjx16@GJXAIOU",[[-1,40305,"/gouzoq"]],[40312,40312],[40305,40305]]],[1543583838295,["gjx16@GJXAIOU",[[1,40305,"构造函数"]],[40305,40305],[40309,40309]]],[1543583849692,["gjx16@GJXAIOU",[[-1,40347,"public:"]],[40347,40354],[40347,40347]]],[1543583850884,["gjx16@GJXAIOU",[[-1,40347,"\n"]],[40347,40347],[40346,40346]]],[1543584981690,[null,[[-1,40347,"\n"]],[40347,40347],[40347,40347]]],[1543584981690,[null,[[1,40347,"\n"]],[40347,40347],[40347,40347]]],[1543584975444,["gjx16@GJXAIOU",[[-1,40189,"\tint a;\n\tint b;"]],[40189,40204],[40189,40189]]],[1543584977654,["gjx16@GJXAIOU",[[-1,40251,"public:"]],[40251,40258],[40251,40251]]],[1543584979538,["gjx16@GJXAIOU",[[-1,40189,"\n"]],[40189,40189],[40188,40188]]],[1543585041695,[null,[[-1,40324,"\n"]],[40324,40324],[40324,40324]]],[1543585041695,[null,[[1,40324,"\n"]],[40324,40324],[40324,40324]]],[1543584985026,["gjx16@GJXAIOU",[[1,40401,"\n"]],[40399,40399],[40400,40400]]],[1543584986268,["gjx16@GJXAIOU",[[1,40400,"int"]],[40400,40400],[40403,40403]]],[1543584989966,["gjx16@GJXAIOU",[[-1,40400,"int"]],[40403,40403],[40400,40400]]],[1543584995837,["gjx16@GJXAIOU",[[1,40400,"  int a;"]],[40400,40400],[40408,40408]]],[1543584997436,["gjx16@GJXAIOU",[[1,40409,"  \n"]],[40408,40408],[40411,40411]]],[1543585001043,["gjx16@GJXAIOU",[[1,40411,"int b;"]],[40411,40411],[40417,40417]]],[1543585103683,[null,[[-1,40324,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40324,40324],[40417,40417]]],[1543585103683,[null,[[1,40324,"\n"],[-1,40399,"\n"],[1,40417,"\n"]],[40417,40417],[40324,40324]]],[1543585086218,["gjx16@GJXAIOU",[[-1,40419,"\n"]],[40419,40419],[40418,40418]]],[1543585101124,["gjx16@GJXAIOU",[[-1,40676,"vo"],[-1,40679,"d"]],[40676,40680],[40677,40677]]],[1543585102323,["gjx16@GJXAIOU",[[1,40677,"nt"]],[40677,40677],[40679,40679]]],[1543585102960,["gjx16@GJXAIOU",[[1,40680," "]],[40679,40679],[40680,40680]]],[1543585163649,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543585163649,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543585114427,["gjx16@GJXAIOU",[[-1,40540,"\n"]],[40540,40540],[40539,40539]]],[1543585115750,["gjx16@GJXAIOU",[[-1,40486,"\n"]],[40486,40486],[40485,40485]]],[1543585117343,["gjx16@GJXAIOU",[[-1,40443,"\n"]],[40443,40443],[40442,40442]]],[1543585130581,["gjx16@GJXAIOU",[[1,40554,"sahgnmian "]],[40554,40554],[40564,40564]]],[1543585141645,["gjx16@GJXAIOU",[[1,41084,"\n"]],[41081,41081],[41082,41082]]],[1543585142320,["gjx16@GJXAIOU",[[1,41082,"c"]],[41082,41082],[41083,41083]]],[1543585143295,["gjx16@GJXAIOU",[[-1,41082,"c"]],[41083,41083],[41082,41082]]],[1543585151711,["gjx16@GJXAIOU",[[1,41082,"程序运行结果：``"]],[41082,41082],[41091,41091]]],[1543585156310,["gjx16@GJXAIOU",[[1,41090,"4+6i"]],[41090,41090],[41094,41094]]],[1543585223648,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543585223648,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543585166082,["gjx16@GJXAIOU",[[-1,40554,"sahgnmian "]],[40554,40564],[40554,40554]]],[1543585174239,["gjx16@GJXAIOU",[[1,40554,"上面全局"]],[40554,40554],[40558,40558]]],[1543585175229,["gjx16@GJXAIOU",[[1,40560,"函数"]],[40558,40558],[40560,40560]]],[1543585175780,["gjx16@GJXAIOU",[[1,40560,"的"]],[40560,40560],[40561,40561]]],[1543585182153,["gjx16@GJXAIOU",[[1,40550,"简单的"]],[40550,40550],[40553,40553]]],[1543585185178,["gjx16@GJXAIOU",[[-1,40666,"\n"]],[40666,40666],[40665,40665]]],[1543585191146,["gjx16@GJXAIOU",[[-1,40540,"\n"]],[40540,40540],[40539,40539]]],[1543585283678,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543585283678,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543585223890,["gjx16@GJXAIOU",[[-1,40744,"\n"]],[40744,40744],[40743,40743]]],[1543585226452,["gjx16@GJXAIOU",[[-1,40775,"\n"]],[40775,40775],[40774,40774]]],[1543585233400,["gjx16@GJXAIOU",[[1,40681,"\n"]],[40680,40680],[40681,40681]]],[1543585233961,["gjx16@GJXAIOU",[[1,40682,"\n"]],[40681,40681],[40682,40682]]],[1543585248185,["gjx16@GJXAIOU",[[-1,40799,"\n"]],[40799,40799],[40798,40798]]],[1543585248732,["gjx16@GJXAIOU",[[-1,40798,"\n"]],[40798,40798],[40797,40797]]],[1543585249970,["gjx16@GJXAIOU",[[-1,40797,"\n"]],[40797,40797],[40796,40796]]],[1543585253129,["gjx16@GJXAIOU",[[-1,40839,"\n"]],[40839,40839],[40838,40838]]],[1543585343666,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543585343666,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543585303156,["gjx16@GJXAIOU",[[-1,40906,"\n"]],[40906,40906],[40905,40905]]],[1543585316491,["gjx16@GJXAIOU",[[-1,40948,"\t//4 把Complex类变成私有属性\n\n\t//友元函数的应用场景\n\n\t//friend Complex operator+(Complex &c1, Complex &c2);"]],[40949,41038],[40948,40948]]],[1543585317158,["gjx16@GJXAIOU",[[-1,40949,"\n"]],[40948,40948],[40947,40947]]],[1543585317818,["gjx16@GJXAIOU",[[-1,40948,"\n"]],[40947,40947],[40946,40946]]],[1543585318438,["gjx16@GJXAIOU",[[-1,40947,"\n"]],[40946,40946],[40945,40945]]],[1543585319059,["gjx16@GJXAIOU",[[-1,40944,";"]],[40945,40945],[40944,40944]]],[1543585322098,["gjx16@GJXAIOU",[[-1,40974,"\n"]],[40974,40974],[40973,40973]]],[1543585323378,["gjx16@GJXAIOU",[[-1,40964,"\n"]],[40964,40964],[40963,40963]]],[1543585337588,["gjx16@GJXAIOU",[[1,40897,"方法3："]],[40897,40897],[40901,40901]]],[1543585883788,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543585883788,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543585828817,["gjx16@GJXAIOU",[[-1,41044,"![13]($resource/13.png)"],[1,41067,"\n"]],[41044,41067],[41045,41045]]],[1543585842719,["gjx16@GJXAIOU",[[1,41045,"重载运算符操作符"]],[41045,41045],[41053,41053]]],[1543585849827,["gjx16@GJXAIOU",[[-1,41050,"操作符"]],[41053,41053],[41050,41050]]],[1543585869783,["gjx16@GJXAIOU",[[1,41050,"函数可以对运算符进行新的解释，但是原有的基础"]],[41050,41050],[41072,41072]]],[1543585872132,["gjx16@GJXAIOU",[[-1,41070,"基础"]],[41072,41072],[41070,41070]]],[1543585878579,["gjx16@GJXAIOU",[[1,41070,"基本语义不变："]],[41070,41070],[41077,41077]]],[1543585879178,["gjx16@GJXAIOU",[[1,41079,"\n"]],[41077,41077],[41078,41078]]],[1543585943862,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543585943862,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543585893983,["gjx16@GJXAIOU",[[1,41078,"* 不改变运算符的优先级"]],[41078,41078],[41090,41090]]],[1543585894544,["gjx16@GJXAIOU",[[1,41091,"* \n"]],[41090,41090],[41093,41093]]],[1543585911928,["gjx16@GJXAIOU",[[1,41093,"不改变云端福的结核性"]],[41093,41093],[41103,41103]]],[1543585915775,["gjx16@GJXAIOU",[[-1,41100,"结核性"]],[41103,41103],[41100,41100]]],[1543586183791,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543586183791,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543586165889,["gjx16@GJXAIOU",[[-1,41096,"云端福的"]],[41100,41100],[41096,41096]]],[1543586175610,["gjx16@GJXAIOU",[[1,41096,"运算符的结核性"]],[41096,41096],[41103,41103]]],[1543586178078,["gjx16@GJXAIOU",[[-1,41100,"结核性"]],[41103,41103],[41100,41100]]],[1543586181036,["gjx16@GJXAIOU",[[1,41100,"结合性"]],[41100,41100],[41103,41103]]],[1543586182135,["gjx16@GJXAIOU",[[1,41104,"* \n"]],[41103,41103],[41106,41106]]],[1543586243792,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543586243792,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543586195377,["gjx16@GJXAIOU",[[1,41106,"不改变运算符所需要的操作数"]],[41106,41106],[41119,41119]]],[1543586196090,["gjx16@GJXAIOU",[[1,41120,"* \n"]],[41119,41119],[41122,41122]]],[1543586207462,["gjx16@GJXAIOU",[[1,41122,"不能创建新的运算符"]],[41122,41122],[41131,41131]]],[1543586303802,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543586303802,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543586295819,["gjx16@GJXAIOU",[[-1,41337,"![15]($resource/15.png)"],[1,41360,"-"]],[41337,41337],[41338,41338]]],[1543586302049,["gjx16@GJXAIOU",[[1,41338,"运算符可以"]],[41338,41338],[41343,41343]]],[1543586364341,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543586364341,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543586305047,["gjx16@GJXAIOU",[[1,41338," "]],[41338,41338],[41339,41339]]],[1543586317197,["gjx16@GJXAIOU",[[1,41344,"重载为成员函数了或者友元哈舒"]],[41344,41344],[41358,41358]]],[1543586318436,["gjx16@GJXAIOU",[[-1,41356,"哈舒"]],[41358,41358],[41356,41356]]],[1543586321103,["gjx16@GJXAIOU",[[1,41356,"函数"]],[41356,41356],[41358,41358]]],[1543586328525,["gjx16@GJXAIOU",[[1,41359,"- \n"]],[41358,41358],[41361,41361]]],[1543586354630,["gjx16@GJXAIOU",[[1,41361,"关键区别在于成员函数具有this指针，youyuanha"]],[41361,41361],[41389,41389]]],[1543586363618,["gjx16@GJXAIOU",[[-1,41380,"youyuanha"]],[41389,41389],[41380,41380]]],[1543586424331,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543586424331,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543586374349,["gjx16@GJXAIOU",[[1,41380,"友元函数没有this 指针"]],[41380,41380],[41393,41393]]],[1543586376458,["gjx16@GJXAIOU",[[1,41394,"- \n"]],[41393,41393],[41396,41396]]],[1543586407070,["gjx16@GJXAIOU",[[1,41396,"不管是成员函数还是友元函数重载，运算符的使用方法相同"]],[41396,41396],[41422,41422]]],[1543586408995,["gjx16@GJXAIOU",[[1,41423,"- \n"]],[41422,41422],[41425,41425]]],[1543586421154,["gjx16@GJXAIOU",[[1,41425,"但是两种的"]],[41425,41425],[41430,41430]]],[1543586484325,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543586484325,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543586441081,["gjx16@GJXAIOU",[[1,41430,"传递参数不同，实现代码也不同，应用场合也不同"]],[41430,41430],[41452,41452]]],[1543586454206,["gjx16@GJXAIOU",[[1,41456,"**"],[1,41467,"**"]],[41456,41467],[41456,41471]]],[1543586844356,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543586844356,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543586824403,["gjx16@GJXAIOU",[[-1,41586,"\n"]],[41586,41586],[41585,41585]]],[1543586827209,["gjx16@GJXAIOU",[[-1,41601,"\n"]],[41601,41601],[41600,41600]]],[1543586831008,["gjx16@GJXAIOU",[[-1,41549,"\n"]],[41549,41549],[41548,41548]]],[1543586904340,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543586904340,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543586849310,["gjx16@GJXAIOU",[[-1,41786,"主要"]],[41788,41788],[41786,41786]]],[1543586856730,["gjx16@GJXAIOU",[[-1,41803,"\n"]],[41803,41803],[41802,41802]]],[1543586859768,["gjx16@GJXAIOU",[[-1,41852,"\n"]],[41852,41852],[41851,41851]]],[1543586862098,["gjx16@GJXAIOU",[[-1,41867,"\n"]],[41867,41867],[41866,41866]]],[1543586879303,["gjx16@GJXAIOU",[[-1,41871,"public:"]],[41871,41878],[41871,41871]]],[1543586880467,["gjx16@GJXAIOU",[[-1,41872,"\n"]],[41871,41871],[41870,41870]]],[1543586881551,["gjx16@GJXAIOU",[[-1,41871,"\n"]],[41870,41870],[41869,41869]]],[1543586964347,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543586964347,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543586906944,["gjx16@GJXAIOU",[[1,41988,"、、"]],[41988,41988],[41990,41990]]],[1543586909217,["gjx16@GJXAIOU",[[-1,41988,"、、"]],[41990,41990],[41988,41988]]],[1543586933936,["gjx16@GJXAIOU",[[1,41988,"//因为是c1调用的，因此这里的this 指向c2"]],[41988,41988],[42013,42013]]],[1543586934506,["gjx16@GJXAIOU",[[-1,42012,"2"]],[42013,42013],[42012,42012]]],[1543586935086,["gjx16@GJXAIOU",[[1,42012,"1"]],[42012,42012],[42013,42013]]],[1543586943976,["gjx16@GJXAIOU",[[-1,42065,"\n"]],[42065,42065],[42064,42064]]],[1543587024407,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543587024407,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543586990250,["gjx16@GJXAIOU",[[-1,42083,"private:\n"]],[42083,42092],[42083,42083]]],[1543586991279,["gjx16@GJXAIOU",[[-1,42083,"\n"]],[42083,42083],[42082,42082]]],[1543586998355,["gjx16@GJXAIOU",[[1,42064,"、、"]],[42064,42064],[42066,42066]]],[1543587000215,["gjx16@GJXAIOU",[[-1,42064,"、、"]],[42066,42066],[42064,42064]]],[1543587008535,["gjx16@GJXAIOU",[[1,42064,"//tongguo gouh"]],[42064,42064],[42078,42078]]],[1543587018260,["gjx16@GJXAIOU",[[-1,42066,"tongguo gouh"]],[42078,42078],[42066,42066]]],[1543587023704,["gjx16@GJXAIOU",[[1,42066,"通过构造哈舒"]],[42066,42066],[42072,42072]]],[1543587084402,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543587084402,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543587025524,["gjx16@GJXAIOU",[[-1,42070,"哈舒"]],[42072,42072],[42070,42070]]],[1543587043556,["gjx16@GJXAIOU",[[1,42070,"函数实现 tmpp中"]],[42070,42070],[42080,42080]]],[1543587045358,["gjx16@GJXAIOU",[[-1,42078,"p中"]],[42080,42080],[42078,42078]]],[1543587063422,["gjx16@GJXAIOU",[[1,42078,"zhong chengyuanbianlaing de "]],[42078,42078],[42106,42106]]],[1543587068783,["gjx16@GJXAIOU",[[-1,42078,"zhong chengyuanbianlaing de"]],[42078,42105],[42078,42078]]],[1543587078533,["gjx16@GJXAIOU",[[1,42078,"中成员变量的变化"]],[42078,42078],[42086,42086]]],[1543587144434,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543587144434,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543587089817,["gjx16@GJXAIOU",[[1,42113,"使用"]],[42113,42113],[42115,42115]]],[1543587096600,["gjx16@GJXAIOU",[[-1,42248,"\n"]],[42248,42248],[42247,42247]]],[1543587098376,["gjx16@GJXAIOU",[[1,42234,"\n"]],[42233,42233],[42234,42234]]],[1543587102146,["gjx16@GJXAIOU",[[-1,42290,"\n"]],[42290,42290],[42289,42289]]],[1543587106593,["gjx16@GJXAIOU",[[-1,42420,"\n"]],[42420,42420],[42419,42419]]],[1543587204407,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543587204407,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543587160771,["gjx16@GJXAIOU",[[1,42425,"\n"]],[42423,42423],[42424,42424]]],[1543587168479,["gjx16@GJXAIOU",[[1,42424,"程序运行结果："]],[42424,42424],[42431,42431]]],[1543587170167,["gjx16@GJXAIOU",[[1,42433,"\n"]],[42431,42431],[42432,42432]]],[1543587172718,["gjx16@GJXAIOU",[[1,42432,"``"]],[42432,42432],[42434,42434]]],[1543587175819,["gjx16@GJXAIOU",[[1,42433,"4 + 6i\n-2 + -2i"]],[42433,42433],[42448,42448]]],[1543587178678,["gjx16@GJXAIOU",[[1,42439,"`"]],[42439,42439],[42440,42440]]],[1543587182538,["gjx16@GJXAIOU",[[1,42441,"`"]],[42441,42441],[42442,42442]]],[1543587200422,["gjx16@GJXAIOU",[[1,42453,"\n"]],[42452,42452],[42453,42453]]],[1543587201016,["gjx16@GJXAIOU",[[1,42454,"\n"]],[42453,42453],[42454,42454]]],[1543587264428,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"]],[40282,40282],[40417,40417]]],[1543587264428,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"]],[40417,40417],[40282,40282]]],[1543587241252,["gjx16@GJXAIOU",[[1,42456,"**"],[1,42469,"**"]],[42456,42469],[42456,42473]]],[1543587243941,["gjx16@GJXAIOU",[[1,42498,"\n"]],[42497,42497],[42498,42498]]],[1543587261696,["gjx16@GJXAIOU",[[-1,42711,"\n"]],[42711,42711],[42710,42710]]],[1543587324418,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"],[-1,42454,"\n"],[1,42456," "],[-1,42458," "],[1,42471,"："],[-1,42473,"："]],[40282,40282],[42473,42473]]],[1543587324418,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"],[1,42454,"\n"],[-1,42455," "],[1,42458," "],[-1,42470,"："],[1,42473,"："]],[42473,42473],[40282,40282]]],[1543587266352,["gjx16@GJXAIOU",[[-1,42760,"\n"]],[42760,42760],[42759,42759]]],[1543587323096,["gjx16@GJXAIOU",[[-1,43145,"\n"]],[43145,43145],[43144,43144]]],[1543587384421,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"],[-1,42454,"\n"],[1,42456," "],[-1,42458," "],[1,42471,"："],[-1,42473,"："]],[40282,40282],[42473,42473]]],[1543587384421,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"],[1,42454,"\n"],[-1,42455," "],[1,42458," "],[-1,42470,"："],[1,42473,"："]],[42473,42473],[40282,40282]]],[1543587325912,["gjx16@GJXAIOU",[[1,43123,"\n"]],[43122,43122],[43123,43123]]],[1543587328664,["gjx16@GJXAIOU",[[-1,43171,"\n"]],[43171,43171],[43170,43170]]],[1543587504426,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"],[-1,42454,"\n"],[1,42456," "],[-1,42458," "],[1,42471,"："],[-1,42473,"："]],[40282,40282],[42473,42473]]],[1543587504426,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"],[1,42454,"\n"],[-1,42455," "],[1,42458," "],[-1,42470,"："],[1,42473,"："]],[42473,42473],[40282,40282]]],[1543587470493,["gjx16@GJXAIOU",[[1,43208,"\n"]],[43206,43206],[43207,43207]]],[1543587472004,["gjx16@GJXAIOU",[[1,43207,"ch"]],[43207,43207],[43209,43209]]],[1543587473702,["gjx16@GJXAIOU",[[-1,43207,"ch"]],[43209,43209],[43207,43207]]],[1543587478565,["gjx16@GJXAIOU",[[1,43207,"程序运行结果："]],[43207,43207],[43214,43214]]],[1543587480012,["gjx16@GJXAIOU",[[1,43216,"\n"]],[43214,43214],[43215,43215]]],[1543587481704,["gjx16@GJXAIOU",[[1,43215,"//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现前置++和前置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex& operator++(Complex &c1); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\tComplex& operator--()\n\t{\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn *this;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  + 运算符重载\nComplex& operator++(Complex &c1)\n{\n\tc1.a++;\n\tc1.b++;\n\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1,c2;\n\n\t//使用全局函数实现前置++操作符的重置\n\t++c1;\n\tc1.printCom();\n\n\n\t//使用成员函数实现前置--操作符的重置\n\t--c2;\n\tc2.printCom();\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}"]],[43215,43215],[43896,43896]]],[1543587488112,["gjx16@GJXAIOU",[[-1,43215,"//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现前置++和前置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex& operator++(Complex &c1); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\tComplex& operator--()\n\t{\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn *this;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  + 运算符重载\nComplex& operator++(Complex &c1)\n{\n\tc1.a++;\n\tc1.b++;\n\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1,c2;\n\n\t//使用全局函数实现前置++操作符的重置\n\t++c1;\n\tc1.printCom();\n\n\n\t//使用成员函数实现前置--操作符的重置\n\t--c2;\n\tc2.printCom();\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}"]],[43896,43896],[43215,43215]]],[1543587496810,["gjx16@GJXAIOU",[[1,43215,"1 + 1i\n-1 + -1i"]],[43215,43215],[43230,43230]]],[1543587499913,["gjx16@GJXAIOU",[[1,43215,"·"]],[43215,43215],[43216,43216]]],[1543587500812,["gjx16@GJXAIOU",[[-1,43215,"·"]],[43216,43216],[43215,43215]]],[1543587501805,["gjx16@GJXAIOU",[[1,43215,"`"]],[43215,43215],[43216,43216]]],[1543587503190,["gjx16@GJXAIOU",[[1,43223,"`"]],[43223,43223],[43224,43224]]],[1543587564425,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"],[-1,42454,"\n"],[1,42456," "],[-1,42458," "],[1,42471,"："],[-1,42473,"："],[1,43207,"\n"],[-1,43232,"\n"]],[40282,40282],[43232,43232]]],[1543587564425,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"],[1,42454,"\n"],[-1,42455," "],[1,42458," "],[-1,42470,"："],[1,42473,"："],[-1,43206,"\n"],[1,43232,"\n"]],[43232,43232],[40282,40282]]],[1543587505902,["gjx16@GJXAIOU",[[1,43232,"`"]],[43232,43232],[43233,43233]]],[1543587506548,["gjx16@GJXAIOU",[[1,43222,"`"]],[43222,43222],[43223,43223]]],[1543587515499,["gjx16@GJXAIOU",[[-1,43502,"\n"]],[43502,43502],[43501,43501]]],[1543587523016,["gjx16@GJXAIOU",[[-1,43030,"\n"]],[43030,43030],[43029,43029]]],[1543587535471,["gjx16@GJXAIOU",[[-1,43956,"\n"]],[43956,43956],[43955,43955]]],[1543587540647,["gjx16@GJXAIOU",[[-1,44002,"\n"]],[44002,44002],[44001,44001]]],[1543587624438,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"],[-1,42454,"\n"],[1,42456," "],[-1,42458," "],[1,42471,"："],[-1,42473,"："],[1,43206,"\n"],[-1,43233,"\n"]],[40282,40282],[43233,43233]]],[1543587624438,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"],[1,42454,"\n"],[-1,42455," "],[1,42458," "],[-1,42470,"："],[1,42473,"："],[-1,43205,"\n"],[1,43233,"\n"]],[43233,43233],[40282,40282]]],[1543587586759,["gjx16@GJXAIOU",[[-1,44071,"\n"]],[44071,44071],[44070,44070]]],[1543587588975,["gjx16@GJXAIOU",[[-1,44024,"\n"]],[44024,44024],[44023,44023]]],[1543587804443,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"],[-1,42454,"\n"],[1,42456," "],[-1,42458," "],[1,42471,"："],[-1,42473,"："],[1,43206,"\n"],[-1,43233,"\n"]],[40282,40282],[43233,43233]]],[1543587804443,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"],[1,42454,"\n"],[-1,42455," "],[1,42458," "],[-1,42470,"："],[1,42473,"："],[-1,43205,"\n"],[1,43233,"\n"]],[43233,43233],[40282,40282]]],[1543587793589,["gjx16@GJXAIOU",[[-1,44133,"前置和后置运算符总结"],[1,44143,"B"]],[44133,44143],[44134,44134]]],[1543587795827,["gjx16@GJXAIOU",[[-1,44133,"B"]],[44134,44134],[44133,44133]]],[1543587797419,["gjx16@GJXAIOU",[[1,44133,"B"]],[44133,44133],[44134,44134]]],[1543587799295,["gjx16@GJXAIOU",[[1,44133,"前置和后置运算符总结"],[-1,44133,"B"]],[44134,44134],[44133,44143]]],[1543587801635,["gjx16@GJXAIOU",[[1,44133,"**"],[1,44143,"**"]],[44133,44143],[44133,44147]]],[1543587864552,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"],[-1,42454,"\n"],[1,42456," "],[-1,42458," "],[1,42471,"："],[-1,42473,"："],[1,43206,"\n"],[-1,43233,"\n"],[1,44133,"\n"],[-1,44147,"结"]],[40282,40282],[44147,44147]]],[1543587864552,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"],[1,42454,"\n"],[-1,42455," "],[1,42458," "],[-1,42470,"："],[1,42473,"："],[-1,43205,"\n"],[1,43233,"\n"],[-1,44132,"\n"],[1,44147,"结"]],[44147,44147],[40282,40282]]],[1543587804793,["gjx16@GJXAIOU",[[1,44145,":"]],[44145,44145],[44146,44146]]],[1543587807999,["gjx16@GJXAIOU",[[-1,44150,"**"]],[44152,44152],[44150,44150]]],[1543587812655,["gjx16@GJXAIOU",[[-1,44174,"**"]],[44176,44176],[44174,44174]]],[1543587839274,["gjx16@GJXAIOU",[[1,44200,"\n"]],[44199,44199],[44200,44200]]],[1543587839973,["gjx16@GJXAIOU",[[1,44201,"\n"]],[44200,44200],[44201,44201]]],[1543587855636,["gjx16@GJXAIOU",[[1,41323,"1."]],[41323,41323],[41325,41325]]],[1543587924517,[null,[[1,40282,"/"],[-1,40322,"\n"],[1,40400,"\n"],[-1,40417,"\n"],[-1,42456,"\n"],[1,42458," "],[-1,42460," "],[1,42473,"："],[-1,42475,"："],[1,43208,"\n"],[-1,43235,"\n"],[1,44135,"\n"],[-1,44150,"结\n*"],[1,44153,"\n\n"],[-1,44176,"*"],[1,44177,"算"]],[40282,40282],[44178,44178]]],[1543587924517,[null,[[-1,40282,"/"],[1,40323,"\n"],[-1,40400,"\n"],[1,40418,"\n"],[1,42456,"\n"],[-1,42457," "],[1,42460," "],[-1,42472,"："],[1,42475,"："],[-1,43207,"\n"],[1,43235,"\n"],[-1,44134,"\n"],[1,44150,"结\n*"],[-1,44150,"\n\n"],[1,44175,"*"],[-1,44175,"算"]],[44178,44178],[40282,40282]]],[1543587872194,["gjx16@GJXAIOU",[[1,44211,"2."]],[44211,44211],[44213,44213]]],[1543587875941,["gjx16@GJXAIOU",[[1,44354,"3."]],[44354,44354],[44356,44356]]],[1543587887662,["gjx16@GJXAIOU",[[-1,44229,"\n"]],[44229,44229],[44228,44228]]],[1543587892519,["gjx16@GJXAIOU",[[1,44252,"* "],[1,44288,"* "],[1,44303," *"]],[44251,44344],[44253,44350]]],[1543587896518,["gjx16@GJXAIOU",[[1,44288," * 2）根据操作数，写出函数参数 * 3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务 1）要承认操作符重载是一个函数，写出函数名称operator+ ()"]],[44253,44350],[44348,44348]]],[1543587899776,["gjx16@GJXAIOU",[[-1,44288," * 2）根据操作数，写出函数参数 * 3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务 1）要承认操作符重载是一个函数，写出函数名称operator+ ()"]],[44348,44348],[44253,44350]]],[1543587984542,[null,[[-1,40282,""],[1,40282,"/"],[-1,40324,"\n"],[-1,40400,""],[1,40400,"\n"],[-1,40418,"\n"],[-1,42456,"\n"],[1,42458," "],[-1,42460," "],[1,42473,"："],[-1,42475,"："],[-1,43208,""],[1,43208,"\n"],[-1,43237,"\n"],[1,44135,"\n"],[-1,44150,"结\n*"],[1,44153,"\n\n"],[-1,44176,"*"],[1,44177,"算"],[1,44211,"*"],[-1,44213,"*"],[-1,44252,"*"],[1,44254,"*"],[-1,44290,"*"],[1,44292,"*"],[1,44307,"\n"],[-1,44309,"\n"],[1,44359,"*"],[-1,44361,"*"]],[40282,40282],[44361,44361]]],[1543587984542,[null,[[1,40282,""],[-1,40282,"/"],[1,40325,"\n"],[1,40400,""],[-1,40400,"\n"],[1,40419,"\n"],[1,42456,"\n"],[-1,42457," "],[1,42460," "],[-1,42472,"："],[1,42475,"："],[1,43207,""],[-1,43207,"\n"],[1,43237,"\n"],[-1,44134,"\n"],[1,44150,"结\n*"],[-1,44150,"\n\n"],[1,44175,"*"],[-1,44175,"算"],[-1,44210,"*"],[1,44213,"*"],[1,44251,"*"],[-1,44252,"*"],[1,44289,"*"],[-1,44290,"*"],[-1,44306,"\n"],[1,44309,"\n"],[-1,44358,"*"],[1,44361,"*"]],[44361,44361],[40282,40282]]],[1543587941891,["gjx16@GJXAIOU",[[-1,44401,"\n"]],[44401,44401],[44400,44400]]],[1543587949870,["gjx16@GJXAIOU",[[1,44426,",yinwei"]],[44426,44426],[44433,44433]]],[1543587954504,["gjx16@GJXAIOU",[[-1,44427,"yinwei"]],[44433,44433],[44427,44427]]],[1543587965142,["gjx16@GJXAIOU",[[1,44427,"因为成员函数需要在左边的额"]],[44427,44427],[44440,44440]]],[1543587966970,["gjx16@GJXAIOU",[[-1,44439,"额"]],[44440,44440],[44439,44439]]],[1543587968987,["gjx16@GJXAIOU",[[1,44439,"勒种"]],[44439,44439],[44441,44441]]],[1543587970959,["gjx16@GJXAIOU",[[-1,44439,"勒种"]],[44441,44441],[44439,44439]]],[1543587976872,["gjx16@GJXAIOU",[[1,44439,"类中进行修改；"]],[44439,44439],[44446,44446]]],[1543588044542,[null,[[-1,40282,""],[1,40282,"/"],[-1,40324,"\n"],[-1,40400,""],[1,40400,"\n"],[-1,40418,"\n"],[-1,42456,"\n"],[1,42458," "],[-1,42460," "],[1,42473,"："],[-1,42475,"："],[-1,43208,""],[1,43208,"\n"],[-1,43237,"\n"],[1,44135,"\n"],[-1,44150,"结\n*"],[1,44153,"\n\n"],[-1,44176,"*"],[1,44177,"算"],[1,44210,"*"],[-1,44213,"*"],[-1,44252,"*"],[1,44254,"*"],[-1,44290,"*"],[1,44292,"*"],[1,44307,"\n"],[-1,44309,"\n"],[1,44359,"*"],[-1,44361,"*"],[1,44426,"载"],[-1,44446,"载"]],[40282,40282],[44446,44446]]],[1543588044542,[null,[[1,40282,""],[-1,40282,"/"],[1,40325,"\n"],[1,40400,""],[-1,40400,"\n"],[1,40419,"\n"],[1,42456,"\n"],[-1,42457," "],[1,42460," "],[-1,42472,"："],[1,42475,"："],[1,43207,""],[-1,43207,"\n"],[1,43237,"\n"],[-1,44134,"\n"],[1,44150,"结\n*"],[-1,44150,"\n\n"],[1,44175,"*"],[-1,44175,"算"],[-1,44209,"*"],[1,44213,"*"],[1,44251,"*"],[-1,44252,"*"],[1,44289,"*"],[-1,44290,"*"],[-1,44306,"\n"],[1,44309,"\n"],[-1,44358,"*"],[1,44361,"*"],[-1,44425,"载"],[1,44446,"载"]],[44446,44446],[40282,40282]]],[1543588011077,["gjx16@GJXAIOU",[[1,44492,"和"]],[44492,44492],[44493,44493]]],[1543588035448,["gjx16@GJXAIOU",[[1,44535,"，都不让修改的；"]],[44535,44535],[44543,44543]]],[1543588036367,["gjx16@GJXAIOU",[[-1,44542,"；"]],[44543,44543],[44542,44542]]]],null,"gjx16@GJXAIOU"],["0e034631-28d2-4246-9d8e-fd6b461c05e8",1543625859583,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁;\n   * c++面向对象模型初探;  \n   * c++面向对象多态原理探究;\n   * 操作符重载;\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;//定义两个对象c1和c2\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n};\n\n```\nTeacher.cpp\n//具体实现函数内容，在函数名前面加上`类名::`\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1:设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)//因为类的成员变量这里都是private:\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n###  (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n###  (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//需要重载=号操作符，才能解决带来的浅拷贝问题\n\n\tobj2 = obj3; //=号操作，也是一种浅拷贝\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++的默认copy构造函数是浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n\n---\n\n\n### （五）多个对象构造和析构\n\n**1.对象初始化列表**\n\n- 1）对象初始化列表出现原因\n程序本身是有问题的\n```cpp\n\n/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B   //在一个类里面组合了一个带有参数的构造函数的类，因为C++编译器要确定分配给B多大的内存，但是没法初始化A定义的两个对象（因为需要调用有参的构造函数）\n{\npublic:   //没有写B的构造函数，按理说应该调用默认的构造函数\n\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  //主要是因为没有方法和没有机会去初始化这两个A定义的对象\n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB;\n\treturn 0;\n\n}\n\n```\n\n解决方法：\n```cpp\n/*\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n};\n\n\nclass B  \n{\npublic:   \n//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）\n\tB(int _a, int _b) : a1(1), a2(3)  \n\t{\n\n\t}\n//第二种参数传递的方法：\n/*\nB(int _a, int _b,int m,int n) : a1(m), a2(n)  \n\t{\n      a = _a;\n      b = _b;\n\t}\n\t\n*/\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  \n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB(1,2);\n\t//第二种方式：B objB(1,2,4,3)\n\treturn 0;\n\n}\n\n```\n\n**以上程序的操作顺序：**\n首先执行被组合对象的构造函数（a1,a2），如果有多个组合对象，则按照定义的顺序，而不是按照初始化列表的顺序（：后面的顺序）\n析构函数：和构造函数的调用顺序相反\n\n  - 1.必须这样做：\n    - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    - 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n  - 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    - 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    - 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n- 2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n```cpp\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n{\n // some other assignment operation\n}\n```\n\n\n- 3）注意概念\n  - 初始化：被初始化的对象正在创建\n  - 赋值：被赋值的对象已经存在\n\n- 4）注意：\n  - 成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n  - 初始化列表先于构造函数的函数体执行\n\n**说明：**\n\n* 1 C++中提供了初始化列表对成员变量进行初始化\n* 2 使用初始化列表出现原因：\n  * 1.必须这样做：\n    * 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n    * 而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    * 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n  * 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    * 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    * 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n```cpp\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n ABC(int a, int b, int c)\n {\n this->a = a;\n this->b = b;\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"ABC construct ..\\n\");\n }\n\n ~ABC()\n {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n }\n\nprotected:\nprivate:\n int a;\n int b;\n int c;\n};\n\nclass MyD\n{\npublic:\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n {\n cout<<\"MyD()\"<<endl;\n }\n\n ~MyD()\n {\n cout<<\"~MyD()\"<<endl;\n }\n\nprotected:\nprivate:\n ABC abc1; //c++编译器不知道如何构造abc1\n ABC abc2;\n const int m;\n};\n\nint run()\n{\n MyD myD;\n return 0;\n}\n\nint main_dem03()\n{\n run();\n system(\"pause\");\n return 0;\n}\n\n```\n\n\n\n\n### （六）构造函数和析构函数的调用顺序研究\n\n**构造函数与析构函数的调用顺序**\n\n- 1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n- 2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n### （七）构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1构造析构综合训练**\n```cpp\n\n/*\n\n总结 构造和析构的调用顺序\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n\tABC(int a, int b, int c)   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\n\t}\n\n\t~ABC()\n\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\n\nclass MyD \n{\npublic:\n\tMyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~MyD()\n\t{\n\t\tcout << \"~MyD()\" << endl;\n\t}\n\n\tMyD(const MyD & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\tcout << \"MyD(const MyD &obj)\" << endl;\n\t}\n\nprotected:\nprivate:\n\tABC abc1; //c++编译器不知道如何构造abc1//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\tABC abc2;\n\tconst int m;//因为是const m,所以上面所有的m都进行了赋值\n};\n\n\nint doThing(MyD myel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;\n}\n\n\nint run2()//二\n{\n\tMyD myD;//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\treturn 0;\n}\n\nint run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main()\n{\n\trun2();//一\n\t//run3();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n\n\n```\n\n\n**2匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3匿名对象强化训练**\n\n3） 构造中调用构造\n\n```cpp\n/*\n\n构造中调用构造\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass MyTest\n{\npublic:\n\tMyTest(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t}\n\n\tMyTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\n\t\tMyTest(a, b, 10);\n\t}\n\n\t~MyTest()\n\t{\n\t\tcout << \"MyTest is ...\" << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n\n\npublic:\n\tint getC() const { return c; }\n\n\tvoid setC(int val) { c = val; }\n};\n\nint main()\n{\n\tMyTest t1(1, 2);\n\tcout << t1.getC() << endl;\n\tsystem(\"pause\");\n\treturn 0;\n\t\n}\n\n\n```\n\n 结论： 构造函数中调用构造函数，是一个蹩脚的行为。\n程序内存图：\n![搜狗截图20181124125452]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181124125452.png)\n\n### （八）对象的动态建立和释放\n\n**1.new和delete基本语法**\n```cpp\n/*\n\nnew 和delete的使用\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nvoid main()\n{\n\t//先分配内存然后赋值\n\tint *p = new int;  //分配基础类型\n\t*p = 20;  \n\n\t//在定义的时候直接分配内存\n\tint *p1 = new int(30);\n\tcout << *p1 << endl;\n\n\tsystem(\"pause\");\n\treturn; \n}\n\n```\n\n- 1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n  **注意： new和delete是运算符，不是函数，因此执行效率高。**\n\n- 2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： \nnew int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 \nnew char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址    new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n- 3）new和delete运算符使用的一般格式为：\n  用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n![new运算符动态]($resource/new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%A8%E6%80%81.png)\n```cpp\n\n/*\n使用malloc /free 与new /delete的区别\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest();\n\t~Test();\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\nTest::Test()\n{\n\tcout << \"执行了构造函数\" << endl;\n}\n\nTest::~Test()\n{\n\tcout << \"执行了析构函数\" << endl;\n}\n\n\n\nint main()\n{\n\t//基础类型\n\tint *p1 = (int *)malloc(sizeof(int));\n\t*p1 = 10;\n\tdelete p1;\n\n\tint *p2 = new int;\n\t*p2 = 20;\n\tfree(p2);\n\n\n\n\t//数组类型（元素为基础类型）\n\tint *p3 = (int *)malloc(sizeof(int)*10);\n\tp3[0] = 1;\n\tdelete[]p3;\n\n\tint *p4 = new int[10];\n\tp4[1] = 2;\n\tfree(p4);\n\n\n\t//类\n\tTest *p5 = (Test *)malloc(sizeof(Test));\n\tdelete p5;\n\n\tTest *p6 = new Test(10);\n\tfree(p6);\n}\n\n\n```\n**结论：** \nnew：不仅分配内存，而且调用了构造函数\ndelete:不仅释放了内存，而且调用了析构函数\n\n- 4） 应用举例\n\n![5]($resource/5.png)\n\n**2类对象的动态建立和释放**\n\n- 使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n-  C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n  比如：\n\n  Box *pt;  //定义一个指向Box类对象的指针变量pt\n      pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n   这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n  新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n   在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3.编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n\n\n\n## 四、静态成员变量和成员函数\n\n\n思考：每个变量，拥有属性。有没有一些属性，归所有对象拥有？\n\n### （一）静态成员变量\n\n- **1定义静态成员变量**\n  - 关键字 **static**  可以用于说明一个类的成员，\n    静态成员提供了一个同类对象的共享机制\n\n  - 把一个类的成员说明为 **static**  时，这个类无论有多少个对象被创建，这些对象共享这个 **static**  成员\n\n  - 静态成员局部于类，它不是对象成员\n\n![1]($resource/1.png)\n\n例如：\n\n```cpp\n\n/*\n静态成员变量\n*/\n\n#include<iostream>\nusing namespace std;\n\nclass counter\n{\n\n\tstatic int num; //**声明与定义静态数据成员**\n\npublic:\n\n\tvoid setnum(int i) \n\t{ \n\t\tnum = i; \n\t} //成员函数访问静态数据成员\n\n\tvoid shownum() \n\t{ \n\t\tcout << num << endl;\n\t}\n\n};\n\nint counter::num = 0;//声明与定义静态数据成员\n\nvoid main()\n{\n\tcounter a, b;\n\n\ta.shownum(); //调用成员函数访问私有静态数据成员\n\tb.shownum();\n\ta.setnum(10);\n\ta.shownum();\n\tb.shownum();\n\n}\n\n```\n\n![6]($resource/6.png)\n\n**从结果可以看出，访问的是同一个静态数据成员**\n\n- **2使用静态成员变量**\n```cpp\n//例5-14_使用公有静态数据成员\n\n#include<iostream.h>\n\nclass counter\n{ \npublic :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n\n```\n使用静态成员函数调用静态成员变量\n```cpp\n/*\n静态成员函数\n*/\n// 结论：在静态成员函数中可以使用静态成员变量，但是不能使用类中普通的成员变量\n\n#include\"iostream\"\nusing namespace std;\n\nclass BB\n{\npublic:\n\tint printC()\n\t{\n\t\tcout << \"c:\" << c << endl;\n\t\treturn c;\n\t}\n\n\tint addC()\n\t{\n\t\tc = c+1;\n\t}\n\n\n\tstatic void getC()\n\t{\n\t\tcout << \"c\" << c << endl;  //可以直接在静态成员函数中使用静态成员变量，但是不能直接使用一般变量\n\t}\nprivate:\n\tint a;\n\tint b;\n\tstatic int c;\n\n};\n\n\nint BB::c = 10;  //初始化成员变量值\n\nvoid main()\n{\n\tBB b1, b2, b3;\n\tb1.printC();//10\n\tb2.addC();//11\n\tb3.printC();//11\n\n\t//调用成员函数两种方法；\n\tb3.getC();//使用对象.\n\tBB::getC();//使用类::\n\n\n\n}\n\n```\n\n### (二)静态成员函数\n\n- **1）概念**\n\n  - 静态成员函数数冠以关键字static\n\n  - 静态成员函数提供不依赖于类数据结构的共同操作，它没有this指针\n  - 在类外调用静态成员函数用 `_类名_ ::`作限定词，或通过对象调用\n\n- **2）案例**\n![7]($resource/7.png)\n\n- **3）疑难问题：**\n静态成员函数中，不能使用普通变量。\n//静态成员变量属于整个类的，分不清楚，是那个具体对象的属性。\n![成员函数中的疑难问题]($resource/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98.png)\n\n**4.3 综合训练**\n\n\n\n## 五、 C++面向对象模型初探\n\n**前言**\n\n- C++对象模型可以概括为以下2部分：\n\n  - 1. 语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等等。\n\n  - 2. 对于各种支持的底层实现机制。\n\n  在c语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。在c++中，通过抽象数据类型（abstract data type，ADT），在类中定义数据和函数，来实现数据和函数直接的绑定。\n\n  概括来说，在C++类中有两种成员数据：static、nonstatic；三种成员函数：static、nonstatic、virtual。\n\n![C++类的组成]($resource/C++%E7%B1%BB%E7%9A%84%E7%BB%84%E6%88%90.png)\n\n### （一）基础知识\n\nC++中的class从面向对象理论出发，将变量(属性)和函数(方法)集中定义在一起，用于描述现实世界中的类。从计算机的角度，程序依然由数据段和代码段构成。\n\n**C++编译器如何完成面向对象理论到计算机程序的转化？**\n换句话：C++编译器是如何管理类、对象、类和对象之间的关系\n具体的说：具体对象调用类中的方法，那，c++编译器是如何区分，是那个具体的类，调用这个方法那?\n\n思考一下程序结果\n```cpp\n/*\n面向对象模型初探\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass C1\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\nprotected:\n\nprivate:\n\n}; //12\n\nclass C2\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\n\tstatic int m; \n\npublic:\n\n\tint getK() const { return k; } //方法是属于代码，应该放在代码区\n\tvoid setK(int val) { k = val; } \n\nprotected:\n\nprivate:\n}; \n\nstruct S1\n{\n\tint i;\n\tint j;\n\tint k;\n}; \n\nstruct S2\n{\n\tint i;\n\tint j;\n\tint k;\n\tstatic int m;\n}; \n\nint main()\n{\n\n\tprintf(\"c1:%d \\n\", sizeof(C1));\n\tprintf(\"c2:%d \\n\", sizeof(C2));\n\tprintf(\"s1:%d \\n\", sizeof(S1));\n\tprintf(\"s2:%d \\n\", sizeof(S2));\n\tsystem(\"pause\");\n\n}\n```\n程序运行结果：\n`c1:12`\n`c2:12`\n`s1:12`\n`s2:12`\n\n \n### (二)编译器对属性和方法的处理机制\n\n通过上面的案例，我们可以的得出：\n1）C++类对象中的成员变量和成员函数是分开存储的\n- 成员变量：\n  - 普通成员变量：存储于对象中，与struct变量有相同的内存布局和字节对齐方式\n  - 静态成员变量：存储于全局数据区中\n\n- 成员函数：存储于代码段中。\n问题出来了：很多对象共用一块代码？代码是如何区分具体对象的那？\n换句话说：int getK() const { return k; }，代码是如何区分，具体obj1、obj2、obj3对象的k值？\n\n2）C++编译器对普通成员函数的内部处理\n\n![C++编译器对普通成员函数的内部处理]($resource/C++%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E9%83%A8%E5%A4%84%E7%90%86.png)\n\n请仔细思考，并说出你的总结！\n\n\n\n### （三）总结\n\n1、C++类对象中的成员变量和成员函数是分开存储的。C语言中的内存四区模型仍然有效！\n**2、C++中类的普通成员函数都隐式包含一个指向当前对象的this指针。**\n3、静态成员函数、成员变量属于类\n\n静态成员函数与普通成员函数的区别\n\n静态成员函数不包含指向具体对象的指针\n\n普通成员函数包含一个指向具体对象的指针\n\n\n### （四）this指针\n\n![this指针图示]($resource/this%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png)\n\n实验1：若类成员函数的形参 和 类的属性（成员变量）名字相同，通过this指针来解决。\n```cpp\n\n/*\nthis 指针\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass Test\n{\npublic:\n\tTest( int a, int b)//Test(Test *this, int a, int b)//因为这里成员函数的形参和成员变量一样，不用this指针会出现：a = a ,b = b;\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printT()\n\t{\n\t\tcout << \"a; \" << a << endl;\n\t\tcout << \"b: \" << this->b << endl;\n\t}\n\n\n    const void hello(int a,int b )\n    {\n      //下面这两个语句都是错误的\n      this->a = 100;\n      this ->b = 200;\n    }\n   //const修饰的this指针，即相当于this指针指向的内存空间不能被修改\n   //因为上面的函数会别C++编译器解析为:void hello(const Test *this, int a ,int b)\n   //同时上面的const其实下载函数（）外面的任何位置都行\n   \nprotected:\nprivate:\n\tint a;\n\tint b;\n};\nint  main()\n{\n\tTest t1(1, 2);\n\tt1.printT();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`a:1`\n`b:2`\n\n\n实验2：类的成员函数可通过const修饰，请问const修饰的是谁\n\n\n### （五）全局函数PK成员函数\n\n 1、把全局函数转化成成员函数，通过this指针隐藏左操作数\n\n   Test add(Test &t1, Test &t2)===》Test add( Test &t2)\n```cpp\n/*\n全局函数与成员函数\n*/\n\n\n//使用全局函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\t\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nTest Testadd(Test &t1, Test &t2)\n{\n\tTest tmp(3,4);\n\treturn tmp;\n}\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3(2, 3);\n\tt3= Testadd(t1, t2);\n}\n```\n\n```cpp\n//使用成员函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\tTest Testadd(Test &t2)\n\t{\n\t\tTest tmp(this->a + t2.a, this->b + t2.b);\n\t\treturn tmp;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3 = t1.Testadd(t2);//匿名对象直接转化成t4\n\tTest t4(3,5);\n\tt4 = t1.Testadd(t2);  //匿名对象复制给t5\n}\n\n\n```\n 2、把成员函数转换成全局函数，多了一个参数\n\n   void printAB()===》void printAB(Test *pthis)\n\n 3、函数返回元素和返回引用\n```cpp\nTest& add(Test &t2) //*this //函数返回引用,相当于返回自身，谁调用返回谁\n {      \n   this->a = this->a + t2.getA();\n\n   this->b = this->b + t2.getB();\n\n   return *this; //*操作让this指针回到元素状态\n\n }\n\nTest add2(Test &t2) //*this //函数返回元素\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n return t3;\n\n }\n\n void add3(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n //return t3;\n\n }\n  \n\n```\n\n\n\n\n---\n\n## 六、友元\n\n### （一）友元函数\n- 首先友元函数是全局函数，在友元函数中可以修改类的私有属性；\n- 友元函数在类中的声明位置位于public或者private只下均可；\n![8]($resource/8.png)\n\n```cpp\n//友元函数：\n\n#include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend void modify(A *PA,int _a);  //友元函数的声明\n\n\tA(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\n\nprivate:\n\tint a;\n\tint b;\n};\n\nvoid modify(A *PA,int _a)//后面的参数可加可不加\n{\n\t//PA->a = 100;//可以这样直接修改值\n\tPA->a = _a;  //通过传递的值进行修改\n}\n\n\nint main()\n{\n\tA a1(1, 2);\n\tcout << \"a:\" << a1.getA() << endl;\n\tmodify(&a1,20);\n\n\tint aa = a1.getA();\n\n\tcout << \"aa:\" << aa << endl;\n}\n```\n![9]($resource/9.png)\n\n\n### （二）友元类\n\n- 若B类是A类的友员类，则B类的所有成员函数都是A类的友员函数\n- 若B类是A类的友元类，则B类可以直接修改A的成员变量和成员函数\n- 友员类通常设计为一种对数据操作或类之间传递消息的辅助类\n程序示例：\n```cpp\n//友元类\n #include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend class B;//将B 声明为A的友元类，这样B 可以直接修改A的成员变量和成员函数 \n\n\tA(int a=0, int b=0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B\n{\npublic:\n\n\tvoid set(int a)\n\t{\n\t\tobjA.a = a;\n\t}\n\n\tvoid printa()\n\t{\n\t\tcout << objA.a << endl;\n\t}\n\nprivate:\n\tA objA;\n};\n\n\nint main()\n{\n\tB b1;\n\tb1.set(200);\n\tb1.printa();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：200\n\n![10]($resource/10.png)\n\n\n\n## 七、强化训练\n\n**1 static关键字强化训练题**\n\n某商店经销一种货物。货物购进和卖出时以箱为单位，各箱的重量不一样，因此，商店需要记录目前库存的总重量。现在用C++模拟商店货物购进和卖出的情况。\n```cpp\n#include \"iostream\"\nusing namespace std;\n\nclass Goods\n{\npublic:\n\n\tGoods(int w) { weight = w; total_weight += w; }\n\n\t~Goods() { total_weight -= weight; }\n\n\tint Weight() { return weight; };\n\n\tstatic int TotalWeight() { return total_weight; }\n\n\tGoods *next;\n\nprivate:\n\n\tint weight;\n\tstatic int total_weight;\n\n};\n\nint Goods::total_weight = 0;\n\n//r尾部指针\n\nvoid purchase(Goods * &f, Goods *& r, int w)\n{\n\n\tGoods *p = new Goods(w);\n\n\tp->next = NULL;\n\n\tif (f == NULL) f = r = p;\n\n\telse { r->next = p; r = r->next; } //尾部指针下移或新结点变成尾部结点\n\n}\n\nvoid sale(Goods * & f, Goods * & r)\n{\n\n\tif (f == NULL) { cout << \"No any goods!\\n\"; return; }\n\n\tGoods *q = f; f = f->next; delete q;\n\n\tcout << \"saled.\\n\";\n\n}\n\nvoid main()\n{\n\tGoods * front = NULL, *rear = NULL;\n\n\tint w; int choice;\n\n\tdo\n\t{\n\t\tcout << \"Please choice:\\n\";\n\n\t\tcout << \"Key in 1 is purchase,\\nKey in 2 is sale,\\nKey in 0 is over.\\n\";\n\n\t\tcin >> choice;\n\n\t\tswitch (choice) // 操作选择\n\t\t{\n\t\tcase 1: // 键入1，购进1箱货物\n\t\t{ cout << \"Input weight: \";\n\t\tcin >> w;\n\n\t\tpurchase(front, rear, w); // 从表尾插入1个结点\n\n\t\tbreak;\n\t\t}\n\n\t\tcase 2:              // 键入2，售出1箱货物\n\t\t{ sale(front, rear); break; } // 从表头删除1个结点\n\n\t\tcase 0: break;              // 键入0，结束\n\t\t}\n\n\t\tcout << \"Now total weight is:\" << Goods::TotalWeight() << endl;\n\n\t} while (choice);\n}\n```\n**2** **数组类封装**\n\n目标：解决实际问题，训练构造函数、copy构造函数等，为操作符重载做准备\n\n数组类的头文件:`Array.h`\n```cpp\n#pragma once\nclass Array\n{\npublic:\n\tArray(int length);\n\tArray(const Array&obj);\n\t~Array();\npublic:\n\tint length();\n\n\tvoid setData(int index, int value);\n\n\tint getData(int index);\nprivate:\n\tint m_length;\n\tchar *m_space;\n};\n```\n\n数组类的头文件的实现：`Array.cpp`\n```cppp\n#include \"Array.h\"\nusing namespace std;\n#include\"iostream\"\n\nArray::Array(int length)\n{\n\tif (length < 0)\n\t{\n\t\tlength = 0;\n\t}\n\telse\n\t{\n\t\tm_length = length;\n\t\tm_space = new char[m_length];\n\t}\n}\n\nArray::Array(const Array&obj)\n{\n   this->m_length = obj.m_length;\n   this->m_space = new char [this->m_length];//进行分配内存空间\n\n  for(int i= 0; i < obj.m_length;i++)//数组元素复制， 这里的obj.m_length可以直接替换成m_length\n  {\n    this->m_space[i] = obj.m_space[i];\n  }\n}\n\nArray::~Array()\n{\n\tif (m_space != NULL)\n\t{\n\t\tdelete[] m_space;\n\t\tm_length = 0;\n\t}\n}\n\nvoid Array::setData(int index, int valude)\n{\n\tm_space[index] = valude;\n}\n\nint Array::getData(int index)\n{\n\treturn m_space[index];\n}\n\nint Array::length()\n{\n\treturn m_length; \n}\n```\n\n数组类的测试\n```cpp\n#include \"iostream\"\n#include \"Array.h\"\nusing namespace std;\n\nint main()\n{\n\tArray a1(10);\n\tfor (int i = 0; i < a1.length(); i++)\n\t{\n\t\ta1.setData(i, i);\n\t}\n\tfor (int i = 0; i <  a1.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a1.getData(i));\n\t}\n\n\tArray a2 = a1;\n\n\tfor (int i = 0; i < a2.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a2.getData(i));\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**3.小结**\n\n* 类通常用关键字class定义。类是数据成员和成员函数的封装。类的实例称为对象。\n* 结构类型用关键字struct定义，是由不同类型数据组成的数据类型。\n* 类成员由private, protected, public决定访问特性。public成员集称为接口。\n* 构造函数在创建和初始化对象时自动调用。析构函数则在对象作用域结束时自动调用。\n* 重载构造函数和复制构造函数提供了创建对象的不同初始化方式。\n* 静态成员是局部于类的成员，提供一种同类对象的共享机制。\n* 友员用关键字friend声明。友员是对类操作的一种辅助手段。一个类的友员可以访问该类各种性质的成员\n* 链表是一种重要的动态数据结构，可以在程序运行时创建或撤消数据元素。\n\n\n\n---\n\n\n## 八、运算符重载\n\n### （一）概念\n\n#### **1.什么是运算符重载**\n\n![11]($resource/11.png)\n所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是”一名多用”。\n\n运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重载。例如，大 家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行加法运算，如5+8， 5.8 +3.67等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的， 但由于C++已经对运算符”+”进行了重载，所以就能适用于int, float, doUble类型的运算。\n\n又如`<<`是C的位运算中的位移运算符（左移），但在输出操作中又是与流对 象cout 配合使用的流插入运算符，`>>`也是位移运算符(右移），但在输入操作中又是与流对象 cin 配合使用的流提取运算符。这就是运算符重载(operator overloading)。C系统对`<<`和`>>`进行了重载，用户在不同的场合下使用它们时，作用是不同 的。对`<<`和`>>`的重载处理是放在头文件stream中的。因此，如果要在程序中用`<<`和`>>`作流插入运算符和流提取运算符，必须在本文件模块中包含头文件stream(当然还应当包括”using namespace std“)。\n\n现在要讨论的问题是：用户能否根据自己的需要对C++已提供的运算符进行重载，赋予它们新的含义，使之一名多用？\n\n#### **2.运算符重载入门技术推演**\n\n1为什么会用运算符重载机制\n//原因 Complex是用户自定义类型，编译器根本不知道如何进行加减，但是编译器给提供了一种机制，让用户自己去完成，自定义类型的加减操作。。。这个机制就是运算符重载机制\n\n用复数类举例，定义一个Complex类,有两个对象，每个对象由两个属性，要求使用对象之间的加法实现对应属性的相加，示例程序如下：\n```cpp\n\n/*对于基础数据类型，C++编译器知道如何进行运算，但是对于用户自定义的类型编译器提供了一种\n让自定义数据类型进行运算符操作的机制,=》运算符重载机制\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\npublic:\n\tfriend Complex operator+(Complex &c1, Complex &c2);//友元函数声明\n\n\tComplex(int a = 0, int b = 0)//构造函数\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\nprivate:\n  int a;\n  int b;\n};\n\n/*使用全局函数，通过调用全局函数实现\nComplex myAdd(Complex &c1, Complex &c2)\n{\n Complex tmp(c1.a+ c2.a, c1.b + c2.b);\n\n return tmp;\n}\n*/\n\n\n//可以简单的想象为将上面全局函数的函数名替换为operator+\nComplex operator+(Complex &c1, Complex &c2)\n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\treturn tmp;\n}\n\n\n\nint  main()\n{\n\tComplex c1(1, 2), c2(3, 4);\n\n\t//方法1： 通过调用普通函数实现\n\t//Complex c3 = myAdd(c1, c2);\n\t//c3.printCom();\n\n\n\t//方法2  将函数名称替换为：operator+ \n\t//使用以下方式进行调用\n\t//Complex c3 = operator+(c1, c2);\n\t//c3.printCom();\n\n\n\t//方法3：最常用的调用方式\n\tComplex c3 = c1 + c2; \n\tc3.printCom()\n\n\tsystem(\"pause\");\n\treturn;\n}\n```\n程序运行结果：`4+6i`\n\n\n---\n\n### （二）运算符重载的限制\n![12]($resource/12.png)\n\n重载运算符函数可以对运算符进行新的解释，但是原有的基本语义不变：\n* 不改变运算符的优先级\n* 不改变运算符的结合性\n* 不改变运算符所需要的操作数\n* 不能创建新的运算符\n\n---\n\n### （三）运算符重载编程基础\n![14]($resource/14.png)\n例如:\n   //全局函数  完成 +操作符  重载  \n    Complex operator+(Complex &c1, Complex &c2)\n\n  //类成员函数  完成 -操作符  重载\n    Complex operator-(Complex &c2)\n\n#### **1.运算符重载的两种方法:**\n- 运算符可以重载为成员函数了或者友元函数\n- 关键区别在于成员函数具有this指针，友元函数没有this 指针\n- 不管是成员函数还是友元函数重载，运算符的使用方法相同\n- 但是两种的传递参数不同，实现代码也不同，应用场合也不同\n\n- **二元操作符重载的实现：**\n![16]($resource/16.png)\n \n```cpp\n//二元函数操作符的重载的两种方法\n\n\n/*全局函数、类成员函数方法实现运算符重载步骤\n1）要承认操作符重载是一个函数，写出函数名称operator + ()\n2）根据操作数，写出函数参数\n3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex operator+(Complex &c1, Complex &c2); //这里是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\t//成员函数实现 - 运算符重载 \n\tComplex operator-(Complex &c2)//因为是c1调用的，因此这里的this 指向c1\n\t{\n\t\tComplex tmp(this->a - c2.a, this->b -  c2.b);//通过构造函数实现 tmp中成员变量的变化 \n\t\treturn tmp;\n\t}\n\n};\n\n\n//使用全局函数实现  + 运算符重载\nComplex operator+(Complex &c1, Complex &c2)\n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\n\treturn tmp;\n}\n\n\nint  main()\n{\n\tComplex c1(1, 2), c2(3, 4);\n\n\t//使用 全局函数\n\tComplex c3 = c1 + c2;\n\tc3.printCom();\n\n\t//使用成员函数\n\tComplex c4 = c1.operator-(c2);\n\tc4.printCom();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`4 + 6i`\n`-2 + -2i`\n\n\n- **一元函数操作符重载的实现：**\n![17]($resource/17.png)\n\n- 实现前置++和前置--\n```cpp\n//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现前置++和前置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex& operator++(Complex &c1); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\tComplex& operator--()\n\t{\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn *this;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  + 运算符重载\nComplex& operator++(Complex &c1)\n{\n\tc1.a++;\n\tc1.b++;\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1,c2;\n\n\t//使用全局函数实现前置++操作符的重置\n\t++c1;\n\tc1.printCom();\n\n\n\t//使用成员函数实现前置--操作符的重置\n\t--c2;\n\tc2.printCom();\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`1 + 1i`\n`-1 + -1i`\n\n- 实现后置++和后置--\n```cpp\n//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现后置++ 和后置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex operator++(Complex &c1, int); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\t//成员函数实现后置--\n\tComplex operator--(int)\n\t{\n\t\tComplex tmp = *this;\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn tmp;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  ++ 运算符重载\nComplex operator++(Complex &c1,int)  //为了和前置++的函数能够共同存在，参数中加了一个占位符从而实现函数重载\n{\n\t//前置++是先使用后++ ，所以应该先返回c1,但是直接使用return c1.会造成程序的直接退出，后面的++无法实现，所以使用临时变量\n\n\tComplex tmp = c1;\n\tc1.a++;\n\tc1.b++;\n\treturn tmp;\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1, c2;\n\t//使用全局函数实现后置++操作符的重置\n\tc1++;\n\tc1.printCom();\n\n\t//使用成员函数实现后置--操作符的重置\n\tc2--;\n\tc2.printCom();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n\n**前置和后置运算符总结:**\n\nC++中通过一个占位参数来区分前置运算和后置运算\n![18]($resource/18.png)\n\n\n\n#### **2.定义运算符重载函数名的步骤**\n全局函数、类成员函数方法实现运算符重载步骤\n * 1）要承认操作符重载是一个函数，写出函数名称operator+ ()\n * 2）根据操作数，写出函数参数\n * 3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n\n#### **3.友元函数实现操作符重载的应用场景**\n\n**1）友元函数和成员函数选择方法**\n- 当无法修改左操作数的类时，使用全局函数进行重载,因为成员函数需要在左边的类中进行修改；\n- =, [], ()和->操作符只能通过成员函数进行重载\n\n**2）用友元函数重载 <<和 >>操作符**\n\n* istream 和 ostream 是 C++ 的预定义流类，都不让修改的\n* cin 是 istream 的对象，cout 是 ostream 的对象\n* 运算符 << 由ostream 重载为插入操作，用于输出基本类型数据\n* 运算符 >> 由 istream 重载为提取操作，用于输入基本类型数据\n* 用友员函数重载 << 和 >> ，输出和输入用户自定义的数据类型\n\na）用全局函数方法实现 << 操作符\n```pp\n//实现<<运算符的重载\n\n//注释内部是一套完整的程序，但是只能实现一次打印输出，新的一套程序可以实现链式输出\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\t//friend  void operator<<(ostream &cout, Complex &c1); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n};\n\n/*这里类似于cout只能有全局函数加上友元函数实现，因为如果要使用成员函数实现，需要在cout 的类：ostream中定义成员函数，\n但是这个ostream类是系统隐藏的，不现实；\nvoid operator<<(ostream &cout, Complex &c1)\n{\n\tcout << c1.a << \" + \" << c1.b << \"i\" << endl;\n}\n*/\n\nostream& operator<<(ostream &cout, Complex &c2)  //要想实现函数返回值当左值，需要返回一个引用\n{\n\tcout << c2.a << \" + \" << c2.b << \"i\" << endl;\n\treturn cout;\n}\n\n\n \nint  main()\n{\n\tComplex c1, c2;\n\t//cout << c1;  //实现将c1中两个元素以a+bi的形式直接打印输出；\n\t/*\n\t首先承认运算符重载是函数，所以函数名为：operator<<\n\t其次因为有左右参数，分别为ostream 和Complex类，所有函数头为：operator<<(ostream&cout,Complex c1)\n\t然后根据返回值确定最前面的返回值类型\n\t*/\n\n\tcout << c2 << \"kdjfkdjfkd\";\n\t//因为<<操作符是从左到右，所以左边执行返回值要当左值再次执行这个函数\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n**3）友元函数重载操作符使用注意点**\n\n- a） 友员函数重载运算符常用于运算符的左右操作数类型不同的情况\n![19]($resource/19.png)\n- b）其他\n  - 在第一个参数需要隐式转换的情形下，使用友员函数重载运算符是正确的选择\n  - 友员函数没有 this 指针，所需操作数都必须在参数表显式声明，很容易实现类型的隐式转换\n  - C++中不能用友员函数重载的运算符有\n     = （）  ［］  －>\n\n**4）友元函数案例vector类**\n```cpp\n#include <iostream>\nusing namespace std;\n\n//为vector类重载流插入运算符和提取运算符\n\nclass vector\n{\npublic:\n\tvector(int size = 1);\n\n\t~vector();\n\n\tint & operator[](int i);\n\n\tfriend ostream & operator << (ostream & output, vector &);\n\n\tfriend istream & operator >> (istream & input, vector &);\n\nprivate:\n\tint * v;\n\n\tint len;\n\n};\n\nvector::vector(int size)\n{\n\tif (size <= 0 || size > 100)\n\t{\n\t\tcout << \"The size of \" << size << \" is null !\\n\"; abort();\n\t}\n\n\tv = new int[size]; len = size;\n}\n\nvector :: ~vector()\n{\n\tdelete[] v;\n\n\tlen = 0;\n}\n\nint &vector::operator[](int i)\n{\n\tif (i >= 0 && i < len) return v[i];\n\n\tcout << \"The subscript \" << i << \" is outside !\\n\"; abort();\n}\n\nostream & operator << (ostream & output, vector & ary)\n{\n\tfor (int i = 0; i < ary.len; i++)\n\t\toutput << ary[i] << \" \";\n\n\toutput << endl;\n\treturn output;\n}\n\nistream & operator >> (istream & input, vector & ary)\n{\n\tfor (int i = 0; i < ary.len; i++)\n\t\tinput >> ary[i];\n\n\treturn input;\n}\n\nvoid main()\n{\n\tint k;\n\tcout << \"Input the length of vector A :\\n\";\n\tcin >> k;\n\tvector A(k);\n\tcout << \"Input the elements of vector A :\\n\";\n\tcin >> A;\n\tcout << \"Output the elements of vector A :\\n\";\n\tcout << A;\n\tsystem(\"pause\");\n}\n\n```\n\n### （四）运算符重载提高\n\n#### **1.运算符重载机制**\n\nC++编译器是如何支持操作符重载机制的?\n\n#### **2.重载赋值运算符=**\n\n* 赋值运算符重载用于对象数据的复制\n* operator= 必须重载为成员函数\n* 重载函数原型为：\n  类型&类名:: operator= ( const  类名 & ) ;\n\n案例：完善Name类，支持=号操作。\n![22]($resource/22.png)\n\n  结论:\n 1 先释放旧的内存\n 2 返回一个引用\n 3 =操作符 从右向左\n```cpp\n//重载 = 操作符\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\t//obj3 = obj1; // C++编译器提供的  等号操作  也属  浅拷贝\\\n\t// obj4 = obj3 = obj1\n\t//obj3.operator=(obj1)\n\n\tName& operator=(Name &obj1)\n\t{\n\t\t//1 先释放obj3旧的内存\n\n\t\tif (this->pName != NULL)\n\t\t{\n\t\t\tdelete[] pName;\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\t//2 根据obj1分配内存大小\n\n\t\tthis->size = obj1.size;\n\t\tthis->pName = new char[size + 1];\n\n\t\t//3把obj1赋值给obj3\n\n\t\tstrcpy(pName, obj1.pName);\n\t\treturn *this;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nint main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n\n#### **3.重载数组下表运算符[]** ==这里的视频再看一遍==\n- 重载[]和()运算符\n  - 运算符 [] 和 () 是二元运算符\n  - [] 和 () 只能用成员函数重载，不能用友元函数重载\n\n- 重载下标运算符 []\n  - [] 运算符用于访问数据对象的元素\n  重载格式：  返回值类型 类 :: operator[] ( 类型 ) ；\n  设 x 是类 X 的一个对象，则表达式 `x[y]` 可被解释为  `x.operator[](y)`\n\n![33]($resource/33.png)\n![44]($resource/44.png)\n\n\n#### **4.重载函数调用符()**\n\n() 运算符用于函数调用\n\n重载格式:  返回值类型 类:: operator() ( 表达式表 ) ；\n\n例1\n设 x是类 X的一个对象，则表达式*\nx ( arg1, arg2, … )\n可被解释为\nx . operator () (arg1, arg2, … )\n\n**案例：**\n例2：用重载()运算符实现数学函数的抽象\n```cpp\n\n#include <iostream>\n\nclass F\n\n { public :\n\n double operator ( )  ( double x , double y ) ;\n\n } ;\n\ndouble F :: operator ( )  ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\nf.getA();\n\n cout << f ( 5.2 , 2.5 ) << endl ; // **f . _operator()_ (5.2, 2.5)**\n\n}\n```\n比较普通成员函数\n\n**//例3用重载()运算符实现 pk成员函数**\n```cpp\n#include <iostream.h>\n\nclass F\n\n { public :\n\n double memFun ( double x , double y ) ;\n\n } ;\n\ndouble F :: memFun ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\n cout << f.memFun ( 5.2 , 2.5 ) << endl ;\n\n}\n```\n\n#### **5.为什么不要重载&&和||操作符**\n\n- 理论知识：\n  - 1）&&和||是C++中非常特殊的操作符\n  - 2）&&和||内置实现了短路规则\n  - 3）操作符重载是靠函数重载来完成的\n  - 4）操作数作为函数参数传递\n  - 5）C++的函数参数都会被求值，无法实现短路规则\n```cpp\n#include <cstdlib>\n\n#include <iostream>\n\nusing namespace std;\n\nclass Test\n\n{\n\n int i;\n\npublic:\n\n Test(int i)\n\n {\n\n this->i = i;\n\n }\n\n Test operator+ (const Test& obj)\n\n {\n\n Test ret(0);\n\n cout<<\"执行+号重载函数\"<<endl;\n\n ret.i = i + obj.i;\n\n return ret;\n\n }\n\n bool operator&& (const Test& obj)\n\n {\n\n cout<<\"执行&&重载函数\"<<endl;\n\n return i && obj.i;\n\n }\n\n};\n\n// && 从左向右\n\nvoid main()\n\n{\n\n int a1 = 0;\n\n int a2 = 1;\n\n cout<<\"注意：&&操作符的结合顺序是从左向右\"<<endl;\n\n if( a1 && (a1 + a2) )\n\n {\n\n cout<<\"有一个是假，则不在执行下一个表达式的计算\"<<endl;\n\n }\n\n Test t1 = 0;\n\n Test t2 = 1;\n\n If ( t1 && (t1 + t2) )\n\n {\n\n=è\n\n T1.operator&&( t1 + t2) )\n\nT1.operator&&( t1.operator+(t2) )\n\n //t1 && t1.operator+(t2)\n\n // t1.operator( t1.operator(t2) )\n\n cout<<\"两个函数都被执行了，而且是先执行了+\"<<endl;\n\n }\n\n system(\"pause\");\n\n return ;\n\n}\n\n```\n\n\n### （五）运算符重载在项目开发中的应用\n\n#### **1实现一个数组类**\n\n添加<< >>\n\n#### **2实现一个字符串类**\n\n构造函数要求\n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串类 以零结尾的字符串\n\n//若len为0,表示空串\n```cpp\nMyString a; //空串 “”\n\nMyString a(“dddd”);\n\nMyString b = a;\n\nb = “aaaaaa” \n\nb = a;\n\nif (a > b)\n\nif (a == b)\n\nb[i] = ‘a’;\n```\n常用的操作符\n\n<< >> != == > < =\n\n```cpp\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串 以零结尾的字符串\n\nclass MyString\n\n{\n\n friend ostream& operator<<(ostream &out, const MyString &s);\n\npublic: //构造和析构\n\n MyString(int len = 0);\n\n MyString(const char *p);\n\n MyString(const MyString& obj);\n\n ~MyString();\n\npublic: //操作符重载\n\n MyString& operator=(const char *p);\n\n MyString& operator=(const MyString& obj);\n\n char& operator[](int index) const;\n\npublic:\n\n bool operator==(const char* p) const;\n\n bool operator!=(const char* p) const;\n\n bool operator==(const MyString& s) const;\n\n bool operator!=(const MyString& s) const;\n\npublic: //string to c\n\n char *c_str();\n\n const char* c_str() const;\n\n int length()\n\n {\n\n return m_len;\n\n }\n\npublic:\n\n int operator<(const char *p);\n\n int operator>(const char *p);\n\n int operator<(const MyString &s);\n\n int operator>(const MyString &s);\n\nprivate:\n\n int m_len;\n\n char  *m_p;\n\n};\n\n```\n\n\n#### **3智能指针类编写**\n\n1问题抛出\n  指针使用过程中，经常会出现内存泄漏和内存多次被释放常\n\n2 解决方案：例如：boost库的智能指针\n  项目开发中，要求开发者使用预先编写的智能指针类对象代替C语言中的原生指针\n\n3 智能指针思想\n  工程中的智能指针是一个类模板\n  通过构造函数接管申请的内存\n  通过析构函数确保堆内存被及时释放\n  通过重载指针运算符* 和 -> 来模拟指针的行为\n  通过重载比较运算符 == 和 != 来模拟指针的比较\n\n```cpp\nclass Test\n\n{\n\npublic:\n\n Test()\n\n {\n\n this->a = 10;\n\n }\n\n void printT()\n\n {\n\n cout<<a<<endl;\n\n }\n\nprivate:\n\n int a;\n\n};\n\nclass MyTestPointer\n\n{\n\npublic:\n\npublic:\n\n MyTestPointer()\n\n {\n\n p = NULL;\n\n }\n\n MyTestPointer(Test* p)\n\n {\n\n this->p = p;\n\n }\n\n ~MyTestPointer()\n\n {\n\n delete p;\n\n }\n\n Test* operator->()\n\n {\n\n return p;\n\n }\n\n Test& operator*()\n\n {\n\n return *p;\n\n }\n\nprotected:\n\n Test *p;\n\n};\n\nvoid main01_classp()\n\n{\n\n Test *p = new Test;\n\n p->printT();\n\n delete p;\n\n MyTestPointer myp = new Test; //构造函数\n\n myp->printT(); //重载操作符 ->\n\n};\n\n```\n\n```cpp\n\n\nclass MyIntPointer\n\n{\n\npublic:\n\npublic:\n\n MyIntPointer()\n\n {\n\n p = NULL;\n\n }\n\n MyIntPointer(int* p)\n\n {\n\n this->p = p;\n\n }\n\n ~MyIntPointer()\n\n {\n\n delete p;\n\n }\n\n int* operator->()\n\n {\n\n return p;\n\n }\n\n int& operator*()\n\n {\n\n return *p;\n\n }\n\nprotected:\n\n int *p;\n\n};\n\nvoid main02_intp()\n\n{\n\n int *p = new int(100);\n\n cout<<*p<<endl;\n\n delete p;\n\n MyIntPointer myp = new int(200);\n\n cout<<*myp<<endl; //重载*操作符\n\n};\n```\n\n**8.7****附录：运算符和结合性**\n\n![55]($resource/55.png)\n\n![66]($resource/66.png)\n\n- 总结\n  * 操作符重载是C++的强大特性之一\n  * 操作符重载的本质是通过函数扩展操作符的语义\n  * operator关键字是操作符重载的关键\n  * friend关键字可以对函数或类开发访问权限\n  * 操作符重载遵循函数重载的规则\n  * 操作符重载可以直接使用类的成员函数实现\n  * =, [], ()和->操作符只能通过成员函数进行重载\n  * ++操作符通过一个int参数进行前置与后置的重载\n  * C++中不要重载&&和||操作符\n\n\n\n\n\n\n\n\n\n\n\n",[[1543625822766,["gjx16@GJXAIOU",[[1,44542,"222222222222222222222222222222222222222222222"]],[44542,44542],[44587,44587]]],[1543626609185,["gjx16@GJXAIOU",[[-1,50462,"=è\n"]],[50462,50465],[50462,50462]]],[1543626969551,["gjx16@GJXAIOU",[[-1,49913,"\n"],[-1,49968,"\n"],[-1,49971,"\n "],[1,49973,"\t"],[-1,49989,"\n "],[1,49991,"\t"],[-1,50003,"\n {\n\n "],[1,50009,"\t{\n\t\t"],[-1,50022,"\n }\n\n "],[1,50028,"\t}\n\n\t"],[-1,50061,"\n {\n\n "],[1,50067,"\t{\n\t\t"],[-1,50081," "],[1,50082,"\t\t"],[1,50086," "],[1,50088," "],[1,50098," "],[1,50100," "],[-1,50107," "],[1,50108,"\t\t"],[-1,50128," "],[1,50129,"\t\t"],[-1,50141,"\n }\n\n "],[1,50147,"\t}\n\n\t"],[-1,50181,"\n {\n\n "],[1,50187,"\t{\n\t\t"],[1,50191," "],[1,50193," "],[1,50203," "],[1,50205," "],[-1,50212," "],[1,50213,"\t\t"],[-1,50232,"\n "],[1,50234,"\t"],[-1,50253,"void"],[1,50257,"int "],[-1,50265,"\n"],[-1,50268,"\n "],[1,50270,"\t"],[-1,50282,"\n "],[1,50284,"\t"],[-1,50296,"\n "],[1,50298,"\t"],[1,50302," "],[1,50304," "],[1,50324," "],[1,50326," "],[-1,50333," "],[1,50334,"\t"],[-1,50336,"("],[1,50338,"("],[-1,50353," "],[-1,50356,"\n {\n\n "],[1,50362,"\t{\n\t\t"],[1,50366," "],[1,50368," "],[1,50390," "],[1,50392," "],[-1,50398,"\n }\n\n "],[1,50404,"\t}\n\n\t"],[-1,50417,"\n "],[1,50419,"\t"],[-1,50433," If ( "],[1,50439,"\tif("],[-1,50454," "],[-1,50457,"\n {\n\n\n T"],[1,50465,"\t{\n\t\tt"],[-1,50478," "],[-1,50487," )\n\nT"],[1,50492,";\n\t\tt"],[-1,50505," "],[-1,50522," "],[1,50524,";"],[-1,50526," "],[1,50527,"\t\t\t"],[-1,50553," "],[1,50554,"\t\t\t"],[-1,50589," "],[1,50590,"\t\t\t"],[1,50594," "],[1,50596," "],[1,50616," "],[1,50618," "],[-1,50624,"\n }\n\n "],[1,50630,"\t}\n\n\t"],[-1,50647,"\n "],[1,50649,"\t"],[1,50656,"0"],[-1,50657,"\n"]],[49894,50660],[50663,50663]]],[1543626972653,["gjx16@GJXAIOU",[[-1,49933,"\n"]],[49933,49933],[49932,49932]]],[1543626994702,["gjx16@GJXAIOU",[[1,50670,"\n"]],[50667,50667],[50668,50668]]],[1543626997343,["gjx16@GJXAIOU",[[1,50668,"程序"]],[50668,50668],[50670,50670]]],[1543626999293,["gjx16@GJXAIOU",[[1,50672,"而就哟"]],[50672,50672],[50675,50675]]],[1543627002238,["gjx16@GJXAIOU",[[-1,50672,"而就哟"]],[50675,50675],[50672,50672]]],[1543627003966,["gjx16@GJXAIOU",[[1,50672,"结果："]],[50672,50672],[50675,50675]]],[1543627004535,["gjx16@GJXAIOU",[[1,50678,"\n"]],[50675,50675],[50676,50676]]],[1543627005755,["gjx16@GJXAIOU",[[1,50679,"\n"]],[50676,50676],[50677,50677]]],[1543627007329,["gjx16@GJXAIOU",[[-1,50679,"\n"]],[50677,50677],[50676,50676]]],[1543627009429,["gjx16@GJXAIOU",[[1,50676,"··"]],[50676,50676],[50678,50678]]],[1543627011643,["gjx16@GJXAIOU",[[-1,50676,"··"]],[50678,50678],[50676,50676]]],[1543627012789,["gjx16@GJXAIOU",[[1,50676,"``"]],[50676,50676],[50678,50678]]],[1543627015032,["gjx16@GJXAIOU",[[1,50677,"注意：&&操作符的结合顺序是从左向右\n执行+号重载函数\n执行&&重载函数"]],[50677,50677],[50713,50713]]],[1543627018063,["gjx16@GJXAIOU",[[1,50704,"`"]],[50704,50704],[50705,50705]]],[1543627022490,["gjx16@GJXAIOU",[[1,50695,"`"]],[50695,50695],[50696,50696]]],[1543627024064,["gjx16@GJXAIOU",[[1,50697,"`"]],[50697,50697],[50698,50698]]],[1543627029552,["gjx16@GJXAIOU",[[1,50708,"`"]],[50708,50708],[50709,50709]]],[1543630143904,[null,[[-1,50670,"\n\n"],[1,50672,"运行"],[1,50718,"\n\n\n"],[-1,50720,"\n"]],[50670,50670],[50720,50720]]],[1543630143904,[null,[[1,50670,"\n\n"],[-1,50670,"运行"],[-1,50718,"\n\n\n"],[1,50723,"\n"]],[50720,50720],[50670,50670]]],[1543630108469,["gjx16@GJXAIOU",[[-1,51043," "]],[51044,51044],[51043,51043]]],[1543630264894,[null,[[-1,50670,"\n\n"],[1,50672,"运行"],[1,50718,"\n\n\n"],[-1,50720,"\n"],[-1,51041," "],[1,51043,"有"]],[50670,50670],[51044,51044]]],[1543630264894,[null,[[1,50670,"\n\n"],[-1,50670,"运行"],[-1,50718,"\n\n\n"],[1,50723,"\n"],[1,51043," "],[-1,51044,"有"]],[51044,51044],[50670,50670]]],[1543630232842,["gjx16@GJXAIOU",[[-1,51347,"\n"]],[51347,51347],[51346,51346]]],[1543630235051,["gjx16@GJXAIOU",[[-1,51390,"\n"]],[51390,51390],[51389,51389]]],[1543630239012,["gjx16@GJXAIOU",[[-1,51435,"\n"]],[51435,51435],[51434,51434]]],[1543630240766,["gjx16@GJXAIOU",[[-1,51474,"\n"]],[51474,51474],[51473,51473]]],[1543630242280,["gjx16@GJXAIOU",[[-1,51513,"\n"]],[51513,51513],[51512,51512]]],[1543630243734,["gjx16@GJXAIOU",[[-1,51556,"\n"]],[51556,51556],[51555,51555]]],[1543651092867,[null,[[-1,50670,"\n\n"],[1,50672,"运行"],[1,50718,"\n\n\n"],[-1,50720,"\n"],[-1,51041," "],[1,51043,"有"],[-1,51345,"\n"],[1,51347,"M"],[-1,51387,"\n"],[1,51390,"c"],[-1,51433,"\n"],[1,51435,"b"],[-1,51472,"\n"],[1,51474,"b"],[-1,51510,"\n"],[1,51513,"b"],[-1,51554,"\n"],[1,51556,"b"]],[50670,50670],[51557,51557]]],[1543651092867,[null,[[1,50670,"\n\n"],[-1,50670,"运行"],[-1,50718,"\n\n\n"],[1,50723,"\n"],[1,51043," "],[-1,51044,"有"],[1,51347,"\n"],[-1,51348,"M"],[1,51389,"\n"],[-1,51391,"c"],[1,51435,"\n"],[-1,51436,"b"],[1,51474,"\n"],[-1,51475,"b"],[1,51512,"\n"],[-1,51514,"b"],[1,51556,"\n"],[-1,51557,"b"]],[51557,51557],[50670,50670]]],[1543651045988,["gjx16@GJXAIOU",[[-1,51622,"\n"]],[51622,51622],[51621,51621]]],[1543651048869,["gjx16@GJXAIOU",[[-1,51638,"\n"]],[51638,51638],[51637,51637]]],[1543651051557,["gjx16@GJXAIOU",[[-1,51666,"\n"]],[51666,51666],[51665,51665]]],[1543651053996,["gjx16@GJXAIOU",[[-1,51680,"\n"]],[51680,51680],[51679,51679]]],[1543651056607,["gjx16@GJXAIOU",[[-1,51683,"\n"]],[51683,51683],[51682,51682]]],[1543651060497,["gjx16@GJXAIOU",[[-1,51698,"\n"]],[51698,51698],[51697,51697]]],[1543651068475,["gjx16@GJXAIOU",[[1,51684,"  "]],[51684,51684],[51686,51686]]],[1543651332908,[null,[[-1,50670,"\n\n"],[1,50672,"运行"],[1,50718,"\n\n\n"],[-1,50720,"\n"],[-1,51041," "],[1,51043,"有"],[-1,51345,"\n"],[1,51347,"M"],[-1,51388,"\n"],[1,51390,"c"],[-1,51433,"\n"],[1,51435,"b"],[-1,51471,"\n"],[1,51474,"b"],[-1,51511,"\n"],[1,51513,"b"],[-1,51554,"\n"],[1,51556,"b"],[-1,51619,"\n"],[1,51622,"c"],[-1,51636,"\n"],[1,51638,"c"],[-1,51663,"\n"],[1,51666,"i"],[-1,51678,"\n \n"],[1,51681," {"],[-1,51683,"e"],[1,51686,"re"],[-1,51698,"\n"],[1,51700,"}"]],[50670,50670],[51701,51701]]],[1543651332908,[null,[[1,50670,"\n\n"],[-1,50670,"运行"],[-1,50718,"\n\n\n"],[1,50723,"\n"],[1,51043," "],[-1,51044,"有"],[1,51347,"\n"],[-1,51348,"M"],[1,51390,"\n"],[-1,51391,"c"],[1,51435,"\n"],[-1,51436,"b"],[1,51473,"\n"],[-1,51475,"b"],[1,51513,"\n"],[-1,51514,"b"],[1,51556,"\n"],[-1,51557,"b"],[1,51621,"\n"],[-1,51623,"c"],[1,51638,"\n"],[-1,51639,"c"],[1,51665,"\n"],[-1,51667,"i"],[1,51680,"\n \n"],[-1,51680," {"],[1,51684,"e"],[-1,51686,"re"],[1,51700,"\n"],[-1,51701,"}"]],[51701,51701],[50670,50670]]],[1543651301651,["gjx16@GJXAIOU",[[-1,51776,"\n"]],[51776,51776],[51775,51775]]],[1543651303879,["gjx16@GJXAIOU",[[-1,51744,"\n"]],[51744,51744],[51743,51743]]],[1543651307732,["gjx16@GJXAIOU",[[-1,51810,"\n"]],[51810,51810],[51809,51809]]],[1543651321504,["gjx16@GJXAIOU",[[-1,51845,"\n"]],[51845,51845],[51844,51844]]],[1543651324661,["gjx16@GJXAIOU",[[-1,51712,"\n"]],[51712,51712],[51711,51711]]],[1543651329788,["gjx16@GJXAIOU",[[-1,51853,"\n"]],[51853,51853],[51852,51852]]],[1543651332231,["gjx16@GJXAIOU",[[-1,51865,"\n"]],[51865,51865],[51864,51864]]],[1543651392907,[null,[[-1,50670,"\n\n"],[1,50672,"运行"],[1,50718,"\n\n\n"],[-1,50720,"\n"],[-1,51041," "],[1,51043,"有"],[-1,51345,"\n"],[1,51347,"M"],[-1,51387,"\n"],[1,51390,"c"],[-1,51432,"\n"],[1,51435,"b"],[-1,51472,"\n"],[1,51474,"b"],[-1,51511,"\n"],[1,51513,"b"],[-1,51554,"\n"],[1,51556,"b"],[-1,51620,"\n"],[1,51622,"c"],[-1,51636,"\n"],[1,51638,"c"],[-1,51664,"\n"],[1,51666,"i"],[-1,51678,"\n \n"],[1,51681," {"],[-1,51683,"e"],[1,51686,"re"],[-1,51697,"\n"],[1,51700,"}"],[-1,51710,"\n"],[1,51712,"i"],[-1,51741,"\n"],[1,51743,"i"],[-1,51772,"\n"],[1,51774,"i"],[-1,51806,"\n"],[1,51809,"i"],[-1,51841,"\n"],[1,51844,"r"],[-1,51851,"\n"],[1,51853,"i"],[-1,51863,"\n"],[1,51865,"c"]],[50670,50670],[51866,51866]]],[1543651392907,[null,[[1,50670,"\n\n"],[-1,50670,"运行"],[-1,50718,"\n\n\n"],[1,50723,"\n"],[1,51043," "],[-1,51044,"有"],[1,51347,"\n"],[-1,51348,"M"],[1,51389,"\n"],[-1,51391,"c"],[1,51434,"\n"],[-1,51436,"b"],[1,51474,"\n"],[-1,51475,"b"],[1,51513,"\n"],[-1,51514,"b"],[1,51556,"\n"],[-1,51557,"b"],[1,51622,"\n"],[-1,51623,"c"],[1,51638,"\n"],[-1,51639,"c"],[1,51666,"\n"],[-1,51667,"i"],[1,51680,"\n \n"],[-1,51680," {"],[1,51684,"e"],[-1,51686,"re"],[1,51699,"\n"],[-1,51701,"}"],[1,51712,"\n"],[-1,51713,"i"],[1,51743,"\n"],[-1,51744,"i"],[1,51774,"\n"],[-1,51775,"i"],[1,51808,"\n"],[-1,51810,"i"],[1,51843,"\n"],[-1,51845,"r"],[1,51853,"\n"],[-1,51854,"i"],[1,51865,"\n"],[-1,51866,"c"]],[51866,51866],[50670,50670]]],[1543651334649,["gjx16@GJXAIOU",[[-1,51878,"\n"]],[51878,51878],[51877,51877]]],[1543651388620,["gjx16@GJXAIOU",[[-1,51309,"\n"]],[51309,51309],[51308,51308]]],[1543651452909,[null,[[-1,50670,"\n\n"],[1,50672,"运行"],[1,50718,"\n\n\n"],[-1,50720,"\n"],[-1,51041," "],[1,51043,"有"],[-1,51307,"\n"],[1,51309,"M"],[-1,51344,"\n"],[1,51346,"M"],[-1,51387,"\n"],[1,51389,"c"],[-1,51432,"\n"],[1,51434,"b"],[-1,51470,"\n"],[1,51473,"b"],[-1,51509,"\n"],[1,51512,"b"],[-1,51553,"\n"],[1,51555,"b"],[-1,51619,"\n"],[1,51621,"c"],[-1,51634,"\n"],[1,51637,"c"],[-1,51663,"\n"],[1,51665,"i"],[-1,51677,"\n \n"],[1,51680," {"],[-1,51682,"e"],[1,51685,"re"],[-1,51697,"\n"],[1,51699,"}"],[-1,51709,"\n"],[1,51711,"i"],[-1,51739,"\n"],[1,51742,"i"],[-1,51770,"\n"],[1,51773,"i"],[-1,51806,"\n"],[1,51808,"i"],[-1,51841,"\n"],[1,51843,"r"],[-1,51849,"\n"],[1,51852,"i"],[-1,51862,"\n"],[1,51864,"c"],[-1,51875,"\n"],[1,51877,";"]],[50670,50670],[51878,51878]]],[1543651452909,[null,[[1,50670,"\n\n"],[-1,50670,"运行"],[-1,50718,"\n\n\n"],[1,50723,"\n"],[1,51043," "],[-1,51044,"有"],[1,51309,"\n"],[-1,51310,"M"],[1,51346,"\n"],[-1,51347,"M"],[1,51389,"\n"],[-1,51390,"c"],[1,51434,"\n"],[-1,51435,"b"],[1,51472,"\n"],[-1,51474,"b"],[1,51511,"\n"],[-1,51513,"b"],[1,51555,"\n"],[-1,51556,"b"],[1,51621,"\n"],[-1,51622,"c"],[1,51636,"\n"],[-1,51638,"c"],[1,51665,"\n"],[-1,51666,"i"],[1,51679,"\n \n"],[-1,51679," {"],[1,51683,"e"],[-1,51685,"re"],[1,51699,"\n"],[-1,51700,"}"],[1,51711,"\n"],[-1,51712,"i"],[1,51741,"\n"],[-1,51743,"i"],[1,51772,"\n"],[-1,51774,"i"],[1,51808,"\n"],[-1,51809,"i"],[1,51843,"\n"],[-1,51844,"r"],[1,51851,"\n"],[-1,51853,"i"],[1,51864,"\n"],[-1,51865,"c"],[1,51877,"\n"],[-1,51878,";"]],[51878,51878],[50670,50670]]],[1543651394565,["gjx16@GJXAIOU",[[-1,51109,"\n"]],[51109,51109],[51108,51108]]],[1543651398255,["gjx16@GJXAIOU",[[-1,51191,"\n"]],[51191,51191],[51190,51190]]],[1543651400299,["gjx16@GJXAIOU",[[-1,51215,"\n"]],[51215,51215],[51214,51214]]],[1543651402756,["gjx16@GJXAIOU",[[-1,51241,"\n"]],[51241,51241],[51240,51240]]],[1543651406085,["gjx16@GJXAIOU",[[-1,51273,"\n"]],[51273,51273],[51272,51272]]],[1543651512937,[null,[[-1,50670,"\n\n"],[1,50672,"运行"],[1,50718,"\n\n\n"],[-1,50720,"\n"],[-1,51041," "],[1,51043,"有"],[-1,51107,"\n"],[1,51110,"\n"],[-1,51189,"\n"],[1,51191,"M"],[-1,51213,"\n"],[1,51215,"M"],[-1,51239,"\n"],[1,51241,"M"],[-1,51270,"\n"],[1,51273,"~"],[-1,51302,"\n"],[1,51304,"M"],[-1,51339,"\n"],[1,51341,"M"],[-1,51381,"\n"],[1,51384,"c"],[-1,51427,"\n"],[1,51429,"b"],[-1,51465,"\n"],[1,51468,"b"],[-1,51505,"\n"],[1,51507,"b"],[-1,51548,"\n"],[1,51550,"b"],[-1,51614,"\n"],[1,51616,"c"],[-1,51630,"\n"],[1,51632,"c"],[-1,51658,"\n"],[1,51660,"i"],[-1,51672,"\n \n"],[1,51675," {"],[-1,51677,"e"],[1,51680,"re"],[-1,51692,"\n"],[1,51694,"}"],[-1,51704,"\n"],[1,51706,"i"],[-1,51734,"\n"],[1,51737,"i"],[-1,51766,"\n"],[1,51768,"i"],[-1,51800,"\n"],[1,51803,"i"],[-1,51836,"\n"],[1,51838,"r"],[-1,51845,"\n"],[1,51847,"i"],[-1,51856,"\n"],[1,51859,"c"],[-1,51870,"\n"],[1,51872,";"]],[50670,50670],[51873,51873]]],[1543651512937,[null,[[1,50670,"\n\n"],[-1,50670,"运行"],[-1,50718,"\n\n\n"],[1,50723,"\n"],[1,51043," "],[-1,51044,"有"],[1,51109,"\n"],[-1,51111,"\n"],[1,51191,"\n"],[-1,51192,"M"],[1,51215,"\n"],[-1,51216,"M"],[1,51241,"\n"],[-1,51242,"M"],[1,51272,"\n"],[-1,51274,"~"],[1,51304,"\n"],[-1,51305,"M"],[1,51341,"\n"],[-1,51342,"M"],[1,51383,"\n"],[-1,51385,"c"],[1,51429,"\n"],[-1,51430,"b"],[1,51467,"\n"],[-1,51469,"b"],[1,51507,"\n"],[-1,51508,"b"],[1,51550,"\n"],[-1,51551,"b"],[1,51616,"\n"],[-1,51617,"c"],[1,51632,"\n"],[-1,51633,"c"],[1,51660,"\n"],[-1,51661,"i"],[1,51674,"\n \n"],[-1,51674," {"],[1,51678,"e"],[-1,51680,"re"],[1,51694,"\n"],[-1,51695,"}"],[1,51706,"\n"],[-1,51707,"i"],[1,51736,"\n"],[-1,51738,"i"],[1,51768,"\n"],[-1,51769,"i"],[1,51802,"\n"],[-1,51804,"i"],[1,51838,"\n"],[-1,51839,"r"],[1,51847,"\n"],[-1,51848,"i"],[1,51858,"\n"],[-1,51860,"c"],[1,51872,"\n"],[-1,51873,";"]],[51873,51873],[50670,50670]]],[1543651470044,["gjx16@GJXAIOU",[[-1,51111,"\n"]],[51111,51111],[51110,51110]]],[1543651510348,["gjx16@GJXAIOU",[[-1,51864," "]],[51865,51865],[51864,51864]]],[1543651573824,[null,[[-1,50670,"\n\n"],[1,50672,"运行"],[1,50718,"\n\n\n"],[-1,50720,"\n"],[-1,51041," "],[1,51043,"有"],[-1,51107,"\n"],[1,51111,"f"],[-1,51188,"\n"],[1,51190,"M"],[-1,51211,"\n"],[1,51214,"M"],[-1,51238,"\n"],[1,51240,"M"],[-1,51270,"\n"],[1,51272,"~"],[-1,51301,"\n"],[1,51303,"M"],[-1,51338,"\n"],[1,51340,"M"],[-1,51380,"\n"],[1,51383,"c"],[-1,51426,"\n"],[1,51428,"b"],[-1,51464,"\n"],[1,51467,"b"],[-1,51504,"\n"],[1,51506,"b"],[-1,51547,"\n"],[1,51549,"b"],[-1,51613,"\n"],[1,51615,"c"],[-1,51629,"\n"],[1,51631,"c"],[-1,51656,"\n"],[1,51659,"i"],[-1,51671,"\n \n"],[1,51674," {"],[-1,51676,"e"],[1,51679,"re"],[-1,51691,"\n"],[1,51693,"}"],[-1,51703,"\n"],[1,51705,"i"],[-1,51734,"\n"],[1,51736,"i"],[-1,51764,"\n"],[1,51767,"i"],[-1,51799,"\n"],[1,51802,"i"],[-1,51834,"\n"],[1,51837,"r"],[-1,51844,"\n"],[1,51846,"i"],[-1,51856,"\n"],[1,51858,"c"],[-1,51861," "],[1,51864,"m"],[-1,51868,"\n"],[1,51870,";"]],[50670,50670],[51871,51871]]],[1543651573824,[null,[[1,50670,"\n\n"],[-1,50670,"运行"],[-1,50718,"\n\n\n"],[1,50723,"\n"],[1,51043," "],[-1,51044,"有"],[1,51109,"\n"],[-1,51112,"f"],[1,51190,"\n"],[-1,51191,"M"],[1,51213,"\n"],[-1,51215,"M"],[1,51240,"\n"],[-1,51241,"M"],[1,51272,"\n"],[-1,51273,"~"],[1,51303,"\n"],[-1,51304,"M"],[1,51340,"\n"],[-1,51341,"M"],[1,51382,"\n"],[-1,51384,"c"],[1,51428,"\n"],[-1,51429,"b"],[1,51466,"\n"],[-1,51468,"b"],[1,51506,"\n"],[-1,51507,"b"],[1,51549,"\n"],[-1,51550,"b"],[1,51615,"\n"],[-1,51616,"c"],[1,51631,"\n"],[-1,51632,"c"],[1,51658,"\n"],[-1,51660,"i"],[1,51673,"\n \n"],[-1,51673," {"],[1,51677,"e"],[-1,51679,"re"],[1,51693,"\n"],[-1,51694,"}"],[1,51705,"\n"],[-1,51706,"i"],[1,51736,"\n"],[-1,51737,"i"],[1,51766,"\n"],[-1,51768,"i"],[1,51801,"\n"],[-1,51803,"i"],[1,51836,"\n"],[-1,51838,"r"],[1,51846,"\n"],[-1,51847,"i"],[1,51858,"\n"],[-1,51859,"c"],[1,51863," "],[-1,51865,"m"],[1,51870,"\n"],[-1,51871,";"]],[51871,51871],[50670,50670]]],[1543651517860,["gjx16@GJXAIOU",[[-1,50973,"\n"]],[50973,50973],[50972,50972]]],[1543651520377,["gjx16@GJXAIOU",[[-1,50985,"\n"]],[50985,50985],[50984,50984]]],[1543651523638,["gjx16@GJXAIOU",[[-1,50953,"\n"]],[50953,50953],[50952,50952]]],[1543651525748,["gjx16@GJXAIOU",[[-1,50938,"\n"]],[50938,50938],[50937,50937]]],[1543651527374,["gjx16@GJXAIOU",[[-1,50921,"\n"]],[50921,50921],[50920,50920]]],[1543651529393,["gjx16@GJXAIOU",[[-1,50900,"\n"]],[50900,50900],[50899,50899]]],[1543651538871,["gjx16@GJXAIOU",[[-1,50762,"\n"]],[50762,50762],[50761,50761]]],[1543651541194,["gjx16@GJXAIOU",[[-1,50770,"\n"]],[50770,50770],[50769,50769]]],[1543652853844,[null,[[-1,50670,"\n\n"],[1,50672,"运行"],[1,50718,"\n\n\n"],[-1,50720,"\n"],[-1,50760,"\n"],[1,50762,"加"],[-1,50768,"\n"],[1,50769,"#"],[-1,50896,"\n"],[1,50898,"y"],[-1,50915,"\n"],[1,50918,"y"],[-1,50932,"\n"],[1,50934," "],[-1,50946,"\n"],[1,50948," "],[-1,50965,"\n"],[1,50967,"f"],[-1,50977,"\n"],[1,50979,"["],[-1,51033," "],[1,51035,"有"],[-1,51099,"\n"],[1,51103,"f"],[-1,51180,"\n"],[1,51182,"M"],[-1,51203,"\n"],[1,51206,"M"],[-1,51230,"\n"],[1,51232,"M"],[-1,51262,"\n"],[1,51264,"~"],[-1,51293,"\n"],[1,51295,"M"],[-1,51330,"\n"],[1,51332,"M"],[-1,51372,"\n"],[1,51375,"c"],[-1,51418,"\n"],[1,51420,"b"],[-1,51456,"\n"],[1,51459,"b"],[-1,51496,"\n"],[1,51498,"b"],[-1,51539,"\n"],[1,51541,"b"],[-1,51605,"\n"],[1,51607,"c"],[-1,51621,"\n"],[1,51623,"c"],[-1,51648,"\n"],[1,51651,"i"],[-1,51663,"\n \n"],[1,51666," {"],[-1,51668,"e"],[1,51671,"re"],[-1,51683,"\n"],[1,51685,"}"],[-1,51695,"\n"],[1,51697,"i"],[-1,51726,"\n"],[1,51728,"i"],[-1,51756,"\n"],[1,51759,"i"],[-1,51791,"\n"],[1,51794,"i"],[-1,51826,"\n"],[1,51829,"r"],[-1,51836,"\n"],[1,51838,"i"],[-1,51848,"\n"],[1,51850,"c"],[-1,51853," "],[1,51856,"m"],[-1,51860,"\n"],[1,51862,";"]],[50670,50670],[51863,51863]]],[1543652853844,[null,[[1,50670,"\n\n"],[-1,50670,"运行"],[-1,50718,"\n\n\n"],[1,50723,"\n"],[1,50762,"\n"],[-1,50763,"加"],[1,50770,"\n"],[-1,50770,"#"],[1,50898,"\n"],[-1,50899,"y"],[1,50917,"\n"],[-1,50919,"y"],[1,50934,"\n"],[-1,50935," "],[1,50948,"\n"],[-1,50949," "],[1,50967,"\n"],[-1,50968,"f"],[1,50979,"\n"],[-1,50980,"["],[1,51035," "],[-1,51036,"有"],[1,51101,"\n"],[-1,51104,"f"],[1,51182,"\n"],[-1,51183,"M"],[1,51205,"\n"],[-1,51207,"M"],[1,51232,"\n"],[-1,51233,"M"],[1,51264,"\n"],[-1,51265,"~"],[1,51295,"\n"],[-1,51296,"M"],[1,51332,"\n"],[-1,51333,"M"],[1,51374,"\n"],[-1,51376,"c"],[1,51420,"\n"],[-1,51421,"b"],[1,51458,"\n"],[-1,51460,"b"],[1,51498,"\n"],[-1,51499,"b"],[1,51541,"\n"],[-1,51542,"b"],[1,51607,"\n"],[-1,51608,"c"],[1,51623,"\n"],[-1,51624,"c"],[1,51650,"\n"],[-1,51652,"i"],[1,51665,"\n \n"],[-1,51665," {"],[1,51669,"e"],[-1,51671,"re"],[1,51685,"\n"],[-1,51686,"}"],[1,51697,"\n"],[-1,51698,"i"],[1,51728,"\n"],[-1,51729,"i"],[1,51758,"\n"],[-1,51760,"i"],[1,51793,"\n"],[-1,51795,"i"],[1,51828,"\n"],[-1,51830,"r"],[1,51838,"\n"],[-1,51839,"i"],[1,51850,"\n"],[-1,51851,"c"],[1,51855," "],[-1,51857,"m"],[1,51862,"\n"],[-1,51863,";"]],[51863,51863],[50670,50670]]],[1543652834283,["gjx16@GJXAIOU",[[-1,51928," "]],[51929,51929],[51928,51928]]],[1543652838610,["gjx16@GJXAIOU",[[-1,51989," "]],[51990,51990],[51989,51989]]],[1543652845869,["gjx16@GJXAIOU",[[-1,52123,"\n"]],[52123,52123],[52122,52122]]],[1543652848309,["gjx16@GJXAIOU",[[-1,52125,"\n"]],[52125,52125],[52124,52124]]],[1543652850834,["gjx16@GJXAIOU",[[-1,52133,"\n"]],[52133,52133],[52132,52132]]],[1543652852973,["gjx16@GJXAIOU",[[-1,52141,"\n"]],[52141,52141],[52140,52140]]],[1543652913956,[null,[[-1,50670,"\n\n"],[1,50672,"运行"],[1,50718,"\n\n\n"],[-1,50720,"\n"],[-1,50760,"\n"],[1,50762,"加"],[-1,50768,"\n"],[1,50769,"#"],[-1,50896,"\n"],[1,50898,"y"],[-1,50915,"\n"],[1,50918,"y"],[-1,50932,"\n"],[1,50934," "],[-1,50946,"\n"],[1,50948," "],[-1,50965,"\n"],[1,50967,"f"],[-1,50977,"\n"],[1,50979,"["],[-1,51033," "],[1,51035,"有"],[-1,51099,"\n"],[1,51103,"f"],[-1,51180,"\n"],[1,51182,"M"],[-1,51203,"\n"],[1,51206,"M"],[-1,51230,"\n"],[1,51232,"M"],[-1,51262,"\n"],[1,51264,"~"],[-1,51293,"\n"],[1,51295,"M"],[-1,51330,"\n"],[1,51332,"M"],[-1,51372,"\n"],[1,51375,"c"],[-1,51418,"\n"],[1,51420,"b"],[-1,51456,"\n"],[1,51459,"b"],[-1,51496,"\n"],[1,51498,"b"],[-1,51539,"\n"],[1,51541,"b"],[-1,51605,"\n"],[1,51607,"c"],[-1,51621,"\n"],[1,51623,"c"],[-1,51648,"\n"],[1,51651,"i"],[-1,51663,"\n \n"],[1,51666," {"],[-1,51668,"e"],[1,51671,"re"],[-1,51683,"\n"],[1,51685,"}"],[-1,51695,"\n"],[1,51697,"i"],[-1,51726,"\n"],[1,51728,"i"],[-1,51756,"\n"],[1,51759,"i"],[-1,51791,"\n"],[1,51794,"i"],[-1,51826,"\n"],[1,51829,"r"],[-1,51836,"\n"],[1,51838,"i"],[-1,51848,"\n"],[1,51850,"c"],[-1,51853," "],[1,51856,"m"],[-1,51860,"\n"],[1,51862,";"],[-1,51926," "],[1,51928,"决"],[-1,51987," "],[1,51989,"能"],[-1,52121,"\n"],[1,52125,"u"],[-1,52131,"\n"],[1,52133,"T"],[-1,52139,"\n"],[1,52141,"{"]],[50670,50670],[52142,52142]]],[1543652913956,[null,[[1,50670,"\n\n"],[-1,50670,"运行"],[-1,50718,"\n\n\n"],[1,50723,"\n"],[1,50762,"\n"],[-1,50763,"加"],[1,50770,"\n"],[-1,50770,"#"],[1,50898,"\n"],[-1,50899,"y"],[1,50917,"\n"],[-1,50919,"y"],[1,50934,"\n"],[-1,50935," "],[1,50948,"\n"],[-1,50949," "],[1,50967,"\n"],[-1,50968,"f"],[1,50979,"\n"],[-1,50980,"["],[1,51035," "],[-1,51036,"有"],[1,51101,"\n"],[-1,51104,"f"],[1,51182,"\n"],[-1,51183,"M"],[1,51205,"\n"],[-1,51207,"M"],[1,51232,"\n"],[-1,51233,"M"],[1,51264,"\n"],[-1,51265,"~"],[1,51295,"\n"],[-1,51296,"M"],[1,51332,"\n"],[-1,51333,"M"],[1,51374,"\n"],[-1,51376,"c"],[1,51420,"\n"],[-1,51421,"b"],[1,51458,"\n"],[-1,51460,"b"],[1,51498,"\n"],[-1,51499,"b"],[1,51541,"\n"],[-1,51542,"b"],[1,51607,"\n"],[-1,51608,"c"],[1,51623,"\n"],[-1,51624,"c"],[1,51650,"\n"],[-1,51652,"i"],[1,51665,"\n \n"],[-1,51665," {"],[1,51669,"e"],[-1,51671,"re"],[1,51685,"\n"],[-1,51686,"}"],[1,51697,"\n"],[-1,51698,"i"],[1,51728,"\n"],[-1,51729,"i"],[1,51758,"\n"],[-1,51760,"i"],[1,51793,"\n"],[-1,51795,"i"],[1,51828,"\n"],[-1,51830,"r"],[1,51838,"\n"],[-1,51839,"i"],[1,51850,"\n"],[-1,51851,"c"],[1,51855," "],[-1,51857,"m"],[1,51862,"\n"],[-1,51863,";"],[1,51928," "],[-1,51929,"决"],[1,51989," "],[-1,51990,"能"],[1,52123,"\n"],[-1,52126,"u"],[1,52133,"\n"],[-1,52134,"T"],[1,52141,"\n"],[-1,52142,"{"]],[52142,52142],[50670,50670]]],[1543652855157,["gjx16@GJXAIOU",[[-1,52144,"\n"]],[52144,52144],[52143,52143]]],[1543652857186,["gjx16@GJXAIOU",[[-1,52159,"\n"]],[52159,52159],[52158,52158]]],[1543652863301,["gjx16@GJXAIOU",[[1,52145,"  "]],[52145,52145],[52147,52147]]],[1543652866693,["gjx16@GJXAIOU",[[-1,52180,"\n"]],[52180,52180],[52179,52179]]],[1543652868986,["gjx16@GJXAIOU",[[-1,52183,"\n"]],[52183,52183],[52182,52182]]],[1543652872978,["gjx16@GJXAIOU",[[1,52184,"  "]],[52184,52184],[52186,52186]]],[1543652875626,["gjx16@GJXAIOU",[[-1,52201,"\n"]],[52201,52201],[52200,52200]]],[1543652879404,["gjx16@GJXAIOU",[[-1,52214,"\n"]],[52214,52214],[52213,52213]]],[1543652882853,["gjx16@GJXAIOU",[[-1,52222,"\n"]],[52222,52222],[52221,52221]]],[1543652888067,["gjx16@GJXAIOU",[[-1,52246,"\n"]],[52246,52246],[52245,52245]]],[1543652890780,["gjx16@GJXAIOU",[[-1,52248,"\n"]],[52248,52248],[52247,52247]]],[1543652897789,["gjx16@GJXAIOU",[[-1,52265,"\n"]],[52265,52265],[52264,52264]]],[1543652901051,["gjx16@GJXAIOU",[[-1,52282,"\n"]],[52282,52282],[52281,52281]]],[1543652904115,["gjx16@GJXAIOU",[[-1,52285,"\n"]],[52285,52285],[52284,52284]]],[1543652907418,["gjx16@GJXAIOU",[[-1,52296,"\n"]],[52296,52296],[52295,52295]]],[1543652913290,["gjx16@GJXAIOU",[[1,52286,"  "]],[52286,52286],[52288,52288]]],[1543652973974,[null,[[-1,50670,"\n\n"],[1,50672,"运行"],[1,50718,"\n\n\n"],[-1,50720,"\n"],[-1,50760,"\n"],[1,50762,"加"],[-1,50768,"\n"],[1,50769,"#"],[-1,50896,"\n"],[1,50898,"y"],[-1,50915,"\n"],[1,50918,"y"],[-1,50932,"\n"],[1,50934," "],[-1,50946,"\n"],[1,50948," "],[-1,50965,"\n"],[1,50967,"f"],[-1,50977,"\n"],[1,50979,"["],[-1,51033," "],[1,51035,"有"],[-1,51099,"\n"],[1,51103,"f"],[-1,51180,"\n"],[1,51182,"M"],[-1,51203,"\n"],[1,51206,"M"],[-1,51230,"\n"],[1,51232,"M"],[-1,51262,"\n"],[1,51264,"~"],[-1,51293,"\n"],[1,51295,"M"],[-1,51330,"\n"],[1,51332,"M"],[-1,51372,"\n"],[1,51375,"c"],[-1,51418,"\n"],[1,51420,"b"],[-1,51456,"\n"],[1,51459,"b"],[-1,51496,"\n"],[1,51498,"b"],[-1,51539,"\n"],[1,51541,"b"],[-1,51605,"\n"],[1,51607,"c"],[-1,51621,"\n"],[1,51623,"c"],[-1,51648,"\n"],[1,51651,"i"],[-1,51663,"\n \n"],[1,51666," {"],[-1,51668,"e"],[1,51671,"re"],[-1,51683,"\n"],[1,51685,"}"],[-1,51695,"\n"],[1,51697,"i"],[-1,51726,"\n"],[1,51728,"i"],[-1,51756,"\n"],[1,51759,"i"],[-1,51791,"\n"],[1,51794,"i"],[-1,51826,"\n"],[1,51829,"r"],[-1,51836,"\n"],[1,51838,"i"],[-1,51848,"\n"],[1,51850,"c"],[-1,51853," "],[1,51856,"m"],[-1,51860,"\n"],[1,51862,";"],[-1,51926," "],[1,51928,"决"],[-1,51987," "],[1,51989,"能"],[-1,52121,"\n"],[1,52125,"u"],[-1,52131,"\n"],[1,52133,"T"],[-1,52139,"\n \n"],[1,52142," {"],[-1,52144,"h"],[1,52147,"th"],[-1,52159,"\n"],[1,52161,"}"],[-1,52177,"\n"],[-1,52180,"\n"],[1,52181,"{"],[-1,52183,"o"],[1,52186,"co"],[-1,52198,"\n"],[1,52201,"}"],[-1,52212,"\n"],[1,52214,"i"],[-1,52220,"\n"],[1,52222,";"],[-1,52244,"\n"],[-1,52247,"pblic:\n\n"],[1,52264,"public:\n"],[1,52265,"M"],[-1,52280,"\n \n"],[1,52283," {"],[1,52287,"p"],[-1,52296,"\n"],[1,52298,"}"]],[50670,50670],[52299,52299]]],[1543652973974,[null,[[1,50670,"\n\n"],[-1,50670,"运行"],[-1,50718,"\n\n\n"],[1,50723,"\n"],[1,50762,"\n"],[-1,50763,"加"],[1,50770,"\n"],[-1,50770,"#"],[1,50898,"\n"],[-1,50899,"y"],[1,50917,"\n"],[-1,50919,"y"],[1,50934,"\n"],[-1,50935," "],[1,50948,"\n"],[-1,50949," "],[1,50967,"\n"],[-1,50968,"f"],[1,50979,"\n"],[-1,50980,"["],[1,51035," "],[-1,51036,"有"],[1,51101,"\n"],[-1,51104,"f"],[1,51182,"\n"],[-1,51183,"M"],[1,51205,"\n"],[-1,51207,"M"],[1,51232,"\n"],[-1,51233,"M"],[1,51264,"\n"],[-1,51265,"~"],[1,51295,"\n"],[-1,51296,"M"],[1,51332,"\n"],[-1,51333,"M"],[1,51374,"\n"],[-1,51376,"c"],[1,51420,"\n"],[-1,51421,"b"],[1,51458,"\n"],[-1,51460,"b"],[1,51498,"\n"],[-1,51499,"b"],[1,51541,"\n"],[-1,51542,"b"],[1,51607,"\n"],[-1,51608,"c"],[1,51623,"\n"],[-1,51624,"c"],[1,51650,"\n"],[-1,51652,"i"],[1,51665,"\n \n"],[-1,51665," {"],[1,51669,"e"],[-1,51671,"re"],[1,51685,"\n"],[-1,51686,"}"],[1,51697,"\n"],[-1,51698,"i"],[1,51728,"\n"],[-1,51729,"i"],[1,51758,"\n"],[-1,51760,"i"],[1,51793,"\n"],[-1,51795,"i"],[1,51828,"\n"],[-1,51830,"r"],[1,51838,"\n"],[-1,51839,"i"],[1,51850,"\n"],[-1,51851,"c"],[1,51855," "],[-1,51857,"m"],[1,51862,"\n"],[-1,51863,";"],[1,51928," "],[-1,51929,"决"],[1,51989," "],[-1,51990,"能"],[1,52123,"\n"],[-1,52126,"u"],[1,52133,"\n"],[-1,52134,"T"],[1,52141,"\n \n"],[-1,52141," {"],[1,52145,"h"],[-1,52147,"th"],[1,52161,"\n"],[-1,52162,"}"],[1,52179,"\n"],[1,52181,"\n"],[-1,52181,"{"],[1,52184,"o"],[-1,52186,"co"],[1,52200,"\n"],[-1,52202,"}"],[1,52214,"\n"],[-1,52215,"i"],[1,52222,"\n"],[-1,52223,";"],[1,52246,"\n"],[1,52248,"pblic:\n\n"],[-1,52257,"public:\n"],[-1,52266,"M"],[1,52282,"\n \n"],[-1,52282," {"],[-1,52288,"p"],[1,52298,"\n"],[-1,52299,"}"]],[52299,52299],[50670,50670]]],[1543652918970,["gjx16@GJXAIOU",[[-1,52326,"\n"]],[52326,52326],[52325,52325]]],[1543652920099,["gjx16@GJXAIOU",[[-1,52324,")"]],[52325,52325],[52324,52324]]],[1543652924126,["gjx16@GJXAIOU",[[1,52324,")"]],[52324,52324],[52325,52325]]],[1543652928337,["gjx16@GJXAIOU",[[-1,52329,"\n"]],[52329,52329],[52328,52328]]],[1543652931074,["gjx16@GJXAIOU",[[1,52330,"  "]],[52330,52330],[52332,52332]]],[1543652934663,["gjx16@GJXAIOU",[[-1,52345,"\n"]],[52345,52345],[52344,52344]]],[1543652939229,["gjx16@GJXAIOU",[[-1,52367,"\n"]],[52367,52367],[52366,52366]]],[1543652941561,["gjx16@GJXAIOU",[[-1,52370,"\n"]],[52370,52370],[52369,52369]]],[1543652944515,["gjx16@GJXAIOU",[[1,52371,"  "]],[52371,52371],[52373,52373]]],[1543652949052,["gjx16@GJXAIOU",[[-1,52383,"\n"]],[52383,52383],[52382,52382]]],[1543652954453,["gjx16@GJXAIOU",[[-1,52407,"\n"]],[52407,52407],[52406,52406]]],[1543652960132,["gjx16@GJXAIOU",[[-1,52410,"\n"]],[52410,52410],[52409,52409]]],[1543652963756,["gjx16@GJXAIOU",[[1,52411,"  "]],[52411,52411],[52413,52413]]],[1543652967966,["gjx16@GJXAIOU",[[-1,52423,"\n"]],[52423,52423],[52422,52422]]],[1543653033991,[null,[[-1,50670,"\n\n"],[1,50672,"运行"],[1,50718,"\n\n\n"],[-1,50720,"\n"],[-1,50760,"\n"],[1,50762,"加"],[-1,50768,"\n"],[1,50769,"#"],[-1,50896,"\n"],[1,50898,"y"],[-1,50915,"\n"],[1,50918,"y"],[-1,50932,"\n"],[1,50934," "],[-1,50946,"\n"],[1,50948," "],[-1,50965,"\n"],[1,50967,"f"],[-1,50977,"\n"],[1,50979,"["],[-1,51033," "],[1,51035,"有"],[-1,51099,"\n"],[1,51103,"f"],[-1,51180,"\n"],[1,51182,"M"],[-1,51203,"\n"],[1,51206,"M"],[-1,51230,"\n"],[1,51232,"M"],[-1,51262,"\n"],[1,51264,"~"],[-1,51293,"\n"],[1,51295,"M"],[-1,51330,"\n"],[1,51332,"M"],[-1,51372,"\n"],[1,51375,"c"],[-1,51418,"\n"],[1,51420,"b"],[-1,51456,"\n"],[1,51459,"b"],[-1,51496,"\n"],[1,51498,"b"],[-1,51539,"\n"],[1,51541,"b"],[-1,51605,"\n"],[1,51607,"c"],[-1,51621,"\n"],[1,51623,"c"],[-1,51648,"\n"],[1,51651,"i"],[-1,51663,"\n \n"],[1,51666," {"],[-1,51668,"e"],[1,51671,"re"],[-1,51683,"\n"],[1,51685,"}"],[-1,51695,"\n"],[1,51697,"i"],[-1,51726,"\n"],[1,51728,"i"],[-1,51756,"\n"],[1,51759,"i"],[-1,51791,"\n"],[1,51794,"i"],[-1,51826,"\n"],[1,51829,"r"],[-1,51836,"\n"],[1,51838,"i"],[-1,51848,"\n"],[1,51850,"c"],[-1,51853," "],[1,51856,"m"],[-1,51860,"\n"],[1,51862,";"],[-1,51926," "],[1,51928,"决"],[-1,51987," "],[1,51989,"能"],[-1,52121,"\n"],[1,52125,"u"],[-1,52131,"\n"],[1,52133,"T"],[-1,52139,"\n \n"],[1,52142," {"],[-1,52144,"h"],[1,52147,"th"],[-1,52159,"\n"],[1,52161,"}"],[-1,52177,"\n"],[-1,52180,"\n"],[1,52181,"{"],[-1,52183,"o"],[1,52186,"co"],[-1,52198,"\n"],[1,52201,"}"],[-1,52212,"\n"],[1,52214,"i"],[-1,52220,"\n"],[1,52222,";"],[-1,52244,"\n"],[-1,52248,""],[1,52248,"u"],[-1,52263,"\n"],[1,52265,"M"],[-1,52280,"\n \n"],[1,52283," {"],[1,52287,"p"],[-1,52296,"\n"],[1,52298,"}"],[-1,52324,") \n"],[1,52327," {"],[-1,52329,"h"],[1,52332,"th"],[-1,52343,"\n"],[1,52345,"}"],[-1,52365,"\n \n"],[1,52368," {"],[-1,52370,"e"],[1,52373,"de"],[-1,52381,"\n"],[1,52383,"}"],[-1,52405,"\n \n"],[1,52408," {"],[-1,52410,"e"],[1,52413,"re"],[-1,52421,"\n"],[1,52423,"}"]],[50670,50670],[52424,52424]]],[1543653033991,[null,[[1,50670,"\n\n"],[-1,50670,"运行"],[-1,50718,"\n\n\n"],[1,50723,"\n"],[1,50762,"\n"],[-1,50763,"加"],[1,50770,"\n"],[-1,50770,"#"],[1,50898,"\n"],[-1,50899,"y"],[1,50917,"\n"],[-1,50919,"y"],[1,50934,"\n"],[-1,50935," "],[1,50948,"\n"],[-1,50949," "],[1,50967,"\n"],[-1,50968,"f"],[1,50979,"\n"],[-1,50980,"["],[1,51035," "],[-1,51036,"有"],[1,51101,"\n"],[-1,51104,"f"],[1,51182,"\n"],[-1,51183,"M"],[1,51205,"\n"],[-1,51207,"M"],[1,51232,"\n"],[-1,51233,"M"],[1,51264,"\n"],[-1,51265,"~"],[1,51295,"\n"],[-1,51296,"M"],[1,51332,"\n"],[-1,51333,"M"],[1,51374,"\n"],[-1,51376,"c"],[1,51420,"\n"],[-1,51421,"b"],[1,51458,"\n"],[-1,51460,"b"],[1,51498,"\n"],[-1,51499,"b"],[1,51541,"\n"],[-1,51542,"b"],[1,51607,"\n"],[-1,51608,"c"],[1,51623,"\n"],[-1,51624,"c"],[1,51650,"\n"],[-1,51652,"i"],[1,51665,"\n \n"],[-1,51665," {"],[1,51669,"e"],[-1,51671,"re"],[1,51685,"\n"],[-1,51686,"}"],[1,51697,"\n"],[-1,51698,"i"],[1,51728,"\n"],[-1,51729,"i"],[1,51758,"\n"],[-1,51760,"i"],[1,51793,"\n"],[-1,51795,"i"],[1,51828,"\n"],[-1,51830,"r"],[1,51838,"\n"],[-1,51839,"i"],[1,51850,"\n"],[-1,51851,"c"],[1,51855," "],[-1,51857,"m"],[1,51862,"\n"],[-1,51863,";"],[1,51928," "],[-1,51929,"决"],[1,51989," "],[-1,51990,"能"],[1,52123,"\n"],[-1,52126,"u"],[1,52133,"\n"],[-1,52134,"T"],[1,52141,"\n \n"],[-1,52141," {"],[1,52145,"h"],[-1,52147,"th"],[1,52161,"\n"],[-1,52162,"}"],[1,52179,"\n"],[1,52181,"\n"],[-1,52181,"{"],[1,52184,"o"],[-1,52186,"co"],[1,52200,"\n"],[-1,52202,"}"],[1,52214,"\n"],[-1,52215,"i"],[1,52222,"\n"],[-1,52223,";"],[1,52246,"\n"],[1,52249,""],[-1,52249,"u"],[1,52265,"\n"],[-1,52266,"M"],[1,52282,"\n \n"],[-1,52282," {"],[-1,52288,"p"],[1,52298,"\n"],[-1,52299,"}"],[1,52326,") \n"],[-1,52326," {"],[1,52330,"h"],[-1,52332,"th"],[1,52345,"\n"],[-1,52346,"}"],[1,52367,"\n \n"],[-1,52367," {"],[1,52371,"e"],[-1,52373,"de"],[1,52383,"\n"],[-1,52384,"}"],[1,52407,"\n \n"],[-1,52407," {"],[1,52411,"e"],[-1,52413,"re"],[1,52423,"\n"],[-1,52424,"}"]],[52424,52424],[50670,50670]]],[1543652980386,["gjx16@GJXAIOU",[[-1,52446,"\n"]],[52446,52446],[52445,52445]]],[1543652983594,["gjx16@GJXAIOU",[[-1,52449,"\n"]],[52449,52449],[52448,52448]]],[1543652986329,["gjx16@GJXAIOU",[[1,52450,"  "]],[52450,52450],[52452,52452]]],[1543652988954,["gjx16@GJXAIOU",[[-1,52463,"\n"]],[52463,52463],[52462,52462]]],[1543652992861,["gjx16@GJXAIOU",[[-1,52478,"\n"]],[52478,52478],[52477,52477]]],[1543652995617,["gjx16@GJXAIOU",[[-1,52488,"\n"]],[52488,52488],[52487,52487]]],[1543652998740,["gjx16@GJXAIOU",[[-1,52513,"\n"]],[52513,52513],[52512,52512]]],[1543653001789,["gjx16@GJXAIOU",[[-1,52537,"\n"]],[52537,52537],[52536,52536]]],[1543653004364,["gjx16@GJXAIOU",[[-1,52551,"\n"]],[52551,52551],[52550,52550]]],[1543653008670,["gjx16@GJXAIOU",[[-1,52562,"\n"]],[52562,52562],[52561,52561]]],[1543653011825,["gjx16@GJXAIOU",[[-1,52600,"\n"]],[52600,52600],[52599,52599]]],[1543653014932,["gjx16@GJXAIOU",[[-1,52627,"\n"]],[52627,52627],[52626,52626]]],[1543653020626,["gjx16@GJXAIOU",[[-1,52644,"\n"]],[52644,52644],[52643,52643]]],[1543653022286,["gjx16@GJXAIOU",[[-1,52643,"\n"]],[52643,52643],[52642,52642]]],[1543653025272,["gjx16@GJXAIOU",[[-1,52662,"\n"]],[52662,52662],[52661,52661]]],[1543653028521,["gjx16@GJXAIOU",[[-1,52664,"\n"]],[52664,52664],[52663,52663]]],[1543653033106,["gjx16@GJXAIOU",[[-1,52698,"\n"]],[52698,52698],[52697,52697]]],[1543653094087,[null,[[-1,50670,"\n\n"],[1,50672,"运行"],[1,50718,"\n\n\n"],[-1,50720,"\n"],[-1,50760,"\n"],[1,50762,"加"],[-1,50768,"\n"],[1,50769,"#"],[-1,50896,"\n"],[1,50898,"y"],[-1,50915,"\n"],[1,50918,"y"],[-1,50932,"\n"],[1,50934," "],[-1,50946,"\n"],[1,50948," "],[-1,50965,"\n"],[1,50967,"f"],[-1,50977,"\n"],[1,50979,"["],[-1,51033," "],[1,51035,"有"],[-1,51099,"\n"],[1,51103,"f"],[-1,51180,"\n"],[1,51182,"M"],[-1,51203,"\n"],[1,51206,"M"],[-1,51230,"\n"],[1,51232,"M"],[-1,51262,"\n"],[1,51264,"~"],[-1,51293,"\n"],[1,51295,"M"],[-1,51330,"\n"],[1,51332,"M"],[-1,51372,"\n"],[1,51375,"c"],[-1,51418,"\n"],[1,51420,"b"],[-1,51456,"\n"],[1,51459,"b"],[-1,51496,"\n"],[1,51498,"b"],[-1,51539,"\n"],[1,51541,"b"],[-1,51605,"\n"],[1,51607,"c"],[-1,51621,"\n"],[1,51623,"c"],[-1,51648,"\n"],[1,51651,"i"],[-1,51663,"\n \n"],[1,51666," {"],[-1,51668,"e"],[1,51671,"re"],[-1,51683,"\n"],[1,51685,"}"],[-1,51695,"\n"],[1,51697,"i"],[-1,51726,"\n"],[1,51728,"i"],[-1,51756,"\n"],[1,51759,"i"],[-1,51791,"\n"],[1,51794,"i"],[-1,51826,"\n"],[1,51829,"r"],[-1,51836,"\n"],[1,51838,"i"],[-1,51848,"\n"],[1,51850,"c"],[-1,51853," "],[1,51856,"m"],[-1,51860,"\n"],[1,51862,";"],[-1,51926," "],[1,51928,"决"],[-1,51987," "],[1,51989,"能"],[-1,52121,"\n"],[1,52125,"u"],[-1,52131,"\n"],[1,52133,"T"],[-1,52139,"\n \n"],[1,52142," {"],[-1,52144,"h"],[1,52147,"th"],[-1,52159,"\n"],[1,52161,"}"],[-1,52177,"\n"],[-1,52180,"\n"],[1,52181,"{"],[-1,52183,"o"],[1,52186,"co"],[-1,52198,"\n"],[1,52201,"}"],[-1,52212,"\n"],[1,52214,"i"],[-1,52220,"\n"],[1,52222,";"],[-1,52244,"\n"],[-1,52247,"pblic:\n\n"],[1,52264,"public:\n"],[1,52265,"M"],[-1,52280,"\n \n"],[1,52283," {"],[1,52287,"p"],[-1,52296,"\n"],[1,52298,"}"],[-1,52324,") \n"],[1,52327," {"],[-1,52329,"h"],[1,52332,"th"],[-1,52343,"\n"],[1,52345,"}"],[-1,52364,"\n"],[-1,52367,"\n"],[1,52368,"{"],[-1,52370,"e"],[1,52373,"de"],[-1,52381,"\n"],[1,52383,"}"],[-1,52405,"\n \n"],[1,52408," {"],[-1,52410,"e"],[1,52413,"re"],[-1,52421,"\n"],[1,52423,"}"],[-1,52444,"\n \n"],[1,52447," {"],[-1,52449,"e"],[1,52452,"re"],[-1,52461,"\n"],[1,52463,"}"],[-1,52475,"\n"],[1,52478,"T"],[-1,52486,"\n"],[1,52488,";"],[-1,52511,"\n"],[1,52514,"\n"],[-1,52535,"\n"],[1,52537,"p"],[-1,52549,"\n"],[1,52551,"d"],[-1,52560,"\n"],[1,52562,"M"],[-1,52598,"\n"],[1,52600,"m"],[-1,52625,"\n"],[1,52627,";"],[-1,52641,"\n\n"],[1,52643,"cl"],[-1,52660,"\n"],[1,52664,"u"],[-1,52696,"\n"],[1,52698,"{"]],[50670,50670],[52699,52699]]],[1543653094087,[null,[[1,50670,"\n\n"],[-1,50670,"运行"],[-1,50718,"\n\n\n"],[1,50723,"\n"],[1,50762,"\n"],[-1,50763,"加"],[1,50770,"\n"],[-1,50770,"#"],[1,50898,"\n"],[-1,50899,"y"],[1,50917,"\n"],[-1,50919,"y"],[1,50934,"\n"],[-1,50935," "],[1,50948,"\n"],[-1,50949," "],[1,50967,"\n"],[-1,50968,"f"],[1,50979,"\n"],[-1,50980,"["],[1,51035," "],[-1,51036,"有"],[1,51101,"\n"],[-1,51104,"f"],[1,51182,"\n"],[-1,51183,"M"],[1,51205,"\n"],[-1,51207,"M"],[1,51232,"\n"],[-1,51233,"M"],[1,51264,"\n"],[-1,51265,"~"],[1,51295,"\n"],[-1,51296,"M"],[1,51332,"\n"],[-1,51333,"M"],[1,51374,"\n"],[-1,51376,"c"],[1,51420,"\n"],[-1,51421,"b"],[1,51458,"\n"],[-1,51460,"b"],[1,51498,"\n"],[-1,51499,"b"],[1,51541,"\n"],[-1,51542,"b"],[1,51607,"\n"],[-1,51608,"c"],[1,51623,"\n"],[-1,51624,"c"],[1,51650,"\n"],[-1,51652,"i"],[1,51665,"\n \n"],[-1,51665," {"],[1,51669,"e"],[-1,51671,"re"],[1,51685,"\n"],[-1,51686,"}"],[1,51697,"\n"],[-1,51698,"i"],[1,51728,"\n"],[-1,51729,"i"],[1,51758,"\n"],[-1,51760,"i"],[1,51793,"\n"],[-1,51795,"i"],[1,51828,"\n"],[-1,51830,"r"],[1,51838,"\n"],[-1,51839,"i"],[1,51850,"\n"],[-1,51851,"c"],[1,51855," "],[-1,51857,"m"],[1,51862,"\n"],[-1,51863,";"],[1,51928," "],[-1,51929,"决"],[1,51989," "],[-1,51990,"能"],[1,52123,"\n"],[-1,52126,"u"],[1,52133,"\n"],[-1,52134,"T"],[1,52141,"\n \n"],[-1,52141," {"],[1,52145,"h"],[-1,52147,"th"],[1,52161,"\n"],[-1,52162,"}"],[1,52179,"\n"],[1,52181,"\n"],[-1,52181,"{"],[1,52184,"o"],[-1,52186,"co"],[1,52200,"\n"],[-1,52202,"}"],[1,52214,"\n"],[-1,52215,"i"],[1,52222,"\n"],[-1,52223,";"],[1,52246,"\n"],[1,52248,"pblic:\n\n"],[-1,52257,"public:\n"],[-1,52266,"M"],[1,52282,"\n \n"],[-1,52282," {"],[-1,52288,"p"],[1,52298,"\n"],[-1,52299,"}"],[1,52326,") \n"],[-1,52326," {"],[1,52330,"h"],[-1,52332,"th"],[1,52345,"\n"],[-1,52346,"}"],[1,52366,"\n"],[1,52368,"\n"],[-1,52368,"{"],[1,52371,"e"],[-1,52373,"de"],[1,52383,"\n"],[-1,52384,"}"],[1,52407,"\n \n"],[-1,52407," {"],[1,52411,"e"],[-1,52413,"re"],[1,52423,"\n"],[-1,52424,"}"],[1,52446,"\n \n"],[-1,52446," {"],[1,52450,"e"],[-1,52452,"re"],[1,52463,"\n"],[-1,52464,"}"],[1,52477,"\n"],[-1,52479,"T"],[1,52488,"\n"],[-1,52489,";"],[1,52513,"\n"],[-1,52515,"\n"],[1,52537,"\n"],[-1,52538,"p"],[1,52551,"\n"],[-1,52552,"d"],[1,52562,"\n"],[-1,52563,"M"],[1,52600,"\n"],[-1,52601,"m"],[1,52627,"\n"],[-1,52628,";"],[1,52643,"\n\n"],[-1,52643,"cl"],[1,52662,"\n"],[-1,52665,"u"],[1,52698,"\n"],[-1,52699,"{"]],[52699,52699],[50670,50670]]],[1543653036560,["gjx16@GJXAIOU",[[-1,52701,"\n"]],[52701,52701],[52700,52700]]],[1543653039550,["gjx16@GJXAIOU",[[-1,52712,"\n"]],[52712,52712],[52711,52711]]],[1543653044901,["gjx16@GJXAIOU",[[1,52702,"  "]],[52702,52702],[52704,52704]]],[1543653049246,["gjx16@GJXAIOU",[[-1,52740,"\n"]],[52740,52740],[52739,52739]]],[1543653052443,["gjx16@GJXAIOU",[[-1,52743,"\n"]],[52743,52743],[52742,52742]]],[1543653055988,["gjx16@GJXAIOU",[[1,52744,"  "]],[52744,52744],[52746,52746]]],[1543653058874,["gjx16@GJXAIOU",[[-1,52759,"\n"]],[52759,52759],[52758,52758]]],[1543653063623,["gjx16@GJXAIOU",[[-1,52672,"\n"]],[52672,52672],[52671,52671]]],[1543653084865,["gjx16@GJXAIOU",[[-1,52779,"\n"]],[52779,52779],[52778,52778]]],[1543653088358,["gjx16@GJXAIOU",[[-1,52782,"\n"]],[52782,52782],[52781,52781]]],[1543653093383,["gjx16@GJXAIOU",[[1,52783,"  "]],[52783,52783],[52785,52785]]],[1543653154101,[null,[[-1,50670,"\n\n"],[1,50672,"运行"],[1,50718,"\n\n\n"],[-1,50720,"\n"],[-1,50760,"\n"],[1,50762,"加"],[-1,50768,"\n"],[1,50769,"#"],[-1,50896,"\n"],[1,50898,"y"],[-1,50915,"\n"],[1,50918,"y"],[-1,50932,"\n"],[1,50934," "],[-1,50946,"\n"],[1,50948," "],[-1,50965,"\n"],[1,50967,"f"],[-1,50977,"\n"],[1,50979,"["],[-1,51033," "],[1,51035,"有"],[-1,51099,"\n"],[1,51103,"f"],[-1,51180,"\n"],[1,51182,"M"],[-1,51203,"\n"],[1,51206,"M"],[-1,51230,"\n"],[1,51232,"M"],[-1,51262,"\n"],[1,51264,"~"],[-1,51293,"\n"],[1,51295,"M"],[-1,51330,"\n"],[1,51332,"M"],[-1,51372,"\n"],[1,51375,"c"],[-1,51418,"\n"],[1,51420,"b"],[-1,51456,"\n"],[1,51459,"b"],[-1,51496,"\n"],[1,51498,"b"],[-1,51539,"\n"],[1,51541,"b"],[-1,51605,"\n"],[1,51607,"c"],[-1,51621,"\n"],[1,51623,"c"],[-1,51648,"\n"],[1,51651,"i"],[-1,51663,"\n \n"],[1,51666," {"],[-1,51668,"e"],[1,51671,"re"],[-1,51683,"\n"],[1,51685,"}"],[-1,51695,"\n"],[1,51697,"i"],[-1,51726,"\n"],[1,51728,"i"],[-1,51756,"\n"],[1,51759,"i"],[-1,51791,"\n"],[1,51794,"i"],[-1,51826,"\n"],[1,51829,"r"],[-1,51836,"\n"],[1,51838,"i"],[-1,51848,"\n"],[1,51850,"c"],[-1,51853," "],[1,51856,"m"],[-1,51860,"\n"],[1,51862,";"],[-1,51926," "],[1,51928,"决"],[-1,51987," "],[1,51989,"能"],[-1,52121,"\n"],[1,52125,"u"],[-1,52131,"\n"],[1,52133,"T"],[-1,52139,"\n \n"],[1,52142," {"],[-1,52144,"h"],[1,52147,"th"],[-1,52159,"\n"],[1,52161,"}"],[-1,52177,"\n"],[-1,52180,"\n"],[1,52181,"{"],[-1,52183,"o"],[1,52186,"co"],[-1,52198,"\n"],[1,52201,"}"],[-1,52212,"\n"],[1,52214,"i"],[-1,52220,"\n"],[1,52222,";"],[-1,52244,"\n"],[-1,52247,"pblic:\n\n"],[1,52264,"public:\n"],[1,52265,"M"],[-1,52280,"\n \n"],[1,52283," {"],[1,52287,"p"],[-1,52296,"\n"],[1,52298,"}"],[-1,52324,") \n"],[1,52327," {"],[-1,52329,"h"],[1,52332,"th"],[-1,52343,"\n"],[1,52345,"}"],[-1,52364,"\n"],[-1,52367,"\n"],[1,52368,"{"],[-1,52370,"e"],[1,52373,"de"],[-1,52381,"\n"],[1,52383,"}"],[-1,52405,"\n \n"],[1,52408," {"],[-1,52410,"e"],[1,52413,"re"],[-1,52421,"\n"],[1,52423,"}"],[-1,52444,"\n \n"],[1,52447," {"],[-1,52449,"e"],[1,52452,"re"],[-1,52461,"\n"],[1,52463,"}"],[-1,52475,"\n"],[1,52478,"T"],[-1,52486,"\n"],[1,52488,";"],[-1,52511,"\n"],[1,52514,"\n"],[-1,52535,"\n"],[1,52537,"p"],[-1,52548,"\n"],[1,52551,"d"],[-1,52560,"\n"],[1,52562,"M"],[-1,52598,"\n"],[1,52600,"m"],[-1,52625,"\n"],[1,52627,";"],[-1,52641,"\n\n"],[1,52643,"cl"],[-1,52660,"\n"],[1,52664,"u"],[-1,52670,"\n"],[1,52672,"u"],[-1,52695,"\n \n"],[1,52698," {"],[1,52702,"p"],[-1,52711,"\n"],[1,52713,"}"],[-1,52737,"\n \n"],[1,52740," {"],[-1,52742,"h"],[1,52745,"th"],[-1,52756,"\n"],[1,52758,"}"],[-1,52777,"\n \n"],[1,52780," {"],[-1,52782,"e"],[1,52785,"de"]],[50670,50670],[52787,52787]]],[1543653154101,[null,[[1,50670,"\n\n"],[-1,50670,"运行"],[-1,50718,"\n\n\n"],[1,50723,"\n"],[1,50762,"\n"],[-1,50763,"加"],[1,50770,"\n"],[-1,50770,"#"],[1,50898,"\n"],[-1,50899,"y"],[1,50917,"\n"],[-1,50919,"y"],[1,50934,"\n"],[-1,50935," "],[1,50948,"\n"],[-1,50949," "],[1,50967,"\n"],[-1,50968,"f"],[1,50979,"\n"],[-1,50980,"["],[1,51035," "],[-1,51036,"有"],[1,51101,"\n"],[-1,51104,"f"],[1,51182,"\n"],[-1,51183,"M"],[1,51205,"\n"],[-1,51207,"M"],[1,51232,"\n"],[-1,51233,"M"],[1,51264,"\n"],[-1,51265,"~"],[1,51295,"\n"],[-1,51296,"M"],[1,51332,"\n"],[-1,51333,"M"],[1,51374,"\n"],[-1,51376,"c"],[1,51420,"\n"],[-1,51421,"b"],[1,51458,"\n"],[-1,51460,"b"],[1,51498,"\n"],[-1,51499,"b"],[1,51541,"\n"],[-1,51542,"b"],[1,51607,"\n"],[-1,51608,"c"],[1,51623,"\n"],[-1,51624,"c"],[1,51650,"\n"],[-1,51652,"i"],[1,51665,"\n \n"],[-1,51665," {"],[1,51669,"e"],[-1,51671,"re"],[1,51685,"\n"],[-1,51686,"}"],[1,51697,"\n"],[-1,51698,"i"],[1,51728,"\n"],[-1,51729,"i"],[1,51758,"\n"],[-1,51760,"i"],[1,51793,"\n"],[-1,51795,"i"],[1,51828,"\n"],[-1,51830,"r"],[1,51838,"\n"],[-1,51839,"i"],[1,51850,"\n"],[-1,51851,"c"],[1,51855," "],[-1,51857,"m"],[1,51862,"\n"],[-1,51863,";"],[1,51928," "],[-1,51929,"决"],[1,51989," "],[-1,51990,"能"],[1,52123,"\n"],[-1,52126,"u"],[1,52133,"\n"],[-1,52134,"T"],[1,52141,"\n \n"],[-1,52141," {"],[1,52145,"h"],[-1,52147,"th"],[1,52161,"\n"],[-1,52162,"}"],[1,52179,"\n"],[1,52181,"\n"],[-1,52181,"{"],[1,52184,"o"],[-1,52186,"co"],[1,52200,"\n"],[-1,52202,"}"],[1,52214,"\n"],[-1,52215,"i"],[1,52222,"\n"],[-1,52223,";"],[1,52246,"\n"],[1,52248,"pblic:\n\n"],[-1,52257,"public:\n"],[-1,52266,"M"],[1,52282,"\n \n"],[-1,52282," {"],[-1,52288,"p"],[1,52298,"\n"],[-1,52299,"}"],[1,52326,") \n"],[-1,52326," {"],[1,52330,"h"],[-1,52332,"th"],[1,52345,"\n"],[-1,52346,"}"],[1,52366,"\n"],[1,52368,"\n"],[-1,52368,"{"],[1,52371,"e"],[-1,52373,"de"],[1,52383,"\n"],[-1,52384,"}"],[1,52407,"\n \n"],[-1,52407," {"],[1,52411,"e"],[-1,52413,"re"],[1,52423,"\n"],[-1,52424,"}"],[1,52446,"\n \n"],[-1,52446," {"],[1,52450,"e"],[-1,52452,"re"],[1,52463,"\n"],[-1,52464,"}"],[1,52477,"\n"],[-1,52479,"T"],[1,52488,"\n"],[-1,52489,";"],[1,52513,"\n"],[-1,52515,"\n"],[1,52537,"\n"],[-1,52538,"p"],[1,52550,"\n"],[-1,52552,"d"],[1,52562,"\n"],[-1,52563,"M"],[1,52600,"\n"],[-1,52601,"m"],[1,52627,"\n"],[-1,52628,";"],[1,52643,"\n\n"],[-1,52643,"cl"],[1,52662,"\n"],[-1,52665,"u"],[1,52672,"\n"],[-1,52673,"u"],[1,52697,"\n \n"],[-1,52697," {"],[-1,52703,"p"],[1,52713,"\n"],[-1,52714,"}"],[1,52739,"\n \n"],[-1,52739," {"],[1,52743,"h"],[-1,52745,"th"],[1,52758,"\n"],[-1,52759,"}"],[1,52779,"\n \n"],[-1,52779," {"],[1,52783,"e"],[-1,52785,"de"]],[52787,52787],[50670,50670]]],[1543653098026,["gjx16@GJXAIOU",[[-1,52795,"\n"]],[52795,52795],[52794,52794]]],[1543653118416,["gjx16@GJXAIOU",[[-1,52818,"\n"]],[52818,52818],[52817,52817]]],[1543653121217,["gjx16@GJXAIOU",[[-1,52821,"\n"]],[52821,52821],[52820,52820]]],[1543653124357,["gjx16@GJXAIOU",[[1,52822,"  "]],[52822,52822],[52824,52824]]],[1543653127010,["gjx16@GJXAIOU",[[-1,52834,"\n"]],[52834,52834],[52833,52833]]],[1543653131252,["gjx16@GJXAIOU",[[-1,52856,"\n"]],[52856,52856],[52855,52855]]],[1543653134178,["gjx16@GJXAIOU",[[-1,52859,"\n"]],[52859,52859],[52858,52858]]],[1543653137611,["gjx16@GJXAIOU",[[1,52860,"  "]],[52860,52860],[52862,52862]]],[1543653140293,["gjx16@GJXAIOU",[[-1,52873,"\n"]],[52873,52873],[52872,52872]]],[1543653144205,["gjx16@GJXAIOU",[[-1,52888,"\n"]],[52888,52888],[52887,52887]]],[1543653148378,["gjx16@GJXAIOU",[[-1,52897,"\n"]],[52897,52897],[52896,52896]]],[1543653152783,["gjx16@GJXAIOU",[[-1,52920,"\n"]],[52920,52920],[52919,52919]]],[1543653214101,[null,[[-1,50670,"\n\n"],[1,50672,"运行"],[1,50718,"\n\n\n"],[-1,50720,"\n"],[-1,50760,"\n"],[1,50762,"加"],[-1,50768,"\n"],[1,50769,"#"],[-1,50896,"\n"],[1,50898,"y"],[-1,50915,"\n"],[1,50918,"y"],[-1,50932,"\n"],[1,50934," "],[-1,50946,"\n"],[1,50948," "],[-1,50965,"\n"],[1,50967,"f"],[-1,50977,"\n"],[1,50979,"["],[-1,51033," "],[1,51035,"有"],[-1,51099,"\n"],[1,51103,"f"],[-1,51180,"\n"],[1,51182,"M"],[-1,51203,"\n"],[1,51206,"M"],[-1,51230,"\n"],[1,51232,"M"],[-1,51262,"\n"],[1,51264,"~"],[-1,51293,"\n"],[1,51295,"M"],[-1,51330,"\n"],[1,51332,"M"],[-1,51372,"\n"],[1,51375,"c"],[-1,51418,"\n"],[1,51420,"b"],[-1,51456,"\n"],[1,51459,"b"],[-1,51496,"\n"],[1,51498,"b"],[-1,51539,"\n"],[1,51541,"b"],[-1,51605,"\n"],[1,51607,"c"],[-1,51621,"\n"],[1,51623,"c"],[-1,51648,"\n"],[1,51651,"i"],[-1,51663,"\n \n"],[1,51666," {"],[-1,51668,"e"],[1,51671,"re"],[-1,51683,"\n"],[1,51685,"}"],[-1,51695,"\n"],[1,51697,"i"],[-1,51726,"\n"],[1,51728,"i"],[-1,51756,"\n"],[1,51759,"i"],[-1,51791,"\n"],[1,51794,"i"],[-1,51826,"\n"],[1,51829,"r"],[-1,51836,"\n"],[1,51838,"i"],[-1,51848,"\n"],[1,51850,"c"],[-1,51853," "],[1,51856,"m"],[-1,51860,"\n"],[1,51862,";"],[-1,51926," "],[1,51928,"决"],[-1,51987," "],[1,51989,"能"],[-1,52121,"\n"],[1,52125,"u"],[-1,52131,"\n"],[1,52133,"T"],[-1,52139,"\n \n"],[1,52142," {"],[-1,52144,"h"],[1,52147,"th"],[-1,52159,"\n"],[1,52161,"}"],[-1,52177,"\n"],[-1,52180,"\n"],[1,52181,"{"],[-1,52183,"o"],[1,52186,"co"],[-1,52198,"\n"],[1,52201,"}"],[-1,52212,"\n"],[1,52214,"i"],[-1,52220,"\n"],[1,52222,";"],[-1,52244,"\n"],[-1,52247,"pblic:\n\n"],[1,52264,"public:\n"],[1,52265,"M"],[-1,52280,"\n \n"],[1,52283," {"],[1,52287,"p"],[-1,52296,"\n"],[1,52298,"}"],[-1,52324,") \n"],[1,52327," {"],[-1,52329,"h"],[1,52332,"th"],[-1,52343,"\n"],[1,52345,"}"],[-1,52364,"\n"],[-1,52367,"\n"],[1,52368,"{"],[-1,52370,"e"],[1,52373,"de"],[-1,52381,"\n"],[1,52383,"}"],[-1,52405,"\n \n"],[1,52408," {"],[-1,52410,"e"],[1,52413,"re"],[-1,52421,"\n"],[1,52423,"}"],[-1,52444,"\n \n"],[1,52447," {"],[-1,52449,"e"],[1,52452,"re"],[-1,52461,"\n"],[1,52463,"}"],[-1,52475,"\n"],[1,52478,"T"],[-1,52486,"\n"],[1,52488,";"],[-1,52511,"\n"],[1,52514,"\n"],[-1,52535,"\n"],[1,52537,"p"],[-1,52548,"\n"],[1,52551,"d"],[-1,52560,"\n"],[1,52562,"M"],[-1,52598,"\n"],[1,52600,"m"],[-1,52625,"\n"],[1,52627,";"],[-1,52641,"\n\n"],[1,52643,"cl"],[-1,52659,"\n"],[1,52664,"u"],[-1,52670,"\n"],[1,52672,"u"],[-1,52694,"\n"],[-1,52697,"\n"],[1,52698,"{"],[1,52702,"p"],[-1,52710,"\n"],[1,52713,"}"],[-1,52737,"\n \n"],[1,52740," {"],[-1,52742,"h"],[1,52745,"th"],[-1,52756,"\n"],[1,52758,"}"],[-1,52777,"\n \n"],[1,52780," {"],[-1,52782,"e"],[1,52785,"de"],[-1,52793,"\n"],[1,52795,"}"],[-1,52816,"\n \n"],[1,52819," {"],[-1,52821,"e"],[1,52824,"re"],[-1,52832,"\n"],[1,52834,"}"],[-1,52854,"\n \n"],[1,52857," {"],[-1,52859,"e"],[1,52862,"re"],[-1,52871,"\n"],[1,52873,"}"],[-1,52885,"\n"],[1,52888,"i"],[-1,52895,"\n"],[1,52897,";"],[-1,52918,"\n"],[1,52920,"\n"]],[50670,50670],[52921,52921]]],[1543653214102,[null,[[1,50670,"\n\n"],[-1,50670,"运行"],[-1,50718,"\n\n\n"],[1,50723,"\n"],[1,50762,"\n"],[-1,50763,"加"],[1,50770,"\n"],[-1,50770,"#"],[1,50898,"\n"],[-1,50899,"y"],[1,50917,"\n"],[-1,50919,"y"],[1,50934,"\n"],[-1,50935," "],[1,50948,"\n"],[-1,50949," "],[1,50967,"\n"],[-1,50968,"f"],[1,50979,"\n"],[-1,50980,"["],[1,51035," "],[-1,51036,"有"],[1,51101,"\n"],[-1,51104,"f"],[1,51182,"\n"],[-1,51183,"M"],[1,51205,"\n"],[-1,51207,"M"],[1,51232,"\n"],[-1,51233,"M"],[1,51264,"\n"],[-1,51265,"~"],[1,51295,"\n"],[-1,51296,"M"],[1,51332,"\n"],[-1,51333,"M"],[1,51374,"\n"],[-1,51376,"c"],[1,51420,"\n"],[-1,51421,"b"],[1,51458,"\n"],[-1,51460,"b"],[1,51498,"\n"],[-1,51499,"b"],[1,51541,"\n"],[-1,51542,"b"],[1,51607,"\n"],[-1,51608,"c"],[1,51623,"\n"],[-1,51624,"c"],[1,51650,"\n"],[-1,51652,"i"],[1,51665,"\n \n"],[-1,51665," {"],[1,51669,"e"],[-1,51671,"re"],[1,51685,"\n"],[-1,51686,"}"],[1,51697,"\n"],[-1,51698,"i"],[1,51728,"\n"],[-1,51729,"i"],[1,51758,"\n"],[-1,51760,"i"],[1,51793,"\n"],[-1,51795,"i"],[1,51828,"\n"],[-1,51830,"r"],[1,51838,"\n"],[-1,51839,"i"],[1,51850,"\n"],[-1,51851,"c"],[1,51855," "],[-1,51857,"m"],[1,51862,"\n"],[-1,51863,";"],[1,51928," "],[-1,51929,"决"],[1,51989," "],[-1,51990,"能"],[1,52123,"\n"],[-1,52126,"u"],[1,52133,"\n"],[-1,52134,"T"],[1,52141,"\n \n"],[-1,52141," {"],[1,52145,"h"],[-1,52147,"th"],[1,52161,"\n"],[-1,52162,"}"],[1,52179,"\n"],[1,52181,"\n"],[-1,52181,"{"],[1,52184,"o"],[-1,52186,"co"],[1,52200,"\n"],[-1,52202,"}"],[1,52214,"\n"],[-1,52215,"i"],[1,52222,"\n"],[-1,52223,";"],[1,52246,"\n"],[1,52248,"pblic:\n\n"],[-1,52257,"public:\n"],[-1,52266,"M"],[1,52282,"\n \n"],[-1,52282," {"],[-1,52288,"p"],[1,52298,"\n"],[-1,52299,"}"],[1,52326,") \n"],[-1,52326," {"],[1,52330,"h"],[-1,52332,"th"],[1,52345,"\n"],[-1,52346,"}"],[1,52366,"\n"],[1,52368,"\n"],[-1,52368,"{"],[1,52371,"e"],[-1,52373,"de"],[1,52383,"\n"],[-1,52384,"}"],[1,52407,"\n \n"],[-1,52407," {"],[1,52411,"e"],[-1,52413,"re"],[1,52423,"\n"],[-1,52424,"}"],[1,52446,"\n \n"],[-1,52446," {"],[1,52450,"e"],[-1,52452,"re"],[1,52463,"\n"],[-1,52464,"}"],[1,52477,"\n"],[-1,52479,"T"],[1,52488,"\n"],[-1,52489,";"],[1,52513,"\n"],[-1,52515,"\n"],[1,52537,"\n"],[-1,52538,"p"],[1,52550,"\n"],[-1,52552,"d"],[1,52562,"\n"],[-1,52563,"M"],[1,52600,"\n"],[-1,52601,"m"],[1,52627,"\n"],[-1,52628,";"],[1,52643,"\n\n"],[-1,52643,"cl"],[1,52661,"\n"],[-1,52665,"u"],[1,52672,"\n"],[-1,52673,"u"],[1,52696,"\n"],[1,52698,"\n"],[-1,52698,"{"],[-1,52703,"p"],[1,52712,"\n"],[-1,52714,"}"],[1,52739,"\n \n"],[-1,52739," {"],[1,52743,"h"],[-1,52745,"th"],[1,52758,"\n"],[-1,52759,"}"],[1,52779,"\n \n"],[-1,52779," {"],[1,52783,"e"],[-1,52785,"de"],[1,52795,"\n"],[-1,52796,"}"],[1,52818,"\n \n"],[-1,52818," {"],[1,52822,"e"],[-1,52824,"re"],[1,52834,"\n"],[-1,52835,"}"],[1,52856,"\n \n"],[-1,52856," {"],[1,52860,"e"],[-1,52862,"re"],[1,52873,"\n"],[-1,52874,"}"],[1,52887,"\n"],[-1,52889,"i"],[1,52897,"\n"],[-1,52898,";"],[1,52920,"\n"],[-1,52921,"\n"]],[52921,52921],[50670,50670]]],[1543653155750,["gjx16@GJXAIOU",[[-1,52922,"\n"]],[52922,52922],[52921,52921]]],[1543653158915,["gjx16@GJXAIOU",[[-1,52946,"\n"]],[52946,52946],[52945,52945]]],[1543653163283,["gjx16@GJXAIOU",[[-1,52963,"\n"]],[52963,52963],[52962,52962]]],[1543653166344,["gjx16@GJXAIOU",[[-1,52974,"\n"]],[52974,52974],[52973,52973]]],[1543653169233,["gjx16@GJXAIOU",[[-1,53008,"\n"]],[53008,53008],[53007,53007]]],[1543653172348,["gjx16@GJXAIOU",[[-1,53036,"\n"]],[53036,53036],[53035,53035]]],[1543653202964,["gjx16@GJXAIOU",[[-1,52664,"public:"]],[52671,52671],[52664,52664]]],[1543653203933,["gjx16@GJXAIOU",[[-1,52664,"\n"]],[52664,52664],[52663,52663]]],[1543653274091,[null,[[-1,50670,"\n\n"],[1,50672,"运行"],[1,50718,"\n\n\n"],[-1,50720,"\n"],[-1,50760,"\n"],[1,50762,"加"],[-1,50768,"\n"],[1,50769,"#"],[-1,50896,"\n"],[1,50898,"y"],[-1,50915,"\n"],[1,50918,"y"],[-1,50932,"\n"],[1,50934," "],[-1,50946,"\n"],[1,50948," "],[-1,50965,"\n"],[1,50967,"f"],[-1,50977,"\n"],[1,50979,"["],[-1,51033," "],[1,51035,"有"],[-1,51099,"\n"],[1,51103,"f"],[-1,51180,"\n"],[1,51182,"M"],[-1,51203,"\n"],[1,51206,"M"],[-1,51230,"\n"],[1,51232,"M"],[-1,51262,"\n"],[1,51264,"~"],[-1,51293,"\n"],[1,51295,"M"],[-1,51330,"\n"],[1,51332,"M"],[-1,51372,"\n"],[1,51375,"c"],[-1,51418,"\n"],[1,51420,"b"],[-1,51456,"\n"],[1,51459,"b"],[-1,51496,"\n"],[1,51498,"b"],[-1,51539,"\n"],[1,51541,"b"],[-1,51605,"\n"],[1,51607,"c"],[-1,51621,"\n"],[1,51623,"c"],[-1,51648,"\n"],[1,51651,"i"],[-1,51663,"\n \n"],[1,51666," {"],[-1,51668,"e"],[1,51671,"re"],[-1,51683,"\n"],[1,51685,"}"],[-1,51695,"\n"],[1,51697,"i"],[-1,51726,"\n"],[1,51728,"i"],[-1,51756,"\n"],[1,51759,"i"],[-1,51791,"\n"],[1,51794,"i"],[-1,51826,"\n"],[1,51829,"r"],[-1,51836,"\n"],[1,51838,"i"],[-1,51848,"\n"],[1,51850,"c"],[-1,51853," "],[1,51856,"m"],[-1,51860,"\n"],[1,51862,";"],[-1,51926," "],[1,51928,"决"],[-1,51987," "],[1,51989,"能"],[-1,52121,"\n"],[1,52125,"u"],[-1,52131,"\n"],[1,52133,"T"],[-1,52139,"\n \n"],[1,52142," {"],[-1,52144,"h"],[1,52147,"th"],[-1,52159,"\n"],[1,52161,"}"],[-1,52177,"\n"],[-1,52180,"\n"],[1,52181,"{"],[-1,52183,"o"],[1,52186,"co"],[-1,52198,"\n"],[1,52201,"}"],[-1,52212,"\n"],[1,52214,"i"],[-1,52220,"\n"],[1,52222,";"],[-1,52244,"\n"],[-1,52248,""],[1,52248,"u"],[-1,52263,"\n"],[1,52265,"M"],[-1,52280,"\n \n"],[1,52283," {"],[1,52287,"p"],[-1,52296,"\n"],[1,52298,"}"],[-1,52324,") \n"],[1,52327," {"],[-1,52329,"h"],[1,52332,"th"],[-1,52343,"\n"],[1,52345,"}"],[-1,52365,"\n \n"],[1,52368," {"],[-1,52370,"e"],[1,52373,"de"],[-1,52381,"\n"],[1,52383,"}"],[-1,52405,"\n \n"],[1,52408," {"],[-1,52410,"e"],[1,52413,"re"],[-1,52421,"\n"],[1,52423,"}"],[-1,52444,"\n \n"],[1,52447," {"],[-1,52449,"e"],[1,52452,"re"],[-1,52461,"\n"],[1,52463,"}"],[-1,52475,"\n"],[1,52478,"T"],[-1,52486,"\n"],[1,52488,";"],[-1,52511,"\n"],[1,52514,"\n"],[-1,52535,"\n"],[1,52537,"p"],[-1,52548,"\n"],[1,52551,"d"],[-1,52560,"\n"],[1,52562,"M"],[-1,52598,"\n"],[1,52600,"m"],[-1,52625,"\n"],[1,52627,";"],[-1,52641,"\n\n"],[1,52643,"cl"],[-1,52659,"\n"],[1,52664,"u"],[-1,52687,"\n \n"],[1,52690," {"],[1,52694,"p"],[-1,52703,"\n"],[1,52705,"}"],[-1,52729,"\n \n"],[1,52732," {"],[-1,52734,"h"],[1,52737,"th"],[-1,52747,"\n"],[1,52750,"}"],[-1,52769,"\n \n"],[1,52772," {"],[-1,52774,"e"],[1,52777,"de"],[-1,52784,"\n"],[1,52787,"}"],[-1,52808,"\n \n"],[1,52811," {"],[-1,52813,"e"],[1,52816,"re"],[-1,52824,"\n"],[1,52826,"}"],[-1,52846,"\n \n"],[1,52849," {"],[-1,52851,"e"],[1,52854,"re"],[-1,52863,"\n"],[1,52865,"}"],[-1,52877,"\n"],[1,52880,"i"],[-1,52887,"\n"],[1,52889,";"],[-1,52910,"\n"],[1,52914,"i"],[-1,52936,"\n"],[1,52938,"c"],[-1,52953,"\n"],[1,52955,"d"],[-1,52963,"\n"],[1,52966,"M"],[-1,52998,"\n"],[1,53000,"c"],[-1,53026,"\n"],[1,53028,";"]],[50670,50670],[53029,53029]]],[1543653274091,[null,[[1,50670,"\n\n"],[-1,50670,"运行"],[-1,50718,"\n\n\n"],[1,50723,"\n"],[1,50762,"\n"],[-1,50763,"加"],[1,50770,"\n"],[-1,50770,"#"],[1,50898,"\n"],[-1,50899,"y"],[1,50917,"\n"],[-1,50919,"y"],[1,50934,"\n"],[-1,50935," "],[1,50948,"\n"],[-1,50949," "],[1,50967,"\n"],[-1,50968,"f"],[1,50979,"\n"],[-1,50980,"["],[1,51035," "],[-1,51036,"有"],[1,51101,"\n"],[-1,51104,"f"],[1,51182,"\n"],[-1,51183,"M"],[1,51205,"\n"],[-1,51207,"M"],[1,51232,"\n"],[-1,51233,"M"],[1,51264,"\n"],[-1,51265,"~"],[1,51295,"\n"],[-1,51296,"M"],[1,51332,"\n"],[-1,51333,"M"],[1,51374,"\n"],[-1,51376,"c"],[1,51420,"\n"],[-1,51421,"b"],[1,51458,"\n"],[-1,51460,"b"],[1,51498,"\n"],[-1,51499,"b"],[1,51541,"\n"],[-1,51542,"b"],[1,51607,"\n"],[-1,51608,"c"],[1,51623,"\n"],[-1,51624,"c"],[1,51650,"\n"],[-1,51652,"i"],[1,51665,"\n \n"],[-1,51665," {"],[1,51669,"e"],[-1,51671,"re"],[1,51685,"\n"],[-1,51686,"}"],[1,51697,"\n"],[-1,51698,"i"],[1,51728,"\n"],[-1,51729,"i"],[1,51758,"\n"],[-1,51760,"i"],[1,51793,"\n"],[-1,51795,"i"],[1,51828,"\n"],[-1,51830,"r"],[1,51838,"\n"],[-1,51839,"i"],[1,51850,"\n"],[-1,51851,"c"],[1,51855," "],[-1,51857,"m"],[1,51862,"\n"],[-1,51863,";"],[1,51928," "],[-1,51929,"决"],[1,51989," "],[-1,51990,"能"],[1,52123,"\n"],[-1,52126,"u"],[1,52133,"\n"],[-1,52134,"T"],[1,52141,"\n \n"],[-1,52141," {"],[1,52145,"h"],[-1,52147,"th"],[1,52161,"\n"],[-1,52162,"}"],[1,52179,"\n"],[1,52181,"\n"],[-1,52181,"{"],[1,52184,"o"],[-1,52186,"co"],[1,52200,"\n"],[-1,52202,"}"],[1,52214,"\n"],[-1,52215,"i"],[1,52222,"\n"],[-1,52223,";"],[1,52246,"\n"],[1,52249,""],[-1,52249,"u"],[1,52265,"\n"],[-1,52266,"M"],[1,52282,"\n \n"],[-1,52282," {"],[-1,52288,"p"],[1,52298,"\n"],[-1,52299,"}"],[1,52326,") \n"],[-1,52326," {"],[1,52330,"h"],[-1,52332,"th"],[1,52345,"\n"],[-1,52346,"}"],[1,52367,"\n \n"],[-1,52367," {"],[1,52371,"e"],[-1,52373,"de"],[1,52383,"\n"],[-1,52384,"}"],[1,52407,"\n \n"],[-1,52407," {"],[1,52411,"e"],[-1,52413,"re"],[1,52423,"\n"],[-1,52424,"}"],[1,52446,"\n \n"],[-1,52446," {"],[1,52450,"e"],[-1,52452,"re"],[1,52463,"\n"],[-1,52464,"}"],[1,52477,"\n"],[-1,52479,"T"],[1,52488,"\n"],[-1,52489,";"],[1,52513,"\n"],[-1,52515,"\n"],[1,52537,"\n"],[-1,52538,"p"],[1,52550,"\n"],[-1,52552,"d"],[1,52562,"\n"],[-1,52563,"M"],[1,52600,"\n"],[-1,52601,"m"],[1,52627,"\n"],[-1,52628,";"],[1,52643,"\n\n"],[-1,52643,"cl"],[1,52661,"\n"],[-1,52665,"u"],[1,52689,"\n \n"],[-1,52689," {"],[-1,52695,"p"],[1,52705,"\n"],[-1,52706,"}"],[1,52731,"\n \n"],[-1,52731," {"],[1,52735,"h"],[-1,52737,"th"],[1,52749,"\n"],[-1,52751,"}"],[1,52771,"\n \n"],[-1,52771," {"],[1,52775,"e"],[-1,52777,"de"],[1,52786,"\n"],[-1,52788,"}"],[1,52810,"\n \n"],[-1,52810," {"],[1,52814,"e"],[-1,52816,"re"],[1,52826,"\n"],[-1,52827,"}"],[1,52848,"\n \n"],[-1,52848," {"],[1,52852,"e"],[-1,52854,"re"],[1,52865,"\n"],[-1,52866,"}"],[1,52879,"\n"],[-1,52881,"i"],[1,52889,"\n"],[-1,52890,";"],[1,52912,"\n"],[-1,52915,"i"],[1,52938,"\n"],[-1,52939,"c"],[1,52955,"\n"],[-1,52956,"d"],[1,52965,"\n"],[-1,52967,"M"],[1,53000,"\n"],[-1,53001,"c"],[1,53028,"\n"],[-1,53029,";"]],[53029,53029],[50670,50670]]],[1543653247952,["gjx16@GJXAIOU",[[-1,53041,"****"]],[53045,53045],[53041,53041]]],[1543653248943,["gjx16@GJXAIOU",[[1,53041," "]],[53041,53041],[53042,53042]]]],null,"gjx16@GJXAIOU"],["03945404-2c6e-4a41-bc0a-59b8387d9eff",1543653370996,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁;\n   * c++面向对象模型初探;  \n   * c++面向对象多态原理探究;\n   * 操作符重载;\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;//定义两个对象c1和c2\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n};\n\n```\nTeacher.cpp\n//具体实现函数内容，在函数名前面加上`类名::`\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1:设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)//因为类的成员变量这里都是private:\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n###  (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n###  (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//需要重载=号操作符，才能解决带来的浅拷贝问题\n\n\tobj2 = obj3; //=号操作，也是一种浅拷贝\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++的默认copy构造函数是浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n\n---\n\n\n### （五）多个对象构造和析构\n\n**1.对象初始化列表**\n\n- 1）对象初始化列表出现原因\n程序本身是有问题的\n```cpp\n\n/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B   //在一个类里面组合了一个带有参数的构造函数的类，因为C++编译器要确定分配给B多大的内存，但是没法初始化A定义的两个对象（因为需要调用有参的构造函数）\n{\npublic:   //没有写B的构造函数，按理说应该调用默认的构造函数\n\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  //主要是因为没有方法和没有机会去初始化这两个A定义的对象\n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB;\n\treturn 0;\n\n}\n\n```\n\n解决方法：\n```cpp\n/*\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n};\n\n\nclass B  \n{\npublic:   \n//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）\n\tB(int _a, int _b) : a1(1), a2(3)  \n\t{\n\n\t}\n//第二种参数传递的方法：\n/*\nB(int _a, int _b,int m,int n) : a1(m), a2(n)  \n\t{\n      a = _a;\n      b = _b;\n\t}\n\t\n*/\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  \n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB(1,2);\n\t//第二种方式：B objB(1,2,4,3)\n\treturn 0;\n\n}\n\n```\n\n**以上程序的操作顺序：**\n首先执行被组合对象的构造函数（a1,a2），如果有多个组合对象，则按照定义的顺序，而不是按照初始化列表的顺序（：后面的顺序）\n析构函数：和构造函数的调用顺序相反\n\n  - 1.必须这样做：\n    - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    - 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n  - 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    - 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    - 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n- 2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n```cpp\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n{\n // some other assignment operation\n}\n```\n\n\n- 3）注意概念\n  - 初始化：被初始化的对象正在创建\n  - 赋值：被赋值的对象已经存在\n\n- 4）注意：\n  - 成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n  - 初始化列表先于构造函数的函数体执行\n\n**说明：**\n\n* 1 C++中提供了初始化列表对成员变量进行初始化\n* 2 使用初始化列表出现原因：\n  * 1.必须这样做：\n    * 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n    * 而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    * 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n  * 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    * 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    * 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n```cpp\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n ABC(int a, int b, int c)\n {\n this->a = a;\n this->b = b;\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"ABC construct ..\\n\");\n }\n\n ~ABC()\n {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n }\n\nprotected:\nprivate:\n int a;\n int b;\n int c;\n};\n\nclass MyD\n{\npublic:\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n {\n cout<<\"MyD()\"<<endl;\n }\n\n ~MyD()\n {\n cout<<\"~MyD()\"<<endl;\n }\n\nprotected:\nprivate:\n ABC abc1; //c++编译器不知道如何构造abc1\n ABC abc2;\n const int m;\n};\n\nint run()\n{\n MyD myD;\n return 0;\n}\n\nint main_dem03()\n{\n run();\n system(\"pause\");\n return 0;\n}\n\n```\n\n\n\n\n### （六）构造函数和析构函数的调用顺序研究\n\n**构造函数与析构函数的调用顺序**\n\n- 1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n- 2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n### （七）构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1构造析构综合训练**\n```cpp\n\n/*\n\n总结 构造和析构的调用顺序\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n\tABC(int a, int b, int c)   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\n\t}\n\n\t~ABC()\n\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\n\nclass MyD \n{\npublic:\n\tMyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~MyD()\n\t{\n\t\tcout << \"~MyD()\" << endl;\n\t}\n\n\tMyD(const MyD & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\tcout << \"MyD(const MyD &obj)\" << endl;\n\t}\n\nprotected:\nprivate:\n\tABC abc1; //c++编译器不知道如何构造abc1//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\tABC abc2;\n\tconst int m;//因为是const m,所以上面所有的m都进行了赋值\n};\n\n\nint doThing(MyD myel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;\n}\n\n\nint run2()//二\n{\n\tMyD myD;//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\treturn 0;\n}\n\nint run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main()\n{\n\trun2();//一\n\t//run3();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n\n\n```\n\n\n**2匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3匿名对象强化训练**\n\n3） 构造中调用构造\n\n```cpp\n/*\n\n构造中调用构造\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass MyTest\n{\npublic:\n\tMyTest(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t}\n\n\tMyTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\n\t\tMyTest(a, b, 10);\n\t}\n\n\t~MyTest()\n\t{\n\t\tcout << \"MyTest is ...\" << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n\n\npublic:\n\tint getC() const { return c; }\n\n\tvoid setC(int val) { c = val; }\n};\n\nint main()\n{\n\tMyTest t1(1, 2);\n\tcout << t1.getC() << endl;\n\tsystem(\"pause\");\n\treturn 0;\n\t\n}\n\n\n```\n\n 结论： 构造函数中调用构造函数，是一个蹩脚的行为。\n程序内存图：\n![搜狗截图20181124125452]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181124125452.png)\n\n### （八）对象的动态建立和释放\n\n**1.new和delete基本语法**\n```cpp\n/*\n\nnew 和delete的使用\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nvoid main()\n{\n\t//先分配内存然后赋值\n\tint *p = new int;  //分配基础类型\n\t*p = 20;  \n\n\t//在定义的时候直接分配内存\n\tint *p1 = new int(30);\n\tcout << *p1 << endl;\n\n\tsystem(\"pause\");\n\treturn; \n}\n\n```\n\n- 1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n  **注意： new和delete是运算符，不是函数，因此执行效率高。**\n\n- 2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： \nnew int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 \nnew char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址    new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n- 3）new和delete运算符使用的一般格式为：\n  用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n![new运算符动态]($resource/new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%A8%E6%80%81.png)\n```cpp\n\n/*\n使用malloc /free 与new /delete的区别\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest();\n\t~Test();\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\nTest::Test()\n{\n\tcout << \"执行了构造函数\" << endl;\n}\n\nTest::~Test()\n{\n\tcout << \"执行了析构函数\" << endl;\n}\n\n\n\nint main()\n{\n\t//基础类型\n\tint *p1 = (int *)malloc(sizeof(int));\n\t*p1 = 10;\n\tdelete p1;\n\n\tint *p2 = new int;\n\t*p2 = 20;\n\tfree(p2);\n\n\n\n\t//数组类型（元素为基础类型）\n\tint *p3 = (int *)malloc(sizeof(int)*10);\n\tp3[0] = 1;\n\tdelete[]p3;\n\n\tint *p4 = new int[10];\n\tp4[1] = 2;\n\tfree(p4);\n\n\n\t//类\n\tTest *p5 = (Test *)malloc(sizeof(Test));\n\tdelete p5;\n\n\tTest *p6 = new Test(10);\n\tfree(p6);\n}\n\n\n```\n**结论：** \nnew：不仅分配内存，而且调用了构造函数\ndelete:不仅释放了内存，而且调用了析构函数\n\n- 4） 应用举例\n\n![5]($resource/5.png)\n\n**2类对象的动态建立和释放**\n\n- 使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n-  C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n  比如：\n\n  Box *pt;  //定义一个指向Box类对象的指针变量pt\n      pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n   这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n  新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n   在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3.编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n\n\n\n## 四、静态成员变量和成员函数\n\n\n思考：每个变量，拥有属性。有没有一些属性，归所有对象拥有？\n\n### （一）静态成员变量\n\n- **1定义静态成员变量**\n  - 关键字 **static**  可以用于说明一个类的成员，\n    静态成员提供了一个同类对象的共享机制\n\n  - 把一个类的成员说明为 **static**  时，这个类无论有多少个对象被创建，这些对象共享这个 **static**  成员\n\n  - 静态成员局部于类，它不是对象成员\n\n![1]($resource/1.png)\n\n例如：\n\n```cpp\n\n/*\n静态成员变量\n*/\n\n#include<iostream>\nusing namespace std;\n\nclass counter\n{\n\n\tstatic int num; //**声明与定义静态数据成员**\n\npublic:\n\n\tvoid setnum(int i) \n\t{ \n\t\tnum = i; \n\t} //成员函数访问静态数据成员\n\n\tvoid shownum() \n\t{ \n\t\tcout << num << endl;\n\t}\n\n};\n\nint counter::num = 0;//声明与定义静态数据成员\n\nvoid main()\n{\n\tcounter a, b;\n\n\ta.shownum(); //调用成员函数访问私有静态数据成员\n\tb.shownum();\n\ta.setnum(10);\n\ta.shownum();\n\tb.shownum();\n\n}\n\n```\n\n![6]($resource/6.png)\n\n**从结果可以看出，访问的是同一个静态数据成员**\n\n- **2使用静态成员变量**\n```cpp\n//例5-14_使用公有静态数据成员\n\n#include<iostream.h>\n\nclass counter\n{ \npublic :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n\n```\n使用静态成员函数调用静态成员变量\n```cpp\n/*\n静态成员函数\n*/\n// 结论：在静态成员函数中可以使用静态成员变量，但是不能使用类中普通的成员变量\n\n#include\"iostream\"\nusing namespace std;\n\nclass BB\n{\npublic:\n\tint printC()\n\t{\n\t\tcout << \"c:\" << c << endl;\n\t\treturn c;\n\t}\n\n\tint addC()\n\t{\n\t\tc = c+1;\n\t}\n\n\n\tstatic void getC()\n\t{\n\t\tcout << \"c\" << c << endl;  //可以直接在静态成员函数中使用静态成员变量，但是不能直接使用一般变量\n\t}\nprivate:\n\tint a;\n\tint b;\n\tstatic int c;\n\n};\n\n\nint BB::c = 10;  //初始化成员变量值\n\nvoid main()\n{\n\tBB b1, b2, b3;\n\tb1.printC();//10\n\tb2.addC();//11\n\tb3.printC();//11\n\n\t//调用成员函数两种方法；\n\tb3.getC();//使用对象.\n\tBB::getC();//使用类::\n\n\n\n}\n\n```\n\n### (二)静态成员函数\n\n- **1）概念**\n\n  - 静态成员函数数冠以关键字static\n\n  - 静态成员函数提供不依赖于类数据结构的共同操作，它没有this指针\n  - 在类外调用静态成员函数用 `_类名_ ::`作限定词，或通过对象调用\n\n- **2）案例**\n![7]($resource/7.png)\n\n- **3）疑难问题：**\n静态成员函数中，不能使用普通变量。\n//静态成员变量属于整个类的，分不清楚，是那个具体对象的属性。\n![成员函数中的疑难问题]($resource/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98.png)\n\n**4.3 综合训练**\n\n\n\n## 五、 C++面向对象模型初探\n\n**前言**\n\n- C++对象模型可以概括为以下2部分：\n\n  - 1. 语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等等。\n\n  - 2. 对于各种支持的底层实现机制。\n\n  在c语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。在c++中，通过抽象数据类型（abstract data type，ADT），在类中定义数据和函数，来实现数据和函数直接的绑定。\n\n  概括来说，在C++类中有两种成员数据：static、nonstatic；三种成员函数：static、nonstatic、virtual。\n\n![C++类的组成]($resource/C++%E7%B1%BB%E7%9A%84%E7%BB%84%E6%88%90.png)\n\n### （一）基础知识\n\nC++中的class从面向对象理论出发，将变量(属性)和函数(方法)集中定义在一起，用于描述现实世界中的类。从计算机的角度，程序依然由数据段和代码段构成。\n\n**C++编译器如何完成面向对象理论到计算机程序的转化？**\n换句话：C++编译器是如何管理类、对象、类和对象之间的关系\n具体的说：具体对象调用类中的方法，那，c++编译器是如何区分，是那个具体的类，调用这个方法那?\n\n思考一下程序结果\n```cpp\n/*\n面向对象模型初探\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass C1\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\nprotected:\n\nprivate:\n\n}; //12\n\nclass C2\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\n\tstatic int m; \n\npublic:\n\n\tint getK() const { return k; } //方法是属于代码，应该放在代码区\n\tvoid setK(int val) { k = val; } \n\nprotected:\n\nprivate:\n}; \n\nstruct S1\n{\n\tint i;\n\tint j;\n\tint k;\n}; \n\nstruct S2\n{\n\tint i;\n\tint j;\n\tint k;\n\tstatic int m;\n}; \n\nint main()\n{\n\n\tprintf(\"c1:%d \\n\", sizeof(C1));\n\tprintf(\"c2:%d \\n\", sizeof(C2));\n\tprintf(\"s1:%d \\n\", sizeof(S1));\n\tprintf(\"s2:%d \\n\", sizeof(S2));\n\tsystem(\"pause\");\n\n}\n```\n程序运行结果：\n`c1:12`\n`c2:12`\n`s1:12`\n`s2:12`\n\n \n### (二)编译器对属性和方法的处理机制\n\n通过上面的案例，我们可以的得出：\n1）C++类对象中的成员变量和成员函数是分开存储的\n- 成员变量：\n  - 普通成员变量：存储于对象中，与struct变量有相同的内存布局和字节对齐方式\n  - 静态成员变量：存储于全局数据区中\n\n- 成员函数：存储于代码段中。\n问题出来了：很多对象共用一块代码？代码是如何区分具体对象的那？\n换句话说：int getK() const { return k; }，代码是如何区分，具体obj1、obj2、obj3对象的k值？\n\n2）C++编译器对普通成员函数的内部处理\n\n![C++编译器对普通成员函数的内部处理]($resource/C++%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E9%83%A8%E5%A4%84%E7%90%86.png)\n\n请仔细思考，并说出你的总结！\n\n\n\n### （三）总结\n\n1、C++类对象中的成员变量和成员函数是分开存储的。C语言中的内存四区模型仍然有效！\n**2、C++中类的普通成员函数都隐式包含一个指向当前对象的this指针。**\n3、静态成员函数、成员变量属于类\n\n静态成员函数与普通成员函数的区别\n\n静态成员函数不包含指向具体对象的指针\n\n普通成员函数包含一个指向具体对象的指针\n\n\n### （四）this指针\n\n![this指针图示]($resource/this%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png)\n\n实验1：若类成员函数的形参 和 类的属性（成员变量）名字相同，通过this指针来解决。\n```cpp\n\n/*\nthis 指针\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass Test\n{\npublic:\n\tTest( int a, int b)//Test(Test *this, int a, int b)//因为这里成员函数的形参和成员变量一样，不用this指针会出现：a = a ,b = b;\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printT()\n\t{\n\t\tcout << \"a; \" << a << endl;\n\t\tcout << \"b: \" << this->b << endl;\n\t}\n\n\n    const void hello(int a,int b )\n    {\n      //下面这两个语句都是错误的\n      this->a = 100;\n      this ->b = 200;\n    }\n   //const修饰的this指针，即相当于this指针指向的内存空间不能被修改\n   //因为上面的函数会别C++编译器解析为:void hello(const Test *this, int a ,int b)\n   //同时上面的const其实下载函数（）外面的任何位置都行\n   \nprotected:\nprivate:\n\tint a;\n\tint b;\n};\nint  main()\n{\n\tTest t1(1, 2);\n\tt1.printT();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`a:1`\n`b:2`\n\n\n实验2：类的成员函数可通过const修饰，请问const修饰的是谁\n\n\n### （五）全局函数PK成员函数\n\n 1、把全局函数转化成成员函数，通过this指针隐藏左操作数\n\n   Test add(Test &t1, Test &t2)===》Test add( Test &t2)\n```cpp\n/*\n全局函数与成员函数\n*/\n\n\n//使用全局函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\t\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nTest Testadd(Test &t1, Test &t2)\n{\n\tTest tmp(3,4);\n\treturn tmp;\n}\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3(2, 3);\n\tt3= Testadd(t1, t2);\n}\n```\n\n```cpp\n//使用成员函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\tTest Testadd(Test &t2)\n\t{\n\t\tTest tmp(this->a + t2.a, this->b + t2.b);\n\t\treturn tmp;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3 = t1.Testadd(t2);//匿名对象直接转化成t4\n\tTest t4(3,5);\n\tt4 = t1.Testadd(t2);  //匿名对象复制给t5\n}\n\n\n```\n 2、把成员函数转换成全局函数，多了一个参数\n\n   void printAB()===》void printAB(Test *pthis)\n\n 3、函数返回元素和返回引用\n```cpp\nTest& add(Test &t2) //*this //函数返回引用,相当于返回自身，谁调用返回谁\n {      \n   this->a = this->a + t2.getA();\n\n   this->b = this->b + t2.getB();\n\n   return *this; //*操作让this指针回到元素状态\n\n }\n\nTest add2(Test &t2) //*this //函数返回元素\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n return t3;\n\n }\n\n void add3(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n //return t3;\n\n }\n  \n\n```\n\n\n\n\n---\n\n## 六、友元\n\n### （一）友元函数\n- 首先友元函数是全局函数，在友元函数中可以修改类的私有属性；\n- 友元函数在类中的声明位置位于public或者private只下均可；\n![8]($resource/8.png)\n\n```cpp\n//友元函数：\n\n#include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend void modify(A *PA,int _a);  //友元函数的声明\n\n\tA(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\n\nprivate:\n\tint a;\n\tint b;\n};\n\nvoid modify(A *PA,int _a)//后面的参数可加可不加\n{\n\t//PA->a = 100;//可以这样直接修改值\n\tPA->a = _a;  //通过传递的值进行修改\n}\n\n\nint main()\n{\n\tA a1(1, 2);\n\tcout << \"a:\" << a1.getA() << endl;\n\tmodify(&a1,20);\n\n\tint aa = a1.getA();\n\n\tcout << \"aa:\" << aa << endl;\n}\n```\n![9]($resource/9.png)\n\n\n### （二）友元类\n\n- 若B类是A类的友员类，则B类的所有成员函数都是A类的友员函数\n- 若B类是A类的友元类，则B类可以直接修改A的成员变量和成员函数\n- 友员类通常设计为一种对数据操作或类之间传递消息的辅助类\n程序示例：\n```cpp\n//友元类\n #include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend class B;//将B 声明为A的友元类，这样B 可以直接修改A的成员变量和成员函数 \n\n\tA(int a=0, int b=0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B\n{\npublic:\n\n\tvoid set(int a)\n\t{\n\t\tobjA.a = a;\n\t}\n\n\tvoid printa()\n\t{\n\t\tcout << objA.a << endl;\n\t}\n\nprivate:\n\tA objA;\n};\n\n\nint main()\n{\n\tB b1;\n\tb1.set(200);\n\tb1.printa();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：200\n\n![10]($resource/10.png)\n\n\n\n## 七、强化训练\n\n**1 static关键字强化训练题**\n\n某商店经销一种货物。货物购进和卖出时以箱为单位，各箱的重量不一样，因此，商店需要记录目前库存的总重量。现在用C++模拟商店货物购进和卖出的情况。\n```cpp\n#include \"iostream\"\nusing namespace std;\n\nclass Goods\n{\npublic:\n\n\tGoods(int w) { weight = w; total_weight += w; }\n\n\t~Goods() { total_weight -= weight; }\n\n\tint Weight() { return weight; };\n\n\tstatic int TotalWeight() { return total_weight; }\n\n\tGoods *next;\n\nprivate:\n\n\tint weight;\n\tstatic int total_weight;\n\n};\n\nint Goods::total_weight = 0;\n\n//r尾部指针\n\nvoid purchase(Goods * &f, Goods *& r, int w)\n{\n\n\tGoods *p = new Goods(w);\n\n\tp->next = NULL;\n\n\tif (f == NULL) f = r = p;\n\n\telse { r->next = p; r = r->next; } //尾部指针下移或新结点变成尾部结点\n\n}\n\nvoid sale(Goods * & f, Goods * & r)\n{\n\n\tif (f == NULL) { cout << \"No any goods!\\n\"; return; }\n\n\tGoods *q = f; f = f->next; delete q;\n\n\tcout << \"saled.\\n\";\n\n}\n\nvoid main()\n{\n\tGoods * front = NULL, *rear = NULL;\n\n\tint w; int choice;\n\n\tdo\n\t{\n\t\tcout << \"Please choice:\\n\";\n\n\t\tcout << \"Key in 1 is purchase,\\nKey in 2 is sale,\\nKey in 0 is over.\\n\";\n\n\t\tcin >> choice;\n\n\t\tswitch (choice) // 操作选择\n\t\t{\n\t\tcase 1: // 键入1，购进1箱货物\n\t\t{ cout << \"Input weight: \";\n\t\tcin >> w;\n\n\t\tpurchase(front, rear, w); // 从表尾插入1个结点\n\n\t\tbreak;\n\t\t}\n\n\t\tcase 2:              // 键入2，售出1箱货物\n\t\t{ sale(front, rear); break; } // 从表头删除1个结点\n\n\t\tcase 0: break;              // 键入0，结束\n\t\t}\n\n\t\tcout << \"Now total weight is:\" << Goods::TotalWeight() << endl;\n\n\t} while (choice);\n}\n```\n**2** **数组类封装**\n\n目标：解决实际问题，训练构造函数、copy构造函数等，为操作符重载做准备\n\n数组类的头文件:`Array.h`\n```cpp\n#pragma once\nclass Array\n{\npublic:\n\tArray(int length);\n\tArray(const Array&obj);\n\t~Array();\npublic:\n\tint length();\n\n\tvoid setData(int index, int value);\n\n\tint getData(int index);\nprivate:\n\tint m_length;\n\tchar *m_space;\n};\n```\n\n数组类的头文件的实现：`Array.cpp`\n```cppp\n#include \"Array.h\"\nusing namespace std;\n#include\"iostream\"\n\nArray::Array(int length)\n{\n\tif (length < 0)\n\t{\n\t\tlength = 0;\n\t}\n\telse\n\t{\n\t\tm_length = length;\n\t\tm_space = new char[m_length];\n\t}\n}\n\nArray::Array(const Array&obj)\n{\n   this->m_length = obj.m_length;\n   this->m_space = new char [this->m_length];//进行分配内存空间\n\n  for(int i= 0; i < obj.m_length;i++)//数组元素复制， 这里的obj.m_length可以直接替换成m_length\n  {\n    this->m_space[i] = obj.m_space[i];\n  }\n}\n\nArray::~Array()\n{\n\tif (m_space != NULL)\n\t{\n\t\tdelete[] m_space;\n\t\tm_length = 0;\n\t}\n}\n\nvoid Array::setData(int index, int valude)\n{\n\tm_space[index] = valude;\n}\n\nint Array::getData(int index)\n{\n\treturn m_space[index];\n}\n\nint Array::length()\n{\n\treturn m_length; \n}\n```\n\n数组类的测试\n```cpp\n#include \"iostream\"\n#include \"Array.h\"\nusing namespace std;\n\nint main()\n{\n\tArray a1(10);\n\tfor (int i = 0; i < a1.length(); i++)\n\t{\n\t\ta1.setData(i, i);\n\t}\n\tfor (int i = 0; i <  a1.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a1.getData(i));\n\t}\n\n\tArray a2 = a1;\n\n\tfor (int i = 0; i < a2.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a2.getData(i));\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**3.小结**\n\n* 类通常用关键字class定义。类是数据成员和成员函数的封装。类的实例称为对象。\n* 结构类型用关键字struct定义，是由不同类型数据组成的数据类型。\n* 类成员由private, protected, public决定访问特性。public成员集称为接口。\n* 构造函数在创建和初始化对象时自动调用。析构函数则在对象作用域结束时自动调用。\n* 重载构造函数和复制构造函数提供了创建对象的不同初始化方式。\n* 静态成员是局部于类的成员，提供一种同类对象的共享机制。\n* 友员用关键字friend声明。友员是对类操作的一种辅助手段。一个类的友员可以访问该类各种性质的成员\n* 链表是一种重要的动态数据结构，可以在程序运行时创建或撤消数据元素。\n\n\n\n---\n\n\n## 八、运算符重载\n\n### （一）概念\n\n#### **1.什么是运算符重载**\n\n![11]($resource/11.png)\n所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是”一名多用”。\n\n运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重载。例如，大 家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行加法运算，如5+8， 5.8 +3.67等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的， 但由于C++已经对运算符”+”进行了重载，所以就能适用于int, float, doUble类型的运算。\n\n又如`<<`是C的位运算中的位移运算符（左移），但在输出操作中又是与流对 象cout 配合使用的流插入运算符，`>>`也是位移运算符(右移），但在输入操作中又是与流对象 cin 配合使用的流提取运算符。这就是运算符重载(operator overloading)。C系统对`<<`和`>>`进行了重载，用户在不同的场合下使用它们时，作用是不同 的。对`<<`和`>>`的重载处理是放在头文件stream中的。因此，如果要在程序中用`<<`和`>>`作流插入运算符和流提取运算符，必须在本文件模块中包含头文件stream(当然还应当包括”using namespace std“)。\n\n现在要讨论的问题是：用户能否根据自己的需要对C++已提供的运算符进行重载，赋予它们新的含义，使之一名多用？\n\n#### **2.运算符重载入门技术推演**\n\n1为什么会用运算符重载机制\n//原因 Complex是用户自定义类型，编译器根本不知道如何进行加减，但是编译器给提供了一种机制，让用户自己去完成，自定义类型的加减操作。。。这个机制就是运算符重载机制\n\n用复数类举例，定义一个Complex类,有两个对象，每个对象由两个属性，要求使用对象之间的加法实现对应属性的相加，示例程序如下：\n```cpp\n\n/*对于基础数据类型，C++编译器知道如何进行运算，但是对于用户自定义的类型编译器提供了一种\n让自定义数据类型进行运算符操作的机制,=》运算符重载机制\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\npublic:\n\tfriend Complex operator+(Complex &c1, Complex &c2);//友元函数声明\n\n\tComplex(int a = 0, int b = 0)//构造函数\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\nprivate:\n  int a;\n  int b;\n};\n\n/*使用全局函数，通过调用全局函数实现\nComplex myAdd(Complex &c1, Complex &c2)\n{\n Complex tmp(c1.a+ c2.a, c1.b + c2.b);\n\n return tmp;\n}\n*/\n\n\n//可以简单的想象为将上面全局函数的函数名替换为operator+\nComplex operator+(Complex &c1, Complex &c2)\n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\treturn tmp;\n}\n\n\n\nint  main()\n{\n\tComplex c1(1, 2), c2(3, 4);\n\n\t//方法1： 通过调用普通函数实现\n\t//Complex c3 = myAdd(c1, c2);\n\t//c3.printCom();\n\n\n\t//方法2  将函数名称替换为：operator+ \n\t//使用以下方式进行调用\n\t//Complex c3 = operator+(c1, c2);\n\t//c3.printCom();\n\n\n\t//方法3：最常用的调用方式\n\tComplex c3 = c1 + c2; \n\tc3.printCom()\n\n\tsystem(\"pause\");\n\treturn;\n}\n```\n程序运行结果：`4+6i`\n\n\n---\n\n### （二）运算符重载的限制\n![12]($resource/12.png)\n\n重载运算符函数可以对运算符进行新的解释，但是原有的基本语义不变：\n* 不改变运算符的优先级\n* 不改变运算符的结合性\n* 不改变运算符所需要的操作数\n* 不能创建新的运算符\n\n---\n\n### （三）运算符重载编程基础\n![14]($resource/14.png)\n例如:\n   //全局函数  完成 +操作符  重载  \n    Complex operator+(Complex &c1, Complex &c2)\n\n  //类成员函数  完成 -操作符  重载\n    Complex operator-(Complex &c2)\n\n#### **1.运算符重载的两种方法:**\n- 运算符可以重载为成员函数了或者友元函数\n- 关键区别在于成员函数具有this指针，友元函数没有this 指针\n- 不管是成员函数还是友元函数重载，运算符的使用方法相同\n- 但是两种的传递参数不同，实现代码也不同，应用场合也不同\n\n- **二元操作符重载的实现：**\n![16]($resource/16.png)\n \n```cpp\n//二元函数操作符的重载的两种方法\n\n\n/*全局函数、类成员函数方法实现运算符重载步骤\n1）要承认操作符重载是一个函数，写出函数名称operator + ()\n2）根据操作数，写出函数参数\n3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex operator+(Complex &c1, Complex &c2); //这里是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\t//成员函数实现 - 运算符重载 \n\tComplex operator-(Complex &c2)//因为是c1调用的，因此这里的this 指向c1\n\t{\n\t\tComplex tmp(this->a - c2.a, this->b -  c2.b);//通过构造函数实现 tmp中成员变量的变化 \n\t\treturn tmp;\n\t}\n\n};\n\n\n//使用全局函数实现  + 运算符重载\nComplex operator+(Complex &c1, Complex &c2)\n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\n\treturn tmp;\n}\n\n\nint  main()\n{\n\tComplex c1(1, 2), c2(3, 4);\n\n\t//使用 全局函数\n\tComplex c3 = c1 + c2;\n\tc3.printCom();\n\n\t//使用成员函数\n\tComplex c4 = c1.operator-(c2);\n\tc4.printCom();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`4 + 6i`\n`-2 + -2i`\n\n\n- **一元函数操作符重载的实现：**\n![17]($resource/17.png)\n\n- 实现前置++和前置--\n```cpp\n//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现前置++和前置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex& operator++(Complex &c1); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\tComplex& operator--()\n\t{\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn *this;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  + 运算符重载\nComplex& operator++(Complex &c1)\n{\n\tc1.a++;\n\tc1.b++;\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1,c2;\n\n\t//使用全局函数实现前置++操作符的重置\n\t++c1;\n\tc1.printCom();\n\n\n\t//使用成员函数实现前置--操作符的重置\n\t--c2;\n\tc2.printCom();\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`1 + 1i`\n`-1 + -1i`\n\n- 实现后置++和后置--\n```cpp\n//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现后置++ 和后置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex operator++(Complex &c1, int); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\t//成员函数实现后置--\n\tComplex operator--(int)\n\t{\n\t\tComplex tmp = *this;\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn tmp;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  ++ 运算符重载\nComplex operator++(Complex &c1,int)  //为了和前置++的函数能够共同存在，参数中加了一个占位符从而实现函数重载\n{\n\t//前置++是先使用后++ ，所以应该先返回c1,但是直接使用return c1.会造成程序的直接退出，后面的++无法实现，所以使用临时变量\n\n\tComplex tmp = c1;\n\tc1.a++;\n\tc1.b++;\n\treturn tmp;\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1, c2;\n\t//使用全局函数实现后置++操作符的重置\n\tc1++;\n\tc1.printCom();\n\n\t//使用成员函数实现后置--操作符的重置\n\tc2--;\n\tc2.printCom();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n\n**前置和后置运算符总结:**\n\nC++中通过一个占位参数来区分前置运算和后置运算\n![18]($resource/18.png)\n\n\n\n#### **2.定义运算符重载函数名的步骤**\n全局函数、类成员函数方法实现运算符重载步骤\n * 1）要承认操作符重载是一个函数，写出函数名称operator+ ()\n * 2）根据操作数，写出函数参数\n * 3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n\n#### **3.友元函数实现操作符重载的应用场景**\n\n**1）友元函数和成员函数选择方法**\n- 当无法修改左操作数的类时，使用全局函数进行重载,因为成员函数需要在左边的类中进行修改；\n- =, [], ()和->操作符只能通过成员函数进行重载\n\n**2）用友元函数重载 <<和 >>操作符**\n\n* istream 和 ostream 是 C++ 的预定义流类，都不让修改的222222222222222222222222222222222222222222222\n* cin 是 istream 的对象，cout 是 ostream 的对象\n* 运算符 << 由ostream 重载为插入操作，用于输出基本类型数据\n* 运算符 >> 由 istream 重载为提取操作，用于输入基本类型数据\n* 用友员函数重载 << 和 >> ，输出和输入用户自定义的数据类型\n\na）用全局函数方法实现 << 操作符\n```pp\n//实现<<运算符的重载\n\n//注释内部是一套完整的程序，但是只能实现一次打印输出，新的一套程序可以实现链式输出\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\t//friend  void operator<<(ostream &cout, Complex &c1); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n};\n\n/*这里类似于cout只能有全局函数加上友元函数实现，因为如果要使用成员函数实现，需要在cout 的类：ostream中定义成员函数，\n但是这个ostream类是系统隐藏的，不现实；\nvoid operator<<(ostream &cout, Complex &c1)\n{\n\tcout << c1.a << \" + \" << c1.b << \"i\" << endl;\n}\n*/\n\nostream& operator<<(ostream &cout, Complex &c2)  //要想实现函数返回值当左值，需要返回一个引用\n{\n\tcout << c2.a << \" + \" << c2.b << \"i\" << endl;\n\treturn cout;\n}\n\n\n \nint  main()\n{\n\tComplex c1, c2;\n\t//cout << c1;  //实现将c1中两个元素以a+bi的形式直接打印输出；\n\t/*\n\t首先承认运算符重载是函数，所以函数名为：operator<<\n\t其次因为有左右参数，分别为ostream 和Complex类，所有函数头为：operator<<(ostream&cout,Complex c1)\n\t然后根据返回值确定最前面的返回值类型\n\t*/\n\n\tcout << c2 << \"kdjfkdjfkd\";\n\t//因为<<操作符是从左到右，所以左边执行返回值要当左值再次执行这个函数\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n**3）友元函数重载操作符使用注意点**\n\n- a） 友员函数重载运算符常用于运算符的左右操作数类型不同的情况\n![19]($resource/19.png)\n- b）其他\n  - 在第一个参数需要隐式转换的情形下，使用友员函数重载运算符是正确的选择\n  - 友员函数没有 this 指针，所需操作数都必须在参数表显式声明，很容易实现类型的隐式转换\n  - C++中不能用友员函数重载的运算符有\n     = （）  ［］  －>\n\n**4）友元函数案例vector类**\n```cpp\n#include <iostream>\nusing namespace std;\n\n//为vector类重载流插入运算符和提取运算符\n\nclass vector\n{\npublic:\n\tvector(int size = 1);\n\n\t~vector();\n\n\tint & operator[](int i);\n\n\tfriend ostream & operator << (ostream & output, vector &);\n\n\tfriend istream & operator >> (istream & input, vector &);\n\nprivate:\n\tint * v;\n\n\tint len;\n\n};\n\nvector::vector(int size)\n{\n\tif (size <= 0 || size > 100)\n\t{\n\t\tcout << \"The size of \" << size << \" is null !\\n\"; abort();\n\t}\n\n\tv = new int[size]; len = size;\n}\n\nvector :: ~vector()\n{\n\tdelete[] v;\n\n\tlen = 0;\n}\n\nint &vector::operator[](int i)\n{\n\tif (i >= 0 && i < len) return v[i];\n\n\tcout << \"The subscript \" << i << \" is outside !\\n\"; abort();\n}\n\nostream & operator << (ostream & output, vector & ary)\n{\n\tfor (int i = 0; i < ary.len; i++)\n\t\toutput << ary[i] << \" \";\n\n\toutput << endl;\n\treturn output;\n}\n\nistream & operator >> (istream & input, vector & ary)\n{\n\tfor (int i = 0; i < ary.len; i++)\n\t\tinput >> ary[i];\n\n\treturn input;\n}\n\nvoid main()\n{\n\tint k;\n\tcout << \"Input the length of vector A :\\n\";\n\tcin >> k;\n\tvector A(k);\n\tcout << \"Input the elements of vector A :\\n\";\n\tcin >> A;\n\tcout << \"Output the elements of vector A :\\n\";\n\tcout << A;\n\tsystem(\"pause\");\n}\n\n```\n\n### （四）运算符重载提高\n\n#### **1.运算符重载机制**\n\nC++编译器是如何支持操作符重载机制的?\n\n#### **2.重载赋值运算符=**\n\n* 赋值运算符重载用于对象数据的复制\n* operator= 必须重载为成员函数\n* 重载函数原型为：\n  类型&类名:: operator= ( const  类名 & ) ;\n\n案例：完善Name类，支持=号操作。\n![22]($resource/22.png)\n\n  结论:\n 1 先释放旧的内存\n 2 返回一个引用\n 3 =操作符 从右向左\n```cpp\n//重载 = 操作符\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\t//obj3 = obj1; // C++编译器提供的  等号操作  也属  浅拷贝\\\n\t// obj4 = obj3 = obj1\n\t//obj3.operator=(obj1)\n\n\tName& operator=(Name &obj1)\n\t{\n\t\t//1 先释放obj3旧的内存\n\n\t\tif (this->pName != NULL)\n\t\t{\n\t\t\tdelete[] pName;\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\t//2 根据obj1分配内存大小\n\n\t\tthis->size = obj1.size;\n\t\tthis->pName = new char[size + 1];\n\n\t\t//3把obj1赋值给obj3\n\n\t\tstrcpy(pName, obj1.pName);\n\t\treturn *this;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nint main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n\n#### **3.重载数组下表运算符[]** ==这里的视频再看一遍==\n- 重载[]和()运算符\n  - 运算符 [] 和 () 是二元运算符\n  - [] 和 () 只能用成员函数重载，不能用友元函数重载\n\n- 重载下标运算符 []\n  - [] 运算符用于访问数据对象的元素\n  重载格式：  返回值类型 类 :: operator[] ( 类型 ) ；\n  设 x 是类 X 的一个对象，则表达式 `x[y]` 可被解释为  `x.operator[](y)`\n\n![33]($resource/33.png)\n![44]($resource/44.png)\n\n\n#### **4.重载函数调用符()**\n\n() 运算符用于函数调用\n\n重载格式:  返回值类型 类:: operator() ( 表达式表 ) ；\n\n例1\n设 x是类 X的一个对象，则表达式*\nx ( arg1, arg2, … )\n可被解释为\nx . operator () (arg1, arg2, … )\n\n**案例：**\n例2：用重载()运算符实现数学函数的抽象\n```cpp\n\n#include <iostream>\n\nclass F\n\n { public :\n\n double operator ( )  ( double x , double y ) ;\n\n } ;\n\ndouble F :: operator ( )  ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\nf.getA();\n\n cout << f ( 5.2 , 2.5 ) << endl ; // **f . _operator()_ (5.2, 2.5)**\n\n}\n```\n比较普通成员函数\n\n**//例3用重载()运算符实现 pk成员函数**\n```cpp\n#include <iostream.h>\n\nclass F\n\n { public :\n\n double memFun ( double x , double y ) ;\n\n } ;\n\ndouble F :: memFun ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\n cout << f.memFun ( 5.2 , 2.5 ) << endl ;\n\n}\n```\n\n#### **5.为什么不要重载&&和||操作符**\n\n- 理论知识：\n  - 1）&&和||是C++中非常特殊的操作符\n  - 2）&&和||内置实现了短路规则\n  - 3）操作符重载是靠函数重载来完成的\n  - 4）操作数作为函数参数传递\n  - 5）C++的函数参数都会被求值，无法实现短路规则\n```cpp\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nclass Test\n{\n\tint i;\n\npublic:\n\tTest(int i)\n\t{\n\t\tthis->i = i;\n\t}\n\n\tTest operator+ (const Test& obj)\n\t{\n\t\tTest ret(0);\n\n\t\tcout << \"执行+号重载函数\" << endl;\n\n\t\tret.i = i + obj.i;\n\n\t\treturn ret;\n\t}\n\n\tbool operator&& (const Test& obj)\n\t{\n\t\tcout << \"执行&&重载函数\" << endl;\n\n\t\treturn i && obj.i;\n\t}\n\n};\n\n// && 从左向右\n\nint  main()\n{\n\tint a1 = 0;\n\tint a2 = 1;\n\tcout << \"注意：&&操作符的结合顺序是从左向右\" << endl;\n\n\tif (a1 && (a1 + a2))\n\t{\n\t\tcout << \"有一个是假，则不在执行下一个表达式的计算\" << endl;\n\t}\n\n\tTest t1 = 0;\n\tTest t2 = 1;\n\n\tif(t1 && (t1 + t2))\n\t{\n\t\tt1.operator&&(t1 + t2);\n\t\tt1.operator&&(t1.operator+(t2));\n\n\t\t\t//t1 && t1.operator+(t2)\n\n\t\t\t// t1.operator( t1.operator(t2) )\n\n\t\t\tcout << \"两个函数都被执行了，而且是先执行了+\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`注意：&&操作符的结合顺序是从左向右`\n`执行+号重载函数`\n`执行&&重载函数`\n\n\n### （五）运算符重载在项目开发中的应用\n\n#### **1实现一个数组类**\n添加<< >>\n#### **2实现一个字符串类**\n\n构造函数要求\n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串类 以零结尾的字符串\n\n//若len为0,表示空串\n```cpp\nMyString a; //空串 “”\nMyString a(“dddd”);\nMyString b = a;\nb = “aaaaaa” \nb = a;\n\nif (a > b)\nif (a == b)\nb[i] = ‘a’;\n```\n常用的操作符\n\n<< >> != == > < =\n\n```cpp\n//C语言中没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串 以零结尾的字符串\n\nclass MyString\n{\n friend ostream& operator<<(ostream &out, const MyString &s);\n\npublic: //构造和析构\n MyString(int len = 0);\n MyString(const char *p);\n MyString(const MyString& obj);\n ~MyString();\n\npublic: //操作符重载\n MyString& operator=(const char *p);\n MyString& operator=(const MyString& obj);\n char& operator[](int index) const;\n\npublic:\n bool operator==(const char* p) const;\n bool operator!=(const char* p) const;\n bool operator==(const MyString& s) const;\n bool operator!=(const MyString& s) const;\n\npublic: //string to c\n char *c_str();\n const char* c_str() const;\n int length()\n {\n   return m_len;\n }\n\npublic:\n int operator<(const char *p);\n int operator>(const char *p);\n int operator<(const MyString &s);\n int operator>(const MyString &s);\nprivate:\n int m_len;\n char *m_p;\n};\n\n```\n\n\n#### **3智能指针类编写**\n\n1问题抛出\n  指针使用过程中，经常会出现内存泄漏和内存多次被释放常\n\n2解决方案：例如：boost库的智能指针\n  项目开发中，要求开发者使用预先编写的智能指针类对象代替C语言中的原生指针\n\n3智能指针思想\n  工程中的智能指针是一个类模板\n  通过构造函数接管申请的内存\n  通过析构函数确保堆内存被及时释放\n  通过重载指针运算符* 和 -> 来模拟指针的行为\n  通过重载比较运算符 == 和 != 来模拟指针的比较\n\n```cpp\nclass Test\n{\npublic:\n Test()\n {\n   this->a = 10;\n }\n\n void printT()\n {\n   cout<<a<<endl;\n }\n\nprivate:\n int a;\n};\n\nclass MyTestPointer\n{\npublic:\n\npublic:\n MyTestPointer()\n {\n   p = NULL;\n }\n\n MyTestPointer(Test* p)\n {\n   this->p = p;\n }\n\n ~MyTestPointer()\n {\n   delete p;\n }\n\n Test* operator->()\n {\n   return p;\n }\n\n Test& operator*()\n {\n   return *p;\n }\n\nprotected:\n Test *p;\n};\n\nvoid main01_classp()\n{\n\n Test *p = new Test;\n p->printT();\n delete p;\n MyTestPointer myp = new Test; //构造函数\n myp->printT(); //重载操作符 ->\n};\n\n```\n\n```cpp\nclass MyIntPointer\n{\npublic:\n\n MyIntPointer()\n {\n   p = NULL;\n }\n\n MyIntPointer(int* p)\n {\n   this->p = p;\n }\n\n ~MyIntPointer()\n {\n   delete p;\n }\n\n int* operator->()\n {\n   return p;\n }\n\n int& operator*()\n {\n   return *p;\n }\n\nprotected:\n int *p;\n};\n\nvoid main02_intp()\n{\n int *p = new int(100);\n cout<<*p<<endl;\n delete p;\n MyIntPointer myp = new int(200);\n cout<<*myp<<endl; //重载*操作符\n};\n```\n\n**8.7 附录：运算符和结合性**\n\n![55]($resource/55.png)\n\n![66]($resource/66.png)\n\n- 总结\n  * 操作符重载是C++的强大特性之一\n  * 操作符重载的本质是通过函数扩展操作符的语义\n  * operator关键字是操作符重载的关键\n  * friend关键字可以对函数或类开发访问权限\n  * 操作符重载遵循函数重载的规则\n  * 操作符重载可以直接使用类的成员函数实现\n  * =, [], ()和->操作符只能通过成员函数进行重载\n  * ++操作符通过一个int参数进行前置与后置的重载\n  * C++中不要重载&&和||操作符\n\n\n\n\n\n\n\n\n\n\n\n",[[1543653330571,["gjx16@GJXAIOU",[[-1,52515,"\n"]],[52515,52515],[52514,52514]]],[1543653348062,["gjx16@GJXAIOU",[[-1,52671,"\n"]],[52671,52671],[52670,52670]]],[1543653518585,["gjx16@GJXAIOU",[[-1,53078,"\n"]],[53078,53078],[53077,53077]]],[1543653558599,["gjx16@GJXAIOU",[[-1,53342,"\n"]],[53342,53342],[53341,53341]]],[1543653559172,["gjx16@GJXAIOU",[[-1,53341,"\n"]],[53341,53341],[53340,53340]]],[1543653561559,["gjx16@GJXAIOU",[[-1,53340,"\n"]],[53340,53340],[53339,53339]]],[1543653562064,["gjx16@GJXAIOU",[[-1,53339,"\n"]],[53339,53339],[53338,53338]]],[1543653562589,["gjx16@GJXAIOU",[[-1,53338,"\n"]],[53338,53338],[53337,53337]]],[1543653575849,["gjx16@GJXAIOU",[[-1,51057,"\n"]],[51057,51057],[51056,51056]]],[1543653762670,["gjx16@GJXAIOU",[[-1,49976,"\n"]],[49976,49976],[49975,49975]]],[1543654885641,["gjx16@GJXAIOU",[[-1,50071,"\n"]],[50071,50071],[50070,50070]]],[1543654889873,["gjx16@GJXAIOU",[[-1,50101,"\n"]],[50101,50101],[50100,50100]]],[1543654894213,["gjx16@GJXAIOU",[[-1,50122,"\n"]],[50122,50122],[50121,50121]]],[1543654898871,["gjx16@GJXAIOU",[[-1,50208,"\n"]],[50208,50208],[50207,50207]]],[1543654905736,["gjx16@GJXAIOU",[[-1,50248,"\n"]],[50248,50248],[50247,50247]]],[1543654917756,["gjx16@GJXAIOU",[[-1,50542,"\n"]],[50542,50542],[50541,50541]]],[1543654922584,["gjx16@GJXAIOU",[[-1,50579,"\n"]],[50579,50579],[50578,50578]]],[1543654938728,["gjx16@GJXAIOU",[[-1,50623,"\n"]],[50623,50623],[50622,50622]]]],null,"gjx16@GJXAIOU"],["22c8f8ba-4214-4402-b48a-219eb1c1f145",1543716398889,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁;\n   * c++面向对象模型初探;  \n   * c++面向对象多态原理探究;\n   * 操作符重载;\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;//定义两个对象c1和c2\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n};\n\n```\nTeacher.cpp\n//具体实现函数内容，在函数名前面加上`类名::`\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1:设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)//因为类的成员变量这里都是private:\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n###  (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n###  (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//需要重载=号操作符，才能解决带来的浅拷贝问题\n\n\tobj2 = obj3; //=号操作，也是一种浅拷贝\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++的默认copy构造函数是浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n\n---\n\n\n### （五）多个对象构造和析构\n\n**1.对象初始化列表**\n\n- 1）对象初始化列表出现原因\n程序本身是有问题的\n```cpp\n\n/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B   //在一个类里面组合了一个带有参数的构造函数的类，因为C++编译器要确定分配给B多大的内存，但是没法初始化A定义的两个对象（因为需要调用有参的构造函数）\n{\npublic:   //没有写B的构造函数，按理说应该调用默认的构造函数\n\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  //主要是因为没有方法和没有机会去初始化这两个A定义的对象\n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB;\n\treturn 0;\n\n}\n\n```\n\n解决方法：\n```cpp\n/*\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n};\n\n\nclass B  \n{\npublic:   \n//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）\n\tB(int _a, int _b) : a1(1), a2(3)  \n\t{\n\n\t}\n//第二种参数传递的方法：\n/*\nB(int _a, int _b,int m,int n) : a1(m), a2(n)  \n\t{\n      a = _a;\n      b = _b;\n\t}\n\t\n*/\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  \n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB(1,2);\n\t//第二种方式：B objB(1,2,4,3)\n\treturn 0;\n\n}\n\n```\n\n**以上程序的操作顺序：**\n首先执行被组合对象的构造函数（a1,a2），如果有多个组合对象，则按照定义的顺序，而不是按照初始化列表的顺序（：后面的顺序）\n析构函数：和构造函数的调用顺序相反\n\n  - 1.必须这样做：\n    - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    - 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n  - 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    - 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    - 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n- 2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n```cpp\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n{\n // some other assignment operation\n}\n```\n\n\n- 3）注意概念\n  - 初始化：被初始化的对象正在创建\n  - 赋值：被赋值的对象已经存在\n\n- 4）注意：\n  - 成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n  - 初始化列表先于构造函数的函数体执行\n\n**说明：**\n\n* 1 C++中提供了初始化列表对成员变量进行初始化\n* 2 使用初始化列表出现原因：\n  * 1.必须这样做：\n    * 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n    * 而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    * 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n  * 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    * 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    * 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n```cpp\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n ABC(int a, int b, int c)\n {\n this->a = a;\n this->b = b;\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"ABC construct ..\\n\");\n }\n\n ~ABC()\n {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n }\n\nprotected:\nprivate:\n int a;\n int b;\n int c;\n};\n\nclass MyD\n{\npublic:\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n {\n cout<<\"MyD()\"<<endl;\n }\n\n ~MyD()\n {\n cout<<\"~MyD()\"<<endl;\n }\n\nprotected:\nprivate:\n ABC abc1; //c++编译器不知道如何构造abc1\n ABC abc2;\n const int m;\n};\n\nint run()\n{\n MyD myD;\n return 0;\n}\n\nint main_dem03()\n{\n run();\n system(\"pause\");\n return 0;\n}\n\n```\n\n\n\n\n### （六）构造函数和析构函数的调用顺序研究\n\n**构造函数与析构函数的调用顺序**\n\n- 1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n- 2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n### （七）构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1构造析构综合训练**\n```cpp\n\n/*\n\n总结 构造和析构的调用顺序\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n\tABC(int a, int b, int c)   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\n\t}\n\n\t~ABC()\n\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\n\nclass MyD \n{\npublic:\n\tMyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~MyD()\n\t{\n\t\tcout << \"~MyD()\" << endl;\n\t}\n\n\tMyD(const MyD & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\tcout << \"MyD(const MyD &obj)\" << endl;\n\t}\n\nprotected:\nprivate:\n\tABC abc1; //c++编译器不知道如何构造abc1//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\tABC abc2;\n\tconst int m;//因为是const m,所以上面所有的m都进行了赋值\n};\n\n\nint doThing(MyD myel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;\n}\n\n\nint run2()//二\n{\n\tMyD myD;//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\treturn 0;\n}\n\nint run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main()\n{\n\trun2();//一\n\t//run3();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n\n\n```\n\n\n**2匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3匿名对象强化训练**\n\n3） 构造中调用构造\n\n```cpp\n/*\n\n构造中调用构造\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass MyTest\n{\npublic:\n\tMyTest(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t}\n\n\tMyTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\n\t\tMyTest(a, b, 10);\n\t}\n\n\t~MyTest()\n\t{\n\t\tcout << \"MyTest is ...\" << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n\n\npublic:\n\tint getC() const { return c; }\n\n\tvoid setC(int val) { c = val; }\n};\n\nint main()\n{\n\tMyTest t1(1, 2);\n\tcout << t1.getC() << endl;\n\tsystem(\"pause\");\n\treturn 0;\n\t\n}\n\n\n```\n\n 结论： 构造函数中调用构造函数，是一个蹩脚的行为。\n程序内存图：\n![搜狗截图20181124125452]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181124125452.png)\n\n### （八）对象的动态建立和释放\n\n**1.new和delete基本语法**\n```cpp\n/*\n\nnew 和delete的使用\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nvoid main()\n{\n\t//先分配内存然后赋值\n\tint *p = new int;  //分配基础类型\n\t*p = 20;  \n\n\t//在定义的时候直接分配内存\n\tint *p1 = new int(30);\n\tcout << *p1 << endl;\n\n\tsystem(\"pause\");\n\treturn; \n}\n\n```\n\n- 1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n  **注意： new和delete是运算符，不是函数，因此执行效率高。**\n\n- 2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： \nnew int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 \nnew char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址    new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n- 3）new和delete运算符使用的一般格式为：\n  用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n![new运算符动态]($resource/new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%A8%E6%80%81.png)\n```cpp\n\n/*\n使用malloc /free 与new /delete的区别\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest();\n\t~Test();\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\nTest::Test()\n{\n\tcout << \"执行了构造函数\" << endl;\n}\n\nTest::~Test()\n{\n\tcout << \"执行了析构函数\" << endl;\n}\n\n\n\nint main()\n{\n\t//基础类型\n\tint *p1 = (int *)malloc(sizeof(int));\n\t*p1 = 10;\n\tdelete p1;\n\n\tint *p2 = new int;\n\t*p2 = 20;\n\tfree(p2);\n\n\n\n\t//数组类型（元素为基础类型）\n\tint *p3 = (int *)malloc(sizeof(int)*10);\n\tp3[0] = 1;\n\tdelete[]p3;\n\n\tint *p4 = new int[10];\n\tp4[1] = 2;\n\tfree(p4);\n\n\n\t//类\n\tTest *p5 = (Test *)malloc(sizeof(Test));\n\tdelete p5;\n\n\tTest *p6 = new Test(10);\n\tfree(p6);\n}\n\n\n```\n**结论：** \nnew：不仅分配内存，而且调用了构造函数\ndelete:不仅释放了内存，而且调用了析构函数\n\n- 4） 应用举例\n\n![5]($resource/5.png)\n\n**2类对象的动态建立和释放**\n\n- 使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n-  C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n  比如：\n\n  Box *pt;  //定义一个指向Box类对象的指针变量pt\n      pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n   这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n  新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n   在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3.编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n\n\n\n## 四、静态成员变量和成员函数\n\n\n思考：每个变量，拥有属性。有没有一些属性，归所有对象拥有？\n\n### （一）静态成员变量\n\n- **1定义静态成员变量**\n  - 关键字 **static**  可以用于说明一个类的成员，\n    静态成员提供了一个同类对象的共享机制\n\n  - 把一个类的成员说明为 **static**  时，这个类无论有多少个对象被创建，这些对象共享这个 **static**  成员\n\n  - 静态成员局部于类，它不是对象成员\n\n![1]($resource/1.png)\n\n例如：\n\n```cpp\n\n/*\n静态成员变量\n*/\n\n#include<iostream>\nusing namespace std;\n\nclass counter\n{\n\n\tstatic int num; //**声明与定义静态数据成员**\n\npublic:\n\n\tvoid setnum(int i) \n\t{ \n\t\tnum = i; \n\t} //成员函数访问静态数据成员\n\n\tvoid shownum() \n\t{ \n\t\tcout << num << endl;\n\t}\n\n};\n\nint counter::num = 0;//声明与定义静态数据成员\n\nvoid main()\n{\n\tcounter a, b;\n\n\ta.shownum(); //调用成员函数访问私有静态数据成员\n\tb.shownum();\n\ta.setnum(10);\n\ta.shownum();\n\tb.shownum();\n\n}\n\n```\n\n![6]($resource/6.png)\n\n**从结果可以看出，访问的是同一个静态数据成员**\n\n- **2使用静态成员变量**\n```cpp\n//例5-14_使用公有静态数据成员\n\n#include<iostream.h>\n\nclass counter\n{ \npublic :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n\n```\n使用静态成员函数调用静态成员变量\n```cpp\n/*\n静态成员函数\n*/\n// 结论：在静态成员函数中可以使用静态成员变量，但是不能使用类中普通的成员变量\n\n#include\"iostream\"\nusing namespace std;\n\nclass BB\n{\npublic:\n\tint printC()\n\t{\n\t\tcout << \"c:\" << c << endl;\n\t\treturn c;\n\t}\n\n\tint addC()\n\t{\n\t\tc = c+1;\n\t}\n\n\n\tstatic void getC()\n\t{\n\t\tcout << \"c\" << c << endl;  //可以直接在静态成员函数中使用静态成员变量，但是不能直接使用一般变量\n\t}\nprivate:\n\tint a;\n\tint b;\n\tstatic int c;\n\n};\n\n\nint BB::c = 10;  //初始化成员变量值\n\nvoid main()\n{\n\tBB b1, b2, b3;\n\tb1.printC();//10\n\tb2.addC();//11\n\tb3.printC();//11\n\n\t//调用成员函数两种方法；\n\tb3.getC();//使用对象.\n\tBB::getC();//使用类::\n\n\n\n}\n\n```\n\n### (二)静态成员函数\n\n- **1）概念**\n\n  - 静态成员函数数冠以关键字static\n\n  - 静态成员函数提供不依赖于类数据结构的共同操作，它没有this指针\n  - 在类外调用静态成员函数用 `_类名_ ::`作限定词，或通过对象调用\n\n- **2）案例**\n![7]($resource/7.png)\n\n- **3）疑难问题：**\n静态成员函数中，不能使用普通变量。\n//静态成员变量属于整个类的，分不清楚，是那个具体对象的属性。\n![成员函数中的疑难问题]($resource/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98.png)\n\n**4.3 综合训练**\n\n\n\n## 五、 C++面向对象模型初探\n\n**前言**\n\n- C++对象模型可以概括为以下2部分：\n\n  - 1. 语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等等。\n\n  - 2. 对于各种支持的底层实现机制。\n\n  在c语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。在c++中，通过抽象数据类型（abstract data type，ADT），在类中定义数据和函数，来实现数据和函数直接的绑定。\n\n  概括来说，在C++类中有两种成员数据：static、nonstatic；三种成员函数：static、nonstatic、virtual。\n\n![C++类的组成]($resource/C++%E7%B1%BB%E7%9A%84%E7%BB%84%E6%88%90.png)\n\n### （一）基础知识\n\nC++中的class从面向对象理论出发，将变量(属性)和函数(方法)集中定义在一起，用于描述现实世界中的类。从计算机的角度，程序依然由数据段和代码段构成。\n\n**C++编译器如何完成面向对象理论到计算机程序的转化？**\n换句话：C++编译器是如何管理类、对象、类和对象之间的关系\n具体的说：具体对象调用类中的方法，那，c++编译器是如何区分，是那个具体的类，调用这个方法那?\n\n思考一下程序结果\n```cpp\n/*\n面向对象模型初探\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass C1\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\nprotected:\n\nprivate:\n\n}; //12\n\nclass C2\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\n\tstatic int m; \n\npublic:\n\n\tint getK() const { return k; } //方法是属于代码，应该放在代码区\n\tvoid setK(int val) { k = val; } \n\nprotected:\n\nprivate:\n}; \n\nstruct S1\n{\n\tint i;\n\tint j;\n\tint k;\n}; \n\nstruct S2\n{\n\tint i;\n\tint j;\n\tint k;\n\tstatic int m;\n}; \n\nint main()\n{\n\n\tprintf(\"c1:%d \\n\", sizeof(C1));\n\tprintf(\"c2:%d \\n\", sizeof(C2));\n\tprintf(\"s1:%d \\n\", sizeof(S1));\n\tprintf(\"s2:%d \\n\", sizeof(S2));\n\tsystem(\"pause\");\n\n}\n```\n程序运行结果：\n`c1:12`\n`c2:12`\n`s1:12`\n`s2:12`\n\n \n### (二)编译器对属性和方法的处理机制\n\n通过上面的案例，我们可以的得出：\n1）C++类对象中的成员变量和成员函数是分开存储的\n- 成员变量：\n  - 普通成员变量：存储于对象中，与struct变量有相同的内存布局和字节对齐方式\n  - 静态成员变量：存储于全局数据区中\n\n- 成员函数：存储于代码段中。\n问题出来了：很多对象共用一块代码？代码是如何区分具体对象的那？\n换句话说：int getK() const { return k; }，代码是如何区分，具体obj1、obj2、obj3对象的k值？\n\n2）C++编译器对普通成员函数的内部处理\n\n![C++编译器对普通成员函数的内部处理]($resource/C++%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E9%83%A8%E5%A4%84%E7%90%86.png)\n\n请仔细思考，并说出你的总结！\n\n\n\n### （三）总结\n\n1、C++类对象中的成员变量和成员函数是分开存储的。C语言中的内存四区模型仍然有效！\n**2、C++中类的普通成员函数都隐式包含一个指向当前对象的this指针。**\n3、静态成员函数、成员变量属于类\n\n静态成员函数与普通成员函数的区别\n\n静态成员函数不包含指向具体对象的指针\n\n普通成员函数包含一个指向具体对象的指针\n\n\n### （四）this指针\n\n![this指针图示]($resource/this%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png)\n\n实验1：若类成员函数的形参 和 类的属性（成员变量）名字相同，通过this指针来解决。\n```cpp\n\n/*\nthis 指针\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass Test\n{\npublic:\n\tTest( int a, int b)//Test(Test *this, int a, int b)//因为这里成员函数的形参和成员变量一样，不用this指针会出现：a = a ,b = b;\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printT()\n\t{\n\t\tcout << \"a; \" << a << endl;\n\t\tcout << \"b: \" << this->b << endl;\n\t}\n\n\n    const void hello(int a,int b )\n    {\n      //下面这两个语句都是错误的\n      this->a = 100;\n      this ->b = 200;\n    }\n   //const修饰的this指针，即相当于this指针指向的内存空间不能被修改\n   //因为上面的函数会别C++编译器解析为:void hello(const Test *this, int a ,int b)\n   //同时上面的const其实下载函数（）外面的任何位置都行\n   \nprotected:\nprivate:\n\tint a;\n\tint b;\n};\nint  main()\n{\n\tTest t1(1, 2);\n\tt1.printT();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`a:1`\n`b:2`\n\n\n实验2：类的成员函数可通过const修饰，请问const修饰的是谁\n\n\n### （五）全局函数PK成员函数\n\n 1、把全局函数转化成成员函数，通过this指针隐藏左操作数\n\n   Test add(Test &t1, Test &t2)===》Test add( Test &t2)\n```cpp\n/*\n全局函数与成员函数\n*/\n\n\n//使用全局函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\t\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nTest Testadd(Test &t1, Test &t2)\n{\n\tTest tmp(3,4);\n\treturn tmp;\n}\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3(2, 3);\n\tt3= Testadd(t1, t2);\n}\n```\n\n```cpp\n//使用成员函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\tTest Testadd(Test &t2)\n\t{\n\t\tTest tmp(this->a + t2.a, this->b + t2.b);\n\t\treturn tmp;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3 = t1.Testadd(t2);//匿名对象直接转化成t4\n\tTest t4(3,5);\n\tt4 = t1.Testadd(t2);  //匿名对象复制给t5\n}\n\n\n```\n 2、把成员函数转换成全局函数，多了一个参数\n\n   void printAB()===》void printAB(Test *pthis)\n\n 3、函数返回元素和返回引用\n```cpp\nTest& add(Test &t2) //*this //函数返回引用,相当于返回自身，谁调用返回谁\n {      \n   this->a = this->a + t2.getA();\n\n   this->b = this->b + t2.getB();\n\n   return *this; //*操作让this指针回到元素状态\n\n }\n\nTest add2(Test &t2) //*this //函数返回元素\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n return t3;\n\n }\n\n void add3(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n //return t3;\n\n }\n  \n\n```\n\n\n\n\n---\n\n## 六、友元\n\n### （一）友元函数\n- 首先友元函数是全局函数，在友元函数中可以修改类的私有属性；\n- 友元函数在类中的声明位置位于public或者private只下均可；\n![8]($resource/8.png)\n\n```cpp\n//友元函数：\n\n#include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend void modify(A *PA,int _a);  //友元函数的声明\n\n\tA(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\n\nprivate:\n\tint a;\n\tint b;\n};\n\nvoid modify(A *PA,int _a)//后面的参数可加可不加\n{\n\t//PA->a = 100;//可以这样直接修改值\n\tPA->a = _a;  //通过传递的值进行修改\n}\n\n\nint main()\n{\n\tA a1(1, 2);\n\tcout << \"a:\" << a1.getA() << endl;\n\tmodify(&a1,20);\n\n\tint aa = a1.getA();\n\n\tcout << \"aa:\" << aa << endl;\n}\n```\n![9]($resource/9.png)\n\n\n### （二）友元类\n\n- 若B类是A类的友员类，则B类的所有成员函数都是A类的友员函数\n- 若B类是A类的友元类，则B类可以直接修改A的成员变量和成员函数\n- 友员类通常设计为一种对数据操作或类之间传递消息的辅助类\n程序示例：\n```cpp\n//友元类\n #include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend class B;//将B 声明为A的友元类，这样B 可以直接修改A的成员变量和成员函数 \n\n\tA(int a=0, int b=0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B\n{\npublic:\n\n\tvoid set(int a)\n\t{\n\t\tobjA.a = a;\n\t}\n\n\tvoid printa()\n\t{\n\t\tcout << objA.a << endl;\n\t}\n\nprivate:\n\tA objA;\n};\n\n\nint main()\n{\n\tB b1;\n\tb1.set(200);\n\tb1.printa();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：200\n\n![10]($resource/10.png)\n\n\n\n## 七、强化训练\n\n**1 static关键字强化训练题**\n\n某商店经销一种货物。货物购进和卖出时以箱为单位，各箱的重量不一样，因此，商店需要记录目前库存的总重量。现在用C++模拟商店货物购进和卖出的情况。\n```cpp\n#include \"iostream\"\nusing namespace std;\n\nclass Goods\n{\npublic:\n\n\tGoods(int w) { weight = w; total_weight += w; }\n\n\t~Goods() { total_weight -= weight; }\n\n\tint Weight() { return weight; };\n\n\tstatic int TotalWeight() { return total_weight; }\n\n\tGoods *next;\n\nprivate:\n\n\tint weight;\n\tstatic int total_weight;\n\n};\n\nint Goods::total_weight = 0;\n\n//r尾部指针\n\nvoid purchase(Goods * &f, Goods *& r, int w)\n{\n\n\tGoods *p = new Goods(w);\n\n\tp->next = NULL;\n\n\tif (f == NULL) f = r = p;\n\n\telse { r->next = p; r = r->next; } //尾部指针下移或新结点变成尾部结点\n\n}\n\nvoid sale(Goods * & f, Goods * & r)\n{\n\n\tif (f == NULL) { cout << \"No any goods!\\n\"; return; }\n\n\tGoods *q = f; f = f->next; delete q;\n\n\tcout << \"saled.\\n\";\n\n}\n\nvoid main()\n{\n\tGoods * front = NULL, *rear = NULL;\n\n\tint w; int choice;\n\n\tdo\n\t{\n\t\tcout << \"Please choice:\\n\";\n\n\t\tcout << \"Key in 1 is purchase,\\nKey in 2 is sale,\\nKey in 0 is over.\\n\";\n\n\t\tcin >> choice;\n\n\t\tswitch (choice) // 操作选择\n\t\t{\n\t\tcase 1: // 键入1，购进1箱货物\n\t\t{ cout << \"Input weight: \";\n\t\tcin >> w;\n\n\t\tpurchase(front, rear, w); // 从表尾插入1个结点\n\n\t\tbreak;\n\t\t}\n\n\t\tcase 2:              // 键入2，售出1箱货物\n\t\t{ sale(front, rear); break; } // 从表头删除1个结点\n\n\t\tcase 0: break;              // 键入0，结束\n\t\t}\n\n\t\tcout << \"Now total weight is:\" << Goods::TotalWeight() << endl;\n\n\t} while (choice);\n}\n```\n**2** **数组类封装**\n\n目标：解决实际问题，训练构造函数、copy构造函数等，为操作符重载做准备\n\n数组类的头文件:`Array.h`\n```cpp\n#pragma once\nclass Array\n{\npublic:\n\tArray(int length);\n\tArray(const Array&obj);\n\t~Array();\npublic:\n\tint length();\n\n\tvoid setData(int index, int value);\n\n\tint getData(int index);\nprivate:\n\tint m_length;\n\tchar *m_space;\n};\n```\n\n数组类的头文件的实现：`Array.cpp`\n```cppp\n#include \"Array.h\"\nusing namespace std;\n#include\"iostream\"\n\nArray::Array(int length)\n{\n\tif (length < 0)\n\t{\n\t\tlength = 0;\n\t}\n\telse\n\t{\n\t\tm_length = length;\n\t\tm_space = new char[m_length];\n\t}\n}\n\nArray::Array(const Array&obj)\n{\n   this->m_length = obj.m_length;\n   this->m_space = new char [this->m_length];//进行分配内存空间\n\n  for(int i= 0; i < obj.m_length;i++)//数组元素复制， 这里的obj.m_length可以直接替换成m_length\n  {\n    this->m_space[i] = obj.m_space[i];\n  }\n}\n\nArray::~Array()\n{\n\tif (m_space != NULL)\n\t{\n\t\tdelete[] m_space;\n\t\tm_length = 0;\n\t}\n}\n\nvoid Array::setData(int index, int valude)\n{\n\tm_space[index] = valude;\n}\n\nint Array::getData(int index)\n{\n\treturn m_space[index];\n}\n\nint Array::length()\n{\n\treturn m_length; \n}\n```\n\n数组类的测试\n```cpp\n#include \"iostream\"\n#include \"Array.h\"\nusing namespace std;\n\nint main()\n{\n\tArray a1(10);\n\tfor (int i = 0; i < a1.length(); i++)\n\t{\n\t\ta1.setData(i, i);\n\t}\n\tfor (int i = 0; i <  a1.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a1.getData(i));\n\t}\n\n\tArray a2 = a1;\n\n\tfor (int i = 0; i < a2.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a2.getData(i));\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**3.小结**\n\n* 类通常用关键字class定义。类是数据成员和成员函数的封装。类的实例称为对象。\n* 结构类型用关键字struct定义，是由不同类型数据组成的数据类型。\n* 类成员由private, protected, public决定访问特性。public成员集称为接口。\n* 构造函数在创建和初始化对象时自动调用。析构函数则在对象作用域结束时自动调用。\n* 重载构造函数和复制构造函数提供了创建对象的不同初始化方式。\n* 静态成员是局部于类的成员，提供一种同类对象的共享机制。\n* 友员用关键字friend声明。友员是对类操作的一种辅助手段。一个类的友员可以访问该类各种性质的成员\n* 链表是一种重要的动态数据结构，可以在程序运行时创建或撤消数据元素。\n\n\n\n---\n\n\n## 八、运算符重载\n\n### （一）概念\n\n#### **1.什么是运算符重载**\n\n![11]($resource/11.png)\n所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是”一名多用”。\n\n运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重载。例如，大 家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行加法运算，如5+8， 5.8 +3.67等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的， 但由于C++已经对运算符”+”进行了重载，所以就能适用于int, float, doUble类型的运算。\n\n又如`<<`是C的位运算中的位移运算符（左移），但在输出操作中又是与流对 象cout 配合使用的流插入运算符，`>>`也是位移运算符(右移），但在输入操作中又是与流对象 cin 配合使用的流提取运算符。这就是运算符重载(operator overloading)。C系统对`<<`和`>>`进行了重载，用户在不同的场合下使用它们时，作用是不同 的。对`<<`和`>>`的重载处理是放在头文件stream中的。因此，如果要在程序中用`<<`和`>>`作流插入运算符和流提取运算符，必须在本文件模块中包含头文件stream(当然还应当包括”using namespace std“)。\n\n现在要讨论的问题是：用户能否根据自己的需要对C++已提供的运算符进行重载，赋予它们新的含义，使之一名多用？\n\n#### **2.运算符重载入门技术推演**\n\n1为什么会用运算符重载机制\n//原因 Complex是用户自定义类型，编译器根本不知道如何进行加减，但是编译器给提供了一种机制，让用户自己去完成，自定义类型的加减操作。。。这个机制就是运算符重载机制\n\n用复数类举例，定义一个Complex类,有两个对象，每个对象由两个属性，要求使用对象之间的加法实现对应属性的相加，示例程序如下：\n```cpp\n\n/*对于基础数据类型，C++编译器知道如何进行运算，但是对于用户自定义的类型编译器提供了一种\n让自定义数据类型进行运算符操作的机制,=》运算符重载机制\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\npublic:\n\tfriend Complex operator+(Complex &c1, Complex &c2);//友元函数声明\n\n\tComplex(int a = 0, int b = 0)//构造函数\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\nprivate:\n  int a;\n  int b;\n};\n\n/*使用全局函数，通过调用全局函数实现\nComplex myAdd(Complex &c1, Complex &c2)\n{\n Complex tmp(c1.a+ c2.a, c1.b + c2.b);\n\n return tmp;\n}\n*/\n\n\n//可以简单的想象为将上面全局函数的函数名替换为operator+\nComplex operator+(Complex &c1, Complex &c2)\n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\treturn tmp;\n}\n\n\n\nint  main()\n{\n\tComplex c1(1, 2), c2(3, 4);\n\n\t//方法1： 通过调用普通函数实现\n\t//Complex c3 = myAdd(c1, c2);\n\t//c3.printCom();\n\n\n\t//方法2  将函数名称替换为：operator+ \n\t//使用以下方式进行调用\n\t//Complex c3 = operator+(c1, c2);\n\t//c3.printCom();\n\n\n\t//方法3：最常用的调用方式\n\tComplex c3 = c1 + c2; \n\tc3.printCom()\n\n\tsystem(\"pause\");\n\treturn;\n}\n```\n程序运行结果：`4+6i`\n\n\n---\n\n### （二）运算符重载的限制\n![12]($resource/12.png)\n\n重载运算符函数可以对运算符进行新的解释，但是原有的基本语义不变：\n* 不改变运算符的优先级\n* 不改变运算符的结合性\n* 不改变运算符所需要的操作数\n* 不能创建新的运算符\n\n---\n\n### （三）运算符重载编程基础\n![14]($resource/14.png)\n例如:\n   //全局函数  完成 +操作符  重载  \n    Complex operator+(Complex &c1, Complex &c2)\n\n  //类成员函数  完成 -操作符  重载\n    Complex operator-(Complex &c2)\n\n#### **1.运算符重载的两种方法:**\n- 运算符可以重载为成员函数了或者友元函数\n- 关键区别在于成员函数具有this指针，友元函数没有this 指针\n- 不管是成员函数还是友元函数重载，运算符的使用方法相同\n- 但是两种的传递参数不同，实现代码也不同，应用场合也不同\n\n- **二元操作符重载的实现：**\n![16]($resource/16.png)\n \n```cpp\n//二元函数操作符的重载的两种方法\n\n\n/*全局函数、类成员函数方法实现运算符重载步骤\n1）要承认操作符重载是一个函数，写出函数名称operator + ()\n2）根据操作数，写出函数参数\n3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex operator+(Complex &c1, Complex &c2); //这里是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\t//成员函数实现 - 运算符重载 \n\tComplex operator-(Complex &c2)//因为是c1调用的，因此这里的this 指向c1\n\t{\n\t\tComplex tmp(this->a - c2.a, this->b -  c2.b);//通过构造函数实现 tmp中成员变量的变化 \n\t\treturn tmp;\n\t}\n\n};\n\n\n//使用全局函数实现  + 运算符重载\nComplex operator+(Complex &c1, Complex &c2)\n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\n\treturn tmp;\n}\n\n\nint  main()\n{\n\tComplex c1(1, 2), c2(3, 4);\n\n\t//使用 全局函数\n\tComplex c3 = c1 + c2;\n\tc3.printCom();\n\n\t//使用成员函数\n\tComplex c4 = c1.operator-(c2);\n\tc4.printCom();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`4 + 6i`\n`-2 + -2i`\n\n\n- **一元函数操作符重载的实现：**\n![17]($resource/17.png)\n\n- 实现前置++和前置--\n```cpp\n//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现前置++和前置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex& operator++(Complex &c1); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\tComplex& operator--()\n\t{\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn *this;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  + 运算符重载\nComplex& operator++(Complex &c1)\n{\n\tc1.a++;\n\tc1.b++;\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1,c2;\n\n\t//使用全局函数实现前置++操作符的重置\n\t++c1;\n\tc1.printCom();\n\n\n\t//使用成员函数实现前置--操作符的重置\n\t--c2;\n\tc2.printCom();\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`1 + 1i`\n`-1 + -1i`\n\n- 实现后置++和后置--\n```cpp\n//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现后置++ 和后置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex operator++(Complex &c1, int); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\t//成员函数实现后置--\n\tComplex operator--(int)\n\t{\n\t\tComplex tmp = *this;\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn tmp;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  ++ 运算符重载\nComplex operator++(Complex &c1,int)  //为了和前置++的函数能够共同存在，参数中加了一个占位符从而实现函数重载\n{\n\t//前置++是先使用后++ ，所以应该先返回c1,但是直接使用return c1.会造成程序的直接退出，后面的++无法实现，所以使用临时变量\n\n\tComplex tmp = c1;\n\tc1.a++;\n\tc1.b++;\n\treturn tmp;\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1, c2;\n\t//使用全局函数实现后置++操作符的重置\n\tc1++;\n\tc1.printCom();\n\n\t//使用成员函数实现后置--操作符的重置\n\tc2--;\n\tc2.printCom();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n\n**前置和后置运算符总结:**\n\nC++中通过一个占位参数来区分前置运算和后置运算\n![18]($resource/18.png)\n\n\n\n#### **2.定义运算符重载函数名的步骤**\n全局函数、类成员函数方法实现运算符重载步骤\n * 1）要承认操作符重载是一个函数，写出函数名称operator+ ()\n * 2）根据操作数，写出函数参数\n * 3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n\n#### **3.友元函数实现操作符重载的应用场景**\n\n**1）友元函数和成员函数选择方法**\n- 当无法修改左操作数的类时，使用全局函数进行重载,因为成员函数需要在左边的类中进行修改；\n- =, [], ()和->操作符只能通过成员函数进行重载\n\n**2）用友元函数重载 <<和 >>操作符**\n\n* istream 和 ostream 是 C++ 的预定义流类，都不让修改的222222222222222222222222222222222222222222222\n* cin 是 istream 的对象，cout 是 ostream 的对象\n* 运算符 << 由ostream 重载为插入操作，用于输出基本类型数据\n* 运算符 >> 由 istream 重载为提取操作，用于输入基本类型数据\n* 用友员函数重载 << 和 >> ，输出和输入用户自定义的数据类型\n\na）用全局函数方法实现 << 操作符\n```pp\n//实现<<运算符的重载\n\n//注释内部是一套完整的程序，但是只能实现一次打印输出，新的一套程序可以实现链式输出\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\t//friend  void operator<<(ostream &cout, Complex &c1); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n};\n\n/*这里类似于cout只能有全局函数加上友元函数实现，因为如果要使用成员函数实现，需要在cout 的类：ostream中定义成员函数，\n但是这个ostream类是系统隐藏的，不现实；\nvoid operator<<(ostream &cout, Complex &c1)\n{\n\tcout << c1.a << \" + \" << c1.b << \"i\" << endl;\n}\n*/\n\nostream& operator<<(ostream &cout, Complex &c2)  //要想实现函数返回值当左值，需要返回一个引用\n{\n\tcout << c2.a << \" + \" << c2.b << \"i\" << endl;\n\treturn cout;\n}\n\n\n \nint  main()\n{\n\tComplex c1, c2;\n\t//cout << c1;  //实现将c1中两个元素以a+bi的形式直接打印输出；\n\t/*\n\t首先承认运算符重载是函数，所以函数名为：operator<<\n\t其次因为有左右参数，分别为ostream 和Complex类，所有函数头为：operator<<(ostream&cout,Complex c1)\n\t然后根据返回值确定最前面的返回值类型\n\t*/\n\n\tcout << c2 << \"kdjfkdjfkd\";\n\t//因为<<操作符是从左到右，所以左边执行返回值要当左值再次执行这个函数\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n**3）友元函数重载操作符使用注意点**\n\n- a） 友员函数重载运算符常用于运算符的左右操作数类型不同的情况\n![19]($resource/19.png)\n- b）其他\n  - 在第一个参数需要隐式转换的情形下，使用友员函数重载运算符是正确的选择\n  - 友员函数没有 this 指针，所需操作数都必须在参数表显式声明，很容易实现类型的隐式转换\n  - C++中不能用友员函数重载的运算符有\n     = （）  ［］  －>\n\n**4）友元函数案例vector类**\n```cpp\n#include <iostream>\nusing namespace std;\n\n//为vector类重载流插入运算符和提取运算符\n\nclass vector\n{\npublic:\n\tvector(int size = 1);\n\n\t~vector();\n\n\tint & operator[](int i);\n\n\tfriend ostream & operator << (ostream & output, vector &);\n\n\tfriend istream & operator >> (istream & input, vector &);\n\nprivate:\n\tint * v;\n\n\tint len;\n\n};\n\nvector::vector(int size)\n{\n\tif (size <= 0 || size > 100)\n\t{\n\t\tcout << \"The size of \" << size << \" is null !\\n\"; abort();\n\t}\n\n\tv = new int[size]; len = size;\n}\n\nvector :: ~vector()\n{\n\tdelete[] v;\n\n\tlen = 0;\n}\n\nint &vector::operator[](int i)\n{\n\tif (i >= 0 && i < len) return v[i];\n\n\tcout << \"The subscript \" << i << \" is outside !\\n\"; abort();\n}\n\nostream & operator << (ostream & output, vector & ary)\n{\n\tfor (int i = 0; i < ary.len; i++)\n\t\toutput << ary[i] << \" \";\n\n\toutput << endl;\n\treturn output;\n}\n\nistream & operator >> (istream & input, vector & ary)\n{\n\tfor (int i = 0; i < ary.len; i++)\n\t\tinput >> ary[i];\n\n\treturn input;\n}\n\nvoid main()\n{\n\tint k;\n\tcout << \"Input the length of vector A :\\n\";\n\tcin >> k;\n\tvector A(k);\n\tcout << \"Input the elements of vector A :\\n\";\n\tcin >> A;\n\tcout << \"Output the elements of vector A :\\n\";\n\tcout << A;\n\tsystem(\"pause\");\n}\n\n```\n\n### （四）运算符重载提高\n\n#### **1.运算符重载机制**\n\nC++编译器是如何支持操作符重载机制的?\n\n#### **2.重载赋值运算符=**\n\n* 赋值运算符重载用于对象数据的复制\n* operator= 必须重载为成员函数\n* 重载函数原型为：\n  类型&类名:: operator= ( const  类名 & ) ;\n\n案例：完善Name类，支持=号操作。\n![22]($resource/22.png)\n\n  结论:\n 1 先释放旧的内存\n 2 返回一个引用\n 3 =操作符 从右向左\n```cpp\n//重载 = 操作符\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\t//obj3 = obj1; // C++编译器提供的  等号操作  也属  浅拷贝\\\n\t// obj4 = obj3 = obj1\n\t//obj3.operator=(obj1)\n\n\tName& operator=(Name &obj1)\n\t{\n\t\t//1 先释放obj3旧的内存\n\n\t\tif (this->pName != NULL)\n\t\t{\n\t\t\tdelete[] pName;\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\t//2 根据obj1分配内存大小\n\n\t\tthis->size = obj1.size;\n\t\tthis->pName = new char[size + 1];\n\n\t\t//3把obj1赋值给obj3\n\n\t\tstrcpy(pName, obj1.pName);\n\t\treturn *this;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nint main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n\n#### **3.重载数组下表运算符[]** ==这里的视频再看一遍==\n- 重载[]和()运算符\n  - 运算符 [] 和 () 是二元运算符\n  - [] 和 () 只能用成员函数重载，不能用友元函数重载\n\n- 重载下标运算符 []\n  - [] 运算符用于访问数据对象的元素\n  重载格式：  返回值类型 类 :: operator[] ( 类型 ) ；\n  设 x 是类 X 的一个对象，则表达式 `x[y]` 可被解释为  `x.operator[](y)`\n\n![33]($resource/33.png)\n![44]($resource/44.png)\n\n\n#### **4.重载函数调用符()**\n\n() 运算符用于函数调用\n\n重载格式:  返回值类型 类:: operator() ( 表达式表 ) ；\n\n例1\n设 x是类 X的一个对象，则表达式*\nx ( arg1, arg2, … )\n可被解释为\nx . operator () (arg1, arg2, … )\n\n**案例：**\n例2：用重载()运算符实现数学函数的抽象\n```cpp\n\n#include <iostream>\n\nclass F\n\n { public :\n\n double operator ( )  ( double x , double y ) ;\n\n } ;\n\ndouble F :: operator ( )  ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\nf.getA();\n\n cout << f ( 5.2 , 2.5 ) << endl ; // **f . _operator()_ (5.2, 2.5)**\n\n}\n```\n比较普通成员函数\n\n**//例3用重载()运算符实现 pk成员函数**\n```cpp\n#include <iostream.h>\n\nclass F\n\n { public :\n\n double memFun ( double x , double y ) ;\n\n } ;\n\ndouble F :: memFun ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\n cout << f.memFun ( 5.2 , 2.5 ) << endl ;\n\n}\n```\n\n#### **5.为什么不要重载&&和||操作符**\n\n- 理论知识：\n  - 1）&&和||是C++中非常特殊的操作符\n  - 2）&&和||内置实现了短路规则\n  - 3）操作符重载是靠函数重载来完成的\n  - 4）操作数作为函数参数传递\n  - 5）C++的函数参数都会被求值，无法实现短路规则\n```cpp\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nclass Test\n{\n\tint i;\npublic:\n\tTest(int i)\n\t{\n\t\tthis->i = i;\n\t}\n\n\tTest operator+ (const Test& obj)\n\t{\n\t\tTest ret(0);\n\t\tcout << \"执行+号重载函数\" << endl;\n\t\tret.i = i + obj.i;\n\t\treturn ret;\n\t}\n\n\tbool operator&& (const Test& obj)\n\t{\n\t\tcout << \"执行&&重载函数\" << endl;\n\t\treturn i && obj.i;\n\t}\n\n};\n\n// && 从左向右\nint  main()\n{\n\tint a1 = 0;\n\tint a2 = 1;\n\tcout << \"注意：&&操作符的结合顺序是从左向右\" << endl;\n\n\tif (a1 && (a1 + a2))\n\t{\n\t\tcout << \"有一个是假，则不在执行下一个表达式的计算\" << endl;\n\t}\n\n\tTest t1 = 0;\n\tTest t2 = 1;\n\n\tif(t1 && (t1 + t2))\n\t{\n\t\tt1.operator&&(t1 + t2);\n\t\tt1.operator&&(t1.operator+(t2));\n\n\t\t\t//t1 && t1.operator+(t2)\n\t\t\t// t1.operator( t1.operator(t2) )\n\t\t\tcout << \"两个函数都被执行了，而且是先执行了+\" << endl;\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`注意：&&操作符的结合顺序是从左向右`\n`执行+号重载函数`\n`执行&&重载函数`\n\n\n### （五）运算符重载在项目开发中的应用\n\n#### **1实现一个数组类**\n添加<< >>\n#### **2实现一个字符串类**\n\n构造函数要求\n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串类 以零结尾的字符串\n\n//若len为0,表示空串\n```cpp\nMyString a; //空串 “”\nMyString a(“dddd”);\nMyString b = a;\nb = “aaaaaa” \nb = a;\n\nif (a > b)\nif (a == b)\nb[i] = ‘a’;\n```\n常用的操作符\n\n<< >> != == > < =\n\n```cpp\n//C语言中没有字符串这种类型，是通过数组来模拟字符串\n//C++中 我们来设计一个字符串 以零结尾的字符串\n\nclass MyString\n{\n friend ostream& operator<<(ostream &out, const MyString &s);\n\npublic: //构造和析构\n MyString(int len = 0);\n MyString(const char *p);\n MyString(const MyString& obj);\n ~MyString();\n\npublic: //操作符重载\n MyString& operator=(const char *p);\n MyString& operator=(const MyString& obj);\n char& operator[](int index) const;\n\npublic:\n bool operator==(const char* p) const;\n bool operator!=(const char* p) const;\n bool operator==(const MyString& s) const;\n bool operator!=(const MyString& s) const;\n\npublic: //string to c\n char *c_str();\n const char* c_str() const;\n int length()\n {\n   return m_len;\n }\n\npublic:\n int operator<(const char *p);\n int operator>(const char *p);\n int operator<(const MyString &s);\n int operator>(const MyString &s);\nprivate:\n int m_len;\n char *m_p;\n};\n\n```\n\n\n#### **3智能指针类编写**\n\n1问题抛出\n  指针使用过程中，经常会出现内存泄漏和内存多次被释放常\n\n2解决方案：例如：boost库的智能指针\n  项目开发中，要求开发者使用预先编写的智能指针类对象代替C语言中的原生指针\n\n3智能指针思想\n  工程中的智能指针是一个类模板\n  通过构造函数接管申请的内存\n  通过析构函数确保堆内存被及时释放\n  通过重载指针运算符* 和 -> 来模拟指针的行为\n  通过重载比较运算符 == 和 != 来模拟指针的比较\n\n```cpp\nclass Test\n{\npublic:\n Test()\n {\n   this->a = 10;\n }\n\n void printT()\n {\n   cout<<a<<endl;\n }\n\nprivate:\n int a;\n};\n\nclass MyTestPointer\n{\npublic:\n\npublic:\n MyTestPointer()\n {\n   p = NULL;\n }\n\n MyTestPointer(Test* p)\n {\n   this->p = p;\n }\n\n ~MyTestPointer()\n {\n   delete p;\n }\n\n Test* operator->()\n {\n   return p;\n }\n\n Test& operator*()\n {\n   return *p;\n }\n\nprotected:\n Test *p;\n};\n\nvoid main01_classp()\n{\n Test *p = new Test;\n p->printT();\n delete p;\n MyTestPointer myp = new Test; //构造函数\n myp->printT(); //重载操作符 ->\n};\n\n```\n\n```cpp\nclass MyIntPointer\n{\npublic:\n MyIntPointer()\n {\n   p = NULL;\n }\n\n MyIntPointer(int* p)\n {\n   this->p = p;\n }\n\n ~MyIntPointer()\n {\n   delete p;\n }\n\n int* operator->()\n {\n   return p;\n }\n\n int& operator*()\n {\n   return *p;\n }\n\nprotected:\n int *p;\n};\n\nvoid main02_intp()\n{\n int *p = new int(100);\n cout<<*p<<endl;\n delete p;\n MyIntPointer myp = new int(200);\n cout<<*myp<<endl; //重载*操作符\n};\n```\n\n**8.7 附录：运算符和结合性**\n\n![55]($resource/55.png)\n![66]($resource/66.png)\n\n- 总结\n  * 操作符重载是C++的强大特性之一\n  * 操作符重载的本质是通过函数扩展操作符的语义\n  * operator关键字是操作符重载的关键\n  * friend关键字可以对函数或类开发访问权限\n  * 操作符重载遵循函数重载的规则\n  * 操作符重载可以直接使用类的成员函数实现\n  * =, [], ()和->操作符只能通过成员函数进行重载\n  * ++操作符通过一个int参数进行前置与后置的重载\n  * C++中不要重载&&和||操作符\n\n\n\n\n\n\n",[[1543716375227,["gjx16@GJXAIOU",[[1,50781,"、、"]],[50781,50781],[50783,50783]]],[1543716377405,["gjx16@GJXAIOU",[[-1,50781,"、、"]],[50783,50783],[50781,50781]]],[1543716381792,["gjx16@GJXAIOU",[[1,50781,"、、、、//"]],[50781,50781],[50787,50787]]],[1543716385444,["gjx16@GJXAIOU",[[-1,50781,"、、、、"]],[50781,50785],[50781,50781]]],[1543716385947,["gjx16@GJXAIOU",[[-1,50780,"\n"]],[50781,50781],[50780,50780]]],[1543716388759,["gjx16@GJXAIOU",[[1,50761,"\n"]],[50761,50761],[50762,50762]]],[1543717630802,["gjx16@GJXAIOU",[[1,48009,"//如果要是实现这种连续的赋值，需要返回"]],[48009,48009],[48029,48029]]],[1543717634751,["gjx16@GJXAIOU",[[-1,48027,"返回"]],[48029,48029],[48027,48027]]],[1543717640534,["gjx16@GJXAIOU",[[1,48027,"函数返回一个引用"]],[48027,48027],[48035,48035]]],[1543717658835,["gjx16@GJXAIOU",[[1,48059,"//这种是成员函数的调用方法"]],[48059,48059],[48073,48073]]],[1543717668332,["gjx16@GJXAIOU",[[1,48075,"\n"]],[48074,48074],[48075,48075]]],[1543717670602,["gjx16@GJXAIOU",[[1,48075,"//"]],[48075,48075],[48077,48077]]],[1543717680818,["gjx16@GJXAIOU",[[1,48077,"具体的实现步骤，先释放on"]],[48077,48077],[48090,48090]]],[1543717681349,["gjx16@GJXAIOU",[[-1,48089,"n"]],[48090,48090],[48089,48089]]],[1543717691077,["gjx16@GJXAIOU",[[1,48089,"bj3的内存,houshi"]],[48089,48089],[48102,48102]]],[1543717699767,["gjx16@GJXAIOU",[[-1,48096,"houshi"]],[48102,48102],[48096,48096]]],[1543717725226,["gjx16@GJXAIOU",[[1,48096,"后根据obj1进行分配内存大小，zuihou jiang obj"]],[48096,48096],[48128,48128]]],[1543717734334,["gjx16@GJXAIOU",[[-1,48119,"jiang obj"]],[48128,48128],[48119,48119]]],[1543717739311,["gjx16@GJXAIOU",[[-1,48112,"zui"]],[48115,48115],[48112,48112]]],[1543717741384,["gjx16@GJXAIOU",[[1,48112,"z"]],[48112,48112],[48113,48113]]],[1543717742560,["gjx16@GJXAIOU",[[-1,48112,"z"]],[48113,48113],[48112,48112]]],[1543717758147,["gjx16@GJXAIOU",[[1,48112,"最后将obj1赋值给obj3"]],[48112,48112],[48126,48126]]],[1543718035069,[null,[[-1,48126,"hou "]],[48126,48126],[48126,48126]]],[1543718035069,[null,[[1,48126,"hou "]],[48126,48126],[48126,48126]]],[1543718012507,["gjx16@GJXAIOU",[[1,48965,"laing"]],[48965,48965],[48970,48970]]],[1543718016691,["gjx16@GJXAIOU",[[-1,48965,"laing"]],[48970,48970],[48965,48965]]],[1543718018958,["gjx16@GJXAIOU",[[1,48965,"-"]],[48965,48965],[48966,48966]]],[1543718020915,["gjx16@GJXAIOU",[[1,48911,"### "],[-1,48964,"\n-"]],[48966,48966],[48970,48970]]],[1543718026276,["gjx16@GJXAIOU",[[1,48970," 两种使用方法："]],[48970,48970],[48978,48978]]],[1543718026807,["gjx16@GJXAIOU",[[1,48978,"\n"]],[48978,48978],[48979,48979]]],[1543718031861,["gjx16@GJXAIOU",[[-1,48969,"! "]],[48971,48971],[48969,48969]]],[1543718032991,["gjx16@GJXAIOU",[[1,48969,"- "]],[48969,48969],[48971,48971]]],[1543718095071,[null,[[-1,48126,"hou "],[1,48911,") ；\n"],[-1,48915,") ；\n"],[1,48968,"("],[1,48969,")`\n"],[-1,48979,"`\n\n!"]],[48126,48126],[48979,48979]]],[1543718095071,[null,[[1,48126,"hou "],[-1,48907,") ；\n"],[1,48915,") ；\n"],[-1,48964,"("],[-1,48966,")`\n"],[1,48979,"`\n\n!"]],[48979,48979],[48126,48126]]],[1543718036137,["gjx16@GJXAIOU",[[1,48979,"- \n"]],[48978,48978],[48981,48981]]],[1543718037632,["gjx16@GJXAIOU",[[1,48979,"  "]],[48981,48981],[48983,48983]]],[1543718044858,["gjx16@GJXAIOU",[[1,48983,"返回值当优质"]],[48983,48983],[48989,48989]]],[1543718046191,["gjx16@GJXAIOU",[[-1,48987,"优质"]],[48989,48989],[48987,48987]]],[1543718064560,["gjx16@GJXAIOU",[[1,48987,"右值，相当于返回一个元素"]],[48987,48987],[48999,48999]]],[1543718065473,["gjx16@GJXAIOU",[[1,49000,"  - \n"]],[48999,48999],[49004,49004]]],[1543718071191,["gjx16@GJXAIOU",[[1,49004,"返回值当左值看，"]],[49004,49004],[49012,49012]]],[1543718074108,["gjx16@GJXAIOU",[[-1,49010,"看，"]],[49012,49012],[49010,49010]]],[1543718091984,["gjx16@GJXAIOU",[[1,49010,"，相当于返回一个引用；"]],[49010,49010],[49021,49021]]],[1543718093846,["gjx16@GJXAIOU",[[1,48999,"；"]],[48999,48999],[49000,49000]]],[1543718155081,[null,[[-1,48126,"hou "],[1,48911,") ；\n"],[-1,48915,") ；\n"],[1,48968,"("],[1,48969,")`\n"],[-1,49023,"`\n\n!"]],[48126,48126],[49023,49023]]],[1543718155081,[null,[[1,48126,"hou "],[-1,48907,") ；\n"],[1,48915,") ；\n"],[-1,48964,"("],[-1,48966,")`\n"],[1,49023,"`\n\n!"]],[49023,49023],[48126,48126]]],[1543718100483,["gjx16@GJXAIOU",[[1,49023,"！"]],[49023,49023],[49024,49024]]],[1543718102359,["gjx16@GJXAIOU",[[-1,49023,"！"]],[49024,49024],[49023,49023]]],[1543718103344,["gjx16@GJXAIOU",[[1,49023,"1"]],[49023,49023],[49024,49024]]],[1543718105021,["gjx16@GJXAIOU",[[-1,49023,"1"]],[49024,49024],[49023,49023]]],[1543718105546,["gjx16@GJXAIOU",[[1,49023,"!"]],[49023,49023],[49024,49024]]],[1543718108269,["gjx16@GJXAIOU",[[1,49023,"  - \n"]],[49022,49022],[49027,49027]]],[1543718110074,["gjx16@GJXAIOU",[[-1,49025,"- "]],[49027,49027],[49025,49025]]],[1543718140571,["gjx16@GJXAIOU",[[1,44229,"\n"]],[44228,44228],[44229,44229]]],[1543718147044,["gjx16@GJXAIOU",[[1,44229,"shouxaing"]],[44229,44229],[44238,44238]]],[1543718153884,["gjx16@GJXAIOU",[[-1,44229,"shouxaing"]],[44238,44238],[44229,44229]]],[1543718215331,[null,[[-1,48127,"hou "],[1,48912,") ；\n"],[-1,48916,") ；\n"],[1,48969,"("],[1,48970,")`\n"],[1,49024,""],[-1,49026,"\n!`\n"]],[48127,48127],[49026,49026]]],[1543718215331,[null,[[1,48127,"hou "],[-1,48908,") ；\n"],[1,48916,") ；\n"],[-1,48965,"("],[-1,48967,")`\n"],[-1,49024,""],[1,49026,"\n!`\n"]],[49026,49026],[48127,48127]]],[1543718165186,["gjx16@GJXAIOU",[[1,44229,"首先写函数的调用，然后"]],[44229,44229],[44240,44240]]],[1543718173691,["gjx16@GJXAIOU",[[-1,44231,"写函数的调用，然后"]],[44240,44240],[44231,44231]]],[1543718182647,["gjx16@GJXAIOU",[[1,44231,"写运算符虫子啊"]],[44231,44231],[44238,44238]]],[1543718186626,["gjx16@GJXAIOU",[[-1,44235,"虫子啊"]],[44238,44238],[44235,44235]]],[1543718189531,["gjx16@GJXAIOU",[[1,44235,"重载哈舒"]],[44235,44235],[44239,44239]]],[1543718191882,["gjx16@GJXAIOU",[[-1,44237,"哈舒"]],[44239,44239],[44237,44237]]],[1543718214644,["gjx16@GJXAIOU",[[1,44237,"函数的调用，然后根据调用的形式写具体的函数实现"]],[44237,44237],[44260,44260]]],[1543718275335,[null,[[-1,48158,"hou "],[1,48943,") ；\n"],[-1,48947,") ；\n"],[1,49000,"("],[1,49001,")`\n"],[1,49055,""],[-1,49057,"\n!`\n"]],[48158,48158],[49057,49057]]],[1543718275335,[null,[[1,48158,"hou "],[-1,48939,") ；\n"],[1,48947,") ；\n"],[-1,48996,"("],[-1,48998,")`\n"],[-1,49055,""],[1,49057,"\n!`\n"]],[49057,49057],[48158,48158]]],[1543718215693,["gjx16@GJXAIOU",[[1,44260,"；"]],[44260,44260],[44261,44261]]],[1543718217414,["gjx16@GJXAIOU",[[1,44262,"\n"]],[44261,44261],[44262,44262]]],[1543718221760,["gjx16@GJXAIOU",[[1,44262,"一般情况"]],[44262,44262],[44266,44266]]],[1543718226188,["gjx16@GJXAIOU",[[1,44262,"****"]],[44262,44262],[44264,44264]]],[1543718229445,["gjx16@GJXAIOU",[[-1,44264,"**"]],[44266,44266],[44264,44264]]],[1543718234687,["gjx16@GJXAIOU",[[1,44268,"下哈舒"]],[44268,44268],[44271,44271]]],[1543718235951,["gjx16@GJXAIOU",[[-1,44269,"哈舒"]],[44271,44271],[44269,44269]]],[1543718245022,["gjx16@GJXAIOU",[[1,44269,"函数重载使用成员哈舒"]],[44269,44269],[44279,44279]]],[1543718246251,["gjx16@GJXAIOU",[[-1,44277,"哈舒"]],[44279,44279],[44277,44277]]],[1543718251625,["gjx16@GJXAIOU",[[1,44277,"函数实现；"]],[44277,44277],[44282,44282]]],[1543718253869,["gjx16@GJXAIOU",[[-1,44281,"；"]],[44282,44282],[44281,44281]]],[1543718255222,["gjx16@GJXAIOU",[[1,44281,"**"]],[44281,44281],[44283,44283]]],[1543718335792,[null,[[-1,48181,"hou "],[1,48966,") ；\n"],[-1,48970,") ；\n"],[1,49023,"("],[1,49024,")`\n"],[1,49078,""],[-1,49080,"\n!`\n"]],[48181,48181],[49080,49080]]],[1543718335792,[null,[[1,48181,"hou "],[-1,48962,") ；\n"],[1,48970,") ；\n"],[-1,49019,"("],[-1,49021,")`\n"],[-1,49078,""],[1,49080,"\n!`\n"]],[49080,49080],[48181,48181]]],[1543718323967,["gjx16@GJXAIOU",[[-1,49550,"f.getA();"]],[49550,49559],[49550,49550]]],[1543718325069,["gjx16@GJXAIOU",[[-1,49551,"\n"]],[49550,49550],[49549,49549]]],[1543718328081,["gjx16@GJXAIOU",[[1,49549,"、"]],[49549,49549],[49550,49550]]],[1543718329319,["gjx16@GJXAIOU",[[-1,49549,"、"]],[49550,49550],[49549,49549]]],[1543718334298,["gjx16@GJXAIOU",[[1,49549,"//对象名后面"]],[49549,49549],[49556,49556]]],[1543718335108,["gjx16@GJXAIOU",[[-1,49555,"面"]],[49556,49556],[49555,49555]]],[1543718395785,[null,[[-1,48181,"hou "],[1,48966,") ；\n"],[-1,48970,") ；\n"],[1,49023,"("],[1,49024,")`\n"],[1,49078,""],[-1,49080,"\n!`\n"],[1,49549,"f ;\n"],[-1,49555,"fA);"]],[48181,48181],[49555,49555]]],[1543718395785,[null,[[1,48181,"hou "],[-1,48962,") ；\n"],[1,48970,") ；\n"],[-1,49019,"("],[-1,49021,")`\n"],[-1,49078,""],[1,49080,"\n!`\n"],[-1,49545,"f ;\n"],[1,49555,"fA);"]],[49555,49555],[48181,48181]]],[1543718342032,["gjx16@GJXAIOU",[[1,49555,"面（）"]],[49555,49555],[49558,49558]]],[1543718344836,["gjx16@GJXAIOU",[[1,49557,"参数"]],[49557,49557],[49559,49559]]],[1543718372488,["gjx16@GJXAIOU",[[1,49560,"这种形式要不就是调用了构造函数，要不就是运算符重载"]],[49560,49560],[49585,49585]]],[1543718390773,["gjx16@GJXAIOU",[[-1,49628," . _"]],[49630,49632],[49628,49628]]],[1543718392313,["gjx16@GJXAIOU",[[1,49628,"。"]],[49628,49628],[49629,49629]]],[1543718393893,["gjx16@GJXAIOU",[[-1,49628,"。"]],[49629,49629],[49628,49628]]],[1543718394514,["gjx16@GJXAIOU",[[1,49628,"."]],[49628,49628],[49629,49629]]],[1543718455847,[null,[[-1,48181,"hou "],[1,48966,") ；\n"],[-1,48970,") ；\n"],[1,49023,"("],[1,49024,")`\n"],[1,49078,""],[-1,49080,"\n!`\n"],[1,49549,"f ;\n"],[-1,49585,"fA);"],[-1,49628,"."],[1,49630,"**f"],[-1,49631," _"]],[48181,48181],[49631,49631]]],[1543718455847,[null,[[1,48181,"hou "],[-1,48962,") ；\n"],[1,48970,") ；\n"],[-1,49019,"("],[-1,49021,")`\n"],[-1,49078,""],[1,49080,"\n!`\n"],[-1,49545,"f ;\n"],[1,49585,"fA);"],[1,49624,"."],[-1,49625,"**f"],[1,49629," _"]],[49631,49631],[48181,48181]]],[1543718402837,["gjx16@GJXAIOU",[[-1,49625,"**"]],[49625,49627],[49625,49625]]],[1543718407880,["gjx16@GJXAIOU",[[-1,49637,"_ "]],[49639,49639],[49637,49637]]],[1543718412212,["gjx16@GJXAIOU",[[-1,49647,"**"]],[49649,49649],[49647,49647]]],[1543718875792,[null,[[-1,48181,"hou "],[1,48966,") ；\n"],[-1,48970,") ；\n"],[1,49023,"("],[1,49024,")`\n"],[1,49078,""],[-1,49080,"\n!`\n"],[1,49549,"f ;\n"],[-1,49585,"fA);"],[1,49625," /"],[-1,49626,"."],[1,49628,"f"],[-1,49629," _"],[1,49637,"or"],[-1,49639,"_ "],[1,49647,"2."],[-1,49649,"**"]],[48181,48181],[49649,49649]]],[1543718875792,[null,[[1,48181,"hou "],[-1,48962,") ；\n"],[1,48970,") ；\n"],[-1,49019,"("],[-1,49021,")`\n"],[-1,49078,""],[1,49080,"\n!`\n"],[-1,49545,"f ;\n"],[1,49585,"fA);"],[-1,49621," /"],[1,49624,"."],[-1,49625,"f"],[1,49627," _"],[-1,49633,"or"],[1,49637,"_ "],[-1,49643,"2."],[1,49647,"**"]],[49649,49649],[48181,48181]]],[1543718816793,["gjx16@GJXAIOU",[[1,49326,"\n"],[1,49346,"using namespace std;"],[1,49355,"{"],[-1,49356," { "],[-1,49365," "],[-1,49369," "],[1,49370,"\t"],[-1,49392," "],[-1,49401," "],[-1,49412," "],[-1,49414," "],[-1,49417,"\n "],[-1,49420," "],[-1,49451," "],[-1,49460," "],[-1,49471," "],[-1,49474,"\n { "],[1,49478,"{\n\t"],[-1,49498," ; "],[1,49501,";\n"],[-1,49513," "],[-1,49515," "],[-1,49517,"                     \n"],[-1,49542,"\n"],[1,49543,"\t"],[-1,49546," "],[1,49549,"\t"],[-1,49587," "],[1,49588,"\t"],[-1,49597," "],[-1,49599," 5."],[-1,49603," "],[-1,49606,"2.5 "],[1,49610,"4"],[-1,49619," "],[1,49621," "],[-1,49647,"\n"]],[49326,49650],[49623,49623]]],[1543718820280,["gjx16@GJXAIOU",[[-1,49326,"\n"]],[49326,49326],[49325,49325]]],[1543718820862,["gjx16@GJXAIOU",[[-1,49325,"\n"]],[49325,49325],[49324,49324]]],[1543719055918,[null,[[-1,48181,"hou "],[1,48966,") ；\n"],[-1,48970,") ；\n"],[1,49023,"("],[1,49024,")`\n"],[-1,49081,"!`\n\n"],[1,49325,"c"],[-1,49327,"\n"],[1,49345,"am>\n"],[-1,49365,"am>\n"],[-1,49374,"{s\n { "],[1,49380,"s F\n{\n"],[1,49382,"b"],[-1,49385,"\t"],[-1,49389," "],[1,49390,"\t"],[1,49408,")"],[-1,49411," "],[1,49416,"l"],[-1,49419," "],[-1,49426,"ey "],[1,49429,"le y)"],[-1,49431," "],[-1,49433," "],[1,49460,")"],[-1,49463," "],[1,49468,"l"],[-1,49471," "],[1,49478,"l"],[1,49480,"y)\n"],[-1,49483,"\n { "],[-1,49503,";\ny ; "],[1,49509," * y;\n"],[-1,49517,"an   \t"],[1,49523,"main()"],[1,49526,"\t"],[1,49528,"f;\n"],[-1,49565,"fA\t;"],[-1,49571," "],[1,49572,"\t"],[-1,49578,"(5.42.5 "],[1,49586,"< f(2, 4"],[1,49591,"e"],[-1,49592," "],[-1,49595," ;/. . _"],[1,49603,";  // f."],[1,49609,"or"],[-1,49611,"_ "],[1,49619,"2.5"],[-1,49620,"**\n"]],[48181,48181],[49620,49620]]],[1543719055918,[null,[[1,48181,"hou "],[-1,48962,") ；\n"],[1,48970,") ；\n"],[-1,49019,"("],[-1,49021,")`\n"],[1,49081,"!`\n\n"],[-1,49321,"c"],[1,49324,"\n"],[-1,49341,"am>\n"],[1,49365,"am>\n"],[1,49370,"{s\n { "],[-1,49370,"s F\n{\n"],[-1,49378,"b"],[1,49382,"\t"],[1,49385," "],[-1,49385,"\t"],[-1,49404,")"],[1,49408," "],[-1,49412,"l"],[1,49416," "],[1,49422,"ey "],[-1,49422,"le y)"],[1,49429," "],[1,49430," "],[-1,49456,")"],[1,49460," "],[-1,49464,"l"],[1,49468," "],[-1,49474,"l"],[-1,49477,"y)\n"],[1,49483,"\n { "],[1,49499,";\ny ; "],[-1,49499," * y;\n"],[1,49513,"an   \t"],[-1,49513,"main()"],[-1,49522,"\t"],[-1,49525,"f;\n"],[1,49565,"fA\t;"],[1,49567," "],[-1,49567,"\t"],[1,49574,"(5.42.5 "],[-1,49574,"< f(2, 4"],[-1,49587,"e"],[1,49589," "],[1,49591," ;/. . _"],[-1,49591,";  // f."],[-1,49605,"or"],[1,49609,"_ "],[-1,49615,"2.5"],[1,49619,"**\n"]],[49620,49620],[48181,48181]]],[1543719015851,["gjx16@GJXAIOU",[[1,50736,"、、"]],[50736,50736],[50738,50738]]],[1543719017890,["gjx16@GJXAIOU",[[-1,50736,"、、"]],[50738,50738],[50736,50736]]],[1543719032364,["gjx16@GJXAIOU",[[1,50736,"//首先执行加号运算符重载"]],[50736,50736],[50749,50749]]],[1543719046584,["gjx16@GJXAIOU",[[1,50786,"//zaizhixing"]],[50786,50786],[50798,50798]]],[1543719055129,["gjx16@GJXAIOU",[[-1,50788,"zaizhixing"]],[50798,50798],[50788,50788]]],[1543719115896,[null,[[-1,48181,"hou "],[1,48185,""],[1,48966,") ；\n"],[-1,48970,") ；\n"],[1,49023,"("],[1,49024,")`\n"],[-1,49081,"!`\n\n"],[1,49325,"c"],[-1,49327,"\n"],[1,49345,"am>\n"],[-1,49365,"am>\n"],[-1,49374,"{s\n { "],[1,49380,"s F\n{\n"],[1,49382,"b"],[-1,49385,"\t"],[-1,49389," "],[1,49390,"\t"],[1,49408,")"],[-1,49411," "],[1,49416,"l"],[-1,49419," "],[-1,49426,"ey "],[1,49429,"le y)"],[-1,49431," "],[-1,49433," "],[1,49460,")"],[-1,49463," "],[1,49468,"l"],[-1,49471," "],[1,49478,"l"],[1,49480,"y)\n"],[-1,49483,"\n { "],[-1,49503,";\ny ; "],[1,49509," * y;\n"],[-1,49517,"an   \t"],[1,49523,"main()"],[1,49526,"\t"],[1,49528,"f;\n"],[-1,49565,"fA\t;"],[-1,49571," "],[1,49572,"\t"],[-1,49578,"(5.42.5 "],[1,49586,"< f(2, 4"],[1,49591,"e"],[-1,49592," "],[-1,49595," ;/. . _"],[1,49603,";  // f."],[1,49609,"or"],[-1,49611,"_ "],[1,49619,"2.5"],[-1,49620,"**\n"],[1,50736,"(t2)"],[-1,50749,"(t2)"],[-1,50786,"//"],[1,50792,"//"]],[48181,48181],[50794,50794]]],[1543719115896,[null,[[1,48181,"hou "],[-1,48181,""],[-1,48962,") ；\n"],[1,48970,") ；\n"],[-1,49019,"("],[-1,49021,")`\n"],[1,49081,"!`\n\n"],[-1,49321,"c"],[1,49324,"\n"],[-1,49341,"am>\n"],[1,49365,"am>\n"],[1,49370,"{s\n { "],[-1,49370,"s F\n{\n"],[-1,49378,"b"],[1,49382,"\t"],[1,49385," "],[-1,49385,"\t"],[-1,49404,")"],[1,49408," "],[-1,49412,"l"],[1,49416," "],[1,49422,"ey "],[-1,49422,"le y)"],[1,49429," "],[1,49430," "],[-1,49456,")"],[1,49460," "],[-1,49464,"l"],[1,49468," "],[-1,49474,"l"],[-1,49477,"y)\n"],[1,49483,"\n { "],[1,49499,";\ny ; "],[-1,49499," * y;\n"],[1,49513,"an   \t"],[-1,49513,"main()"],[-1,49522,"\t"],[-1,49525,"f;\n"],[1,49565,"fA\t;"],[1,49567," "],[-1,49567,"\t"],[1,49574,"(5.42.5 "],[-1,49574,"< f(2, 4"],[-1,49587,"e"],[1,49589," "],[1,49591," ;/. . _"],[-1,49591,";  // f."],[-1,49605,"or"],[1,49609,"_ "],[-1,49615,"2.5"],[1,49619,"**\n"],[-1,50732,"(t2)"],[1,50749,"(t2)"],[1,50782,"//"],[-1,50786,"//"]],[50794,50794],[48181,48181]]],[1543719057533,["gjx16@GJXAIOU",[[1,50788,"在"]],[50788,50788],[50789,50789]]],[1543719058236,["gjx16@GJXAIOU",[[-1,50788,"在"]],[50789,50789],[50788,50788]]],[1543719071635,["gjx16@GJXAIOU",[[1,50788,"再执行&&的运算符重载"]],[50788,50788],[50799,50799]]]],null,"gjx16@GJXAIOU"],["7b3b4d73-39b3-48ba-b33b-bb1e41032b6f",1543759534291,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁;\n   * c++面向对象模型初探;  \n   * c++面向对象多态原理探究;\n   * 操作符重载;\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;//定义两个对象c1和c2\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n};\n\n```\nTeacher.cpp\n//具体实现函数内容，在函数名前面加上`类名::`\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1:设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)//因为类的成员变量这里都是private:\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n###  (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n###  (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//需要重载=号操作符，才能解决带来的浅拷贝问题\n\n\tobj2 = obj3; //=号操作，也是一种浅拷贝\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++的默认copy构造函数是浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n\n---\n\n\n### （五）多个对象构造和析构\n\n**1.对象初始化列表**\n\n- 1）对象初始化列表出现原因\n程序本身是有问题的\n```cpp\n\n/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B   //在一个类里面组合了一个带有参数的构造函数的类，因为C++编译器要确定分配给B多大的内存，但是没法初始化A定义的两个对象（因为需要调用有参的构造函数）\n{\npublic:   //没有写B的构造函数，按理说应该调用默认的构造函数\n\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  //主要是因为没有方法和没有机会去初始化这两个A定义的对象\n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB;\n\treturn 0;\n\n}\n\n```\n\n解决方法：\n```cpp\n/*\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n};\n\n\nclass B  \n{\npublic:   \n//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）\n\tB(int _a, int _b) : a1(1), a2(3)  \n\t{\n\n\t}\n//第二种参数传递的方法：\n/*\nB(int _a, int _b,int m,int n) : a1(m), a2(n)  \n\t{\n      a = _a;\n      b = _b;\n\t}\n\t\n*/\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  \n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB(1,2);\n\t//第二种方式：B objB(1,2,4,3)\n\treturn 0;\n\n}\n\n```\n\n**以上程序的操作顺序：**\n首先执行被组合对象的构造函数（a1,a2），如果有多个组合对象，则按照定义的顺序，而不是按照初始化列表的顺序（：后面的顺序）\n析构函数：和构造函数的调用顺序相反\n\n  - 1.必须这样做：\n    - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    - 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n  - 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    - 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    - 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n- 2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n```cpp\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n{\n // some other assignment operation\n}\n```\n\n\n- 3）注意概念\n  - 初始化：被初始化的对象正在创建\n  - 赋值：被赋值的对象已经存在\n\n- 4）注意：\n  - 成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n  - 初始化列表先于构造函数的函数体执行\n\n**说明：**\n\n* 1 C++中提供了初始化列表对成员变量进行初始化\n* 2 使用初始化列表出现原因：\n  * 1.必须这样做：\n    * 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n    * 而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    * 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n  * 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    * 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    * 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n```cpp\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n ABC(int a, int b, int c)\n {\n this->a = a;\n this->b = b;\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"ABC construct ..\\n\");\n }\n\n ~ABC()\n {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n }\n\nprotected:\nprivate:\n int a;\n int b;\n int c;\n};\n\nclass MyD\n{\npublic:\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n {\n cout<<\"MyD()\"<<endl;\n }\n\n ~MyD()\n {\n cout<<\"~MyD()\"<<endl;\n }\n\nprotected:\nprivate:\n ABC abc1; //c++编译器不知道如何构造abc1\n ABC abc2;\n const int m;\n};\n\nint run()\n{\n MyD myD;\n return 0;\n}\n\nint main_dem03()\n{\n run();\n system(\"pause\");\n return 0;\n}\n\n```\n\n\n\n\n### （六）构造函数和析构函数的调用顺序研究\n\n**构造函数与析构函数的调用顺序**\n\n- 1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n- 2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n### （七）构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1构造析构综合训练**\n```cpp\n\n/*\n\n总结 构造和析构的调用顺序\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n\tABC(int a, int b, int c)   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\n\t}\n\n\t~ABC()\n\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\n\nclass MyD \n{\npublic:\n\tMyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~MyD()\n\t{\n\t\tcout << \"~MyD()\" << endl;\n\t}\n\n\tMyD(const MyD & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\tcout << \"MyD(const MyD &obj)\" << endl;\n\t}\n\nprotected:\nprivate:\n\tABC abc1; //c++编译器不知道如何构造abc1//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\tABC abc2;\n\tconst int m;//因为是const m,所以上面所有的m都进行了赋值\n};\n\n\nint doThing(MyD myel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;\n}\n\n\nint run2()//二\n{\n\tMyD myD;//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\treturn 0;\n}\n\nint run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main()\n{\n\trun2();//一\n\t//run3();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n\n\n```\n\n\n**2匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3匿名对象强化训练**\n\n3） 构造中调用构造\n\n```cpp\n/*\n\n构造中调用构造\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass MyTest\n{\npublic:\n\tMyTest(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t}\n\n\tMyTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\n\t\tMyTest(a, b, 10);\n\t}\n\n\t~MyTest()\n\t{\n\t\tcout << \"MyTest is ...\" << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n\n\npublic:\n\tint getC() const { return c; }\n\n\tvoid setC(int val) { c = val; }\n};\n\nint main()\n{\n\tMyTest t1(1, 2);\n\tcout << t1.getC() << endl;\n\tsystem(\"pause\");\n\treturn 0;\n\t\n}\n\n\n```\n\n 结论： 构造函数中调用构造函数，是一个蹩脚的行为。\n程序内存图：\n![搜狗截图20181124125452]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181124125452.png)\n\n### （八）对象的动态建立和释放\n\n**1.new和delete基本语法**\n```cpp\n/*\n\nnew 和delete的使用\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nvoid main()\n{\n\t//先分配内存然后赋值\n\tint *p = new int;  //分配基础类型\n\t*p = 20;  \n\n\t//在定义的时候直接分配内存\n\tint *p1 = new int(30);\n\tcout << *p1 << endl;\n\n\tsystem(\"pause\");\n\treturn; \n}\n\n```\n\n- 1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n  **注意： new和delete是运算符，不是函数，因此执行效率高。**\n\n- 2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： \nnew int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 \nnew char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址    new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n- 3）new和delete运算符使用的一般格式为：\n  用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n![new运算符动态]($resource/new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%A8%E6%80%81.png)\n```cpp\n\n/*\n使用malloc /free 与new /delete的区别\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest();\n\t~Test();\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\nTest::Test()\n{\n\tcout << \"执行了构造函数\" << endl;\n}\n\nTest::~Test()\n{\n\tcout << \"执行了析构函数\" << endl;\n}\n\n\n\nint main()\n{\n\t//基础类型\n\tint *p1 = (int *)malloc(sizeof(int));\n\t*p1 = 10;\n\tdelete p1;\n\n\tint *p2 = new int;\n\t*p2 = 20;\n\tfree(p2);\n\n\n\n\t//数组类型（元素为基础类型）\n\tint *p3 = (int *)malloc(sizeof(int)*10);\n\tp3[0] = 1;\n\tdelete[]p3;\n\n\tint *p4 = new int[10];\n\tp4[1] = 2;\n\tfree(p4);\n\n\n\t//类\n\tTest *p5 = (Test *)malloc(sizeof(Test));\n\tdelete p5;\n\n\tTest *p6 = new Test(10);\n\tfree(p6);\n}\n\n\n```\n**结论：** \nnew：不仅分配内存，而且调用了构造函数\ndelete:不仅释放了内存，而且调用了析构函数\n\n- 4） 应用举例\n\n![5]($resource/5.png)\n\n**2类对象的动态建立和释放**\n\n- 使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n-  C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n  比如：\n\n  Box *pt;  //定义一个指向Box类对象的指针变量pt\n      pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n   这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n  新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n   在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3.编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n\n\n\n## 四、静态成员变量和成员函数\n\n\n思考：每个变量，拥有属性。有没有一些属性，归所有对象拥有？\n\n### （一）静态成员变量\n\n- **1定义静态成员变量**\n  - 关键字 **static**  可以用于说明一个类的成员，\n    静态成员提供了一个同类对象的共享机制\n\n  - 把一个类的成员说明为 **static**  时，这个类无论有多少个对象被创建，这些对象共享这个 **static**  成员\n\n  - 静态成员局部于类，它不是对象成员\n\n![1]($resource/1.png)\n\n例如：\n\n```cpp\n\n/*\n静态成员变量\n*/\n\n#include<iostream>\nusing namespace std;\n\nclass counter\n{\n\n\tstatic int num; //**声明与定义静态数据成员**\n\npublic:\n\n\tvoid setnum(int i) \n\t{ \n\t\tnum = i; \n\t} //成员函数访问静态数据成员\n\n\tvoid shownum() \n\t{ \n\t\tcout << num << endl;\n\t}\n\n};\n\nint counter::num = 0;//声明与定义静态数据成员\n\nvoid main()\n{\n\tcounter a, b;\n\n\ta.shownum(); //调用成员函数访问私有静态数据成员\n\tb.shownum();\n\ta.setnum(10);\n\ta.shownum();\n\tb.shownum();\n\n}\n\n```\n\n![6]($resource/6.png)\n\n**从结果可以看出，访问的是同一个静态数据成员**\n\n- **2使用静态成员变量**\n```cpp\n//例5-14_使用公有静态数据成员\n\n#include<iostream.h>\n\nclass counter\n{ \npublic :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n\n```\n使用静态成员函数调用静态成员变量\n```cpp\n/*\n静态成员函数\n*/\n// 结论：在静态成员函数中可以使用静态成员变量，但是不能使用类中普通的成员变量\n\n#include\"iostream\"\nusing namespace std;\n\nclass BB\n{\npublic:\n\tint printC()\n\t{\n\t\tcout << \"c:\" << c << endl;\n\t\treturn c;\n\t}\n\n\tint addC()\n\t{\n\t\tc = c+1;\n\t}\n\n\n\tstatic void getC()\n\t{\n\t\tcout << \"c\" << c << endl;  //可以直接在静态成员函数中使用静态成员变量，但是不能直接使用一般变量\n\t}\nprivate:\n\tint a;\n\tint b;\n\tstatic int c;\n\n};\n\n\nint BB::c = 10;  //初始化成员变量值\n\nvoid main()\n{\n\tBB b1, b2, b3;\n\tb1.printC();//10\n\tb2.addC();//11\n\tb3.printC();//11\n\n\t//调用成员函数两种方法；\n\tb3.getC();//使用对象.\n\tBB::getC();//使用类::\n\n\n\n}\n\n```\n\n### (二)静态成员函数\n\n- **1）概念**\n\n  - 静态成员函数数冠以关键字static\n\n  - 静态成员函数提供不依赖于类数据结构的共同操作，它没有this指针\n  - 在类外调用静态成员函数用 `_类名_ ::`作限定词，或通过对象调用\n\n- **2）案例**\n![7]($resource/7.png)\n\n- **3）疑难问题：**\n静态成员函数中，不能使用普通变量。\n//静态成员变量属于整个类的，分不清楚，是那个具体对象的属性。\n![成员函数中的疑难问题]($resource/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98.png)\n\n**4.3 综合训练**\n\n\n\n## 五、 C++面向对象模型初探\n\n**前言**\n\n- C++对象模型可以概括为以下2部分：\n\n  - 1. 语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等等。\n\n  - 2. 对于各种支持的底层实现机制。\n\n  在c语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。在c++中，通过抽象数据类型（abstract data type，ADT），在类中定义数据和函数，来实现数据和函数直接的绑定。\n\n  概括来说，在C++类中有两种成员数据：static、nonstatic；三种成员函数：static、nonstatic、virtual。\n\n![C++类的组成]($resource/C++%E7%B1%BB%E7%9A%84%E7%BB%84%E6%88%90.png)\n\n### （一）基础知识\n\nC++中的class从面向对象理论出发，将变量(属性)和函数(方法)集中定义在一起，用于描述现实世界中的类。从计算机的角度，程序依然由数据段和代码段构成。\n\n**C++编译器如何完成面向对象理论到计算机程序的转化？**\n换句话：C++编译器是如何管理类、对象、类和对象之间的关系\n具体的说：具体对象调用类中的方法，那，c++编译器是如何区分，是那个具体的类，调用这个方法那?\n\n思考一下程序结果\n```cpp\n/*\n面向对象模型初探\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass C1\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\nprotected:\n\nprivate:\n\n}; //12\n\nclass C2\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\n\tstatic int m; \n\npublic:\n\n\tint getK() const { return k; } //方法是属于代码，应该放在代码区\n\tvoid setK(int val) { k = val; } \n\nprotected:\n\nprivate:\n}; \n\nstruct S1\n{\n\tint i;\n\tint j;\n\tint k;\n}; \n\nstruct S2\n{\n\tint i;\n\tint j;\n\tint k;\n\tstatic int m;\n}; \n\nint main()\n{\n\n\tprintf(\"c1:%d \\n\", sizeof(C1));\n\tprintf(\"c2:%d \\n\", sizeof(C2));\n\tprintf(\"s1:%d \\n\", sizeof(S1));\n\tprintf(\"s2:%d \\n\", sizeof(S2));\n\tsystem(\"pause\");\n\n}\n```\n程序运行结果：\n`c1:12`\n`c2:12`\n`s1:12`\n`s2:12`\n\n \n### (二)编译器对属性和方法的处理机制\n\n通过上面的案例，我们可以的得出：\n1）C++类对象中的成员变量和成员函数是分开存储的\n- 成员变量：\n  - 普通成员变量：存储于对象中，与struct变量有相同的内存布局和字节对齐方式\n  - 静态成员变量：存储于全局数据区中\n\n- 成员函数：存储于代码段中。\n问题出来了：很多对象共用一块代码？代码是如何区分具体对象的那？\n换句话说：int getK() const { return k; }，代码是如何区分，具体obj1、obj2、obj3对象的k值？\n\n2）C++编译器对普通成员函数的内部处理\n\n![C++编译器对普通成员函数的内部处理]($resource/C++%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E9%83%A8%E5%A4%84%E7%90%86.png)\n\n请仔细思考，并说出你的总结！\n\n\n\n### （三）总结\n\n1、C++类对象中的成员变量和成员函数是分开存储的。C语言中的内存四区模型仍然有效！\n**2、C++中类的普通成员函数都隐式包含一个指向当前对象的this指针。**\n3、静态成员函数、成员变量属于类\n\n静态成员函数与普通成员函数的区别\n\n静态成员函数不包含指向具体对象的指针\n\n普通成员函数包含一个指向具体对象的指针\n\n\n### （四）this指针\n\n![this指针图示]($resource/this%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png)\n\n实验1：若类成员函数的形参 和 类的属性（成员变量）名字相同，通过this指针来解决。\n```cpp\n\n/*\nthis 指针\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass Test\n{\npublic:\n\tTest( int a, int b)//Test(Test *this, int a, int b)//因为这里成员函数的形参和成员变量一样，不用this指针会出现：a = a ,b = b;\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printT()\n\t{\n\t\tcout << \"a; \" << a << endl;\n\t\tcout << \"b: \" << this->b << endl;\n\t}\n\n\n    const void hello(int a,int b )\n    {\n      //下面这两个语句都是错误的\n      this->a = 100;\n      this ->b = 200;\n    }\n   //const修饰的this指针，即相当于this指针指向的内存空间不能被修改\n   //因为上面的函数会别C++编译器解析为:void hello(const Test *this, int a ,int b)\n   //同时上面的const其实下载函数（）外面的任何位置都行\n   \nprotected:\nprivate:\n\tint a;\n\tint b;\n};\nint  main()\n{\n\tTest t1(1, 2);\n\tt1.printT();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`a:1`\n`b:2`\n\n\n实验2：类的成员函数可通过const修饰，请问const修饰的是谁\n\n\n### （五）全局函数PK成员函数\n\n 1、把全局函数转化成成员函数，通过this指针隐藏左操作数\n\n   Test add(Test &t1, Test &t2)===》Test add( Test &t2)\n```cpp\n/*\n全局函数与成员函数\n*/\n\n\n//使用全局函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\t\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nTest Testadd(Test &t1, Test &t2)\n{\n\tTest tmp(3,4);\n\treturn tmp;\n}\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3(2, 3);\n\tt3= Testadd(t1, t2);\n}\n```\n\n```cpp\n//使用成员函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\tTest Testadd(Test &t2)\n\t{\n\t\tTest tmp(this->a + t2.a, this->b + t2.b);\n\t\treturn tmp;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3 = t1.Testadd(t2);//匿名对象直接转化成t4\n\tTest t4(3,5);\n\tt4 = t1.Testadd(t2);  //匿名对象复制给t5\n}\n\n\n```\n 2、把成员函数转换成全局函数，多了一个参数\n\n   void printAB()===》void printAB(Test *pthis)\n\n 3、函数返回元素和返回引用\n```cpp\nTest& add(Test &t2) //*this //函数返回引用,相当于返回自身，谁调用返回谁\n {      \n   this->a = this->a + t2.getA();\n\n   this->b = this->b + t2.getB();\n\n   return *this; //*操作让this指针回到元素状态\n\n }\n\nTest add2(Test &t2) //*this //函数返回元素\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n return t3;\n\n }\n\n void add3(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n //return t3;\n\n }\n  \n\n```\n\n\n\n\n---\n\n## 六、友元\n\n### （一）友元函数\n- 首先友元函数是全局函数，在友元函数中可以修改类的私有属性；\n- 友元函数在类中的声明位置位于public或者private只下均可；\n![8]($resource/8.png)\n\n```cpp\n//友元函数：\n\n#include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend void modify(A *PA,int _a);  //友元函数的声明\n\n\tA(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\n\nprivate:\n\tint a;\n\tint b;\n};\n\nvoid modify(A *PA,int _a)//后面的参数可加可不加\n{\n\t//PA->a = 100;//可以这样直接修改值\n\tPA->a = _a;  //通过传递的值进行修改\n}\n\n\nint main()\n{\n\tA a1(1, 2);\n\tcout << \"a:\" << a1.getA() << endl;\n\tmodify(&a1,20);\n\n\tint aa = a1.getA();\n\n\tcout << \"aa:\" << aa << endl;\n}\n```\n![9]($resource/9.png)\n\n\n### （二）友元类\n\n- 若B类是A类的友员类，则B类的所有成员函数都是A类的友员函数\n- 若B类是A类的友元类，则B类可以直接修改A的成员变量和成员函数\n- 友员类通常设计为一种对数据操作或类之间传递消息的辅助类\n程序示例：\n```cpp\n//友元类\n #include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend class B;//将B 声明为A的友元类，这样B 可以直接修改A的成员变量和成员函数 \n\n\tA(int a=0, int b=0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B\n{\npublic:\n\n\tvoid set(int a)\n\t{\n\t\tobjA.a = a;\n\t}\n\n\tvoid printa()\n\t{\n\t\tcout << objA.a << endl;\n\t}\n\nprivate:\n\tA objA;\n};\n\n\nint main()\n{\n\tB b1;\n\tb1.set(200);\n\tb1.printa();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：200\n\n![10]($resource/10.png)\n\n\n\n## 七、强化训练\n\n**1 static关键字强化训练题**\n\n某商店经销一种货物。货物购进和卖出时以箱为单位，各箱的重量不一样，因此，商店需要记录目前库存的总重量。现在用C++模拟商店货物购进和卖出的情况。\n```cpp\n#include \"iostream\"\nusing namespace std;\n\nclass Goods\n{\npublic:\n\n\tGoods(int w) { weight = w; total_weight += w; }\n\n\t~Goods() { total_weight -= weight; }\n\n\tint Weight() { return weight; };\n\n\tstatic int TotalWeight() { return total_weight; }\n\n\tGoods *next;\n\nprivate:\n\n\tint weight;\n\tstatic int total_weight;\n\n};\n\nint Goods::total_weight = 0;\n\n//r尾部指针\n\nvoid purchase(Goods * &f, Goods *& r, int w)\n{\n\n\tGoods *p = new Goods(w);\n\n\tp->next = NULL;\n\n\tif (f == NULL) f = r = p;\n\n\telse { r->next = p; r = r->next; } //尾部指针下移或新结点变成尾部结点\n\n}\n\nvoid sale(Goods * & f, Goods * & r)\n{\n\n\tif (f == NULL) { cout << \"No any goods!\\n\"; return; }\n\n\tGoods *q = f; f = f->next; delete q;\n\n\tcout << \"saled.\\n\";\n\n}\n\nvoid main()\n{\n\tGoods * front = NULL, *rear = NULL;\n\n\tint w; int choice;\n\n\tdo\n\t{\n\t\tcout << \"Please choice:\\n\";\n\n\t\tcout << \"Key in 1 is purchase,\\nKey in 2 is sale,\\nKey in 0 is over.\\n\";\n\n\t\tcin >> choice;\n\n\t\tswitch (choice) // 操作选择\n\t\t{\n\t\tcase 1: // 键入1，购进1箱货物\n\t\t{ cout << \"Input weight: \";\n\t\tcin >> w;\n\n\t\tpurchase(front, rear, w); // 从表尾插入1个结点\n\n\t\tbreak;\n\t\t}\n\n\t\tcase 2:              // 键入2，售出1箱货物\n\t\t{ sale(front, rear); break; } // 从表头删除1个结点\n\n\t\tcase 0: break;              // 键入0，结束\n\t\t}\n\n\t\tcout << \"Now total weight is:\" << Goods::TotalWeight() << endl;\n\n\t} while (choice);\n}\n```\n**2** **数组类封装**\n\n目标：解决实际问题，训练构造函数、copy构造函数等，为操作符重载做准备\n\n数组类的头文件:`Array.h`\n```cpp\n#pragma once\nclass Array\n{\npublic:\n\tArray(int length);\n\tArray(const Array&obj);\n\t~Array();\npublic:\n\tint length();\n\n\tvoid setData(int index, int value);\n\n\tint getData(int index);\nprivate:\n\tint m_length;\n\tchar *m_space;\n};\n```\n\n数组类的头文件的实现：`Array.cpp`\n```cppp\n#include \"Array.h\"\nusing namespace std;\n#include\"iostream\"\n\nArray::Array(int length)\n{\n\tif (length < 0)\n\t{\n\t\tlength = 0;\n\t}\n\telse\n\t{\n\t\tm_length = length;\n\t\tm_space = new char[m_length];\n\t}\n}\n\nArray::Array(const Array&obj)\n{\n   this->m_length = obj.m_length;\n   this->m_space = new char [this->m_length];//进行分配内存空间\n\n  for(int i= 0; i < obj.m_length;i++)//数组元素复制， 这里的obj.m_length可以直接替换成m_length\n  {\n    this->m_space[i] = obj.m_space[i];\n  }\n}\n\nArray::~Array()\n{\n\tif (m_space != NULL)\n\t{\n\t\tdelete[] m_space;\n\t\tm_length = 0;\n\t}\n}\n\nvoid Array::setData(int index, int valude)\n{\n\tm_space[index] = valude;\n}\n\nint Array::getData(int index)\n{\n\treturn m_space[index];\n}\n\nint Array::length()\n{\n\treturn m_length; \n}\n```\n\n数组类的测试\n```cpp\n#include \"iostream\"\n#include \"Array.h\"\nusing namespace std;\n\nint main()\n{\n\tArray a1(10);\n\tfor (int i = 0; i < a1.length(); i++)\n\t{\n\t\ta1.setData(i, i);\n\t}\n\tfor (int i = 0; i <  a1.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a1.getData(i));\n\t}\n\n\tArray a2 = a1;\n\n\tfor (int i = 0; i < a2.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a2.getData(i));\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**3.小结**\n\n* 类通常用关键字class定义。类是数据成员和成员函数的封装。类的实例称为对象。\n* 结构类型用关键字struct定义，是由不同类型数据组成的数据类型。\n* 类成员由private, protected, public决定访问特性。public成员集称为接口。\n* 构造函数在创建和初始化对象时自动调用。析构函数则在对象作用域结束时自动调用。\n* 重载构造函数和复制构造函数提供了创建对象的不同初始化方式。\n* 静态成员是局部于类的成员，提供一种同类对象的共享机制。\n* 友员用关键字friend声明。友员是对类操作的一种辅助手段。一个类的友员可以访问该类各种性质的成员\n* 链表是一种重要的动态数据结构，可以在程序运行时创建或撤消数据元素。\n\n\n\n---\n\n\n## 八、运算符重载\n\n### （一）概念\n\n#### **1.什么是运算符重载**\n\n![11]($resource/11.png)\n所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是”一名多用”。\n\n运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重载。例如，大 家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行加法运算，如5+8， 5.8 +3.67等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的， 但由于C++已经对运算符”+”进行了重载，所以就能适用于int, float, doUble类型的运算。\n\n又如`<<`是C的位运算中的位移运算符（左移），但在输出操作中又是与流对 象cout 配合使用的流插入运算符，`>>`也是位移运算符(右移），但在输入操作中又是与流对象 cin 配合使用的流提取运算符。这就是运算符重载(operator overloading)。C系统对`<<`和`>>`进行了重载，用户在不同的场合下使用它们时，作用是不同 的。对`<<`和`>>`的重载处理是放在头文件stream中的。因此，如果要在程序中用`<<`和`>>`作流插入运算符和流提取运算符，必须在本文件模块中包含头文件stream(当然还应当包括”using namespace std“)。\n\n现在要讨论的问题是：用户能否根据自己的需要对C++已提供的运算符进行重载，赋予它们新的含义，使之一名多用？\n\n#### **2.运算符重载入门技术推演**\n\n1为什么会用运算符重载机制\n//原因 Complex是用户自定义类型，编译器根本不知道如何进行加减，但是编译器给提供了一种机制，让用户自己去完成，自定义类型的加减操作。。。这个机制就是运算符重载机制\n\n用复数类举例，定义一个Complex类,有两个对象，每个对象由两个属性，要求使用对象之间的加法实现对应属性的相加，示例程序如下：\n```cpp\n\n/*对于基础数据类型，C++编译器知道如何进行运算，但是对于用户自定义的类型编译器提供了一种\n让自定义数据类型进行运算符操作的机制,=》运算符重载机制\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\npublic:\n\tfriend Complex operator+(Complex &c1, Complex &c2);//友元函数声明\n\n\tComplex(int a = 0, int b = 0)//构造函数\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\nprivate:\n  int a;\n  int b;\n};\n\n/*使用全局函数，通过调用全局函数实现\nComplex myAdd(Complex &c1, Complex &c2)\n{\n Complex tmp(c1.a+ c2.a, c1.b + c2.b);\n\n return tmp;\n}\n*/\n\n\n//可以简单的想象为将上面全局函数的函数名替换为operator+\nComplex operator+(Complex &c1, Complex &c2)\n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\treturn tmp;\n}\n\n\n\nint  main()\n{\n\tComplex c1(1, 2), c2(3, 4);\n\n\t//方法1： 通过调用普通函数实现\n\t//Complex c3 = myAdd(c1, c2);\n\t//c3.printCom();\n\n\n\t//方法2  将函数名称替换为：operator+ \n\t//使用以下方式进行调用\n\t//Complex c3 = operator+(c1, c2);\n\t//c3.printCom();\n\n\n\t//方法3：最常用的调用方式\n\tComplex c3 = c1 + c2; \n\tc3.printCom()\n\n\tsystem(\"pause\");\n\treturn;\n}\n```\n程序运行结果：`4+6i`\n\n\n---\n\n### （二）运算符重载的限制\n![12]($resource/12.png)\n\n重载运算符函数可以对运算符进行新的解释，但是原有的基本语义不变：\n* 不改变运算符的优先级\n* 不改变运算符的结合性\n* 不改变运算符所需要的操作数\n* 不能创建新的运算符\n\n---\n\n### （三）运算符重载编程基础\n![14]($resource/14.png)\n例如:\n   //全局函数  完成 +操作符  重载  \n    Complex operator+(Complex &c1, Complex &c2)\n\n  //类成员函数  完成 -操作符  重载\n    Complex operator-(Complex &c2)\n\n#### **1.运算符重载的两种方法:**\n- 运算符可以重载为成员函数了或者友元函数\n- 关键区别在于成员函数具有this指针，友元函数没有this 指针\n- 不管是成员函数还是友元函数重载，运算符的使用方法相同\n- 但是两种的传递参数不同，实现代码也不同，应用场合也不同\n\n- **二元操作符重载的实现：**\n![16]($resource/16.png)\n \n```cpp\n//二元函数操作符的重载的两种方法\n\n\n/*全局函数、类成员函数方法实现运算符重载步骤\n1）要承认操作符重载是一个函数，写出函数名称operator + ()\n2）根据操作数，写出函数参数\n3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex operator+(Complex &c1, Complex &c2); //这里是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\t//成员函数实现 - 运算符重载 \n\tComplex operator-(Complex &c2)//因为是c1调用的，因此这里的this 指向c1\n\t{\n\t\tComplex tmp(this->a - c2.a, this->b -  c2.b);//通过构造函数实现 tmp中成员变量的变化 \n\t\treturn tmp;\n\t}\n\n};\n\n\n//使用全局函数实现  + 运算符重载\nComplex operator+(Complex &c1, Complex &c2)\n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\n\treturn tmp;\n}\n\n\nint  main()\n{\n\tComplex c1(1, 2), c2(3, 4);\n\n\t//使用 全局函数\n\tComplex c3 = c1 + c2;\n\tc3.printCom();\n\n\t//使用成员函数\n\tComplex c4 = c1.operator-(c2);\n\tc4.printCom();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`4 + 6i`\n`-2 + -2i`\n\n\n- **一元函数操作符重载的实现：**\n![17]($resource/17.png)\n\n- 实现前置++和前置--\n```cpp\n//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现前置++和前置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex& operator++(Complex &c1); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\tComplex& operator--()\n\t{\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn *this;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  + 运算符重载\nComplex& operator++(Complex &c1)\n{\n\tc1.a++;\n\tc1.b++;\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1,c2;\n\n\t//使用全局函数实现前置++操作符的重置\n\t++c1;\n\tc1.printCom();\n\n\n\t//使用成员函数实现前置--操作符的重置\n\t--c2;\n\tc2.printCom();\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`1 + 1i`\n`-1 + -1i`\n\n- 实现后置++和后置--\n```cpp\n//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现后置++ 和后置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex operator++(Complex &c1, int); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\t//成员函数实现后置--\n\tComplex operator--(int)\n\t{\n\t\tComplex tmp = *this;\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn tmp;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  ++ 运算符重载\nComplex operator++(Complex &c1,int)  //为了和前置++的函数能够共同存在，参数中加了一个占位符从而实现函数重载\n{\n\t//前置++是先使用后++ ，所以应该先返回c1,但是直接使用return c1.会造成程序的直接退出，后面的++无法实现，所以使用临时变量\n\n\tComplex tmp = c1;\n\tc1.a++;\n\tc1.b++;\n\treturn tmp;\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1, c2;\n\t//使用全局函数实现后置++操作符的重置\n\tc1++;\n\tc1.printCom();\n\n\t//使用成员函数实现后置--操作符的重置\n\tc2--;\n\tc2.printCom();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n\n**前置和后置运算符总结:**\n\nC++中通过一个占位参数来区分前置运算和后置运算\n![18]($resource/18.png)\n\n\n\n#### **2.定义运算符重载函数名的步骤**\n首先写运算符重载函数的调用，然后根据调用的形式写具体的函数实现；\n**一般情况下函数重载使用成员函数实现**\n全局函数、类成员函数方法实现运算符重载步骤\n * 1）要承认操作符重载是一个函数，写出函数名称operator+ ()\n * 2）根据操作数，写出函数参数\n * 3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n\n#### **3.友元函数实现操作符重载的应用场景**\n\n**1）友元函数和成员函数选择方法**\n- 当无法修改左操作数的类时，使用全局函数进行重载,因为成员函数需要在左边的类中进行修改；\n- =, [], ()和->操作符只能通过成员函数进行重载\n\n**2）用友元函数重载 <<和 >>操作符**\n\n* istream 和 ostream 是 C++ 的预定义流类，都不让修改的222222222222222222222222222222222222222222222\n* cin 是 istream 的对象，cout 是 ostream 的对象\n* 运算符 << 由ostream 重载为插入操作，用于输出基本类型数据\n* 运算符 >> 由 istream 重载为提取操作，用于输入基本类型数据\n* 用友员函数重载 << 和 >> ，输出和输入用户自定义的数据类型\n\na）用全局函数方法实现 << 操作符\n```pp\n//实现<<运算符的重载\n\n//注释内部是一套完整的程序，但是只能实现一次打印输出，新的一套程序可以实现链式输出\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\t//friend  void operator<<(ostream &cout, Complex &c1); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n};\n\n/*这里类似于cout只能有全局函数加上友元函数实现，因为如果要使用成员函数实现，需要在cout 的类：ostream中定义成员函数，\n但是这个ostream类是系统隐藏的，不现实；\nvoid operator<<(ostream &cout, Complex &c1)\n{\n\tcout << c1.a << \" + \" << c1.b << \"i\" << endl;\n}\n*/\n\nostream& operator<<(ostream &cout, Complex &c2)  //要想实现函数返回值当左值，需要返回一个引用\n{\n\tcout << c2.a << \" + \" << c2.b << \"i\" << endl;\n\treturn cout;\n}\n\n\n \nint  main()\n{\n\tComplex c1, c2;\n\t//cout << c1;  //实现将c1中两个元素以a+bi的形式直接打印输出；\n\t/*\n\t首先承认运算符重载是函数，所以函数名为：operator<<\n\t其次因为有左右参数，分别为ostream 和Complex类，所有函数头为：operator<<(ostream&cout,Complex c1)\n\t然后根据返回值确定最前面的返回值类型\n\t*/\n\n\tcout << c2 << \"kdjfkdjfkd\";\n\t//因为<<操作符是从左到右，所以左边执行返回值要当左值再次执行这个函数\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n**3）友元函数重载操作符使用注意点**\n\n- a） 友员函数重载运算符常用于运算符的左右操作数类型不同的情况\n![19]($resource/19.png)\n- b）其他\n  - 在第一个参数需要隐式转换的情形下，使用友员函数重载运算符是正确的选择\n  - 友员函数没有 this 指针，所需操作数都必须在参数表显式声明，很容易实现类型的隐式转换\n  - C++中不能用友员函数重载的运算符有\n     = （）  ［］  －>\n\n**4）友元函数案例vector类**\n```cpp\n#include <iostream>\nusing namespace std;\n\n//为vector类重载流插入运算符和提取运算符\n\nclass vector\n{\npublic:\n\tvector(int size = 1);\n\n\t~vector();\n\n\tint & operator[](int i);\n\n\tfriend ostream & operator << (ostream & output, vector &);\n\n\tfriend istream & operator >> (istream & input, vector &);\n\nprivate:\n\tint * v;\n\n\tint len;\n\n};\n\nvector::vector(int size)\n{\n\tif (size <= 0 || size > 100)\n\t{\n\t\tcout << \"The size of \" << size << \" is null !\\n\"; abort();\n\t}\n\n\tv = new int[size]; len = size;\n}\n\nvector :: ~vector()\n{\n\tdelete[] v;\n\n\tlen = 0;\n}\n\nint &vector::operator[](int i)\n{\n\tif (i >= 0 && i < len) return v[i];\n\n\tcout << \"The subscript \" << i << \" is outside !\\n\"; abort();\n}\n\nostream & operator << (ostream & output, vector & ary)\n{\n\tfor (int i = 0; i < ary.len; i++)\n\t\toutput << ary[i] << \" \";\n\n\toutput << endl;\n\treturn output;\n}\n\nistream & operator >> (istream & input, vector & ary)\n{\n\tfor (int i = 0; i < ary.len; i++)\n\t\tinput >> ary[i];\n\n\treturn input;\n}\n\nvoid main()\n{\n\tint k;\n\tcout << \"Input the length of vector A :\\n\";\n\tcin >> k;\n\tvector A(k);\n\tcout << \"Input the elements of vector A :\\n\";\n\tcin >> A;\n\tcout << \"Output the elements of vector A :\\n\";\n\tcout << A;\n\tsystem(\"pause\");\n}\n\n```\n\n### （四）运算符重载提高\n\n#### **1.运算符重载机制**\n\nC++编译器是如何支持操作符重载机制的?\n\n#### **2.重载赋值运算符=**\n\n* 赋值运算符重载用于对象数据的复制\n* operator= 必须重载为成员函数\n* 重载函数原型为：\n  类型&类名:: operator= ( const  类名 & ) ;\n\n案例：完善Name类，支持=号操作。\n![22]($resource/22.png)\n\n  结论:\n 1 先释放旧的内存\n 2 返回一个引用\n 3 =操作符 从右向左\n```cpp\n//重载 = 操作符\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\t//obj3 = obj1; // C++编译器提供的  等号操作  也属  浅拷贝\\\n\t// obj4 = obj3 = obj1//如果要是实现这种连续的赋值，需要函数返回一个引用\n\t//obj3.operator=(obj1)//这种是成员函数的调用方法\n\n//具体的实现步骤，先释放obj3的内存,后根据obj1进行分配内存大小，最后将obj1赋值给obj3\n\tName& operator=(Name &obj1)\n\t{\n\t\t//1 先释放obj3旧的内存\n\n\t\tif (this->pName != NULL)\n\t\t{\n\t\t\tdelete[] pName;\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\t//2 根据obj1分配内存大小\n\n\t\tthis->size = obj1.size;\n\t\tthis->pName = new char[size + 1];\n\n\t\t//3把obj1赋值给obj3\n\n\t\tstrcpy(pName, obj1.pName);\n\t\treturn *this;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nint main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n\n#### **3.重载数组下表运算符[]** ==这里的视频再看一遍==\n- 重载[]和()运算符\n  - 运算符 [] 和 () 是二元运算符\n  - [] 和 () 只能用成员函数重载，不能用友元函数重载\n\n- 重载下标运算符 []\n  - [] 运算符用于访问数据对象的元素\n  重载格式：  返回值类型 类 :: operator[] ( 类型 ) ；\n###   设 x 是类 X 的一个对象，则表达式 `x[y]` 可被解释为  `x.operator[](y)`\n- 两种使用方法：\n  - 返回值当右值，相当于返回一个元素；\n  - 返回值当左值，相当于返回一个引用；\n  \n![33]($resource/33.png)\n![44]($resource/44.png)\n\n\n#### **4.重载函数调用符()**\n\n() 运算符用于函数调用\n\n重载格式:  返回值类型 类:: operator() ( 表达式表 ) ；\n\n例1\n设 x是类 X的一个对象，则表达式*\nx ( arg1, arg2, … )\n可被解释为\nx . operator () (arg1, arg2, … )\n\n**案例：**\n例2：用重载()运算符实现数学函数的抽象\n```cpp\n#include <iostream>\nusing namespace std;\nclass F\n{\npublic:\n\n\tdouble operator ( )  (double x, double y);\n};\n\ndouble F :: operator ( )  (double x, double y)\n{\n\treturn x * x + y * y;\n}\n\nvoid main()\n{\n\tF f;\n\t//对象名后面（参数）这种形式要不就是调用了构造函数，要不就是运算符重载\n\n\tcout << f(2, 4) << endl;  // f.operator()(5.2, 2.5)\n}\n```\n比较普通成员函数\n\n**//例3用重载()运算符实现 pk成员函数**\n```cpp\n#include <iostream.h>\n\nclass F\n\n { public :\n\n double memFun ( double x , double y ) ;\n\n } ;\n\ndouble F :: memFun ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\n cout << f.memFun ( 5.2 , 2.5 ) << endl ;\n\n}\n```\n\n#### **5.为什么不要重载&&和||操作符**\n\n- 理论知识：\n  - 1）&&和||是C++中非常特殊的操作符\n  - 2）&&和||内置实现了短路规则\n  - 3）操作符重载是靠函数重载来完成的\n  - 4）操作数作为函数参数传递\n  - 5）C++的函数参数都会被求值，无法实现短路规则\n```cpp\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nclass Test\n{\n\tint i;\npublic:\n\tTest(int i)\n\t{\n\t\tthis->i = i;\n\t}\n\n\tTest operator+ (const Test& obj)\n\t{\n\t\tTest ret(0);\n\t\tcout << \"执行+号重载函数\" << endl;\n\t\tret.i = i + obj.i;\n\t\treturn ret;\n\t}\n\n\tbool operator&& (const Test& obj)\n\t{\n\t\tcout << \"执行&&重载函数\" << endl;\n\t\treturn i && obj.i;\n\t}\n\n};\n\n// && 从左向右\nint  main()\n{\n\tint a1 = 0;\n\tint a2 = 1;\n\tcout << \"注意：&&操作符的结合顺序是从左向右\" << endl;\n\n\tif (a1 && (a1 + a2))\n\t{\n\t\tcout << \"有一个是假，则不在执行下一个表达式的计算\" << endl;\n\t}\n\n\tTest t1 = 0;\n\tTest t2 = 1;\n\n\tif(t1 && (t1 + t2))\n\t{\n\t\tt1.operator&&(t1 + t2);\n\t\tt1.operator&&(t1.operator+(t2));\n\n\t\t\t//t1 && t1.operator+(t2)//首先执行加号运算符重载\n\t\t\t// t1.operator( t1.operator(t2) )//再执行&&的运算符重载\n\t\t\tcout << \"两个函数都被执行了，而且是先执行了+\" << endl;\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`注意：&&操作符的结合顺序是从左向右`\n`执行+号重载函数`\n`执行&&重载函数`\n\n\n### （五）运算符重载在项目开发中的应用\n\n#### **1实现一个数组类**\n添加<< >>\n\n#### **2实现一个字符串类**\n//构造函数要求\n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串类 以零结尾的字符串\n\n//若len为0,表示空串\n```cpp\nMyString a; //空串 “”\nMyString a(“dddd”);\nMyString b = a;\nb = “aaaaaa” \nb = a;\n\nif (a > b)\nif (a == b)\nb[i] = ‘a’;\n```\n常用的操作符\n\n<< >> != == > < =\n\n```cpp\n//C语言中没有字符串这种类型，是通过数组来模拟字符串\n//C++中 我们来设计一个字符串 以零结尾的字符串\n\nclass MyString\n{\n friend ostream& operator<<(ostream &out, const MyString &s);\n\npublic: //构造和析构\n MyString(int len = 0);\n MyString(const char *p);\n MyString(const MyString& obj);\n ~MyString();\n\npublic: //操作符重载\n MyString& operator=(const char *p);\n MyString& operator=(const MyString& obj);\n char& operator[](int index) const;\n\npublic:\n bool operator==(const char* p) const;\n bool operator!=(const char* p) const;\n bool operator==(const MyString& s) const;\n bool operator!=(const MyString& s) const;\n\npublic: //string to c\n char *c_str();\n const char* c_str() const;\n int length()\n {\n   return m_len;\n }\n\npublic:\n int operator<(const char *p);\n int operator>(const char *p);\n int operator<(const MyString &s);\n int operator>(const MyString &s);\nprivate:\n int m_len;\n char *m_p;\n};\n\n```\n\n\n#### **3智能指针类编写**\n\n1问题抛出\n  指针使用过程中，经常会出现内存泄漏和内存多次被释放常\n\n2解决方案：例如：boost库的智能指针\n  项目开发中，要求开发者使用预先编写的智能指针类对象代替C语言中的原生指针\n\n3智能指针思想\n  工程中的智能指针是一个类模板\n  通过构造函数接管申请的内存\n  通过析构函数确保堆内存被及时释放\n  通过重载指针运算符* 和 -> 来模拟指针的行为\n  通过重载比较运算符 == 和 != 来模拟指针的比较\n\n```cpp\nclass Test\n{\npublic:\n Test()\n {\n   this->a = 10;\n }\n\n void printT()\n {\n   cout<<a<<endl;\n }\n\nprivate:\n int a;\n};\n\nclass MyTestPointer\n{\npublic:\n\npublic:\n MyTestPointer()\n {\n   p = NULL;\n }\n\n MyTestPointer(Test* p)\n {\n   this->p = p;\n }\n\n ~MyTestPointer()\n {\n   delete p;\n }\n\n Test* operator->()\n {\n   return p;\n }\n\n Test& operator*()\n {\n   return *p;\n }\n\nprotected:\n Test *p;\n};\n\nvoid main01_classp()\n{\n Test *p = new Test;\n p->printT();\n delete p;\n MyTestPointer myp = new Test; //构造函数\n myp->printT(); //重载操作符 ->\n};\n\n```\n\n```cpp\nclass MyIntPointer\n{\npublic:\n MyIntPointer()\n {\n   p = NULL;\n }\n\n MyIntPointer(int* p)\n {\n   this->p = p;\n }\n\n ~MyIntPointer()\n {\n   delete p;\n }\n\n int* operator->()\n {\n   return p;\n }\n\n int& operator*()\n {\n   return *p;\n }\n\nprotected:\n int *p;\n};\n\nvoid main02_intp()\n{\n int *p = new int(100);\n cout<<*p<<endl;\n delete p;\n MyIntPointer myp = new int(200);\n cout<<*myp<<endl; //重载*操作符\n};\n```\n\n**8.7 附录：运算符和结合性**\n\n![55]($resource/55.png)\n![66]($resource/66.png)\n\n- 总结\n  * 操作符重载是C++的强大特性之一\n  * 操作符重载的本质是通过函数扩展操作符的语义\n  * operator关键字是操作符重载的关键\n  * friend关键字可以对函数或类开发访问权限\n  * 操作符重载遵循函数重载的规则\n  * 操作符重载可以直接使用类的成员函数实现\n  * =, [], ()和->操作符只能通过成员函数进行重载\n  * ++操作符通过一个int参数进行前置与后置的重载\n  * C++中不要重载&&和||操作符\n\n\n\n\n\n\n",[[1543759477744,["gjx16@GJXAIOU",[[-1,51071,"//若len为0,表示空串\n```cpp\nMyString a; //空串 “”\nMyString a(“dddd”);\nMyString b = a;\nb = “aaaaaa” \nb = a;\n\nif (a > b)\nif (a == b)\nb[i] = ‘a’;\n```\n常用的操作符\n\n<< >> != == > < =\n\n```cpp\n//C语言中没有字符串这种类型，是通过数组来模拟字符串\n//C++中 我们来设计一个字符串 以零结尾的字符串\n\nclass MyString\n{\n friend ostream& operator<<(ostream &out, const MyString &s);\n\npublic: //构造和析构\n MyString(int len = 0);\n MyString(const char *p);\n MyString(const MyString& obj);\n ~MyString();\n\npublic: //操作符重载\n MyString& operator=(const char *p);\n MyString& operator=(const MyString& obj);\n char& operator[](int index) const;\n\npublic:\n bool operator==(const char* p) const;\n bool operator!=(const char* p) const;\n bool operator==(const MyString& s) const;\n bool operator!=(const MyString& s) const;\n\npublic: //string to c\n char *c_str();\n const char* c_str() const;\n int length()\n {\n   return m_len;\n }\n\npublic:\n int operator<(const char *p);\n int operator>(const char *p);\n int operator<(const MyString &s);\n int operator>(const MyString &s);\nprivate:\n int m_len;\n char *m_p;\n};\n"]],[51071,52078],[51071,51071]]],[1543759482695,["gjx16@GJXAIOU",[[1,51071,"···"]],[51071,51071],[51074,51074]]],[1543759485207,["gjx16@GJXAIOU",[[-1,51071,"···"]],[51074,51074],[51071,51071]]],[1543759489147,["gjx16@GJXAIOU",[[1,51071,"```cpp"]],[51071,51071],[51077,51077]]],[1543759489691,["gjx16@GJXAIOU",[[1,51078,"\n"]],[51077,51077],[51078,51078]]],[1543759497823,["gjx16@GJXAIOU",[[1,51070,"touwenjian"]],[51070,51070],[51080,51080]]],[1543759504648,["gjx16@GJXAIOU",[[-1,51070,"touwenjian"]],[51080,51080],[51070,51070]]],[1543759508743,["gjx16@GJXAIOU",[[1,51070,"头文件；"]],[51070,51070],[51074,51074]]],[1543759521657,["gjx16@GJXAIOU",[[1,51082,"#pragma once\n#include \"iostream\"\nusing namespace std;\n\nclass MyString\n{\npublic:\n\tMyString();\n\tMyString(const char *p);\n\tMyString(const MyString &s);\n\t~MyString();\nprivate:\n\tint m_len;\n\tchar* m_p;\n\n\npublic:\n\tMyString& operator=(const char *p);\n\tMyString& operator= (const MyString &s);\n\n\tchar& operator[](int index);\n\n\tfriend ostream & operator<<(ostream &out, MyString &s);\n\n\n\tbool operator==(const char *p);\n\tbool operator!=(const char *p);\n\tbool operator==(const MyString&s);\n\tbool operator!=(const MyString &s);\n\n\n\n\tint operator<(const char *p);\n\tint operator<(const MyString &s);\n\n\n\n\tchar *c_str()\n\t{\n\t\treturn m_p;\n\t}\n\t//这个函数相比上面的区别只是得到的指针不能改变\n\tconst char *c_str2()\n\t{\n\t\treturn m_p;\n\t}\n\n\tint length()\n\t{\n\t\treturn m_len;\n\t}\n};\n"]],[51082,51082],[51812,51812]]],[1543759525648,["gjx16@GJXAIOU",[[1,51819,"\n"]],[51816,51816],[51817,51817]]],[1543759526222,["gjx16@GJXAIOU",[[1,51820,"\n"]],[51817,51817],[51818,51818]]],[1543759530765,["gjx16@GJXAIOU",[[1,51818,"头文件类的实现："]],[51818,51818],[51826,51826]]],[1543759531307,["gjx16@GJXAIOU",[[1,51829,"\n"]],[51826,51826],[51827,51827]]],[1543759543461,["gjx16@GJXAIOU",[[1,51827,"```cppp"]],[51827,51827],[51834,51834]]],[1543759544045,["gjx16@GJXAIOU",[[1,51837,"\n"]],[51834,51834],[51835,51835]]],[1543759544614,["gjx16@GJXAIOU",[[1,51835,"\\"]],[51835,51835],[51836,51836]]],[1543759545212,["gjx16@GJXAIOU",[[1,51839,"\n"]],[51836,51836],[51837,51837]]],[1543759546877,["gjx16@GJXAIOU",[[1,51837,"```"]],[51837,51837],[51840,51840]]],[1543759549794,["gjx16@GJXAIOU",[[-1,51835,"\\"]],[51836,51836],[51835,51835]]],[1543759565978,["gjx16@GJXAIOU",[[1,51835,"#include \"MyString.h\"\n#include\"math.h\"\n#include \"iostream\"\n#pragma warning(disable:4996)\n\n\n\nMyString::MyString() //构造函数：将默认的字符串进行默认为空字符串\n{\n\tm_len = 0;\n\tm_p = new char[m_len + 1];\n\tstrcpy(m_p, \" \");\n}\n\nMyString::MyString(const char *p)\n{\n\tif (p == NULL)\n\t{\n\t\tm_len = 0;\n\t\tm_p = new char[m_len + 1];\n\t\tstrcpy(m_p, \"\");\n\t}\n\telse\n\t{\n\t\tm_len = strlen(p);\n\t\tm_p = new char[m_len + 1];\n\t\tstrcpy(m_p, p);\n\t}\n}\n\n//拷贝构造函数\n//实现MyString s3 = s2;\n MyString::MyString(const MyString &s)\n{\n\tm_len = s.m_len;   \n\tm_p = new char[m_len + 1];  //分配空间\n\tstrcpy(m_p, s.m_p);\n}\n\n\n//析构函数的实现\n MyString::~MyString()\n {\n\t if (m_p != NULL)\n\t {\n\t\t delete[] m_p;\n\t\t m_p = NULL;\n\t\t m_len = 0;\n\t }\n }\n\n//下面进行的是操作符重载\n\t//等号=操作符重载\n MyString&MyString:: operator=(const char *p)\n\t{\n\t\t//用于实现s4 = \"s2222\"\n\t\t//因为s4已经分配内存，应该先将旧的内存空间删掉然后再分配新的\n\t\t\n\t\t//释放旧内存\n\t\tif (m_p != NULL)\n\t\t{\n\t\t\tdelete[] m_p;\n\t\t\tm_len = 0;\n\t\t}\n\n\t\t//分配新的内存\n\t\tif (p == NULL)\n\t\t{\n\t\t\tm_len = 0;\n\t\t\tm_p = new char[m_len + 1];\n\t\t\tstrcpy(m_p, \"\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_len = strlen(p);\n\t\t\tm_p = new char[m_len + 1];\n\t\t\tstrcpy(m_p, p);\n\t\t}\n\t\treturn *this;\n\t}\n\n\n\n MyString&MyString:: operator= (const MyString &s)\n\t{\n\t\t//用于实现s4 = s2\n\t\tif (m_p != NULL)\n\t\t{\n\t\t\tdelete[] m_p;\n\t\t\tm_len = 0;\n\t\t}\n\n\t\t//根据s分配新的内存\n\t\tm_len = s.m_len;\n\t\tm_p = new char[m_len + 1];\n\t\tstrcpy(m_p, s.m_p);\n\t\n\t\treturn *this;\n\t}\n\n\n\n char&MyString::operator[](int index)\n {\n\t return m_p[index];\n }\n\n\n //注意这个是全局函数，所以函数名前面不能加上MyString::  \n ostream& operator<<(ostream &out, MyString &s)\n {\n\t cout << s.m_p;\n\t return out;\n }\n\n\n\n //下面是实现==和!= 的重载，其中分为类和字符串的比较与类和类的比较\n bool MyString::operator==(const char *p)\n {\n\t if (p == NULL)\n\t {\n\t\t if (m_len == 0)\n\t\t {\n\t\t\t return true;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t return false;\n\t\t }\n\t }\n\t else\n\t {\n\t\t if (m_len == strlen(p))\n\t\t {\n\t\t\t return !strcmp(m_p, p);\n\t\t } \n\t\t else\n\t\t {\n\t\t\t return false;\n\t\t }\n\t }\n\t return true;\n }\n\n bool MyString::operator!=(const char *p)\n {\n\t return !(*this == p);\n }\n\n\n //两个类之间的比较\n bool MyString::operator==(const MyString&s)\n {\n\tif (m_len != s.m_len)\n\t{\n\t\treturn false;\n\t}\n\treturn !strcmp(m_p, s.m_p);\n }\n\n bool MyString::operator!=(const MyString &s)\n {\n\t return !(*this == s);\n }\n\n\n\n\n\n\n //实现  <  的重载\n\n int MyString::operator<(const char *p)\n {\n\t return strcmp(this->m_p, p);\n }\n int MyString::operator<(const MyString &s)\n {\n\t return strcmp(this->m_p, s.m_p);\n }"]],[51835,51835],[54141,54141]]],[1543759573989,["gjx16@GJXAIOU",[[1,54148,"\n"]],[54145,54145],[54146,54146]]],[1543759574541,["gjx16@GJXAIOU",[[1,54149,"\n"]],[54146,54146],[54147,54147]]],[1543759578025,["gjx16@GJXAIOU",[[1,54147,"hanshu"]],[54147,54147],[54153,54153]]],[1543759582971,["gjx16@GJXAIOU",[[-1,54147,"hanshu"]],[54153,54153],[54147,54147]]],[1543759586502,["gjx16@GJXAIOU",[[1,54147,"函数就调用"]],[54147,54147],[54152,54152]]],[1543759590112,["gjx16@GJXAIOU",[[-1,54149,"就调用"]],[54152,54152],[54149,54149]]],[1543759592432,["gjx16@GJXAIOU",[[1,54149,"调用"]],[54149,54149],[54151,54151]]],[1543759594363,["gjx16@GJXAIOU",[[1,54151,"实现："]],[54151,54151],[54154,54154]]],[1543759594951,["gjx16@GJXAIOU",[[1,54157,"\n"]],[54154,54154],[54155,54155]]],[1543759600111,["gjx16@GJXAIOU",[[1,54155,"```cppp"]],[54155,54155],[54162,54162]]],[1543759600732,["gjx16@GJXAIOU",[[1,54165,"\n"]],[54162,54162],[54163,54163]]],[1543759601337,["gjx16@GJXAIOU",[[1,54166,"\n"]],[54163,54163],[54164,54164]]],[1543759603414,["gjx16@GJXAIOU",[[1,54164,"```"]],[54164,54164],[54167,54167]]],[1543759614624,["gjx16@GJXAIOU",[[1,54163,"// 实现一个字符串类\n\n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串类 以零结尾的字符串\n\n//若len为0,表示空串\n\n#include \"iostream\"\n#include \"MyString.h\"\nusing namespace std;\n\n\nint main()\n{\n\tMyString s1;\n\tMyString s2(\"s2\");\n\tMyString s2_2 = NULL;\n\tMyString s3 = s2;\n\n\n\n\n\t//下面进行操作符重载\n\t//=操作符\n\t//两种调用方式；\n\tMyString s4 = \"adfdfdn\";\n\t\n\ts4 = \"s2222\"; \n\n\t//调用方式二；\n\ts4 = s2;\n\n\n\n\n//实现[]重载\n\ts4[1] = 'a';\n\tcout << \"s4[1] = \" << s4[1] << endl;\n\t//当[]当右值的时候\n\t\n\n//实现<<操作符的重载\n\tcout << s4 << endl;   //相当于实现字符串的整体输出\n\n\n\n//实现== 和!= 的重载\n\tMyString s5 = \"ahhhh\";\n\t\n\tif (s5 == \"shhsk\")\n\t{\n\t\tcout << \"相等\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"不相等\" << endl;\n\t}\n\n\tif (s5 != \"sjfddsj\")\n\t{\n\t\tcout << \"false\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"true\" << endl;\n\t}\n\t\n\t//两个类之间做判断\n\t\n\tif (s5 == s2)\n\t{\n\t\tcout << \"相等\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"不相等\" << endl;\n\t}\n\n\tif (s5 != s2)\n\t{\n\t\tcout << \"false\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"true\" << endl;\n\t}\n\n\n\n//实现大于小于号的符号重载\n\n\tMyString s6 = \"skdjfkld\";\n\tif (s6 < \"kdjfkdj\")\n\t{\n\t\tcout << \"s6 小于 skdjfkld\" << endl;\n\t} \n\telse\n\t{\n\t\tcout << \"s6 大于 skdjfkld\" << endl;\n\t}\n\n\n\tif (s6 < s5)\n\t{\n\t\tcout << \"s6 小于 s5\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"s6 大于 s5\" << endl;\n\t}\n\n\n\n\n\n\t//使用类中的private:的指针\n\n\tMyString s7 = \"jdkfjdklfjdl\";\n\tstrcpy(s7.c_str(), \"lskjdfkljdklf\");\n\tcout << s7 << endl;\n}\n"]],[54163,54163],[55419,55419]]]],null,"gjx16@GJXAIOU"],["93f21e9e-75db-407f-bafc-78eafee88c19",1543798649809,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁;\n   * c++面向对象模型初探;  \n   * c++面向对象多态原理探究;\n   * 操作符重载;\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;//定义两个对象c1和c2\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n};\n\n```\nTeacher.cpp\n//具体实现函数内容，在函数名前面加上`类名::`\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1:设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)//因为类的成员变量这里都是private:\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n###  (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n###  (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//需要重载=号操作符，才能解决带来的浅拷贝问题\n\n\tobj2 = obj3; //=号操作，也是一种浅拷贝\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++的默认copy构造函数是浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n\n---\n\n\n### （五）多个对象构造和析构\n\n**1.对象初始化列表**\n\n- 1）对象初始化列表出现原因\n程序本身是有问题的\n```cpp\n\n/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B   //在一个类里面组合了一个带有参数的构造函数的类，因为C++编译器要确定分配给B多大的内存，但是没法初始化A定义的两个对象（因为需要调用有参的构造函数）\n{\npublic:   //没有写B的构造函数，按理说应该调用默认的构造函数\n\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  //主要是因为没有方法和没有机会去初始化这两个A定义的对象\n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB;\n\treturn 0;\n\n}\n\n```\n\n解决方法：\n```cpp\n/*\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n};\n\n\nclass B  \n{\npublic:   \n//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）\n\tB(int _a, int _b) : a1(1), a2(3)  \n\t{\n\n\t}\n//第二种参数传递的方法：\n/*\nB(int _a, int _b,int m,int n) : a1(m), a2(n)  \n\t{\n      a = _a;\n      b = _b;\n\t}\n\t\n*/\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  \n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB(1,2);\n\t//第二种方式：B objB(1,2,4,3)\n\treturn 0;\n\n}\n\n```\n\n**以上程序的操作顺序：**\n首先执行被组合对象的构造函数（a1,a2），如果有多个组合对象，则按照定义的顺序，而不是按照初始化列表的顺序（：后面的顺序）\n析构函数：和构造函数的调用顺序相反\n\n  - 1.必须这样做：\n    - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    - 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n  - 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    - 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    - 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n- 2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n```cpp\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n{\n // some other assignment operation\n}\n```\n\n\n- 3）注意概念\n  - 初始化：被初始化的对象正在创建\n  - 赋值：被赋值的对象已经存在\n\n- 4）注意：\n  - 成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n  - 初始化列表先于构造函数的函数体执行\n\n**说明：**\n\n* 1 C++中提供了初始化列表对成员变量进行初始化\n* 2 使用初始化列表出现原因：\n  * 1.必须这样做：\n    * 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n    * 而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    * 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n  * 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    * 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    * 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n```cpp\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n ABC(int a, int b, int c)\n {\n this->a = a;\n this->b = b;\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"ABC construct ..\\n\");\n }\n\n ~ABC()\n {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n }\n\nprotected:\nprivate:\n int a;\n int b;\n int c;\n};\n\nclass MyD\n{\npublic:\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n {\n cout<<\"MyD()\"<<endl;\n }\n\n ~MyD()\n {\n cout<<\"~MyD()\"<<endl;\n }\n\nprotected:\nprivate:\n ABC abc1; //c++编译器不知道如何构造abc1\n ABC abc2;\n const int m;\n};\n\nint run()\n{\n MyD myD;\n return 0;\n}\n\nint main_dem03()\n{\n run();\n system(\"pause\");\n return 0;\n}\n\n```\n\n\n\n\n### （六）构造函数和析构函数的调用顺序研究\n\n**构造函数与析构函数的调用顺序**\n\n- 1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n- 2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n### （七）构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1构造析构综合训练**\n```cpp\n\n/*\n\n总结 构造和析构的调用顺序\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n\tABC(int a, int b, int c)   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\n\t}\n\n\t~ABC()\n\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\n\nclass MyD \n{\npublic:\n\tMyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~MyD()\n\t{\n\t\tcout << \"~MyD()\" << endl;\n\t}\n\n\tMyD(const MyD & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\tcout << \"MyD(const MyD &obj)\" << endl;\n\t}\n\nprotected:\nprivate:\n\tABC abc1; //c++编译器不知道如何构造abc1//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\tABC abc2;\n\tconst int m;//因为是const m,所以上面所有的m都进行了赋值\n};\n\n\nint doThing(MyD myel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;\n}\n\n\nint run2()//二\n{\n\tMyD myD;//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\treturn 0;\n}\n\nint run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main()\n{\n\trun2();//一\n\t//run3();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n\n\n```\n\n\n**2匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3匿名对象强化训练**\n\n3） 构造中调用构造\n\n```cpp\n/*\n\n构造中调用构造\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass MyTest\n{\npublic:\n\tMyTest(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t}\n\n\tMyTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\n\t\tMyTest(a, b, 10);\n\t}\n\n\t~MyTest()\n\t{\n\t\tcout << \"MyTest is ...\" << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n\n\npublic:\n\tint getC() const { return c; }\n\n\tvoid setC(int val) { c = val; }\n};\n\nint main()\n{\n\tMyTest t1(1, 2);\n\tcout << t1.getC() << endl;\n\tsystem(\"pause\");\n\treturn 0;\n\t\n}\n\n\n```\n\n 结论： 构造函数中调用构造函数，是一个蹩脚的行为。\n程序内存图：\n![搜狗截图20181124125452]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181124125452.png)\n\n### （八）对象的动态建立和释放\n\n**1.new和delete基本语法**\n```cpp\n/*\n\nnew 和delete的使用\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nvoid main()\n{\n\t//先分配内存然后赋值\n\tint *p = new int;  //分配基础类型\n\t*p = 20;  \n\n\t//在定义的时候直接分配内存\n\tint *p1 = new int(30);\n\tcout << *p1 << endl;\n\n\tsystem(\"pause\");\n\treturn; \n}\n\n```\n\n- 1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n  **注意： new和delete是运算符，不是函数，因此执行效率高。**\n\n- 2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： \nnew int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 \nnew char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址    new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n- 3）new和delete运算符使用的一般格式为：\n  用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n![new运算符动态]($resource/new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%A8%E6%80%81.png)\n```cpp\n\n/*\n使用malloc /free 与new /delete的区别\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest();\n\t~Test();\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\nTest::Test()\n{\n\tcout << \"执行了构造函数\" << endl;\n}\n\nTest::~Test()\n{\n\tcout << \"执行了析构函数\" << endl;\n}\n\n\n\nint main()\n{\n\t//基础类型\n\tint *p1 = (int *)malloc(sizeof(int));\n\t*p1 = 10;\n\tdelete p1;\n\n\tint *p2 = new int;\n\t*p2 = 20;\n\tfree(p2);\n\n\n\n\t//数组类型（元素为基础类型）\n\tint *p3 = (int *)malloc(sizeof(int)*10);\n\tp3[0] = 1;\n\tdelete[]p3;\n\n\tint *p4 = new int[10];\n\tp4[1] = 2;\n\tfree(p4);\n\n\n\t//类\n\tTest *p5 = (Test *)malloc(sizeof(Test));\n\tdelete p5;\n\n\tTest *p6 = new Test(10);\n\tfree(p6);\n}\n\n\n```\n**结论：** \nnew：不仅分配内存，而且调用了构造函数\ndelete:不仅释放了内存，而且调用了析构函数\n\n- 4） 应用举例\n\n![5]($resource/5.png)\n\n**2类对象的动态建立和释放**\n\n- 使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n-  C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n  比如：\n\n  Box *pt;  //定义一个指向Box类对象的指针变量pt\n      pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n   这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n  新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n   在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3.编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n\n\n\n## 四、静态成员变量和成员函数\n\n\n思考：每个变量，拥有属性。有没有一些属性，归所有对象拥有？\n\n### （一）静态成员变量\n\n- **1定义静态成员变量**\n  - 关键字 **static**  可以用于说明一个类的成员，\n    静态成员提供了一个同类对象的共享机制\n\n  - 把一个类的成员说明为 **static**  时，这个类无论有多少个对象被创建，这些对象共享这个 **static**  成员\n\n  - 静态成员局部于类，它不是对象成员\n\n![1]($resource/1.png)\n\n例如：\n\n```cpp\n\n/*\n静态成员变量\n*/\n\n#include<iostream>\nusing namespace std;\n\nclass counter\n{\n\n\tstatic int num; //**声明与定义静态数据成员**\n\npublic:\n\n\tvoid setnum(int i) \n\t{ \n\t\tnum = i; \n\t} //成员函数访问静态数据成员\n\n\tvoid shownum() \n\t{ \n\t\tcout << num << endl;\n\t}\n\n};\n\nint counter::num = 0;//声明与定义静态数据成员\n\nvoid main()\n{\n\tcounter a, b;\n\n\ta.shownum(); //调用成员函数访问私有静态数据成员\n\tb.shownum();\n\ta.setnum(10);\n\ta.shownum();\n\tb.shownum();\n\n}\n\n```\n\n![6]($resource/6.png)\n\n**从结果可以看出，访问的是同一个静态数据成员**\n\n- **2使用静态成员变量**\n```cpp\n//例5-14_使用公有静态数据成员\n\n#include<iostream.h>\n\nclass counter\n{ \npublic :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n\n```\n使用静态成员函数调用静态成员变量\n```cpp\n/*\n静态成员函数\n*/\n// 结论：在静态成员函数中可以使用静态成员变量，但是不能使用类中普通的成员变量\n\n#include\"iostream\"\nusing namespace std;\n\nclass BB\n{\npublic:\n\tint printC()\n\t{\n\t\tcout << \"c:\" << c << endl;\n\t\treturn c;\n\t}\n\n\tint addC()\n\t{\n\t\tc = c+1;\n\t}\n\n\n\tstatic void getC()\n\t{\n\t\tcout << \"c\" << c << endl;  //可以直接在静态成员函数中使用静态成员变量，但是不能直接使用一般变量\n\t}\nprivate:\n\tint a;\n\tint b;\n\tstatic int c;\n\n};\n\n\nint BB::c = 10;  //初始化成员变量值\n\nvoid main()\n{\n\tBB b1, b2, b3;\n\tb1.printC();//10\n\tb2.addC();//11\n\tb3.printC();//11\n\n\t//调用成员函数两种方法；\n\tb3.getC();//使用对象.\n\tBB::getC();//使用类::\n\n\n\n}\n\n```\n\n### (二)静态成员函数\n\n- **1）概念**\n\n  - 静态成员函数数冠以关键字static\n\n  - 静态成员函数提供不依赖于类数据结构的共同操作，它没有this指针\n  - 在类外调用静态成员函数用 `_类名_ ::`作限定词，或通过对象调用\n\n- **2）案例**\n![7]($resource/7.png)\n\n- **3）疑难问题：**\n静态成员函数中，不能使用普通变量。\n//静态成员变量属于整个类的，分不清楚，是那个具体对象的属性。\n![成员函数中的疑难问题]($resource/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98.png)\n\n**4.3 综合训练**\n\n\n\n## 五、 C++面向对象模型初探\n\n**前言**\n\n- C++对象模型可以概括为以下2部分：\n\n  - 1. 语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等等。\n\n  - 2. 对于各种支持的底层实现机制。\n\n  在c语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。在c++中，通过抽象数据类型（abstract data type，ADT），在类中定义数据和函数，来实现数据和函数直接的绑定。\n\n  概括来说，在C++类中有两种成员数据：static、nonstatic；三种成员函数：static、nonstatic、virtual。\n\n![C++类的组成]($resource/C++%E7%B1%BB%E7%9A%84%E7%BB%84%E6%88%90.png)\n\n### （一）基础知识\n\nC++中的class从面向对象理论出发，将变量(属性)和函数(方法)集中定义在一起，用于描述现实世界中的类。从计算机的角度，程序依然由数据段和代码段构成。\n\n**C++编译器如何完成面向对象理论到计算机程序的转化？**\n换句话：C++编译器是如何管理类、对象、类和对象之间的关系\n具体的说：具体对象调用类中的方法，那，c++编译器是如何区分，是那个具体的类，调用这个方法那?\n\n思考一下程序结果\n```cpp\n/*\n面向对象模型初探\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass C1\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\nprotected:\n\nprivate:\n\n}; //12\n\nclass C2\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\n\tstatic int m; \n\npublic:\n\n\tint getK() const { return k; } //方法是属于代码，应该放在代码区\n\tvoid setK(int val) { k = val; } \n\nprotected:\n\nprivate:\n}; \n\nstruct S1\n{\n\tint i;\n\tint j;\n\tint k;\n}; \n\nstruct S2\n{\n\tint i;\n\tint j;\n\tint k;\n\tstatic int m;\n}; \n\nint main()\n{\n\n\tprintf(\"c1:%d \\n\", sizeof(C1));\n\tprintf(\"c2:%d \\n\", sizeof(C2));\n\tprintf(\"s1:%d \\n\", sizeof(S1));\n\tprintf(\"s2:%d \\n\", sizeof(S2));\n\tsystem(\"pause\");\n\n}\n```\n程序运行结果：\n`c1:12`\n`c2:12`\n`s1:12`\n`s2:12`\n\n \n### (二)编译器对属性和方法的处理机制\n\n通过上面的案例，我们可以的得出：\n1）C++类对象中的成员变量和成员函数是分开存储的\n- 成员变量：\n  - 普通成员变量：存储于对象中，与struct变量有相同的内存布局和字节对齐方式\n  - 静态成员变量：存储于全局数据区中\n\n- 成员函数：存储于代码段中。\n问题出来了：很多对象共用一块代码？代码是如何区分具体对象的那？\n换句话说：int getK() const { return k; }，代码是如何区分，具体obj1、obj2、obj3对象的k值？\n\n2）C++编译器对普通成员函数的内部处理\n\n![C++编译器对普通成员函数的内部处理]($resource/C++%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E9%83%A8%E5%A4%84%E7%90%86.png)\n\n请仔细思考，并说出你的总结！\n\n\n\n### （三）总结\n\n1、C++类对象中的成员变量和成员函数是分开存储的。C语言中的内存四区模型仍然有效！\n**2、C++中类的普通成员函数都隐式包含一个指向当前对象的this指针。**\n3、静态成员函数、成员变量属于类\n\n静态成员函数与普通成员函数的区别\n\n静态成员函数不包含指向具体对象的指针\n\n普通成员函数包含一个指向具体对象的指针\n\n\n### （四）this指针\n\n![this指针图示]($resource/this%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png)\n\n实验1：若类成员函数的形参 和 类的属性（成员变量）名字相同，通过this指针来解决。\n```cpp\n\n/*\nthis 指针\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass Test\n{\npublic:\n\tTest( int a, int b)//Test(Test *this, int a, int b)//因为这里成员函数的形参和成员变量一样，不用this指针会出现：a = a ,b = b;\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printT()\n\t{\n\t\tcout << \"a; \" << a << endl;\n\t\tcout << \"b: \" << this->b << endl;\n\t}\n\n\n    const void hello(int a,int b )\n    {\n      //下面这两个语句都是错误的\n      this->a = 100;\n      this ->b = 200;\n    }\n   //const修饰的this指针，即相当于this指针指向的内存空间不能被修改\n   //因为上面的函数会别C++编译器解析为:void hello(const Test *this, int a ,int b)\n   //同时上面的const其实下载函数（）外面的任何位置都行\n   \nprotected:\nprivate:\n\tint a;\n\tint b;\n};\nint  main()\n{\n\tTest t1(1, 2);\n\tt1.printT();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`a:1`\n`b:2`\n\n\n实验2：类的成员函数可通过const修饰，请问const修饰的是谁\n\n\n### （五）全局函数PK成员函数\n\n 1、把全局函数转化成成员函数，通过this指针隐藏左操作数\n\n   Test add(Test &t1, Test &t2)===》Test add( Test &t2)\n```cpp\n/*\n全局函数与成员函数\n*/\n\n\n//使用全局函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\t\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nTest Testadd(Test &t1, Test &t2)\n{\n\tTest tmp(3,4);\n\treturn tmp;\n}\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3(2, 3);\n\tt3= Testadd(t1, t2);\n}\n```\n\n```cpp\n//使用成员函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\tTest Testadd(Test &t2)\n\t{\n\t\tTest tmp(this->a + t2.a, this->b + t2.b);\n\t\treturn tmp;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3 = t1.Testadd(t2);//匿名对象直接转化成t4\n\tTest t4(3,5);\n\tt4 = t1.Testadd(t2);  //匿名对象复制给t5\n}\n\n\n```\n 2、把成员函数转换成全局函数，多了一个参数\n\n   void printAB()===》void printAB(Test *pthis)\n\n 3、函数返回元素和返回引用\n```cpp\nTest& add(Test &t2) //*this //函数返回引用,相当于返回自身，谁调用返回谁\n {      \n   this->a = this->a + t2.getA();\n\n   this->b = this->b + t2.getB();\n\n   return *this; //*操作让this指针回到元素状态\n\n }\n\nTest add2(Test &t2) //*this //函数返回元素\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n return t3;\n\n }\n\n void add3(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n //return t3;\n\n }\n  \n\n```\n\n\n\n\n---\n\n## 六、友元\n\n### （一）友元函数\n- 首先友元函数是全局函数，在友元函数中可以修改类的私有属性；\n- 友元函数在类中的声明位置位于public或者private只下均可；\n![8]($resource/8.png)\n\n```cpp\n//友元函数：\n\n#include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend void modify(A *PA,int _a);  //友元函数的声明\n\n\tA(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\n\nprivate:\n\tint a;\n\tint b;\n};\n\nvoid modify(A *PA,int _a)//后面的参数可加可不加\n{\n\t//PA->a = 100;//可以这样直接修改值\n\tPA->a = _a;  //通过传递的值进行修改\n}\n\n\nint main()\n{\n\tA a1(1, 2);\n\tcout << \"a:\" << a1.getA() << endl;\n\tmodify(&a1,20);\n\n\tint aa = a1.getA();\n\n\tcout << \"aa:\" << aa << endl;\n}\n```\n![9]($resource/9.png)\n\n\n### （二）友元类\n\n- 若B类是A类的友员类，则B类的所有成员函数都是A类的友员函数\n- 若B类是A类的友元类，则B类可以直接修改A的成员变量和成员函数\n- 友员类通常设计为一种对数据操作或类之间传递消息的辅助类\n程序示例：\n```cpp\n//友元类\n #include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend class B;//将B 声明为A的友元类，这样B 可以直接修改A的成员变量和成员函数 \n\n\tA(int a=0, int b=0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B\n{\npublic:\n\n\tvoid set(int a)\n\t{\n\t\tobjA.a = a;\n\t}\n\n\tvoid printa()\n\t{\n\t\tcout << objA.a << endl;\n\t}\n\nprivate:\n\tA objA;\n};\n\n\nint main()\n{\n\tB b1;\n\tb1.set(200);\n\tb1.printa();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：200\n\n![10]($resource/10.png)\n\n\n\n## 七、强化训练\n\n**1 static关键字强化训练题**\n\n某商店经销一种货物。货物购进和卖出时以箱为单位，各箱的重量不一样，因此，商店需要记录目前库存的总重量。现在用C++模拟商店货物购进和卖出的情况。\n```cpp\n#include \"iostream\"\nusing namespace std;\n\nclass Goods\n{\npublic:\n\n\tGoods(int w) { weight = w; total_weight += w; }\n\n\t~Goods() { total_weight -= weight; }\n\n\tint Weight() { return weight; };\n\n\tstatic int TotalWeight() { return total_weight; }\n\n\tGoods *next;\n\nprivate:\n\n\tint weight;\n\tstatic int total_weight;\n\n};\n\nint Goods::total_weight = 0;\n\n//r尾部指针\n\nvoid purchase(Goods * &f, Goods *& r, int w)\n{\n\n\tGoods *p = new Goods(w);\n\n\tp->next = NULL;\n\n\tif (f == NULL) f = r = p;\n\n\telse { r->next = p; r = r->next; } //尾部指针下移或新结点变成尾部结点\n\n}\n\nvoid sale(Goods * & f, Goods * & r)\n{\n\n\tif (f == NULL) { cout << \"No any goods!\\n\"; return; }\n\n\tGoods *q = f; f = f->next; delete q;\n\n\tcout << \"saled.\\n\";\n\n}\n\nvoid main()\n{\n\tGoods * front = NULL, *rear = NULL;\n\n\tint w; int choice;\n\n\tdo\n\t{\n\t\tcout << \"Please choice:\\n\";\n\n\t\tcout << \"Key in 1 is purchase,\\nKey in 2 is sale,\\nKey in 0 is over.\\n\";\n\n\t\tcin >> choice;\n\n\t\tswitch (choice) // 操作选择\n\t\t{\n\t\tcase 1: // 键入1，购进1箱货物\n\t\t{ cout << \"Input weight: \";\n\t\tcin >> w;\n\n\t\tpurchase(front, rear, w); // 从表尾插入1个结点\n\n\t\tbreak;\n\t\t}\n\n\t\tcase 2:              // 键入2，售出1箱货物\n\t\t{ sale(front, rear); break; } // 从表头删除1个结点\n\n\t\tcase 0: break;              // 键入0，结束\n\t\t}\n\n\t\tcout << \"Now total weight is:\" << Goods::TotalWeight() << endl;\n\n\t} while (choice);\n}\n```\n**2** **数组类封装**\n\n目标：解决实际问题，训练构造函数、copy构造函数等，为操作符重载做准备\n\n数组类的头文件:`Array.h`\n```cpp\n#pragma once\nclass Array\n{\npublic:\n\tArray(int length);\n\tArray(const Array&obj);\n\t~Array();\npublic:\n\tint length();\n\n\tvoid setData(int index, int value);\n\n\tint getData(int index);\nprivate:\n\tint m_length;\n\tchar *m_space;\n};\n```\n\n数组类的头文件的实现：`Array.cpp`\n```cppp\n#include \"Array.h\"\nusing namespace std;\n#include\"iostream\"\n\nArray::Array(int length)\n{\n\tif (length < 0)\n\t{\n\t\tlength = 0;\n\t}\n\telse\n\t{\n\t\tm_length = length;\n\t\tm_space = new char[m_length];\n\t}\n}\n\nArray::Array(const Array&obj)\n{\n   this->m_length = obj.m_length;\n   this->m_space = new char [this->m_length];//进行分配内存空间\n\n  for(int i= 0; i < obj.m_length;i++)//数组元素复制， 这里的obj.m_length可以直接替换成m_length\n  {\n    this->m_space[i] = obj.m_space[i];\n  }\n}\n\nArray::~Array()\n{\n\tif (m_space != NULL)\n\t{\n\t\tdelete[] m_space;\n\t\tm_length = 0;\n\t}\n}\n\nvoid Array::setData(int index, int valude)\n{\n\tm_space[index] = valude;\n}\n\nint Array::getData(int index)\n{\n\treturn m_space[index];\n}\n\nint Array::length()\n{\n\treturn m_length; \n}\n```\n\n数组类的测试\n```cpp\n#include \"iostream\"\n#include \"Array.h\"\nusing namespace std;\n\nint main()\n{\n\tArray a1(10);\n\tfor (int i = 0; i < a1.length(); i++)\n\t{\n\t\ta1.setData(i, i);\n\t}\n\tfor (int i = 0; i <  a1.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a1.getData(i));\n\t}\n\n\tArray a2 = a1;\n\n\tfor (int i = 0; i < a2.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a2.getData(i));\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**3.小结**\n\n* 类通常用关键字class定义。类是数据成员和成员函数的封装。类的实例称为对象。\n* 结构类型用关键字struct定义，是由不同类型数据组成的数据类型。\n* 类成员由private, protected, public决定访问特性。public成员集称为接口。\n* 构造函数在创建和初始化对象时自动调用。析构函数则在对象作用域结束时自动调用。\n* 重载构造函数和复制构造函数提供了创建对象的不同初始化方式。\n* 静态成员是局部于类的成员，提供一种同类对象的共享机制。\n* 友员用关键字friend声明。友员是对类操作的一种辅助手段。一个类的友员可以访问该类各种性质的成员\n* 链表是一种重要的动态数据结构，可以在程序运行时创建或撤消数据元素。\n\n\n\n---\n\n\n## 八、运算符重载\n\n### （一）概念\n\n#### **1.什么是运算符重载**\n\n![11]($resource/11.png)\n所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是”一名多用”。\n\n运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重载。例如，大 家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行加法运算，如5+8， 5.8 +3.67等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的， 但由于C++已经对运算符”+”进行了重载，所以就能适用于int, float, doUble类型的运算。\n\n又如`<<`是C的位运算中的位移运算符（左移），但在输出操作中又是与流对 象cout 配合使用的流插入运算符，`>>`也是位移运算符(右移），但在输入操作中又是与流对象 cin 配合使用的流提取运算符。这就是运算符重载(operator overloading)。C系统对`<<`和`>>`进行了重载，用户在不同的场合下使用它们时，作用是不同 的。对`<<`和`>>`的重载处理是放在头文件stream中的。因此，如果要在程序中用`<<`和`>>`作流插入运算符和流提取运算符，必须在本文件模块中包含头文件stream(当然还应当包括”using namespace std“)。\n\n现在要讨论的问题是：用户能否根据自己的需要对C++已提供的运算符进行重载，赋予它们新的含义，使之一名多用？\n\n#### **2.运算符重载入门技术推演**\n\n1为什么会用运算符重载机制\n//原因 Complex是用户自定义类型，编译器根本不知道如何进行加减，但是编译器给提供了一种机制，让用户自己去完成，自定义类型的加减操作。。。这个机制就是运算符重载机制\n\n用复数类举例，定义一个Complex类,有两个对象，每个对象由两个属性，要求使用对象之间的加法实现对应属性的相加，示例程序如下：\n```cpp\n\n/*对于基础数据类型，C++编译器知道如何进行运算，但是对于用户自定义的类型编译器提供了一种\n让自定义数据类型进行运算符操作的机制,=》运算符重载机制\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\npublic:\n\tfriend Complex operator+(Complex &c1, Complex &c2);//友元函数声明\n\n\tComplex(int a = 0, int b = 0)//构造函数\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\nprivate:\n  int a;\n  int b;\n};\n\n/*使用全局函数，通过调用全局函数实现\nComplex myAdd(Complex &c1, Complex &c2)\n{\n Complex tmp(c1.a+ c2.a, c1.b + c2.b);\n\n return tmp;\n}\n*/\n\n\n//可以简单的想象为将上面全局函数的函数名替换为operator+\nComplex operator+(Complex &c1, Complex &c2)\n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\treturn tmp;\n}\n\n\n\nint  main()\n{\n\tComplex c1(1, 2), c2(3, 4);\n\n\t//方法1： 通过调用普通函数实现\n\t//Complex c3 = myAdd(c1, c2);\n\t//c3.printCom();\n\n\n\t//方法2  将函数名称替换为：operator+ \n\t//使用以下方式进行调用\n\t//Complex c3 = operator+(c1, c2);\n\t//c3.printCom();\n\n\n\t//方法3：最常用的调用方式\n\tComplex c3 = c1 + c2; \n\tc3.printCom()\n\n\tsystem(\"pause\");\n\treturn;\n}\n```\n程序运行结果：`4+6i`\n\n\n---\n\n### （二）运算符重载的限制\n![12]($resource/12.png)\n\n重载运算符函数可以对运算符进行新的解释，但是原有的基本语义不变：\n* 不改变运算符的优先级\n* 不改变运算符的结合性\n* 不改变运算符所需要的操作数\n* 不能创建新的运算符\n\n---\n\n### （三）运算符重载编程基础\n![14]($resource/14.png)\n例如:\n   //全局函数  完成 +操作符  重载  \n    Complex operator+(Complex &c1, Complex &c2)\n\n  //类成员函数  完成 -操作符  重载\n    Complex operator-(Complex &c2)\n\n#### **1.运算符重载的两种方法:**\n- 运算符可以重载为成员函数了或者友元函数\n- 关键区别在于成员函数具有this指针，友元函数没有this 指针\n- 不管是成员函数还是友元函数重载，运算符的使用方法相同\n- 但是两种的传递参数不同，实现代码也不同，应用场合也不同\n\n- **二元操作符重载的实现：**\n![16]($resource/16.png)\n \n```cpp\n//二元函数操作符的重载的两种方法\n\n\n/*全局函数、类成员函数方法实现运算符重载步骤\n1）要承认操作符重载是一个函数，写出函数名称operator + ()\n2）根据操作数，写出函数参数\n3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex operator+(Complex &c1, Complex &c2); //这里是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\t//成员函数实现 - 运算符重载 \n\tComplex operator-(Complex &c2)//因为是c1调用的，因此这里的this 指向c1\n\t{\n\t\tComplex tmp(this->a - c2.a, this->b -  c2.b);//通过构造函数实现 tmp中成员变量的变化 \n\t\treturn tmp;\n\t}\n\n};\n\n\n//使用全局函数实现  + 运算符重载\nComplex operator+(Complex &c1, Complex &c2)\n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\n\treturn tmp;\n}\n\n\nint  main()\n{\n\tComplex c1(1, 2), c2(3, 4);\n\n\t//使用 全局函数\n\tComplex c3 = c1 + c2;\n\tc3.printCom();\n\n\t//使用成员函数\n\tComplex c4 = c1.operator-(c2);\n\tc4.printCom();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`4 + 6i`\n`-2 + -2i`\n\n\n- **一元函数操作符重载的实现：**\n![17]($resource/17.png)\n\n- 实现前置++和前置--\n```cpp\n//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现前置++和前置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex& operator++(Complex &c1); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\tComplex& operator--()\n\t{\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn *this;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  + 运算符重载\nComplex& operator++(Complex &c1)\n{\n\tc1.a++;\n\tc1.b++;\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1,c2;\n\n\t//使用全局函数实现前置++操作符的重置\n\t++c1;\n\tc1.printCom();\n\n\n\t//使用成员函数实现前置--操作符的重置\n\t--c2;\n\tc2.printCom();\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`1 + 1i`\n`-1 + -1i`\n\n- 实现后置++和后置--\n```cpp\n//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现后置++ 和后置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex operator++(Complex &c1, int); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\t//成员函数实现后置--\n\tComplex operator--(int)\n\t{\n\t\tComplex tmp = *this;\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn tmp;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  ++ 运算符重载\nComplex operator++(Complex &c1,int)  //为了和前置++的函数能够共同存在，参数中加了一个占位符从而实现函数重载\n{\n\t//前置++是先使用后++ ，所以应该先返回c1,但是直接使用return c1.会造成程序的直接退出，后面的++无法实现，所以使用临时变量\n\n\tComplex tmp = c1;\n\tc1.a++;\n\tc1.b++;\n\treturn tmp;\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1, c2;\n\t//使用全局函数实现后置++操作符的重置\n\tc1++;\n\tc1.printCom();\n\n\t//使用成员函数实现后置--操作符的重置\n\tc2--;\n\tc2.printCom();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n\n**前置和后置运算符总结:**\n\nC++中通过一个占位参数来区分前置运算和后置运算\n![18]($resource/18.png)\n\n\n\n#### **2.定义运算符重载函数名的步骤**\n首先写运算符重载函数的调用，然后根据调用的形式写具体的函数实现；\n**一般情况下函数重载使用成员函数实现**\n全局函数、类成员函数方法实现运算符重载步骤\n * 1）要承认操作符重载是一个函数，写出函数名称operator+ ()\n * 2）根据操作数，写出函数参数\n * 3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n\n#### **3.友元函数实现操作符重载的应用场景**\n\n**1）友元函数和成员函数选择方法**\n- 当无法修改左操作数的类时，使用全局函数进行重载,因为成员函数需要在左边的类中进行修改；\n- =, [], ()和->操作符只能通过成员函数进行重载\n\n**2）用友元函数重载 <<和 >>操作符**\n\n* istream 和 ostream 是 C++ 的预定义流类，都不让修改的222222222222222222222222222222222222222222222\n* cin 是 istream 的对象，cout 是 ostream 的对象\n* 运算符 << 由ostream 重载为插入操作，用于输出基本类型数据\n* 运算符 >> 由 istream 重载为提取操作，用于输入基本类型数据\n* 用友员函数重载 << 和 >> ，输出和输入用户自定义的数据类型\n\na）用全局函数方法实现 << 操作符\n```pp\n//实现<<运算符的重载\n\n//注释内部是一套完整的程序，但是只能实现一次打印输出，新的一套程序可以实现链式输出\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\t//friend  void operator<<(ostream &cout, Complex &c1); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n};\n\n/*这里类似于cout只能有全局函数加上友元函数实现，因为如果要使用成员函数实现，需要在cout 的类：ostream中定义成员函数，\n但是这个ostream类是系统隐藏的，不现实；\nvoid operator<<(ostream &cout, Complex &c1)\n{\n\tcout << c1.a << \" + \" << c1.b << \"i\" << endl;\n}\n*/\n\nostream& operator<<(ostream &cout, Complex &c2)  //要想实现函数返回值当左值，需要返回一个引用\n{\n\tcout << c2.a << \" + \" << c2.b << \"i\" << endl;\n\treturn cout;\n}\n\n\n \nint  main()\n{\n\tComplex c1, c2;\n\t//cout << c1;  //实现将c1中两个元素以a+bi的形式直接打印输出；\n\t/*\n\t首先承认运算符重载是函数，所以函数名为：operator<<\n\t其次因为有左右参数，分别为ostream 和Complex类，所有函数头为：operator<<(ostream&cout,Complex c1)\n\t然后根据返回值确定最前面的返回值类型\n\t*/\n\n\tcout << c2 << \"kdjfkdjfkd\";\n\t//因为<<操作符是从左到右，所以左边执行返回值要当左值再次执行这个函数\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n**3）友元函数重载操作符使用注意点**\n\n- a） 友员函数重载运算符常用于运算符的左右操作数类型不同的情况\n![19]($resource/19.png)\n- b）其他\n  - 在第一个参数需要隐式转换的情形下，使用友员函数重载运算符是正确的选择\n  - 友员函数没有 this 指针，所需操作数都必须在参数表显式声明，很容易实现类型的隐式转换\n  - C++中不能用友员函数重载的运算符有\n     = （）  ［］  －>\n\n**4）友元函数案例vector类**\n```cpp\n#include <iostream>\nusing namespace std;\n\n//为vector类重载流插入运算符和提取运算符\n\nclass vector\n{\npublic:\n\tvector(int size = 1);\n\n\t~vector();\n\n\tint & operator[](int i);\n\n\tfriend ostream & operator << (ostream & output, vector &);\n\n\tfriend istream & operator >> (istream & input, vector &);\n\nprivate:\n\tint * v;\n\n\tint len;\n\n};\n\nvector::vector(int size)\n{\n\tif (size <= 0 || size > 100)\n\t{\n\t\tcout << \"The size of \" << size << \" is null !\\n\"; abort();\n\t}\n\n\tv = new int[size]; len = size;\n}\n\nvector :: ~vector()\n{\n\tdelete[] v;\n\n\tlen = 0;\n}\n\nint &vector::operator[](int i)\n{\n\tif (i >= 0 && i < len) return v[i];\n\n\tcout << \"The subscript \" << i << \" is outside !\\n\"; abort();\n}\n\nostream & operator << (ostream & output, vector & ary)\n{\n\tfor (int i = 0; i < ary.len; i++)\n\t\toutput << ary[i] << \" \";\n\n\toutput << endl;\n\treturn output;\n}\n\nistream & operator >> (istream & input, vector & ary)\n{\n\tfor (int i = 0; i < ary.len; i++)\n\t\tinput >> ary[i];\n\n\treturn input;\n}\n\nvoid main()\n{\n\tint k;\n\tcout << \"Input the length of vector A :\\n\";\n\tcin >> k;\n\tvector A(k);\n\tcout << \"Input the elements of vector A :\\n\";\n\tcin >> A;\n\tcout << \"Output the elements of vector A :\\n\";\n\tcout << A;\n\tsystem(\"pause\");\n}\n\n```\n\n### （四）运算符重载提高\n\n#### **1.运算符重载机制**\n\nC++编译器是如何支持操作符重载机制的?\n\n#### **2.重载赋值运算符=**\n\n* 赋值运算符重载用于对象数据的复制\n* operator= 必须重载为成员函数\n* 重载函数原型为：\n  类型&类名:: operator= ( const  类名 & ) ;\n\n案例：完善Name类，支持=号操作。\n![22]($resource/22.png)\n\n  结论:\n 1 先释放旧的内存\n 2 返回一个引用\n 3 =操作符 从右向左\n```cpp\n//重载 = 操作符\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\t//obj3 = obj1; // C++编译器提供的  等号操作  也属  浅拷贝\\\n\t// obj4 = obj3 = obj1//如果要是实现这种连续的赋值，需要函数返回一个引用\n\t//obj3.operator=(obj1)//这种是成员函数的调用方法\n\n//具体的实现步骤，先释放obj3的内存,后根据obj1进行分配内存大小，最后将obj1赋值给obj3\n\tName& operator=(Name &obj1)\n\t{\n\t\t//1 先释放obj3旧的内存\n\n\t\tif (this->pName != NULL)\n\t\t{\n\t\t\tdelete[] pName;\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\t//2 根据obj1分配内存大小\n\n\t\tthis->size = obj1.size;\n\t\tthis->pName = new char[size + 1];\n\n\t\t//3把obj1赋值给obj3\n\n\t\tstrcpy(pName, obj1.pName);\n\t\treturn *this;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nint main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n\n#### **3.重载数组下表运算符[]** ==这里的视频再看一遍==\n- 重载[]和()运算符\n  - 运算符 [] 和 () 是二元运算符\n  - [] 和 () 只能用成员函数重载，不能用友元函数重载\n\n- 重载下标运算符 []\n  - [] 运算符用于访问数据对象的元素\n  重载格式：  返回值类型 类 :: operator[] ( 类型 ) ；\n###   设 x 是类 X 的一个对象，则表达式 `x[y]` 可被解释为  `x.operator[](y)`\n- 两种使用方法：\n  - 返回值当右值，相当于返回一个元素；\n  - 返回值当左值，相当于返回一个引用；\n  \n![33]($resource/33.png)\n![44]($resource/44.png)\n\n\n#### **4.重载函数调用符()**\n\n() 运算符用于函数调用\n\n重载格式:  返回值类型 类:: operator() ( 表达式表 ) ；\n\n例1\n设 x是类 X的一个对象，则表达式*\nx ( arg1, arg2, … )\n可被解释为\nx . operator () (arg1, arg2, … )\n\n**案例：**\n例2：用重载()运算符实现数学函数的抽象\n```cpp\n#include <iostream>\nusing namespace std;\nclass F\n{\npublic:\n\n\tdouble operator ( )  (double x, double y);\n};\n\ndouble F :: operator ( )  (double x, double y)\n{\n\treturn x * x + y * y;\n}\n\nvoid main()\n{\n\tF f;\n\t//对象名后面（参数）这种形式要不就是调用了构造函数，要不就是运算符重载\n\n\tcout << f(2, 4) << endl;  // f.operator()(5.2, 2.5)\n}\n```\n比较普通成员函数\n\n**//例3用重载()运算符实现 pk成员函数**\n```cpp\n#include <iostream.h>\n\nclass F\n\n { public :\n\n double memFun ( double x , double y ) ;\n\n } ;\n\ndouble F :: memFun ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\n cout << f.memFun ( 5.2 , 2.5 ) << endl ;\n\n}\n```\n\n#### **5.为什么不要重载&&和||操作符**\n\n- 理论知识：\n  - 1）&&和||是C++中非常特殊的操作符\n  - 2）&&和||内置实现了短路规则\n  - 3）操作符重载是靠函数重载来完成的\n  - 4）操作数作为函数参数传递\n  - 5）C++的函数参数都会被求值，无法实现短路规则\n```cpp\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nclass Test\n{\n\tint i;\npublic:\n\tTest(int i)\n\t{\n\t\tthis->i = i;\n\t}\n\n\tTest operator+ (const Test& obj)\n\t{\n\t\tTest ret(0);\n\t\tcout << \"执行+号重载函数\" << endl;\n\t\tret.i = i + obj.i;\n\t\treturn ret;\n\t}\n\n\tbool operator&& (const Test& obj)\n\t{\n\t\tcout << \"执行&&重载函数\" << endl;\n\t\treturn i && obj.i;\n\t}\n\n};\n\n// && 从左向右\nint  main()\n{\n\tint a1 = 0;\n\tint a2 = 1;\n\tcout << \"注意：&&操作符的结合顺序是从左向右\" << endl;\n\n\tif (a1 && (a1 + a2))\n\t{\n\t\tcout << \"有一个是假，则不在执行下一个表达式的计算\" << endl;\n\t}\n\n\tTest t1 = 0;\n\tTest t2 = 1;\n\n\tif(t1 && (t1 + t2))\n\t{\n\t\tt1.operator&&(t1 + t2);\n\t\tt1.operator&&(t1.operator+(t2));\n\n\t\t\t//t1 && t1.operator+(t2)//首先执行加号运算符重载\n\t\t\t// t1.operator( t1.operator(t2) )//再执行&&的运算符重载\n\t\t\tcout << \"两个函数都被执行了，而且是先执行了+\" << endl;\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`注意：&&操作符的结合顺序是从左向右`\n`执行+号重载函数`\n`执行&&重载函数`\n\n\n### （五）运算符重载在项目开发中的应用\n\n#### **1实现一个数组类**\n添加<< >>\n\n#### **2实现一个字符串类**\n//构造函数要求\n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串类 以零结尾的字符串\n头文件；\n```cpp\n#pragma once\n#include \"iostream\"\nusing namespace std;\n\nclass MyString\n{\npublic:\n\tMyString();\n\tMyString(const char *p);\n\tMyString(const MyString &s);\n\t~MyString();\nprivate:\n\tint m_len;\n\tchar* m_p;\n\n\npublic:\n\tMyString& operator=(const char *p);\n\tMyString& operator= (const MyString &s);\n\n\tchar& operator[](int index);\n\n\tfriend ostream & operator<<(ostream &out, MyString &s);\n\n\n\tbool operator==(const char *p);\n\tbool operator!=(const char *p);\n\tbool operator==(const MyString&s);\n\tbool operator!=(const MyString &s);\n\n\n\n\tint operator<(const char *p);\n\tint operator<(const MyString &s);\n\n\n\n\tchar *c_str()\n\t{\n\t\treturn m_p;\n\t}\n\t//这个函数相比上面的区别只是得到的指针不能改变\n\tconst char *c_str2()\n\t{\n\t\treturn m_p;\n\t}\n\n\tint length()\n\t{\n\t\treturn m_len;\n\t}\n};\n\n```\n\n头文件类的实现：\n```cppp\n#include \"MyString.h\"\n#include\"math.h\"\n#include \"iostream\"\n#pragma warning(disable:4996)\n\n\n\nMyString::MyString() //构造函数：将默认的字符串进行默认为空字符串\n{\n\tm_len = 0;\n\tm_p = new char[m_len + 1];\n\tstrcpy(m_p, \" \");\n}\n\nMyString::MyString(const char *p)\n{\n\tif (p == NULL)\n\t{\n\t\tm_len = 0;\n\t\tm_p = new char[m_len + 1];\n\t\tstrcpy(m_p, \"\");\n\t}\n\telse\n\t{\n\t\tm_len = strlen(p);\n\t\tm_p = new char[m_len + 1];\n\t\tstrcpy(m_p, p);\n\t}\n}\n\n//拷贝构造函数\n//实现MyString s3 = s2;\n MyString::MyString(const MyString &s)\n{\n\tm_len = s.m_len;   \n\tm_p = new char[m_len + 1];  //分配空间\n\tstrcpy(m_p, s.m_p);\n}\n\n\n//析构函数的实现\n MyString::~MyString()\n {\n\t if (m_p != NULL)\n\t {\n\t\t delete[] m_p;\n\t\t m_p = NULL;\n\t\t m_len = 0;\n\t }\n }\n\n//下面进行的是操作符重载\n\t//等号=操作符重载\n MyString&MyString:: operator=(const char *p)\n\t{\n\t\t//用于实现s4 = \"s2222\"\n\t\t//因为s4已经分配内存，应该先将旧的内存空间删掉然后再分配新的\n\t\t\n\t\t//释放旧内存\n\t\tif (m_p != NULL)\n\t\t{\n\t\t\tdelete[] m_p;\n\t\t\tm_len = 0;\n\t\t}\n\n\t\t//分配新的内存\n\t\tif (p == NULL)\n\t\t{\n\t\t\tm_len = 0;\n\t\t\tm_p = new char[m_len + 1];\n\t\t\tstrcpy(m_p, \"\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_len = strlen(p);\n\t\t\tm_p = new char[m_len + 1];\n\t\t\tstrcpy(m_p, p);\n\t\t}\n\t\treturn *this;\n\t}\n\n\n\n MyString&MyString:: operator= (const MyString &s)\n\t{\n\t\t//用于实现s4 = s2\n\t\tif (m_p != NULL)\n\t\t{\n\t\t\tdelete[] m_p;\n\t\t\tm_len = 0;\n\t\t}\n\n\t\t//根据s分配新的内存\n\t\tm_len = s.m_len;\n\t\tm_p = new char[m_len + 1];\n\t\tstrcpy(m_p, s.m_p);\n\t\n\t\treturn *this;\n\t}\n\n\n\n char&MyString::operator[](int index)\n {\n\t return m_p[index];\n }\n\n\n //注意这个是全局函数，所以函数名前面不能加上MyString::  \n ostream& operator<<(ostream &out, MyString &s)\n {\n\t cout << s.m_p;\n\t return out;\n }\n\n\n\n //下面是实现==和!= 的重载，其中分为类和字符串的比较与类和类的比较\n bool MyString::operator==(const char *p)\n {\n\t if (p == NULL)\n\t {\n\t\t if (m_len == 0)\n\t\t {\n\t\t\t return true;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t return false;\n\t\t }\n\t }\n\t else\n\t {\n\t\t if (m_len == strlen(p))\n\t\t {\n\t\t\t return !strcmp(m_p, p);\n\t\t } \n\t\t else\n\t\t {\n\t\t\t return false;\n\t\t }\n\t }\n\t return true;\n }\n\n bool MyString::operator!=(const char *p)\n {\n\t return !(*this == p);\n }\n\n\n //两个类之间的比较\n bool MyString::operator==(const MyString&s)\n {\n\tif (m_len != s.m_len)\n\t{\n\t\treturn false;\n\t}\n\treturn !strcmp(m_p, s.m_p);\n }\n\n bool MyString::operator!=(const MyString &s)\n {\n\t return !(*this == s);\n }\n\n\n\n\n\n\n //实现  <  的重载\n\n int MyString::operator<(const char *p)\n {\n\t return strcmp(this->m_p, p);\n }\n int MyString::operator<(const MyString &s)\n {\n\t return strcmp(this->m_p, s.m_p);\n }\n```\n\n函数调用实现：\n```cppp\n// 实现一个字符串类\n\n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串类 以零结尾的字符串\n\n//若len为0,表示空串\n\n#include \"iostream\"\n#include \"MyString.h\"\nusing namespace std;\n\n\nint main()\n{\n\tMyString s1;\n\tMyString s2(\"s2\");\n\tMyString s2_2 = NULL;\n\tMyString s3 = s2;\n\n\n\n\n\t//下面进行操作符重载\n\t//=操作符\n\t//两种调用方式；\n\tMyString s4 = \"adfdfdn\";\n\t\n\ts4 = \"s2222\"; \n\n\t//调用方式二；\n\ts4 = s2;\n\n\n\n\n//实现[]重载\n\ts4[1] = 'a';\n\tcout << \"s4[1] = \" << s4[1] << endl;\n\t//当[]当右值的时候\n\t\n\n//实现<<操作符的重载\n\tcout << s4 << endl;   //相当于实现字符串的整体输出\n\n\n\n//实现== 和!= 的重载\n\tMyString s5 = \"ahhhh\";\n\t\n\tif (s5 == \"shhsk\")\n\t{\n\t\tcout << \"相等\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"不相等\" << endl;\n\t}\n\n\tif (s5 != \"sjfddsj\")\n\t{\n\t\tcout << \"false\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"true\" << endl;\n\t}\n\t\n\t//两个类之间做判断\n\t\n\tif (s5 == s2)\n\t{\n\t\tcout << \"相等\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"不相等\" << endl;\n\t}\n\n\tif (s5 != s2)\n\t{\n\t\tcout << \"false\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"true\" << endl;\n\t}\n\n\n\n//实现大于小于号的符号重载\n\n\tMyString s6 = \"skdjfkld\";\n\tif (s6 < \"kdjfkdj\")\n\t{\n\t\tcout << \"s6 小于 skdjfkld\" << endl;\n\t} \n\telse\n\t{\n\t\tcout << \"s6 大于 skdjfkld\" << endl;\n\t}\n\n\n\tif (s6 < s5)\n\t{\n\t\tcout << \"s6 小于 s5\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"s6 大于 s5\" << endl;\n\t}\n\n\n\n\n\n\t//使用类中的private:的指针\n\n\tMyString s7 = \"jdkfjdklfjdl\";\n\tstrcpy(s7.c_str(), \"lskjdfkljdklf\");\n\tcout << s7 << endl;\n}\n\n```\n\n\n#### **3智能指针类编写**\n\n1问题抛出\n  指针使用过程中，经常会出现内存泄漏和内存多次被释放常\n\n2解决方案：例如：boost库的智能指针\n  项目开发中，要求开发者使用预先编写的智能指针类对象代替C语言中的原生指针\n\n3智能指针思想\n  工程中的智能指针是一个类模板\n  通过构造函数接管申请的内存\n  通过析构函数确保堆内存被及时释放\n  通过重载指针运算符* 和 -> 来模拟指针的行为\n  通过重载比较运算符 == 和 != 来模拟指针的比较\n\n```cpp\nclass Test\n{\npublic:\n Test()\n {\n   this->a = 10;\n }\n\n void printT()\n {\n   cout<<a<<endl;\n }\n\nprivate:\n int a;\n};\n\nclass MyTestPointer\n{\npublic:\n\npublic:\n MyTestPointer()\n {\n   p = NULL;\n }\n\n MyTestPointer(Test* p)\n {\n   this->p = p;\n }\n\n ~MyTestPointer()\n {\n   delete p;\n }\n\n Test* operator->()\n {\n   return p;\n }\n\n Test& operator*()\n {\n   return *p;\n }\n\nprotected:\n Test *p;\n};\n\nvoid main01_classp()\n{\n Test *p = new Test;\n p->printT();\n delete p;\n MyTestPointer myp = new Test; //构造函数\n myp->printT(); //重载操作符 ->\n};\n\n```\n\n```cpp\nclass MyIntPointer\n{\npublic:\n MyIntPointer()\n {\n   p = NULL;\n }\n\n MyIntPointer(int* p)\n {\n   this->p = p;\n }\n\n ~MyIntPointer()\n {\n   delete p;\n }\n\n int* operator->()\n {\n   return p;\n }\n\n int& operator*()\n {\n   return *p;\n }\n\nprotected:\n int *p;\n};\n\nvoid main02_intp()\n{\n int *p = new int(100);\n cout<<*p<<endl;\n delete p;\n MyIntPointer myp = new int(200);\n cout<<*myp<<endl; //重载*操作符\n};\n```\n\n**8.7 附录：运算符和结合性**\n\n![55]($resource/55.png)\n![66]($resource/66.png)\n\n- 总结\n  * 操作符重载是C++的强大特性之一\n  * 操作符重载的本质是通过函数扩展操作符的语义\n  * operator关键字是操作符重载的关键\n  * friend关键字可以对函数或类开发访问权限\n  * 操作符重载遵循函数重载的规则\n  * 操作符重载可以直接使用类的成员函数实现\n  * =, [], ()和->操作符只能通过成员函数进行重载\n  * ++操作符通过一个int参数进行前置与后置的重载\n  * C++中不要重载&&和||操作符\n\n\n\n\n\n\n",[[1543798606487,["gjx16@GJXAIOU",[[1,54316,"\n"]],[54313,54313],[54314,54314]]],[1543798625394,["gjx16@GJXAIOU",[[1,54314,"#pragma  warning (disable: 4996)"]],[54314,54314],[54346,54346]]],[1543798753668,["gjx16@GJXAIOU",[[-1,54455,"\t"]],[54456,54456],[54455,54455]]],[1543798775226,["gjx16@GJXAIOU",[[-1,54604,"//当[]当右值的时候"]],[54604,54615],[54604,54604]]],[1543798778273,["gjx16@GJXAIOU",[[1,54551,"\n"]],[54550,54550],[54551,54551]]],[1543798781300,["gjx16@GJXAIOU",[[1,54551,"  //当[]当右值的时候"]],[54551,54551],[54564,54564]]],[1543798889174,["gjx16@GJXAIOU",[[-1,54752,"相等"]],[54754,54754],[54752,54752]]],[1543798892795,["gjx16@GJXAIOU",[[1,54752,"true"]],[54752,54752],[54756,54756]]],[1543798896674,["gjx16@GJXAIOU",[[-1,54790,"不相等"]],[54793,54793],[54790,54790]]],[1543798899916,["gjx16@GJXAIOU",[[1,54790,"false"]],[54790,54790],[54795,54795]]],[1543799678264,["gjx16@GJXAIOU",[[-1,54984,"不相等"]],[54987,54987],[54984,54984]]],[1543799683051,["gjx16@GJXAIOU",[[1,54984,"false"]],[54984,54984],[54989,54989]]],[1543799687606,["gjx16@GJXAIOU",[[-1,54948,"相等"]],[54950,54950],[54948,54948]]],[1543799691111,["gjx16@GJXAIOU",[[1,54948,"true"]],[54948,54948],[54952,54952]]],[1543803161169,["gjx16@GJXAIOU",[[1,51827,"\n"]],[51826,51826],[51827,51827]]],[1543803163809,["gjx16@GJXAIOU",[[1,51827,"()"]],[51827,51827],[51829,51829]]],[1543803167943,["gjx16@GJXAIOU",[[1,51828,"hanshu"]],[51828,51828],[51834,51834]]],[1543803173226,["gjx16@GJXAIOU",[[-1,51828,"hanshu"]],[51834,51834],[51828,51828]]],[1543803177020,["gjx16@GJXAIOU",[[1,51828,"函数签名"]],[51828,51828],[51832,51832]]],[1543803181465,["gjx16@GJXAIOU",[[-1,51830,"签名"]],[51832,51832],[51830,51830]]],[1543803185189,["gjx16@GJXAIOU",[[1,51830,"前面假的"]],[51830,51830],[51834,51834]]],[1543803187947,["gjx16@GJXAIOU",[[-1,51832,"假的"]],[51834,51834],[51832,51832]]],[1543803191302,["gjx16@GJXAIOU",[[1,51832,"加的是"]],[51832,51832],[51835,51835]]],[1543803241934,["gjx16@GJXAIOU",[[1,51835,"域作用符"]],[51835,51835],[51839,51839]]],[1543803260719,["gjx16@GJXAIOU",[[1,51070,"类的"]],[51070,51070],[51072,51072]]],[1543803264406,["gjx16@GJXAIOU",[[-1,51041,"\n"]],[51041,51041],[51040,51040]]],[1543803266241,["gjx16@GJXAIOU",[[-1,51011,"\n"]],[51011,51011],[51010,51010]]],[1543803271122,["gjx16@GJXAIOU",[[1,51068,"\n"]],[51068,51068],[51069,51069]]],[1543803274511,["gjx16@GJXAIOU",[[1,51069,"\n"]],[51068,51068],[51069,51069]]],[1543803279571,["gjx16@GJXAIOU",[[1,51069,"具体函数实现："]],[51069,51069],[51076,51076]]],[1543803282460,["gjx16@GJXAIOU",[[-1,51082,"；"]],[51083,51083],[51082,51082]]],[1543803283228,["gjx16@GJXAIOU",[[1,51082,"："]],[51082,51082],[51083,51083]]],[1543803286639,["gjx16@GJXAIOU",[[1,51077,"- "]],[51077,51077],[51079,51079]]],[1543803333808,["gjx16@GJXAIOU",[[-1,51290,"\n"]],[51290,51290],[51289,51289]]],[1543803355148,["gjx16@GJXAIOU",[[-1,51678,"\n"]],[51678,51678],[51677,51677]]],[1543803355770,["gjx16@GJXAIOU",[[-1,51677,"\n"]],[51677,51677],[51676,51676]]],[1543803357906,["gjx16@GJXAIOU",[[-1,51609,"\n"]],[51609,51609],[51608,51608]]],[1543803358453,["gjx16@GJXAIOU",[[-1,51608,"\n"]],[51608,51608],[51607,51607]]],[1543803361617,["gjx16@GJXAIOU",[[-1,51467,"\n"]],[51467,51467],[51466,51466]]],[1543803384514,["gjx16@GJXAIOU",[[1,51734,"，在下面具体调用中嗲用"]],[51734,51734],[51745,51745]]],[1543803538897,["gjx16@GJXAIOU",[[-1,51956,"\n"]],[51955,51955],[51954,51954]]]],"12月3日版本，已经听完视频day5","gjx16@GJXAIOU"],["e553e60d-ba03-4739-9d5c-429a1eeff230",1554445896325,"---\ndate:`2018-11-19-2018-11-19`\n---\n\n# C_PP_章二 类和对象\n\n## 一、前言\n\n- C++学习技术路线及目标\n   * 研究C++编译器管理类和对象的方法 ===》避免死角\n   * c++编译器对类对象的生命周期管理，对象创建、使用、销毁;\n   * c++面向对象模型初探;  \n   * c++面向对象多态原理探究;\n   * 操作符重载;\n   \n   \n- 面向抽象类（接口）编程\n![面向抽象类（接口）编程]($resource/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89%E7%BC%96%E7%A8%8B.png)\n\n\n\n## 二、类和对象\n\n### （一）基本概念\n\n- 1）类、对象、成员变量、成员函数\n- 2）面向对象三大概念\n  - 封装、继承、多态\n- 3）编程实践\n  - 类的定义和对象的定义，对象的使用\n  - 求圆形的面积\n  - 定义Teacher类，打印Teacher的信息（把类的声明和类的实现分开）\n\n\n\n### （二）类的封装\n\n**1.封装（Encapsulation）**\n\n- A）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。\n- B）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n\n  备注：有2层含义（==把属性和方法进行封装和对属性和方法进行访问控制==）\n\n- C++中类的封装\n  - 成员变量，C++中用于表示类属性的变量\n  - 成员函数，C++中用于表示类行为的函数\n\n**类的封装的第一层含义：**\n```cpp\n/*\n类的定义以及使用：\n*/\n\n//封装的第一层含义：\n//将属性和方法进行封装\n\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\npublic :\n\tdouble m_r;\n\tdouble m_s;\n\npublic:\n\tdouble getR()\n\t{\n\t\treturn m_r;\n\t}\n\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n\tdouble getS()\n\t{\n\t\tm_s = 3.14*m_r *m_r;\n\t\treturn m_s;\n\t}\n\n};\n\n\n\n//使用指针调用类中函数\n//通过类的指针可以调用类的成员函数\nvoid printCircle01(my_circle *pc)\n{\n\tcout<<\"r\"<<pc->getR()<<endl;\n\tcout << \"s\" << pc->getS() << endl;\n\n}\n\n\nvoid printCircle01(my_circle &pc)  #这里加不加&都行\n{\n\tcout << \"r\" << pc.getR() << endl;\n\tcout << \"s\" << pc.getS() << endl;\n\n}\n\n\n\nint main()\n{\n\tmy_circle c1, c2;//定义两个对象c1和c2\n\tc1.setR(10);\n\tcout << \"c1 s: \" << c1.getS() << endl;\n\n\t//指针\n\n\tc1.setR(11);\n\tprintCircle01(&c1);\n\n\tc2.setR(20);\n\tprintCircle01(&c2);\n\n\n\t//引用\n\tprintCircle01(c2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`c1 s: 314`\n`r11`\n`s379.94`\n`r20`\n`s1256`\n`r20`\n`s1256`\n\n**类的封装的第二层含义：**\n- public:修饰的成员变量和成员函数，可以在类的内部和类的外部访问\n- private:修饰的成员变量和成员函数，只能在类的内部被访问，不能在类的外部访问\n- protected:修饰的成员变量和成员函数，只能在类的内部被访问，不能再类的外部访问;但是可以用在继承之中，子类可以继承父类的protected修饰的变量或者函数\n```cpp\n/封装的第二层含义：\n//对属性和方法进行访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass my_circle\n{\nprivate://下面两个成员变量的属性是私有的\n\tdouble m_r;\ndouble m_s; //属性没有写（没有权限修饰的）默认等同于私有的\n\npublic:\n\tdouble setR(double r)\n\t{\n\t\tm_r = r;\n\t\treturn m_r;\n\t}\n\n};\n\n\nint main()\n{\n\tmy_circle c1, c2;\n\t//c1.m_r = 23;   //这个是不可以的\n\n\tc1.setR(20);  //这个是可以的\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**2类成员的访问控制**\n\n- 在C++中可以给成员变量和成员函数定义访问级别\n  - Public修饰成员变量和成员函数可以在类的内部和类的外部被访问\n  - Private修饰成员变量和成员函数只能在类的内部被访问\n\n* //类是把属性和方法封装 同时对信息进行访问控制\n* //类的内部，类的外部\n* //我们抽象了一个类，用类去定义对象\n* //类是一个数据类型，类是抽象的\n* //对象是一个具体的变量。占用内存空间。\n```cpp\n\nclass Circle\n{\npublic:\n\tdouble r;\n\tdouble s;\n\npublic:\n\tdouble getR()\n\t{\n\t\ta++;\n\t\treturn r;\n\t}\n\n\tvoid setR(double val)\n\t{\n\t\tr = val;\n\t}\n\n\npublic:\n\tdouble getS() //增加功能时，是在修改类, 修改类中的属性或者是方法\n\t{\n\t\ts = 3.14f*r*r;\n\t\treturn s;\n\t}\n\n\t//private:\n\n\tint a;\n\n};\n```\n\n\n\n**3.struct和class关键字区别**\n- 在用struct定义类时，所有成员的默认属性为public\n- 在用class定义类时，所有成员的默认属性为private\n\n\n**4.类的声明和类的实现分开**\n首先在“项目名称”右击，选择“添加”，然后选择“类”\n![新建类1]($resource/%E6%96%B0%E5%BB%BA%E7%B1%BB1.png)\n\n在新的弹出窗口内填写类名之后，系统会自动生成两个文件\n![添加类]($resource/%E6%B7%BB%E5%8A%A0%E7%B1%BB.png)\n\nTeacher.h\n```h\n#pragma once//表示给头文件仅包含一次\nclass Teacher\n{\nprivate:\n\tdouble m_la;\n\tint str[39];\npublic:\n\tint num_of_class(int i);\n\tvoid hahaha();\n};\n\n```\nTeacher.cpp\n//具体实现函数内容，在函数名前面加上`类名::`\n```cpp\n#include \"Teacher.h\"\n\nint Teacher::num_of_class(int i)   //这里是具体实现在.h中声明的函数，注意函数名前加上.h的头文件名\n{\n\ti =i + 200;\n\treturn i;\n}\n\nvoid Teacher::hahaha()\n{\n\n}\n```\n\n在其他函数中使用该类：（相当于主函数）\n```cpp\n/*\n\n使用Teacher类（类的定义和实现是分来的）\n*/\n\n#include\"iostream\"\n#include\"Teacher.h\"\n\nusing namespace std;\n\nint main()\n{\n\tTeacher t1;\n\tint ans = 0;\n\tans = t1.num_of_class(34);\n\tcout << \"ans = \" << ans << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`ans = 234`\n\n\n\n\n### （三）C++面向对象程序设计举例\n\n**目标：面向过程向面向对象思想转变**\n**初学者要仔细体会类和对象之间的关系，并通过适当练习巩固和提高！**\n\n- 案例1:设计立方体类(cube)，求出立方体的面积和体积\n```cpp\n/*\n案例一：根据长宽高求出长方体的面积与体积\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)//因为类的成员变量这里都是private:\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube;\n\tcube.set(1, 2, 3);\n\tint s = 0;\n\tint v = 0;\n\ts = cube.getS();\n\tv = cube.getV();\n\n\tcout << \"s = \" << s << endl;\n\tcout << \"v = \" << v << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`s = 22`\n`v = 6`\n\n - 求两个立方体，是否相等（全局函数和成员函数）\n   - 方法一：使用全局函数法\n```cpp\n\n/*\n判断两个立方体是否相等：\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\t\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n};\n\n//使用全局函数法\nint judgecube(Cube &cube1, Cube &cube2)\n{\n\tif (cube1.getA()==cube2.getA()  && cube1.getB() == cube2.getB() && cube1.getC() == cube2.getC())\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n\n}\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\n\tif (judgecube(cube1,cube2) == 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`buxiangdeng`\n\n  - 方法二：使用类的成员函数\n```cpp\n\n/*\n使用类的成员函数进行判别\n*/\n#include\"iostream\"\nusing namespace std;\n\nclass Cube\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\tint m_c;\n\tint m_s;\n\tint m_v;\n\npublic:\n\tvoid set(int a, int b, int c)\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t\tm_c = c;\n\t}\n\n\tint getS()\n\t{\n\t\tm_s = 2 * (m_a *m_b + m_a * m_c + m_b * m_c);\n\t\treturn m_s;\n\t}\n\n\tint getV()\n\t{\n\t\tm_v = m_a * m_b *m_c;\n\t\treturn m_v;\n\t}\n\n\t//因为这里面的m_a,m_b,m_c变量均是private，外部无法直接调用\n\n\tint getA()\n\t{\n\t\tint a = m_a;\n\t\treturn a;\n\t}\n\n\tint getB()\n\t{\n\t\tint b = m_b;\n\t\treturn b;\n\t}\n\n\tint getC()\n\t{\n\t\tint c = m_c;\n\t\treturn c;\n\t}\n\n\n\tint judgecube(Cube &cube2)\n\t{\n\t\tif (m_a== cube2.getA() && m_b== cube2.getB() &&m_c == cube2.getC()) //因为调用时cube1的类的成员函数，所以他自身的私有成员变量也可以使用\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n};\n\n\n\nint main()\n{\n\tCube cube1, cube2;\n\tcube1.set(1, 2, 3);\n\n\tcube2.set(1, 2, 4);\n\t\n\tint ret = cube1.judgecube(cube2);//使用cube1对象的类的成员函数judgecube去执行\n\n\tif ( ret== 0)\n\t{\n\t\tcout << \"buxiangdeng \" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"xiangdeng\" << endl;\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：`buxiangdeng`\n\n\n案例2 :设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n         即：求点和圆的关系（圆内和圆外）\n         \n![案例示意图]($resource/%E6%A1%88%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE%E2%80%98%E2%80%99.png)\n\n```cpp\n\n/*\n设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外\n即：求点和圆的关系（圆内和圆外）\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint getY1()\n\t{\n\t\treturn y1;\n\t}\n\n};\n\n\nclass myCircle\n{\nprivate:\n\tint x0;\n\tint y0;//圆心坐标\n\tint r;\n\npublic:\n\tint get_circle(int _x0, int _y0, int _r)\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\n\t\n\n\tint judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n\n};\n\n\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n\n\n\n}\n```\n程序运行结果：`zai`\n案例3: 对于第二个案例，类的声明和类的实现分开\n整个文件分为：main.cpp  myCircle.h  myCircle.cpp   myPoint.h   myPoint.cpp\n**main.cpp**\n```cpp\n\n/*\n上个例子中：\n类的实现和声明分开\n*/\n\n#include\"myCircle.h\"\n#include\"myPoint.h\"\n#include\"iostream\"\nusing namespace std;\n\nint main()\n{\n\tmyCircle circle;\n\tcircle.get_circle(1, 2, 3);\n\n\tmyPoint point;\n\tpoint.set_point(2, 3);\n\n\tint x_point = point.getX1();\n\tint y_point = point.getY1();\n\n\tint ret = circle.judge(point);\n\tif (ret == 0)\n\t\t\t{\n\t\t\t\tcout << \"buzai \" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"zai\" << endl;\n\t\t\t}\n\t\t\n}\n\n\n```\n**myCircle.h**\n```h\n#pragma once\n\nclass myPoint;\n\nclass myCircle\n{\n\tprivate:\n\t\tint x0;\n\t\tint y0;//圆心坐标\n\t\tint r;\n\n\tpublic:\n\t\tint get_circle(int _x0, int _y0, int _r);\n\n\t\tint judge(myPoint &point);//这里使用到了myPoint类，所以前面需要类的声明\n\t\t\n};\n```\n\n**myCircle.cpp**\n```cpp\n#include \"myCircle.h\"\n#include\"myPoint.h\"\n\nclass myPoint;\n\n\tint myCircle::get_circle(int _x0, int _y0, int _r)//在函数前面加上类名：：\n\t{\n\t\tx0 = _x0;\n\t\ty0 = _y0;\n\t\tr = _r;\n\t\treturn x0, y0, r;\n\t}\n\n\tint myCircle::judge(myPoint &point)\n\t{\n\t\tint line = (point.getX1() - x0)*(point.getX1() - x0) + (point.getY1() - y0)*(point.getY1() - y0);\n\t\tif (line <= r * r)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\n```\n\n**myPoint.h**\n```h\n#pragma once\nclass myPoint\n{\nprivate:\n\tint x1;\n\tint y1;\n\npublic:\n\tint set_point(int _x1, int _y1);\n\tint getX1();\n\tint getY1();\n\n};\n\n\n```\n\n**myPoint.cpp**\n```cpp\n#include \"myPoint.h\"\n\n\tint  myPoint::set_point(int _x1, int _y1)\n\t{\n\t\tx1 = _x1;\n\t\ty1 = _y1;\n\t\treturn x1, y1;\n\t}\n\n\tint myPoint:: getX1()\n\t{\n\t\treturn x1;\n\t}\n\n\tint myPoint::getY1()\n\t{\n\t\treturn y1;\n\t}\n\n```\n\n\n\n\n\n\n\n\n### （四）作业\n\n作业1：编写C++程序完成以下功能：\n\n1）定义一个Point类，其属性包括点的坐标，提供计算两点之间距离的方法；\n2）定义一个圆形类，其属性包括圆心和半径；\n3）创建两个圆形对象，提示用户输入圆心坐标和半径，判断两个圆是否相交，并输出结果。\n\n作业2：设计并测试一个名为Rectangle的矩形类，其属性为矩形的左下角与右上角两个点的坐标，根据坐标能计算出矩形的面积\n\n作业3：定义一个Tree类，有成员ages（树龄），成员函数grow（int years）对ages加上years，age（）显示tree对象的ages的值。\n\n\n\n\n\n\n\n\n## 三、对象的构造和析构\n\n**前言**\n\n- 创建一个对象时，常常需要作某些初始化的工作，例如对数据成员赋初值。注意，类的数据成员是不能在声明类时初始化的。\n- 为了解决这个问题，**C++编译器提供了构造函数(constructor)来处理对象的初始化。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来调用它，而是在建立对象时自动执行。**\n\n### （一）构造和析构函数\n\n#### **1.构造函数和析构函数的概念**\n\n**有关构造函数**\n\n- 构造函数的定义：\n  * 1）C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数；\n  * 2）构造函数在定义时可以有参数； \n  * 3）没有任何返回类型的声明。\n\n- 构造函数的调用：\n  * 自动调用：一般情况下C++编译器会自动调用构造函数\n  * 手动调用：在一些情况下则需要手工调用构造函数\n\n**有关析构函数**\n\n* 析构函数定义及调用\n  * 1）C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数\n  * 语法：~ClassName()\n  * 2）析构函数没有参数也没有任何返回类型的声明\n  * 3）析构函数在对象销毁时自动被调用\n  * 4）析构函数调用机制\n     * C++编译器自动调用\n\n代码演示：\n```cpp\n/*\n构造函数和析构函数的定义和使用 \n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //无参数，无返回值，构造函数\n\t{\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\t~Test() //析构函数\n\t{\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n};\n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1，t2;\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`this is gouzaofunction`\n`this is a xigoufunction`\n\n---\n构造函数和析构函数用法：可以用于初始化和释放内存空间\n```cpp\n/*\n构建函数和析构函数的实际使用示例；\n*/\n\n\n#pragma warning(disable:4996)\n\n#include\"iostream\"\nusing namespace std;\n\nclass  Test\t\n{\npublic:\n\tTest()  //构造函数 ，可以用于一些初始化\n\t{\n\t\ta = 100;\n\t\tp = (char *)malloc(150);\n\t\tstrcpy(p, \"aabbccddeeffgg\");\n\t\tcout << \"this is gouzaofunction\" << endl;\n\t}\n\n\tvoid print()\n\t{\n\t\tcout << a << endl;\n\t\tcout << p << endl;\n\t}\n\n\t~Test() //析构函数 ,可以用于释放函数内存空间\n\t{\n\t\tif (p != NULL)\n\t\t{\n\t\t\tfree(p);\n\t\t}\n\t\tcout << \"this is a xigoufunction\" << endl;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tchar *p;\n}; \n\nvoid objectplay()  //从这里可以更加直接的看到运行周期\n{\n\tTest t1;\n\tt1.print();\n\n\tTest t2;\n\tt2.print();\n//先构建的后析构\n}\n\nint main()\n{\n\tobjectplay();\n\t\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n#### **2 C++编译器构造析构方案  PK 对象显示初始化方案**\n（相当于使用构造函数和析构函数与使用原始的初始化方案的区别）\n\n**设计构造函数和析构函数的原因**\n面向对象的思想是从生活中来，手机、车出厂时，是一样的。\n生活中存在的对象都是被初始化后才上市的；初始状态是对象普遍存在的一个状态的\n\n- 普通方案：\n  - 为每个类都提供一个public的initialize函数；\n  - 对象创建后立即调用initialize函数进行初始化。\n\n* 优缺点分析\n  * 1）initialize只是一个普通的函数，必须显示的调用\n  * 2）一旦由于失误的原因，对象没有初始化，那么结果将是不确定的\n     **没有初始化的对象，其内部成员变量的值是不定的**\n  * 3）不能完全解决问题\n```cpp\n//为什么对象需要初始化 有什么样的初始化方案\n\n#include \"iostream\"\n\nusing namespace std;\n\n/*\n思考为什么需要初始化\n\n  面向对象思想来自生活，手机、车、电子产品，出厂时有初始化\n\n  怎么样进行初始化？\n\n方案1：显示调用方法\n\n缺点：易忘、麻烦；显示调用init，不能完全解决问题\n\n*/\n\nclass Test21\n{\npublic:\n\tint m;\n\tint getM() const { return m; }\n\tvoid setM(int val) { m = val; }\n\tint n;\n\n\tint getN() const { return n; }\n\n\tvoid setN(int val) { n = val; }\n\npublic:\n\tint init(int m, int n)\n\t{\n\t\tthis->m = m;\n\t\tthis->n = n;\n\t\treturn 0;\n\t}\n\nprotected:\n\nprivate:\n\n};\n\nint main()\n{\n\tint rv = 0;\n\n\tTest21 t1; //无参构造函数的调用方法\n\n\tTest21 t2;\n\n\t//t1.init(100, 200);\n\n\t//t2.init(300, 400);\n\n\tcout << t1.getM() << \" \" << t1.getN() << endl;\n\n\tcout << t2.getM() << \" \" << t2.getN() << endl;\n\n\t**//****定义对象数组时，没有机会进行显示初始化**\n\n\t\tTest21 arr[3];\n\n\t//Test arr_2[3] = {Test(1,3), Test(), Test()};\n\n\tsystem(\"pause\");\n\n\treturn rv;\n\n}\n\n\n```\n\n###  (二)构造函数的分类及调用\n\nC++编译器给程序员提供的对象初始化方案，高端大气上档次。\n\n**1.构造参数的定义和调用方式：**\n```cpp\n/*\n构造函数的分类和使用\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数,这里的const可加可不加，后面的obj 自己变换  \n\t{\n\n\t}\n\n};\n\n\n//下面进行调用函数\n\nint main()\n{\n\t//调用无参数的构造函数，本质上这是C++编译器自动的调用构造函数\n\n\tTest t1;\n\n\n\n\t//调用有参数的构造函数\n\n\t//调用只有一个参数的构造函数\n\t//以下两种调用方式等效\n\tTest t2(1);\n\n\tTest t3 = (1, 2, 3, 4);  //逗号表达式，最后传入的参数为最后一个值\n\n\n\t//调用多个参数的构造函数\n\n\tTest t4(1, 2); //相当于调用两个参数的构造函数\n\n\t//采用直接调用构造函数，即采用手动调用的方式\n\t\n\tTest t5 = Test(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n \n三种构造函数的调用方式：\n```cpp\n/*\n\n显示初始化方案，相当于从不用初始化方案的角度来突出为什么需要使用构造函数\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint a;\n\tint b;\n\n\npublic:\n\tvoid init(int _a, int _b)  //一个相当于初始化的函数\n\t{\n\t\ta = _a;\n\t\tb = _b;\n\t}\n\n};\n\n\nint  main()\n{\n\t//由上面的类可以看出，并没有提供构造函数\n\t// 类没有提供构造函数，C++编译器会自动提供另一个默认的构造函数\n\t//类没有提供赋值构造   函数，C++编译器也会自动的提供另一个默认的赋值构造函数\n\tTest t1;\n\n\t//如果需要对对象t1进行初始化\n\tint a = 10;\n\tint b = 20;\n\tt1.init(a, b);\n\n\n\t//如果定义的对象是一个数组，就需要挨个的进行初始化\n\tTest array[3];\n\tarray[0].init(1, 2);\n\tarray[1].init(1, 2);\n\tarray[2].init(1, 2);\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n```\n\n\n\n**2.随机构造函数（copy构造函数）调用时机**\n\n- 赋值构造函数的四种调用场景（调用时机）\n\n  - 第1和第2个调用场景  \n```cpp\n#include \"iostream\"\nusing namespace std;\nclass AA\n{\npublic:\n AA() //无参构造函数 默认构造函数\n {\n cout<<\"我是构造函数，自动被调用了\"<<endl;\n }\n \n AA(int _a) //无参构造函数 默认构造函数\n {\n a = _a;\n }\n\n  AA(const AA &obj2)\n\n  {\n\n  cout<<\"我也是构造函数，我是通过另外一个对象obj2，来初始化我自己\"<<endl;\n\n  a = obj2.a + 10;\n\n  }\n\n ~AA()\n\n {\n\n cout<<\"我是析构函数，自动被调用了\"<<endl;\n\n }\n\n void getA()\n\n {\n\n printf(\"a:%d \\n\", a);\n\n }\n\nprotected:\n\nprivate:\n\n int a;\n\n};\n\n//单独搭建一个舞台\n\nvoid ObjPlay01()\n\n{\n\n AA a1; //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2 = a1; //定义变量并初始化 //初始化法\n\n a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n}\n\n```\n\n  - 第二个应用场景\n```cpp\n//单独搭建一个舞台\n\nvoid ObjPlay02()\n{\n\n AA a1(10); //变量定义\n\n //赋值构造函数的第一个应用场景\n\n //用对象1 初始化 对象2\n\n AA a2(a1); //定义变量并初始化 //括号法\n\n //a2 = a1; //用a1来=号给a2 编译器给我们提供的浅copy\n\n a2.getA();\n}\n```\n//注意：初始化操作 和 等号操作 是两个不同的概念\n\n**第一个和第二个场景：**\n```cpp\n\n/*\n赋值构造函数四种使用时机\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\nprivate:\n\tint m_a;\n\tint m_b;\n\npublic:\n\tTest()  //构造无参函数\n\t{\n\t\tm_a = 1;\n\t\tm_b = 2;\n\t}\n\n\n\tTest(int a)\n\t{\n\t\tm_a = a;\n\t\tm_b = 0;\n\t}\n\n\n\tTest(int a ,int b) //构造有参函数\n\t{\n\t\tm_a = a;\n\t\tm_b = b;\n\t}\n\n\tTest(const Test& obj) //赋值构造函数\n\t{\n\t\tm_b = obj.m_b + 100;\n\t\tm_a = obj.m_a + 100;\n\n\t}\n\n\tvoid my_print()\n\t{\n\t\tcout << \"m_a\" << m_a << \"m_b\" << m_b << endl;\n\n\t}\n};\n\n\n\nint main()\n{\n\t//第一种调用方法：\n\tTest t1(1,2);\n\tTest t2 = t1;  //用t1来初始化t2\n\tt2.my_print();\n\n\t//第二种调用机制：\n\tTest t3(t1);\n\tt3.my_print();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n  - 第3个调用场景\n使用实参去初始化形参，调用形参的copy构造函数\n```cpp\n/*\n\n第三种应用场景\n*/\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & obj)      //拷贝构造函数\n\t{\n\t\tX = obj.X; Y = obj.Y;\n\t\tcout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//这是业务函数，形参是一个元素\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\nvoid mainobjplay()\n{\n\tLocation A(1, 2);  //形参是一个元素，函数调用，会执行实参变量初始化形参变量\n\n\t    f(A);\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n```\n\n  - 第4个调用场景\n\n\n```cpp\n#第四个应用场景\n\n#include \"iostream\"\nusing namespace std;\n\nclass Location\n{\npublic:\n\n\tLocation(int xx = 0, int yy = 0)\n\t{\n\t\tX = xx; Y = yy; cout << \"Constructor Object.\\n\";\n\t}\n\n\tLocation(const Location & p)      //复制构造函数\n\t{\n\t\tX = p.X; Y = p.Y; cout << \"Copy_constructor called.\" << endl;\n\t}\n\n\t~Location()\n\t{\n\t\tcout << X << \",\" << Y << \" Object destroyed.\" << endl;\n\t}\n\n\tint GetX() { return X; } int GetY() { return Y; }\n\nprivate: int X, Y;\n};\n\n//alt + f8 排版\n\nvoid f(Location p)\n{\n\tcout << \"Funtion:\" << p.GetX() << \",\" << p.GetY() << endl;\n}\n\n//结论一：函数的返回值是一个元素（复杂类型的），返回的是一个新的匿名对象（所以会调用匿名对象类的copy构造函数）\nLocation g()\n{\n\tLocation A(1, 2);\n\treturn A;\n}\n\n//对象初始化操作 和 =等号操作 是两个不同的概念\n\n//匿名对象的去和留，关键看，返回时如何接\n\nvoid mainobjplay()\n{\n\t//若返回的匿名对象，赋值给另外一个同类型的对象，那么匿名对象会被析构\n\n\t//Location B;\n\n\t//B = g();  //用匿名对象赋值给B对象，然后匿名对象析构\n\n\t//若返回的匿名对象，来初始化另外一个同类型的对象，那么匿名对象会直接转成新的对象B，不会被析构\n\tLocation B = g();\n\n\tcout << \"传智扫地僧测试\" << endl;\n}\n\nvoid main()\n{\n\tmainobjplay();\n\n\tsystem(\"pause\");\n}\n\n\n```\n\n![全为]($resource/%E5%85%A8%E4%B8%BA.png)\n\n**3.默认构造函数**\n\n- 二个特殊的构造函数\n  - 1）默认无参构造函数\n  当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空\n\n  - 2）默认拷贝构造函数\n  当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制\n\n\n\n\n###  (三)构造函数调用规则研究\n\n* 1）当类中没有定义任何一个构造函数时，c++编译器会提供默认无参构造函数和默认拷贝构造函数；\n* 2）当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数；需要自己加上\n* 3） 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），c++编译器不会提供默认无参构造函数；需要自己加上 \n* 4 ）默认拷贝构造函数成员变量简单赋值；\n\n总结：只要你写了构造函数，那么你必须用。\n\n- **构造析构阶段性总结**\n  * 1）构造函数是C++中用于初始化对象状态的特殊函数\n  * 2）构造函数在对象创建时自动被调用\n  * 3）构造函数和普通成员函数都遵循重载规则\n  * 4）拷贝构造函数是对象正确初始化的重要保证\n  * 5）必要的时候，必须手工编写拷贝构造函数\n\n========》1个对象的初始化讲完了，增加一个案例。\n\n### （四）深拷贝和浅拷贝\n\n- 默认复制构造函数可以完成对象的数据成员值简单的复制\n- 对象的数据资源是由指针指示的堆时，默认复制构造函数仅作指针值复制\n\n**1浅拷贝问题抛出和分析**\n\n深拷贝浅拷贝现象出现的原因\n```cpp\n/*\n如果未定义copy函数，使用C++默认的copy函数，实质上是一种浅拷贝\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\t\t\tpName = NULL;\n\t\t\tsize = 0;\n\t\t}\n\t}\n\n\tvoid operator=(Name &obj3)\n\t{\n\t\tif (pName != NULL)\n\t\t{\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//需要重载=号操作符，才能解决带来的浅拷贝问题\n\n\tobj2 = obj3; //=号操作，也是一种浅拷贝\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n```\n//程序在运行的时候理会出错，因为本质上是进行的浅拷贝，一开始释放obj2时候是正常析构的，但是析构obj1的时候就会出错\n\n示意图：\n![4]($resource/4.png)\n\n**2浅拷贝程序C++提供的解决方法**\n\n显示提供copy构造函数\n\n显示操作重载=号操作，不使用编译器提供的浅copy\n\n```cpp\n\n/*\n\nC++的默认copy构造函数是浅拷贝的解决方法 \n*/\n\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n    //解决方法：手工编写拷贝函数，使用深copy\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\tvoid operator=(Name &obj3)\n\n\t{\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\tcout << \"测试有没有调用我。。。。\" << endl;\n\n\t\t//用obj3来=自己\n\n\t\tpName = (char *)malloc(obj3.size + 1);\n\n\t\tstrcpy(pName, obj3.pName);\n\n\t\tsize = obj3.size;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nvoid main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n![3]($resource/3.png)\n\n---\n\n\n### （五）多个对象构造和析构\n\n**1.对象初始化列表**\n\n- 1）对象初始化列表出现原因\n程序本身是有问题的\n```cpp\n\n/*\n\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B   //在一个类里面组合了一个带有参数的构造函数的类，因为C++编译器要确定分配给B多大的内存，但是没法初始化A定义的两个对象（因为需要调用有参的构造函数）\n{\npublic:   //没有写B的构造函数，按理说应该调用默认的构造函数\n\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  //主要是因为没有方法和没有机会去初始化这两个A定义的对象\n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB;\n\treturn 0;\n\n}\n\n```\n\n解决方法：\n```cpp\n/*\n构造函数的初始化列表\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass A \n{\npublic:\n\tA(int _a)\n\t{\n\t\ta = _a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n};\n\n\nclass B  \n{\npublic:   \n//含义：前面就是定义B的构造函数，：后面试两个需要初始化的对象，括号里面是初始化的时候需要传递的参数（初始化的函数在class A中）\n\tB(int _a, int _b) : a1(1), a2(3)  \n\t{\n\n\t}\n//第二种参数传递的方法：\n/*\nB(int _a, int _b,int m,int n) : a1(m), a2(n)  \n\t{\n      a = _a;\n      b = _b;\n\t}\n\t\n*/\nprotected:\nprivate:\n\tint b1;\n\tint b2;\n\tA a1;  \n\tA a2;\n};\n\nint main()\n{\n\tA a1(10);\n\tB objB(1,2);\n\t//第二种方式：B objB(1,2,4,3)\n\treturn 0;\n\n}\n\n```\n\n**以上程序的操作顺序：**\n首先执行被组合对象的构造函数（a1,a2），如果有多个组合对象，则按照定义的顺序，而不是按照初始化列表的顺序（：后面的顺序）\n析构函数：和构造函数的调用顺序相反\n\n  - 1.必须这样做：\n    - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    - 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n\n  - 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    - 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    - 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n- 2）C++中提供初始化列表对成员变量进行初始化\n\n语法规则\n```cpp\nConstructor::Contructor() : m1(v1), m2(v1,v2), m3(v3)\n{\n // some other assignment operation\n}\n```\n\n\n- 3）注意概念\n  - 初始化：被初始化的对象正在创建\n  - 赋值：被赋值的对象已经存在\n\n- 4）注意：\n  - 成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关\n  - 初始化列表先于构造函数的函数体执行\n\n**说明：**\n\n* 1 C++中提供了初始化列表对成员变量进行初始化\n* 2 使用初始化列表出现原因：\n  * 1.必须这样做：\n    * 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，\n    * 而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，\n    * 如果没有初始化列表，那么他将无法完成第一步，就会报错。\n  * 2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值\n    * 当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，\n    * 因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。\n\n```cpp\n//总结 构造和析构的调用顺序\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n ABC(int a, int b, int c)\n {\n this->a = a;\n this->b = b;\n this->c = c;\n\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"ABC construct ..\\n\");\n }\n\n ~ABC()\n {\n printf(\"a:%d,b:%d,c:%d \\n\", a, b, c);\n printf(\"~ABC() ..\\n\");\n }\n\nprotected:\nprivate:\n int a;\n int b;\n int c;\n};\n\nclass MyD\n{\npublic:\n MyD():abc1(1,2,3),abc2(4,5,6),m(100)\n\n //MyD()\n {\n cout<<\"MyD()\"<<endl;\n }\n\n ~MyD()\n {\n cout<<\"~MyD()\"<<endl;\n }\n\nprotected:\nprivate:\n ABC abc1; //c++编译器不知道如何构造abc1\n ABC abc2;\n const int m;\n};\n\nint run()\n{\n MyD myD;\n return 0;\n}\n\nint main_dem03()\n{\n run();\n system(\"pause\");\n return 0;\n}\n\n```\n\n\n\n\n### （六）构造函数和析构函数的调用顺序研究\n\n**构造函数与析构函数的调用顺序**\n\n- 1）当类中有成员变量是其它类的对象时，首先调用成员变量的构造函数，调用顺序与声明顺序相同；之后调用自身类的构造函数\n\n- 2）析构函数的调用顺序与对应的构造函数调用顺序相反\n\n### （七）构造函数和析构函数综合练习**\n\n通过训练，把所学知识点都穿起来\n\n**1构造析构综合训练**\n```cpp\n\n/*\n\n总结 构造和析构的调用顺序\n\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass ABC\n{\npublic:\n\tABC(int a, int b, int c)   //构造函数  //所以最先执行的构造函数是这个abc1，然后再次执行这个，对应于;abc2\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\n\t}\n\n\t~ABC()\n\t{\n\t\tcout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;\n\t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\n\nclass MyD \n{\npublic:\n\tMyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100)  //因此必须使用构造函数的初始化列表    //定义的时候，先定义的abc1，所以应该先指向ABC的构造函数\n\t{\n\t\tcout << \"MyD()\" << endl;\n\t}\n\n\t~MyD()\n\t{\n\t\tcout << \"~MyD()\" << endl;\n\t}\n\n\tMyD(const MyD & obj) :abc1(7, 8, 9), abc2(10, 11, 12), m(100)  //copy函数后面也可以跟初始化列表\n\t{\n\t\tcout << \"MyD(const MyD &obj)\" << endl;\n\t}\n\nprotected:\nprivate:\n\tABC abc1; //c++编译器不知道如何构造abc1//这里组合类ABC类，又因为ABC类含有有参构造函数 \n\tABC abc2;\n\tconst int m;//因为是const m,所以上面所有的m都进行了赋值\n};\n\n\nint doThing(MyD myel)   //myel是一个元素\n{\n\tcout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;\n}\n\n\nint run2()//二\n{\n\tMyD myD;//定义成员变量，这时候会执行MyD的构造函数\n\tdoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n\treturn 0;\n}\n\nint run3()\n{\n\tcout << \"run3 start..\" << endl;\n\n\tcout << \"run3 end,,\" << endl;\n}\n\n\nint main()\n{\n\trun2();//一\n\t//run3();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n\n\n\n/*\n构造函数运行顺序\n1.执行abc1构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：1 2 3\n2.执行abc2构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl; 结果为：4 5 6\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n至此：MyD myD;这句话执行完毕\n\ndoThing(myD);//因为myel是一个元素，这里是使用实参来初始化形参，调用形参的copy构造函数\n然后因为这还是一个组合对象，所以对于copy构造函数仍然要向上面一样，挨个执行\n1.执行abc1的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;7 8 9\n2.执行abc2的copy构造函数：cout << \"ABC construct ..\\n\" << this->a << this->b << this->c << endl;10 11  12\n3.执行MyD自己的构造函数：cout << \"MyD()\" << endl;\n\n然后指向doThing的内部函数：cout << \"dothing() myel.abc1.a:\" << myel.abc1.getA() << endl;  7\n\n*/\n\n/*\n析构的过程\n首先析构形参myel:\n先析构自己：cout << \"~MyD()\" << endl; \n然后析构10 ,11,12 :\n然后析构7,8,9；\n至此形参的析构结束；\n\n然后开始析构myD\n*/\n\n\n```\n\n\n**2匿名对象强化训练**\n\n demo10_构造析构练习强化.cpp\n\n1） 匿名对象生命周期\n\n2） 匿名对象的去和留\n\n**3匿名对象强化训练**\n\n3） 构造中调用构造\n\n```cpp\n/*\n\n构造中调用构造\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass MyTest\n{\npublic:\n\tMyTest(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\n\t}\n\n\tMyTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\n\t\tMyTest(a, b, 10);\n\t}\n\n\t~MyTest()\n\t{\n\t\tcout << \"MyTest is ...\" << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n\n\npublic:\n\tint getC() const { return c; }\n\n\tvoid setC(int val) { c = val; }\n};\n\nint main()\n{\n\tMyTest t1(1, 2);\n\tcout << t1.getC() << endl;\n\tsystem(\"pause\");\n\treturn 0;\n\t\n}\n\n\n```\n\n 结论： 构造函数中调用构造函数，是一个蹩脚的行为。\n程序内存图：\n![搜狗截图20181124125452]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181124125452.png)\n\n### （八）对象的动态建立和释放\n\n**1.new和delete基本语法**\n```cpp\n/*\n\nnew 和delete的使用\n\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nvoid main()\n{\n\t//先分配内存然后赋值\n\tint *p = new int;  //分配基础类型\n\t*p = 20;  \n\n\t//在定义的时候直接分配内存\n\tint *p1 = new int(30);\n\tcout << *p1 << endl;\n\n\tsystem(\"pause\");\n\treturn; \n}\n\n```\n\n- 1）在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。\n\n  **注意： new和delete是运算符，不是函数，因此执行效率高。**\n\n- 2）虽然为了与C语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。new运算符的例子： \nnew int;  //开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)\nnew int(100);  //开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址 \nnew char[10];  //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址    new int[5][4];  //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159);  //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p\n\n- 3）new和delete运算符使用的一般格式为：\n  用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。\n![new运算符动态]($resource/new%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%A8%E6%80%81.png)\n```cpp\n\n/*\n使用malloc /free 与new /delete的区别\n*/\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest();\n\t~Test();\n\nprivate:\n\tint a;\n\tint b;\n\tint c;\n};\n\nTest::Test()\n{\n\tcout << \"执行了构造函数\" << endl;\n}\n\nTest::~Test()\n{\n\tcout << \"执行了析构函数\" << endl;\n}\n\n\n\nint main()\n{\n\t//基础类型\n\tint *p1 = (int *)malloc(sizeof(int));\n\t*p1 = 10;\n\tdelete p1;\n\n\tint *p2 = new int;\n\t*p2 = 20;\n\tfree(p2);\n\n\n\n\t//数组类型（元素为基础类型）\n\tint *p3 = (int *)malloc(sizeof(int)*10);\n\tp3[0] = 1;\n\tdelete[]p3;\n\n\tint *p4 = new int[10];\n\tp4[1] = 2;\n\tfree(p4);\n\n\n\t//类\n\tTest *p5 = (Test *)malloc(sizeof(Test));\n\tdelete p5;\n\n\tTest *p6 = new Test(10);\n\tfree(p6);\n}\n\n\n```\n**结论：** \nnew：不仅分配内存，而且调用了构造函数\ndelete:不仅释放了内存，而且调用了析构函数\n\n- 4） 应用举例\n\n![5]($resource/5.png)\n\n**2类对象的动态建立和释放**\n\n- 使用类名定义的对象都是静态的，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。\n\n-  C++中，可以用new运算符动态建立对象，用delete运算符撤销对象\n\n  比如：\n\n  Box *pt;  //定义一个指向Box类对象的指针变量pt\n      pt=new Box;  //在pt中存放了新建对象的起始地址  在程序中就可以通过pt访问这个新建的对象。如 cout<<pt->height;  //输出该对象的height成员 cout<<pt->volume( );  //调用该对象的volume函数，计算并输出体积 C++还允许在执行new时，对新建立的对象进行初始化。如 Box *pt=new Box(12,15,18);\n\n   这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。\n\n  新对象中的height，width和length分别获得初值12,15,18。调用对象既可以通过对象名，也可以通过指针。\n\n   在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。\n\n  ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。\n\n在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如\n\ndelete pt; //释放pt指向的内存空间\n\n这就撤销了pt指向的对象。此后程序不能再使用该对象。\n\n如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的**当前指向**，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。\n\n**3.编程实践**\n\n//1 malloc free函数 c关键字\n\n// new delete 操作符号 c++的关键字\n\n//2 new 在堆上分配内存 delete\n\n//分配基础类型 、分配数组类型、分配对象\n\n//3 new和malloc 深入分析\n\n混用测试、异同比较\n\n结论： malloc不会调用类的构造函数\n\n Free不会调用类的析构函数\n\n\n\n\n## 四、静态成员变量和成员函数\n\n\n思考：每个变量，拥有属性。有没有一些属性，归所有对象拥有？\n\n### （一）静态成员变量\n\n- **1定义静态成员变量**\n  - 关键字 **static**  可以用于说明一个类的成员，\n    静态成员提供了一个同类对象的共享机制\n\n  - 把一个类的成员说明为 **static**  时，这个类无论有多少个对象被创建，这些对象共享这个 **static**  成员\n\n  - 静态成员局部于类，它不是对象成员\n\n![1]($resource/1.png)\n\n例如：\n\n```cpp\n\n/*\n静态成员变量\n*/\n\n#include<iostream>\nusing namespace std;\n\nclass counter\n{\n\n\tstatic int num; //**声明与定义静态数据成员**\n\npublic:\n\n\tvoid setnum(int i) \n\t{ \n\t\tnum = i; \n\t} //成员函数访问静态数据成员\n\n\tvoid shownum() \n\t{ \n\t\tcout << num << endl;\n\t}\n\n};\n\nint counter::num = 0;//声明与定义静态数据成员\n\nvoid main()\n{\n\tcounter a, b;\n\n\ta.shownum(); //调用成员函数访问私有静态数据成员\n\tb.shownum();\n\ta.setnum(10);\n\ta.shownum();\n\tb.shownum();\n\n}\n\n```\n\n![6]($resource/6.png)\n\n**从结果可以看出，访问的是同一个静态数据成员**\n\n- **2使用静态成员变量**\n```cpp\n//例5-14_使用公有静态数据成员\n\n#include<iostream.h>\n\nclass counter\n{ \npublic :\n\n counter (int a) { mem = a; }\n\n int mem; **_//_****_公有数据成员_**\n\n static int Smem ; **_//_****_公有静态数据成员_**\n\n} ;\n\nint counter :: Smem = 1 ; **_//_****_初始值为1_**\n\nvoid main()\n\n{  counter c(5);\n\n int i ;\n\n for( i = 0 ; i < 5 ; i ++ )\n\n { **counter::Smem** += i ;\n\n cout << **counter::Smem** << '\\t' ; //访问静态成员变量方法2\n\n }\n\n cout<<endl;\n\n cout<<\"c.Smem = \"<<**c.Smem**<<endl; //访问静态成员变量方法1\n\n cout<<\"c.mem = \"<<**_c.mem_**<<endl;\n\n}\n\n```\n使用静态成员函数调用静态成员变量\n```cpp\n/*\n静态成员函数\n*/\n// 结论：在静态成员函数中可以使用静态成员变量，但是不能使用类中普通的成员变量\n\n#include\"iostream\"\nusing namespace std;\n\nclass BB\n{\npublic:\n\tint printC()\n\t{\n\t\tcout << \"c:\" << c << endl;\n\t\treturn c;\n\t}\n\n\tint addC()\n\t{\n\t\tc = c+1;\n\t}\n\n\n\tstatic void getC()\n\t{\n\t\tcout << \"c\" << c << endl;  //可以直接在静态成员函数中使用静态成员变量，但是不能直接使用一般变量\n\t}\nprivate:\n\tint a;\n\tint b;\n\tstatic int c;\n\n};\n\n\nint BB::c = 10;  //初始化成员变量值\n\nvoid main()\n{\n\tBB b1, b2, b3;\n\tb1.printC();//10\n\tb2.addC();//11\n\tb3.printC();//11\n\n\t//调用成员函数两种方法；\n\tb3.getC();//使用对象.\n\tBB::getC();//使用类::\n\n\n\n}\n\n```\n\n### (二)静态成员函数\n\n- **1）概念**\n\n  - 静态成员函数数冠以关键字static\n\n  - 静态成员函数提供不依赖于类数据结构的共同操作，它没有this指针\n  - 在类外调用静态成员函数用 `_类名_ ::`作限定词，或通过对象调用\n\n- **2）案例**\n![7]($resource/7.png)\n\n- **3）疑难问题：**\n静态成员函数中，不能使用普通变量。\n//静态成员变量属于整个类的，分不清楚，是那个具体对象的属性。\n![成员函数中的疑难问题]($resource/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98.png)\n\n**4.3 综合训练**\n\n\n\n## 五、 C++面向对象模型初探\n\n**前言**\n\n- C++对象模型可以概括为以下2部分：\n\n  - 1. 语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等等。\n\n  - 2. 对于各种支持的底层实现机制。\n\n  在c语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。在c++中，通过抽象数据类型（abstract data type，ADT），在类中定义数据和函数，来实现数据和函数直接的绑定。\n\n  概括来说，在C++类中有两种成员数据：static、nonstatic；三种成员函数：static、nonstatic、virtual。\n\n![C++类的组成]($resource/C++%E7%B1%BB%E7%9A%84%E7%BB%84%E6%88%90.png)\n\n### （一）基础知识\n\nC++中的class从面向对象理论出发，将变量(属性)和函数(方法)集中定义在一起，用于描述现实世界中的类。从计算机的角度，程序依然由数据段和代码段构成。\n\n**C++编译器如何完成面向对象理论到计算机程序的转化？**\n换句话：C++编译器是如何管理类、对象、类和对象之间的关系\n具体的说：具体对象调用类中的方法，那，c++编译器是如何区分，是那个具体的类，调用这个方法那?\n\n思考一下程序结果\n```cpp\n/*\n面向对象模型初探\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass C1\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\nprotected:\n\nprivate:\n\n}; //12\n\nclass C2\n{\npublic:\n\n\tint i; //4\n\tint j; //4\n\tint k; //4\n\n\tstatic int m; \n\npublic:\n\n\tint getK() const { return k; } //方法是属于代码，应该放在代码区\n\tvoid setK(int val) { k = val; } \n\nprotected:\n\nprivate:\n}; \n\nstruct S1\n{\n\tint i;\n\tint j;\n\tint k;\n}; \n\nstruct S2\n{\n\tint i;\n\tint j;\n\tint k;\n\tstatic int m;\n}; \n\nint main()\n{\n\n\tprintf(\"c1:%d \\n\", sizeof(C1));\n\tprintf(\"c2:%d \\n\", sizeof(C2));\n\tprintf(\"s1:%d \\n\", sizeof(S1));\n\tprintf(\"s2:%d \\n\", sizeof(S2));\n\tsystem(\"pause\");\n\n}\n```\n程序运行结果：\n`c1:12`\n`c2:12`\n`s1:12`\n`s2:12`\n\n \n### (二)编译器对属性和方法的处理机制\n\n通过上面的案例，我们可以的得出：\n1）C++类对象中的成员变量和成员函数是分开存储的\n- 成员变量：\n  - 普通成员变量：存储于对象中，与struct变量有相同的内存布局和字节对齐方式\n  - 静态成员变量：存储于全局数据区中\n\n- 成员函数：存储于代码段中。\n问题出来了：很多对象共用一块代码？代码是如何区分具体对象的那？\n换句话说：int getK() const { return k; }，代码是如何区分，具体obj1、obj2、obj3对象的k值？\n\n2）C++编译器对普通成员函数的内部处理\n\n![C++编译器对普通成员函数的内部处理]($resource/C++%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%86%85%E9%83%A8%E5%A4%84%E7%90%86.png)\n\n请仔细思考，并说出你的总结！\n\n\n\n### （三）总结\n\n1、C++类对象中的成员变量和成员函数是分开存储的。C语言中的内存四区模型仍然有效！\n**2、C++中类的普通成员函数都隐式包含一个指向当前对象的this指针。**\n3、静态成员函数、成员变量属于类\n\n静态成员函数与普通成员函数的区别\n\n静态成员函数不包含指向具体对象的指针\n\n普通成员函数包含一个指向具体对象的指针\n\n\n### （四）this指针\n\n![this指针图示]($resource/this%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png)\n\n实验1：若类成员函数的形参 和 类的属性（成员变量）名字相同，通过this指针来解决。\n```cpp\n\n/*\nthis 指针\n*/\n\n#include\"iostream\"\nusing namespace std;\n\n\nclass Test\n{\npublic:\n\tTest( int a, int b)//Test(Test *this, int a, int b)//因为这里成员函数的形参和成员变量一样，不用this指针会出现：a = a ,b = b;\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printT()\n\t{\n\t\tcout << \"a; \" << a << endl;\n\t\tcout << \"b: \" << this->b << endl;\n\t}\n\n\n    const void hello(int a,int b )\n    {\n      //下面这两个语句都是错误的\n      this->a = 100;\n      this ->b = 200;\n    }\n   //const修饰的this指针，即相当于this指针指向的内存空间不能被修改\n   //因为上面的函数会别C++编译器解析为:void hello(const Test *this, int a ,int b)\n   //同时上面的const其实下载函数（）外面的任何位置都行\n   \nprotected:\nprivate:\n\tint a;\n\tint b;\n};\nint  main()\n{\n\tTest t1(1, 2);\n\tt1.printT();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`a:1`\n`b:2`\n\n\n实验2：类的成员函数可通过const修饰，请问const修饰的是谁\n\n\n### （五）全局函数PK成员函数\n\n 1、把全局函数转化成成员函数，通过this指针隐藏左操作数\n\n   Test add(Test &t1, Test &t2)===》Test add( Test &t2)\n```cpp\n/*\n全局函数与成员函数\n*/\n\n\n//使用全局函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\t\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\nTest Testadd(Test &t1, Test &t2)\n{\n\tTest tmp(3,4);\n\treturn tmp;\n}\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3(2, 3);\n\tt3= Testadd(t1, t2);\n}\n```\n\n```cpp\n//使用成员函数\n\n#include\"iostream\"\nusing namespace std;\n\nclass Test\n{\n\npublic:\n\tTest(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\tTest Testadd(Test &t2)\n\t{\n\t\tTest tmp(this->a + t2.a, this->b + t2.b);\n\t\treturn tmp;\n\t}\n\nprotected:\nprivate:\n\tint a;\n\tint b;\n};\n\n\n\nint main()\n{\n\tTest t1(1, 2);\n\tTest t2(3, 4);\n\n\tTest t3 = t1.Testadd(t2);//匿名对象直接转化成t4\n\tTest t4(3,5);\n\tt4 = t1.Testadd(t2);  //匿名对象复制给t5\n}\n\n\n```\n 2、把成员函数转换成全局函数，多了一个参数\n\n   void printAB()===》void printAB(Test *pthis)\n\n 3、函数返回元素和返回引用\n```cpp\nTest& add(Test &t2) //*this //函数返回引用,相当于返回自身，谁调用返回谁\n {      \n   this->a = this->a + t2.getA();\n\n   this->b = this->b + t2.getB();\n\n   return *this; //*操作让this指针回到元素状态\n\n }\n\nTest add2(Test &t2) //*this //函数返回元素\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n return t3;\n\n }\n\n void add3(Test &t2) //*this //函数返回元素\n\n {\n\n //t3是局部变量\n\n Test t3(this->a+t2.getA(), this->b + t2.getB()) ;\n\n //return t3;\n\n }\n  \n\n```\n\n\n\n\n---\n\n## 六、友元\n\n### （一）友元函数\n- 首先友元函数是全局函数，在友元函数中可以修改类的私有属性；\n- 友元函数在类中的声明位置位于public或者private只下均可；\n![8]($resource/8.png)\n\n```cpp\n//友元函数：\n\n#include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend void modify(A *PA,int _a);  //友元函数的声明\n\n\tA(int a, int b)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\n\nprivate:\n\tint a;\n\tint b;\n};\n\nvoid modify(A *PA,int _a)//后面的参数可加可不加\n{\n\t//PA->a = 100;//可以这样直接修改值\n\tPA->a = _a;  //通过传递的值进行修改\n}\n\n\nint main()\n{\n\tA a1(1, 2);\n\tcout << \"a:\" << a1.getA() << endl;\n\tmodify(&a1,20);\n\n\tint aa = a1.getA();\n\n\tcout << \"aa:\" << aa << endl;\n}\n```\n![9]($resource/9.png)\n\n\n### （二）友元类\n\n- 若B类是A类的友员类，则B类的所有成员函数都是A类的友员函数\n- 若B类是A类的友元类，则B类可以直接修改A的成员变量和成员函数\n- 友员类通常设计为一种对数据操作或类之间传递消息的辅助类\n程序示例：\n```cpp\n//友元类\n #include\"iostream\"\nusing namespace std;\n\nclass A\n{\npublic:\n\tfriend class B;//将B 声明为A的友元类，这样B 可以直接修改A的成员变量和成员函数 \n\n\tA(int a=0, int b=0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n \t}\n\n\tint getA()\n\t{\n\t\treturn this->a;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n};\n\n\nclass B\n{\npublic:\n\n\tvoid set(int a)\n\t{\n\t\tobjA.a = a;\n\t}\n\n\tvoid printa()\n\t{\n\t\tcout << objA.a << endl;\n\t}\n\nprivate:\n\tA objA;\n};\n\n\nint main()\n{\n\tB b1;\n\tb1.set(200);\n\tb1.printa();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：200\n\n![10]($resource/10.png)\n\n\n\n## 七、强化训练\n\n**1 static关键字强化训练题**\n\n某商店经销一种货物。货物购进和卖出时以箱为单位，各箱的重量不一样，因此，商店需要记录目前库存的总重量。现在用C++模拟商店货物购进和卖出的情况。\n```cpp\n#include \"iostream\"\nusing namespace std;\n\nclass Goods\n{\npublic:\n\n\tGoods(int w) { weight = w; total_weight += w; }\n\n\t~Goods() { total_weight -= weight; }\n\n\tint Weight() { return weight; };\n\n\tstatic int TotalWeight() { return total_weight; }\n\n\tGoods *next;\n\nprivate:\n\n\tint weight;\n\tstatic int total_weight;\n\n};\n\nint Goods::total_weight = 0;\n\n//r尾部指针\n\nvoid purchase(Goods * &f, Goods *& r, int w)\n{\n\n\tGoods *p = new Goods(w);\n\n\tp->next = NULL;\n\n\tif (f == NULL) f = r = p;\n\n\telse { r->next = p; r = r->next; } //尾部指针下移或新结点变成尾部结点\n\n}\n\nvoid sale(Goods * & f, Goods * & r)\n{\n\n\tif (f == NULL) { cout << \"No any goods!\\n\"; return; }\n\n\tGoods *q = f; f = f->next; delete q;\n\n\tcout << \"saled.\\n\";\n\n}\n\nvoid main()\n{\n\tGoods * front = NULL, *rear = NULL;\n\n\tint w; int choice;\n\n\tdo\n\t{\n\t\tcout << \"Please choice:\\n\";\n\n\t\tcout << \"Key in 1 is purchase,\\nKey in 2 is sale,\\nKey in 0 is over.\\n\";\n\n\t\tcin >> choice;\n\n\t\tswitch (choice) // 操作选择\n\t\t{\n\t\tcase 1: // 键入1，购进1箱货物\n\t\t{ cout << \"Input weight: \";\n\t\tcin >> w;\n\n\t\tpurchase(front, rear, w); // 从表尾插入1个结点\n\n\t\tbreak;\n\t\t}\n\n\t\tcase 2:              // 键入2，售出1箱货物\n\t\t{ sale(front, rear); break; } // 从表头删除1个结点\n\n\t\tcase 0: break;              // 键入0，结束\n\t\t}\n\n\t\tcout << \"Now total weight is:\" << Goods::TotalWeight() << endl;\n\n\t} while (choice);\n}\n```\n**2** **数组类封装**\n\n目标：解决实际问题，训练构造函数、copy构造函数等，为操作符重载做准备\n\n数组类的头文件:`Array.h`\n```cpp\n#pragma once\nclass Array\n{\npublic:\n\tArray(int length);\n\tArray(const Array&obj);\n\t~Array();\npublic:\n\tint length();\n\n\tvoid setData(int index, int value);\n\n\tint getData(int index);\nprivate:\n\tint m_length;\n\tchar *m_space;\n};\n```\n\n数组类的头文件的实现：`Array.cpp`\n```cppp\n#include \"Array.h\"\nusing namespace std;\n#include\"iostream\"\n\nArray::Array(int length)\n{\n\tif (length < 0)\n\t{\n\t\tlength = 0;\n\t}\n\telse\n\t{\n\t\tm_length = length;\n\t\tm_space = new char[m_length];\n\t}\n}\n\nArray::Array(const Array&obj)\n{\n   this->m_length = obj.m_length;\n   this->m_space = new char [this->m_length];//进行分配内存空间\n\n  for(int i= 0; i < obj.m_length;i++)//数组元素复制， 这里的obj.m_length可以直接替换成m_length\n  {\n    this->m_space[i] = obj.m_space[i];\n  }\n}\n\nArray::~Array()\n{\n\tif (m_space != NULL)\n\t{\n\t\tdelete[] m_space;\n\t\tm_length = 0;\n\t}\n}\n\nvoid Array::setData(int index, int valude)\n{\n\tm_space[index] = valude;\n}\n\nint Array::getData(int index)\n{\n\treturn m_space[index];\n}\n\nint Array::length()\n{\n\treturn m_length; \n}\n```\n\n数组类的测试\n```cpp\n#include \"iostream\"\n#include \"Array.h\"\nusing namespace std;\n\nint main()\n{\n\tArray a1(10);\n\tfor (int i = 0; i < a1.length(); i++)\n\t{\n\t\ta1.setData(i, i);\n\t}\n\tfor (int i = 0; i <  a1.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a1.getData(i));\n\t}\n\n\tArray a2 = a1;\n\n\tfor (int i = 0; i < a2.length(); i++)\n\t{\n\t\tprintf(\"array %d: %d\\n\", i, a2.getData(i));\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n**3.小结**\n\n* 类通常用关键字class定义。类是数据成员和成员函数的封装。类的实例称为对象。\n* 结构类型用关键字struct定义，是由不同类型数据组成的数据类型。\n* 类成员由private, protected, public决定访问特性。public成员集称为接口。\n* 构造函数在创建和初始化对象时自动调用。析构函数则在对象作用域结束时自动调用。\n* 重载构造函数和复制构造函数提供了创建对象的不同初始化方式。\n* 静态成员是局部于类的成员，提供一种同类对象的共享机制。\n* 友员用关键字friend声明。友员是对类操作的一种辅助手段。一个类的友员可以访问该类各种性质的成员\n* 链表是一种重要的动态数据结构，可以在程序运行时创建或撤消数据元素。\n\n\n\n---\n\n\n## 八、运算符重载\n\n### （一）概念\n\n#### **1.什么是运算符重载**\n\n![11]($resource/11.png)\n所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是”一名多用”。\n\n运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重载。例如，大 家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行加法运算，如5+8， 5.8 +3.67等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的， 但由于C++已经对运算符”+”进行了重载，所以就能适用于int, float, doUble类型的运算。\n\n又如`<<`是C的位运算中的位移运算符（左移），但在输出操作中又是与流对 象cout 配合使用的流插入运算符，`>>`也是位移运算符(右移），但在输入操作中又是与流对象 cin 配合使用的流提取运算符。这就是运算符重载(operator overloading)。C系统对`<<`和`>>`进行了重载，用户在不同的场合下使用它们时，作用是不同 的。对`<<`和`>>`的重载处理是放在头文件stream中的。因此，如果要在程序中用`<<`和`>>`作流插入运算符和流提取运算符，必须在本文件模块中包含头文件stream(当然还应当包括”using namespace std“)。\n\n现在要讨论的问题是：用户能否根据自己的需要对C++已提供的运算符进行重载，赋予它们新的含义，使之一名多用？\n\n#### **2.运算符重载入门技术推演**\n\n1为什么会用运算符重载机制\n//原因 Complex是用户自定义类型，编译器根本不知道如何进行加减，但是编译器给提供了一种机制，让用户自己去完成，自定义类型的加减操作。。。这个机制就是运算符重载机制\n\n用复数类举例，定义一个Complex类,有两个对象，每个对象由两个属性，要求使用对象之间的加法实现对应属性的相加，示例程序如下：\n```cpp\n\n/*对于基础数据类型，C++编译器知道如何进行运算，但是对于用户自定义的类型编译器提供了一种\n让自定义数据类型进行运算符操作的机制,=》运算符重载机制\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\npublic:\n\tfriend Complex operator+(Complex &c1, Complex &c2);//友元函数声明\n\n\tComplex(int a = 0, int b = 0)//构造函数\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\nprivate:\n  int a;\n  int b;\n};\n\n/*使用全局函数，通过调用全局函数实现\nComplex myAdd(Complex &c1, Complex &c2)\n{\n Complex tmp(c1.a+ c2.a, c1.b + c2.b);\n\n return tmp;\n}\n*/\n\n\n//可以简单的想象为将上面全局函数的函数名替换为operator+\nComplex operator+(Complex &c1, Complex &c2)\n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\treturn tmp;\n}\n\n\n\nint  main()\n{\n\tComplex c1(1, 2), c2(3, 4);\n\n\t//方法1： 通过调用普通函数实现\n\t//Complex c3 = myAdd(c1, c2);\n\t//c3.printCom();\n\n\n\t//方法2  将函数名称替换为：operator+ \n\t//使用以下方式进行调用\n\t//Complex c3 = operator+(c1, c2);\n\t//c3.printCom();\n\n\n\t//方法3：最常用的调用方式\n\tComplex c3 = c1 + c2; \n\tc3.printCom()\n\n\tsystem(\"pause\");\n\treturn;\n}\n```\n程序运行结果：`4+6i`\n\n\n---\n\n### （二）运算符重载的限制\n![12]($resource/12.png)\n\n重载运算符函数可以对运算符进行新的解释，但是原有的基本语义不变：\n* 不改变运算符的优先级\n* 不改变运算符的结合性\n* 不改变运算符所需要的操作数\n* 不能创建新的运算符\n\n---\n\n### （三）运算符重载编程基础\n![14]($resource/14.png)\n例如:\n   //全局函数  完成 +操作符  重载  \n    Complex operator+(Complex &c1, Complex &c2)\n\n  //类成员函数  完成 -操作符  重载\n    Complex operator-(Complex &c2)\n\n#### **1.运算符重载的两种方法:**\n- 运算符可以重载为成员函数了或者友元函数\n- 关键区别在于成员函数具有this指针，友元函数没有this 指针\n- 不管是成员函数还是友元函数重载，运算符的使用方法相同\n- 但是两种的传递参数不同，实现代码也不同，应用场合也不同\n\n- **二元操作符重载的实现：**\n![16]($resource/16.png)\n \n```cpp\n//二元函数操作符的重载的两种方法\n\n\n/*全局函数、类成员函数方法实现运算符重载步骤\n1）要承认操作符重载是一个函数，写出函数名称operator + ()\n2）根据操作数，写出函数参数\n3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n*/\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex operator+(Complex &c1, Complex &c2); //这里是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\t//成员函数实现 - 运算符重载 \n\tComplex operator-(Complex &c2)//因为是c1调用的，因此这里的this 指向c1\n\t{\n\t\tComplex tmp(this->a - c2.a, this->b -  c2.b);//通过构造函数实现 tmp中成员变量的变化 \n\t\treturn tmp;\n\t}\n\n};\n\n\n//使用全局函数实现  + 运算符重载\nComplex operator+(Complex &c1, Complex &c2)\n{\n\tComplex tmp(c1.a + c2.a, c1.b + c2.b);\n\n\treturn tmp;\n}\n\n\nint  main()\n{\n\tComplex c1(1, 2), c2(3, 4);\n\n\t//使用 全局函数\n\tComplex c3 = c1 + c2;\n\tc3.printCom();\n\n\t//使用成员函数\n\tComplex c4 = c1.operator-(c2);\n\tc4.printCom();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`4 + 6i`\n`-2 + -2i`\n\n\n- **一元函数操作符重载的实现：**\n![17]($resource/17.png)\n\n- 实现前置++和前置--\n```cpp\n//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现前置++和前置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex& operator++(Complex &c1); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\tComplex& operator--()\n\t{\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn *this;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  + 运算符重载\nComplex& operator++(Complex &c1)\n{\n\tc1.a++;\n\tc1.b++;\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1,c2;\n\n\t//使用全局函数实现前置++操作符的重置\n\t++c1;\n\tc1.printCom();\n\n\n\t//使用成员函数实现前置--操作符的重置\n\t--c2;\n\tc2.printCom();\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`1 + 1i`\n`-1 + -1i`\n\n- 实现后置++和后置--\n```cpp\n//使用成员函数和全局函数实现一元函数运算符的重载\n\n//实现后置++ 和后置--\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\tfriend Complex operator++(Complex &c1, int); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n\n\t//成员函数实现后置--\n\tComplex operator--(int)\n\t{\n\t\tComplex tmp = *this;\n\t\tthis->a--;\n\t\tthis->b--;\n\t\treturn tmp;   //因为this指针代表c2的地址，所以*this则表示c2本身；\n\t}\n\n};\n\n\n//全局函数实现  ++ 运算符重载\nComplex operator++(Complex &c1,int)  //为了和前置++的函数能够共同存在，参数中加了一个占位符从而实现函数重载\n{\n\t//前置++是先使用后++ ，所以应该先返回c1,但是直接使用return c1.会造成程序的直接退出，后面的++无法实现，所以使用临时变量\n\n\tComplex tmp = c1;\n\tc1.a++;\n\tc1.b++;\n\treturn tmp;\n\treturn c1;\n}\n\nint  main()\n{\n\tComplex c1, c2;\n\t//使用全局函数实现后置++操作符的重置\n\tc1++;\n\tc1.printCom();\n\n\t//使用成员函数实现后置--操作符的重置\n\tc2--;\n\tc2.printCom();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n\n**前置和后置运算符总结:**\n\nC++中通过一个占位参数来区分前置运算和后置运算\n![18]($resource/18.png)\n\n\n\n#### **2.定义运算符重载函数名的步骤**\n首先写运算符重载函数的调用，然后根据调用的形式写具体的函数实现；\n**一般情况下函数重载使用成员函数实现**\n全局函数、类成员函数方法实现运算符重载步骤\n * 1）要承认操作符重载是一个函数，写出函数名称operator+ ()\n * 2）根据操作数，写出函数参数\n * 3）根据业务，完善函数返回值(看函数是返回引用 还是指针 元素)，及实现函数业务\n\n#### **3.友元函数实现操作符重载的应用场景**\n\n**1）友元函数和成员函数选择方法**\n- 当无法修改左操作数的类时，使用全局函数进行重载,因为成员函数需要在左边的类中进行修改；\n- =, [], ()和->操作符只能通过成员函数进行重载\n\n**2）用友元函数重载 <<和 >>操作符**\n\n* istream 和 ostream 是 C++ 的预定义流类，都不让修改的222222222222222222222222222222222222222222222\n* cin 是 istream 的对象，cout 是 ostream 的对象\n* 运算符 << 由ostream 重载为插入操作，用于输出基本类型数据\n* 运算符 >> 由 istream 重载为提取操作，用于输入基本类型数据\n* 用友员函数重载 << 和 >> ，输出和输入用户自定义的数据类型\n\na）用全局函数方法实现 << 操作符\n```pp\n//实现<<运算符的重载\n\n//注释内部是一套完整的程序，但是只能实现一次打印输出，新的一套程序可以实现链式输出\n\n#include \"iostream\"\nusing namespace std;\n\nclass Complex\n{\nprivate:\n\tint a;\n\tint b;\n\n\t//friend  void operator<<(ostream &cout, Complex &c1); //这里主要是针对全局函数\n\npublic:\n\tComplex(int a = 0, int b = 0)\n\t{\n\t\tthis->a = a;\n\n\t\tthis->b = b;\n\t}\n\n\tvoid printCom()\n\t{\n\t\tcout << a << \" + \" << b << \"i \" << endl;\n\t}\n};\n\n/*这里类似于cout只能有全局函数加上友元函数实现，因为如果要使用成员函数实现，需要在cout 的类：ostream中定义成员函数，\n但是这个ostream类是系统隐藏的，不现实；\nvoid operator<<(ostream &cout, Complex &c1)\n{\n\tcout << c1.a << \" + \" << c1.b << \"i\" << endl;\n}\n*/\n\nostream& operator<<(ostream &cout, Complex &c2)  //要想实现函数返回值当左值，需要返回一个引用\n{\n\tcout << c2.a << \" + \" << c2.b << \"i\" << endl;\n\treturn cout;\n}\n\n\n \nint  main()\n{\n\tComplex c1, c2;\n\t//cout << c1;  //实现将c1中两个元素以a+bi的形式直接打印输出；\n\t/*\n\t首先承认运算符重载是函数，所以函数名为：operator<<\n\t其次因为有左右参数，分别为ostream 和Complex类，所有函数头为：operator<<(ostream&cout,Complex c1)\n\t然后根据返回值确定最前面的返回值类型\n\t*/\n\n\tcout << c2 << \"kdjfkdjfkd\";\n\t//因为<<操作符是从左到右，所以左边执行返回值要当左值再次执行这个函数\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n**3）友元函数重载操作符使用注意点**\n\n- a） 友员函数重载运算符常用于运算符的左右操作数类型不同的情况\n![19]($resource/19.png)\n- b）其他\n  - 在第一个参数需要隐式转换的情形下，使用友员函数重载运算符是正确的选择\n  - 友员函数没有 this 指针，所需操作数都必须在参数表显式声明，很容易实现类型的隐式转换\n  - C++中不能用友员函数重载的运算符有\n     = （）  ［］  －>\n\n**4）友元函数案例vector类**\n```cpp\n#include <iostream>\nusing namespace std;\n\n//为vector类重载流插入运算符和提取运算符\n\nclass vector\n{\npublic:\n\tvector(int size = 1);\n\n\t~vector();\n\n\tint & operator[](int i);\n\n\tfriend ostream & operator << (ostream & output, vector &);\n\n\tfriend istream & operator >> (istream & input, vector &);\n\nprivate:\n\tint * v;\n\n\tint len;\n\n};\n\nvector::vector(int size)\n{\n\tif (size <= 0 || size > 100)\n\t{\n\t\tcout << \"The size of \" << size << \" is null !\\n\"; abort();\n\t}\n\n\tv = new int[size]; len = size;\n}\n\nvector :: ~vector()\n{\n\tdelete[] v;\n\n\tlen = 0;\n}\n\nint &vector::operator[](int i)\n{\n\tif (i >= 0 && i < len) return v[i];\n\n\tcout << \"The subscript \" << i << \" is outside !\\n\"; abort();\n}\n\nostream & operator << (ostream & output, vector & ary)\n{\n\tfor (int i = 0; i < ary.len; i++)\n\t\toutput << ary[i] << \" \";\n\n\toutput << endl;\n\treturn output;\n}\n\nistream & operator >> (istream & input, vector & ary)\n{\n\tfor (int i = 0; i < ary.len; i++)\n\t\tinput >> ary[i];\n\n\treturn input;\n}\n\nvoid main()\n{\n\tint k;\n\tcout << \"Input the length of vector A :\\n\";\n\tcin >> k;\n\tvector A(k);\n\tcout << \"Input the elements of vector A :\\n\";\n\tcin >> A;\n\tcout << \"Output the elements of vector A :\\n\";\n\tcout << A;\n\tsystem(\"pause\");\n}\n\n```\n\n### （四）运算符重载提高\n\n#### **1.运算符重载机制**\n\nC++编译器是如何支持操作符重载机制的?\n\n#### **2.重载赋值运算符=**\n\n* 赋值运算符重载用于对象数据的复制\n* operator= 必须重载为成员函数\n* 重载函数原型为：\n  类型&类名:: operator= ( const  类名 & ) ;\n\n案例：完善Name类，支持=号操作。\n![22]($resource/22.png)\n\n  结论:\n 1 先释放旧的内存\n 2 返回一个引用\n 3 =操作符 从右向左\n```cpp\n//重载 = 操作符\n\n#define _CRT_SECURE_NO_WARNINGS\n#include\"iostream\"\nusing namespace std;\n\nclass Name\n{\npublic:\n\n\tName(const char *pname)\n\t{\n\t\tsize = strlen(pname);\n\n\t\tpName = (char *)malloc(size + 1);\n\n\t\tstrcpy(pName, pname);\n\t}\n\n\tName(Name &obj)\n\t{\n\t\t//用obj来初始化自己\n\n\t\tpName = (char *)malloc(obj.size + 1);\n\n\t\tstrcpy(pName, obj.pName);\n\n\t\tsize = obj.size;\n\t}\n\n\t//析构函数\n\t~Name()\n\t{\n\n\t\tcout << \"开始析构\" << endl;\n\n\t\tif (pName != NULL)\n\n\t\t{\n\n\t\t\tfree(pName);\n\n\t\t\tpName = NULL;\n\n\t\t\tsize = 0;\n\n\t\t}\n\n\t}\n\n\t//obj3 = obj1; // C++编译器提供的  等号操作  也属  浅拷贝\\\n\t// obj4 = obj3 = obj1//如果要是实现这种连续的赋值，需要函数返回一个引用\n\t//obj3.operator=(obj1)//这种是成员函数的调用方法\n\n//具体的实现步骤，先释放obj3的内存,后根据obj1进行分配内存大小，最后将obj1赋值给obj3\n\tName& operator=(Name &obj1)\n\t{\n\t\t//1 先释放obj3旧的内存\n\n\t\tif (this->pName != NULL)\n\t\t{\n\t\t\tdelete[] pName;\n\t\t\tsize = 0;\n\n\t\t}\n\n\t\t//2 根据obj1分配内存大小\n\n\t\tthis->size = obj1.size;\n\t\tthis->pName = new char[size + 1];\n\n\t\t//3把obj1赋值给obj3\n\n\t\tstrcpy(pName, obj1.pName);\n\t\treturn *this;\n\n\t}\n\nprotected:\n\nprivate:\n\n\tchar *pName;\n\n\tint size;\n\n};\n\n//对象的初始化 和 对象之间=号操作是两个不同的概念\n\nvoid playObj()\n{\n\n\tName obj1(\"obj1.....\");\n\n\tName obj2 = obj1; //obj2创建并初始化\n\t//C++中提供的默认copy 构造函数是浅拷贝\n\n\tName obj3(\"obj3...\");\n\n\t//重载=号操作符\n\n\tobj2 = obj3; //=号操作\n\n\tcout << \"业务操作。。。5000\" << endl;\n}\n\nint main()\n{\n\tplayObj();\n\n\tsystem(\"pause\");\n}\n\n```\n\n\n#### **3.重载数组下表运算符[]** ==这里的视频再看一遍==\n- 重载[]和()运算符\n  - 运算符 [] 和 () 是二元运算符\n  - [] 和 () 只能用成员函数重载，不能用友元函数重载\n\n- 重载下标运算符 []\n  - [] 运算符用于访问数据对象的元素\n  重载格式：  返回值类型 类 :: operator[] ( 类型 ) ；\n###   设 x 是类 X 的一个对象，则表达式 `x[y]` 可被解释为  `x.operator[](y)`\n- 两种使用方法：\n  - 返回值当右值，相当于返回一个元素；\n  - 返回值当左值，相当于返回一个引用；\n  \n![33]($resource/33.png)\n![44]($resource/44.png)\n\n\n#### **4.重载函数调用符()**\n\n() 运算符用于函数调用\n\n重载格式:  返回值类型 类:: operator() ( 表达式表 ) ；\n\n例1\n设 x是类 X的一个对象，则表达式*\nx ( arg1, arg2, … )\n可被解释为\nx . operator () (arg1, arg2, … )\n\n**案例：**\n例2：用重载()运算符实现数学函数的抽象\n```cpp\n#include <iostream>\nusing namespace std;\nclass F\n{\npublic:\n\n\tdouble operator ( )  (double x, double y);\n};\n\ndouble F :: operator ( )  (double x, double y)\n{\n\treturn x * x + y * y;\n}\n\nvoid main()\n{\n\tF f;\n\t//对象名后面（参数）这种形式要不就是调用了构造函数，要不就是运算符重载\n\n\tcout << f(2, 4) << endl;  // f.operator()(5.2, 2.5)\n}\n```\n比较普通成员函数\n\n**//例3用重载()运算符实现 pk成员函数**\n```cpp\n#include <iostream.h>\n\nclass F\n\n { public :\n\n double memFun ( double x , double y ) ;\n\n } ;\n\ndouble F :: memFun ( double x , double y )\n\n { return x * x + y * y ; }\n\nvoid main ( )                     \n\n{\n\nF f ;\n\n cout << f.memFun ( 5.2 , 2.5 ) << endl ;\n\n}\n```\n\n#### **5.为什么不要重载&&和||操作符**\n\n- 理论知识：\n  - 1）&&和||是C++中非常特殊的操作符\n  - 2）&&和||内置实现了短路规则\n  - 3）操作符重载是靠函数重载来完成的\n  - 4）操作数作为函数参数传递\n  - 5）C++的函数参数都会被求值，无法实现短路规则\n```cpp\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nclass Test\n{\n\tint i;\npublic:\n\tTest(int i)\n\t{\n\t\tthis->i = i;\n\t}\n\n\tTest operator+ (const Test& obj)\n\t{\n\t\tTest ret(0);\n\t\tcout << \"执行+号重载函数\" << endl;\n\t\tret.i = i + obj.i;\n\t\treturn ret;\n\t}\n\n\tbool operator&& (const Test& obj)\n\t{\n\t\tcout << \"执行&&重载函数\" << endl;\n\t\treturn i && obj.i;\n\t}\n\n};\n\n// && 从左向右\nint  main()\n{\n\tint a1 = 0;\n\tint a2 = 1;\n\tcout << \"注意：&&操作符的结合顺序是从左向右\" << endl;\n\n\tif (a1 && (a1 + a2))\n\t{\n\t\tcout << \"有一个是假，则不在执行下一个表达式的计算\" << endl;\n\t}\n\n\tTest t1 = 0;\n\tTest t2 = 1;\n\n\tif(t1 && (t1 + t2))\n\t{\n\t\tt1.operator&&(t1 + t2);\n\t\tt1.operator&&(t1.operator+(t2));\n\n\t\t\t//t1 && t1.operator+(t2)//首先执行加号运算符重载\n\t\t\t// t1.operator( t1.operator(t2) )//再执行&&的运算符重载\n\t\t\tcout << \"两个函数都被执行了，而且是先执行了+\" << endl;\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n程序运行结果：\n`注意：&&操作符的结合顺序是从左向右`\n`执行+号重载函数`\n`执行&&重载函数`\n\n\n### （五）运算符重载在项目开发中的应用\n\n#### **1实现一个数组类**\n添加<< >>\n\n#### **2实现一个字符串类**\n//构造函数要求\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n//C++中 我们来设计一个字符串类 以零结尾的字符串\n\n具体函数实现：\n- 类的头文件：\n```cpp\n#pragma once\n#include \"iostream\"\nusing namespace std;\n\nclass MyString\n{\npublic:\n\tMyString();\n\tMyString(const char *p);\n\tMyString(const MyString &s);\n\t~MyString();\nprivate:\n\tint m_len;\n\tchar* m_p;\n\npublic:\n\tMyString& operator=(const char *p);\n\tMyString& operator= (const MyString &s);\n\n\tchar& operator[](int index);\n\n\tfriend ostream & operator<<(ostream &out, MyString &s);\n\n\tbool operator==(const char *p);\n\tbool operator!=(const char *p);\n\tbool operator==(const MyString&s);\n\tbool operator!=(const MyString &s);\n\n\tint operator<(const char *p);\n\tint operator<(const MyString &s);\n\n\tchar *c_str()\n\t{\n\t\treturn m_p;\n\t}\n\t//这个函数相比上面的区别只是得到的指针不能改变，在下面具体调用中嗲用\n\tconst char *c_str2()\n\t{\n\t\treturn m_p;\n\t}\n\n\tint length()\n\t{\n\t\treturn m_len;\n\t}\n};\n\n```\n\n头文件类的实现：\n(函数前面加的是域作用符)\n```cppp\n#include \"MyString.h\"\n#include\"math.h\"\n#include \"iostream\"\n#pragma warning(disable:4996)\n\n\nMyString::MyString() //构造函数：将默认的字符串进行默认为空字符串\n{\n\tm_len = 0;\n\tm_p = new char[m_len + 1];\n\tstrcpy(m_p, \" \");\n}\n\nMyString::MyString(const char *p)\n{\n\tif (p == NULL)\n\t{\n\t\tm_len = 0;\n\t\tm_p = new char[m_len + 1];\n\t\tstrcpy(m_p, \"\");\n\t}\n\telse\n\t{\n\t\tm_len = strlen(p);\n\t\tm_p = new char[m_len + 1];\n\t\tstrcpy(m_p, p);\n\t}\n}\n\n//拷贝构造函数\n//实现MyString s3 = s2;\n MyString::MyString(const MyString &s)\n{\n\tm_len = s.m_len;   \n\tm_p = new char[m_len + 1];  //分配空间\n\tstrcpy(m_p, s.m_p);\n}\n\n\n//析构函数的实现\n MyString::~MyString()\n {\n\t if (m_p != NULL)\n\t {\n\t\t delete[] m_p;\n\t\t m_p = NULL;\n\t\t m_len = 0;\n\t }\n }\n\n//下面进行的是操作符重载\n\t//等号=操作符重载\n MyString&MyString:: operator=(const char *p)\n\t{\n\t\t//用于实现s4 = \"s2222\"\n\t\t//因为s4已经分配内存，应该先将旧的内存空间删掉然后再分配新的\n\t\t\n\t\t//释放旧内存\n\t\tif (m_p != NULL)\n\t\t{\n\t\t\tdelete[] m_p;\n\t\t\tm_len = 0;\n\t\t}\n\n\t\t//分配新的内存\n\t\tif (p == NULL)\n\t\t{\n\t\t\tm_len = 0;\n\t\t\tm_p = new char[m_len + 1];\n\t\t\tstrcpy(m_p, \"\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_len = strlen(p);\n\t\t\tm_p = new char[m_len + 1];\n\t\t\tstrcpy(m_p, p);\n\t\t}\n\t\treturn *this;\n\t}\n\n\n\n MyString&MyString:: operator= (const MyString &s)\n\t{\n\t\t//用于实现s4 = s2\n\t\tif (m_p != NULL)\n\t\t{\n\t\t\tdelete[] m_p;\n\t\t\tm_len = 0;\n\t\t}\n\n\t\t//根据s分配新的内存\n\t\tm_len = s.m_len;\n\t\tm_p = new char[m_len + 1];\n\t\tstrcpy(m_p, s.m_p);\n\t\n\t\treturn *this;\n\t}\n\n\n\n char&MyString::operator[](int index)\n {\n\t return m_p[index];\n }\n\n\n //注意这个是全局函数，所以函数名前面不能加上MyString::  \n ostream& operator<<(ostream &out, MyString &s)\n {\n\t cout << s.m_p;\n\t return out;\n }\n\n\n\n //下面是实现==和!= 的重载，其中分为类和字符串的比较与类和类的比较\n bool MyString::operator==(const char *p)\n {\n\t if (p == NULL)\n\t {\n\t\t if (m_len == 0)\n\t\t {\n\t\t\t return true;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t return false;\n\t\t }\n\t }\n\t else\n\t {\n\t\t if (m_len == strlen(p))\n\t\t {\n\t\t\t return !strcmp(m_p, p);\n\t\t } \n\t\t else\n\t\t {\n\t\t\t return false;\n\t\t }\n\t }\n\t return true;\n }\n\n bool MyString::operator!=(const char *p)\n {\n\t return !(*this == p);\n }\n\n\n //两个类之间的比较\n bool MyString::operator==(const MyString&s)\n {\n\tif (m_len != s.m_len)\n\t{\n\t\treturn false;\n\t}\n\treturn !strcmp(m_p, s.m_p);\n }\n\n bool MyString::operator!=(const MyString &s)\n {\n\t return !(*this == s);\n }\n\n\n\n\n\n\n //实现  <  的重载\n\n int MyString::operator<(const char *p)\n {\n\t return strcmp(this->m_p, p);\n }\n int MyString::operator<(const MyString &s)\n {\n\t return strcmp(this->m_p, s.m_p);\n }\n```\n\n函数调用实现：\n```cppp\n// 实现一个字符串类\n\n\n//C语言中 没有字符串这种类型，是通过数组来模拟字符串\n\n//C++中 我们来设计一个字符串类 以零结尾的字符串\n\n//若len为0,表示空串\n\n#include \"iostream\"\n#include \"MyString.h\"\nusing namespace std;\n#pragma  warning (disable: 4996)\n\n\nint main()\n{\n\tMyString s1;\n\tMyString s2(\"s2\");\n\tMyString s2_2 = NULL;\n\tMyString s3 = s2;\n\n\n\n\n\t//下面进行操作符重载\n//=操作符\n\t//两种调用方式；\n\tMyString s4 = \"adfdfdn\";\n\t\n\ts4 = \"s2222\"; \n\n\t//调用方式二；\n\ts4 = s2;\n\n\n\n\n//实现[]重载\n  //当[]当右值的时候\n\ts4[1] = 'a';\n\tcout << \"s4[1] = \" << s4[1] << endl;\n\t\n\t\n\n//实现<<操作符的重载\n\tcout << s4 << endl;   //相当于实现字符串的整体输出\n\n\n\n//实现== 和!= 的重载\n\tMyString s5 = \"ahhhh\";\n\t\n\tif (s5 == \"shhsk\")\n\t{\n\t\tcout << \"true\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"false\" << endl;\n\t}\n\n\tif (s5 != \"sjfddsj\")\n\t{\n\t\tcout << \"false\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"true\" << endl;\n\t}\n\t\n\t//两个类之间做判断\n\t\n\tif (s5 == s2)\n\t{\n\t\tcout << \"true\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"false\" << endl;\n\t}\n\n\tif (s5 != s2)\n\t{\n\t\tcout << \"false\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"true\" << endl;\n\t}\n\n\n\n//实现大于小于号的符号重载\n\n\tMyString s6 = \"skdjfkld\";\n\tif (s6 < \"kdjfkdj\")\n\t{\n\t\tcout << \"s6 小于 skdjfkld\" << endl;\n\t} \n\telse\n\t{\n\t\tcout << \"s6 大于 skdjfkld\" << endl;\n\t}\n\n\n\tif (s6 < s5)\n\t{\n\t\tcout << \"s6 小于 s5\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"s6 大于 s5\" << endl;\n\t}\n\n\n\n\n\n\t//使用类中的private:的指针\n\n\tMyString s7 = \"jdkfjdklfjdl\";\n\tstrcpy(s7.c_str(), \"lskjdfkljdklf\");\n\tcout << s7 << endl;\n}\n\n```\n\n\n#### **3智能指针类编写**\n\n1问题抛出\n  指针使用过程中，经常会出现内存泄漏和内存多次被释放常\n\n2解决方案：例如：boost库的智能指针\n  项目开发中，要求开发者使用预先编写的智能指针类对象代替C语言中的原生指针\n\n3智能指针思想\n  工程中的智能指针是一个类模板\n  通过构造函数接管申请的内存\n  通过析构函数确保堆内存被及时释放\n  通过重载指针运算符* 和 -> 来模拟指针的行为\n  通过重载比较运算符 == 和 != 来模拟指针的比较\n\n```cpp\nclass Test\n{\npublic:\n Test()\n {\n   this->a = 10;\n }\n\n void printT()\n {\n   cout<<a<<endl;\n }\n\nprivate:\n int a;\n};\n\nclass MyTestPointer\n{\npublic:\n\npublic:\n MyTestPointer()\n {\n   p = NULL;\n }\n\n MyTestPointer(Test* p)\n {\n   this->p = p;\n }\n\n ~MyTestPointer()\n {\n   delete p;\n }\n\n Test* operator->()\n {\n   return p;\n }\n\n Test& operator*()\n {\n   return *p;\n }\n\nprotected:\n Test *p;\n};\n\nvoid main01_classp()\n{\n Test *p = new Test;\n p->printT();\n delete p;\n MyTestPointer myp = new Test; //构造函数\n myp->printT(); //重载操作符 ->\n};\n\n```\n\n```cpp\nclass MyIntPointer\n{\npublic:\n MyIntPointer()\n {\n   p = NULL;\n }\n\n MyIntPointer(int* p)\n {\n   this->p = p;\n }\n\n ~MyIntPointer()\n {\n   delete p;\n }\n\n int* operator->()\n {\n   return p;\n }\n\n int& operator*()\n {\n   return *p;\n }\n\nprotected:\n int *p;\n};\n\nvoid main02_intp()\n{\n int *p = new int(100);\n cout<<*p<<endl;\n delete p;\n MyIntPointer myp = new int(200);\n cout<<*myp<<endl; //重载*操作符\n};\n```\n\n**8.7 附录：运算符和结合性**\n\n![55]($resource/55.png)\n![66]($resource/66.png)\n\n- 总结\n  * 操作符重载是C++的强大特性之一\n  * 操作符重载的本质是通过函数扩展操作符的语义\n  * operator关键字是操作符重载的关键\n  * friend关键字可以对函数或类开发访问权限\n  * 操作符重载遵循函数重载的规则\n  * 操作符重载可以直接使用类的成员函数实现\n  * =, [], ()和->操作符只能通过成员函数进行重载\n  * ++操作符通过一个int参数进行前置与后置的重载\n  * C++中不要重载&&和||操作符\n\n\n\n\n\n\n",[[1554445890087,["GJX@GJXAIOU",[[1,52481," \n\t"]],[52479,52479],[52482,52482]]],[1554445933904,["GJX@GJXAIOU",[[-1,52481," "]],[52482,52482],[52481,52481]]],[1554445934801,["GJX@GJXAIOU",[[1,52481,"、"]],[52481,52481],[52482,52482]]],[1554445935303,["GJX@GJXAIOU",[[1,52484,"\n\t"]],[52482,52482],[52484,52484]]]],null,"GJX@GJXAIOU"]]}