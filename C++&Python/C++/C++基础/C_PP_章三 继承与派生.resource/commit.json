{"compress":true,"commitItems":[["0addb8f1-d87c-4f72-8179-85852ad6e4fc",1543923827641,"",[[1543923794715,["gjx16@GJXAIOU",[[1,0,"# C_PP_章三 继承\n\n\n\n"]],[0,0],[15,15]]],[1543923820889,["gjx16@GJXAIOU",[[1,12,"和派生"]],[12,12],[15,15]]],[1543923893226,["gjx16@GJXAIOU",[[1,18,"**3.1****继承概念**\n\n面向对象程序设计有4个主要特点：抽象、封装、继承和多态性。我们已经讲解了类和对象，了解了面向对象程序设计的两个重要特征一数据抽象与封装，已经能够设计出基于对象的程序，这是面向对象程序设计的基础。\n\n要较好地进行面向对象程序设计，还必须了解面向对象程序设计另外两个重要特 征——继承性和多态性。本章主要介绍有关继承的知识，多态性将在后续章节中讲解。\n\n继承性是面向对象程序设计最重要的特征，可以说，如果没有掌握继承性，就等于没有掌握类和对象的精华，就是没有掌握面向对象程序设计的真谛。\n\n**3.1.1****类之间的关系**\n\nhas-A，uses-A 和 is-A\n\nhas-A 包含关系，用以描述一个类由多个“部件类”构成。实现has-A关系用类成员表示，即一个类中的数据成员是另一种已经定义的类。\n\nuses-A 一个类部分地使用另一个类。通过类之间成员函数的相互联系，定义友员或对象参数传递实现。\n\nis-A 机制称为“继承”。关系具有传递性,不具有对称性。\n\n**3.1.2****继承关系举例**\n\n万事万物中皆有继承，是重要的现象 \n\n两个案例：1）植物继承图；2）程序员继承图\n\n**3.1.3** **继承相关概念**\n\n**3.1.4** **派生类的定义**\n\n注意：C++中的继承方式（public、private、protected）会影响子类的对外访问属性。\n\n**3.1.5** **继承重要说明**\n\n1、子类拥有父类的所有成员变量和成员函数\n\n2、子类可以拥有父类没有的方法和属性\n\n3、子类就是一种特殊的父类\n\n4、子类对象可以当作父类对象使用\n\n**3.2****派生类的访问控制**\n\n派生类继承了基类的全部成员变量和成员方法（除了构造和析构之外的成员方法），但是这些成员的访问属性，在派生过程中是可以调整的。\n\n**3.2.1****单个类的访问控制**\n\n1、类成员访问级别（public、private、protected）\n\n2、思考：类成员的访问级别只有public和private是否足够？\n\n**3.2.2****不同的继承方式会改变继承成员的访问属性**\n\n**1****）C++****中的继承方式会影响子类的对外访问属性**\n\npublic继承：父类成员在子类中保持原有访问级别\n\nprivate继承：父类成员在子类中变为private成员\n\nprotected继承：父类中public成员会变成protected\n\n  父类中protected成员仍然为protected\n\n  父类中private成员仍然为private\n\n2）**private****成员在子类中依然存在，但是却无法访问到。不论种方式继承基类，派生类都不能直接使用基类的私有成员** **。**\n\n**3****）C++****中子类对外访问属性表**\n\n|  | \n\n父类成员访问级别\n\n |\n| \n\n继\n\n承\n\n方\n\n式\n\n |  | \n\npublic\n\n | \n\nproteced\n\n | \n\nprivate\n\n |\n| \n\npublic\n\n | \n\npublic\n\n | \n\nproteced\n\n | \n\nprivate\n\n |\n| \n\nproteced\n\n | \n\nproteced\n\n | \n\nproteced\n\n | \n\nprivate\n\n |\n| \n\nprivate\n\n | \n\nprivate\n\n | \n\nprivate\n\n | \n\nPrivate\n\n |\n\n**4****）继承中的访问控制**\n\n**3.2.3****“三看”原则**\n\nC++中的继承方式（public、private、protected）会影响子类的对外访问属性    \n\n判断某一句话，能否被访问\n\n 1）看调用语句，这句话写在子类的内部、外部\n\n 2）看子类如何从父类继承（public、private、protected）    \n\n 3）看父类中的访问级别（public、private、protected）\n\n**3.2.3****派生类类成员访问级别设置的原则**\n\n思考：如何恰当的使用public，protected和private为成员声明访问级别？\n\n1、需要被外界访问的成员直接设置为public\n\n2、只能在当前类中访问的成员设置为private\n\n3、只能在当前类和子类中访问的成员设置为protected，protected成员的访问权限介于public和private之间。\n\n**3.2.4****综合训练**\n\n练习：\n\npublic继承不会改变父类对外访问属性；\n\nprivate继承会改变父类对外访问属性为private；\n\nprotected继承会部分改变父类对外访问属性。\n\n结论：一般情况下class B : public A\n\n| \n\n//类的继承方式对子类对外访问属性影响\n\n#include <cstdlib>\n\n#include <iostream>\n\nusing namespace std;\n\nclass A\n\n{\n\nprivate:\n\n int a;\n\nprotected:\n\n int b;\n\npublic:\n\n int c;\n\n A()\n\n {\n\n a = 0;\n\n b = 0;\n\n c = 0;\n\n }\n\n void set(int a, int b, int c)\n\n {\n\n this->a = a;\n\n this->b = b;\n\n this->c = c;\n\n }\n\n};\n\nclass B : public A\n\n{\n\npublic:\n\n void print()\n\n {\n\n //cout<<\"a = \"<<a; //err\n\n cout<<\"b = \"<<b;\n\n cout<<\"c = \"<<endl;\n\n }\n\n};\n\nclass C : protected A\n\n{\n\npublic:\n\n void print()\n\n {\n\n //cout<<\"a = \"<<a; //err\n\n cout<<\"b = \"<<b;\n\n cout<<\"c = \"<<endl;\n\n }\n\n};\n\nclass D : private A\n\n{\n\npublic:\n\n void print()\n\n {\n\n //cout<<\"a = \"<<a; //err\n\n cout<<\"b = \"<<b<<endl;\n\n cout<<\"c = \"<<c<<endl;\n\n }\n\n};\n\nint main_01(int argc, char *argv[])\n\n{\n\n A aa;\n\n B bb;\n\n C cc;\n\n D dd;\n\n aa.c = 100; //ok\n\n bb.c = 100; //ok\n\n //cc.c = 100; //err 类的外部是什么含义\n\n //dd.c = 100; //err\n\n aa.set(1, 2, 3);\n\n bb.set(10, 20, 30);\n\n //cc.set(40, 50, 60); //ee\n\n //dd.set(70, 80, 90); //ee\n\n bb.print();\n\n cc.print();\n\n dd.print();\n\n system(\"pause\");\n\n return 0;\n\n}\n\n |"]],[18,18],[3059,3059]]],[1543923985976,["gjx16@GJXAIOU",[[1,533,"\n"]],[531,531],[532,532]]],[1543923993172,["gjx16@GJXAIOU",[[1,532,"![1]($resource/1.png)"]],[532,532],[554,554]]],[1543923998252,["gjx16@GJXAIOU",[[1,577,"\n"]],[576,576],[577,577]]],[1543924006217,["gjx16@GJXAIOU",[[1,576,"![2]($resource/2.png)"]],[576,576],[598,598]]],[1543924026056,["gjx16@GJXAIOU",[[1,621,"\n"]],[620,620],[621,621]]],[1543924032900,["gjx16@GJXAIOU",[[1,621,"![3]($resource/3.png)"]],[621,621],[643,643]]],[1543924035104,["gjx16@GJXAIOU",[[1,643,"\n"]],[642,642],[643,643]]],[1543924050959,["gjx16@GJXAIOU",[[-1,1298,"|  | \n\n父类成员访问级别\n\n |\n| \n\n继\n\n承\n\n方\n\n式\n\n |  | \n\npublic\n\n | \n\nproteced\n\n | \n\nprivate\n\n |\n| \n\npublic\n\n | \n\npublic\n\n | \n\nproteced\n\n | \n\nprivate\n\n |\n| \n\nproteced\n\n | \n\nproteced\n\n | \n\nproteced\n\n | \n\nprivate\n\n |\n| \n\nprivate\n\n | \n\nprivate\n\n | \n\nprivate\n\n | \n\nPrivate\n\n |"]],[1298,1557],[1298,1298]]],[1543924068289,["gjx16@GJXAIOU",[[1,1297,"|  | \n\npublic\n\n | \n\nproteced\n\n | \n\nprivate\n\n |\n| \n\npublic\n\n | \n\npublic\n\n | \n\nproteced\n\n | \n\nprivate\n\n |\n| \n\nproteced\n\n | \n\nproteced\n\n | \n\nproteced\n\n | \n\nprivate\n\n |\n| \n\nprivate\n\n | \n\nprivate\n\n | \n\nprivate\n\n | \n\nPrivate\n\n |"]],[1297,1297],[1519,1519]]],[1543924069713,["gjx16@GJXAIOU",[[-1,1297,"|  | \n\npublic\n\n | \n\nproteced\n\n | \n\nprivate\n\n |\n| \n\npublic\n\n | \n\npublic\n\n | \n\nproteced\n\n | \n\nprivate\n\n |\n| \n\nproteced\n\n | \n\nproteced\n\n | \n\nproteced\n\n | \n\nprivate\n\n |\n| \n\nprivate\n\n | \n\nprivate\n\n | \n\nprivate\n\n | \n\nPrivate\n\n |"]],[1519,1519],[1297,1297]]],[1543924071500,["gjx16@GJXAIOU",[[1,1298,"\tpublic\tproteced\tprivate\npublic\tpublic\tproteced\tprivate\nproteced\tproteced\tproteced\tprivate\nprivate\tprivate\tprivate\tPrivate\n"]],[1298,1298],[1421,1421]]],[1543924074848,["gjx16@GJXAIOU",[[-1,507," "],[1,508," "],[1,1299," "],[-1,1511,"    "],[1,1515,"    "],[-1,1594,"    "],[1,1598,"    "]],[1299,1299],[1300,1300]]],[1543924104097,["gjx16@GJXAIOU",[[1,1297,"；"]],[1297,1297],[1298,1298]]],[1543924104711,["gjx16@GJXAIOU",[[-1,1297,"；"]],[1298,1298],[1297,1297]]],[1543924107236,["gjx16@GJXAIOU",[[1,1297,"、"]],[1297,1297],[1298,1298]]],[1543924107679,["gjx16@GJXAIOU",[[-1,1297,"、"]],[1298,1298],[1297,1297]]],[1543924124981,["gjx16@GJXAIOU",[[1,1297,"|    |  }"]],[1297,1297],[1306,1306]]],[1543924125879,["gjx16@GJXAIOU",[[-1,1305,"}"]],[1306,1306],[1305,1305]]],[1543924136177,["gjx16@GJXAIOU",[[1,1305,"|  |  |  |"]],[1305,1305],[1315,1315]]],[1543924136907,["gjx16@GJXAIOU",[[1,1316,"\n"]],[1315,1315],[1316,1316]]],[1543924146865,["gjx16@GJXAIOU",[[1,1316,"|---|---|---|  "]],[1316,1316],[1331,1331]]],[1543924147783,["gjx16@GJXAIOU",[[-1,1329,"  "]],[1331,1331],[1329,1329]]],[1543924154581,["gjx16@GJXAIOU",[[1,1329,"---|---|"]],[1329,1329],[1337,1337]]],[1543924158258,["gjx16@GJXAIOU",[[1,1338,"|"]],[1338,1338],[1339,1339]]],[1543924161178,["gjx16@GJXAIOU",[[1,1341,"|"]],[1341,1341],[1342,1342]]],[1543924166522,["gjx16@GJXAIOU",[[1,1348,"|"]],[1348,1348],[1349,1349]]],[1543924178146,["gjx16@GJXAIOU",[[1,1340,"|"]],[1340,1340],[1341,1341]]],[1543924181764,["gjx16@GJXAIOU",[[1,1359,"|"]],[1359,1359],[1360,1360]]],[1543924185038,["gjx16@GJXAIOU",[[1,1368,"|"]],[1368,1368],[1369,1369]]],[1543924188043,["gjx16@GJXAIOU",[[1,1370,"|"]],[1370,1370],[1371,1371]]],[1543924190876,["gjx16@GJXAIOU",[[1,1402,"|"]],[1402,1402],[1403,1403]]],[1543924192284,["gjx16@GJXAIOU",[[1,1438,"|"]],[1438,1438],[1439,1439]]],[1543924194987,["gjx16@GJXAIOU",[[1,1447,"|"]],[1447,1447],[1448,1448]]],[1543924197140,["gjx16@GJXAIOU",[[1,1412,"|"]],[1412,1412],[1413,1413]]],[1543924199533,["gjx16@GJXAIOU",[[1,1378,"|"]],[1378,1378],[1379,1379]]],[1543924202978,["gjx16@GJXAIOU",[[1,1386,"|"]],[1386,1386],[1387,1387]]],[1543924206012,["gjx16@GJXAIOU",[[1,1395,"|"]],[1395,1395],[1396,1396]]],[1543924208634,["gjx16@GJXAIOU",[[1,1404,"|"]],[1404,1404],[1405,1405]]],[1543924212347,["gjx16@GJXAIOU",[[1,1434,"|"]],[1434,1434],[1435,1435]]],[1543924215035,["gjx16@GJXAIOU",[[1,1425,"|"]],[1425,1425],[1426,1426]]],[1543924217005,["gjx16@GJXAIOU",[[1,1462,"|"]],[1462,1462],[1463,1463]]],[1543924219385,["gjx16@GJXAIOU",[[1,1472,"|"]],[1472,1472],[1473,1473]]],[1543924221761,["gjx16@GJXAIOU",[[1,1480,"|"]],[1480,1480],[1481,1481]]],[1543924223417,["gjx16@GJXAIOU",[[1,1444,"|"]],[1444,1444],[1445,1445]]],[1543924255082,["gjx16@GJXAIOU",[[1,1371," | "]],[1371,1371],[1374,1374]]],[1543924259035,["gjx16@GJXAIOU",[[1,1410,"| "]],[1410,1410],[1412,1412]]],[1543924261913,["gjx16@GJXAIOU",[[1,1452,"|"]],[1452,1452],[1453,1453]]],[1543924263082,["gjx16@GJXAIOU",[[1,1452," "]],[1452,1452],[1453,1453]]],[1543924263924,["gjx16@GJXAIOU",[[1,1410," "]],[1410,1410],[1411,1411]]],[1543924279273,["gjx16@GJXAIOU",[[1,1304,"fulei"]],[1304,1304],[1309,1309]]],[1543924280958,["gjx16@GJXAIOU",[[-1,1304,"fulei "]],[1309,1309],[1303,1303]]],[1543924283944,["gjx16@GJXAIOU",[[1,1303,"父类"]],[1303,1303],[1305,1305]]],[1543924292138,["gjx16@GJXAIOU",[[1,1307,"成员"]],[1307,1307],[1309,1309]]],[1543924296128,["gjx16@GJXAIOU",[[-1,1312,"  "],[1,1314,"访问"]],[1312,1312],[1314,1314]]],[1543924298322,["gjx16@GJXAIOU",[[-1,1315,"  "],[1,1317,"级别"]],[1315,1315],[1317,1317]]],[1543924312372,["gjx16@GJXAIOU",[[1,1342,"继承"]],[1342,1342],[1344,1344]]],[1543924312662,["gjx16@GJXAIOU",[[-1,1343,"承"]],[1344,1344],[1343,1343]]],[1543924320133,["gjx16@GJXAIOU",[[1,1375,"继承"]],[1375,1375],[1377,1377]]],[1543924321345,["gjx16@GJXAIOU",[[-1,1375,"继"]],[1376,1376],[1375,1375]]],[1543924324032,["gjx16@GJXAIOU",[[1,1415,"方式"]],[1415,1415],[1417,1417]]],[1543924324743,["gjx16@GJXAIOU",[[-1,1416,"式"]],[1417,1417],[1416,1416]]],[1543924328099,["gjx16@GJXAIOU",[[1,1459,"方式"]],[1459,1459],[1461,1461]]],[1543924329344,["gjx16@GJXAIOU",[[-1,1459,"方"]],[1460,1460],[1459,1459]]],[1543924366726,["gjx16@GJXAIOU",[[1,1520,"\n"]],[1519,1519],[1520,1520]]],[1543924374676,["gjx16@GJXAIOU",[[1,1519,"![4]($resource/4.png)"]],[1519,1519],[1541,1541]]],[1543924508087,["gjx16@GJXAIOU",[[-1,2066,"| "]],[2066,2068],[2066,2066]]],[1543924508980,["gjx16@GJXAIOU",[[1,2066,"·"]],[2066,2066],[2067,2067]]],[1543924509774,["gjx16@GJXAIOU",[[-1,2066,"·"]],[2067,2067],[2066,2066]]],[1543924510677,["gjx16@GJXAIOU",[[1,2066,"```"]],[2066,2066],[2069,2069]]],[1543924510708,["gjx16@GJXAIOU",[[1,2069,"language\n```\n"]],[2069,2069],[2069,2077]]],[1543924512507,["gjx16@GJXAIOU",[[-1,2069,"language"],[1,2077,"c"]],[2069,2077],[2070,2070]]],[1543924512800,["gjx16@GJXAIOU",[[1,2070,"pp"]],[2070,2070],[2072,2072]]],[1543924513512,["gjx16@GJXAIOU",[[1,2073,"\n"]],[2072,2072],[2073,2073]]],[1543924518367,["gjx16@GJXAIOU",[[-1,2074,"```"]],[2074,2077],[2074,2074]]],[1543924520486,["gjx16@GJXAIOU",[[-1,2076,"\n"]],[2076,2076],[2075,2075]]],[1543924520614,["gjx16@GJXAIOU",[[-1,2075,"\n"]],[2075,2075],[2074,2074]]],[1543924521118,["gjx16@GJXAIOU",[[-1,2074,"\n"]],[2074,2074],[2073,2073]]],[1543924538878,["gjx16@GJXAIOU",[[-1,3091," |"]],[3091,3093],[3091,3091]]],[1543924539006,["gjx16@GJXAIOU",[[-1,3091,"\n"]],[3091,3091],[3090,3090]]],[1543924539697,["gjx16@GJXAIOU",[[-1,3090,"\n"],[1,3091,"`"]],[3090,3090],[3091,3091]]],[1543924540051,["gjx16@GJXAIOU",[[1,3091,"``"]],[3091,3091],[3093,3093]]],[1543924796068,["gjx16@GJXAIOU",[[-1,2166,"\n"],[-1,2169,"\n"],[-1,2179,"\n "],[1,2181,"\t"],[-1,2200,"\n "],[1,2202,"\t"],[-1,2218,"\n "],[1,2220,"\t"],[-1,2228," "],[1,2229,"\t"],[-1,2233,"\n {\n\n "],[1,2239,"\t{\n\t\t"],[-1,2246,"\n "],[1,2248,"\t\t"],[-1,2255,"\n "],[1,2257,"\t\t"],[-1,2264,"\n }\n\n "],[1,2270,"\t}\n\n\t"],[-1,2300,"\n {\n\n "],[1,2306,"\t{\n\t\t"],[-1,2319,"\n "],[1,2321,"\t\t"],[-1,2334,"\n "],[1,2336,"\t\t"],[-1,2349,"\n "],[1,2351,"\t"],[-1,2377,"\n"],[-1,2380,"\n"],[-1,2389,"\n "],[1,2391,"\t"],[-1,2404,"\n {\n\n "],[1,2410,"\t{\n\t\t"],[-1,2435,"\n "],[1,2437,"\t\t"],[1,2441," "],[1,2443," "],[1,2449," "],[1,2451," "],[-1,2454,"\n "],[1,2456,"\t\t"],[1,2460," "],[1,2462," "],[1,2468," "],[1,2470," "],[-1,2476,"\n }\n"],[1,2480,"\t}"],[-1,2507,"\n"],[-1,2510,"\n"],[-1,2519,"\n "],[1,2521,"\t"],[-1,2534,"\n {\n\n "],[1,2540,"\t{\n\t\t"],[-1,2565,"\n "],[1,2567,"\t\t"],[1,2571," "],[1,2573," "],[1,2579," "],[1,2581," "],[-1,2584,"\n "],[1,2586,"\t\t"],[1,2590," "],[1,2592," "],[1,2598," "],[1,2600," "],[-1,2606,"\n }\n"],[1,2610,"\t}"],[-1,2635,"\n"],[-1,2638,"\n"],[-1,2647,"\n "],[1,2649,"\t"],[-1,2662,"\n {\n\n "],[1,2668,"\t{\n\t\t"],[-1,2693,"\n "],[1,2695,"\t\t"],[1,2699," "],[1,2701," "],[1,2707," "],[1,2709," "],[1,2710," "],[1,2712," "],[-1,2718,"\n "],[1,2720,"\t\t"],[1,2724," "],[1,2726," "],[1,2732," "],[1,2734," "],[1,2735," "],[1,2737," "],[-1,2743,"\n }\n"],[1,2747,"\t}"],[-1,2788,"\n"],[-1,2791,"\n "],[1,2793,"\t"],[-1,2799,"\n "],[1,2801,"\t"],[-1,2807,"\n "],[1,2809,"\t"],[-1,2815,"\n "],[1,2817,"\t"],[-1,2823,"\n "],[1,2825,"\t"],[-1,2842,"\n "],[1,2844,"\t"],[-1,2861,"\n "],[1,2863,"\t"],[-1,2893,"\n "],[1,2895,"\t"],[-1,2915,"\n "],[1,2917,"\t"],[-1,2934,"\n "],[1,2936,"\t"],[-1,2956,"\n "],[1,2958,"\t"],[-1,2986," "],[1,2987,"\t"],[-1,3014,"\n "],[1,3016,"\t"],[-1,3028,"\n "],[1,3030,"\t"],[-1,3042,"\n "],[1,3044,"\t"],[-1,3056,"\n "],[1,3058,"\t"],[-1,3075,"\n "],[1,3077,"\t"],[-1,3086,"\n"]],[2095,3089],[3072,3072]]],[1543924800056,["gjx16@GJXAIOU",[[1,2166,"\n"],[1,2168,"\n"],[1,2177,"\n "],[-1,2177,"\t"],[1,2197,"\n "],[-1,2197,"\t"],[1,2214,"\n "],[-1,2214,"\t"],[1,2223," "],[-1,2223,"\t"],[1,2228,"\n {\n\n "],[-1,2228,"\t{\n\t\t"],[1,2240,"\n "],[-1,2240,"\t\t"],[1,2249,"\n "],[-1,2249,"\t\t"],[1,2258,"\n }\n\n "],[-1,2258,"\t}\n\n\t"],[1,2293,"\n {\n\n "],[-1,2293,"\t{\n\t\t"],[1,2311,"\n "],[-1,2311,"\t\t"],[1,2326,"\n "],[-1,2326,"\t\t"],[1,2341,"\n "],[-1,2341,"\t"],[1,2368,"\n"],[1,2370,"\n"],[1,2378,"\n "],[-1,2378,"\t"],[1,2392,"\n {\n\n "],[-1,2392,"\t{\n\t\t"],[1,2422,"\n "],[-1,2422,"\t\t"],[-1,2428," "],[-1,2431," "],[-1,2438," "],[-1,2441," "],[1,2445,"\n "],[-1,2445,"\t\t"],[-1,2451," "],[-1,2454," "],[-1,2461," "],[-1,2464," "],[1,2471,"\n }\n"],[-1,2471,"\t}"],[1,2500,"\n"],[1,2502,"\n"],[1,2510,"\n "],[-1,2510,"\t"],[1,2524,"\n {\n\n "],[-1,2524,"\t{\n\t\t"],[1,2554,"\n "],[-1,2554,"\t\t"],[-1,2560," "],[-1,2563," "],[-1,2570," "],[-1,2573," "],[1,2577,"\n "],[-1,2577,"\t\t"],[-1,2583," "],[-1,2586," "],[-1,2593," "],[-1,2596," "],[1,2603,"\n }\n"],[-1,2603,"\t}"],[1,2630,"\n"],[1,2632,"\n"],[1,2640,"\n "],[-1,2640,"\t"],[1,2654,"\n {\n\n "],[-1,2654,"\t{\n\t\t"],[1,2684,"\n "],[-1,2684,"\t\t"],[-1,2690," "],[-1,2693," "],[-1,2700," "],[-1,2703," "],[-1,2705," "],[-1,2708," "],[1,2715,"\n "],[-1,2715,"\t\t"],[-1,2721," "],[-1,2724," "],[-1,2731," "],[-1,2734," "],[-1,2736," "],[-1,2739," "],[1,2746,"\n }\n"],[-1,2746,"\t}"],[1,2789,"\n"],[1,2791,"\n "],[-1,2791,"\t"],[1,2798,"\n "],[-1,2798,"\t"],[1,2805,"\n "],[-1,2805,"\t"],[1,2812,"\n "],[-1,2812,"\t"],[1,2819,"\n "],[-1,2819,"\t"],[1,2837,"\n "],[-1,2837,"\t"],[1,2855,"\n "],[-1,2855,"\t"],[1,2886,"\n "],[-1,2886,"\t"],[1,2907,"\n "],[-1,2907,"\t"],[1,2925,"\n "],[-1,2925,"\t"],[1,2946,"\n "],[-1,2946,"\t"],[1,2975," "],[-1,2975,"\t"],[1,3003,"\n "],[-1,3003,"\t"],[1,3016,"\n "],[-1,3016,"\t"],[1,3029,"\n "],[-1,3029,"\t"],[1,3042,"\n "],[-1,3042,"\t"],[1,3060,"\n "],[-1,3060,"\t"],[1,3070,"\n"]],[3072,3072],[2095,3089]]],[1543924803139,["gjx16@GJXAIOU",[[-1,2166,"\n"],[-1,2169,"\n"],[-1,2179,"\n "],[1,2181,"\t"],[-1,2200,"\n "],[1,2202,"\t"],[-1,2218,"\n "],[1,2220,"\t"],[-1,2228," "],[1,2229,"\t"],[-1,2233,"\n {\n\n "],[1,2239,"\t{\n\t\t"],[-1,2246,"\n "],[1,2248,"\t\t"],[-1,2255,"\n "],[1,2257,"\t\t"],[-1,2264,"\n }\n\n "],[1,2270,"\t}\n\n\t"],[-1,2300,"\n {\n\n "],[1,2306,"\t{\n\t\t"],[-1,2319,"\n "],[1,2321,"\t\t"],[-1,2334,"\n "],[1,2336,"\t\t"],[-1,2349,"\n "],[1,2351,"\t"],[-1,2377,"\n"],[-1,2380,"\n"],[-1,2389,"\n "],[1,2391,"\t"],[-1,2404,"\n {\n\n "],[1,2410,"\t{\n\t\t"],[-1,2435,"\n "],[1,2437,"\t\t"],[1,2441," "],[1,2443," "],[1,2449," "],[1,2451," "],[-1,2454,"\n "],[1,2456,"\t\t"],[1,2460," "],[1,2462," "],[1,2468," "],[1,2470," "],[-1,2476,"\n }\n"],[1,2480,"\t}"],[-1,2507,"\n"],[-1,2510,"\n"],[-1,2519,"\n "],[1,2521,"\t"],[-1,2534,"\n {\n\n "],[1,2540,"\t{\n\t\t"],[-1,2565,"\n "],[1,2567,"\t\t"],[1,2571," "],[1,2573," "],[1,2579," "],[1,2581," "],[-1,2584,"\n "],[1,2586,"\t\t"],[1,2590," "],[1,2592," "],[1,2598," "],[1,2600," "],[-1,2606,"\n }\n"],[1,2610,"\t}"],[-1,2635,"\n"],[-1,2638,"\n"],[-1,2647,"\n "],[1,2649,"\t"],[-1,2662,"\n {\n\n "],[1,2668,"\t{\n\t\t"],[-1,2693,"\n "],[1,2695,"\t\t"],[1,2699," "],[1,2701," "],[1,2707," "],[1,2709," "],[1,2710," "],[1,2712," "],[-1,2718,"\n "],[1,2720,"\t\t"],[1,2724," "],[1,2726," "],[1,2732," "],[1,2734," "],[1,2735," "],[1,2737," "],[-1,2743,"\n }\n"],[1,2747,"\t}"],[-1,2788,"\n"],[-1,2791,"\n "],[1,2793,"\t"],[-1,2799,"\n "],[1,2801,"\t"],[-1,2807,"\n "],[1,2809,"\t"],[-1,2815,"\n "],[1,2817,"\t"],[-1,2823,"\n "],[1,2825,"\t"],[-1,2842,"\n "],[1,2844,"\t"],[-1,2861,"\n "],[1,2863,"\t"],[-1,2893,"\n "],[1,2895,"\t"],[-1,2915,"\n "],[1,2917,"\t"],[-1,2934,"\n "],[1,2936,"\t"],[-1,2956,"\n "],[1,2958,"\t"],[-1,2986," "],[1,2987,"\t"],[-1,3014,"\n "],[1,3016,"\t"],[-1,3028,"\n "],[1,3030,"\t"],[-1,3042,"\n "],[1,3044,"\t"],[-1,3056,"\n "],[1,3058,"\t"],[-1,3075,"\n "],[1,3077,"\t"],[-1,3086,"\n"]],[2095,3089],[3072,3072]]],[1543924807501,["gjx16@GJXAIOU",[[-1,2114,"\n"]],[2114,2114],[2113,2113]]],[1543924808563,["gjx16@GJXAIOU",[[-1,2134,"\n"]],[2134,2134],[2133,2133]]],[1543924809784,["gjx16@GJXAIOU",[[-1,2183,"\n"]],[2183,2183],[2182,2182]]],[1543924810741,["gjx16@GJXAIOU",[[-1,2202,"\n"]],[2202,2202],[2201,2201]]],[1543924811425,["gjx16@GJXAIOU",[[-1,2218,"\n"]],[2218,2218],[2217,2217]]],[1543924838754,["gjx16@GJXAIOU",[[1,3071,"\n\n"]],[3071,3071],[3072,3072]]],[1543924838894,["gjx16@GJXAIOU",[[1,3073,"\n"]],[3072,3072],[3073,3073]]],[1543924839007,["gjx16@GJXAIOU",[[1,3074,"\n"]],[3073,3073],[3074,3074]]],[1543924839551,["gjx16@GJXAIOU",[[1,3074,"**3.3****继承中的构造和析构**\n\n**3.3.1****类型兼容性原则**\n\n类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。类型兼容规则中所指的替代包括以下情况：\n\n子类对象可以当作父类对象使用\n\n子类对象可以直接赋值给父类对象\n\n子类对象可以直接初始化父类对象\n\n父类指针可以直接指向子类对象\n\n父类引用可以直接引用子类对象\n\n在替代之后，派生类对象就可以作为基类的对象使用，但是只能使用从基类继承的成员。\n\n类型兼容规则是多态性的重要基础之一。\n\n总结：子类就是特殊的父类 (**base *p = &child;)**\n\n| \n\n#include <cstdlib>\n\n#include <iostream>\n\nusing namespace std;\n\n/*\n\n子类对象可以当作父类对象使用\n\n  子类对象可以直接赋值给父类对象\n\n  子类对象可以直接初始化父类对象\n\n  父类指针可以直接指向子类对象\n\n  父类引用可以直接引用子类对象\n\n */\n\n//子类就是特殊的父类\n\nclass Parent03\n\n{\n\nprotected:\n\n const char* name;\n\npublic:\n\n Parent03()\n\n {\n\n name = \"Parent03\";\n\n }\n\n void print()\n\n {\n\n cout<<\"Name: \"<<name<<endl;\n\n }\n\n};\n\nclass Child03 : public Parent03\n\n{\n\nprotected:\n\n int i;\n\npublic:\n\n Child03(int i)\n\n {\n\n this->name = \"Child2\";\n\n this->i = i;\n\n }\n\n};\n\nint main()\n\n{\n\n Child03 child03(1000);\n\n //分别定义父类对象 父类指针 父类引用 child\n\n Parent03 parent = child03;\n\n Parent03* pp = &child03;\n\n Parent03& rp = child03;\n\n parent.print();\n\n pp->print();\n\n rp.print();\n\n system(\"pause\");\n\n return 0;\n\n}\n\n |\n\n**3.3.2****继承中的对象模型**\n\n类在C++编译器的内部可以理解为结构体\n\n子类是由父类成员叠加子类新成员得到的\n\n**继承中构造和析构**\n\n**问题：如何初始化父类成员？父类与子类的构造函数有什么关系**\n\n  在子类对象构造时，需要调用父类构造函数对其继承得来的成员进行初始化\n\n  在子类对象析构时，需要调用父类析构函数对其继承得来的成员进行清理\n\n| \n\n#include <cstdlib>\n\n#include <iostream>\n\nusing namespace std;\n\nclass Parent04\n\n{\n\npublic:\n\n Parent04(const char* s)\n\n {\n\n cout<<\"Parent04()\"<<\" \"<<s<<endl;\n\n }\n\n ~Parent04()\n\n {\n\n cout<<\"~Parent04()\"<<endl;\n\n }\n\n};\n\nclass Child04 : public Parent04\n\n{\n\npublic:\n\n Child04() : Parent04(\"Parameter from Child!\")\n\n {\n\n cout<<\"Child04()\"<<endl;\n\n }\n\n ~Child04()\n\n {\n\n cout<<\"~Child04()\"<<endl;\n\n }\n\n};\n\nvoid run04()\n\n{\n\n Child04 child;\n\n}\n\nint main_04(int argc, char *argv[])\n\n{\n\n run04();\n\n system(\"pause\");\n\n return 0;\n\n}\n\n |\n\n**3.3.3****继承中的构造析构调用原则**\n\n1、子类对象在创建时会首先调用父类的构造函数\n\n2、父类构造函数执行结束后，执行子类的构造函数\n\n3、当父类的构造函数有参数时，需要在子类的初始化列表中显示调用\n\n4、析构函数调用的先后顺序与构造函数相反\n\n**3.3.4****继承与组合混搭情况下，构造和析构调用原则**\n\n  原则：  先构造父类，再构造成员变量、最后构造自己\n\n  先析构自己，在析构成员变量、最后析构父类\n\n //先构造的对象，后释放\n\n练习：demo05_extend_construct_destory.cpp\n\n| \n\n//子类对象如何初始化父类成员\n\n//继承中的构造和析构\n\n//继承和组合混搭情况下，构造函数、析构函数调用顺序研究\n\n#include <iostream>\n\nusing namespace std;\n\nclass Object\n\n{\n\npublic:\n\n Object(const char* s)\n\n {\n\n cout<<\"Object()\"<<\" \"<<s<<endl;\n\n }\n\n ~Object()\n\n {\n\n cout<<\"~Object()\"<<endl;\n\n }\n\n};\n\nclass Parent : public Object\n\n{\n\npublic:\n\n Parent(const char* s) : Object(s)\n\n {\n\n cout<<\"Parent()\"<<\" \"<<s<<endl;\n\n }\n\n ~Parent()\n\n {\n\n cout<<\"~Parent()\"<<endl;\n\n }\n\n};\n\nclass Child : public Parent\n\n{\n\nprotected:\n\n Object o1;\n\n Object o2;\n\npublic:\n\n Child() : o2(\"o2\"), o1(\"o1\"), Parent(\"Parameter from Child!\")\n\n {\n\n cout<<\"Child()\"<<endl;\n\n }\n\n ~Child()\n\n {\n\n cout<<\"~Child()\"<<endl;\n\n }\n\n};\n\nvoid run05()\n\n{\n\n Child child;\n\n}\n\nint main05(int argc, char *argv[])\n\n{\n\n cout<<\"demo05_extend_construct_destory.cpp\"<<endl;\n\n run05();\n\n system(\"pause\");\n\n return 0;\n\n}\n\n |\n\n**3.3.5****继承中的同名成员变量处理方法**\n\n1、当子类成员变量与父类成员变量同名时\n\n2、子类依然从父类继承同名成员\n\n3、在子类中通过作用域分辨符::进行同名成员区分（**在派生类中使用基类的同名成员，显式地使用类名限定符**）\n\n4、同名成员存储在内存中的不同位置\n\n总结：同名成员变量和成员函数通过作用域分辨符进行区分\n\n**3.3.6****派生类中的****static****关键字**\n\n继承和static关键字在一起会产生什么现象哪？\n\n理论知识\n\nØ 基类定义的静态成员，将被所有派生类共享\n\nØ 根据静态成员自身的访问特性和派生类的继承方式，在类层次体系中具有不同的访问性质  （遵守派生类的访问控制）\n\nØ  派生类中访问静态成员，用以下形式显式说明：\n\n_类名_ :: _成员_\n\n  或通过对象访问  _对象名_ . _成员_\n\n总结：\n\n1> static函数也遵守3个访问原则\n\n2> static易犯错误（不但要初始化，更重要的显示的告诉编译器分配内存）\n\n3> 构造函数默认为private"]],[3074,3074],[6422,6422]]],[1543924857469,["gjx16@GJXAIOU",[[1,3436,"`"],[1,3438,"`"]],[3436,3438],[3436,3440]]],[1543924858909,["gjx16@GJXAIOU",[[-1,3436,"`| `"]],[3436,3440],[3436,3436]]],[1543924859565,["gjx16@GJXAIOU",[[1,3436,"`"],[-1,6273," "],[1,6274," "]],[3436,3436],[3437,3437]]],[1543924859912,["gjx16@GJXAIOU",[[1,3437,"``"]],[3437,3437],[3439,3439]]],[1543924859954,["gjx16@GJXAIOU",[[1,3439,"language\n```\n"]],[3439,3439],[3439,3447]]],[1543924861088,["gjx16@GJXAIOU",[[-1,3439,"language"],[1,3447,"c"]],[3439,3447],[3440,3440]]],[1543924861367,["gjx16@GJXAIOU",[[1,3440,"pp"]],[3440,3440],[3442,3442]]],[1543924862054,["gjx16@GJXAIOU",[[1,3443,"\n"]],[3442,3442],[3443,3443]]],[1543924864738,["gjx16@GJXAIOU",[[-1,3444,"```"]],[3444,3447],[3444,3444]]],[1543924875282,["gjx16@GJXAIOU",[[-1,4148," |"],[1,4150,"```"]],[4148,4150],[4151,4151]]],[1543924909051,["gjx16@GJXAIOU",[[1,4217,"\n"]],[4216,4216],[4217,4217]]],[1543924909184,["gjx16@GJXAIOU",[[1,4218,"\n"]],[4217,4217],[4218,4218]]],[1543924909398,["gjx16@GJXAIOU",[[1,4219,"\n"]],[4218,4218],[4219,4219]]],[1543924909501,["gjx16@GJXAIOU",[[1,4220,"\n"]],[4219,4219],[4220,4220]]],[1543924918689,["gjx16@GJXAIOU",[[1,4218,"![5]($resource/5.png)\n![6]($resource/6.png)"]],[4218,4218],[4262,4262]]],[1543925074693,["gjx16@GJXAIOU",[[-1,4385,"| \n"]],[4385,4388],[4385,4385]]],[1543925075532,["gjx16@GJXAIOU",[[1,4385,"```"]],[4385,4385],[4388,4388]]],[1543925075576,["gjx16@GJXAIOU",[[1,4388,"language\n```\n"]],[4388,4388],[4388,4396]]],[1543925077254,["gjx16@GJXAIOU",[[-1,4388,"language"],[1,4396,"c"]],[4388,4396],[4389,4389]]],[1543925077527,["gjx16@GJXAIOU",[[1,4389,"pp"]],[4389,4389],[4391,4391]]],[1543925081239,["gjx16@GJXAIOU",[[-1,4392,"```"]],[4392,4395],[4392,4392]]],[1543925085882,["gjx16@GJXAIOU",[[-1,4913," |"],[1,4915,"```"]],[4913,4915],[4916,4916]]],[1543925349245,["gjx16@GJXAIOU",[[-1,5193," "]],[5194,5194],[5193,5193]]],[1543925351370,["gjx16@GJXAIOU",[[1,5193,"```"]],[5193,5193],[5196,5196]]],[1543925352460,["gjx16@GJXAIOU",[[-1,5192,"|```"]],[5196,5196],[5192,5192]]],[1543925353366,["gjx16@GJXAIOU",[[1,5192,"```"]],[5192,5192],[5195,5195]]],[1543925353404,["gjx16@GJXAIOU",[[1,5195,"language\n```\n"]],[5195,5195],[5195,5203]]],[1543925354727,["gjx16@GJXAIOU",[[-1,5195,"language"],[1,5203,"c"]],[5195,5203],[5196,5196]]],[1543925355010,["gjx16@GJXAIOU",[[1,5196,"pp"]],[5196,5196],[5198,5198]]],[1543925357410,["gjx16@GJXAIOU",[[-1,5199,"```"]],[5199,5202],[5199,5199]]],[1543925363160,["gjx16@GJXAIOU",[[-1,6016," |"],[1,6018,"```"]],[6016,6018],[6019,6019]]],[1543925399565,["gjx16@GJXAIOU",[[1,6164,"\n"]],[6163,6163],[6164,6164]]],[1543925399684,["gjx16@GJXAIOU",[[1,6165,"\n"]],[6164,6164],[6165,6165]]],[1543925411542,["gjx16@GJXAIOU",[[1,6164,"![7]($resource/7.png)\n![8]($resource/8.png)"]],[6164,6164],[6208,6208]]],[1543925440972,["gjx16@GJXAIOU",[[1,6451,"\n"]],[6450,6450],[6451,6451]]],[1543925441119,["gjx16@GJXAIOU",[[1,6452,"\n"]],[6451,6451],[6452,6452]]],[1543925450262,["gjx16@GJXAIOU",[[1,6451,"![aa]($resource/aa.png)"]],[6451,6451],[6475,6475]]],[1543925486331,["gjx16@GJXAIOU",[[1,6476,"\n"]],[6474,6474],[6475,6475]]],[1543925496222,["gjx16@GJXAIOU",[[1,6475,"![bb]($resource/bb.png)\n![cc]($resource/cc.png)"]],[6475,6475],[6523,6523]]],[1543925564243,["gjx16@GJXAIOU",[[-1,18,"**3.1****"],[1,27,"#"]],[18,27],[19,19]]],[1543925566659,["gjx16@GJXAIOU",[[1,19,"# yi "]],[19,19],[24,24]]],[1543925567781,["gjx16@GJXAIOU",[[-1,21,"yi "]],[24,24],[21,21]]],[1543925569318,["gjx16@GJXAIOU",[[1,21,"一、"]],[21,21],[23,23]]],[1543925572084,["gjx16@GJXAIOU",[[-1,27,"**"]],[29,29],[27,27]]],[1543925577980,["gjx16@GJXAIOU",[[-1,272,"**3.1.1****"],[1,283,"#"]],[272,272],[273,273]]],[1543925578504,["gjx16@GJXAIOU",[[1,273,"###"]],[273,273],[276,276]]],[1543925579363,["gjx16@GJXAIOU",[[-1,275,"#"]],[276,276],[275,275]]],[1543925580570,["gjx16@GJXAIOU",[[1,275," （）"]],[275,275],[278,278]]],[1543925582268,["gjx16@GJXAIOU",[[1,277,"一"]],[277,277],[278,278]]],[1543925586047,["gjx16@GJXAIOU",[[-1,285,"**"]],[287,287],[285,285]]],[1543925591371,["gjx16@GJXAIOU",[[-1,458,"**3.1.2****"],[1,469,"#"]],[458,458],[459,459]]],[1543925593506,["gjx16@GJXAIOU",[[1,459,"## （）"]],[459,459],[464,464]]],[1543925595171,["gjx16@GJXAIOU",[[1,463,"二"]],[463,463],[464,464]]],[1543925598795,["gjx16@GJXAIOU",[[-1,471,"**"]],[473,473],[471,471]]],[1543925604959,["gjx16@GJXAIOU",[[-1,537,"**3.1.3** **"],[1,549,"#"]],[537,537],[538,538]]],[1543925607031,["gjx16@GJXAIOU",[[1,538,"## （）"]],[538,538],[543,543]]],[1543925608713,["gjx16@GJXAIOU",[[1,542,"三"]],[542,542],[543,543]]],[1543925613521,["gjx16@GJXAIOU",[[-1,550,"**"]],[552,552],[550,550]]],[1543925617027,["gjx16@GJXAIOU",[[-1,574,"**3.1.4** **"],[1,586,"#"]],[574,574],[575,575]]],[1543925618943,["gjx16@GJXAIOU",[[1,575,"## （）"]],[575,575],[580,580]]],[1543925620665,["gjx16@GJXAIOU",[[1,579,"四"]],[579,579],[580,580]]],[1543925623425,["gjx16@GJXAIOU",[[-1,587,"**"]],[589,589],[587,587]]],[1543925627599,["gjx16@GJXAIOU",[[-1,665,"**3.1.5** **"],[1,677,"#"]],[665,665],[666,666]]],[1543925629363,["gjx16@GJXAIOU",[[1,666,"## （）"]],[666,666],[671,671]]],[1543925630882,["gjx16@GJXAIOU",[[1,670,"五"]],[670,670],[671,671]]],[1543925634036,["gjx16@GJXAIOU",[[-1,678,"**"]],[680,680],[678,678]]],[1543925637726,["gjx16@GJXAIOU",[[1,551,"\n"]],[550,550],[551,551]]],[1543925640968,["gjx16@GJXAIOU",[[1,666,"\n"]],[665,665],[666,666]]],[1543925652908,["gjx16@GJXAIOU",[[-1,757,"**3.2****"],[1,766,"@"]],[757,757],[758,758]]],[1543925653724,["gjx16@GJXAIOU",[[-1,757,"@"]],[758,758],[757,757]]],[1543925656895,["gjx16@GJXAIOU",[[1,757,"## 二、"]],[757,757],[762,762]]],[1543925659173,["gjx16@GJXAIOU",[[1,757,"\n"]],[756,756],[757,757]]],[1543925659278,["gjx16@GJXAIOU",[[1,758,"\n"]],[757,757],[758,758]]],[1543925662226,["gjx16@GJXAIOU",[[1,757,"--------"]],[757,757],[765,765]]],[1543925665062,["gjx16@GJXAIOU",[[-1,780,"**"]],[782,782],[780,780]]],[1543925671260,["gjx16@GJXAIOU",[[-1,846,"**3.2.1****"]],[846,857],[846,846]]],[1543925674606,["gjx16@GJXAIOU",[[1,846,"### （）"]],[846,846],[852,852]]],[1543925675977,["gjx16@GJXAIOU",[[1,851,"一"]],[851,851],[852,852]]],[1543925678572,["gjx16@GJXAIOU",[[-1,861,"**"]],[863,863],[861,861]]],[1543925682967,["gjx16@GJXAIOU",[[-1,936,"**3.2.2****"],[1,947,"#"]],[936,936],[937,937]]],[1543925685085,["gjx16@GJXAIOU",[[1,937,"## （）"]],[937,937],[942,942]]],[1543925686520,["gjx16@GJXAIOU",[[1,941,"二"]],[941,941],[942,942]]],[1543925690211,["gjx16@GJXAIOU",[[-1,962,"**"]],[964,964],[962,962]]],[1543925692836,["gjx16@GJXAIOU",[[1,936,"\n"]],[935,935],[936,936]]],[1543925692944,["gjx16@GJXAIOU",[[1,937,"\n"]],[936,936],[937,937]]],[1543925694797,["gjx16@GJXAIOU",[[1,846,"\n"]],[845,845],[846,846]]],[1543925694916,["gjx16@GJXAIOU",[[1,847,"\n"]],[846,846],[847,847]]],[1543925700156,["gjx16@GJXAIOU",[[-1,979,"****"]],[983,983],[979,979]]],[1543925713487,["gjx16@GJXAIOU",[[-1,968,"**1****）"]],[975,975],[968,968]]],[1543925713598,["gjx16@GJXAIOU",[[-1,967,"\n"]],[968,968],[967,967]]],[1543925714849,["gjx16@GJXAIOU",[[1,967,"\n"]],[967,967],[968,968]]],[1543925718182,["gjx16@GJXAIOU",[[1,968,"**1."]],[968,968],[972,972]]],[1543925725828,["gjx16@GJXAIOU",[[-1,1150,"**"]],[1150,1152],[1150,1150]]],[1543925730275,["gjx16@GJXAIOU",[[-1,1157,"****"]],[1161,1161],[1157,1157]]],[1543925733057,["gjx16@GJXAIOU",[[1,1148,"**"]],[1148,1148],[1150,1150]]],[1543925735876,["gjx16@GJXAIOU",[[-1,1212,"**"]],[1212,1214],[1212,1212]]],[1543925738875,["gjx16@GJXAIOU",[[-1,1206,"** **"]],[1211,1211],[1206,1206]]],[1543925740390,["gjx16@GJXAIOU",[[1,1206,"****"]],[1206,1206],[1208,1208]]],[1543925742029,["gjx16@GJXAIOU",[[-1,1208,"**"]],[1208,1208],[1206,1206]]],[1543925744524,["gjx16@GJXAIOU",[[-1,1151,"）"]],[1152,1152],[1151,1151]]],[1543925745503,["gjx16@GJXAIOU",[[1,1151,"。"]],[1151,1151],[1152,1152]]],[1543925749537,["gjx16@GJXAIOU",[[-1,1214,"****"],[1,1218,"。"]],[1214,1214],[1215,1215]]],[1543925750485,["gjx16@GJXAIOU",[[-1,1214,"。"]],[1215,1215],[1214,1214]]],[1543925751048,["gjx16@GJXAIOU",[[1,1214,"."]],[1214,1214],[1215,1215]]],[1543925753411,["gjx16@GJXAIOU",[[-1,1215,"）"]],[1216,1216],[1215,1215]]],[1543925756240,["gjx16@GJXAIOU",[[-1,1218,"****"]],[1222,1222],[1218,1218]]],[1543925761611,["gjx16@GJXAIOU",[[-1,1437,"****）"]],[1437,1442],[1437,1437]]],[1543925762533,["gjx16@GJXAIOU",[[1,1437,"."]],[1437,1437],[1438,1438]]],[1543925767267,["gjx16@GJXAIOU",[[-1,1472,"**3.2.3****"],[1,1483,"j"]],[1472,1483],[1473,1473]]],[1543925768001,["gjx16@GJXAIOU",[[1,1473,"###"]],[1473,1473],[1476,1476]]],[1543925769556,["gjx16@GJXAIOU",[[-1,1472,"j###"]],[1476,1476],[1472,1472]]],[1543925769899,["gjx16@GJXAIOU",[[-1,1471,"\n"]],[1472,1472],[1471,1471]]],[1543925771051,["gjx16@GJXAIOU",[[1,1471,"\n"]],[1471,1471],[1472,1472]]],[1543925771181,["gjx16@GJXAIOU",[[1,1472,"\n"]],[1472,1472],[1473,1473]]],[1543925774203,["gjx16@GJXAIOU",[[1,1473,"### ()"]],[1473,1473],[1479,1479]]],[1543925776162,["gjx16@GJXAIOU",[[1,1478,"san"]],[1478,1478],[1481,1481]]],[1543925777046,["gjx16@GJXAIOU",[[-1,1478,"san"]],[1481,1481],[1478,1478]]],[1543925778959,["gjx16@GJXAIOU",[[1,1478,"三"]],[1478,1478],[1479,1479]]],[1543925782390,["gjx16@GJXAIOU",[[-1,1486,"**"]],[1488,1488],[1486,1486]]],[1543925791420,["gjx16@GJXAIOU",[[1,1486,"**"]],[1486,1486],[1488,1488]]],[1543925791981,["gjx16@GJXAIOU",[[-1,1478,"三"]],[1479,1479],[1478,1478]]],[1543925792486,["gjx16@GJXAIOU",[[1,1478,"san"]],[1478,1478],[1481,1481]]],[1543925793041,["gjx16@GJXAIOU",[[-1,1478,"san"]],[1481,1481],[1478,1478]]],[1543925793519,["gjx16@GJXAIOU",[[-1,1473,"### ()"]],[1479,1479],[1473,1473]]],[1543925794015,["gjx16@GJXAIOU",[[-1,1472,"\n"]],[1473,1473],[1472,1472]]],[1543925794604,["gjx16@GJXAIOU",[[-1,1471,"\n"]],[1472,1472],[1471,1471]]],[1543925795172,["gjx16@GJXAIOU",[[1,1471,"\n"]],[1471,1471],[1472,1472]]],[1543925795637,["gjx16@GJXAIOU",[[1,1472,"j###"]],[1472,1472],[1476,1476]]],[1543925796272,["gjx16@GJXAIOU",[[-1,1473,"###"]],[1476,1476],[1473,1473]]],[1543925796780,["gjx16@GJXAIOU",[[1,1472,"**3.2.3****"],[-1,1472,"j"]],[1473,1473],[1472,1483]]],[1543925809676,["gjx16@GJXAIOU",[[-1,1472,"**3.2.3****"]],[1472,1483],[1472,1472]]],[1543925812968,["gjx16@GJXAIOU",[[1,1472,"### （）"]],[1472,1472],[1478,1478]]],[1543925814630,["gjx16@GJXAIOU",[[1,1477,"三"]],[1477,1477],[1478,1478]]],[1543925818570,["gjx16@GJXAIOU",[[-1,1665,"**3.2.3****"],[1,1676,"#"]],[1665,1665],[1666,1666]]],[1543925820422,["gjx16@GJXAIOU",[[1,1666,"## （）"]],[1666,1666],[1671,1671]]],[1543925821909,["gjx16@GJXAIOU",[[1,1670,"四"]],[1670,1670],[1671,1671]]],[1543925825161,["gjx16@GJXAIOU",[[-1,1687,"**"]],[1689,1689],[1687,1687]]],[1543925829774,["gjx16@GJXAIOU",[[-1,1853,"**3.2.4****"],[1,1864,"#"]],[1853,1853],[1854,1854]]],[1543925832060,["gjx16@GJXAIOU",[[1,1854,"## （）"]],[1854,1854],[1859,1859]]],[1543925833943,["gjx16@GJXAIOU",[[1,1858,"五"]],[1858,1858],[1859,1859]]],[1543925840983,["gjx16@GJXAIOU",[[-1,2990,"**3.3****"],[1,2999,"#"]],[2990,2990],[2991,2991]]],[1543925843894,["gjx16@GJXAIOU",[[1,2991,"# 三。"]],[2991,2991],[2995,2995]]],[1543925844395,["gjx16@GJXAIOU",[[-1,2994,"。"]],[2995,2995],[2994,2994]]],[1543925845102,["gjx16@GJXAIOU",[[1,2994,"、"]],[2994,2994],[2995,2995]]],[1543925848232,["gjx16@GJXAIOU",[[-1,3004,"**"]],[3006,3006],[3004,3004]]],[1543925853843,["gjx16@GJXAIOU",[[-1,3006,"**3.3.1****"],[1,3017,"#"]],[3006,3006],[3007,3007]]],[1543925855610,["gjx16@GJXAIOU",[[1,3007,"## （）"]],[3007,3007],[3012,3012]]],[1543925857052,["gjx16@GJXAIOU",[[1,3011,"一"]],[3011,3011],[3012,3012]]],[1543925859974,["gjx16@GJXAIOU",[[-1,3020,"**"]],[3022,3022],[3020,3020]]],[1543925868323,["gjx16@GJXAIOU",[[-1,4057,"**3.3.2****"],[1,4068,"#"]],[4057,4057],[4058,4058]]],[1543925871213,["gjx16@GJXAIOU",[[1,4058,"## （）"]],[4058,4058],[4063,4063]]],[1543925872710,["gjx16@GJXAIOU",[[1,4062,"二"]],[4062,4062],[4063,4063]]],[1543925876363,["gjx16@GJXAIOU",[[-1,4072,"**"]],[4074,4074],[4072,4072]]],[1543925889691,["gjx16@GJXAIOU",[[-1,4816,"**3.3.3****"]],[4816,4827],[4816,4816]]],[1543925892989,["gjx16@GJXAIOU",[[1,4816,"### （）"]],[4816,4816],[4822,4822]]],[1543925895342,["gjx16@GJXAIOU",[[1,4821,"三"]],[4821,4821],[4822,4822]]],[1543925898330,["gjx16@GJXAIOU",[[-1,4835,"**"]],[4837,4837],[4835,4835]]],[1543925902538,["gjx16@GJXAIOU",[[-1,4941,"**3.3.4****"],[1,4952,"#"]],[4941,4941],[4942,4942]]],[1543925904480,["gjx16@GJXAIOU",[[1,4942,"## （）"]],[4942,4942],[4947,4947]]],[1543925905896,["gjx16@GJXAIOU",[[1,4946,"四"]],[4946,4946],[4947,4947]]],[1543925912780,["gjx16@GJXAIOU",[[-1,5909,"**3.3.5****"],[1,5920,"#"]],[5909,5909],[5910,5910]]],[1543925914270,["gjx16@GJXAIOU",[[1,5910,"## （）"]],[5910,5910],[5915,5915]]],[1543925915581,["gjx16@GJXAIOU",[[1,5914,"五"]],[5914,5914],[5915,5915]]],[1543925919171,["gjx16@GJXAIOU",[[-1,5930,"**"]],[5932,5932],[5930,5930]]],[1543925924244,["gjx16@GJXAIOU",[[-1,6119,"**3.3.6****"]],[6119,6130],[6119,6119]]],[1543925926825,["gjx16@GJXAIOU",[[1,6119,"### （）"]],[6119,6119],[6125,6125]]],[1543925928053,["gjx16@GJXAIOU",[[1,6124,"六"]],[6124,6124],[6125,6125]]],[1543925932636,["gjx16@GJXAIOU",[[-1,6131,"****"]],[6135,6135],[6131,6131]]],[1543925936899,["gjx16@GJXAIOU",[[-1,6137,"****"]],[6141,6141],[6137,6137]]],[1543925939097,["gjx16@GJXAIOU",[[-1,6140,"**"]],[6142,6142],[6140,6140]]],[1543927495971,["gjx16@GJXAIOU",[[-1,738,"\n"]],[738,738],[737,737]]],[1543927497483,["gjx16@GJXAIOU",[[-1,723,"\n"]],[723,723],[722,722]]],[1543927498689,["gjx16@GJXAIOU",[[-1,703,"\n"]],[703,703],[702,702]]]],null,"gjx16@GJXAIOU"],["cc127a6c-ce75-4aab-b15f-7fb34c79ba0f",1544006386994,"# C_PP_章三 继承和派生\n\n\n## 一、继承概念\n\n面向对象程序设计有4个主要特点：抽象、封装、继承和多态性。我们已经讲解了类和对象，了解了面向对象程序设计的两个重要特征一数据抽象与封装，已经能够设计出基于对象的程序，这是面向对象程序设计的基础。\n\n要较好地进行面向对象程序设计，还必须了解面向对象程序设计另外两个重要特 征——继承性和多态性。本章主要介绍有关继承的知识，多态性将在后续章节中讲解。\n\n继承性是面向对象程序设计最重要的特征，可以说，如果没有掌握继承性，就等于没有掌握类和对象的精华，就是没有掌握面向对象程序设计的真谛。\n\n### （一）类之间的关系\n\nhas-A，uses-A 和 is-A\n\nhas-A 包含关系，用以描述一个类由多个“部件类”构成。实现has-A关系用类成员表示，即一个类中的数据成员是另一种已经定义的类。\n\nuses-A 一个类部分地使用另一个类。通过类之间成员函数的相互联系，定义友员或对象参数传递实现。\n\nis-A 机制称为“继承”。关系具有传递性,不具有对称性。\n\n### （二）继承关系举例\n\n万事万物中皆有继承，是重要的现象 \n\n两个案例：1）植物继承图；2）程序员继承图\n![1]($resource/1.png)\n\n### （三）继承相关概念\n\n![2]($resource/2.png)\n\n### （四）派生类的定义\n\n![3]($resource/3.png)\n\n注意：C++中的继承方式（public、private、protected）会影响子类的对外访问属性。\n\n\n### （五）继承重要说明\n\n1、子类拥有父类的所有成员变量和成员函数\n2、子类可以拥有父类没有的方法和属性\n3、子类就是一种特殊的父类\n4、子类对象可以当作父类对象使用\n\n--------\n\n## 二、派生类的访问控制\n\n派生类继承了基类的全部成员变量和成员方法（除了构造和析构之外的成员方法），但是这些成员的访问属性，在派生过程中是可以调整的。\n\n\n\n### （一）单个类的访问控制\n\n1、类成员访问级别（public、private、protected）\n\n2、思考：类成员的访问级别只有public和private是否足够？\n\n\n\n### （二）不同的继承方式会改变继承成员的访问属性\n\n**1.C++中的继承方式会影响子类的对外访问属性**\n\npublic继承：父类成员在子类中保持原有访问级别\n\nprivate继承：父类成员在子类中变为private成员\n\nprotected继承：父类中public成员会变成protected\n\n  父类中protected成员仍然为protected\n\n  父类中private成员仍然为private\n\n**2。private成员在子类中依然存在，但是却无法访问到。不论种方式继承基类，派生类都不能直接使用基类的私有成员**。\n\n**3.C++中子类对外访问属性表**\n|    |父类 |成员  |访问|级别|\n|---|---|---|---|---|\n|继\t| |public|\tproteced|\tprivate|\n|承 | public\t|public\t|proteced|\tprivate|\n|方 | proteced\t|proteced|\tproteced|\tprivate|\n|式 |private\t|private|\tprivate\t|Private|\n\n\n**4.继承中的访问控制**\n![4]($resource/4.png)\n\n### （三）“三看”原则**\n\nC++中的继承方式（public、private、protected）会影响子类的对外访问属性    \n\n判断某一句话，能否被访问\n\n 1）看调用语句，这句话写在子类的内部、外部\n\n 2）看子类如何从父类继承（public、private、protected）    \n\n 3）看父类中的访问级别（public、private、protected）\n\n### （四）派生类类成员访问级别设置的原则\n\n思考：如何恰当的使用public，protected和private为成员声明访问级别？\n\n1、需要被外界访问的成员直接设置为public\n\n2、只能在当前类中访问的成员设置为private\n\n3、只能在当前类和子类中访问的成员设置为protected，protected成员的访问权限介于public和private之间。\n\n### （五）综合训练**\n\n练习：\n\npublic继承不会改变父类对外访问属性；\n\nprivate继承会改变父类对外访问属性为private；\n\nprotected继承会部分改变父类对外访问属性。\n\n结论：一般情况下class B : public A\n\n```cpp\n\n//类的继承方式对子类对外访问属性影响\n\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nclass A\n{\nprivate:\n\tint a;\nprotected:\n\tint b;\npublic:\n\tint c;\n\tA()\n\t{\n\t\ta = 0;\n\t\tb = 0;\n\t\tc = 0;\n\t}\n\n\tvoid set(int a, int b, int c)\n\t{\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t\tthis->c = c;\n\t}\n\n};\n\nclass B : public A\n{\npublic:\n\tvoid print()\n\t{\n\t\t//cout<<\"a = \"<<a; //err\n\t\tcout << \"b = \" << b;\n\t\tcout << \"c = \" << endl;\n\t}\n};\n\nclass C : protected A\n{\npublic:\n\tvoid print()\n\t{\n\t\t//cout<<\"a = \"<<a; //err\n\t\tcout << \"b = \" << b;\n\t\tcout << \"c = \" << endl;\n\t}\n};\n\nclass D : private A\n{\npublic:\n\tvoid print()\n\t{\n\t\t//cout<<\"a = \"<<a; //err\n\t\tcout << \"b = \" << b << endl;\n\t\tcout << \"c = \" << c << endl;\n\t}\n};\n\nint main_01(int argc, char *argv[])\n{\n\tA aa;\n\tB bb;\n\tC cc;\n\tD dd;\n\taa.c = 100; //ok\n\tbb.c = 100; //ok\n\t//cc.c = 100; //err 类的外部是什么含义\n\t//dd.c = 100; //err\n\taa.set(1, 2, 3);\n\tbb.set(10, 20, 30);\n\t//cc.set(40, 50, 60); //ee\n\n\t//dd.set(70, 80, 90); //ee\n\tbb.print();\n\tcc.print();\n\tdd.print();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n## 三、继承中的构造和析构\n\n### （一）类型兼容性原则\n\n类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。类型兼容规则中所指的替代包括以下情况：\n\n子类对象可以当作父类对象使用\n\n子类对象可以直接赋值给父类对象\n\n子类对象可以直接初始化父类对象\n\n父类指针可以直接指向子类对象\n\n父类引用可以直接引用子类对象\n\n在替代之后，派生类对象就可以作为基类的对象使用，但是只能使用从基类继承的成员。\n\n类型兼容规则是多态性的重要基础之一。\n\n总结：子类就是特殊的父类 (**base *p = &child;)**\n\n```cpp\n\n\n\n\n#include <cstdlib>\n\n#include <iostream>\n\nusing namespace std;\n\n/*\n\n子类对象可以当作父类对象使用\n\n  子类对象可以直接赋值给父类对象\n\n  子类对象可以直接初始化父类对象\n\n  父类指针可以直接指向子类对象\n\n  父类引用可以直接引用子类对象\n\n */\n\n//子类就是特殊的父类\n\nclass Parent03\n\n{\n\nprotected:\n\n const char* name;\n\npublic:\n\n Parent03()\n\n {\n\n name = \"Parent03\";\n\n }\n\n void print()\n\n {\n\n cout<<\"Name: \"<<name<<endl;\n\n }\n\n};\n\nclass Child03 : public Parent03\n\n{\n\nprotected:\n\n int i;\n\npublic:\n\n Child03(int i)\n\n {\n\n this->name = \"Child2\";\n\n this->i = i;\n\n }\n\n};\n\nint main()\n\n{\n\n Child03 child03(1000);\n\n //分别定义父类对象 父类指针 父类引用 child\n\n Parent03 parent = child03;\n\n Parent03* pp = &child03;\n\n Parent03& rp = child03;\n\n parent.print();\n\n pp->print();\n\n rp.print();\n\n system(\"pause\");\n\n return 0;\n\n}\n\n```\n\n### （二）继承中的对象模型\n\n类在C++编译器的内部可以理解为结构体\n\n子类是由父类成员叠加子类新成员得到的\n\n\n![5]($resource/5.png)\n![6]($resource/6.png)\n\n\n**继承中构造和析构**\n\n**问题：如何初始化父类成员？父类与子类的构造函数有什么关系**\n\n  在子类对象构造时，需要调用父类构造函数对其继承得来的成员进行初始化\n\n  在子类对象析构时，需要调用父类析构函数对其继承得来的成员进行清理\n\n```cpp\n\n\n#include <cstdlib>\n\n#include <iostream>\n\nusing namespace std;\n\nclass Parent04\n\n{\n\npublic:\n\n Parent04(const char* s)\n\n {\n\n cout<<\"Parent04()\"<<\" \"<<s<<endl;\n\n }\n\n ~Parent04()\n\n {\n\n cout<<\"~Parent04()\"<<endl;\n\n }\n\n};\n\nclass Child04 : public Parent04\n\n{\n\npublic:\n\n Child04() : Parent04(\"Parameter from Child!\")\n\n {\n\n cout<<\"Child04()\"<<endl;\n\n }\n\n ~Child04()\n\n {\n\n cout<<\"~Child04()\"<<endl;\n\n }\n\n};\n\nvoid run04()\n\n{\n\n Child04 child;\n\n}\n\nint main_04(int argc, char *argv[])\n\n{\n\n run04();\n\n system(\"pause\");\n\n return 0;\n\n}\n\n```\n\n### （三）继承中的构造析构调用原则\n\n1、子类对象在创建时会首先调用父类的构造函数\n\n2、父类构造函数执行结束后，执行子类的构造函数\n\n3、当父类的构造函数有参数时，需要在子类的初始化列表中显示调用\n\n4、析构函数调用的先后顺序与构造函数相反\n\n### （四）继承与组合混搭情况下，构造和析构调用原则**\n\n  原则：  先构造父类，再构造成员变量、最后构造自己\n\n  先析构自己，在析构成员变量、最后析构父类\n\n //先构造的对象，后释放\n\n练习：demo05_extend_construct_destory.cpp\n\n```cpp\n\n\n\n//子类对象如何初始化父类成员\n\n//继承中的构造和析构\n\n//继承和组合混搭情况下，构造函数、析构函数调用顺序研究\n\n#include <iostream>\n\nusing namespace std;\n\nclass Object\n\n{\n\npublic:\n\n Object(const char* s)\n\n {\n\n cout<<\"Object()\"<<\" \"<<s<<endl;\n\n }\n\n ~Object()\n\n {\n\n cout<<\"~Object()\"<<endl;\n\n }\n\n};\n\nclass Parent : public Object\n\n{\n\npublic:\n\n Parent(const char* s) : Object(s)\n\n {\n\n cout<<\"Parent()\"<<\" \"<<s<<endl;\n\n }\n\n ~Parent()\n\n {\n\n cout<<\"~Parent()\"<<endl;\n\n }\n\n};\n\nclass Child : public Parent\n\n{\n\nprotected:\n\n Object o1;\n\n Object o2;\n\npublic:\n\n Child() : o2(\"o2\"), o1(\"o1\"), Parent(\"Parameter from Child!\")\n\n {\n\n cout<<\"Child()\"<<endl;\n\n }\n\n ~Child()\n\n {\n\n cout<<\"~Child()\"<<endl;\n\n }\n\n};\n\nvoid run05()\n\n{\n\n Child child;\n\n}\n\nint main05(int argc, char *argv[])\n\n{\n\n cout<<\"demo05_extend_construct_destory.cpp\"<<endl;\n\n run05();\n\n system(\"pause\");\n\n return 0;\n\n}\n\n```\n\n### （五）继承中的同名成员变量处理方法\n\n1、当子类成员变量与父类成员变量同名时\n\n2、子类依然从父类继承同名成员\n\n3、在子类中通过作用域分辨符::进行同名成员区分（**在派生类中使用基类的同名成员，显式地使用类名限定符**）\n\n4、同名成员存储在内存中的不同位置\n\n![7]($resource/7.png)\n![8]($resource/8.png)\n\n总结：同名成员变量和成员函数通过作用域分辨符进行区分\n\n### （六）派生类中的static关键字\n\n继承和static关键字在一起会产生什么现象哪？\n\n理论知识\n\nØ 基类定义的静态成员，将被所有派生类共享\n\nØ 根据静态成员自身的访问特性和派生类的继承方式，在类层次体系中具有不同的访问性质  （遵守派生类的访问控制）\n\nØ  派生类中访问静态成员，用以下形式显式说明：\n\n_类名_ :: _成员_\n\n  或通过对象访问  _对象名_ . _成员_\n\n![aa]($resource/aa.png)\n![bb]($resource/bb.png)\n![cc]($resource/cc.png)\n\n总结：\n\n1> static函数也遵守3个访问原则\n\n2> static易犯错误（不但要初始化，更重要的显示的告诉编译器分配内存）\n\n3> 构造函数默认为private\n",[[1544006376133,["gjx16@GJXAIOU",[[1,934,"··"]],[934,934],[936,936]]],[1544006376833,["gjx16@GJXAIOU",[[-1,934,"··"]],[936,936],[934,934]]],[1544006379475,["gjx16@GJXAIOU",[[1,934,"```cpp"]],[934,934],[940,940]]],[1544006380013,["gjx16@GJXAIOU",[[1,943,"\n"]],[940,940],[941,941]]],[1544006380146,["gjx16@GJXAIOU",[[1,944,"\n"]],[941,941],[942,942]]],[1544006380298,["gjx16@GJXAIOU",[[1,945,"\n"]],[942,942],[943,943]]],[1544006381311,["gjx16@GJXAIOU",[[1,943,"```"]],[943,943],[946,946]]],[1544006383431,["gjx16@GJXAIOU",[[1,941,"//单个类的访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass TestParent\n{\npublic:  //修饰的成员变量和方法，可以在类的内部和外部使用；\n\tTestParent();\n\t~TestParent();\n\tvoid print();\n\tint m_a; \nprotected://修饰的成员变量和方法，只能在类的内部使用，在继承的子类中可以使用\n\tint m_b;\nprivate: //修饰的成员变量和方法，只能在类的内部使用，不能在类的外部使用\n\tint m_c;\n\n};\n\nTestParent::TestParent()\n{\n\tm_a = 0; \n\tm_b = 0;\n\tm_c = 0;\n}\n\nTestParent::~TestParent()\n{\n}\n\nvoid TestParent::print()\n{\n\tcout << \"m_a = \" << m_a << endl;\n\tcout << \"m_b = \" << m_b << endl;\n\tcout << \"m_c = \" << m_c << endl;\n}\n\n\nclass TestChild:public TestParent  //这里还可以是protected 或者private\n{\npublic:\n\tTestChild();\n\t~TestChild();\n\tvoid useVar();\nprivate:\n\n};\n\nTestChild::TestChild()\n{\n\treturn;\n}\n\nTestChild::~TestChild()\n{\n\treturn;\n}\n\nvoid TestChild::useVar()\n{\n\tm_a = 1;//ok\n\tm_b = 2;//ok\n\t//m_c = 3; //error\n}\n\n\nint main()\n{\n\tTestParent t1;\n\tTestChild t2;\n\tt1.m_a = 4;//ok\n\t//t1.m_b = 5;//error\n\t//t1.m_c = 6;//error\n\tt1.print();\n\tt2.print();\n\treturn 0;\n\n}"]],[941,941],[1873,1873]]],[1544008979460,["gjx16@GJXAIOU",[[1,1307,"\treturn;\n"],[1,1443,"\n//三种继承方式的子类\n\n\n//公有继承\n"],[1,1458,"1"],[1,1517,"void useVar1();\nprivate:\n\n};\n\n\nvoid "],[1,1526,"1::useVar1"],[1,1528,"\n{\n\tm_a = 1"],[1,1529,"//ok"],[-1,1531,"~"],[1,1532,"m_b = 2;//ok\n\t//m_c = 3; //error\n}\n\n\n\n//保护继承\nclass "],[-1,1541,"();"],[1,1544,"2 :protected TestParent\n{\npublic:"],[1,1557,"2"],[1,1573,"\n"],[1,1575,"void "],[1,1584,"2"],[-1,1586,"TestChild"],[1,1595,"useVar2"],[-1,1601,"return;"],[1,1608,"m_a = 1;//ok\n\tm_b = 2;//ok\n\t//m_c = 3;//error"],[1,1612,"\n\n//private 继承\nclass "],[-1,1621,"::~"],[1,1624,"3 :private "],[-1,1628,"Child()\n{\n\treturn;"],[1,1646,"Parent\n{\npublic:\n\tvoid useVar3();\nprivate:\n"],[1,1648,";\n"],[1,1664,"3"],[1,1672,"3"],[-1,1716," "],[1,1717,""],[1,1729,"\n"],[-1,1743,"TestParent t1;"],[1,1757,"\n\t//public:"],[1,1768,"1"],[-1,1770,"2"],[1,1771,"1"],[-1,1834,"\tt1.print()"],[1,1845,"\n\t//protected:\n\tTestChild2 t2"],[1,1848,"//"],[1,1851,"m_a = 11;\n\t//t2.m_b = 22;\n\t//t2.m_c = 33;\n\n\t//"],[-1,1854,"nt();"],[1,1859,"vate:\n\tTestChild3 t3;\n\t//t3.m_a = 111;\n\t//t3.m_b = 222;\n\t//t3.m_c = 333;\n"],[-1,1873,"\n"],[1,1874,""]],[941,1874],[2280,2280]]],[1544010827958,["gjx16@GJXAIOU",[[-1,3366," <cstdlib>\n#include <"],[1,3387,"\""],[-1,3395,">"],[1,3396,"\""],[1,3485,";"],[1,3487,"void set(int a, int b, int c);\n};\n\nA::A()\n"],[-1,3490,"\t"],[-1,3498,"\t"],[-1,3507,"\t"],[-1,3516,"\t"],[-1,3520,"\t"],[1,3526,"A::"],[-1,3551,"\t"],[-1,3555,"\t"],[-1,3569,"\t"],[-1,3585,"\t"],[-1,3599,"\t"],[-1,3603,"};"],[1,3605,"\n//public:"],[1,3672,"<<endl"],[1,3701,"<<endl"],[1,3723,"c << "],[1,3735,"\n\n//protected:"],[1,3804,"<<endl"],[1,3833," << endl"],[1,3855,"c << "],[1,3867,"\n//private"],[1,3972,"//保护的在子类中变成私有的，但是在子类中仍可使用"],[1,4003,"//保护的在子类中变成私有的，但是在子类中仍可使用"],[1,4009,"\n\n"],[-1,4019,"_01"],[-1,4023,"int argc, char *argv[]"]],[3337,4330],[4441,4441]]],[1544010856071,["gjx16@GJXAIOU",[[-1,4632,"\n"]],[4632,4632],[4631,4631]]],[1544010857623,["gjx16@GJXAIOU",[[-1,4648,"\n"]],[4648,4648],[4647,4647]]],[1544010858802,["gjx16@GJXAIOU",[[-1,4664,"\n"]],[4664,4664],[4663,4663]]],[1544010860031,["gjx16@GJXAIOU",[[-1,4679,"\n"]],[4679,4679],[4678,4678]]],[1544010862991,["gjx16@GJXAIOU",[[-1,4694,"\n"]],[4694,4694],[4693,4693]]],[1544010864585,["gjx16@GJXAIOU",[[-1,4734,"\n"]],[4734,4734],[4733,4733]]],[1544010908423,["gjx16@GJXAIOU",[[1,4617,"* "],[1,4632,"* "],[1,4648,"* "],[1,4664,"* "],[1,4679,"* "]],[4617,4693],[4619,4703]]],[1544010913422,["gjx16@GJXAIOU",[[-1,4812,"\n"]],[4812,4812],[4811,4811]]],[1544010913571,["gjx16@GJXAIOU",[[-1,4811,"\n"]],[4811,4811],[4810,4810]]],[1544010914022,["gjx16@GJXAIOU",[[-1,4810,"\n"]],[4810,4810],[4809,4809]]],[1544010914600,["gjx16@GJXAIOU",[[-1,4809,"\n"]],[4809,4809],[4808,4808]]],[1544010916784,["gjx16@GJXAIOU",[[-1,4828,"\n"]],[4828,4828],[4827,4827]]],[1544010918293,["gjx16@GJXAIOU",[[-1,4848,"\n"]],[4848,4848],[4847,4847]]],[1544010922456,["gjx16@GJXAIOU",[[-1,4889,"\n"]],[4889,4889],[4888,4888]]],[1544010925006,["gjx16@GJXAIOU",[[-1,4907,"\n"]],[4907,4907],[4906,4906]]],[1544010926661,["gjx16@GJXAIOU",[[-1,4925,"\n"]],[4925,4925],[4924,4924]]],[1544010928505,["gjx16@GJXAIOU",[[-1,4942,"\n"]],[4942,4942],[4941,4941]]],[1544010930552,["gjx16@GJXAIOU",[[-1,4959,"\n"]],[4959,4959],[4958,4958]]],[1544010932584,["gjx16@GJXAIOU",[[-1,4873,"\n"]],[4873,4873],[4872,4872]]],[1544013533979,["gjx16@GJXAIOU",[[1,4801,"zhe"]],[4801,4801],[4804,4804]]],[1544013534547,["gjx16@GJXAIOU",[[-1,4801,"zhe"]],[4804,4804],[4801,4801]]],[1544013534881,["gjx16@GJXAIOU",[[-1,4801,"\n"]],[4801,4801],[4800,4800]]],[1544013535791,["gjx16@GJXAIOU",[[1,4801,"\n"]],[4800,4800],[4801,4801]]],[1544013541642,["gjx16@GJXAIOU",[[1,4801,"这是源文档的"]],[4801,4801],[4807,4807]]],[1544013546603,["gjx16@GJXAIOU",[[1,4807,"示例程序："]],[4807,4807],[4812,4812]]],[1544013555586,["gjx16@GJXAIOU",[[1,5518,"\n"]],[5516,5516],[5517,5517]]],[1544013555734,["gjx16@GJXAIOU",[[1,5519,"\n"]],[5517,5517],[5518,5518]]],[1544013565750,["gjx16@GJXAIOU",[[1,5518,"这是亲自敲得示例程序："]],[5518,5518],[5529,5529]]],[1544013566790,["gjx16@GJXAIOU",[[1,5531,"\n"]],[5529,5529],[5530,5530]]],[1544013570405,["gjx16@GJXAIOU",[[1,5530,"```cpp"]],[5530,5530],[5536,5536]]],[1544013570938,["gjx16@GJXAIOU",[[1,5538,"\n"]],[5536,5536],[5537,5537]]],[1544013571087,["gjx16@GJXAIOU",[[1,5539,"\n"]],[5537,5537],[5538,5538]]],[1544013571239,["gjx16@GJXAIOU",[[1,5540,"\n"]],[5538,5538],[5539,5539]]],[1544013572493,["gjx16@GJXAIOU",[[1,5539,"```"]],[5539,5539],[5542,5542]]],[1544013575062,["gjx16@GJXAIOU",[[1,5537,"// 类型兼容性原则\n\n/*\n子类对象可以当作父类对象使用\n  子类对象可以直接赋值给父类对象\n  子类对象可以直接初始化父类对象\n  父类指针可以直接指向子类对象\n  父类引用可以直接引用子类对象\n */\n#include \"iostream\"\nusing namespace std;\n\nclass Parent\n{\npublic:\n\tParent();\n\tParent(const Parent &obj);\n\tvoid print_Parent();\nprivate:\n\n};\n\nParent::Parent()\n{\n\tcout << \"这是父类构造函数\" << endl;\n}\nParent::Parent(const Parent &obj)\n{\n\tcout << \"这是父类的拷贝构造函数\" << endl;\n}\n\nvoid Parent::print_Parent()\n{\n\tcout << \"这是父类\" << endl;\n}\n\n\n\n\nclass Child :public Parent\n{\npublic:\n\tvoid print_Child();\nprivate:\n\n};\n\nvoid Child::print_Child()\n{\n\tcout << \"这是子类\" << endl;\n}\n\n\nvoid howtoprint1(Parent *p)  //父类指针做函数参数\n{\n\tp->print_Parent();  //调用的是父类的成员函数\n}\n\nvoid howtoprint2(Parent &p)  \n{\n\tp.print_Parent();  \n}\n\n\n\nint main()\n{\n\tParent p1;\n\tp1.print_Parent();\n\n\tChild c1;\n\tc1.print_Child();\n\tc1.print_Parent();//子类对象可以调用父类的方法\n\n\n\n\t//赋值兼容性原则\n\t//1.1基类指针（引用）指向 子类对象\n\n\tParent *p = NULL;\n\tp = &c1;\n\tp->print_Parent();\n\n\n\t//1.2 指针做函数参数\n\thowtoprint1(&p1);  //传递父类对象可以\n\thowtoprint1(&c1);  //传递子类对象也可以，因为赋值兼容性原则\n\n\t//1.3引用做函数参数\n\thowtoprint2(p1);\n\thowtoprint2(c1);\n\n\n\n\t//2.可以使用子类对象初始父类对象\n\t//因为子类就是一种特殊的父类\n\tParent p2 = c1;\n\n\tsystem(\"pause\");\n\treturn 0;\n}"]],[5537,5537],[6657,6657]]],[1544013776866,["gjx16@GJXAIOU",[[1,6830,"**"],[1,6852,"**"]],[6830,6852],[6830,6856]]],[1544013783201,["gjx16@GJXAIOU",[[1,6871,"**"],[1,6892,"**"]],[6871,6892],[6871,6896]]],[1544016335036,["gjx16@GJXAIOU",[[-1,6906,"\n#include <cstdlib>"],[1,6925,"//继承中构造和析构"],[-1,6936,"<"],[1,6937,"\""],[-1,6945,">\n"],[1,6947,"\""],[-1,6982,"04\n"],[1,6985,""],[-1,6988,"\n"],[-1,6997,"\n "],[1,6999,"\tParent(int a, int b);\n\t~"],[-1,7005,"04(const char* s)\n\n {\n\n cout<<\""],[1,7036,"();\n\tvoid print_Parent();\nprivate:\n\tint a;\n\tint b;\n};\n\nParent::"],[-1,7042,"04()\"<<\" \"<<s"],[1,7055,"(int a, int b)\n{\n\tthis->a = a;\n\tthis->b = b;\n\tcout << \"这是父类构造函数\" "],[1,7057," "],[-1,7063,"\n "],[-1,7068," "],[1,7069,"Parent::"],[-1,7076,"04"],[-1,7081,"\n "],[-1,7085,"\n "],[1,7087,"\t"],[1,7091," "],[-1,7093,"\"~"],[1,7095," \"这是父类析构函数\" << endl;\n}\n\n\nvoid "],[-1,7101,"04"],[1,7103,"::print_Parent"],[1,7105,"\n{\n\tcout << "],[1,7106,"这是父类的方法\" "],[1,7108," "],[-1,7114,"\n "],[-1,7119,"};"],[1,7121,"\n"],[-1,7134,"04"],[-1,7138," "],[-1,7152,"04\n"],[-1,7158,"\n"],[-1,7167,"\n "],[1,7169,"\t"],[-1,7174,"04() : Parent04(\"Parameter from "],[1,7206,"(int a, int b, int c);    //声明的时候不需要加上后缀\n\t~Child();\n\tvoid print_Child();\nprivate:\n\tint c;\n\n};\n\nChild::"],[-1,7211,"!\")\n\n {\n\n "],[1,7221,"(int a, int b, int c) : Parent(a, b)   //但是实现的时候需要在后面加上继承的成员变量\n{\n\tthis->c = c;\n\t"],[1,7225," "],[1,7227," "],[1,7228,"这是子类的构造函数\" << endl;\n}\n\n"],[-1,7233,"04"],[1,7235,"::~Child"],[1,7237,"\n{\n\tcout << "],[1,7238,"这是子类的析构函数\" "],[1,7240," "],[-1,7246,"\n "],[-1,7251," ~"],[1,7253,"void Child::print_"],[-1,7258,"04"],[-1,7263,"\n "],[-1,7267,"\n "],[1,7269,"\t"],[1,7273," "],[-1,7275,"\"~Child04()\""],[1,7287," \"这是子类方法\" "],[1,7289," "],[-1,7295,"\n "],[-1,7299,"\n};"],[-1,7309,"run04"],[1,7314,"playobj"],[-1,7316,"\n"],[-1,7320,"\n "],[1,7322,"\tcout << \"下面是完整的生命周期\" << endl;\n\t"],[-1,7327,"04"],[-1,7331,"hild;\n"],[1,7337,"2(3, 4, 5);"],[-1,7349,"_04(int argc, char *argv[])\n\n{\n\n run04"],[1,7387,"()\n{\n\tParent p1(1, 2);  //构造函数写了之后必须调用\n\tChild c1(1,2,3);\n\n\t//为了能够完整的展现生命周期\n\tplayobj"],[-1,7392," "],[1,7393,"\n\t"],[-1,7410,"\n "],[1,7412,"\t"],[-1,7422,"\n"],[-1,7424,"\n"]],[6906,7425],[7847,7847]]],[1544016477402,["gjx16@GJXAIOU",[[-1,8005,"**"]],[8007,8007],[8005,8005]]],[1544018617512,["gjx16@GJXAIOU",[[1,8115,"\n"]],[8114,8114],[8115,8115]]],[1544018619789,["gjx16@GJXAIOU",[[1,8115,"yuanl"]],[8115,8115],[8120,8120]]],[1544018620706,["gjx16@GJXAIOU",[[-1,8115,"yuanl"]],[8120,8120],[8115,8115]]],[1544018620998,["gjx16@GJXAIOU",[[-1,8115,"\n"]],[8115,8115],[8114,8114]]],[1544018629072,["gjx16@GJXAIOU",[[1,8114,"原来的示例程序："]],[8114,8114],[8122,8122]]],[1544018632383,["gjx16@GJXAIOU",[[-1,8132,"\n"]],[8132,8132],[8131,8131]]],[1544018632515,["gjx16@GJXAIOU",[[-1,8131,"\n"]],[8131,8131],[8130,8130]]],[1544018635431,["gjx16@GJXAIOU",[[1,8114,"、"]],[8114,8114],[8115,8115]]],[1544018636296,["gjx16@GJXAIOU",[[-1,8114,"、"]],[8115,8115],[8114,8114]]],[1544018636713,["gjx16@GJXAIOU",[[1,8114,"\n"]],[8114,8114],[8115,8115]]],[1544018642819,["gjx16@GJXAIOU",[[1,8951,"\n"]],[8949,8949],[8950,8950]]],[1544018642953,["gjx16@GJXAIOU",[[1,8952,"\n"]],[8950,8950],[8951,8951]]],[1544018648868,["gjx16@GJXAIOU",[[1,8951,"自己写的示例城固县"]],[8951,8951],[8960,8960]]],[1544018651559,["gjx16@GJXAIOU",[[-1,8955,"示例城固县"]],[8960,8960],[8955,8955]]],[1544018654370,["gjx16@GJXAIOU",[[1,8955,"示例程序"]],[8955,8955],[8959,8959]]],[1544018655259,["gjx16@GJXAIOU",[[1,8961,"\n"]],[8959,8959],[8960,8960]]],[1544018657284,["gjx16@GJXAIOU",[[1,8960,"```"]],[8960,8960],[8963,8963]]],[1544018657323,["gjx16@GJXAIOU",[[1,8963,"language\n```\n"]],[8963,8963],[8963,8971]]],[1544018658403,["gjx16@GJXAIOU",[[-1,8963,"language"],[1,8971,"c"]],[8963,8971],[8964,8964]]],[1544018658794,["gjx16@GJXAIOU",[[1,8964,"pp"]],[8964,8964],[8966,8966]]],[1544018659680,["gjx16@GJXAIOU",[[1,8967,"\n"]],[8966,8966],[8967,8967]]],[1544018660914,["gjx16@GJXAIOU",[[1,8967,"//继承与组合混搭情况下，构造和析构调用原则\n\n#include \"iostream\"\nusing namespace std;\n\nclass Object\n{\npublic:\n\tObject(int a, int b);\n\t~Object();\n\nprivate:\n\tint a;\n\tint b;\n\n};\n\nObject::Object(int a, int b)\n{\n\tthis->a = a;\n\tthis->b = b;\n\tcout << \"这是祖宗类构造函数\" << endl;\n}\n\nObject::~Object()\n{\n\tcout << \"这是祖宗类的析构函数\" << endl;\n}\n\n\nclass Parent :public Object\n{\npublic:\n\tParent(char *p);\n\t~Parent();\nprivate:\n\tchar *p;\n};\n\nParent::Parent(char *p) : Object(1 , 2)\n{\n\tthis->p = p;\n\tcout << \"这是父类构造函数  \" << p<< endl;\n}\n\nParent::~Parent()\n{\n\tcout << \"这是父类析构函数\" << endl;\n}\n\n\n\n\nclass Child :public Parent\n{\npublic:\n\tChild(char *p);    \n\t~Child();\nprivate:\n\tchar *myp;\n\tObject obj1;//增加两个老祖宗类的成员变量\n\tObject obj2;\n\n};\n\nChild::Child(char *p) : Parent(p)  , obj1(3,4),obj2(5,6)\n{\n\tthis->myp = p;\n\tcout << \"这是子类的构造函数  \" << myp<<endl;\n}\n\nChild::~Child()\n{\n\tcout << \"这是子类的析构函数\" << endl;\n}\n\nvoid objplay()\n{\n\tChild c1();\n}\n\nint main()\n{\n\tobjplay();\n\tsystem(\"pause\");\n\treturn 0;\n}\n"]],[8967,8967],[9902,9902]]],[1544018672241,["gjx16@GJXAIOU",[[1,8960,"\n"]],[8959,8959],[8960,8960]]],[1544018674798,["gjx16@GJXAIOU",[[1,8960,"~~~~"]],[8960,8960],[8962,8962]]],[1544018689476,["gjx16@GJXAIOU",[[1,8962,"创建child对象的时候有点"]],[8962,8962],[8976,8976]]],[1544018691786,["gjx16@GJXAIOU",[[-1,8974,"有点"]],[8976,8976],[8974,8974]]],[1544018696869,["gjx16@GJXAIOU",[[1,8974,"有点问题"]],[8974,8974],[8978,8978]]],[1544018701591,["gjx16@GJXAIOU",[[-1,8962,"创建"]],[8964,8964],[8962,8962]]],[1544018703029,["gjx16@GJXAIOU",[[1,8962,"调用"]],[8962,8962],[8964,8964]]],[1544018823975,["gjx16@GJXAIOU",[[1,8978,"，里面场地"]],[8978,8978],[8983,8983]]],[1544018824607,["gjx16@GJXAIOU",[[-1,8982,"地"]],[8983,8983],[8982,8982]]],[1544018825015,["gjx16@GJXAIOU",[[-1,8981,"场"]],[8982,8982],[8981,8981]]],[1544018838014,["gjx16@GJXAIOU",[[1,8981,"传递的参数应该是什么"]],[8981,8981],[8991,8991]]]],null,"gjx16@GJXAIOU"],["534d74d4-55ed-4b31-885b-29f9ea4111a0",1544068295503,"# C_PP_章三 继承和派生\n\n\n## 一、继承概念\n\n面向对象程序设计有4个主要特点：抽象、封装、继承和多态性。我们已经讲解了类和对象，了解了面向对象程序设计的两个重要特征一数据抽象与封装，已经能够设计出基于对象的程序，这是面向对象程序设计的基础。\n\n要较好地进行面向对象程序设计，还必须了解面向对象程序设计另外两个重要特 征——继承性和多态性。本章主要介绍有关继承的知识，多态性将在后续章节中讲解。\n\n继承性是面向对象程序设计最重要的特征，可以说，如果没有掌握继承性，就等于没有掌握类和对象的精华，就是没有掌握面向对象程序设计的真谛。\n\n### （一）类之间的关系\n\nhas-A，uses-A 和 is-A\n\nhas-A 包含关系，用以描述一个类由多个“部件类”构成。实现has-A关系用类成员表示，即一个类中的数据成员是另一种已经定义的类。\n\nuses-A 一个类部分地使用另一个类。通过类之间成员函数的相互联系，定义友员或对象参数传递实现。\n\nis-A 机制称为“继承”。关系具有传递性,不具有对称性。\n\n### （二）继承关系举例\n\n万事万物中皆有继承，是重要的现象 \n\n两个案例：1）植物继承图；2）程序员继承图\n![1]($resource/1.png)\n\n### （三）继承相关概念\n\n![2]($resource/2.png)\n\n### （四）派生类的定义\n\n![3]($resource/3.png)\n\n注意：C++中的继承方式（public、private、protected）会影响子类的对外访问属性。\n\n\n### （五）继承重要说明\n\n1、子类拥有父类的所有成员变量和成员函数\n2、子类可以拥有父类没有的方法和属性\n3、子类就是一种特殊的父类\n4、子类对象可以当作父类对象使用\n\n--------\n\n## 二、派生类的访问控制\n\n派生类继承了基类的全部成员变量和成员方法（除了构造和析构之外的成员方法），但是这些成员的访问属性，在派生过程中是可以调整的。\n\n\n\n### （一）单个类的访问控制\n\n1、类成员访问级别（public、private、protected）\n\n2、思考：类成员的访问级别只有public和private是否足够？\n```cpp\n//单个类的访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass TestParent\n{\npublic:  //修饰的成员变量和方法，可以在类的内部和外部使用；\n\tTestParent();\n\t~TestParent();\n\tvoid print();\n\tint m_a; \nprotected://修饰的成员变量和方法，只能在类的内部使用，在继承的子类中可以使用\n\tint m_b;\nprivate: //修饰的成员变量和方法，只能在类的内部使用，不能在类的外部使用\n\tint m_c;\n\n};\n\nTestParent::TestParent()\n{\n\tm_a = 0; \n\tm_b = 0;\n\tm_c = 0;\n}\n\nTestParent::~TestParent()\n{\n\treturn;\n}\n\nvoid TestParent::print()\n{\n\tcout << \"m_a = \" << m_a << endl;\n\tcout << \"m_b = \" << m_b << endl;\n\tcout << \"m_c = \" << m_c << endl;\n}\n\n\n\n//三种继承方式的子类\n\n\n//公有继承\nclass TestChild1:public TestParent  //这里还可以是protected 或者private\n{\npublic:\n\tvoid useVar1();\nprivate:\n\n};\n\n\nvoid TestChild1::useVar1()\n{\n\tm_a = 1;//ok\n\tm_b = 2;//ok\n\t//m_c = 3; //error\n}\n\n\n\n//保护继承\nclass TestChild2 :protected TestParent\n{\npublic:\n\tvoid useVar2();\nprivate:\n\n};\n\n\nvoid TestChild2::useVar2()\n{\n\tm_a = 1;//ok\n\tm_b = 2;//ok\n\t//m_c = 3;//error\n}\n\n\n\n//private 继承\nclass TestChild3 :private TestParent\n{\npublic:\n\tvoid useVar3();\nprivate:\n\n};\n\n\nvoid TestChild3::useVar3()\n{\n\tm_a = 1;//ok\n\tm_b = 2;//ok\n\t//m_c = 3;//error\n}\n\n\n\nint main()\n{\n\t\n\t//public:\n\tTestChild1 t1;\n\tt1.m_a = 4;//ok\n\t//t1.m_b = 5;//error\n\t//t1.m_c = 6;//error\n\n\t//protected:\n\tTestChild2 t2;\n\t//t2.m_a = 11;\n\t//t2.m_b = 22;\n\t//t2.m_c = 33;\n\n\t//private:\n\tTestChild3 t3;\n\t//t3.m_a = 111;\n\t//t3.m_b = 222;\n\t//t3.m_c = 333;\n\n\treturn 0;\n\n}\n```\n\n\n### （二）不同的继承方式会改变继承成员的访问属性\n\n**1.C++中的继承方式会影响子类的对外访问属性**\n\npublic继承：父类成员在子类中保持原有访问级别\n\nprivate继承：父类成员在子类中变为private成员\n\nprotected继承：父类中public成员会变成protected\n\n  父类中protected成员仍然为protected\n\n  父类中private成员仍然为private\n\n**2。private成员在子类中依然存在，但是却无法访问到。不论种方式继承基类，派生类都不能直接使用基类的私有成员**。\n\n**3.C++中子类对外访问属性表**\n|    |父类 |成员  |访问|级别|\n|---|---|---|---|---|\n|继\t| |public|\tproteced|\tprivate|\n|承 | public\t|public\t|proteced|\tprivate|\n|方 | proteced\t|proteced|\tproteced|\tprivate|\n|式 |private\t|private|\tprivate\t|Private|\n\n\n**4.继承中的访问控制**\n![4]($resource/4.png)\n\n### （三）“三看”原则**\n\nC++中的继承方式（public、private、protected）会影响子类的对外访问属性    \n\n判断某一句话，能否被访问\n\n 1）看调用语句，这句话写在子类的内部、外部\n\n 2）看子类如何从父类继承（public、private、protected）    \n\n 3）看父类中的访问级别（public、private、protected）\n\n### （四）派生类类成员访问级别设置的原则\n\n思考：如何恰当的使用public，protected和private为成员声明访问级别？\n\n1、需要被外界访问的成员直接设置为public\n\n2、只能在当前类中访问的成员设置为private\n\n3、只能在当前类和子类中访问的成员设置为protected，protected成员的访问权限介于public和private之间。\n\n### （五）综合训练**\n\n练习：\n\npublic继承不会改变父类对外访问属性；\n\nprivate继承会改变父类对外访问属性为private；\n\nprotected继承会部分改变父类对外访问属性。\n\n结论：一般情况下class B : public A\n\n```cpp\n\n//类的继承方式对子类对外访问属性影响\n\n#include\"iostream\"\nusing namespace std;\n\nclass A\n{\nprivate:\n\tint a;\nprotected:\n\tint b;\npublic:\n\tint c;\n\tA();\n\tvoid set(int a, int b, int c);\n};\n\nA::A()\n{\n\ta = 0;\n\tb = 0;\n\tc = 0;\n}\n\nvoid A::set(int a, int b, int c)\n{\n\tthis->a = a;\n\tthis->b = b;\n\tthis->c = c;\n}\n\n\n//public:\n\nclass B : public A\n{\npublic:\n\tvoid print()\n\t{\n\t\t//cout<<\"a = \"<<a<<endl; //err\n\t\tcout << \"b = \" << b<<endl;\n\t\tcout << \"c = \" << c << endl;\n\t}\n};\n\n\n//protected:\nclass C : protected A\n{\npublic:\n\tvoid print()\n\t{\n\t\t//cout<<\"a = \"<<a<<endl; //err\n\t\tcout << \"b = \" << b << endl;\n\t\tcout << \"c = \" << c << endl;\n\t}\n};\n\n//private\nclass D : private A\n{\npublic:\n\tvoid print()\n\t{\n\t\t//cout<<\"a = \"<<a; //err\n\t\tcout << \"b = \" << b << endl;//保护的在子类中变成私有的，但是在子类中仍可使用\n\t\tcout << \"c = \" << c << endl;//保护的在子类中变成私有的，但是在子类中仍可使用\n\t}\n};\n\n\n\nint main()\n{\n\tA aa;\n\tB bb;\n\tC cc;\n\tD dd;\n\taa.c = 100; //ok\n\tbb.c = 100; //ok\n\t//cc.c = 100; //err 类的外部是什么含义\n\t//dd.c = 100; //err\n\taa.set(1, 2, 3);\n\tbb.set(10, 20, 30);\n\t//cc.set(40, 50, 60); //ee\n\n\t//dd.set(70, 80, 90); //ee\n\tbb.print();\n\tcc.print();\n\tdd.print();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n## 三、继承中的构造和析构\n\n### （一）类型兼容性原则\n\n类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。类型兼容规则中所指的替代包括以下情况：\n\n* 子类对象可以当作父类对象使用\n* 子类对象可以直接赋值给父类对象\n* 子类对象可以直接初始化父类对象\n* 父类指针可以直接指向子类对象\n* 父类引用可以直接引用子类对象\n在替代之后，派生类对象就可以作为基类的对象使用，但是只能使用从基类继承的成员。\n类型兼容规则是多态性的重要基础之一。\n\n总结：子类就是特殊的父类 (**base *p = &child;)**\n这是源文档的示例程序：\n```cpp\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\n/*\n子类对象可以当作父类对象使用\n  子类对象可以直接赋值给父类对象\n  子类对象可以直接初始化父类对象\n  父类指针可以直接指向子类对象\n  父类引用可以直接引用子类对象\n */\n\n//子类就是特殊的父类\n\nclass Parent03\n\n{\n\nprotected:\n\n const char* name;\n\npublic:\n\n Parent03()\n\n {\n\n name = \"Parent03\";\n\n }\n\n void print()\n\n {\n\n cout<<\"Name: \"<<name<<endl;\n\n }\n\n};\n\nclass Child03 : public Parent03\n\n{\n\nprotected:\n\n int i;\n\npublic:\n\n Child03(int i)\n\n {\n\n this->name = \"Child2\";\n\n this->i = i;\n\n }\n\n};\n\nint main()\n\n{\n\n Child03 child03(1000);\n\n //分别定义父类对象 父类指针 父类引用 child\n\n Parent03 parent = child03;\n\n Parent03* pp = &child03;\n\n Parent03& rp = child03;\n\n parent.print();\n\n pp->print();\n\n rp.print();\n\n system(\"pause\");\n\n return 0;\n\n}\n\n```\n\n这是亲自敲得示例程序：\n```cpp\n// 类型兼容性原则\n\n/*\n子类对象可以当作父类对象使用\n  子类对象可以直接赋值给父类对象\n  子类对象可以直接初始化父类对象\n  父类指针可以直接指向子类对象\n  父类引用可以直接引用子类对象\n */\n#include \"iostream\"\nusing namespace std;\n\nclass Parent\n{\npublic:\n\tParent();\n\tParent(const Parent &obj);\n\tvoid print_Parent();\nprivate:\n\n};\n\nParent::Parent()\n{\n\tcout << \"这是父类构造函数\" << endl;\n}\nParent::Parent(const Parent &obj)\n{\n\tcout << \"这是父类的拷贝构造函数\" << endl;\n}\n\nvoid Parent::print_Parent()\n{\n\tcout << \"这是父类\" << endl;\n}\n\n\n\n\nclass Child :public Parent\n{\npublic:\n\tvoid print_Child();\nprivate:\n\n};\n\nvoid Child::print_Child()\n{\n\tcout << \"这是子类\" << endl;\n}\n\n\nvoid howtoprint1(Parent *p)  //父类指针做函数参数\n{\n\tp->print_Parent();  //调用的是父类的成员函数\n}\n\nvoid howtoprint2(Parent &p)  \n{\n\tp.print_Parent();  \n}\n\n\n\nint main()\n{\n\tParent p1;\n\tp1.print_Parent();\n\n\tChild c1;\n\tc1.print_Child();\n\tc1.print_Parent();//子类对象可以调用父类的方法\n\n\n\n\t//赋值兼容性原则\n\t//1.1基类指针（引用）指向 子类对象\n\n\tParent *p = NULL;\n\tp = &c1;\n\tp->print_Parent();\n\n\n\t//1.2 指针做函数参数\n\thowtoprint1(&p1);  //传递父类对象可以\n\thowtoprint1(&c1);  //传递子类对象也可以，因为赋值兼容性原则\n\n\t//1.3引用做函数参数\n\thowtoprint2(p1);\n\thowtoprint2(c1);\n\n\n\n\t//2.可以使用子类对象初始父类对象\n\t//因为子类就是一种特殊的父类\n\tParent p2 = c1;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n### （二）继承中的对象模型\n\n类在C++编译器的内部可以理解为结构体\n\n子类是由父类成员叠加子类新成员得到的\n\n\n![5]($resource/5.png)\n![6]($resource/6.png)\n\n\n**继承中构造和析构**\n\n**问题：如何初始化父类成员？父类与子类的构造函数有什么关系**\n\n  在子类对象构造时，需要**调用父类构造函数对其继承得来的成员进行初始化**\n\n  在子类对象析构时，需要**调用父类析构函数对其继承得来的成员进行清理**\n\n```cpp\n\n//继承中构造和析构\n\n#include \"iostream\"\nusing namespace std;\n\nclass Parent\n{\npublic:\n\tParent(int a, int b);\n\t~Parent();\n\tvoid print_Parent();\nprivate:\n\tint a;\n\tint b;\n};\n\nParent::Parent(int a, int b)\n{\n\tthis->a = a;\n\tthis->b = b;\n\tcout << \"这是父类构造函数\" << endl;\n}\n\nParent::~Parent()\n{\n\tcout << \"这是父类析构函数\" << endl;\n}\n\n\nvoid Parent::print_Parent()\n{\n\tcout << \"这是父类的方法\" << endl;\n}\n\n\n\n\nclass Child :public Parent\n{\npublic:\n\tChild(int a, int b, int c);    //声明的时候不需要加上后缀\n\t~Child();\n\tvoid print_Child();\nprivate:\n\tint c;\n\n};\n\nChild::Child(int a, int b, int c) : Parent(a, b)   //但是实现的时候需要在后面加上继承的成员变量\n{\n\tthis->c = c;\n\tcout << \"这是子类的构造函数\" << endl;\n}\n\nChild::~Child()\n{\n\tcout << \"这是子类的析构函数\" << endl;\n}\n\nvoid Child::print_Child()\n{\n\tcout << \"这是子类方法\" << endl;\n}\n\n\nvoid playobj()\n{\n\tcout << \"下面是完整的生命周期\" << endl;\n\tChild c2(3, 4, 5);\n}\n\nint main()\n{\n\tParent p1(1, 2);  //构造函数写了之后必须调用\n\tChild c1(1,2,3);\n\n\t//为了能够完整的展现生命周期\n\tplayobj();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### （三）继承中的构造析构调用原则\n\n1、子类对象在创建时会首先调用父类的构造函数\n\n2、父类构造函数执行结束后，执行子类的构造函数\n\n3、当父类的构造函数有参数时，需要在子类的初始化列表中显示调用\n\n4、析构函数调用的先后顺序与构造函数相反\n\n### （四）继承与组合混搭情况下，构造和析构调用原则\n\n  原则：  先构造父类，再构造成员变量、最后构造自己\n\n  先析构自己，在析构成员变量、最后析构父类\n\n //先构造的对象，后释放\n\n练习：demo05_extend_construct_destory.cpp\n\n原来的示例程序：\n```cpp\n\n//子类对象如何初始化父类成员\n\n//继承中的构造和析构\n\n//继承和组合混搭情况下，构造函数、析构函数调用顺序研究\n\n#include <iostream>\n\nusing namespace std;\n\nclass Object\n\n{\n\npublic:\n\n Object(const char* s)\n\n {\n\n cout<<\"Object()\"<<\" \"<<s<<endl;\n\n }\n\n ~Object()\n\n {\n\n cout<<\"~Object()\"<<endl;\n\n }\n\n};\n\nclass Parent : public Object\n\n{\n\npublic:\n\n Parent(const char* s) : Object(s)\n\n {\n\n cout<<\"Parent()\"<<\" \"<<s<<endl;\n\n }\n\n ~Parent()\n\n {\n\n cout<<\"~Parent()\"<<endl;\n\n }\n\n};\n\nclass Child : public Parent\n\n{\n\nprotected:\n\n Object o1;\n\n Object o2;\n\npublic:\n\n Child() : o2(\"o2\"), o1(\"o1\"), Parent(\"Parameter from Child!\")\n\n {\n\n cout<<\"Child()\"<<endl;\n\n }\n\n ~Child()\n\n {\n\n cout<<\"~Child()\"<<endl;\n\n }\n\n};\n\nvoid run05()\n\n{\n\n Child child;\n\n}\n\nint main05(int argc, char *argv[])\n\n{\n\n cout<<\"demo05_extend_construct_destory.cpp\"<<endl;\n\n run05();\n\n system(\"pause\");\n\n return 0;\n\n}\n\n```\n\n自己写的示例程序\n~~调用child对象的时候有点问题，里面传递的参数应该是什么~~\n```cpp\n//继承与组合混搭情况下，构造和析构调用原则\n\n#include \"iostream\"\nusing namespace std;\n\nclass Object\n{\npublic:\n\tObject(int a, int b);\n\t~Object();\n\nprivate:\n\tint a;\n\tint b;\n\n};\n\nObject::Object(int a, int b)\n{\n\tthis->a = a;\n\tthis->b = b;\n\tcout << \"这是祖宗类构造函数\" << endl;\n}\n\nObject::~Object()\n{\n\tcout << \"这是祖宗类的析构函数\" << endl;\n}\n\n\nclass Parent :public Object\n{\npublic:\n\tParent(char *p);\n\t~Parent();\nprivate:\n\tchar *p;\n};\n\nParent::Parent(char *p) : Object(1 , 2)\n{\n\tthis->p = p;\n\tcout << \"这是父类构造函数  \" << p<< endl;\n}\n\nParent::~Parent()\n{\n\tcout << \"这是父类析构函数\" << endl;\n}\n\n\n\n\nclass Child :public Parent\n{\npublic:\n\tChild(char *p);    \n\t~Child();\nprivate:\n\tchar *myp;\n\tObject obj1;//增加两个老祖宗类的成员变量\n\tObject obj2;\n\n};\n\nChild::Child(char *p) : Parent(p)  , obj1(3,4),obj2(5,6)\n{\n\tthis->myp = p;\n\tcout << \"这是子类的构造函数  \" << myp<<endl;\n}\n\nChild::~Child()\n{\n\tcout << \"这是子类的析构函数\" << endl;\n}\n\nvoid objplay()\n{\n\tChild c1();\n}\n\nint main()\n{\n\tobjplay();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n\n### （五）继承中的同名成员变量处理方法\n\n1、当子类成员变量与父类成员变量同名时\n\n2、子类依然从父类继承同名成员\n\n3、在子类中通过作用域分辨符::进行同名成员区分（**在派生类中使用基类的同名成员，显式地使用类名限定符**）\n\n4、同名成员存储在内存中的不同位置\n\n![7]($resource/7.png)\n![8]($resource/8.png)\n\n总结：同名成员变量和成员函数通过作用域分辨符进行区分\n\n### （六）派生类中的static关键字\n\n继承和static关键字在一起会产生什么现象哪？\n\n理论知识\n\nØ 基类定义的静态成员，将被所有派生类共享\n\nØ 根据静态成员自身的访问特性和派生类的继承方式，在类层次体系中具有不同的访问性质  （遵守派生类的访问控制）\n\nØ  派生类中访问静态成员，用以下形式显式说明：\n\n_类名_ :: _成员_\n\n  或通过对象访问  _对象名_ . _成员_\n\n![aa]($resource/aa.png)\n![bb]($resource/bb.png)\n![cc]($resource/cc.png)\n\n总结：\n\n1> static函数也遵守3个访问原则\n\n2> static易犯错误（不但要初始化，更重要的显示的告诉编译器分配内存）\n\n3> 构造函数默认为private\n",[[1544068288609,["gjx16@GJXAIOU",[[1,9300,"                                                                                                                                                                                                                                                                                                                                                                                                                                                               "]],[9300,9300],[9747,9747]]]],null,"gjx16@GJXAIOU"],["1f1ad863-def6-4c66-9afe-344632b541e3",1544070279667,"# C_PP_章三 继承和派生\n\n\n## 一、继承概念\n\n面向对象程序设计有4个主要特点：抽象、封装、继承和多态性。我们已经讲解了类和对象，了解了面向对象程序设计的两个重要特征一数据抽象与封装，已经能够设计出基于对象的程序，这是面向对象程序设计的基础。\n\n要较好地进行面向对象程序设计，还必须了解面向对象程序设计另外两个重要特 征——继承性和多态性。本章主要介绍有关继承的知识，多态性将在后续章节中讲解。\n\n继承性是面向对象程序设计最重要的特征，可以说，如果没有掌握继承性，就等于没有掌握类和对象的精华，就是没有掌握面向对象程序设计的真谛。\n\n### （一）类之间的关系\n\nhas-A，uses-A 和 is-A\n\nhas-A 包含关系，用以描述一个类由多个“部件类”构成。实现has-A关系用类成员表示，即一个类中的数据成员是另一种已经定义的类。\n\nuses-A 一个类部分地使用另一个类。通过类之间成员函数的相互联系，定义友员或对象参数传递实现。\n\nis-A 机制称为“继承”。关系具有传递性,不具有对称性。\n\n### （二）继承关系举例\n\n万事万物中皆有继承，是重要的现象 \n\n两个案例：1）植物继承图；2）程序员继承图\n![1]($resource/1.png)\n\n### （三）继承相关概念\n\n![2]($resource/2.png)\n\n### （四）派生类的定义\n\n![3]($resource/3.png)\n\n注意：C++中的继承方式（public、private、protected）会影响子类的对外访问属性。\n\n\n### （五）继承重要说明\n\n1、子类拥有父类的所有成员变量和成员函数\n2、子类可以拥有父类没有的方法和属性\n3、子类就是一种特殊的父类\n4、子类对象可以当作父类对象使用\n\n--------\n\n## 二、派生类的访问控制\n\n派生类继承了基类的全部成员变量和成员方法（除了构造和析构之外的成员方法），但是这些成员的访问属性，在派生过程中是可以调整的。\n\n\n\n### （一）单个类的访问控制\n\n1、类成员访问级别（public、private、protected）\n\n2、思考：类成员的访问级别只有public和private是否足够？\n```cpp\n//单个类的访问控制\n\n#include\"iostream\"\nusing namespace std;\n\nclass TestParent\n{\npublic:  //修饰的成员变量和方法，可以在类的内部和外部使用；\n\tTestParent();\n\t~TestParent();\n\tvoid print();\n\tint m_a; \nprotected://修饰的成员变量和方法，只能在类的内部使用，在继承的子类中可以使用\n\tint m_b;\nprivate: //修饰的成员变量和方法，只能在类的内部使用，不能在类的外部使用\n\tint m_c;\n\n};\n\nTestParent::TestParent()\n{\n\tm_a = 0; \n\tm_b = 0;\n\tm_c = 0;\n}\n\nTestParent::~TestParent()\n{\n\treturn;\n}\n\nvoid TestParent::print()\n{\n\tcout << \"m_a = \" << m_a << endl;\n\tcout << \"m_b = \" << m_b << endl;\n\tcout << \"m_c = \" << m_c << endl;\n}\n\n\n\n//三种继承方式的子类\n\n\n//公有继承\nclass TestChild1:public TestParent  //这里还可以是protected 或者private\n{\npublic:\n\tvoid useVar1();\nprivate:\n\n};\n\n\nvoid TestChild1::useVar1()\n{\n\tm_a = 1;//ok\n\tm_b = 2;//ok\n\t//m_c = 3; //error\n}\n\n\n\n//保护继承\nclass TestChild2 :protected TestParent\n{\npublic:\n\tvoid useVar2();\nprivate:\n\n};\n\n\nvoid TestChild2::useVar2()\n{\n\tm_a = 1;//ok\n\tm_b = 2;//ok\n\t//m_c = 3;//error\n}\n\n\n\n//private 继承\nclass TestChild3 :private TestParent\n{\npublic:\n\tvoid useVar3();\nprivate:\n\n};\n\n\nvoid TestChild3::useVar3()\n{\n\tm_a = 1;//ok\n\tm_b = 2;//ok\n\t//m_c = 3;//error\n}\n\n\n\nint main()\n{\n\t\n\t//public:\n\tTestChild1 t1;\n\tt1.m_a = 4;//ok\n\t//t1.m_b = 5;//error\n\t//t1.m_c = 6;//error\n\n\t//protected:\n\tTestChild2 t2;\n\t//t2.m_a = 11;\n\t//t2.m_b = 22;\n\t//t2.m_c = 33;\n\n\t//private:\n\tTestChild3 t3;\n\t//t3.m_a = 111;\n\t//t3.m_b = 222;\n\t//t3.m_c = 333;\n\n\treturn 0;\n\n}\n```\n\n\n### （二）不同的继承方式会改变继承成员的访问属性\n\n**1.C++中的继承方式会影响子类的对外访问属性**\n\npublic继承：父类成员在子类中保持原有访问级别\n\nprivate继承：父类成员在子类中变为private成员\n\nprotected继承：父类中public成员会变成protected\n\n  父类中protected成员仍然为protected\n\n  父类中private成员仍然为private\n\n**2。private成员在子类中依然存在，但是却无法访问到。不论种方式继承基类，派生类都不能直接使用基类的私有成员**。\n\n**3.C++中子类对外访问属性表**\n|    |父类 |成员  |访问|级别|\n|---|---|---|---|---|\n|继\t| |public|\tproteced|\tprivate|\n|承 | public\t|public\t|proteced|\tprivate|\n|方 | proteced\t|proteced|\tproteced|\tprivate|\n|式 |private\t|private|\tprivate\t|Private|\n\n\n**4.继承中的访问控制**\n![4]($resource/4.png)\n\n### （三）“三看”原则**\n\nC++中的继承方式（public、private、protected）会影响子类的对外访问属性    \n\n判断某一句话，能否被访问\n\n 1）看调用语句，这句话写在子类的内部、外部\n\n 2）看子类如何从父类继承（public、private、protected）    \n\n 3）看父类中的访问级别（public、private、protected）\n\n### （四）派生类类成员访问级别设置的原则\n\n思考：如何恰当的使用public，protected和private为成员声明访问级别？\n\n1、需要被外界访问的成员直接设置为public\n\n2、只能在当前类中访问的成员设置为private\n\n3、只能在当前类和子类中访问的成员设置为protected，protected成员的访问权限介于public和private之间。\n\n### （五）综合训练**\n\n练习：\n\npublic继承不会改变父类对外访问属性；\n\nprivate继承会改变父类对外访问属性为private；\n\nprotected继承会部分改变父类对外访问属性。\n\n结论：一般情况下class B : public A\n\n```cpp\n\n//类的继承方式对子类对外访问属性影响\n\n#include\"iostream\"\nusing namespace std;\n\nclass A\n{\nprivate:\n\tint a;\nprotected:\n\tint b;\npublic:\n\tint c;\n\tA();\n\tvoid set(int a, int b, int c);\n};\n\nA::A()\n{\n\ta = 0;\n\tb = 0;\n\tc = 0;\n}\n\nvoid A::set(int a, int b, int c)\n{\n\tthis->a = a;\n\tthis->b = b;\n\tthis->c = c;\n}\n\n\n//public:\n\nclass B : public A\n{\npublic:\n\tvoid print()\n\t{\n\t\t//cout<<\"a = \"<<a<<endl; //err\n\t\tcout << \"b = \" << b<<endl;\n\t\tcout << \"c = \" << c << endl;\n\t}\n};\n\n\n//protected:\nclass C : protected A\n{\npublic:\n\tvoid print()\n\t{\n\t\t//cout<<\"a = \"<<a<<endl; //err\n\t\tcout << \"b = \" << b << endl;\n\t\tcout << \"c = \" << c << endl;\n\t}\n};\n\n//private\nclass D : private A\n{\npublic:\n\tvoid print()\n\t{\n\t\t//cout<<\"a = \"<<a; //err\n\t\tcout << \"b = \" << b << endl;//保护的在子类中变成私有的，但是在子类中仍可使用\n\t\tcout << \"c = \" << c << endl;//保护的在子类中变成私有的，但是在子类中仍可使用\n\t}\n};\n\n\n\nint main()\n{\n\tA aa;\n\tB bb;\n\tC cc;\n\tD dd;\n\taa.c = 100; //ok\n\tbb.c = 100; //ok\n\t//cc.c = 100; //err 类的外部是什么含义\n\t//dd.c = 100; //err\n\taa.set(1, 2, 3);\n\tbb.set(10, 20, 30);\n\t//cc.set(40, 50, 60); //ee\n\n\t//dd.set(70, 80, 90); //ee\n\tbb.print();\n\tcc.print();\n\tdd.print();\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n## 三、继承中的构造和析构\n\n### （一）类型兼容性原则\n\n类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。类型兼容规则中所指的替代包括以下情况：\n\n* 子类对象可以当作父类对象使用\n* 子类对象可以直接赋值给父类对象\n* 子类对象可以直接初始化父类对象\n* 父类指针可以直接指向子类对象\n* 父类引用可以直接引用子类对象\n在替代之后，派生类对象就可以作为基类的对象使用，但是只能使用从基类继承的成员。\n类型兼容规则是多态性的重要基础之一。\n\n总结：子类就是特殊的父类 (**base *p = &child;)**\n这是源文档的示例程序：\n```cpp\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\n/*\n子类对象可以当作父类对象使用\n  子类对象可以直接赋值给父类对象\n  子类对象可以直接初始化父类对象\n  父类指针可以直接指向子类对象\n  父类引用可以直接引用子类对象\n */\n\n//子类就是特殊的父类\n\nclass Parent03\n\n{\n\nprotected:\n\n const char* name;\n\npublic:\n\n Parent03()\n\n {\n\n name = \"Parent03\";\n\n }\n\n void print()\n\n {\n\n cout<<\"Name: \"<<name<<endl;\n\n }\n\n};\n\nclass Child03 : public Parent03\n\n{\n\nprotected:\n\n int i;\n\npublic:\n\n Child03(int i)\n\n {\n\n this->name = \"Child2\";\n\n this->i = i;\n\n }\n\n};\n\nint main()\n\n{\n\n Child03 child03(1000);\n\n //分别定义父类对象 父类指针 父类引用 child\n\n Parent03 parent = child03;\n\n Parent03* pp = &child03;\n\n Parent03& rp = child03;\n\n parent.print();\n\n pp->print();\n\n rp.print();\n\n system(\"pause\");\n\n return 0;\n\n}\n\n```\n\n这是亲自敲得示例程序：\n```cpp\n// 类型兼容性原则\n\n/*\n子类对象可以当作父类对象使用\n  子类对象可以直接赋值给父类对象\n  子类对象可以直接初始化父类对象\n  父类指针可以直接指向子类对象\n  父类引用可以直接引用子类对象\n */\n#include \"iostream\"\nusing namespace std;\n\nclass Parent\n{\npublic:\n\tParent();\n\tParent(const Parent &obj);\n\tvoid print_Parent();\nprivate:\n\n};\n\nParent::Parent()\n{\n\tcout << \"这是父类构造函数\" << endl;\n}\nParent::Parent(const Parent &obj)\n{\n\tcout << \"这是父类的拷贝构造函数\" << endl;\n}\n\nvoid Parent::print_Parent()\n{\n\tcout << \"这是父类\" << endl;\n}\n\n\n\n\nclass Child :public Parent\n{\npublic:\n\tvoid print_Child();\nprivate:\n\n};\n\nvoid Child::print_Child()\n{\n\tcout << \"这是子类\" << endl;\n}\n\n\nvoid howtoprint1(Parent *p)  //父类指针做函数参数\n{\n\tp->print_Parent();  //调用的是父类的成员函数\n}\n\nvoid howtoprint2(Parent &p)  \n{\n\tp.print_Parent();  \n}\n\n\n\nint main()\n{\n\tParent p1;\n\tp1.print_Parent();\n\n\tChild c1;\n\tc1.print_Child();\n\tc1.print_Parent();//子类对象可以调用父类的方法\n\n\n\n\t//赋值兼容性原则\n\t//1.1基类指针（引用）指向 子类对象\n\n\tParent *p = NULL;\n\tp = &c1;\n\tp->print_Parent();\n\n\n\t//1.2 指针做函数参数\n\thowtoprint1(&p1);  //传递父类对象可以\n\thowtoprint1(&c1);  //传递子类对象也可以，因为赋值兼容性原则\n\n\t//1.3引用做函数参数\n\thowtoprint2(p1);\n\thowtoprint2(c1);\n\n\n\n\t//2.可以使用子类对象初始父类对象\n\t//因为子类就是一种特殊的父类\n\tParent p2 = c1;\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n### （二）继承中的对象模型\n\n类在C++编译器的内部可以理解为结构体\n\n子类是由父类成员叠加子类新成员得到的\n\n\n![5]($resource/5.png)\n![6]($resource/6.png)\n\n\n**继承中构造和析构**\n\n**问题：如何初始化父类成员？父类与子类的构造函数有什么关系**\n\n  在子类对象构造时，需要**调用父类构造函数对其继承得来的成员进行初始化**\n\n  在子类对象析构时，需要**调用父类析构函数对其继承得来的成员进行清理**\n\n```cpp\n\n//继承中构造和析构\n\n#include \"iostream\"\nusing namespace std;\n\nclass Parent\n{\npublic:\n\tParent(int a, int b);\n\t~Parent();\n\tvoid print_Parent();\nprivate:\n\tint a;\n\tint b;\n};\n\nParent::Parent(int a, int b)\n{\n\tthis->a = a;\n\tthis->b = b;\n\tcout << \"这是父类构造函数\" << endl;\n}\n\nParent::~Parent()\n{\n\tcout << \"这是父类析构函数\" << endl;\n}\n\n\nvoid Parent::print_Parent()\n{\n\tcout << \"这是父类的方法\" << endl;\n}\n\n\n\n\nclass Child :public Parent\n{\npublic:\n\tChild(int a, int b, int c);    //声明的时候不需要加上后缀\n\t~Child();\n\tvoid print_Child();\nprivate:\n\tint c;\n\n};\n\nChild::Child(int a, int b, int c) : Parent(a, b)   //但是实现的时候需要在后面加上继承的成员变量\n{\n\tthis->c = c;\n\tcout << \"这是子类的构造函数\" << endl;\n}\n\nChild::~Child()\n{\n\tcout << \"这是子类的析构函数\" << endl;\n}\n\nvoid Child::print_Child()\n{\n\tcout << \"这是子类方法\" << endl;\n}\n\n\nvoid playobj()\n{\n\tcout << \"下面是完整的生命周期\" << endl;\n\tChild c2(3, 4, 5);\n}\n\nint main()\n{\n\tParent p1(1, 2);  //构造函数写了之后必须调用\n\tChild c1(1,2,3);\n\n\t//为了能够完整的展现生命周期\n\tplayobj();\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n### （三）继承中的构造析构调用原则\n\n1、子类对象在创建时会首先调用父类的构造函数\n\n2、父类构造函数执行结束后，执行子类的构造函数\n\n3、当父类的构造函数有参数时，需要在子类的初始化列表中显示调用\n\n4、析构函数调用的先后顺序与构造函数相反\n\n### （四）继承与组合混搭情况下，构造和析构调用原则\n\n  原则：  先构造父类，再构造成员变量、最后构造自己\n\n  先析构自己，在析构成员变量、最后析构父类\n\n //先构造的对象，后释放\n\n练习：demo05_extend_construct_destory.cpp\n\n原来的示例程序：\n```cpp\n\n//子类对象如何初始化父类成员\n\n//继承中的构造和析构\n\n//继承和组合混搭情况下，构造函数、析构函数调用顺序研究\n\n#include <iostream>\n\nusing namespace std;\n\nclass Object\n\n{\n\npublic:\n\n Object(const char* s)\n\n {\n\n cout<<\"Object()\"<<\" \"<<s<<endl;\n\n }\n\n ~Object()\n\n {\n\n cout<<\"~Object()\"<<endl;\n\n }\n\n};\n\nclass Parent : public Object\n\n{\n\npublic:\n\n Parent(const char* s) : Object(s)\n\n {\n\n cout<<\"Parent()\"<<\" \"<<s<<endl;\n\n }\n\n ~Parent()\n\n {\n\n cout<<\"~Parent()\"<<endl;\n\n }\n\n};\n\nclass Child : public Parent\n\n{\n\nprotected:\n\n Object o1;\n\n Object o2;\n\npublic:\n\n Child() : o2(\"o2\"), o1(\"o1\"), Parent(\"Parameter from Child!\")\n\n {\n\n cout<<\"Child()\"<<endl;\n\n }\n\n ~Child()\n\n {\n\n cout<<\"~Child()\"<<endl;\n\n }\n\n};\n\nvoid run05()\n\n{\n\n Child child;\n\n}\n\nint main05(int argc, char *argv[])\n\n{\n\n cout<<\"demo05_extend_construct_destory.cpp\"<<endl;\n\n run05();\n\n system(\"pause\");\n\n return 0;\n\n}\n\n```\n\n自己写的示例程序\n~~调用child对象的时候有点问题，里面传递的参数应该是什么~~\n```cpp\n//继承与组合混搭情况下，构造和析构调用原则\n\n#include \"iostream\"\nusing namespace std;\n\nclass Object\n{\npublic:\n\tObject(int a, int b);\n\t~Object();\n\nprivate:\n\tint a;\n\tint b;\n\n};\n\nObject::Object(int a, int b)\n{\n\tthis->a = a;\n\tthis->b = b;\n\tcout << \"这是祖宗类构造函数\" << endl;\n}\n\nObject::~Object()\n{\n\tcout << \"这是祖宗类的析构函数\" << endl;\n}                                                                                                                                                                                                                                                                                                                                                                                                                                                               \n\n\nclass Parent :public Object\n{\npublic:\n\tParent(char *p);\n\t~Parent();\nprivate:\n\tchar *p;\n};\n\nParent::Parent(char *p) : Object(1 , 2)\n{\n\tthis->p = p;\n\tcout << \"这是父类构造函数  \" << p<< endl;\n}\n\nParent::~Parent()\n{\n\tcout << \"这是父类析构函数\" << endl;\n}\n\n\n\n\nclass Child :public Parent\n{\npublic:\n\tChild(char *p);    \n\t~Child();\nprivate:\n\tchar *myp;\n\tObject obj1;//增加两个老祖宗类的成员变量\n\tObject obj2;\n\n};\n\nChild::Child(char *p) : Parent(p)  , obj1(3,4),obj2(5,6)\n{\n\tthis->myp = p;\n\tcout << \"这是子类的构造函数  \" << myp<<endl;\n}\n\nChild::~Child()\n{\n\tcout << \"这是子类的析构函数\" << endl;\n}\n\nvoid objplay()\n{\n\tChild c1();\n}\n\nint main()\n{\n\tobjplay();\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n```\n\n\n### （五）继承中的同名成员变量处理方法\n\n1、当子类成员变量与父类成员变量同名时\n\n2、子类依然从父类继承同名成员\n\n3、在子类中通过作用域分辨符::进行同名成员区分（**在派生类中使用基类的同名成员，显式地使用类名限定符**）\n\n4、同名成员存储在内存中的不同位置\n\n![7]($resource/7.png)\n![8]($resource/8.png)\n\n总结：同名成员变量和成员函数通过作用域分辨符进行区分\n\n### （六）派生类中的static关键字\n\n继承和static关键字在一起会产生什么现象哪？\n\n理论知识\n\nØ 基类定义的静态成员，将被所有派生类共享\n\nØ 根据静态成员自身的访问特性和派生类的继承方式，在类层次体系中具有不同的访问性质  （遵守派生类的访问控制）\n\nØ  派生类中访问静态成员，用以下形式显式说明：\n\n_类名_ :: _成员_\n\n  或通过对象访问  _对象名_ . _成员_\n\n![aa]($resource/aa.png)\n![bb]($resource/bb.png)\n![cc]($resource/cc.png)\n\n总结：\n\n1> static函数也遵守3个访问原则\n\n2> static易犯错误（不但要初始化，更重要的显示的告诉编译器分配内存）\n\n3> 构造函数默认为private\n",[[1544070257856,["gjx16@GJXAIOU",[[1,7853,"\n"]],[7852,7852],[7853,7853]]],[1544070258002,["gjx16@GJXAIOU",[[1,7854,"\n"]],[7853,7853],[7854,7854]]],[1544070258118,["gjx16@GJXAIOU",[[1,7855,"\n"]],[7854,7854],[7855,7855]]],[1544070277671,["gjx16@GJXAIOU",[[1,10603,"\n"]],[10602,10602],[10603,10603]]],[1544070277867,["gjx16@GJXAIOU",[[1,10604,"\n"]],[10603,10603],[10604,10604]]],[1544070277986,["gjx16@GJXAIOU",[[1,10605,"\n"]],[10604,10604],[10605,10605]]],[1544070278108,["gjx16@GJXAIOU",[[1,10606,"\n"]],[10605,10605],[10606,10606]]],[1544070278360,["gjx16@GJXAIOU",[[1,10607,"\n"]],[10606,10606],[10607,10607]]],[1544070281379,["gjx16@GJXAIOU",[[-1,10607,"\n"]],[10605,10605],[10604,10604]]],[1544076910491,["gjx16@GJXAIOU",[[1,10575,"\n"]],[10574,10574],[10575,10575]]],[1544076913758,["gjx16@GJXAIOU",[[1,10575,"```"]],[10575,10575],[10578,10578]]],[1544076913798,["gjx16@GJXAIOU",[[1,10578,"language\n```\n"]],[10578,10578],[10578,10586]]],[1544076915165,["gjx16@GJXAIOU",[[-1,10578,"language"],[1,10586,"c"]],[10578,10586],[10579,10579]]],[1544076915507,["gjx16@GJXAIOU",[[1,10579,"pp"]],[10579,10579],[10581,10581]]],[1544076915905,["gjx16@GJXAIOU",[[1,10582,"\n"]],[10581,10581],[10582,10582]]],[1544076917216,["gjx16@GJXAIOU",[[1,10582,"//继承中的同名成员变量和成员函数处理方法\n\n#include \"iostream\"\nusing namespace std;\n\nclass Object\n{\npublic:\n\tvoid GetObject();\n\tint a;\n\tint b;\n\tvoid Printla();\n};\n\n\nvoid Object::GetObject()\n{\n\tcout << \"b \" << b << endl;\n}\n\nvoid Object::Printla()\n{\n\tcout << \"这是父类的成员函数\" << endl;\n}\n\n\nclass Parent :public Object\n{\npublic:\n\tvoid GetParent();\n\tint b;\n\tint c;\n\tvoid Printla();\n};\n\n\nvoid Parent::GetParent()\n{\n\tcout << \"b \" << b << endl;\n\tcout << \"c \" << c << endl;\n}\n\nvoid Parent::Printla()\n{\n\tcout << \"这是子类的成员函数\" << endl;\n}\n\n\nint main()\n{\n\tParent p1;\n\n\t//成员变量的调用比较\n\t//默认是调用子类的成员变量；\n\t//以下的两个语句等价\n\tp1.b = 2;\n\tp1.Parent::b = 2;\n\t//调用父类中的成员变量\n\tp1.Object::b = 3;\n\tp1.GetObject();\n\tp1.GetParent();\n\n\n\t//成员函数的调用比较\n\tp1.Printla();\n\tp1.Parent::Printla();//以上这两句等价，默认调用的也是子类的成员函数\n\tp1.Object::Printla();  //调用父类的成员函数\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n"]],[10582,10582],[11396,11396]]],[1544077773480,["gjx16@GJXAIOU",[[1,11792,"\n"]],[11791,11791],[11792,11792]]],[1544077776967,["gjx16@GJXAIOU",[[-1,11792,"\n"],[1,11793,"`"]],[11792,11792],[11793,11793]]],[1544077777336,["gjx16@GJXAIOU",[[1,11793,"``"]],[11793,11793],[11795,11795]]],[1544077777375,["gjx16@GJXAIOU",[[1,11795,"language\n```\n"]],[11795,11795],[11795,11803]]],[1544077779215,["gjx16@GJXAIOU",[[-1,11795,"language"],[1,11803,"c"]],[11795,11803],[11796,11796]]],[1544077779535,["gjx16@GJXAIOU",[[1,11796,"pp"]],[11796,11796],[11798,11798]]],[1544077780024,["gjx16@GJXAIOU",[[1,11799,"\n"]],[11798,11798],[11799,11799]]],[1544077781887,["gjx16@GJXAIOU",[[1,11799,"//继承中的static关键字\n\n#include \"iostream\"\nusing namespace std;\n\nclass Object\n{\npublic:\n\t static int a;\n};\n\nint Object::a = 2;  //static关键字必须初始化，更重的是C++编译器会根据初始化进行内存分配\n\nclass Parent :public Object\n{\npublic:\n\tint b;\n\tint c;\n};\n\n\nint main()\n{\n\tParent p1;\n\tp1.a = 3;\n\tsystem(\"pause\");\n\treturn 0;\n}"]],[11799,11799],[12087,12087]]],[1544077786667,["gjx16@GJXAIOU",[[1,12092,"\n"]],[12091,12091],[12092,12092]]],[1544077786837,["gjx16@GJXAIOU",[[1,12093,"\n"]],[12092,12092],[12093,12093]]],[1544077837579,["gjx16@GJXAIOU",[[1,12094,"\n"]],[12091,12091],[12092,12092]]],[1544077837775,["gjx16@GJXAIOU",[[1,12095,"\n"]],[12092,12092],[12093,12093]]],[1544077839409,["gjx16@GJXAIOU",[[1,12093,"**3.4****多继承**\n\n**3.4.1****多继承的应用**\n\n**多继承概念**\n\nØ   一个类有多个直接基类的继承关系称为多继承\n\nØ   多继承声明语法\n\nclass _派生类名_ : _访问控制_ _基类名1_ , _访问控制_ _基类名2_ , … , _访问控制_ _基类名n_\n\n {\n\n  _数据成员和成员函数声明_\n\n }；\n\nØ   类 C 可以根据访问控制同时继承类 A 和类 B 的成员，并添加\n\n  自己的成员\n\n**多继承的派生类构造和访问**\n\nØ 多个基类的派生类构造函数可以用初始式调用基类构造函数初始化数据成员\n\nØ 执行顺序与单继承构造函数情况类似。多个直接基类构造函数执行顺序取决于定义派生类时指定的各个继承基类的顺序。\n\nØ  一个派生类对象拥有多个直接或间接基类的成员。不同名成员访问不会出现二义性。如果不同的基类有同名成员，派生类对象访问时应该加以识别。\n\n**多继承简单应用**\n\n**3.4.2****虚继承**\n\n  如果一个派生类从多个基类派生，而这些基类又有一个共同的基类，则在对该基类中声明的名字进行访问时，可能产生二义性\n\n分析：\n\n**总结：**\n\nØ   如果一个派生类从多个基类派生，而这些基类又有一个共同\n\n  的基类，则在对该基类中声明的名字进行访问时，可能产生\n\n  二义性\n\nØ   如果在多条继承路径上有一个公共的基类，那么在继承路径的某处\n\n  汇合点，这个公共基类就会在派生类的对象中产生多个基类子对象\n\nØ   要使这个公共基类在派生类中只产生一个子对象，必须对这个基类\n\n  声明为虚继承，使这个基类成为虚基类。\n\nØ   虚继承声明使用关键字 virtual\n\n实验：注意增加virtual关键字后，构造函数调用的次数。\n\n**3.5****继承总结**\n\nØ 继承是面向对象程序设计实现软件重用的重要方法。程序员可以在已有基类的基础上定义新的派生类。\n\nØ  单继承的派生类只有一个基类。多继承的派生类有多个基类。\n\nØ  派生类对基类成员的访问由继承方式和成员性质决定。\n\nØ  创建派生类对象时，先调用基类构造函数初始化派生类中的基类成员。调用析构函数的次序和调用构造函数的次序相反。\n\nØ  C++提供虚继承机制，防止类继承关系中成员访问的二义性。\n\nØ  多继承提供了软件重用的强大功能，也增加了程序的复杂性。"]],[12093,12093],[13102,13102]]],[1544079633115,["gjx16@GJXAIOU",[[-1,12093,"**3.4****"]],[12102,12102],[12093,12093]]],[1544079636766,["gjx16@GJXAIOU",[[-1,12096,"**"]],[12098,12098],[12096,12096]]],[1544079645008,["gjx16@GJXAIOU",[[-1,12093,""],[1,12093,"#"],[-1,12132,"  "],[1,12134,"  "],[-1,12158,"  "],[1,12160,"  "],[-1,12263,"  "],[1,12265,"  "],[-1,12422," "],[1,12423," "],[-1,12596,"  "],[1,12598,"  "],[-1,12665,"  "],[1,12667,"  "],[-1,12733,"  "],[1,12735,"  "],[-1,12790,"  "],[1,12792,"  "],[-1,12911," "],[1,12912," "],[-1,12943," "],[1,12944," "],[-1,12972," "],[1,12973," "],[-1,13030," "],[1,13031," "],[-1,13063," "],[1,13064," "]],[12093,12093],[12094,12094]]],[1544079647408,["gjx16@GJXAIOU",[[1,12094,"# si"]],[12094,12094],[12098,12098]]],[1544079666162,["gjx16@GJXAIOU",[[-1,12096,"si"]],[12098,12098],[12096,12096]]],[1544079666320,["gjx16@GJXAIOU",[[1,12096,"s"]],[12096,12096],[12097,12097]]],[1544079666811,["gjx16@GJXAIOU",[[-1,12096,"s"]],[12097,12097],[12096,12096]]],[1544079669169,["gjx16@GJXAIOU",[[1,12096,"四、"]],[12096,12096],[12098,12098]]],[1544079686421,["gjx16@GJXAIOU",[[-1,12112,"**"]],[12114,12114],[12112,12112]]],[1544079690473,["gjx16@GJXAIOU",[[-1,12103,"**3.4.1**"]],[12112,12112],[12103,12103]]],[1544079692915,["gjx16@GJXAIOU",[[1,12103,"3#"]],[12103,12103],[12105,12105]]],[1544079694042,["gjx16@GJXAIOU",[[-1,12103,"3#"]],[12105,12105],[12103,12103]]],[1544079696298,["gjx16@GJXAIOU",[[1,12103,"@@"]],[12103,12103],[12105,12105]]],[1544079697307,["gjx16@GJXAIOU",[[-1,12103,"@@"]],[12105,12105],[12103,12103]]],[1544079701666,["gjx16@GJXAIOU",[[1,12103,"### （）"]],[12103,12103],[12109,12109]]],[1544079703706,["gjx16@GJXAIOU",[[1,12108,"一"]],[12108,12108],[12109,12109]]],[1544079706835,["gjx16@GJXAIOU",[[-1,12116,"**"]],[12118,12118],[12116,12116]]],[1544079707077,["gjx16@GJXAIOU",[[1,12116,"="]],[12116,12116],[12117,12117]]],[1544079708370,["gjx16@GJXAIOU",[[-1,12116,"="]],[12117,12117],[12116,12116]]],[1544079713568,["gjx16@GJXAIOU",[[1,12120,"1."]],[12120,12120],[12122,12122]]],[1544079716676,["gjx16@GJXAIOU",[[-1,12133,"  "]],[12135,12135],[12133,12133]]],[1544079729683,["gjx16@GJXAIOU",[[1,12307,"\n"]],[12306,12306],[12307,12307]]],[1544079742599,["gjx16@GJXAIOU",[[1,12307,"![9]($resource/9.png)"]],[12307,12307],[12329,12329]]],[1544079753259,["gjx16@GJXAIOU",[[1,12332,"2."]],[12332,12332],[12334,12334]]],[1544079760576,["gjx16@GJXAIOU",[[1,12516,"3."]],[12516,12516],[12518,12518]]],[1544079764216,["gjx16@GJXAIOU",[[-1,12529,"**3.4.2****"],[1,12540,"#"]],[12529,12529],[12530,12530]]],[1544079766468,["gjx16@GJXAIOU",[[1,12530,"## （）"]],[12530,12530],[12535,12535]]],[1544079768199,["gjx16@GJXAIOU",[[1,12534,"二"]],[12534,12534],[12535,12535]]],[1544079770614,["gjx16@GJXAIOU",[[-1,12539,"**"]],[12541,12541],[12539,12539]]],[1544079786026,["gjx16@GJXAIOU",[[1,12529,"\n"]],[12528,12528],[12529,12529]]],[1544079786190,["gjx16@GJXAIOU",[[1,12530,"\n"]],[12529,12529],[12530,12530]]],[1544079788088,["gjx16@GJXAIOU",[[1,12531,"\n"]],[12529,12529],[12530,12530]]],[1544079788282,["gjx16@GJXAIOU",[[1,12532,"\n"]],[12530,12530],[12531,12531]]],[1544079788507,["gjx16@GJXAIOU",[[1,12533,"\n"]],[12531,12531],[12532,12532]]],[1544079866628,[null,[[1,12329,"\n"],[-1,12331,"多"],[1,12334,"多"],[-1,12515,"多"],[1,12518,"多"],[-1,12528,"*"],[1,12541,"虚"],[-1,12543,"*"],[1,12544,"\n"]],[12329,12329],[12545,12545]]],[1544079866628,[null,[[-1,12329,"\n"],[1,12332,"多"],[-1,12334,"多"],[1,12516,"多"],[-1,12518,"多"],[1,12529,"*"],[-1,12541,"虚"],[1,12544,"*"],[-1,12544,"\n"]],[12545,12545],[12329,12329]]],[1544079807845,["gjx16@GJXAIOU",[[1,12530,"![10]($resource/10.png)\n![11]($resource/11.png)"]],[12530,12530],[12578,12578]]],[1544079816549,["gjx16@GJXAIOU",[[1,12652,"\n"]],[12651,12651],[12652,12652]]],[1544079816725,["gjx16@GJXAIOU",[[1,12653,"\n"]],[12652,12652],[12653,12653]]],[1544079816888,["gjx16@GJXAIOU",[[1,12654,"\n"]],[12653,12653],[12654,12654]]],[1544079825732,["gjx16@GJXAIOU",[[1,12652,"![12]($resource/12.png)"]],[12652,12652],[12676,12676]]],[1544079830340,["gjx16@GJXAIOU",[[1,12683,"\n"]],[12682,12682],[12683,12683]]],[1544079830476,["gjx16@GJXAIOU",[[1,12684,"\n"]],[12683,12683],[12684,12684]]],[1544079842717,["gjx16@GJXAIOU",[[1,12683,"![13]($resource/13.png)"]],[12683,12683],[12707,12707]]],[1544079854093,["gjx16@GJXAIOU",[[1,12935,"\n"]],[12934,12934],[12935,12935]]],[1544079854251,["gjx16@GJXAIOU",[[1,12936,"\n"]],[12935,12935],[12936,12936]]],[1544079854407,["gjx16@GJXAIOU",[[1,12937,"\n"]],[12936,12936],[12937,12937]]],[1544079926628,[null,[[1,12329,"\n"],[-1,12331,"多"],[1,12334,"多"],[-1,12515,"多"],[1,12518,"多"],[-1,12528,"*"],[1,12588,"虚"],[-1,12590,"*"],[1,12591,"\n"],[-1,12651,"分"],[1,12678,"分"],[-1,12682,"*"],[1,12708,"*"],[-1,12934,"实"],[1,12935,""],[1,12938,"实"]],[12329,12329],[12939,12939]]],[1544079926628,[null,[[-1,12329,"\n"],[1,12332,"多"],[-1,12334,"多"],[1,12516,"多"],[-1,12518,"多"],[1,12529,"*"],[-1,12588,"虚"],[1,12591,"*"],[-1,12591,"\n"],[1,12652,"分"],[-1,12678,"分"],[1,12683,"*"],[-1,12708,"*"],[1,12935,"实"],[-1,12935,""],[-1,12938,"实"]],[12939,12939],[12329,12329]]],[1544079868191,["gjx16@GJXAIOU",[[1,12935,"![14]($resource/14.png)"]],[12935,12935],[12959,12959]]],[1544079871173,["gjx16@GJXAIOU",[[1,12935,"\n"]],[12934,12934],[12935,12935]]],[1544079879152,["gjx16@GJXAIOU",[[-1,12993,"**3.5****"],[1,13002,"#"]],[12993,12993],[12994,12994]]],[1544079883771,["gjx16@GJXAIOU",[[1,12994,"# 五。"]],[12994,12994],[12998,12998]]],[1544079884354,["gjx16@GJXAIOU",[[-1,12997,"。"]],[12998,12998],[12997,12997]]],[1544079884636,["gjx16@GJXAIOU",[[1,12997,"、"]],[12997,12997],[12998,12998]]],[1544079886814,["gjx16@GJXAIOU",[[-1,13002,"**"]],[13004,13004],[13002,13002]]],[1544079900731,["gjx16@GJXAIOU",[[1,12093,"\n"]],[12092,12092],[12093,12093]]],[1544079900900,["gjx16@GJXAIOU",[[1,12094,"\n"]],[12093,12093],[12094,12094]]],[1544081368472,[null,[[1,12331,"\n"],[-1,12333,"多"],[1,12336,"多"],[-1,12517,"多"],[1,12520,"多"],[-1,12530,"*"],[1,12590,"虚"],[-1,12592,"*"],[1,12593,"\n"],[-1,12653,"分"],[1,12680,"分"],[-1,12684,"*"],[1,12710,"*"],[-1,12936,"实"],[1,12937,""],[1,12964,"实"],[-1,12994,"*"],[1,13000,"继"],[-1,13003,"*"],[1,13004,"\n"]],[12331,12331],[13005,13005]]],[1544081368472,[null,[[-1,12331,"\n"],[1,12334,"多"],[-1,12336,"多"],[1,12518,"多"],[-1,12520,"多"],[1,12531,"*"],[-1,12590,"虚"],[1,12593,"*"],[-1,12593,"\n"],[1,12654,"分"],[-1,12680,"分"],[1,12685,"*"],[-1,12710,"*"],[1,12937,"实"],[-1,12937,""],[-1,12964,"实"],[1,12995,"*"],[-1,13000,"继"],[1,13004,"*"],[-1,13004,"\n"]],[13005,13005],[12331,12331]]],[1544081352544,["gjx16@GJXAIOU",[[1,12580,"··"]],[12580,12580],[12582,12582]]],[1544081353642,["gjx16@GJXAIOU",[[-1,12580,"··"]],[12582,12582],[12580,12580]]],[1544081354994,["gjx16@GJXAIOU",[[1,12580,"```"]],[12580,12580],[12583,12583]]],[1544081355105,["gjx16@GJXAIOU",[[1,12583,"language\n```\n"]],[12583,12583],[12583,12591]]],[1544081356534,["gjx16@GJXAIOU",[[-1,12583,"language"],[1,12591,"c"]],[12583,12591],[12584,12584]]],[1544081356842,["gjx16@GJXAIOU",[[1,12584,"pp"]],[12584,12584],[12586,12586]]],[1544081357854,["gjx16@GJXAIOU",[[1,12587,"\n"]],[12586,12586],[12587,12587]]],[1544081358608,["gjx16@GJXAIOU",[[1,12587,"//多继承\n\n#include \"iostream\"\nusing namespace std;\n\nclass Object1\n{\npublic:\n\tObject1(int a);\n\t int a;\n};\n\nObject1::Object1(int a)\n{\n\tthis->a = a;\n\tcout << \"这是Object1的构造函数\" << endl;\n}\n\n\nclass Object2\n{\npublic:\n\tObject2(int b);\n\t int b;\n};\n\nObject2::Object2(int b)\n{\n\tthis->b = b;\n\tcout << \"这是Object2的构造函数\" << endl;\n}\n\n\nclass Parent :public Object1,Object2\n{\npublic:\n\tParent(int a, int b, int c);\n\tint c;\n};\n\nParent::Parent(int a, int b, int c) : Object1(a), Object2(b)\n//Parent::Parent(int c) : Object1(1), Object2(2)  //这种相当于将后两个的初始化写死了\n{\n\tthis->c = c;\n}\n\n\nint main()\n{\n\tParent p1(1,2,3);\n\n\tsystem(\"pause\");\n\treturn 0;\n}"]],[12587,12587],[13204,13204]]],[1544082808487,[null,[[1,12331,"\n"],[-1,12333,"多"],[1,12336,"多"],[-1,12517,"多"],[1,12520,"多"],[-1,12530,"*"],[1,13219,"虚"],[-1,13221,"*"],[1,13222,"\n"],[-1,13282,"分"],[1,13309,"分"],[-1,13313,"*"],[1,13339,"*"],[-1,13565,"实"],[1,13593,"实"],[-1,13623,"*"],[1,13629,"继"],[-1,13632,"*"],[1,13633,"\n"]],[12331,12331],[13634,13634]]],[1544082808487,[null,[[-1,12331,"\n"],[1,12334,"多"],[-1,12336,"多"],[1,12518,"多"],[-1,12520,"多"],[1,12531,"*"],[-1,13219,"虚"],[1,13222,"*"],[-1,13222,"\n"],[1,13283,"分"],[-1,13309,"分"],[1,13314,"*"],[-1,13339,"*"],[1,13566,"实"],[-1,13593,"实"],[1,13624,"*"],[-1,13629,"继"],[1,13633,"*"],[-1,13633,"\n"]],[13634,13634],[12331,12331]]],[1544082794124,["gjx16@GJXAIOU",[[1,13591,"·"]],[13591,13591],[13592,13592]]],[1544082795125,["gjx16@GJXAIOU",[[-1,13591,"·"]],[13592,13592],[13591,13591]]],[1544082796015,["gjx16@GJXAIOU",[[1,13591,"```"]],[13591,13591],[13594,13594]]],[1544082796103,["gjx16@GJXAIOU",[[1,13594,"language\n```\n"]],[13594,13594],[13594,13602]]],[1544082797314,["gjx16@GJXAIOU",[[-1,13594,"language"],[1,13602,"c"]],[13594,13602],[13595,13595]]],[1544082797634,["gjx16@GJXAIOU",[[1,13595,"pp"]],[13595,13595],[13597,13597]]],[1544082797984,["gjx16@GJXAIOU",[[1,13598,"\n"]],[13597,13597],[13598,13598]]],[1544082798158,["gjx16@GJXAIOU",[[1,13598,"'"]],[13598,13598],[13599,13599]]],[1544082799293,["gjx16@GJXAIOU",[[-1,13598,"'"]],[13599,13599],[13598,13598]]],[1544082799816,["gjx16@GJXAIOU",[[1,13598,"//虚继承（继承的二义性）\n\n#include \"iostream\"\nusing namespace std;\n\nclass Object\n{\npublic:\n\tint obj;\n};\n\n\nclass Object1:virtual public Object  //使用virtual使其形成虚继承，从而可以在Parent类中直接使用Object类中的成员变量\n{\npublic:\n\t int obj1;\n};\n\nclass Object2 : virtual public Object\n{\npublic:\n\t int obj2;\n};\n\n//class Parent :public Object1,Object2//这样继承Object2为private\nclass Parent :public Object1, public Object2\n{\npublic:\n\tint c;\n};\n\n\nint main()\n{\n\tParent p1;\n\tp1.obj = 1;\n\tp1.obj1 = 2;\n\tp1.obj2 = 3;\n\n\n\tsystem(\"pause\");\n\treturn 0;\n}"]],[13598,13598],[14096,14096]]],[1544093466188,[null,[[1,12331,"\n"],[-1,12333,"多"],[1,12336,"多"],[-1,12517,"多"],[1,12520,"多"],[-1,12530,"*"],[1,13219,"虚"],[-1,13221,"*"],[1,13222,"\n"],[-1,13282,"分"],[1,13309,"分"],[-1,13313,"*"],[1,13339,"*"],[-1,13565,"实"],[1,13566,""],[1,14103,"实"],[-1,14133,"*"],[1,14139,"继"],[-1,14142,"*"],[1,14143,"\n"]],[12331,12331],[14144,14144]]],[1544093466188,[null,[[-1,12331,"\n"],[1,12334,"多"],[-1,12336,"多"],[1,12518,"多"],[-1,12520,"多"],[1,12531,"*"],[-1,13219,"虚"],[1,13222,"*"],[-1,13222,"\n"],[1,13283,"分"],[-1,13309,"分"],[1,13314,"*"],[-1,13339,"*"],[1,13566,"实"],[-1,13566,""],[-1,14103,"实"],[1,14134,"*"],[-1,14139,"继"],[1,14143,"*"],[-1,14143,"\n"]],[14144,14144],[12331,12331]]],[1544093454250,["gjx16@GJXAIOU",[[1,14378,"![派生类的访问控制]($resource/%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6.png)\n"]],[14378,14378],[14478,14478]]],[1544094186207,[null,[[1,12331,"\n"],[-1,12333,"多"],[1,12336,"多"],[-1,12517,"多"],[1,12520,"多"],[-1,12530,"*"],[1,13219,"虚"],[-1,13221,"*"],[1,13222,"\n"],[-1,13282,"分"],[1,13309,"分"],[-1,13313,"*"],[1,13339,"*"],[-1,13565,"实"],[1,13566,""],[1,14103,"实"],[-1,14133,"*"],[1,14139,"继"],[-1,14142,"*"],[1,14143,"\n"],[-1,14377,"\n"],[1,14478,"\n"]],[12331,12331],[14479,14479]]],[1544094186207,[null,[[-1,12331,"\n"],[1,12334,"多"],[-1,12336,"多"],[1,12518,"多"],[-1,12520,"多"],[1,12531,"*"],[-1,13219,"虚"],[1,13222,"*"],[-1,13222,"\n"],[1,13283,"分"],[-1,13309,"分"],[1,13314,"*"],[-1,13339,"*"],[1,13566,"实"],[-1,13566,""],[-1,14103,"实"],[1,14134,"*"],[-1,14139,"继"],[1,14143,"*"],[-1,14143,"\n"],[1,14378,"\n"],[-1,14478,"\n"]],[14479,14479],[12331,12331]]],[1544094161181,["gjx16@GJXAIOU",[[1,13611,"这能"]],[13611,13611],[13613,13613]]],[1544094162122,["gjx16@GJXAIOU",[[-1,13611,"这能"]],[13613,13613],[13611,13611]]],[1544094176926,["gjx16@GJXAIOU",[[1,13611,"只能解决有共同老祖宗的场景"]],[13611,13611],[13624,13624]]],[1544095026263,[null,[[1,12331,"\n"],[-1,12333,"多"],[1,12336,"多"],[-1,12517,"多"],[1,12520,"多"],[-1,12530,"*"],[1,13219,"虚"],[-1,13221,"*"],[1,13222,"\n"],[-1,13282,"分"],[1,13309,"分"],[-1,13313,"*"],[1,13339,"*"],[-1,13565,"实"],[1,13566,""],[1,14116,"实"],[-1,14146,"*"],[1,14152,"继"],[-1,14155,"*"],[1,14156,"\n"],[-1,14390,"\n"],[1,14491,"\n"]],[12331,12331],[14492,14492]]],[1544095026263,[null,[[-1,12331,"\n"],[1,12334,"多"],[-1,12336,"多"],[1,12518,"多"],[-1,12520,"多"],[1,12531,"*"],[-1,13219,"虚"],[1,13222,"*"],[-1,13222,"\n"],[1,13283,"分"],[-1,13309,"分"],[1,13314,"*"],[-1,13339,"*"],[1,13566,"实"],[-1,13566,""],[-1,14116,"实"],[1,14147,"*"],[-1,14152,"继"],[1,14156,"*"],[-1,14156,"\n"],[1,14391,"\n"],[-1,14491,"\n"]],[14492,14492],[12331,12331]]],[1544095012439,["gjx16@GJXAIOU",[[1,14115,"··"]],[14115,14115],[14117,14117]]],[1544095013436,["gjx16@GJXAIOU",[[-1,14115,"··"]],[14117,14117],[14115,14115]]],[1544095014579,["gjx16@GJXAIOU",[[1,14115,"```"]],[14115,14115],[14118,14118]]],[1544095014637,["gjx16@GJXAIOU",[[1,14118,"language\n```\n"]],[14118,14118],[14118,14126]]],[1544095015743,["gjx16@GJXAIOU",[[-1,14118,"language"],[1,14126,"c"]],[14118,14126],[14119,14119]]],[1544095016135,["gjx16@GJXAIOU",[[1,14119,"pp"]],[14119,14119],[14121,14121]]],[1544095017283,["gjx16@GJXAIOU",[[1,14122,"\n"]],[14121,14121],[14122,14122]]],[1544095017977,["gjx16@GJXAIOU",[[1,14122,"//虚继承不是万能的，当继承两个相互独立的类的时候，virsual 关键字并不能解决成员变量相同的问题\n#include \"iostream\"\nusing namespace std;\n\nclass Parent1\n{\npublic:\n\tint a;\n};\n\n\n\nclass Parent2\n{\npublic:\n\tint a;\n};\n\nclass Child :virtual public Parent1,virtual public Parent2\n{\npublic:\n\tint b;\n};\n\nint main()\n{\n\tChild c1;\n\t//c1.a = 1;    //即使加上virtual关键字之后仍然不能直接使用\n\tc1.Parent1::a = 4;  //只能这样使用\n\tc1.b = 2;\n}"]],[14122,14122],[14480,14480]]],[1544095023667,["gjx16@GJXAIOU",[[1,14516,"zen"]],[14516,14516],[14519,14519]]],[1544095024323,["gjx16@GJXAIOU",[[-1,14516,"zen"]],[14519,14519],[14516,14516]]],[1544095025983,["gjx16@GJXAIOU",[[1,14516,"- "]],[14516,14516],[14518,14518]]],[1544095086253,[null,[[1,12331,"\n"],[-1,12333,"多"],[1,12336,"多"],[-1,12517,"多"],[1,12520,"多"],[-1,12530,"*"],[1,13219,"虚"],[-1,13221,"*"],[1,13222,"\n"],[-1,13282,"分"],[1,13309,"分"],[-1,13313,"*"],[1,13339,"*"],[-1,13565,"实"],[1,13566,""],[1,14486,"实"],[-1,14515,"\n"],[-1,14518,"*"],[1,14519,"\n"],[1,14524,"继"],[-1,14527,"*"],[1,14528,"\n"],[-1,14762,"\n"],[1,14863,"\n"]],[12331,12331],[14864,14864]]],[1544095086253,[null,[[-1,12331,"\n"],[1,12334,"多"],[-1,12336,"多"],[1,12518,"多"],[-1,12520,"多"],[1,12531,"*"],[-1,13219,"虚"],[1,13222,"*"],[-1,13222,"\n"],[1,13283,"分"],[-1,13309,"分"],[1,13314,"*"],[-1,13339,"*"],[1,13566,"实"],[-1,13566,""],[-1,14486,"实"],[1,14516,"\n"],[1,14518,"*"],[-1,14518,"\n"],[-1,14524,"继"],[1,14528,"*"],[-1,14528,"\n"],[1,14763,"\n"],[-1,14863,"\n"]],[14864,14864],[12331,12331]]],[1544095037346,["gjx16@GJXAIOU",[[1,14518,"增加virtual关键字之后"]],[14518,14518],[14532,14532]]],[1544095146253,[null,[[1,12331,"\n"],[-1,12333,"多"],[1,12336,"多"],[-1,12517,"多"],[1,12520,"多"],[-1,12530,"*"],[1,13219,"虚"],[-1,13221,"*"],[1,13222,"\n"],[-1,13282,"分"],[1,13309,"分"],[-1,13313,"*"],[1,13339,"*"],[-1,13565,"实"],[1,13566,""],[1,14486,"实"],[-1,14515,"\n"],[-1,14532,"*"],[1,14533,"\n"],[1,14538,"继"],[-1,14541,"*"],[1,14542,"\n"],[-1,14776,"\n"],[1,14877,"\n"]],[12331,12331],[14878,14878]]],[1544095146253,[null,[[-1,12331,"\n"],[1,12334,"多"],[-1,12336,"多"],[1,12518,"多"],[-1,12520,"多"],[1,12531,"*"],[-1,13219,"虚"],[1,13222,"*"],[-1,13222,"\n"],[1,13283,"分"],[-1,13309,"分"],[1,13314,"*"],[-1,13339,"*"],[1,13566,"实"],[-1,13566,""],[-1,14486,"实"],[1,14516,"\n"],[1,14532,"*"],[-1,14532,"\n"],[-1,14538,"继"],[1,14542,"*"],[-1,14542,"\n"],[1,14777,"\n"],[-1,14877,"\n"]],[14878,14878],[12331,12331]]],[1544095094137,["gjx16@GJXAIOU",[[1,14532,"，构造函数值"]],[14532,14532],[14538,14538]]],[1544095094734,["gjx16@GJXAIOU",[[-1,14537,"值"]],[14538,14538],[14537,14537]]],[1544095100465,["gjx16@GJXAIOU",[[1,14537,"只调用一次"]],[14537,14537],[14542,14542]]],[1544095101165,["gjx16@GJXAIOU",[[1,14543,"- \n"]],[14542,14542],[14545,14545]]],[1544095103447,["gjx16@GJXAIOU",[[-1,14543,"- "]],[14545,14545],[14543,14543]]],[1544095106841,["gjx16@GJXAIOU",[[1,14544,"\n"]],[14543,14543],[14544,14544]]],[1544095110433,["gjx16@GJXAIOU",[[1,14544,"构造"]],[14544,14544],[14546,14546]]],[1544095111100,["gjx16@GJXAIOU",[[-1,14544,"构造"]],[14546,14546],[14544,14544]]],[1544095126391,["gjx16@GJXAIOU",[[1,14544,"使用virtual之后每个类的大小也会发生变化"]],[14544,14544],[14567,14567]]],[1544095126951,["gjx16@GJXAIOU",[[1,14568,"\n"]],[14567,14567],[14568,14568]]],[1544095432936,[null,[[1,12331,"\n"],[-1,12333,"多"],[1,12336,"多"],[-1,12517,"多"],[1,12520,"多"],[-1,12530,"*"],[1,13219,"虚"],[-1,13221,"*"],[1,13222,"\n"],[-1,13282,"分"],[1,13309,"分"],[-1,13313,"*"],[1,13339,"*"],[-1,13565,"实"],[1,13566,""],[1,14486,"实"],[-1,14515,"\n"],[-1,14542,"*"],[1,14543,"\n"],[1,14574,"继"],[-1,14577,"*"],[1,14578,"\n"],[-1,14812,"\n"],[1,14913,"\n"]],[12331,12331],[14914,14914]]],[1544095432936,[null,[[-1,12331,"\n"],[1,12334,"多"],[-1,12336,"多"],[1,12518,"多"],[-1,12520,"多"],[1,12531,"*"],[-1,13219,"虚"],[1,13222,"*"],[-1,13222,"\n"],[1,13283,"分"],[-1,13309,"分"],[1,13314,"*"],[-1,13339,"*"],[1,13566,"实"],[-1,13566,""],[-1,14486,"实"],[1,14516,"\n"],[1,14542,"*"],[-1,14542,"\n"],[-1,14574,"继"],[1,14578,"*"],[-1,14578,"\n"],[1,14813,"\n"],[-1,14913,"\n"]],[14914,14914],[12331,12331]]],[1544095426166,["gjx16@GJXAIOU",[[1,14568,"·"]],[14568,14568],[14569,14569]]],[1544095427089,["gjx16@GJXAIOU",[[-1,14568,"·"]],[14569,14569],[14568,14568]]],[1544095428397,["gjx16@GJXAIOU",[[1,14568,"```"]],[14568,14568],[14571,14571]]],[1544095428445,["gjx16@GJXAIOU",[[1,14571,"language\n```\n"]],[14571,14571],[14571,14579]]],[1544095429357,["gjx16@GJXAIOU",[[-1,14571,"language"],[1,14579,"c"]],[14571,14579],[14572,14572]]],[1544095429681,["gjx16@GJXAIOU",[[1,14572,"pp"]],[14572,14572],[14574,14574]]],[1544095430030,["gjx16@GJXAIOU",[[1,14575,"\n"]],[14574,14574],[14575,14575]]],[1544095431184,["gjx16@GJXAIOU",[[1,14575,"//使用virtual关键字，C++编译器会给变量偷偷的增加属性，使类的大小变大\n#include \"iostream\"\nusing namespace std;\n\nclass Parent\n{\npublic:\n\tint a;\n};\n\n\n\nclass Child1:virtual public Parent\n{\npublic:\n\tint b;\n};\n\nclass Child2:public Parent\n{\npublic:\n\tint b;\n};\n\nint main()\n{\n\tcout << sizeof(Parent) << endl;\n\tcout << sizeof(Child1) << endl;\n\tcout << sizeof(Child2) << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}"]],[14575,14575],[14943,14943]]]],null,"gjx16@GJXAIOU"]]}