{"compress":true,"commitItems":[["65b21e75-5a78-4939-bca7-26d19244549c",1541124130020,"",[[1541124085550,["gjx16@GJXAIOU",[[1,0,"# day05 结构体\n\n\n\n"]],[0,0],[14,14]]]],null,"gjx16@GJXAIOU"],["13270cd3-b079-4ccb-9fa3-67feab1d6131",1541145787803,"# day05 结构体\n\n\n\n",[[1541145764035,["gjx16@GJXAIOU",[[-1,14,"\n"],[1,15,"#"]],[14,14],[15,15]]],[1541145764372,["gjx16@GJXAIOU",[[1,15,"##"]],[15,15],[17,17]]],[1541145765270,["gjx16@GJXAIOU",[[-1,16,"#"]],[17,17],[16,16]]],[1541145773652,["gjx16@GJXAIOU",[[1,16," 一、结构体的基础操作"]],[16,16],[27,27]]],[1541145774121,["gjx16@GJXAIOU",[[1,27,"\n\n"]],[27,27],[28,28]]],[1541145774632,["gjx16@GJXAIOU",[[-1,28,"\n"],[1,29,"】"]],[28,28],[29,29]]],[1541145774640,["gjx16@GJXAIOU",[[1,29,"\n\n"]],[29,29],[30,30]]],[1541145775719,["gjx16@GJXAIOU",[[-1,30,"\n"]],[30,30],[29,29]]],[1541145775854,["gjx16@GJXAIOU",[[-1,28,"】"]],[29,29],[28,28]]],[1541145776465,["gjx16@GJXAIOU",[[1,29,"\n"]],[28,28],[29,29]]],[1541145798146,["gjx16@GJXAIOU",[[-1,29,"\n"],[1,30,"-"]],[29,29],[30,30]]],[1541145829810,["gjx16@GJXAIOU",[[1,30," 结构体类型定义\n- 结构体变量定义\n- 结构体变量的初始化\n- 使用体验"]],[30,30],[67,67]]],[1541147564605,["gjx16@GJXAIOU",[[-1,65,"体验"]],[67,67],[65,65]]],[1541147568422,["gjx16@GJXAIOU",[[1,65,"typedef"]],[65,65],[72,72]]],[1541147757285,["gjx16@GJXAIOU",[[1,72,"gai"]],[72,72],[75,75]]],[1541147758355,["gjx16@GJXAIOU",[[-1,72,"gai"]],[75,75],[72,72]]],[1541147770196,["gjx16@GJXAIOU",[[1,72,"该类型名\n- 点运算符和市政法"]],[72,72],[87,87]]],[1541147770924,["gjx16@GJXAIOU",[[-1,84,"市政法"]],[87,87],[84,84]]],[1541147783530,["gjx16@GJXAIOU",[[1,84,"指针法操作结构体\n- 结构体也是一种"]],[84,84],[102,102]]],[1541147797700,["gjx16@GJXAIOU",[[1,102,"数据类型，复合类型，自定义类型\n- "]],[102,102],[120,120]]],[1541147798510,["gjx16@GJXAIOU",[[-1,119," "]],[120,120],[119,119]]],[1541147799356,["gjx16@GJXAIOU",[[-1,118,"-"],[1,119,"\n"]],[119,119],[118,118]]],[1541147799996,["gjx16@GJXAIOU",[[1,119,"\n"]],[118,118],[119,119]]]],null,"gjx16@GJXAIOU"],["7b64cb2d-d791-4582-a54c-0b582a0bc589",1541597680917,"# day05 结构体\n\n\n## 一、结构体的基础操作\n\n- 结构体类型定义\n- 结构体变量定义\n- 结构体变量的初始化\n- 使用typedef该类型名\n- 点运算符和指针法操作结构体\n- 结构体也是一种数据类型，复合类型，自定义类型\n\n\n",[[1541597623925,["gjx16@GJXAIOU",[[1,41,"\n- "]],[38,38],[41,41]]],[1541597625587,["gjx16@GJXAIOU",[[-1,39,"- "]],[41,41],[39,39]]],[1541598106831,["gjx16@GJXAIOU",[[1,39,"···"]],[39,39],[42,42]]],[1541598108447,["gjx16@GJXAIOU",[[-1,39,"···"]],[42,42],[39,39]]],[1541598109533,["gjx16@GJXAIOU",[[1,39,"```"]],[39,39],[42,42]]],[1541598109556,["gjx16@GJXAIOU",[[1,42,"language\n```\n"]],[42,42],[42,50]]],[1541598110198,["gjx16@GJXAIOU",[[-1,42,"language"],[1,50,"p"]],[42,50],[43,43]]],[1541598111060,["gjx16@GJXAIOU",[[1,43,"ytho"]],[43,43],[47,47]]],[1541598112076,["gjx16@GJXAIOU",[[-1,42,"pytho"]],[47,47],[42,42]]],[1541598112404,["gjx16@GJXAIOU",[[1,42,"c"]],[42,42],[43,43]]],[1541598112822,["gjx16@GJXAIOU",[[1,44,"\n"]],[43,43],[44,44]]],[1541598114108,["gjx16@GJXAIOU",[[1,44,"int main()\n{\n\t//结构体类型的定义\n\t/*\n\t首先struct为关键字\n\tstruct Teacher 结合在一起才是类型\n\t{}后面有；\n\t\n\t*/\n\tstruct Teacher\n\t{\n\t\tchar name[50];\n\t\tint age;\n\n\n\t};\n\n\t//结构体变量的定义\n\t//第一种：先定义类型，在定义变量--最常用的方法\n\n\n\n\n\n\n\n\treturn 0;\n}"]],[44,44],[239,239]]],[1541598120212,["gjx16@GJXAIOU",[[-1,182,"//结构体变量的定义\t//第一种：先定义类型，在定义变量--最常用的方法\n"]],[192,219],[182,182]]],[1541598122532,["gjx16@GJXAIOU",[[-1,189,"\n"]],[189,189],[188,188]]],[1541598122668,["gjx16@GJXAIOU",[[-1,188,"\n"]],[188,188],[187,187]]],[1541598122791,["gjx16@GJXAIOU",[[-1,187,"\n"]],[187,187],[186,186]]],[1541598122915,["gjx16@GJXAIOU",[[-1,186,"\n"]],[186,186],[185,185]]],[1541598123056,["gjx16@GJXAIOU",[[-1,185,"\n"]],[185,185],[184,184]]],[1541598123188,["gjx16@GJXAIOU",[[-1,184,"\n"]],[184,184],[183,183]]],[1541598123676,["gjx16@GJXAIOU",[[-1,183,"\n"]],[183,183],[182,182]]],[1541598124215,["gjx16@GJXAIOU",[[-1,181,"\t"]],[182,182],[181,181]]],[1541598124383,["gjx16@GJXAIOU",[[-1,181,"\n"]],[181,181],[180,180]]],[1541598124495,["gjx16@GJXAIOU",[[-1,180,"\n"]],[180,180],[179,179]]],[1541598126388,["gjx16@GJXAIOU",[[-1,175,"\n"]],[175,175],[174,174]]],[1541598126806,["gjx16@GJXAIOU",[[-1,174,"\n"]],[174,174],[173,173]]],[1541598128528,["gjx16@GJXAIOU",[[1,179,"\n\t"]],[177,177],[179,179]]],[1541598131989,["gjx16@GJXAIOU",[[-1,121,"\t"]],[122,122],[121,121]]],[1541598133759,["gjx16@GJXAIOU",[[-1,121,"\n"]],[121,121],[120,120]]],[1541598135900,["gjx16@GJXAIOU",[[1,126,"\n\t"]],[124,124],[126,126]]],[1541598271087,["gjx16@GJXAIOU",[[1,210,"\n- "]],[207,207],[210,210]]],[1541598272275,["gjx16@GJXAIOU",[[-1,208,"- "]],[210,210],[208,208]]],[1541598274581,["gjx16@GJXAIOU",[[1,208,"```"]],[208,208],[211,211]]],[1541598274606,["gjx16@GJXAIOU",[[1,211,"language\n```\n"]],[211,211],[211,219]]],[1541598275840,["gjx16@GJXAIOU",[[-1,211,"language"],[1,219,"c"]],[211,219],[212,212]]],[1541598276059,["gjx16@GJXAIOU",[[1,213,"\n"]],[212,212],[213,213]]],[1541598277356,["gjx16@GJXAIOU",[[1,213,"#include<stdio.h>\n\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n};\n\n\n//结构体变量的定义\n//第一种：先定义类型，在定义变量--最常用的方法\nstruct Teacher t1;  //这里定义的就是全局变量\n\nint main()\n{\n\tstruct Teacher t2;//这里定义的就是局部变量\n\n\treturn 0;\n}"]],[213,213],[411,411]]],[1541598284622,["gjx16@GJXAIOU",[[-1,58,"//结构体类型的定义\n\t/*\n\t首先struct为关键字\n\tstruct Teacher 结合在一起才是类型\n\t{}后面有；\n\t*/\n\t\n\tstruct Teacher\n\t{\n\t\tchar name[50];\n\t\tint age;\n\t};"]],[58,177],[58,58]]],[1541598286792,["gjx16@GJXAIOU",[[1,44,"\n"]],[44,44],[45,45]]],[1541598287732,["gjx16@GJXAIOU",[[1,44,"//结构体类型的定义\n\t/*\n\t首先struct为关键字\n\tstruct Teacher 结合在一起才是类型\n\t{}后面有；\n\t*/\n\t\n\tstruct Teacher\n\t{\n\t\tchar name[50];\n\t\tint age;\n\t};"]],[44,44],[163,163]]],[1541598290171,["gjx16@GJXAIOU",[[1,164,"\t\n"]],[163,163],[165,165]]],[1541598290300,["gjx16@GJXAIOU",[[-1,164,"\t"],[1,165,"\n"]],[165,165],[165,165]]],[1541598296604,["gjx16@GJXAIOU",[[1,44,"\n"]],[44,44],[45,45]]],[1541598296732,["gjx16@GJXAIOU",[[1,45,"\n"]],[45,45],[46,46]]],[1541598297711,["gjx16@GJXAIOU",[[1,45,"#include<stdio.h>"]],[45,45],[62,62]]],[1541598299091,["gjx16@GJXAIOU",[[1,63,"\n"]],[62,62],[63,63]]],[1541598301467,["gjx16@GJXAIOU",[[-1,44,"\n"]],[44,44],[43,43]]],[1541598307580,["gjx16@GJXAIOU",[[1,230,"- \n"]],[229,229],[232,232]]],[1541598310404,["gjx16@GJXAIOU",[[1,230,"  "]],[230,230],[232,232]]],[1541598311527,["gjx16@GJXAIOU",[[1,234," "]],[233,233],[234,234]]],[1541598312980,["gjx16@GJXAIOU",[[1,234,"fangfa"]],[234,234],[240,240]]],[1541598315005,["gjx16@GJXAIOU",[[-1,234,"fangfa"]],[240,240],[234,234]]],[1541598318074,["gjx16@GJXAIOU",[[1,234,"方法一；"]],[234,234],[238,238]]],[1541598319309,["gjx16@GJXAIOU",[[-1,237,"；"]],[238,238],[237,237]]],[1541598319879,["gjx16@GJXAIOU",[[1,237,"："]],[237,237],[238,238]]],[1541598328530,["gjx16@GJXAIOU",[[1,448,"  - 方法二："]],[448,448],[456,456]]],[1541598522430,["gjx16@GJXAIOU",[[1,457,"  - \n"]],[456,456],[461,461]]],[1541598523883,["gjx16@GJXAIOU",[[-1,459,"- "]],[461,461],[459,459]]],[1541598525630,["gjx16@GJXAIOU",[[1,459,"~"]],[459,459],[460,460]]],[1541598526524,["gjx16@GJXAIOU",[[-1,459,"~"]],[460,460],[459,459]]],[1541598527933,["gjx16@GJXAIOU",[[1,459,"```"]],[459,459],[462,462]]],[1541598530570,["gjx16@GJXAIOU",[[-1,458," ```"]],[462,462],[458,458]]],[1541598531885,["gjx16@GJXAIOU",[[1,458,"```"]],[458,458],[461,461]]],[1541598533106,["gjx16@GJXAIOU",[[-1,457," ```"]],[461,461],[457,457]]],[1541598535431,["gjx16@GJXAIOU",[[1,457,"```"]],[457,457],[460,460]]],[1541598535455,["gjx16@GJXAIOU",[[1,460,"language\n```\n"]],[460,460],[460,468]]],[1541598536484,["gjx16@GJXAIOU",[[-1,460,"language"],[1,468,"c"]],[460,468],[461,461]]],[1541598536746,["gjx16@GJXAIOU",[[1,462,"\n"]],[461,461],[462,462]]],[1541598537843,["gjx16@GJXAIOU",[[1,462,"#include<stdio.h>\n//第2种：定义类型的时候同时定义变量\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n}t2,t3;\n\n//第三种：可以不用名字\nstruct \n{\n\tchar name[50];\n\tint age;\n}t2, t3;\n\n\nint main()\n{\n\n\treturn 0;\n}"]],[462,462],[638,638]]],[1541598543451,["gjx16@GJXAIOU",[[1,456,"fang"]],[456,456],[460,460]]],[1541598544772,["gjx16@GJXAIOU",[[-1,456,"fang"]],[460,460],[456,456]]],[1541598550356,["gjx16@GJXAIOU",[[1,456,"方法三："]],[456,456],[460,460]]]],null,"gjx16@GJXAIOU"],["2907b971-e472-47bc-83f1-863f2da2721e",1541685947478,"# day05 结构体\n\n\n## 一、结构体的基础操作\n\n- 结构体类型定义\n```c\n#include<stdio.h>\n\n//结构体类型的定义\n\t/*\n\t首先struct为关键字\n\tstruct Teacher 结合在一起才是类型\n\t{}后面有；\n\t*/\n\t\n\tstruct Teacher\n\t{\n\t\tchar name[50];\n\t\tint age;\n\t};\n\n\nint main()\n{\n\t\n\t\n\treturn 0;\n}\n```\n\n- 结构体变量定义\n  - 方法一： \n```c\n#include<stdio.h>\n\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n};\n\n\n//结构体变量的定义\n//第一种：先定义类型，在定义变量--最常用的方法\nstruct Teacher t1;  //这里定义的就是全局变量\n\nint main()\n{\n\tstruct Teacher t2;//这里定义的就是局部变量\n\n\treturn 0;\n}\n```\n  - 方法二：方法三：\n```c\n#include<stdio.h>\n//第2种：定义类型的时候同时定义变量\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n}t2,t3;\n\n//第三种：可以不用名字\nstruct \n{\n\tchar name[50];\n\tint age;\n}t2, t3;\n\n\nint main()\n{\n\n\treturn 0;\n}\n```\n\n- 结构体变量的初始化\n- 使用typedef该类型名\n- 点运算符和指针法操作结构体\n- 结构体也是一种数据类型，复合类型，自定义类型\n\n\n",[[1541685934892,["gjx16@GJXAIOU",[[1,662,"\n- "]],[659,659],[662,662]]],[1541685936077,["gjx16@GJXAIOU",[[-1,660,"- "]],[662,662],[660,660]]],[1541685938134,["gjx16@GJXAIOU",[[1,660,"```"]],[660,660],[663,663]]],[1541685938160,["gjx16@GJXAIOU",[[1,663,"language\n```\n"]],[663,663],[663,671]]],[1541685939600,["gjx16@GJXAIOU",[[-1,663,"language"],[1,671,"c"]],[663,671],[664,664]]],[1541685939853,["gjx16@GJXAIOU",[[1,665,"\n"]],[664,664],[665,665]]],[1541685941436,["gjx16@GJXAIOU",[[1,665,"#include<stdio.h>\n//定义的同时进行初始化\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n}t1 = {\"hello\",18};\n\n\n\n//或者定义同时进行初始化，这里对应的是另一种定义方法：\nstruct Teacher t2 = { \"hello\",19 };\n\n\n\nint main()\n{\n\t//使用\n\tprintf(\"%s,%d\\n\", t2.name, t2.age);\n\tsystem(\"pause\");\n\treturn 0;\n}"]],[665,665],[916,916]]],[1541685944743,["gjx16@GJXAIOU",[[-1,761,"\n"]],[761,761],[760,760]]],[1541685944909,["gjx16@GJXAIOU",[[-1,760,"\n"]],[760,760],[759,759]]],[1541685948437,["gjx16@GJXAIOU",[[-1,827,"\n"]],[827,827],[826,826]]],[1541685948581,["gjx16@GJXAIOU",[[-1,826,"\n"]],[826,826],[825,825]]],[1541685952679,["gjx16@GJXAIOU",[[1,936,"\n- "]],[933,933],[936,936]]],[1541685953631,["gjx16@GJXAIOU",[[-1,934,"- "]],[936,936],[934,934]]],[1541685956422,["gjx16@GJXAIOU",[[1,934,"```"]],[934,934],[937,937]]],[1541685956447,["gjx16@GJXAIOU",[[1,937,"language\n```\n"]],[937,937],[937,945]]],[1541685957422,["gjx16@GJXAIOU",[[-1,937,"language"],[1,945,"c"]],[937,945],[938,938]]],[1541685957742,["gjx16@GJXAIOU",[[1,939,"\n"]],[938,938],[939,939]]],[1541686266231,["gjx16@GJXAIOU",[[1,939,"#include<stdio.h>\n\ntypedef struct Teacher2\n{\n\tchar name[3];\n\tint age;\n}Teacher2;//将struct Teacher 定义为Teacher2\n//对应的使用\nTeacher2 t3;\n\nint main()\n{\n\t//使用\n\tprintf(\"%s,%d\\n\", t3.name, t3.age);\n\tsystem(\"pause\");\n\treturn 0;\n}"]],[939,939],[1157,1157]]],[1541686269728,["gjx16@GJXAIOU",[[1,1181,"\n- "]],[1178,1178],[1181,1181]]],[1541686270581,["gjx16@GJXAIOU",[[-1,1179,"- "]],[1181,1181],[1179,1179]]],[1541686905961,["gjx16@GJXAIOU",[[1,1179,"```"]],[1179,1179],[1182,1182]]],[1541686905987,["gjx16@GJXAIOU",[[1,1182,"language\n```\n"]],[1182,1182],[1182,1190]]],[1541686906885,["gjx16@GJXAIOU",[[-1,1182,"language"],[1,1190,"c"]],[1182,1190],[1183,1183]]],[1541686907157,["gjx16@GJXAIOU",[[1,1184,"\n"]],[1183,1183],[1184,1184]]],[1541686909008,["gjx16@GJXAIOU",[[1,1184,"#include<stdio.h>\n\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;//将struct Teacher 定义为Teacher2\n//对应的使用\nTeacher2 t3;\n\nint main()\n{\n\t//使用点运算符进行操作\n\tstrcpy(t3.name, \"xiaoming\");\n\tt3.age = 28;\n\tprintf(\"%s,%d\\n\", t3.name, t3.age);\n\n\t//使用指针操作\n\tstruct Teacher2 *p = NULL; //不能直接向指针赋值，因为这个指针只占四个字节\n\tp = &t3;\n\tstrcpy(p->name, \"xiaoli\");\n\tp->age = 25;\n\tprintf(\"%s,%d\\n\", p->name, p->age);\n\treturn 0;\n}"]],[1184,1184],[1590,1590]]]],null,"gjx16@GJXAIOU"],["316aa060-087e-4e45-b71f-c05bc5ca47d4",1541727423029,"# day05 结构体\n\n\n## 一、结构体的基础操作\n\n- 结构体类型定义\n```c\n#include<stdio.h>\n\n//结构体类型的定义\n\t/*\n\t首先struct为关键字\n\tstruct Teacher 结合在一起才是类型\n\t{}后面有；\n\t*/\n\t\n\tstruct Teacher\n\t{\n\t\tchar name[50];\n\t\tint age;\n\t};\n\n\nint main()\n{\n\t\n\t\n\treturn 0;\n}\n```\n\n- 结构体变量定义\n  - 方法一： \n```c\n#include<stdio.h>\n\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n};\n\n\n//结构体变量的定义\n//第一种：先定义类型，在定义变量--最常用的方法\nstruct Teacher t1;  //这里定义的就是全局变量\n\nint main()\n{\n\tstruct Teacher t2;//这里定义的就是局部变量\n\n\treturn 0;\n}\n```\n  - 方法二：方法三：\n```c\n#include<stdio.h>\n//第2种：定义类型的时候同时定义变量\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n}t2,t3;\n\n//第三种：可以不用名字\nstruct \n{\n\tchar name[50];\n\tint age;\n}t2, t3;\n\n\nint main()\n{\n\n\treturn 0;\n}\n```\n\n- 结构体变量的初始化\n```c\n#include<stdio.h>\n//定义的同时进行初始化\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n}t1 = {\"hello\",18};\n\n//或者定义同时进行初始化，这里对应的是另一种定义方法：\nstruct Teacher t2 = { \"hello\",19 };\n\nint main()\n{\n\t//使用\n\tprintf(\"%s,%d\\n\", t2.name, t2.age);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n- 使用typedef该类型名\n```c\n#include<stdio.h>\n\ntypedef struct Teacher2\n{\n\tchar name[3];\n\tint age;\n}Teacher2;//将struct Teacher 定义为Teacher2\n//对应的使用\nTeacher2 t3;\n\nint main()\n{\n\t//使用\n\tprintf(\"%s,%d\\n\", t3.name, t3.age);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n- 点运算符和指针法操作结构体\n```c\n#include<stdio.h>\n\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;//将struct Teacher 定义为Teacher2\n//对应的使用\nTeacher2 t3;\n\nint main()\n{\n\t//使用点运算符进行操作\n\tstrcpy(t3.name, \"xiaoming\");\n\tt3.age = 28;\n\tprintf(\"%s,%d\\n\", t3.name, t3.age);\n\n\t//使用指针操作\n\tstruct Teacher2 *p = NULL; //不能直接向指针赋值，因为这个指针只占四个字节\n\tp = &t3;\n\tstrcpy(p->name, \"xiaoli\");\n\tp->age = 25;\n\tprintf(\"%s,%d\\n\", p->name, p->age);\n\treturn 0;\n}\n```\n\n- 结构体也是一种数据类型，复合类型，自定义类型\n\n\n",[[1541727418439,["gjx16@GJXAIOU",[[-1,448,"  "]],[450,450],[448,448]]],[1541727421304,["gjx16@GJXAIOU",[[1,448,"    "]],[448,448],[452,452]]],[1541727423702,["gjx16@GJXAIOU",[[-1,449,"  "]],[451,451],[449,449]]],[1541727425728,["gjx16@GJXAIOU",[[-1,449,"- "]],[451,451],[449,449]]],[1541727428374,["gjx16@GJXAIOU",[[1,449,"  - "]],[449,449],[453,453]]],[1541727432437,["gjx16@GJXAIOU",[[1,451,"\n   "]],[451,451],[455,455]]],[1541727438161,["gjx16@GJXAIOU",[[-1,452,"   - "]],[457,457],[452,452]]],[1541727441789,["gjx16@GJXAIOU",[[1,452,"  - "]],[452,452],[456,456]]],[1541727444000,["gjx16@GJXAIOU",[[1,454,"  "]],[454,454],[456,456]]],[1541727446572,["gjx16@GJXAIOU",[[-1,455," "]],[456,456],[455,455]]],[1541727449203,["gjx16@GJXAIOU",[[1,455,"                         "]],[455,455],[480,480]]],[1541727451338,["gjx16@GJXAIOU",[[-1,454,"                          "]],[480,480],[454,454]]],[1541727461395,["gjx16@GJXAIOU",[[1,1625,"- \n"]],[1624,1624],[1627,1627]]],[1541727461561,["gjx16@GJXAIOU",[[-1,1625,"- "]],[1627,1627],[1626,1626]]],[1541727462679,["gjx16@GJXAIOU",[[1,1628,"\n"]],[1626,1626],[1627,1627]]],[1541727466176,["gjx16@GJXAIOU",[[1,1627,"- jiegouti"]],[1627,1627],[1637,1637]]],[1541727467374,["gjx16@GJXAIOU",[[-1,1630,"iegouti"]],[1637,1637],[1630,1630]]],[1541727476015,["gjx16@GJXAIOU",[[1,1630,"jie"]],[1630,1630],[1633,1633]]],[1541727477289,["gjx16@GJXAIOU",[[-1,1629,"jjie"]],[1633,1633],[1629,1629]]],[1541727480764,["gjx16@GJXAIOU",[[1,1629,"结构体变量"]],[1629,1629],[1634,1634]]],[1541727541931,[null,[[-1,456," "],[1,1627,"\n"],[-1,1634,"\n"]],[456,456],[1634,1634]]],[1541727541931,[null,[[1,456," "],[-1,1626,"\n"],[1,1634,"\n"]],[1634,1634],[456,456]]],[1541727485762,["gjx16@GJXAIOU",[[1,1634,"相互赋值"]],[1634,1634],[1638,1638]]],[1541727486186,["gjx16@GJXAIOU",[[1,1639,"- \n"]],[1638,1638],[1641,1641]]],[1541727492607,["gjx16@GJXAIOU",[[1,1641,"结构体静态函数"]],[1641,1641],[1648,1648]]],[1541727492984,["gjx16@GJXAIOU",[[1,1649,"- \n"]],[1648,1648],[1651,1651]]],[1541727498837,["gjx16@GJXAIOU",[[1,1651,"结构体动态函数"]],[1651,1651],[1658,1658]]],[1541727499229,["gjx16@GJXAIOU",[[1,1659,"- \n"]],[1658,1658],[1661,1661]]],[1541727517323,["gjx16@GJXAIOU",[[1,1661,"结构体套一级指针问题"]],[1661,1661],[1671,1671]]],[1541727517726,["gjx16@GJXAIOU",[[1,1672,"- \n"]],[1671,1671],[1674,1674]]],[1541727525003,["gjx16@GJXAIOU",[[1,1674,"结构体做函数采纳数"]],[1674,1674],[1683,1683]]],[1541727526052,["gjx16@GJXAIOU",[[-1,1680,"采纳数"]],[1683,1683],[1680,1680]]],[1541727527844,["gjx16@GJXAIOU",[[1,1680,"参数"]],[1680,1680],[1682,1682]]],[1541727528200,["gjx16@GJXAIOU",[[1,1683,"- \n"]],[1682,1682],[1685,1685]]],[1541727540713,["gjx16@GJXAIOU",[[1,1685,"结构体嵌套"]],[1685,1685],[1690,1690]]],[1541727601946,[null,[[-1,456," "],[1,1627,"\n"],[-1,1690,"\n"]],[456,456],[1690,1690]]],[1541727601946,[null,[[1,456," "],[-1,1626,"\n"],[1,1690,"\n"]],[1690,1690],[456,456]]],[1541727543652,["gjx16@GJXAIOU",[[1,1690,"二级指针"]],[1690,1690],[1694,1694]]],[1541727544159,["gjx16@GJXAIOU",[[1,1695,"- \n"]],[1694,1694],[1697,1697]]],[1541727570523,["gjx16@GJXAIOU",[[1,1697,"结构体的点运算符和指针法操作的区别"]],[1697,1697],[1714,1714]]],[1541727571153,["gjx16@GJXAIOU",[[1,1715,"- \n"]],[1714,1714],[1717,1717]]],[1541727582166,["gjx16@GJXAIOU",[[1,1717,"结构体数组的排序"]],[1717,1717],[1725,1725]]],[1541727583104,["gjx16@GJXAIOU",[[1,1726,"- \n"]],[1725,1725],[1728,1728]]],[1541727592090,["gjx16@GJXAIOU",[[1,1728,"结构体的深拷贝和浅拷贝"]],[1728,1728],[1739,1739]]],[1541727592529,["gjx16@GJXAIOU",[[1,1740,"- \n"]],[1739,1739],[1742,1742]]],[1541727597533,["gjx16@GJXAIOU",[[1,1742,"结构体偏移"]],[1742,1742],[1747,1747]]],[1541727598062,["gjx16@GJXAIOU",[[1,1748,"- \n"]],[1747,1747],[1750,1750]]],[1541727601386,["gjx16@GJXAIOU",[[1,1750,"结构体字节"]],[1750,1750],[1755,1755]]],[1541727661947,[null,[[-1,456," "],[1,1627,"\n"],[-1,1755,"\n"]],[456,456],[1755,1755]]],[1541727661947,[null,[[1,456," "],[-1,1626,"\n"],[1,1755,"\n"]],[1755,1755],[456,456]]],[1541727602962,["gjx16@GJXAIOU",[[1,1755,"对齐"]],[1755,1755],[1757,1757]]],[1541727603387,["gjx16@GJXAIOU",[[1,1758,"- \n"]],[1757,1757],[1760,1760]]],[1541727606250,["gjx16@GJXAIOU",[[-1,1758,"- "]],[1760,1760],[1758,1758]]],[1541727614558,["gjx16@GJXAIOU",[[1,1641,"\n- "]],[1638,1638],[1641,1641]]],[1541727615701,["gjx16@GJXAIOU",[[-1,1639,"- "]],[1641,1641],[1639,1639]]],[1541733557163,[null,[[-1,456," "],[1,1627,"\n"],[-1,1758,"\n"]],[456,456],[1758,1758]]],[1541733557163,[null,[[1,456," "],[-1,1626,"\n"],[1,1758,"\n"]],[1758,1758],[456,456]]],[1541733514289,["gjx16@GJXAIOU",[[1,1639,"··"]],[1639,1639],[1641,1641]]],[1541733515564,["gjx16@GJXAIOU",[[-1,1639,"··"]],[1641,1641],[1639,1639]]],[1541733517093,["gjx16@GJXAIOU",[[1,1639,"```"]],[1639,1639],[1642,1642]]],[1541733517132,["gjx16@GJXAIOU",[[1,1642,"language\n```\n"]],[1642,1642],[1642,1650]]],[1541733518589,["gjx16@GJXAIOU",[[-1,1642,"language"],[1,1650,"c"]],[1642,1650],[1643,1643]]],[1541733518843,["gjx16@GJXAIOU",[[1,1644,"\n"]],[1643,1643],[1644,1644]]],[1541733520456,["gjx16@GJXAIOU",[[1,1644,"#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;\n\nint main()\n{\n\tTeacher2 t1 = { \"zhanger\",15 };\n\tTeacher2 t2 = t1;//相同类型的两个结构体之间可以进行相互赋值\n\t//把t1成员变量内存的值拷贝给t2成员变量的内存，本质上t1和t2已经没有关系了\n\tprintf(\"%s,%d\\n\", t2.name, t2.age);\n\treturn 0;\n}"]],[1644,1644],[1962,1962]]],[1541733525388,["gjx16@GJXAIOU",[[1,1968,"\n"]],[1966,1966],[1967,1967]]],[1541733526545,["gjx16@GJXAIOU",[[1,1967,"cheng"]],[1967,1967],[1972,1972]]],[1541733527643,["gjx16@GJXAIOU",[[-1,1967,"cheng"]],[1972,1972],[1967,1967]]],[1541733537644,["gjx16@GJXAIOU",[[1,1967,"程序运行结果：``"]],[1967,1967],[1976,1976]]],[1541733544151,["gjx16@GJXAIOU",[[1,1975,"zhanger,15"]],[1975,1975],[1985,1985]]],[1541746580008,[null,[[-1,456," "],[1,1627,"\n"],[-1,2106,"\n"]],[456,456],[2106,2106]]],[1541746580008,[null,[[1,456," "],[-1,1626,"\n"],[1,2106,"\n"]],[2106,2106],[456,456]]],[1541746568518,["gjx16@GJXAIOU",[[1,1644,"\n"]],[1643,1643],[1644,1644]]],[1541746579153,["gjx16@GJXAIOU",[[1,1644,"//在main函数内部，不需要"]],[1644,1644],[1659,1659]]],[1541746639986,[null,[[-1,456," "],[1,1627,"\n"],[-1,2122,"\n"]],[456,456],[2122,2122]]],[1541746639986,[null,[[1,456," "],[-1,1626,"\n"],[1,2122,"\n"]],[2122,2122],[456,456]]],[1541746581180,["gjx16@GJXAIOU",[[1,1659,"调用函数"]],[1659,1659],[1663,1663]]],[1541746999992,[null,[[-1,456," "],[1,1627,"\n"],[-1,2126,"\n"]],[456,456],[2126,2126]]],[1541746999992,[null,[[1,456," "],[-1,1626,"\n"],[1,2126,"\n"]],[2126,2126],[456,456]]],[1541746975920,["gjx16@GJXAIOU",[[1,2007,"·"]],[2007,2007],[2008,2008]]],[1541746976478,["gjx16@GJXAIOU",[[-1,2007,"·"]],[2008,2008],[2007,2007]]],[1541746977870,["gjx16@GJXAIOU",[[1,2007,"```"]],[2007,2007],[2010,2010]]],[1541746977899,["gjx16@GJXAIOU",[[1,2010,"language\n```\n"]],[2010,2010],[2010,2018]]],[1541746979239,["gjx16@GJXAIOU",[[-1,2010,"language"],[1,2018,"c"]],[2010,2018],[2011,2011]]],[1541746979486,["gjx16@GJXAIOU",[[1,2012,"\n"]],[2011,2011],[2012,2012]]],[1541746980885,["gjx16@GJXAIOU",[[1,2012,"#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;\n\nvoid copyTeacher(Teacher2 *to, Teacher2 *from)\n{\n\t*to = *from;\n\tprintf(\"[copyTeacher] %s ,%d\\n\", to->name, to->age);\n}\n\nint main()\n{\n\tTeacher2 t1 = { \"zhanger\",15 };\n\tTeacher2 t2;\n\tmemset(&t2, 0, sizeof(t2));\n\tcopyTeacher(&t2, &t1);//这里需要传址\n\treturn 0;\n}"]],[2012,2012],[2404,2404]]],[1541747660014,[null,[[-1,456," "],[1,1627,"\n"],[-1,2528,"\n"]],[456,456],[2528,2528]]],[1541747660014,[null,[[1,456," "],[-1,1626,"\n"],[1,2528,"\n"]],[2528,2528],[456,456]]],[1541747635310,["gjx16@GJXAIOU",[[1,2422,"\n- "]],[2419,2419],[2422,2422]]],[1541747636166,["gjx16@GJXAIOU",[[-1,2420,"- "]],[2422,2422],[2420,2420]]],[1541747637786,["gjx16@GJXAIOU",[[1,2420,"···"]],[2420,2420],[2423,2423]]],[1541747639135,["gjx16@GJXAIOU",[[-1,2420,"···"]],[2423,2423],[2420,2420]]],[1541747640184,["gjx16@GJXAIOU",[[1,2420,"···"]],[2420,2420],[2423,2423]]],[1541747640926,["gjx16@GJXAIOU",[[-1,2420,"···"]],[2423,2423],[2420,2420]]],[1541747642137,["gjx16@GJXAIOU",[[1,2420,"```"]],[2420,2420],[2423,2423]]],[1541747642164,["gjx16@GJXAIOU",[[1,2423,"language\n```\n"]],[2423,2423],[2423,2431]]],[1541747643530,["gjx16@GJXAIOU",[[-1,2423,"language"],[1,2431,"c"]],[2423,2431],[2424,2424]]],[1541747643767,["gjx16@GJXAIOU",[[1,2425,"\n"]],[2424,2424],[2425,2425]]],[1541747644966,["gjx16@GJXAIOU",[[1,2425,"#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher\n{\n\tchar name[40];\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\t//定义静态数组和使用静态数组\n\n\tTeacher a[5] = { {\"zhangsan\",34},{\"xiaoli\",23},{\"zhaoliu\",12} };\n\tTeacher b[5] = { \"wangqi\",23,\"qianba\",11,\"liuliuliu\",94 };\n\n\t//使用\n\tint i = 0;\n\tfor (i = 0; i < 5; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", a[i].name, a[i].age);\n\n\t}\n\treturn 0;\n}"]],[2425,2425],[2825,2825]]],[1541747655913,["gjx16@GJXAIOU",[[1,2843,"\n- "]],[2840,2840],[2843,2843]]],[1541747657089,["gjx16@GJXAIOU",[[-1,2841,"- "]],[2843,2843],[2841,2841]]],[1541747720010,[null,[[-1,456," "],[1,1625,"\n"],[-1,2940,"\n"]],[456,456],[2940,2940]]],[1541747720010,[null,[[1,456," "],[-1,1624,"\n"],[1,2940,"\n"]],[2940,2940],[456,456]]],[1541747662046,["gjx16@GJXAIOU",[[-1,2417,"函数"]],[2419,2419],[2417,2417]]],[1541747663322,["gjx16@GJXAIOU",[[1,2417,"shuzu"]],[2417,2417],[2422,2422]]],[1541747664353,["gjx16@GJXAIOU",[[-1,2417,"shuzu"]],[2422,2422],[2417,2417]]],[1541747666229,["gjx16@GJXAIOU",[[1,2417,"数组"]],[2417,2417],[2419,2419]]],[1541747672166,["gjx16@GJXAIOU",[[-1,2838,"函数"]],[2840,2840],[2838,2838]]],[1541747674068,["gjx16@GJXAIOU",[[1,2838,"数组"]],[2838,2838],[2840,2840]]],[1541747678192,["gjx16@GJXAIOU",[[1,2841,"```"]],[2841,2841],[2844,2844]]],[1541747678222,["gjx16@GJXAIOU",[[1,2844,"language\n```\n"]],[2844,2844],[2844,2852]]],[1541747679361,["gjx16@GJXAIOU",[[-1,2844,"language"],[1,2852,"c"]],[2844,2852],[2845,2845]]],[1541747679607,["gjx16@GJXAIOU",[[1,2846,"\n"]],[2845,2845],[2846,2846]]],[1541748500147,[null,[[-1,456," "],[1,1625,"\n"],[-1,2950,"\n"]],[456,456],[2950,2950]]],[1541748500147,[null,[[1,456," "],[-1,1624,"\n"],[1,2950,"\n"]],[2950,2950],[456,456]]],[1541748484886,["gjx16@GJXAIOU",[[1,2846,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name[40];\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\t//定义和使用动态数组\n\tTeacher *p = (Teacher *)malloc(3 * sizeof(Teacher));\n\tif (p == NULL)\n\t{\n\t\treturn -1;\n\t}\n\n\tchar buf[10];\n\tint i = 0;\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i]. age = 20 + i;\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"num of %d:%s,%d\\n\", i + 1, p[i].name, p[i].age);\n\n\t}\n\tprintf(\"\\n\");\n\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\n\treturn 0;\n}"]],[2846,2846],[3407,3407]]],[1541748488633,["gjx16@GJXAIOU",[[1,3413,"\n"]],[3411,3411],[3412,3412]]],[1541748489338,["gjx16@GJXAIOU",[[1,3412,"c"]],[3412,3412],[3413,3413]]],[1541748490009,["gjx16@GJXAIOU",[[-1,3412,"c"]],[3413,3413],[3412,3412]]],[1541748494081,["gjx16@GJXAIOU",[[1,3412,"程序运行结果："]],[3412,3412],[3419,3419]]],[1541748494681,["gjx16@GJXAIOU",[[1,3421,"\n"]],[3419,3419],[3420,3420]]],[1541748560155,[null,[[-1,456," "],[1,1625,"\n"],[-1,3520,"\n"]],[456,456],[3520,3520]]],[1541748560155,[null,[[1,456," "],[-1,1624,"\n"],[1,3520,"\n"]],[3520,3520],[456,456]]],[1541748503703,["gjx16@GJXAIOU",[[1,3420,"num of 1:name 000,20\nnum of 2:name 111,21\nnum of 3:name 222,22"]],[3420,3420],[3482,3482]]],[1541748511539,["gjx16@GJXAIOU",[[1,3420,"·"]],[3420,3420],[3421,3421]]],[1541748513353,["gjx16@GJXAIOU",[[-1,3420,"·"]],[3421,3421],[3420,3420]]],[1541748513817,["gjx16@GJXAIOU",[[1,3420,"`"]],[3420,3420],[3421,3421]]],[1541748514912,["gjx16@GJXAIOU",[[1,3442,"`"]],[3442,3442],[3443,3443]]],[1541748515511,["gjx16@GJXAIOU",[[1,3464,"`"]],[3464,3464],[3465,3465]]],[1541748518965,["gjx16@GJXAIOU",[[1,3485,"`"]],[3485,3485],[3486,3486]]],[1541748519386,["gjx16@GJXAIOU",[[1,3463,"`"]],[3463,3463],[3464,3464]]],[1541748519917,["gjx16@GJXAIOU",[[1,3441,"`"]],[3441,3441],[3442,3442]]],[1541748557014,["gjx16@GJXAIOU",[[1,3505,"\n- "]],[3502,3502],[3505,3505]]],[1541748558447,["gjx16@GJXAIOU",[[-1,3503,"- "]],[3505,3505],[3503,3503]]],[1541748559143,["gjx16@GJXAIOU",[[1,3504,"\n"]],[3503,3503],[3504,3504]]],[1541748620157,[null,[[-1,456," "],[1,1625,"\n"],[-1,3590,"\n"]],[456,456],[3590,3590]]],[1541748620158,[null,[[1,456," "],[-1,1624,"\n"],[1,3590,"\n"]],[3590,3590],[456,456]]],[1541748560878,["gjx16@GJXAIOU",[[-1,3504,"\n"]],[3504,3504],[3503,3503]]],[1541748562208,["gjx16@GJXAIOU",[[1,3503,"```"]],[3503,3503],[3506,3506]]],[1541748562243,["gjx16@GJXAIOU",[[1,3506,"language\n```\n"]],[3506,3506],[3506,3514]]],[1541748563072,["gjx16@GJXAIOU",[[-1,3506,"language"],[1,3514,"c"]],[3506,3514],[3507,3507]]],[1541748563352,["gjx16@GJXAIOU",[[1,3508,"\n"]],[3507,3507],[3508,3508]]],[1541748563479,["gjx16@GJXAIOU",[[1,3509,"\n"]],[3508,3508],[3509,3509]]],[1541749100162,[null,[[-1,456," "],[1,1625,"\n"],[-1,3600,"\n"]],[456,456],[3600,3600]]],[1541749100162,[null,[[1,456," "],[-1,1624,"\n"],[1,3600,"\n"]],[3600,3600],[456,456]]],[1541749051729,["gjx16@GJXAIOU",[[1,3495,"qiantao"]],[3495,3495],[3502,3502]]],[1541749053232,["gjx16@GJXAIOU",[[-1,3495,"qiantao"]],[3502,3502],[3495,3495]]],[1541749055870,["gjx16@GJXAIOU",[[1,3495,"嵌套"]],[3495,3495],[3497,3497]]],[1541749056289,["gjx16@GJXAIOU",[[-1,3497,"套"]],[3497,3497],[3496,3496]]],[1541749058759,["gjx16@GJXAIOU",[[1,3509,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher t;\n\tt.name = (char *)malloc(30); //必须先分配空间\n\tstrcpy(t.name, \"lily\");\n\tt.age = 22;\n\tprintf(\"name = %s ,age = %d\\n\", t.name, t.age);\n\n\tif (t.name != NULL)\n\t{\n\t\tfree(t.name);\n\t\tt.name = NULL;\n\t}\n\n\treturn 0;\n}"]],[3509,3509],[3914,3914]]],[1541749089134,["gjx16@GJXAIOU",[[1,3921,"\n"]],[3919,3919],[3920,3920]]],[1541749094276,["gjx16@GJXAIOU",[[1,3920,"程序运行结果："]],[3920,3920],[3927,3927]]],[1541749160172,[null,[[-1,456," "],[1,1625,"\n"],[-1,4014,"\n"]],[456,456],[4014,4014]]],[1541749160172,[null,[[1,456," "],[-1,1624,"\n"],[1,4014,"\n"]],[4014,4014],[456,456]]],[1541749103321,["gjx16@GJXAIOU",[[1,3927,"``"]],[3927,3927],[3929,3929]]],[1541749105182,["gjx16@GJXAIOU",[[1,3928,"name = lily ,age = 22"]],[3928,3928],[3949,3949]]],[1541749700174,[null,[[-1,456," "],[1,1625,"\n"],[-1,4037,"\n"]],[456,456],[4037,4037]]],[1541749700174,[null,[[1,456," "],[-1,1624,"\n"],[1,4037,"\n"]],[4037,4037],[456,456]]],[1541749682871,["gjx16@GJXAIOU",[[1,3509,"\n"]],[3508,3508],[3509,3509]]],[1541749683433,["gjx16@GJXAIOU",[[1,3509,"、、"]],[3509,3509],[3511,3511]]],[1541749684486,["gjx16@GJXAIOU",[[-1,3509,"、、"]],[3511,3511],[3509,3509]]],[1541749688706,["gjx16@GJXAIOU",[[1,3509,"//koegpui"]],[3509,3509],[3518,3518]]],[1541749690439,["gjx16@GJXAIOU",[[-1,3511,"koegpui"]],[3518,3518],[3511,3511]]],[1541749697239,["gjx16@GJXAIOU",[[1,3511,"结构体变量为"]],[3511,3511],[3517,3517]]],[1541749760181,[null,[[-1,456," "],[1,1625,"\n"],[-1,4046,"\n"]],[456,456],[4046,4046]]],[1541749760181,[null,[[1,456," "],[-1,1624,"\n"],[1,4046,"\n"]],[4046,4046],[456,456]]],[1541749711508,["gjx16@GJXAIOU",[[1,3517,"普通变量名的时候："]],[3517,3517],[3526,3526]]],[1541749711982,["gjx16@GJXAIOU",[[1,3527,"\n"]],[3526,3526],[3527,3527]]],[1541749718281,["gjx16@GJXAIOU",[[1,3970,"```"]],[3970,3970],[3973,3973]]],[1541749718310,["gjx16@GJXAIOU",[[1,3973,"language\n```\n"]],[3973,3973],[3973,3981]]],[1541749719498,["gjx16@GJXAIOU",[[-1,3973,"language"],[1,3981,"c"]],[3973,3981],[3974,3974]]],[1541749719702,["gjx16@GJXAIOU",[[1,3975,"\n"]],[3974,3974],[3975,3975]]],[1541749734323,["gjx16@GJXAIOU",[[1,3975,"//结构体变量为指针的时候"]],[3975,3975],[3988,3988]]],[1541749734720,["gjx16@GJXAIOU",[[1,3989,"\n"]],[3988,3988],[3989,3989]]],[1541749735967,["gjx16@GJXAIOU",[[1,3990,"\n"]],[3989,3989],[3990,3990]]],[1541749738225,["gjx16@GJXAIOU",[[1,3990,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher));//首先为p分配空间\n\tp->name = (char *)malloc(30); //再为p.name 分配空间\n\tstrcpy(p->name, \"lilei\");\n\tp->age = 22;\n\tprintf(\"name = %s ,age = %d\\n\", p->name, p->age);\n\n\tif (p->name != NULL)\n\t{\n\t\tfree(p->name);\n\t\tp->name = NULL;\n\t}\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\n\n\t}\n\treturn 0;\n}"]],[3990,3990],[4516,4516]]],[1541749744960,["gjx16@GJXAIOU",[[1,4522,"\n"]],[4520,4520],[4521,4521]]],[1541749750604,["gjx16@GJXAIOU",[[1,4521,"程序运行结果为："]],[4521,4521],[4529,4529]]],[1541749751015,["gjx16@GJXAIOU",[[1,4531,"\n"]],[4529,4529],[4530,4530]]],[1541749820177,[null,[[-1,456," "],[1,1625,"\n"],[-1,4617,"\n"]],[456,456],[4617,4617]]],[1541749820177,[null,[[1,456," "],[-1,1624,"\n"],[1,4617,"\n"]],[4617,4617],[456,456]]],[1541749773340,["gjx16@GJXAIOU",[[1,4529,"··"]],[4529,4529],[4531,4531]]],[1541749774438,["gjx16@GJXAIOU",[[-1,4529,"··"]],[4531,4531],[4529,4529]]],[1541749775314,["gjx16@GJXAIOU",[[1,4529,"``"]],[4529,4529],[4531,4531]]],[1541749776694,["gjx16@GJXAIOU",[[1,4530,"name = lilei ,age = 22"]],[4530,4530],[4552,4552]]],[1541749779016,["gjx16@GJXAIOU",[[1,4556,"\n"]],[4553,4553],[4554,4554]]],[1541749779649,["gjx16@GJXAIOU",[[1,4557,"\n"]],[4554,4554],[4555,4555]]],[1541749782137,["gjx16@GJXAIOU",[[1,4555,"```"]],[4555,4555],[4558,4558]]],[1541749782170,["gjx16@GJXAIOU",[[1,4558,"language\n```\n"]],[4558,4558],[4558,4566]]],[1541749783146,["gjx16@GJXAIOU",[[-1,4558,"language"],[1,4566,"c"]],[4558,4566],[4559,4559]]],[1541749783471,["gjx16@GJXAIOU",[[1,4560,"\n"]],[4559,4559],[4560,4560]]],[1541749786505,["gjx16@GJXAIOU",[[1,4560,"//"]],[4560,4560],[4562,4562]]],[1541749805479,["gjx16@GJXAIOU",[[1,4555,"\n"]],[4554,4554],[4555,4555]]],[1541749817002,["gjx16@GJXAIOU",[[1,4555,"程序运行内存结构图："]],[4555,4555],[4565,4565]]],[1541749817439,["gjx16@GJXAIOU",[[1,4566,"\n"]],[4565,4565],[4566,4566]]],[1541749880183,[null,[[-1,456," "],[1,1625,"\n"],[-1,4667,"\n"]],[456,456],[4667,4667]]],[1541749880183,[null,[[1,456," "],[-1,1624,"\n"],[1,4667,"\n"]],[4667,4667],[456,456]]],[1541749829973,["gjx16@GJXAIOU",[[1,4566,"![搜狗截图20181109154732]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181109154732.png)"]],[4566,4566],[4654,4654]]],[1541749834167,["gjx16@GJXAIOU",[[1,4654,"\n"]],[4653,4653],[4654,4654]]],[1541750600191,[null,[[-1,456," "],[1,1625,"\n"],[-1,4755,"\n"]],[456,456],[4755,4755]]],[1541750600191,[null,[[1,456," "],[-1,1624,"\n"],[1,4755,"\n"]],[4755,4755],[456,456]]],[1541750551472,["gjx16@GJXAIOU",[[1,4660,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];"],[1,4662,"这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher)*3);\n\t\n\tint i = 0;\n\tchar buf[30];\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tp[i].name = (char *)malloc(30);\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i].age = 20 + 2 * i;\n\n\t}\n\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", p[i].name, p[i].age);\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tif (p[i].name != NULL)\n\t\t{\n\t\t\tfree(p[i].name);\n\t\t\tp[i].name = NULL;\n\t\t}\n\n\n\t}\n\n\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\treturn 0;\n}"]],[4660,4662],[5345,5345]]],[1541750554752,["gjx16@GJXAIOU",[[1,5353,"\n"]],[5349,5349],[5350,5350]]],[1541750560076,["gjx16@GJXAIOU",[[1,5350,"程序运行结果："]],[5350,5350],[5357,5357]]],[1541750570994,["gjx16@GJXAIOU",[[1,5358,"name 000,20\nname 111,22\nname 222,24`"]],[5358,5358],[5394,5394]]],[1541750571609,["gjx16@GJXAIOU",[[1,5381,"`"]],[5381,5381],[5382,5382]]],[1541750572057,["gjx16@GJXAIOU",[[1,5369,"`"]],[5369,5369],[5370,5370]]],[1541750577282,["gjx16@GJXAIOU",[[1,5358,"`"]],[5358,5358],[5359,5359]]],[1541750577980,["gjx16@GJXAIOU",[[1,5372,"`"]],[5372,5372],[5373,5373]]],[1541750578652,["gjx16@GJXAIOU",[[1,5386,"`"]],[5386,5386],[5387,5387]]],[1541754500154,[null,[[-1,456," "],[1,1625,"\n"],[-1,5487,"\n"]],[456,456],[5487,5487]]],[1541754500155,[null,[[1,456," "],[-1,1624,"\n"],[1,5487,"\n"]],[5487,5487],[456,456]]],[1541754457563,["gjx16@GJXAIOU",[[1,5415,"\n- "]],[5412,5412],[5415,5415]]],[1541754457722,["gjx16@GJXAIOU",[[-1,5413,"- "]],[5415,5415],[5414,5414]]],[1541754461078,["gjx16@GJXAIOU",[[1,5413,"···"]],[5413,5413],[5416,5416]]],[1541754462899,["gjx16@GJXAIOU",[[-1,5413,"···"]],[5416,5416],[5413,5413]]],[1541754464294,["gjx16@GJXAIOU",[[1,5413,"```"]],[5413,5413],[5416,5416]]],[1541754464326,["gjx16@GJXAIOU",[[1,5416,"language\n```\n"]],[5416,5416],[5416,5424]]],[1541754465373,["gjx16@GJXAIOU",[[-1,5416,"language"],[1,5424,"c"]],[5416,5424],[5417,5417]]],[1541754465770,["gjx16@GJXAIOU",[[1,5418,"\n"]],[5417,5417],[5418,5418]]],[1541754980173,[null,[[-1,456," "],[1,1625,"\n"],[-1,5498,"\n"]],[456,456],[5498,5498]]],[1541754980173,[null,[[1,456," "],[-1,1624,"\n"],[1,5498,"\n"]],[5498,5498],[456,456]]],[1541754968189,["gjx16@GJXAIOU",[[1,5412,"()"]],[5412,5412],[5414,5414]]],[1541754970379,["gjx16@GJXAIOU",[[1,5413,"li"]],[5413,5413],[5415,5415]]],[1541754971048,["gjx16@GJXAIOU",[[-1,5413,"li"]],[5415,5415],[5413,5413]]],[1541754976564,["gjx16@GJXAIOU",[[1,5413,"例子为上面上述"]],[5413,5413],[5420,5420]]],[1541754978401,["gjx16@GJXAIOU",[[-1,5415,"为上面上述"]],[5420,5420],[5415,5415]]],[1541755040170,[null,[[-1,456," "],[1,1625,"\n"],[-1,5502,"\n"]],[456,456],[5502,5502]]],[1541755040170,[null,[[1,456," "],[-1,1624,"\n"],[1,5502,"\n"]],[5502,5502],[456,456]]],[1541754980879,["gjx16@GJXAIOU",[[1,5415,"西三党羽"]],[5415,5415],[5419,5419]]],[1541754981961,["gjx16@GJXAIOU",[[-1,5415,"西三党羽"]],[5419,5419],[5415,5415]]],[1541754993846,["gjx16@GJXAIOU",[[1,5415,"等于上面程序的函数"]],[5415,5415],[5424,5424]]],[1541754995169,["gjx16@GJXAIOU",[[-1,5421,"的函数"]],[5424,5424],[5421,5421]]],[1541755001682,["gjx16@GJXAIOU",[[1,5421,"进行函数封装"]],[5421,5421],[5427,5427]]],[1541755004777,["gjx16@GJXAIOU",[[1,5434,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\n//就是打印的功能\nvoid showTeacher(Teacher *p, int n)\n{\n\tint i = 0;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", p[i].name, p[i].age);\n\t}\n\n}\n\n\nvoid freeTeacher(Teacher *p, int n)\n{\n\tint i = 0;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (p[i].name != NULL)\n\t\t{\n\t\t\tfree(p[i].name);\n\t\t\tp[i].name = NULL;\n\t\t}\n\t}\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\n\n}\n\n\nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher)*3);\n\t\n\tint i = 0;\n\tchar buf[30];\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tp[i].name = (char *)malloc(30);\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i].age = 20 + 2 * i;\n\n\t}\n\n\n\n\tshowTeacher(p, 3);\n\n\t//释放空间\n\tfreeTeacher(p, 3);\n\n\tp = NULL;\n\t\n\treturn 0;\n}"]],[5434,5434],[6299,6299]]]],null,"gjx16@GJXAIOU"],["4980fa32-f9ce-48c0-ad3d-989a6cf8bc2f",1541847396347,"# day05 结构体\n\n\n## 一、结构体的基础操作\n\n- 结构体类型定义\n```c\n#include<stdio.h>\n\n//结构体类型的定义\n\t/*\n\t首先struct为关键字\n\tstruct Teacher 结合在一起才是类型\n\t{}后面有；\n\t*/\n\t\n\tstruct Teacher\n\t{\n\t\tchar name[50];\n\t\tint age;\n\t};\n\n\nint main()\n{\n\t\n\t\n\treturn 0;\n}\n```\n\n- 结构体变量定义\n  - 方法一： \n```c\n#include<stdio.h>\n\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n};\n\n\n//结构体变量的定义\n//第一种：先定义类型，在定义变量--最常用的方法\nstruct Teacher t1;  //这里定义的就是全局变量\n\nint main()\n{\n\tstruct Teacher t2;//这里定义的就是局部变量\n\n\treturn 0;\n}\n```\n   \n  - 方法二：方法三：\n```c\n#include<stdio.h>\n//第2种：定义类型的时候同时定义变量\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n}t2,t3;\n\n//第三种：可以不用名字\nstruct \n{\n\tchar name[50];\n\tint age;\n}t2, t3;\n\n\nint main()\n{\n\n\treturn 0;\n}\n```\n\n- 结构体变量的初始化\n```c\n#include<stdio.h>\n//定义的同时进行初始化\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n}t1 = {\"hello\",18};\n\n//或者定义同时进行初始化，这里对应的是另一种定义方法：\nstruct Teacher t2 = { \"hello\",19 };\n\nint main()\n{\n\t//使用\n\tprintf(\"%s,%d\\n\", t2.name, t2.age);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n- 使用typedef该类型名\n```c\n#include<stdio.h>\n\ntypedef struct Teacher2\n{\n\tchar name[3];\n\tint age;\n}Teacher2;//将struct Teacher 定义为Teacher2\n//对应的使用\nTeacher2 t3;\n\nint main()\n{\n\t//使用\n\tprintf(\"%s,%d\\n\", t3.name, t3.age);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n- 点运算符和指针法操作结构体\n```c\n#include<stdio.h>\n\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;//将struct Teacher 定义为Teacher2\n//对应的使用\nTeacher2 t3;\n\nint main()\n{\n\t//使用点运算符进行操作\n\tstrcpy(t3.name, \"xiaoming\");\n\tt3.age = 28;\n\tprintf(\"%s,%d\\n\", t3.name, t3.age);\n\n\t//使用指针操作\n\tstruct Teacher2 *p = NULL; //不能直接向指针赋值，因为这个指针只占四个字节\n\tp = &t3;\n\tstrcpy(p->name, \"xiaoli\");\n\tp->age = 25;\n\tprintf(\"%s,%d\\n\", p->name, p->age);\n\treturn 0;\n}\n```\n\n- 结构体也是一种数据类型，复合类型，自定义类型\n\n\n- 结构体变量相互赋值\n```c\n//在main函数内部，不需要调用函数\n#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;\n\nint main()\n{\n\tTeacher2 t1 = { \"zhanger\",15 };\n\tTeacher2 t2 = t1;//相同类型的两个结构体之间可以进行相互赋值\n\t//把t1成员变量内存的值拷贝给t2成员变量的内存，本质上t1和t2已经没有关系了\n\tprintf(\"%s,%d\\n\", t2.name, t2.age);\n\treturn 0;\n}\n```\n程序运行结果：`zhanger,15`\n```c\n#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;\n\nvoid copyTeacher(Teacher2 *to, Teacher2 *from)\n{\n\t*to = *from;\n\tprintf(\"[copyTeacher] %s ,%d\\n\", to->name, to->age);\n}\n\nint main()\n{\n\tTeacher2 t1 = { \"zhanger\",15 };\n\tTeacher2 t2;\n\tmemset(&t2, 0, sizeof(t2));\n\tcopyTeacher(&t2, &t1);//这里需要传址\n\treturn 0;\n}\n```\n\n- 结构体静态数组\n```c\n#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher\n{\n\tchar name[40];\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\t//定义静态数组和使用静态数组\n\n\tTeacher a[5] = { {\"zhangsan\",34},{\"xiaoli\",23},{\"zhaoliu\",12} };\n\tTeacher b[5] = { \"wangqi\",23,\"qianba\",11,\"liuliuliu\",94 };\n\n\t//使用\n\tint i = 0;\n\tfor (i = 0; i < 5; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", a[i].name, a[i].age);\n\n\t}\n\treturn 0;\n}\n```\n\n- 结构体动态数组\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name[40];\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\t//定义和使用动态数组\n\tTeacher *p = (Teacher *)malloc(3 * sizeof(Teacher));\n\tif (p == NULL)\n\t{\n\t\treturn -1;\n\t}\n\n\tchar buf[10];\n\tint i = 0;\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i]. age = 20 + i;\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"num of %d:%s,%d\\n\", i + 1, p[i].name, p[i].age);\n\n\t}\n\tprintf(\"\\n\");\n\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\n\treturn 0;\n}\n```\n程序运行结果：\n`num of 1:name 000,20`\n`num of 2:name 111,21`\n`num of 3:name 222,22`\n\n- 结构体嵌套一级指针问题\n```c\n//结构体变量为普通变量名的时候：\n\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher t;\n\tt.name = (char *)malloc(30); //必须先分配空间\n\tstrcpy(t.name, \"lily\");\n\tt.age = 22;\n\tprintf(\"name = %s ,age = %d\\n\", t.name, t.age);\n\n\tif (t.name != NULL)\n\t{\n\t\tfree(t.name);\n\t\tt.name = NULL;\n\t}\n\n\treturn 0;\n}\n\n```\n程序运行结果：`name = lily ,age = 22`\n```c\n//结构体变量为指针的时候\n\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher));//首先为p分配空间\n\tp->name = (char *)malloc(30); //再为p.name 分配空间\n\tstrcpy(p->name, \"lilei\");\n\tp->age = 22;\n\tprintf(\"name = %s ,age = %d\\n\", p->name, p->age);\n\n\tif (p->name != NULL)\n\t{\n\t\tfree(p->name);\n\t\tp->name = NULL;\n\t}\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\n\n\t}\n\treturn 0;\n}\n```\n程序运行结果为：`name = lilei ,age = 22`\n\n程序运行内存结构图：\n![搜狗截图20181109154732]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181109154732.png)\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher)*3);\n\t\n\tint i = 0;\n\tchar buf[30];\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tp[i].name = (char *)malloc(30);\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i].age = 20 + 2 * i;\n\n\t}\n\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", p[i].name, p[i].age);\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tif (p[i].name != NULL)\n\t\t{\n\t\t\tfree(p[i].name);\n\t\t\tp[i].name = NULL;\n\t\t}\n\n\n\t}\n\n\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\treturn 0;\n}\n```\n程序运行结果：\n`name 000,20`\n`name 111,22`\n`name 222,24`\n\n\n- 结构体做函数参数(例子等于上面程序进行函数封装)\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\n//就是打印的功能\nvoid showTeacher(Teacher *p, int n)\n{\n\tint i = 0;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", p[i].name, p[i].age);\n\t}\n\n}\n\n\nvoid freeTeacher(Teacher *p, int n)\n{\n\tint i = 0;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (p[i].name != NULL)\n\t\t{\n\t\t\tfree(p[i].name);\n\t\t\tp[i].name = NULL;\n\t\t}\n\t}\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\n\n}\n\n\nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher)*3);\n\t\n\tint i = 0;\n\tchar buf[30];\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tp[i].name = (char *)malloc(30);\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i].age = 20 + 2 * i;\n\n\t}\n\n\n\n\tshowTeacher(p, 3);\n\n\t//释放空间\n\tfreeTeacher(p, 3);\n\n\tp = NULL;\n\t\n\treturn 0;\n}\n```\n\n- 结构体嵌套二级指针\n- 结构体的点运算符和指针法操作的区别\n- 结构体数组的排序\n- 结构体的深拷贝和浅拷贝\n- 结构体偏移\n- 结构体字节对齐\n\n\n",[[1541847374439,["gjx16@GJXAIOU",[[1,6319,"\n- "]],[6316,6316],[6319,6319]]],[1541847375119,["gjx16@GJXAIOU",[[-1,6317,"- "]],[6319,6319],[6318,6318]]]],null,"gjx16@GJXAIOU"],["ede3fbff-75b0-4cda-a531-eaa595b2884e",1541900233905,"# day05 结构体\n\n\n## 一、结构体的基础操作\n\n- 结构体类型定义\n```c\n#include<stdio.h>\n\n//结构体类型的定义\n\t/*\n\t首先struct为关键字\n\tstruct Teacher 结合在一起才是类型\n\t{}后面有；\n\t*/\n\t\n\tstruct Teacher\n\t{\n\t\tchar name[50];\n\t\tint age;\n\t};\n\n\nint main()\n{\n\t\n\t\n\treturn 0;\n}\n```\n\n- 结构体变量定义\n  - 方法一： \n```c\n#include<stdio.h>\n\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n};\n\n\n//结构体变量的定义\n//第一种：先定义类型，在定义变量--最常用的方法\nstruct Teacher t1;  //这里定义的就是全局变量\n\nint main()\n{\n\tstruct Teacher t2;//这里定义的就是局部变量\n\n\treturn 0;\n}\n```\n   \n  - 方法二：方法三：\n```c\n#include<stdio.h>\n//第2种：定义类型的时候同时定义变量\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n}t2,t3;\n\n//第三种：可以不用名字\nstruct \n{\n\tchar name[50];\n\tint age;\n}t2, t3;\n\n\nint main()\n{\n\n\treturn 0;\n}\n```\n\n- 结构体变量的初始化\n```c\n#include<stdio.h>\n//定义的同时进行初始化\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n}t1 = {\"hello\",18};\n\n//或者定义同时进行初始化，这里对应的是另一种定义方法：\nstruct Teacher t2 = { \"hello\",19 };\n\nint main()\n{\n\t//使用\n\tprintf(\"%s,%d\\n\", t2.name, t2.age);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n- 使用typedef该类型名\n```c\n#include<stdio.h>\n\ntypedef struct Teacher2\n{\n\tchar name[3];\n\tint age;\n}Teacher2;//将struct Teacher 定义为Teacher2\n//对应的使用\nTeacher2 t3;\n\nint main()\n{\n\t//使用\n\tprintf(\"%s,%d\\n\", t3.name, t3.age);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n- 点运算符和指针法操作结构体\n```c\n#include<stdio.h>\n\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;//将struct Teacher 定义为Teacher2\n//对应的使用\nTeacher2 t3;\n\nint main()\n{\n\t//使用点运算符进行操作\n\tstrcpy(t3.name, \"xiaoming\");\n\tt3.age = 28;\n\tprintf(\"%s,%d\\n\", t3.name, t3.age);\n\n\t//使用指针操作\n\tstruct Teacher2 *p = NULL; //不能直接向指针赋值，因为这个指针只占四个字节\n\tp = &t3;\n\tstrcpy(p->name, \"xiaoli\");\n\tp->age = 25;\n\tprintf(\"%s,%d\\n\", p->name, p->age);\n\treturn 0;\n}\n```\n\n- 结构体也是一种数据类型，复合类型，自定义类型\n\n\n- 结构体变量相互赋值\n```c\n//在main函数内部，不需要调用函数\n#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;\n\nint main()\n{\n\tTeacher2 t1 = { \"zhanger\",15 };\n\tTeacher2 t2 = t1;//相同类型的两个结构体之间可以进行相互赋值\n\t//把t1成员变量内存的值拷贝给t2成员变量的内存，本质上t1和t2已经没有关系了\n\tprintf(\"%s,%d\\n\", t2.name, t2.age);\n\treturn 0;\n}\n```\n程序运行结果：`zhanger,15`\n```c\n#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;\n\nvoid copyTeacher(Teacher2 *to, Teacher2 *from)\n{\n\t*to = *from;\n\tprintf(\"[copyTeacher] %s ,%d\\n\", to->name, to->age);\n}\n\nint main()\n{\n\tTeacher2 t1 = { \"zhanger\",15 };\n\tTeacher2 t2;\n\tmemset(&t2, 0, sizeof(t2));\n\tcopyTeacher(&t2, &t1);//这里需要传址\n\treturn 0;\n}\n```\n\n- 结构体静态数组\n```c\n#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher\n{\n\tchar name[40];\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\t//定义静态数组和使用静态数组\n\n\tTeacher a[5] = { {\"zhangsan\",34},{\"xiaoli\",23},{\"zhaoliu\",12} };\n\tTeacher b[5] = { \"wangqi\",23,\"qianba\",11,\"liuliuliu\",94 };\n\n\t//使用\n\tint i = 0;\n\tfor (i = 0; i < 5; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", a[i].name, a[i].age);\n\n\t}\n\treturn 0;\n}\n```\n\n- 结构体动态数组\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name[40];\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\t//定义和使用动态数组\n\tTeacher *p = (Teacher *)malloc(3 * sizeof(Teacher));\n\tif (p == NULL)\n\t{\n\t\treturn -1;\n\t}\n\n\tchar buf[10];\n\tint i = 0;\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i]. age = 20 + i;\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"num of %d:%s,%d\\n\", i + 1, p[i].name, p[i].age);\n\n\t}\n\tprintf(\"\\n\");\n\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\n\treturn 0;\n}\n```\n程序运行结果：\n`num of 1:name 000,20`\n`num of 2:name 111,21`\n`num of 3:name 222,22`\n\n- 结构体嵌套一级指针问题\n```c\n//结构体变量为普通变量名的时候：\n\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher t;\n\tt.name = (char *)malloc(30); //必须先分配空间\n\tstrcpy(t.name, \"lily\");\n\tt.age = 22;\n\tprintf(\"name = %s ,age = %d\\n\", t.name, t.age);\n\n\tif (t.name != NULL)\n\t{\n\t\tfree(t.name);\n\t\tt.name = NULL;\n\t}\n\n\treturn 0;\n}\n\n```\n程序运行结果：`name = lily ,age = 22`\n```c\n//结构体变量为指针的时候\n\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher));//首先为p分配空间\n\tp->name = (char *)malloc(30); //再为p.name 分配空间\n\tstrcpy(p->name, \"lilei\");\n\tp->age = 22;\n\tprintf(\"name = %s ,age = %d\\n\", p->name, p->age);\n\n\tif (p->name != NULL)\n\t{\n\t\tfree(p->name);\n\t\tp->name = NULL;\n\t}\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\n\n\t}\n\treturn 0;\n}\n```\n程序运行结果为：`name = lilei ,age = 22`\n\n程序运行内存结构图：\n![搜狗截图20181109154732]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181109154732.png)\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher)*3);\n\t\n\tint i = 0;\n\tchar buf[30];\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tp[i].name = (char *)malloc(30);\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i].age = 20 + 2 * i;\n\n\t}\n\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", p[i].name, p[i].age);\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tif (p[i].name != NULL)\n\t\t{\n\t\t\tfree(p[i].name);\n\t\t\tp[i].name = NULL;\n\t\t}\n\n\n\t}\n\n\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\treturn 0;\n}\n```\n程序运行结果：\n`name 000,20`\n`name 111,22`\n`name 222,24`\n\n\n- 结构体做函数参数(例子等于上面程序进行函数封装)\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\n//就是打印的功能\nvoid showTeacher(Teacher *p, int n)\n{\n\tint i = 0;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", p[i].name, p[i].age);\n\t}\n\n}\n\n\nvoid freeTeacher(Teacher *p, int n)\n{\n\tint i = 0;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (p[i].name != NULL)\n\t\t{\n\t\t\tfree(p[i].name);\n\t\t\tp[i].name = NULL;\n\t\t}\n\t}\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\n\n}\n\n\nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher)*3);\n\t\n\tint i = 0;\n\tchar buf[30];\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tp[i].name = (char *)malloc(30);\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i].age = 20 + 2 * i;\n\n\t}\n\n\n\n\tshowTeacher(p, 3);\n\n\t//释放空间\n\tfreeTeacher(p, 3);\n\n\tp = NULL;\n\t\n\treturn 0;\n}\n```\n\n- 结构体嵌套二级指针\n\n- 结构体的点运算符和指针法操作的区别\n- 结构体数组的排序\n- 结构体的深拷贝和浅拷贝\n- 结构体偏移\n- 结构体字节对齐\n\n\n",[[1541900181153,["gjx16@GJXAIOU",[[1,6340,"\n- "]],[6337,6337],[6340,6340]]],[1541900182399,["gjx16@GJXAIOU",[[-1,6338,"- "]],[6340,6340],[6338,6338]]],[1541900290898,["gjx16@GJXAIOU",[[1,6338,"普通变量"]],[6338,6338],[6342,6342]]],[1541900302210,["gjx16@GJXAIOU",[[1,6342,"后面用."]],[6342,6342],[6346,6346]]],[1541900304530,["gjx16@GJXAIOU",[[1,6345,"·"]],[6345,6345],[6346,6346]]],[1541900306417,["gjx16@GJXAIOU",[[-1,6345,"·"]],[6346,6346],[6345,6345]]],[1541900307593,["gjx16@GJXAIOU",[[1,6345,"`"]],[6345,6345],[6346,6346]]],[1541900318427,["gjx16@GJXAIOU",[[1,6347,"`加上成员名"]],[6347,6347],[6353,6353]]],[1541900318871,["gjx16@GJXAIOU",[[1,6354,"\n"]],[6353,6353],[6354,6354]]],[1541900338051,["gjx16@GJXAIOU",[[1,6354,"指针后面使用``"]],[6354,6354],[6362,6362]]],[1541900341161,["gjx16@GJXAIOU",[[1,6361,"->"]],[6361,6361],[6363,6363]]],[1541900351620,["gjx16@GJXAIOU",[[1,6364," 加上成员名"]],[6364,6364],[6370,6370]]],[1541900352103,["gjx16@GJXAIOU",[[1,6371,"\n"]],[6370,6370],[6371,6371]]],[1541900352337,["gjx16@GJXAIOU",[[1,6372,"\n"]],[6371,6371],[6372,6372]]],[1541900377259,["gjx16@GJXAIOU",[[1,5742,"、、"]],[5742,5742],[5744,5744]]],[1541900378294,["gjx16@GJXAIOU",[[-1,5742,"、、"]],[5744,5744],[5742,5742]]],[1541900393788,["gjx16@GJXAIOU",[[1,5742,"//虽然P是指针，但是这里使用的是里面了"]],[5742,5742],[5762,5762]]],[1541900394551,["gjx16@GJXAIOU",[[-1,5761,"了"]],[5762,5762],[5761,5761]]],[1541900405308,["gjx16@GJXAIOU",[[1,5761,"的元素，这里的p[o]"]],[5761,5761],[5772,5772]]],[1541900406960,["gjx16@GJXAIOU",[[-1,5770,"o]"]],[5772,5772],[5770,5770]]],[1541900410026,["gjx16@GJXAIOU",[[1,5770,"i]。"]],[5770,5770],[5773,5773]]],[1541900410903,["gjx16@GJXAIOU",[[-1,5772,"。"]],[5773,5773],[5772,5772]]],[1541900411553,["gjx16@GJXAIOU",[[1,5772,"."]],[5772,5772],[5773,5773]]],[1541900421151,["gjx16@GJXAIOU",[[1,5773,"name 等价于   （）"]],[5773,5773],[5786,5786]]],[1541900424342,["gjx16@GJXAIOU",[[-1,5783," （）"]],[5786,5786],[5783,5783]]],[1541900425679,["gjx16@GJXAIOU",[[1,5783,"()"]],[5783,5783],[5785,5785]]],[1541900427584,["gjx16@GJXAIOU",[[-1,5784,")"],[1,5785,"*"]],[5784,5784],[5785,5785]]],[1541900428976,["gjx16@GJXAIOU",[[1,5785,"()"]],[5785,5785],[5787,5787]]],[1541900441409,["gjx16@GJXAIOU",[[1,5786,"p+i"]],[5786,5786],[5789,5789]]],[1541900446831,["gjx16@GJXAIOU",[[1,5790,").name"]],[5790,5790],[5796,5796]]],[1541901308957,["gjx16@GJXAIOU",[[1,1347,"赋值"]],[1347,1347],[1349,1349]]],[1541901314233,["gjx16@GJXAIOU",[[1,1441,"赋值"]],[1441,1441],[1443,1443]]]],null,"gjx16@GJXAIOU"],["3b583e79-5d81-4287-9507-5ebc8f48dcc9",1542019064192,"# day05 结构体\n\n\n## 一、结构体的基础操作\n\n- 结构体类型定义\n```c\n#include<stdio.h>\n\n//结构体类型的定义\n\t/*\n\t首先struct为关键字\n\tstruct Teacher 结合在一起才是类型\n\t{}后面有；\n\t*/\n\t\n\tstruct Teacher\n\t{\n\t\tchar name[50];\n\t\tint age;\n\t};\n\n\nint main()\n{\n\t\n\t\n\treturn 0;\n}\n```\n\n- 结构体变量定义\n  - 方法一： \n```c\n#include<stdio.h>\n\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n};\n\n\n//结构体变量的定义\n//第一种：先定义类型，在定义变量--最常用的方法\nstruct Teacher t1;  //这里定义的就是全局变量\n\nint main()\n{\n\tstruct Teacher t2;//这里定义的就是局部变量\n\n\treturn 0;\n}\n```\n   \n  - 方法二：方法三：\n```c\n#include<stdio.h>\n//第2种：定义类型的时候同时定义变量\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n}t2,t3;\n\n//第三种：可以不用名字\nstruct \n{\n\tchar name[50];\n\tint age;\n}t2, t3;\n\n\nint main()\n{\n\n\treturn 0;\n}\n```\n\n- 结构体变量的初始化\n```c\n#include<stdio.h>\n//定义的同时进行初始化\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n}t1 = {\"hello\",18};\n\n//或者定义同时进行初始化，这里对应的是另一种定义方法：\nstruct Teacher t2 = { \"hello\",19 };\n\nint main()\n{\n\t//使用\n\tprintf(\"%s,%d\\n\", t2.name, t2.age);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n- 使用typedef该类型名\n```c\n#include<stdio.h>\n\ntypedef struct Teacher2\n{\n\tchar name[3];\n\tint age;\n}Teacher2;//将struct Teacher 定义为Teacher2\n//对应的使用\nTeacher2 t3;\n\nint main()\n{\n\t//使用\n\tprintf(\"%s,%d\\n\", t3.name, t3.age);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n- 点运算符和指针法操作结构体\n```c\n#include<stdio.h>\n\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;//将struct Teacher 定义为Teacher2\n//对应的使用\nTeacher2 t3;\n\nint main()\n{\n\t//使用点运算符进行操作赋值\n\tstrcpy(t3.name, \"xiaoming\");\n\tt3.age = 28;\n\tprintf(\"%s,%d\\n\", t3.name, t3.age);\n\n\t//使用指针操作赋值\n\tstruct Teacher2 *p = NULL; //不能直接向指针赋值，因为这个指针只占四个字节\n\tp = &t3;\n\tstrcpy(p->name, \"xiaoli\");\n\tp->age = 25;\n\tprintf(\"%s,%d\\n\", p->name, p->age);\n\treturn 0;\n}\n```\n\n- 结构体也是一种数据类型，复合类型，自定义类型\n\n\n- 结构体变量相互赋值\n```c\n//在main函数内部，不需要调用函数\n#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;\n\nint main()\n{\n\tTeacher2 t1 = { \"zhanger\",15 };\n\tTeacher2 t2 = t1;//相同类型的两个结构体之间可以进行相互赋值\n\t//把t1成员变量内存的值拷贝给t2成员变量的内存，本质上t1和t2已经没有关系了\n\tprintf(\"%s,%d\\n\", t2.name, t2.age);\n\treturn 0;\n}\n```\n程序运行结果：`zhanger,15`\n```c\n#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;\n\nvoid copyTeacher(Teacher2 *to, Teacher2 *from)\n{\n\t*to = *from;\n\tprintf(\"[copyTeacher] %s ,%d\\n\", to->name, to->age);\n}\n\nint main()\n{\n\tTeacher2 t1 = { \"zhanger\",15 };\n\tTeacher2 t2;\n\tmemset(&t2, 0, sizeof(t2));\n\tcopyTeacher(&t2, &t1);//这里需要传址\n\treturn 0;\n}\n```\n\n- 结构体静态数组\n```c\n#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher\n{\n\tchar name[40];\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\t//定义静态数组和使用静态数组\n\n\tTeacher a[5] = { {\"zhangsan\",34},{\"xiaoli\",23},{\"zhaoliu\",12} };\n\tTeacher b[5] = { \"wangqi\",23,\"qianba\",11,\"liuliuliu\",94 };\n\n\t//使用\n\tint i = 0;\n\tfor (i = 0; i < 5; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", a[i].name, a[i].age);\n\n\t}\n\treturn 0;\n}\n```\n\n- 结构体动态数组\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name[40];\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\t//定义和使用动态数组\n\tTeacher *p = (Teacher *)malloc(3 * sizeof(Teacher));\n\tif (p == NULL)\n\t{\n\t\treturn -1;\n\t}\n\n\tchar buf[10];\n\tint i = 0;\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i]. age = 20 + i;\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"num of %d:%s,%d\\n\", i + 1, p[i].name, p[i].age);\n\n\t}\n\tprintf(\"\\n\");\n\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\n\treturn 0;\n}\n```\n程序运行结果：\n`num of 1:name 000,20`\n`num of 2:name 111,21`\n`num of 3:name 222,22`\n\n- 结构体嵌套一级指针问题\n```c\n//结构体变量为普通变量名的时候：\n\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher t;\n\tt.name = (char *)malloc(30); //必须先分配空间\n\tstrcpy(t.name, \"lily\");\n\tt.age = 22;\n\tprintf(\"name = %s ,age = %d\\n\", t.name, t.age);\n\n\tif (t.name != NULL)\n\t{\n\t\tfree(t.name);\n\t\tt.name = NULL;\n\t}\n\n\treturn 0;\n}\n\n```\n程序运行结果：`name = lily ,age = 22`\n```c\n//结构体变量为指针的时候\n\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher));//首先为p分配空间\n\tp->name = (char *)malloc(30); //再为p.name 分配空间\n\tstrcpy(p->name, \"lilei\");\n\tp->age = 22;\n\tprintf(\"name = %s ,age = %d\\n\", p->name, p->age);\n\n\tif (p->name != NULL)\n\t{\n\t\tfree(p->name);\n\t\tp->name = NULL;\n\t}\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\n\n\t}\n\treturn 0;\n}\n```\n程序运行结果为：`name = lilei ,age = 22`\n\n程序运行内存结构图：\n![搜狗截图20181109154732]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181109154732.png)\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher)*3);\n\t\n\tint i = 0;\n\tchar buf[30];\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tp[i].name = (char *)malloc(30);\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i].age = 20 + 2 * i;\n\n\t}\n\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", p[i].name, p[i].age);\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tif (p[i].name != NULL)\n\t\t{\n\t\t\tfree(p[i].name);\n\t\t\tp[i].name = NULL;\n\t\t}\n\n\n\t}\n\n\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\treturn 0;\n}\n```\n程序运行结果：\n`name 000,20`\n`name 111,22`\n`name 222,24`\n\n\n- 结构体做函数参数(例子等于上面程序进行函数封装)\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\n//就是打印的功能\nvoid showTeacher(Teacher *p, int n)\n{\n\tint i = 0;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", p[i].name, p[i].age);//虽然P是指针，但是这里使用的是里面的元素，这里的p[i].name 等价于  (*(p+i)).name\n\t}\n\n}\n\n\nvoid freeTeacher(Teacher *p, int n)\n{\n\tint i = 0;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (p[i].name != NULL)\n\t\t{\n\t\t\tfree(p[i].name);\n\t\t\tp[i].name = NULL;\n\t\t}\n\t}\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\n\n}\n\n\nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher)*3);\n\t\n\tint i = 0;\n\tchar buf[30];\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tp[i].name = (char *)malloc(30);\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i].age = 20 + 2 * i;\n\n\t}\n\n\n\n\tshowTeacher(p, 3);\n\n\t//释放空间\n\tfreeTeacher(p, 3);\n\n\tp = NULL;\n\t\n\treturn 0;\n}\n```\n\n- 结构体嵌套二级指针\n\n- 结构体的点运算符和指针法操作的区别\n普通变量后面用`.`加上成员名\n指针后面使用`->` 加上成员名\n\n\n- 结构体数组的排序\n- 结构体的深拷贝和浅拷贝\n- 结构体偏移\n- 结构体字节对齐\n\n\n",[[1542019029142,["gjx16@GJXAIOU",[[1,6301,"、、"]],[6301,6301],[6303,6303]]],[1542019030302,["gjx16@GJXAIOU",[[-1,6301,"、、"]],[6303,6303],[6301,6301]]],[1542019037293,["gjx16@GJXAIOU",[[1,6301,"//传地址"]],[6301,6301],[6306,6306]]],[1542019092832,["gjx16@GJXAIOU",[[1,5808,"、、"]],[5808,5808],[5810,5810]]],[1542019093973,["gjx16@GJXAIOU",[[-1,5808,"、、"]],[5810,5810],[5808,5808]]],[1542019095915,["gjx16@GJXAIOU",[[1,5808,"//shi"]],[5808,5808],[5813,5813]]],[1542019096838,["gjx16@GJXAIOU",[[-1,5810,"shi"]],[5813,5813],[5810,5810]]],[1542019102445,["gjx16@GJXAIOU",[[1,5810,"释放功能的实现"]],[5810,5810],[5817,5817]]],[1542019107498,["gjx16@GJXAIOU",[[-1,6021,"\n"]],[6021,6021],[6020,6020]]],[1542019107623,["gjx16@GJXAIOU",[[-1,6020,"\n"]],[6020,6020],[6019,6019]]],[1542019108221,["gjx16@GJXAIOU",[[-1,6019,"\n"]],[6019,6019],[6018,6018]]],[1542019111646,["gjx16@GJXAIOU",[[1,6023,"\n"]],[6022,6022],[6023,6023]]],[1542019254811,["gjx16@GJXAIOU",[[1,6023,"  "]],[6023,6023],[6025,6025]]],[1542021658613,["gjx16@GJXAIOU",[[1,6389,"···"]],[6389,6389],[6392,6392]]],[1542021659663,["gjx16@GJXAIOU",[[-1,6389,"···"]],[6392,6392],[6389,6389]]],[1542021660865,["gjx16@GJXAIOU",[[1,6389,"```"]],[6389,6389],[6392,6392]]],[1542021660899,["gjx16@GJXAIOU",[[1,6392,"language\n```\n"]],[6392,6392],[6392,6400]]],[1542021662345,["gjx16@GJXAIOU",[[-1,6392,"language"],[1,6400,"c"]],[6392,6400],[6393,6393]]],[1542021662715,["gjx16@GJXAIOU",[[1,6394,"\n"]],[6393,6393],[6394,6394]]],[1542021663907,["gjx16@GJXAIOU",[[1,6394,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar **stu;//二维内存\n}Teacher;\n\n\n\n\nint main()\n{\n\tchar **name = NULL;\n\tint n = 3;\n\tint i = 0;\n\tname = (char **)malloc(n * sizeof(char *));\n\t//下面为name 中每一个变量进行赋值\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tname[i] = (char *)malloc(30);\n\t\tstrcpy(name[i], \"lily\");\n\t}\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%s\\n\", name[i]);\n\n\t}\n\n\t//用完需要释放\n\t//先释放里面的\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (name[i] != NULL)\n\t\t{\n\t\t\tfree(name[i]);\n\t\t\tname[i] = NULL;\n\t\t}\n\t}\n\n\t//释放外面的\n\tif (name != NULL)\n\t{\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\n\treturn 0;\n}"]],[6394,6394],[6993,6993]]],[1542022169343,["gjx16@GJXAIOU",[[1,6999,"\n"]],[6997,6997],[6998,6998]]],[1542022173682,["gjx16@GJXAIOU",[[1,6998,"//shi"]],[6998,6998],[7003,7003]]],[1542022174342,["gjx16@GJXAIOU",[[-1,7000,"shi"]],[7003,7003],[7000,7000]]],[1542022178130,["gjx16@GJXAIOU",[[1,7000,"使用第一个"]],[7000,7000],[7005,7005]]],[1542022180498,["gjx16@GJXAIOU",[[1,7007,"\n"]],[7005,7005],[7006,7006]]],[1542022182539,["gjx16@GJXAIOU",[[1,7006,"```"]],[7006,7006],[7009,7009]]],[1542022182574,["gjx16@GJXAIOU",[[1,7009,"language\n```\n"]],[7009,7009],[7009,7017]]],[1542022183484,["gjx16@GJXAIOU",[[-1,7009,"language"],[1,7017,"c"]],[7009,7017],[7010,7010]]],[1542022183719,["gjx16@GJXAIOU",[[1,7011,"\n"]],[7010,7010],[7011,7011]]],[1542022184497,["gjx16@GJXAIOU",[[1,7011,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar **stu;//二维内存\n}Teacher;\n\n\n\n\nint main()\n{\n\t\n\n\t//使用结构体的时候\n\n\t//1.\n\tTeacher t;\n\t//t.stu[3]  //t里面有三个成员\n\n\tint n = 3;\n\tint i = 0;\n\tt.stu = (char **)malloc(n * sizeof(char *));\n\t//下面为name 中每一个变量进行赋值\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tt.stu[i] = (char *)malloc(30);\n\t\tstrcpy(t.stu[i], \"lily\");\n\t}\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%s\\n\", t.stu[i]);\n\n\t}\n\n\t//用完需要释放\n\t//先释放里面的\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (t.stu[i] != NULL)\n\t\t{\n\t\t\tfree(t.stu[i]);\n\t\t\tt.stu[i] = NULL;\n\t\t}\n\t}\n\n\t//释放外面的\n\tif (t.stu != NULL)\n\t{\n\t\tfree(t.stu);\n\t\tt.stu = NULL;\n\t}\n\n\n\n\n\n#if 0\n\t//2.\n\tTeacher *p = NULL;\n\t//p.stu[3]\n\n\n\t//3.\n\tTeacher *q = NULL;\n\t//相当于 Teacher *q[3]  ,然后 q[i].stu[3]\n\n#endif\n\treturn 0;\n}"]],[7011,7011],[7779,7779]]],[1542022189250,["gjx16@GJXAIOU",[[1,7786,"\n"]],[7783,7783],[7784,7784]]],[1542022189377,["gjx16@GJXAIOU",[[1,7787,"\n"]],[7784,7784],[7785,7785]]],[1542022190438,["gjx16@GJXAIOU",[[1,7785,"//"]],[7785,7785],[7787,7787]]],[1542022194495,["gjx16@GJXAIOU",[[1,7787,"使用第二个"]],[7787,7787],[7792,7792]]],[1542022195043,["gjx16@GJXAIOU",[[1,7795,"\n"]],[7792,7792],[7793,7793]]],[1542022196561,["gjx16@GJXAIOU",[[1,7793,"```"]],[7793,7793],[7796,7796]]],[1542022196605,["gjx16@GJXAIOU",[[1,7796,"language\n```\n"]],[7796,7796],[7796,7804]]],[1542022197485,["gjx16@GJXAIOU",[[-1,7796,"language"],[1,7804,"c"]],[7796,7804],[7797,7797]]],[1542022197687,["gjx16@GJXAIOU",[[1,7798,"\n"]],[7797,7797],[7798,7798]]],[1542022197864,["gjx16@GJXAIOU",[[1,7799,"\n"]],[7798,7798],[7799,7799]]],[1542022595026,["gjx16@GJXAIOU",[[1,7798,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar **stu;//二维内存\n}Teacher;\n\n\n\n\nint main()\n{\n//相当于将1中的t.stu 改为p -> stu，然后增加释放P即可\n\n\t//2.\n\tTeacher *p = NULL;\n\t//p->stu[3]\n\n\tp = (Teacher *)malloc(sizeof(Teacher));\n\n\n\tint n = 3;\n\tint i = 0;\n\tp->stu = (char **)malloc(n * sizeof(char *));\n\t//下面为name 中每一个变量进行赋值\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tp->stu[i] = (char *)malloc(30);\n\t\tstrcpy(p->stu[i], \"lily\");\n\t}\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%s\\n\", p->stu[i]);\n\n\t}\n\n\t//用完需要释放\n\t//先释放里面的\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (p->stu[i] != NULL)\n\t\t{\n\t\t\tfree(p->stu[i]);\n\t\t\tp->stu[i] = NULL;\n\t\t}\n\t}\n\n\t//释放外面的\n\tif (p->stu != NULL)\n\t{\n\t\tfree(p->stu);\n\t\tp->stu = NULL;\n\t}\n\t//上面只是释放了stu,还需要释放P\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\n\n\n#if 0\n\t//3.\n\tTeacher *q = NULL;\n\t//相当于 Teacher *q[3]  ,然后 q[i].stu[3]\n\n#endif\n\treturn 0;\n}"]],[7798,7798],[8663,8663]]],[1542022603001,["gjx16@GJXAIOU",[[-1,8573,"#if 0\n\t//3.\n\tTeacher *q = NULL;\n\t//相当于 Teacher *q[3]  ,然后 q[i].stu[3]\n\n#endif"]],[8573,8650],[8573,8573]]],[1542022605407,["gjx16@GJXAIOU",[[-1,8573,"\n"]],[8573,8573],[8572,8572]]],[1542022605547,["gjx16@GJXAIOU",[[-1,8572,"\n"]],[8572,8572],[8571,8571]]],[1542022605767,["gjx16@GJXAIOU",[[-1,8571,"\n"]],[8571,8571],[8570,8570]]],[1542022606167,["gjx16@GJXAIOU",[[-1,8570,"\n"]],[8570,8570],[8569,8569]]],[1542022612377,["gjx16@GJXAIOU",[[-1,7649,"#if 0\n\t//2.\n\tTeacher *p = NULL;\n\t//p.stu[3]\n\n\n\t//3.\n\tTeacher *q = NULL;\n\t//相当于 Teacher *q[3]  ,然后 q[i].stu[3]\n\n#endif\n"]],[7648,7766],[7648,7648]]],[1542022613422,["gjx16@GJXAIOU",[[-1,7648,"\n"]],[7648,7648],[7647,7647]]],[1542022613563,["gjx16@GJXAIOU",[[-1,7647,"\n"]],[7647,7647],[7646,7646]]],[1542022613680,["gjx16@GJXAIOU",[[-1,7646,"\n"]],[7646,7646],[7645,7645]]],[1542022613784,["gjx16@GJXAIOU",[[-1,7645,"\n"]],[7645,7645],[7644,7644]]],[1542022613947,["gjx16@GJXAIOU",[[-1,7644,"\n"]],[7644,7644],[7643,7643]]],[1542024131811,["gjx16@GJXAIOU",[[1,8466,"```"]],[8466,8466],[8469,8469]]],[1542024131851,["gjx16@GJXAIOU",[[1,8469,"language\n```\n"]],[8469,8469],[8469,8477]]],[1542024133034,["gjx16@GJXAIOU",[[-1,8469,"language"],[1,8477,"c"]],[8469,8477],[8470,8470]]],[1542024133256,["gjx16@GJXAIOU",[[1,8471,"\n"]],[8470,8470],[8471,8471]]],[1542024134344,["gjx16@GJXAIOU",[[1,8471,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar **stu;//二维内存\n}Teacher;\n\n\nint main()\n{\n\n\t//之前都是一个元素，现在是三个元素\n\t//3.\n\tTeacher *q = NULL;\n\t//相当于 Teacher q[3]  ,然后 q[i].stu[3]\n\tq = (Teacher *)malloc(sizeof(Teacher) * 3);\n\n\tint i = 0;\n\tint j = 0;\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tq[i].stu = (char **)malloc(3 * sizeof(char *));\n\t\t//相当于现在有三个指针，需要分别进行分配空间\n\t\tfor (j = 0; j < 3; j++)\n\t\t{\n\t\t\tq[i].stu[j] = (char *)malloc(30);\n\t\t\tchar buf[30];\n\t\t\tsprintf(buf, \"name %d%d%d%d\", i, i, j, j);\n\t\t\tstrcpy(q[i].stu[j], buf);\n\t\t}\n\n\t}\n\n\t//将结果进行打印输出\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%s,%s,%s\\n\", q[i].stu[0], q[i].stu[1], q[i].stu[2]);\n\t}\n\n\tprintf(\"\\n\");\n\n\t//释放\n\t//先释放上面的三个指针，然后释放stu,最后释放q\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tfor (j = 0; j < 3; j++)\n\t\t{\n\t\t\t//先释放三个指针\n\t\t\tif (q[i].stu[j] != NULL)\n\t\t\t{\n\t\t\t\tfree(q[i].stu[j]);\n\t\t\t\tq[i].stu[j] = NULL;\n\t\t\t}\n\t\t}\n\n\t\t//然后释放stu\n\t\tif (q[i].stu != NULL)\n\t\t{\n\t\t\tfree(q[i].stu);\n\t\t\tq[i].stu = NULL;\n\t\t}\n\n\t}\n\n\tif (q != NULL)\n\t{\n\t\tfree(q);\n\t\tq = NULL;\n\t}\n\n\treturn 0;\n}"]],[8471,8471],[9500,9500]]],[1542024139734,["gjx16@GJXAIOU",[[1,8465,"//d"]],[8465,8465],[8468,8468]]],[1542024140224,["gjx16@GJXAIOU",[[-1,8467,"d"]],[8468,8468],[8467,8467]]],[1542024145836,["gjx16@GJXAIOU",[[1,8467,"第三种方式"]],[8467,8467],[8472,8472]]],[1542025918544,["gjx16@GJXAIOU",[[1,9513,"、、"]],[9513,9513],[9515,9515]]],[1542025919641,["gjx16@GJXAIOU",[[-1,9513,"、、"]],[9515,9515],[9513,9513]]],[1542025922594,["gjx16@GJXAIOU",[[1,9513,"//jaing "]],[9513,9513],[9521,9521]]],[1542025924091,["gjx16@GJXAIOU",[[-1,9515,"jaing "]],[9521,9521],[9515,9515]]],[1542025937269,["gjx16@GJXAIOU",[[1,9515,"将上面的第三个程序进行"]],[9515,9515],[9526,9526]]],[1542025942807,["gjx16@GJXAIOU",[[1,9526,"函数服装"]],[9526,9526],[9530,9530]]],[1542025943477,["gjx16@GJXAIOU",[[-1,9528,"服装"]],[9530,9530],[9528,9528]]],[1542025947815,["gjx16@GJXAIOU",[[1,9528,"封装得到"]],[9528,9528],[9532,9532]]],[1542025948757,["gjx16@GJXAIOU",[[1,9533,"\n"]],[9532,9532],[9533,9533]]],[1542025950940,["gjx16@GJXAIOU",[[1,9533,"```"]],[9533,9533],[9536,9536]]],[1542025950979,["gjx16@GJXAIOU",[[1,9536,"language\n```\n"]],[9536,9536],[9536,9544]]],[1542025951988,["gjx16@GJXAIOU",[[-1,9536,"language"],[1,9544,"c"]],[9536,9544],[9537,9537]]],[1542025952234,["gjx16@GJXAIOU",[[1,9538,"\n"]],[9537,9537],[9538,9538]]],[1542025953704,["gjx16@GJXAIOU",[[1,9538,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar **stu;//二维内存\n}Teacher;\n\n\n\n//n1表示老师的个数，n2表示学生的个数\nint createTeacher(Teacher **tmp, int n1 ,int n2)\n{\n\t//先做一个判断\n\tif(tmp == NULL)\n\t{\n\t\treturn -1;\n\t}\n\t\n\tTeacher *q = (Teacher *)malloc(sizeof(Teacher) * n1);\n\n\tint i = 0;\n\tint j = 0;\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tq[i].stu = (char **)malloc(n2 * sizeof(char *));\n\t\t//相当于现在有三个指针，需要分别进行分配空间\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tq[i].stu[j] = (char *)malloc(30);\n\t\t\tchar buf[30];\n\t\t\tsprintf(buf, \"name %d%d%d%d\", i, i, j, j);\n\t\t\tstrcpy(q[i].stu[j], buf);\n\t\t}\n\n\t}\n\n\t//间接赋值是指针存在的最大意义\n\t*tmp = q;\n\t\n\n\treturn 0;\n}\n\n\n\n//打印函数\n\nvoid showTeacher(Teacher *q, int n1, int n2)\n{\n\n\tif (q == NULL)\n\t{\n\t\treturn;\n\t}\n\tint i = 0;\n\tint j = 0;\n\t//将结果进行打印输出\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor(j= 0; j< n2; j++)\n\t\t{\n\t\t\tprintf(\"%s\\n\", q[i].stu[j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\n\n}\n\n\n//释放\n//先释放上面的三个指针，然后释放stu,最后释放q\n\nvoid freeTeacher(Teacher **tmp, int n1, int n2)\n{\n\tint i = 0;\n\tint j = 0;\n\tif (tmp == NULL)\n\t{\n\t\treturn;\n\t}\n\tTeacher *q = *tmp;\n\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\t//先释放三个指针\n\t\t\tif (q[i].stu[j] != NULL)\n\t\t\t{\n\t\t\t\tfree(q[i].stu[j]);\n\t\t\t\tq[i].stu[j] = NULL;\n\t\t\t}\n\t\t}\n\n\t\t//然后释放stu\n\t\tif (q[i].stu != NULL)\n\t\t{\n\t\t\tfree(q[i].stu);\n\t\t\tq[i].stu = NULL;\n\t\t}\n\n\t}\n\n\tif (q != NULL)\n\t{\n\t\tfree(q);\n\t\tq = NULL;\n\t\t*tmp = NULL;\n\t}\n\n\n\n\n}\n\n\n\n\nint main()\n{\n\n\t//之前都是一个元素，现在是三个元素\n\t//3.\n\tTeacher *q = NULL;\n\t//相当于 Teacher q[3]  ,然后 q[i].stu[3]\n\tint ret = 0;\n\n\tret = createTeacher(&q, 3,3);\n\t\n\tif (ret != 0)\n\t{\n\t\treturn ret;\n\t}\n\n\n\tshowTeacher(q, 3, 3);\n\n\n\tfreeTeacher(&q, 3, 3);\n\n\n\n\n\t\n\n\n\n\t\n\treturn 0;\n}"]],[9538,9538],[11168,11168]]],[1542028982139,["gjx16@GJXAIOU",[[1,11242,"\n- "]],[11239,11239],[11242,11242]]],[1542028982301,["gjx16@GJXAIOU",[[-1,11240,"- "]],[11242,11242],[11241,11241]]],[1542028984020,["gjx16@GJXAIOU",[[1,11241,"\n"]],[11241,11241],[11242,11242]]],[1542028987410,["gjx16@GJXAIOU",[[1,11240,"···"]],[11240,11240],[11243,11243]]],[1542028988581,["gjx16@GJXAIOU",[[-1,11240,"···"]],[11243,11243],[11240,11240]]],[1542028989018,["gjx16@GJXAIOU",[[-1,11241,"\n"]],[11240,11240],[11239,11239]]],[1542028990298,["gjx16@GJXAIOU",[[1,11240,"- \n"]],[11239,11239],[11242,11242]]],[1542028991292,["gjx16@GJXAIOU",[[-1,11240,"- "]],[11242,11242],[11240,11240]]],[1542028999336,["gjx16@GJXAIOU",[[1,11240,"···"]],[11240,11240],[11243,11243]]],[1542029000282,["gjx16@GJXAIOU",[[-1,11240,"···"]],[11243,11243],[11240,11240]]],[1542029001872,["gjx16@GJXAIOU",[[1,11240,"```"]],[11240,11240],[11243,11243]]],[1542029001911,["gjx16@GJXAIOU",[[1,11243,"language\n```\n"]],[11243,11243],[11243,11251]]],[1542029002838,["gjx16@GJXAIOU",[[-1,11243,"language"],[1,11251,"c"]],[11243,11251],[11244,11244]]],[1542029003062,["gjx16@GJXAIOU",[[1,11245,"\n"]],[11244,11244],[11245,11245]]],[1542029787782,["gjx16@GJXAIOU",[[1,11245,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tint age;\n\tchar **stu;//二维内存\n}Teacher;\n\n\n\n//n1表示老师的个数，n2表示学生的个数\nint createTeacher(Teacher **tmp, int n1 ,int n2)\n{\n\t//先做一个判断\n\tif(tmp == NULL)\n\t{\n\t\treturn -1;\n\t}\n\t\n\tTeacher *q = (Teacher *)malloc(sizeof(Teacher) * n1);\n\n\tint i = 0;\n\tint j = 0;\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tq[i].stu = (char **)malloc(n2 * sizeof(char *));\n\t\t//相当于现在有三个指针，需要分别进行分配空间\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tq[i].stu[j] = (char *)malloc(30);\n\t\t\tchar buf[30];\n\t\t\tsprintf(buf, \"name %d%d%d%d\", i, i, j, j);\n\t\t\tstrcpy(q[i].stu[j], buf);\n\t\t}\n\t\t//首先对age进行赋值\n\t\tq[i].age = 20 + i;\n\t}\n\n\n\n\t//间接赋值是指针存在的最大意义\n\t*tmp = q;\n\t\n\n\n\treturn 0;\n}\n\n\n\n//打印函数\n\nvoid showTeacher(Teacher *q, int n1, int n2)\n{\n\n\tif (q == NULL)\n\t{\n\t\treturn;\n\t}\n\tint i = 0;\n\tint j = 0;\n\t//将结果进行打印输出\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tprintf(\"[age= %d]\\t \", q[i].age);\n\t\tfor(j= 0; j< n2; j++)\n\t\t{\n\t\t\tprintf(\"%s\\n\", q[i].stu[j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\n\n}\n\n\nvoid sortTeacher(Teacher *p, int n)\n{\n\tif (p == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tint i = 0;\n\tint j = 0;\n\tTeacher tmp;\n\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\n\t\tfor (j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (p[i].age < p[j].age)\n\t\t\t{\n\t\t\t\ttmp = p[i];\n\t\t\t\tp[i] = p[j];\n\t\t\t\tp[j] = tmp;\n\t\t\t}\n\n\t\t}\n\t}\n}\n\n\n\n\n\n//释放\n//先释放上面的三个指针，然后释放stu,最后释放q\n\nvoid freeTeacher(Teacher **tmp, int n1, int n2)\n{\n\tint i = 0;\n\tint j = 0;\n\tif (tmp == NULL)\n\t{\n\t\treturn;\n\t}\n\tTeacher *q = *tmp;\n\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\t//先释放三个指针\n\t\t\tif (q[i].stu[j] != NULL)\n\t\t\t{\n\t\t\t\tfree(q[i].stu[j]);\n\t\t\t\tq[i].stu[j] = NULL;\n\t\t\t}\n\t\t}\n\n\t\t//然后释放stu\n\t\tif (q[i].stu != NULL)\n\t\t{\n\t\t\tfree(q[i].stu);\n\t\t\tq[i].stu = NULL;\n\t\t}\n\n\t}\n\n\tif (q != NULL)\n\t{\n\t\tfree(q);\n\t\tq = NULL;\n\t\t*tmp = NULL;\n\t}\n\n\n\n\n}\n\n\n\n\nint main()\n{\n\n\t//之前都是一个元素，现在是三个元素\n\t//3.\n\tTeacher *q = NULL;\n\t//相当于 Teacher q[3]  ,然后 q[i].stu[3]\n\tint ret = 0;\n\n\tret = createTeacher(&q, 3,3);\n\t\n\tif (ret != 0)\n\t{\n\t\treturn ret;\n\t}\n\n\t//排序前\n\tprintf(\"before:\\n\");\n\n\tshowTeacher(q, 3, 3);\n\t\n\tsortTeacher(q, 3);\n\n\t//排序后\n\tprintf(\"after:\\n\");\n\tshowTeacher(q, 3, 3);\n\n\n\tfreeTeacher(&q, 3, 3);\n\n\n\n\n\t\n\n\n\n\t\n\treturn 0;\n}"]],[11245,11245],[13341,13341]]],[1542029790859,["gjx16@GJXAIOU",[[1,11240,"- \n"]],[11239,11239],[11242,11242]]],[1542029792530,["gjx16@GJXAIOU",[[-1,11240,"- "]],[11242,11242],[11240,11240]]],[1542029793643,["gjx16@GJXAIOU",[[1,11240,"jie"]],[11240,11240],[11243,11243]]],[1542029794642,["gjx16@GJXAIOU",[[-1,11240,"jie"]],[11243,11243],[11240,11240]]],[1542029798518,["gjx16@GJXAIOU",[[1,11240,"将结果欧体"]],[11240,11240],[11245,11245]]],[1542029800842,["gjx16@GJXAIOU",[[-1,11241,"结果欧体"]],[11245,11245],[11241,11241]]],[1542029802549,["gjx16@GJXAIOU",[[1,11241,"结构体"]],[11241,11241],[11244,11244]]],[1542029813370,["gjx16@GJXAIOU",[[1,11245,"元素按照从小到大进行来排序"]],[11245,11245],[11258,11258]]],[1542029983308,[null,[[-1,11244,"\n"],[1,11245,"中"],[1,11258,"\n"]],[11244,11244],[11259,11259]]],[1542029983309,[null,[[1,11244,"\n"],[-1,11244,"中"],[-1,11258,"\n"]],[11259,11259],[11244,11244]]],[1542029930818,["gjx16@GJXAIOU",[[-1,13346,"\t"]],[13347,13347],[13346,13346]]],[1542029930989,["gjx16@GJXAIOU",[[-1,13346,"\n"]],[13346,13346],[13345,13345]]],[1542029931227,["gjx16@GJXAIOU",[[-1,13345,"\n"]],[13345,13345],[13344,13344]]],[1542029931578,["gjx16@GJXAIOU",[[-1,13344,"\n"]],[13344,13344],[13343,13343]]],[1542029932018,["gjx16@GJXAIOU",[[-1,13343,"\n"]],[13343,13343],[13342,13342]]],[1542029932418,["gjx16@GJXAIOU",[[-1,13341,"\t"]],[13342,13342],[13341,13341]]],[1542029932786,["gjx16@GJXAIOU",[[-1,13341,"\n"]],[13341,13341],[13340,13340]]],[1542029933214,["gjx16@GJXAIOU",[[-1,13340,"\n"]],[13340,13340],[13339,13339]]],[1542029933626,["gjx16@GJXAIOU",[[-1,13339,"\n"]],[13339,13339],[13338,13338]]],[1542031123321,[null,[[-1,11244,"\n"],[1,11245,"中"],[1,11258,"\n"],[-1,13338,"\n"],[1,13339,"\t"]],[11244,11244],[13340,13340]]],[1542031123321,[null,[[1,11244,"\n"],[-1,11244,"中"],[-1,11258,"\n"],[1,13339,"\n"],[-1,13339,"\t"]],[13340,13340],[11244,11244]]],[1542031069692,["gjx16@GJXAIOU",[[1,13374,"\n- "]],[13371,13371],[13374,13374]]],[1542031070341,["gjx16@GJXAIOU",[[-1,13372,"- "]],[13374,13374],[13373,13373]]],[1542031073141,["gjx16@GJXAIOU",[[1,13372,"··"]],[13372,13372],[13374,13374]]],[1542031073854,["gjx16@GJXAIOU",[[-1,13372,"··"]],[13374,13374],[13372,13372]]],[1542031074931,["gjx16@GJXAIOU",[[1,13372,"```"]],[13372,13372],[13375,13375]]],[1542031074973,["gjx16@GJXAIOU",[[1,13375,"language\n```\n"]],[13375,13375],[13375,13383]]],[1542031076111,["gjx16@GJXAIOU",[[-1,13375,"language"],[1,13383,"c"]],[13375,13383],[13376,13376]]],[1542031076364,["gjx16@GJXAIOU",[[1,13377,"\n"]],[13376,13376],[13377,13377]]],[1542031077998,["gjx16@GJXAIOU",[[1,13377,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar *name;\n\tint age;\n}Teacher;\n\n\n\nint main(void)\n{\n\n\tTeacher t1;\n\tt1.name = (char *)malloc(30);\n\tstrcpy(t1.name, \"lily\");\n\tt1.age = 22;\n\n\tTeacher t2;\n\tt2 = t1;\n\n\tprintf(\"[t2]= %s, %d\\n\", t2.name, t2.age);\n\n\n\t//浅拷贝的内存为同一块，所以只需要释放一次\n\tif (t1.name == NULL)\n\t{\n\t\tfree(t1.name);\n\t\tt1.name = NULL;\n\n\t}\n\n\n\tsystem(\"pause\");\n\n\treturn 0;\n\n}\n\n"]],[13377,13377],[13803,13803]]],[1542031081550,["gjx16@GJXAIOU",[[-1,13377,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar *name;\n\tint age;\n}Teacher;\n\n\n\nint main(void)\n{\n\n\tTeacher t1;\n\tt1.name = (char *)malloc(30);\n\tstrcpy(t1.name, \"lily\");\n\tt1.age = 22;\n\n\tTeacher t2;\n\tt2 = t1;\n\n\tprintf(\"[t2]= %s, %d\\n\", t2.name, t2.age);\n\n\n\t//浅拷贝的内存为同一块，所以只需要释放一次\n\tif (t1.name == NULL)\n\t{\n\t\tfree(t1.name);\n\t\tt1.name = NULL;\n\n\t}\n\n\n\tsystem(\"pause\");\n\n\treturn 0;\n\n}\n\n"]],[13803,13803],[13377,13377]]],[1542031083425,["gjx16@GJXAIOU",[[1,13377,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar *name;\n\tint age;\n}Teacher;\n\n\n\nint main(void)\n{\n\n\tTeacher t1;\n\tt1.name = (char *)malloc(30);\n\tstrcpy(t1.name, \"lily\");\n\tt1.age = 22;\n\n\tTeacher t2;\n\tt2 = t1;\n\n\tprintf(\"[t2]= %s, %d\\n\", t2.name, t2.age);\n\n\n\t//浅拷贝的内存为同一块，所以只需要释放一次\n\tif (t1.name == NULL)\n\t{\n\t\tfree(t1.name);\n\t\tt1.name = NULL;\n\n\t}\n\n\n\tsystem(\"pause\");\n\n\treturn 0;\n\n}\n\n"]],[13377,13377],[13803,13803]]],[1542031088612,["gjx16@GJXAIOU",[[1,13372,"- \n"]],[13371,13371],[13374,13374]]],[1542031090203,["gjx16@GJXAIOU",[[-1,13372,"- "]],[13374,13374],[13372,13372]]],[1542031093690,["gjx16@GJXAIOU",[[1,13372,"//qian"]],[13372,13372],[13378,13378]]],[1542031095043,["gjx16@GJXAIOU",[[-1,13374,"qian"]],[13378,13378],[13374,13374]]],[1542031099417,["gjx16@GJXAIOU",[[1,13374,"浅拷贝"]],[13374,13374],[13377,13377]]],[1542031103301,["gjx16@GJXAIOU",[[1,13815,"\n"]],[13813,13813],[13814,13814]]],[1542031103443,["gjx16@GJXAIOU",[[1,13816,"\n"]],[13814,13814],[13815,13815]]],[1542031104033,["gjx16@GJXAIOU",[[1,13815,"、、"]],[13815,13815],[13817,13817]]],[1542031104681,["gjx16@GJXAIOU",[[-1,13815,"、、"]],[13817,13817],[13815,13815]]],[1542031114522,["gjx16@GJXAIOU",[[1,13815,"//深拷贝：认为"]],[13815,13815],[13823,13823]]],[1542031115096,["gjx16@GJXAIOU",[[-1,13821,"认为"]],[13823,13823],[13821,13821]]],[1542031122939,["gjx16@GJXAIOU",[[1,13821,"认为的增加一块内存"]],[13821,13821],[13830,13830]]],[1542031183324,[null,[[-1,11244,"\n"],[1,11245,"中"],[1,11258,"\n"],[-1,13338,"\n"],[1,13339,"\t"],[-1,13371,"-"],[1,13834,"结"]],[11244,11244],[13835,13835]]],[1542031183324,[null,[[1,11244,"\n"],[-1,11244,"中"],[-1,11258,"\n"],[1,13339,"\n"],[-1,13339,"\t"],[1,13372,"-"],[-1,13834,"结"]],[13835,13835],[11244,11244]]],[1542031131107,["gjx16@GJXAIOU",[[1,13830,"，相当于重新拷贝一份"]],[13830,13830],[13840,13840]]],[1542031137503,["gjx16@GJXAIOU",[[1,13834,"再"]],[13834,13834],[13835,13835]]],[1542031143956,["gjx16@GJXAIOU",[[1,13843,"\n"]],[13841,13841],[13842,13842]]],[1542031146143,["gjx16@GJXAIOU",[[1,13842,"```"]],[13842,13842],[13845,13845]]],[1542031146196,["gjx16@GJXAIOU",[[1,13845,"language\n```\n"]],[13845,13845],[13845,13853]]],[1542031147239,["gjx16@GJXAIOU",[[-1,13845,"language"],[1,13853,"c"]],[13845,13853],[13846,13846]]],[1542031147453,["gjx16@GJXAIOU",[[1,13847,"\n"]],[13846,13846],[13847,13847]]],[1542032143349,[null,[[-1,11244,"\n"],[1,11245,"中"],[1,11258,"\n"],[-1,13338,"\n"],[1,13339,"\t"],[-1,13371,"-"],[1,13856,"结"]],[11244,11244],[13857,13857]]],[1542032143349,[null,[[1,11244,"\n"],[-1,11244,"中"],[-1,11258,"\n"],[1,13339,"\n"],[-1,13339,"\t"],[1,13372,"-"],[-1,13856,"结"]],[13857,13857],[11244,11244]]],[1542032098444,["gjx16@GJXAIOU",[[1,13847,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar *name;\n\tint age;\n}Teacher;\n\n\n\nint main(void)\n{\n\n\tTeacher t1;\n\tt1.name = (char *)malloc(30);\n\tstrcpy(t1.name, \"lily\");\n\tt1.age = 22;\n\n\tTeacher t2;\n\tt2 = t1;//已经复制了一遍\n\n\t//在人为的进行重新拷贝一次\n\tt2.name = (char *)malloc(30);\n\tstrcpy(t2.name, t1.name);\n\n\tprintf(\"[t2]= %s, %d\\n\", t2.name, t2.age);\n\n\n\t\n\tif (t1.name == NULL)\n\t{\n\t\tfree(t1.name);\n\t\tt1.name = NULL;\n\n\t}\n\n\n\tif (t2.name == NULL)\n\t{\n\t\tfree(t2.name);\n\t\tt2.name = NULL;\n\n\t}\n\n\n\tsystem(\"pause\");\n\n\treturn 0;\n\n}\n\n"]],[13847,13847],[14401,14401]]],[1542032100997,["gjx16@GJXAIOU",[[1,13815,"\n"]],[13814,13814],[13815,13815]]],[1542032203348,[null,[[-1,11244,"\n"],[1,11245,"中"],[1,11258,"\n"],[-1,13338,"\n"],[1,13339,"\t"],[-1,13371,"-"],[1,14411,"结"]],[11244,11244],[14412,14412]]],[1542032203348,[null,[[1,11244,"\n"],[-1,11244,"中"],[-1,11258,"\n"],[1,13339,"\n"],[-1,13339,"\t"],[1,13372,"-"],[-1,14411,"结"]],[14412,14412],[11244,11244]]],[1542032189840,["gjx16@GJXAIOU",[[1,13815,"![浅拷贝示例图]($resource/%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%A4%BA%E4%BE%8B%E5%9B%BE.png)"]],[13815,13815],[13895,13895]]],[1542032192511,["gjx16@GJXAIOU",[[1,13895,"\n"]],[13894,13894],[13895,13895]]],[1542032198780,["gjx16@GJXAIOU",[[1,14489,"\n"]],[14486,14486],[14487,14487]]]],null,"gjx16@GJXAIOU"],["acc3574c-1e07-46f0-b0ea-81a6b29c37d5",1542104116947,"# day05 结构体\n\n\n## 一、结构体的基础操作\n\n- 结构体类型定义\n```c\n#include<stdio.h>\n\n//结构体类型的定义\n\t/*\n\t首先struct为关键字\n\tstruct Teacher 结合在一起才是类型\n\t{}后面有；\n\t*/\n\t\n\tstruct Teacher\n\t{\n\t\tchar name[50];\n\t\tint age;\n\t};\n\n\nint main()\n{\n\t\n\t\n\treturn 0;\n}\n```\n\n- 结构体变量定义\n  - 方法一： \n```c\n#include<stdio.h>\n\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n};\n\n\n//结构体变量的定义\n//第一种：先定义类型，在定义变量--最常用的方法\nstruct Teacher t1;  //这里定义的就是全局变量\n\nint main()\n{\n\tstruct Teacher t2;//这里定义的就是局部变量\n\n\treturn 0;\n}\n```\n   \n  - 方法二：方法三：\n```c\n#include<stdio.h>\n//第2种：定义类型的时候同时定义变量\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n}t2,t3;\n\n//第三种：可以不用名字\nstruct \n{\n\tchar name[50];\n\tint age;\n}t2, t3;\n\n\nint main()\n{\n\n\treturn 0;\n}\n```\n\n- 结构体变量的初始化\n```c\n#include<stdio.h>\n//定义的同时进行初始化\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n}t1 = {\"hello\",18};\n\n//或者定义同时进行初始化，这里对应的是另一种定义方法：\nstruct Teacher t2 = { \"hello\",19 };\n\nint main()\n{\n\t//使用\n\tprintf(\"%s,%d\\n\", t2.name, t2.age);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n- 使用typedef该类型名\n```c\n#include<stdio.h>\n\ntypedef struct Teacher2\n{\n\tchar name[3];\n\tint age;\n}Teacher2;//将struct Teacher 定义为Teacher2\n//对应的使用\nTeacher2 t3;\n\nint main()\n{\n\t//使用\n\tprintf(\"%s,%d\\n\", t3.name, t3.age);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n- 点运算符和指针法操作结构体\n```c\n#include<stdio.h>\n\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;//将struct Teacher 定义为Teacher2\n//对应的使用\nTeacher2 t3;\n\nint main()\n{\n\t//使用点运算符进行操作赋值\n\tstrcpy(t3.name, \"xiaoming\");\n\tt3.age = 28;\n\tprintf(\"%s,%d\\n\", t3.name, t3.age);\n\n\t//使用指针操作赋值\n\tstruct Teacher2 *p = NULL; //不能直接向指针赋值，因为这个指针只占四个字节\n\tp = &t3;\n\tstrcpy(p->name, \"xiaoli\");\n\tp->age = 25;\n\tprintf(\"%s,%d\\n\", p->name, p->age);\n\treturn 0;\n}\n```\n\n- 结构体也是一种数据类型，复合类型，自定义类型\n\n\n- 结构体变量相互赋值\n```c\n//在main函数内部，不需要调用函数\n#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;\n\nint main()\n{\n\tTeacher2 t1 = { \"zhanger\",15 };\n\tTeacher2 t2 = t1;//相同类型的两个结构体之间可以进行相互赋值\n\t//把t1成员变量内存的值拷贝给t2成员变量的内存，本质上t1和t2已经没有关系了\n\tprintf(\"%s,%d\\n\", t2.name, t2.age);\n\treturn 0;\n}\n```\n程序运行结果：`zhanger,15`\n```c\n#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;\n\nvoid copyTeacher(Teacher2 *to, Teacher2 *from)\n{\n\t*to = *from;\n\tprintf(\"[copyTeacher] %s ,%d\\n\", to->name, to->age);\n}\n\nint main()\n{\n\tTeacher2 t1 = { \"zhanger\",15 };\n\tTeacher2 t2;\n\tmemset(&t2, 0, sizeof(t2));\n\tcopyTeacher(&t2, &t1);//这里需要传址\n\treturn 0;\n}\n```\n\n- 结构体静态数组\n```c\n#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher\n{\n\tchar name[40];\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\t//定义静态数组和使用静态数组\n\n\tTeacher a[5] = { {\"zhangsan\",34},{\"xiaoli\",23},{\"zhaoliu\",12} };\n\tTeacher b[5] = { \"wangqi\",23,\"qianba\",11,\"liuliuliu\",94 };\n\n\t//使用\n\tint i = 0;\n\tfor (i = 0; i < 5; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", a[i].name, a[i].age);\n\n\t}\n\treturn 0;\n}\n```\n\n- 结构体动态数组\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name[40];\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\t//定义和使用动态数组\n\tTeacher *p = (Teacher *)malloc(3 * sizeof(Teacher));\n\tif (p == NULL)\n\t{\n\t\treturn -1;\n\t}\n\n\tchar buf[10];\n\tint i = 0;\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i]. age = 20 + i;\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"num of %d:%s,%d\\n\", i + 1, p[i].name, p[i].age);\n\n\t}\n\tprintf(\"\\n\");\n\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\n\treturn 0;\n}\n```\n程序运行结果：\n`num of 1:name 000,20`\n`num of 2:name 111,21`\n`num of 3:name 222,22`\n\n- 结构体嵌套一级指针问题\n```c\n//结构体变量为普通变量名的时候：\n\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher t;\n\tt.name = (char *)malloc(30); //必须先分配空间\n\tstrcpy(t.name, \"lily\");\n\tt.age = 22;\n\tprintf(\"name = %s ,age = %d\\n\", t.name, t.age);\n\n\tif (t.name != NULL)\n\t{\n\t\tfree(t.name);\n\t\tt.name = NULL;\n\t}\n\n\treturn 0;\n}\n\n```\n程序运行结果：`name = lily ,age = 22`\n```c\n//结构体变量为指针的时候\n\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher));//首先为p分配空间\n\tp->name = (char *)malloc(30); //再为p.name 分配空间\n\tstrcpy(p->name, \"lilei\");\n\tp->age = 22;\n\tprintf(\"name = %s ,age = %d\\n\", p->name, p->age);\n\n\tif (p->name != NULL)\n\t{\n\t\tfree(p->name);\n\t\tp->name = NULL;\n\t}\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\n\n\t}\n\treturn 0;\n}\n```\n程序运行结果为：`name = lilei ,age = 22`\n\n程序运行内存结构图：\n![搜狗截图20181109154732]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181109154732.png)\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher)*3);\n\t\n\tint i = 0;\n\tchar buf[30];\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tp[i].name = (char *)malloc(30);\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i].age = 20 + 2 * i;\n\n\t}\n\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", p[i].name, p[i].age);\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tif (p[i].name != NULL)\n\t\t{\n\t\t\tfree(p[i].name);\n\t\t\tp[i].name = NULL;\n\t\t}\n\n\n\t}\n\n\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\treturn 0;\n}\n```\n程序运行结果：\n`name 000,20`\n`name 111,22`\n`name 222,24`\n\n\n- 结构体做函数参数(例子等于上面程序进行函数封装)\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\n//就是打印的功能\nvoid showTeacher(Teacher *p, int n)\n{\n\tint i = 0;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", p[i].name, p[i].age);//虽然P是指针，但是这里使用的是里面的元素，这里的p[i].name 等价于  (*(p+i)).name\n\t}\n\n}\n\n//释放功能的实现\nvoid freeTeacher(Teacher *p, int n)\n{\n\tint i = 0;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (p[i].name != NULL)\n\t\t{\n\t\t\tfree(p[i].name);\n\t\t\tp[i].name = NULL;\n\t\t}\n\t}\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n}\n\n\n  \nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher)*3);\n\t\n\tint i = 0;\n\tchar buf[30];\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tp[i].name = (char *)malloc(30);\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i].age = 20 + 2 * i;\n\n\t}\n\n\n\n\tshowTeacher(p, 3);//传地址\n\n\t//释放空间\n\tfreeTeacher(p, 3);\n\n\tp = NULL;\n\t\n\treturn 0;\n}\n```\n\n- 结构体嵌套二级指针\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar **stu;//二维内存\n}Teacher;\n\n\n\n\nint main()\n{\n\tchar **name = NULL;\n\tint n = 3;\n\tint i = 0;\n\tname = (char **)malloc(n * sizeof(char *));\n\t//下面为name 中每一个变量进行赋值\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tname[i] = (char *)malloc(30);\n\t\tstrcpy(name[i], \"lily\");\n\t}\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%s\\n\", name[i]);\n\n\t}\n\n\t//用完需要释放\n\t//先释放里面的\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (name[i] != NULL)\n\t\t{\n\t\t\tfree(name[i]);\n\t\t\tname[i] = NULL;\n\t\t}\n\t}\n\n\t//释放外面的\n\tif (name != NULL)\n\t{\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\n\treturn 0;\n}\n```\n//使用第一个\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar **stu;//二维内存\n}Teacher;\n\n\n\n\nint main()\n{\n\t\n\n\t//使用结构体的时候\n\n\t//1.\n\tTeacher t;\n\t//t.stu[3]  //t里面有三个成员\n\n\tint n = 3;\n\tint i = 0;\n\tt.stu = (char **)malloc(n * sizeof(char *));\n\t//下面为name 中每一个变量进行赋值\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tt.stu[i] = (char *)malloc(30);\n\t\tstrcpy(t.stu[i], \"lily\");\n\t}\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%s\\n\", t.stu[i]);\n\n\t}\n\n\t//用完需要释放\n\t//先释放里面的\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (t.stu[i] != NULL)\n\t\t{\n\t\t\tfree(t.stu[i]);\n\t\t\tt.stu[i] = NULL;\n\t\t}\n\t}\n\n\t//释放外面的\n\tif (t.stu != NULL)\n\t{\n\t\tfree(t.stu);\n\t\tt.stu = NULL;\n\t}\n\treturn 0;\n}\n```\n\n//使用第二个\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar **stu;//二维内存\n}Teacher;\n\n\n\n\nint main()\n{\n//相当于将1中的t.stu 改为p -> stu，然后增加释放P即可\n\n\t//2.\n\tTeacher *p = NULL;\n\t//p->stu[3]\n\n\tp = (Teacher *)malloc(sizeof(Teacher));\n\n\n\tint n = 3;\n\tint i = 0;\n\tp->stu = (char **)malloc(n * sizeof(char *));\n\t//下面为name 中每一个变量进行赋值\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tp->stu[i] = (char *)malloc(30);\n\t\tstrcpy(p->stu[i], \"lily\");\n\t}\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%s\\n\", p->stu[i]);\n\n\t}\n\n\t//用完需要释放\n\t//先释放里面的\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (p->stu[i] != NULL)\n\t\t{\n\t\t\tfree(p->stu[i]);\n\t\t\tp->stu[i] = NULL;\n\t\t}\n\t}\n\n\t//释放外面的\n\tif (p->stu != NULL)\n\t{\n\t\tfree(p->stu);\n\t\tp->stu = NULL;\n\t}\n\t//上面只是释放了stu,还需要释放P\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\treturn 0;\n}\n\n```\n//第三种方式\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar **stu;//二维内存\n}Teacher;\n\n\nint main()\n{\n\n\t//之前都是一个元素，现在是三个元素\n\t//3.\n\tTeacher *q = NULL;\n\t//相当于 Teacher q[3]  ,然后 q[i].stu[3]\n\tq = (Teacher *)malloc(sizeof(Teacher) * 3);\n\n\tint i = 0;\n\tint j = 0;\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tq[i].stu = (char **)malloc(3 * sizeof(char *));\n\t\t//相当于现在有三个指针，需要分别进行分配空间\n\t\tfor (j = 0; j < 3; j++)\n\t\t{\n\t\t\tq[i].stu[j] = (char *)malloc(30);\n\t\t\tchar buf[30];\n\t\t\tsprintf(buf, \"name %d%d%d%d\", i, i, j, j);\n\t\t\tstrcpy(q[i].stu[j], buf);\n\t\t}\n\n\t}\n\n\t//将结果进行打印输出\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%s,%s,%s\\n\", q[i].stu[0], q[i].stu[1], q[i].stu[2]);\n\t}\n\n\tprintf(\"\\n\");\n\n\t//释放\n\t//先释放上面的三个指针，然后释放stu,最后释放q\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tfor (j = 0; j < 3; j++)\n\t\t{\n\t\t\t//先释放三个指针\n\t\t\tif (q[i].stu[j] != NULL)\n\t\t\t{\n\t\t\t\tfree(q[i].stu[j]);\n\t\t\t\tq[i].stu[j] = NULL;\n\t\t\t}\n\t\t}\n\n\t\t//然后释放stu\n\t\tif (q[i].stu != NULL)\n\t\t{\n\t\t\tfree(q[i].stu);\n\t\t\tq[i].stu = NULL;\n\t\t}\n\n\t}\n\n\tif (q != NULL)\n\t{\n\t\tfree(q);\n\t\tq = NULL;\n\t}\n\n\treturn 0;\n}\n```\n\n//将上面的第三个程序进行函数封装得到\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar **stu;//二维内存\n}Teacher;\n\n\n\n//n1表示老师的个数，n2表示学生的个数\nint createTeacher(Teacher **tmp, int n1 ,int n2)\n{\n\t//先做一个判断\n\tif(tmp == NULL)\n\t{\n\t\treturn -1;\n\t}\n\t\n\tTeacher *q = (Teacher *)malloc(sizeof(Teacher) * n1);\n\n\tint i = 0;\n\tint j = 0;\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tq[i].stu = (char **)malloc(n2 * sizeof(char *));\n\t\t//相当于现在有三个指针，需要分别进行分配空间\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tq[i].stu[j] = (char *)malloc(30);\n\t\t\tchar buf[30];\n\t\t\tsprintf(buf, \"name %d%d%d%d\", i, i, j, j);\n\t\t\tstrcpy(q[i].stu[j], buf);\n\t\t}\n\n\t}\n\n\t//间接赋值是指针存在的最大意义\n\t*tmp = q;\n\t\n\n\treturn 0;\n}\n\n\n\n//打印函数\n\nvoid showTeacher(Teacher *q, int n1, int n2)\n{\n\n\tif (q == NULL)\n\t{\n\t\treturn;\n\t}\n\tint i = 0;\n\tint j = 0;\n\t//将结果进行打印输出\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor(j= 0; j< n2; j++)\n\t\t{\n\t\t\tprintf(\"%s\\n\", q[i].stu[j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\n\n}\n\n\n//释放\n//先释放上面的三个指针，然后释放stu,最后释放q\n\nvoid freeTeacher(Teacher **tmp, int n1, int n2)\n{\n\tint i = 0;\n\tint j = 0;\n\tif (tmp == NULL)\n\t{\n\t\treturn;\n\t}\n\tTeacher *q = *tmp;\n\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\t//先释放三个指针\n\t\t\tif (q[i].stu[j] != NULL)\n\t\t\t{\n\t\t\t\tfree(q[i].stu[j]);\n\t\t\t\tq[i].stu[j] = NULL;\n\t\t\t}\n\t\t}\n\n\t\t//然后释放stu\n\t\tif (q[i].stu != NULL)\n\t\t{\n\t\t\tfree(q[i].stu);\n\t\t\tq[i].stu = NULL;\n\t\t}\n\n\t}\n\n\tif (q != NULL)\n\t{\n\t\tfree(q);\n\t\tq = NULL;\n\t\t*tmp = NULL;\n\t}\n\n\n\n\n}\n\n\n\n\nint main()\n{\n\n\t//之前都是一个元素，现在是三个元素\n\t//3.\n\tTeacher *q = NULL;\n\t//相当于 Teacher q[3]  ,然后 q[i].stu[3]\n\tint ret = 0;\n\n\tret = createTeacher(&q, 3,3);\n\t\n\tif (ret != 0)\n\t{\n\t\treturn ret;\n\t}\n\n\n\tshowTeacher(q, 3, 3);\n\n\n\tfreeTeacher(&q, 3, 3);\n\n\n\n\n\t\n\n\n\n\t\n\treturn 0;\n}\n```\n\n- 结构体的点运算符和指针法操作的区别\n普通变量后面用`.`加上成员名\n指针后面使用`->` 加上成员名\n\n\n- 结构体数组的排序\n将结构体中元素按照从小到大进行来排序\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tint age;\n\tchar **stu;//二维内存\n}Teacher;\n\n\n\n//n1表示老师的个数，n2表示学生的个数\nint createTeacher(Teacher **tmp, int n1 ,int n2)\n{\n\t//先做一个判断\n\tif(tmp == NULL)\n\t{\n\t\treturn -1;\n\t}\n\t\n\tTeacher *q = (Teacher *)malloc(sizeof(Teacher) * n1);\n\n\tint i = 0;\n\tint j = 0;\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tq[i].stu = (char **)malloc(n2 * sizeof(char *));\n\t\t//相当于现在有三个指针，需要分别进行分配空间\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tq[i].stu[j] = (char *)malloc(30);\n\t\t\tchar buf[30];\n\t\t\tsprintf(buf, \"name %d%d%d%d\", i, i, j, j);\n\t\t\tstrcpy(q[i].stu[j], buf);\n\t\t}\n\t\t//首先对age进行赋值\n\t\tq[i].age = 20 + i;\n\t}\n\n\n\n\t//间接赋值是指针存在的最大意义\n\t*tmp = q;\n\t\n\n\n\treturn 0;\n}\n\n\n\n//打印函数\n\nvoid showTeacher(Teacher *q, int n1, int n2)\n{\n\n\tif (q == NULL)\n\t{\n\t\treturn;\n\t}\n\tint i = 0;\n\tint j = 0;\n\t//将结果进行打印输出\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tprintf(\"[age= %d]\\t \", q[i].age);\n\t\tfor(j= 0; j< n2; j++)\n\t\t{\n\t\t\tprintf(\"%s\\n\", q[i].stu[j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\n\n}\n\n\nvoid sortTeacher(Teacher *p, int n)\n{\n\tif (p == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tint i = 0;\n\tint j = 0;\n\tTeacher tmp;\n\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\n\t\tfor (j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (p[i].age < p[j].age)\n\t\t\t{\n\t\t\t\ttmp = p[i];\n\t\t\t\tp[i] = p[j];\n\t\t\t\tp[j] = tmp;\n\t\t\t}\n\n\t\t}\n\t}\n}\n\n\n\n\n\n//释放\n//先释放上面的三个指针，然后释放stu,最后释放q\n\nvoid freeTeacher(Teacher **tmp, int n1, int n2)\n{\n\tint i = 0;\n\tint j = 0;\n\tif (tmp == NULL)\n\t{\n\t\treturn;\n\t}\n\tTeacher *q = *tmp;\n\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\t//先释放三个指针\n\t\t\tif (q[i].stu[j] != NULL)\n\t\t\t{\n\t\t\t\tfree(q[i].stu[j]);\n\t\t\t\tq[i].stu[j] = NULL;\n\t\t\t}\n\t\t}\n\n\t\t//然后释放stu\n\t\tif (q[i].stu != NULL)\n\t\t{\n\t\t\tfree(q[i].stu);\n\t\t\tq[i].stu = NULL;\n\t\t}\n\n\t}\n\n\tif (q != NULL)\n\t{\n\t\tfree(q);\n\t\tq = NULL;\n\t\t*tmp = NULL;\n\t}\n\n\n\n\n}\n\n\n\n\nint main()\n{\n\n\t//之前都是一个元素，现在是三个元素\n\t//3.\n\tTeacher *q = NULL;\n\t//相当于 Teacher q[3]  ,然后 q[i].stu[3]\n\tint ret = 0;\n\n\tret = createTeacher(&q, 3,3);\n\t\n\tif (ret != 0)\n\t{\n\t\treturn ret;\n\t}\n\n\t//排序前\n\tprintf(\"before:\\n\");\n\n\tshowTeacher(q, 3, 3);\n\t\n\tsortTeacher(q, 3);\n\n\t//排序后\n\tprintf(\"after:\\n\");\n\tshowTeacher(q, 3, 3);\n\n\n\tfreeTeacher(&q, 3, 3);\n\n\n\treturn 0;\n}\n```\n\n\n- 结构体的深拷贝和浅拷贝\n//浅拷贝\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar *name;\n\tint age;\n}Teacher;\n\n\n\nint main(void)\n{\n\n\tTeacher t1;\n\tt1.name = (char *)malloc(30);\n\tstrcpy(t1.name, \"lily\");\n\tt1.age = 22;\n\n\tTeacher t2;\n\tt2 = t1;\n\n\tprintf(\"[t2]= %s, %d\\n\", t2.name, t2.age);\n\n\n\t//浅拷贝的内存为同一块，所以只需要释放一次\n\tif (t1.name == NULL)\n\t{\n\t\tfree(t1.name);\n\t\tt1.name = NULL;\n\n\t}\n\n\n\tsystem(\"pause\");\n\n\treturn 0;\n\n}\n\n\n```\n\n![浅拷贝示例图]($resource/%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%A4%BA%E4%BE%8B%E5%9B%BE.png)\n\n//深拷贝：认为的增加一块内存，相当于再重新拷贝一份\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar *name;\n\tint age;\n}Teacher;\n\n\n\nint main(void)\n{\n\n\tTeacher t1;\n\tt1.name = (char *)malloc(30);\n\tstrcpy(t1.name, \"lily\");\n\tt1.age = 22;\n\n\tTeacher t2;\n\tt2 = t1;//已经复制了一遍\n\n\t//在人为的进行重新拷贝一次\n\tt2.name = (char *)malloc(30);\n\tstrcpy(t2.name, t1.name);\n\n\tprintf(\"[t2]= %s, %d\\n\", t2.name, t2.age);\n\n\n\t\n\tif (t1.name == NULL)\n\t{\n\t\tfree(t1.name);\n\t\tt1.name = NULL;\n\n\t}\n\n\n\tif (t2.name == NULL)\n\t{\n\t\tfree(t2.name);\n\t\tt2.name = NULL;\n\n\t}\n\n\n\tsystem(\"pause\");\n\n\treturn 0;\n\n}\n\n\n```\n\n\n\n- 结构体偏移\n- 结构体字节对齐\n\n\n",[[1542104097304,["gjx16@GJXAIOU",[[-1,14447,"\n"]],[14447,14447],[14446,14446]]],[1542104100902,["gjx16@GJXAIOU",[[-1,14442,"\n"]],[14442,14442],[14441,14441]]],[1542104105767,["gjx16@GJXAIOU",[[-1,14376,"\n"]],[14376,14376],[14375,14375]]],[1542104114847,["gjx16@GJXAIOU",[[1,14497,"\n- "]],[14494,14494],[14497,14497]]],[1542104115431,["gjx16@GJXAIOU",[[-1,14496," "]],[14497,14497],[14496,14496]]],[1542104119166,["gjx16@GJXAIOU",[[1,14497,"\n- "]],[14494,14494],[14497,14497]]],[1542104120664,["gjx16@GJXAIOU",[[-1,14495,"- "]],[14497,14497],[14495,14495]]],[1542104124401,["gjx16@GJXAIOU",[[1,14495,"不要求"]],[14495,14495],[14498,14498]]],[1542105255849,[null,[[-1,14501,"- "]],[14501,14501],[14501,14501]]],[1542105255849,[null,[[1,14501,"- "]],[14501,14501],[14501,14501]]],[1542105243931,["gjx16@GJXAIOU",[[-1,14495,"不要求"],[1,14498,"·"]],[14495,14495],[14496,14496]]],[1542105244375,["gjx16@GJXAIOU",[[1,14496,"··"]],[14496,14496],[14498,14498]]],[1542105246032,["gjx16@GJXAIOU",[[-1,14495,"···"]],[14498,14498],[14495,14495]]],[1542105247608,["gjx16@GJXAIOU",[[1,14495,"```"]],[14495,14495],[14498,14498]]],[1542105247736,["gjx16@GJXAIOU",[[1,14498,"language\n```\n"]],[14498,14498],[14498,14506]]],[1542105248852,["gjx16@GJXAIOU",[[-1,14498,"language"],[1,14506,"c"]],[14498,14506],[14499,14499]]],[1542105249116,["gjx16@GJXAIOU",[[1,14500,"\n"]],[14499,14499],[14500,14500]]],[1542105251283,["gjx16@GJXAIOU",[[1,14500,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\n\n//结构体类型定义下来之后，内部的成员变量的内存布局就已经确定了\ntypedef struct Teacher\n{\n\tchar name[64];//64\n\tint age;//4\n\tint id;//4\n}Teacher;\n\n\n\nint main(void)\n{\n\n\tTeacher t1;\n\tTeacher *p = NULL;\n\tp = &t1;\n\n\tint n1 = (int)(&p->age) - (int)p;  //这里求的是相对于结构体的首地址的偏移，使用int进行强制转换是因为整数便于比较偏移量\n\tprintf(\"n1 = %d\\n\", n1);\n\n\n\tint n2 = (int)&((Teacher *)0)->age;  //这是相对于绝对0 地址的偏移量\n\tprintf(\"n2 = %d\\n\", n2);\n\t\n\tsystem(\"pause\");\n\n\treturn 0;\n\n}\n\n\n//内存对齐：相当于使用空间换时间\n\n"]],[14500,14500],[14994,14994]]],[1542105315856,[null,[[-1,15002,"- "]],[15002,15002],[15002,15002]]],[1542105315856,[null,[[1,15002,"- "]],[15002,15002],[15002,15002]]],[1542105261104,["gjx16@GJXAIOU",[[-1,14976,"\n"]],[14976,14976],[14975,14975]]],[1542105261268,["gjx16@GJXAIOU",[[-1,14975,"\n"]],[14975,14975],[14974,14974]]],[1542105261763,["gjx16@GJXAIOU",[[-1,14974,"\n"]],[14974,14974],[14973,14973]]],[1542105263701,["gjx16@GJXAIOU",[[1,14979,"\n"]],[14977,14977],[14978,14978]]],[1542105265720,["gjx16@GJXAIOU",[[1,14978,"huan"]],[14978,14978],[14982,14982]]],[1542105267639,["gjx16@GJXAIOU",[[-1,14978,"huan"]],[14982,14982],[14978,14978]]],[1542105281013,["gjx16@GJXAIOU",[[1,14978,"成语"]],[14978,14978],[14980,14980]]],[1542105281935,["gjx16@GJXAIOU",[[-1,14978,"成语"]],[14980,14980],[14978,14978]]],[1542105291634,["gjx16@GJXAIOU",[[1,14978,"程序运行结果："]],[14978,14978],[14985,14985]]],[1542105293621,["gjx16@GJXAIOU",[[1,14987,"\n"]],[14985,14985],[14986,14986]]],[1542105295659,["gjx16@GJXAIOU",[[1,14986,"```"]],[14986,14986],[14989,14989]]],[1542105295776,["gjx16@GJXAIOU",[[1,14989,"language\n```\n"]],[14989,14989],[14989,14997]]],[1542105298522,["gjx16@GJXAIOU",[[-1,14986,"```language"]],[14989,14997],[14986,14986]]],[1542105301314,["gjx16@GJXAIOU",[[-1,14987,"```"]],[14990,14990],[14987,14987]]],[1542105301752,["gjx16@GJXAIOU",[[-1,14989,"\n"]],[14987,14987],[14986,14986]]],[1542105311999,["gjx16@GJXAIOU",[[1,14986,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\n\n//结构体类型定义下来之后，内部的成员变量的内存布局就已经确定了\ntypedef struct Teacher\n{\n\tchar name[64];//64\n\tint age;//4\n\tint id;//4\n}Teacher;\n\n\n\nint main(void)\n{\n\n\tTeacher t1;\n\tTeacher *p = NULL;\n\tp = &t1;\n\n\tint n1 = (int)(&p->age) - (int)p;  //这里求的是相对于结构体的首地址的偏移，使用int进行强制转换是因为整数便于比较偏移量\n\tprintf(\"n1 = %d\\n\", n1);\n\n\n\tint n2 = (int)&((Teacher *)0)->age;  //这是相对于绝对0 地址的偏移量\n\tprintf(\"n2 = %d\\n\", n2);\n\t\n\tsystem(\"pause\");\n\n\treturn 0;\n\n}\n\n\n//内存对齐：相当于使用空间换时间\n\n"]],[14986,14986],[15480,15480]]],[1542105314903,["gjx16@GJXAIOU",[[-1,14986,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\n\n//结构体类型定义下来之后，内部的成员变量的内存布局就已经确定了\ntypedef struct Teacher\n{\n\tchar name[64];//64\n\tint age;//4\n\tint id;//4\n}Teacher;\n\n\n\nint main(void)\n{\n\n\tTeacher t1;\n\tTeacher *p = NULL;\n\tp = &t1;\n\n\tint n1 = (int)(&p->age) - (int)p;  //这里求的是相对于结构体的首地址的偏移，使用int进行强制转换是因为整数便于比较偏移量\n\tprintf(\"n1 = %d\\n\", n1);\n\n\n\tint n2 = (int)&((Teacher *)0)->age;  //这是相对于绝对0 地址的偏移量\n\tprintf(\"n2 = %d\\n\", n2);\n\t\n\tsystem(\"pause\");\n\n\treturn 0;\n\n}\n\n\n//内存对齐：相当于使用空间换时间\n\n"]],[15480,15480],[14986,14986]]],[1542105375868,[null,[[-1,14974,"内存对齐"],[1,14978,"```\n"],[-1,14985,"："],[-1,14989,"相当于使用空间换时间"],[-1,15000,"\n\n```\n\n- "]],[14974,14974],[15000,15000]]],[1542105375868,[null,[[1,14974,"内存对齐"],[-1,14974,"```\n"],[1,14985,"："],[1,14988,"相当于使用空间换时间"],[1,14989,"\n\n```\n\n- "]],[15000,15000],[14974,14974]]],[1542105337432,["gjx16@GJXAIOU",[[1,14986,"n1 = 64\nn2 = 64"]],[14986,14986],[15001,15001]]],[1542105339725,["gjx16@GJXAIOU",[[1,14986,"`"]],[14986,14986],[14987,14987]]],[1542105340968,["gjx16@GJXAIOU",[[1,14994,"`"]],[14994,14994],[14995,14995]]],[1542105341942,["gjx16@GJXAIOU",[[1,14996,"`"]],[14996,14996],[14997,14997]]],[1542105342492,["gjx16@GJXAIOU",[[1,15004,"`"]],[15004,15004],[15005,15005]]],[1542105344963,["gjx16@GJXAIOU",[[-1,15007,"\n"]],[15007,15007],[15006,15006]]],[1542105435861,[null,[[-1,14974,"内存对齐"],[1,14978,"```\n"],[-1,14985,"："],[1,14986,"\n"],[-1,15007,"相当于使用空间换时间\n\n\n```\n\n- "]],[14974,14974],[15007,15007]]],[1542105435861,[null,[[1,14974,"内存对齐"],[-1,14974,"```\n"],[1,14985,"："],[-1,14985,"\n"],[1,15007,"相当于使用空间换时间\n\n\n```\n\n- "]],[15007,15007],[14974,14974]]],[1542105407462,["gjx16@GJXAIOU",[[1,15017,"li"]],[15017,15017],[15019,15019]]],[1542105408160,["gjx16@GJXAIOU",[[-1,15017,"li"]],[15019,15019],[15017,15017]]],[1542105416544,["gjx16@GJXAIOU",[[1,15017,"  - 理论性知识点："]],[15017,15017],[15028,15028]]],[1542105417338,["gjx16@GJXAIOU",[[1,15029,"  - \n"]],[15028,15028],[15033,15033]]],[1542105418943,["gjx16@GJXAIOU",[[-1,15031,"- "]],[15033,15033],[15031,15031]]],[1542105556814,[null,[[-1,14974,"内存对齐"],[1,14978,"```\n"],[-1,14985,"："],[1,14986,"\n"],[-1,15007,"相当于使用空间换时间"],[1,15017,"- 结构体字节对齐\n"],[-1,15033,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[14974,14974],[15033,15033]]],[1542105556814,[null,[[1,14974,"内存对齐"],[-1,14974,"```\n"],[1,14985,"："],[-1,14985,"\n"],[1,15007,"相当于使用空间换时间"],[-1,15007,"- 结构体字节对齐\n"],[1,15033,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[15033,15033],[14974,14974]]],[1542105536219,["gjx16@GJXAIOU",[[1,15032,"![结构体对齐1]($resource/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%901.png)\n![结构体对齐2]($resource/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%902.png)\n![结构体对齐3]($resource/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%903.png)"]],[15031,15031],[15248,15248]]],[1542105539187,["gjx16@GJXAIOU",[[1,15104,"\n"]],[15103,15103],[15104,15104]]],[1542105540180,["gjx16@GJXAIOU",[[1,15177,"\n"]],[15176,15176],[15177,15177]]],[1542105541308,["gjx16@GJXAIOU",[[1,15250,"\n"]],[15249,15249],[15250,15250]]],[1542105544028,["gjx16@GJXAIOU",[[1,15251,"\n"]],[15250,15250],[15251,15251]]],[1542105544188,["gjx16@GJXAIOU",[[1,15252,"\n"]],[15251,15251],[15252,15252]]],[1542105616824,[null,[[-1,14974,"内存对齐"],[1,14978,"```\n"],[-1,14985,"："],[1,14986,"\n"],[-1,15007,"相当于使用空间换时间"],[1,15017,"- 结构体字节对齐\n"],[-1,15253,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[14974,14974],[15253,15253]]],[1542105616824,[null,[[1,14974,"内存对齐"],[-1,14974,"```\n"],[1,14985,"："],[-1,14985,"\n"],[1,15007,"相当于使用空间换时间"],[-1,15007,"- 结构体字节对齐\n"],[1,15253,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[15253,15253],[14974,14974]]],[1542105558187,["gjx16@GJXAIOU",[[1,15016,"（）"]],[15016,15016],[15018,15018]]],[1542105570354,["gjx16@GJXAIOU",[[1,15017,"内存对齐相当于使用空间换区"]],[15017,15017],[15030,15030]]],[1542105571898,["gjx16@GJXAIOU",[[-1,15028,"换区"]],[15030,15030],[15028,15028]]],[1542105575269,["gjx16@GJXAIOU",[[1,15028,"换取时间"]],[15028,15028],[15032,15032]]],[1542106936835,[null,[[-1,14974,"内存对齐"],[1,14978,"```\n"],[-1,14985,"："],[1,14986,"\n"],[-1,15007,"相当于使用空间换时"],[1,15016,"- 结构体字节对齐"],[-1,15033,"间"],[1,15034,"\n"],[-1,15270,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[14974,14974],[15270,15270]]],[1542106936835,[null,[[1,14974,"内存对齐"],[-1,14974,"```\n"],[1,14985,"："],[-1,14985,"\n"],[1,15007,"相当于使用空间换时"],[-1,15007,"- 结构体字节对齐"],[1,15033,"间"],[-1,15033,"\n"],[1,15270,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[15270,15270],[14974,14974]]],[1542106910262,["gjx16@GJXAIOU",[[1,15270,"\n"]],[15269,15269],[15270,15270]]],[1542106910594,["gjx16@GJXAIOU",[[-1,15270,"\n"],[1,15271,"-"]],[15270,15270],[15271,15271]]],[1542106911360,["gjx16@GJXAIOU",[[-1,15270,"-"],[1,15271,"\n"]],[15271,15271],[15270,15270]]],[1542106911530,["gjx16@GJXAIOU",[[-1,15270,"\n"]],[15270,15270],[15269,15269]]],[1542106929155,["gjx16@GJXAIOU",[[1,15269,"   -单一结构体内存大小"]],[15269,15269],[15282,15282]]],[1542106932015,["gjx16@GJXAIOU",[[1,15273," "]],[15273,15273],[15274,15274]]],[1542106935420,["gjx16@GJXAIOU",[[1,15284,"   - \n"]],[15283,15283],[15289,15289]]],[1542106936081,["gjx16@GJXAIOU",[[-1,15288," "]],[15289,15289],[15288,15288]]],[1542106996847,[null,[[-1,14974,"内存对齐"],[1,14978,"```\n"],[-1,14985,"："],[1,14986,"\n"],[-1,15007,"相当于使用空间换时"],[1,15016,"- 结构体字节对齐"],[-1,15033,"间"],[1,15034,"\n"],[-1,15289,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[14974,14974],[15289,15289]]],[1542106996847,[null,[[1,14974,"内存对齐"],[-1,14974,"```\n"],[1,14985,"："],[-1,14985,"\n"],[1,15007,"相当于使用空间换时"],[-1,15007,"- 结构体字节对齐"],[1,15033,"间"],[-1,15033,"\n"],[1,15289,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[15289,15289],[14974,14974]]],[1542106939666,["gjx16@GJXAIOU",[[-1,15285,"  -"]],[15288,15288],[15285,15285]]],[1542106941642,["gjx16@GJXAIOU",[[1,15285,"```"]],[15285,15285],[15288,15288]]],[1542106944237,["gjx16@GJXAIOU",[[-1,15284," ```"]],[15288,15288],[15284,15284]]],[1542106944713,["gjx16@GJXAIOU",[[-1,15284,"\n"]],[15284,15284],[15283,15283]]],[1542106945770,["gjx16@GJXAIOU",[[1,15284,"   - \n"]],[15283,15283],[15289,15289]]],[1542106948247,["gjx16@GJXAIOU",[[-1,15285,"  - "]],[15289,15289],[15285,15285]]],[1542106950838,["gjx16@GJXAIOU",[[1,15285,"```"]],[15285,15285],[15288,15288]]],[1542106953097,["gjx16@GJXAIOU",[[-1,15284," ```"]],[15288,15288],[15284,15284]]],[1542106953704,["gjx16@GJXAIOU",[[-1,15284,"\n"],[1,15285,"`"]],[15284,15284],[15285,15285]]],[1542106954286,["gjx16@GJXAIOU",[[1,15285,"``"]],[15285,15285],[15287,15287]]],[1542106954340,["gjx16@GJXAIOU",[[1,15287,"language\n```\n"]],[15287,15287],[15287,15295]]],[1542106955793,["gjx16@GJXAIOU",[[-1,15287,"language"],[1,15295,"c"]],[15287,15295],[15288,15288]]],[1542106956097,["gjx16@GJXAIOU",[[1,15289,"\n"]],[15288,15288],[15289,15289]]],[1542106957883,["gjx16@GJXAIOU",[[1,15289,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\n//内存对齐：相当于使用空间换时间\n/*\n\t默认情况下：对齐单位以最长的那个，例如double为8，但是数组类型：char[39] 本质上长度为1，只是连起来放置39个，\n\n\t第一个的偏移量为0，相当于是从头开始排\n\n*/\ntypedef struct Teacher\n{\n\t\n\tint age;\n\tdouble haa;\n\tchar name[12];\n\tint id;\n}Teacher;\n\n/*分析：\n首先最长的单位为8\n首先age本身就是4个字节，相当于占4个位置,\n然后haa本身为8个字节，偏移即8*0 = 0,可是0有元素了，所以8*1 = 8 ，可以使用，则中间这4个位置为空\n然后name本身为1个字节，同时以8个长度对齐\n然后id为4个字节，正好补全\n\n\n\nage:      1 1 1 1 * * * *\nhaa:      1 1 1 1 1 1 1 1\nname：1 1 1 1 1 1 1 1\n            1 1 1 1 1 1 1 1\n\n最终结构体占32字节\n*/\n\n\n\nint main(void)\n{\n\tTeacher A;\n\tprintf(\"%d\\n\", sizeof(A));\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n\n\n\n\n"]],[15289,15289],[15909,15909]]],[1542106968539,["gjx16@GJXAIOU",[[-1,15909,"\n"]],[15909,15909],[15908,15908]]],[1542106968695,["gjx16@GJXAIOU",[[-1,15908,"\n"]],[15908,15908],[15907,15907]]],[1542106968850,["gjx16@GJXAIOU",[[-1,15907,"\n"]],[15907,15907],[15906,15906]]],[1542106971857,["gjx16@GJXAIOU",[[1,15911,"\n"]],[15910,15910],[15911,15911]]],[1542106972613,["gjx16@GJXAIOU",[[-1,15911,"\n"],[1,15912,"c"]],[15911,15911],[15912,15912]]],[1542106973367,["gjx16@GJXAIOU",[[1,15912,"heng"]],[15912,15912],[15916,15916]]],[1542106974519,["gjx16@GJXAIOU",[[-1,15912,"heng"]],[15916,15916],[15912,15912]]],[1542106975047,["gjx16@GJXAIOU",[[-1,15911,"c"],[1,15912,"\n"]],[15912,15912],[15911,15911]]],[1542106977224,["gjx16@GJXAIOU",[[-1,15911,"\n"],[1,15912,"程序"]],[15911,15911],[15913,15913]]],[1542106983654,["gjx16@GJXAIOU",[[1,15913,"运行结果：``"]],[15913,15913],[15920,15920]]],[1542106985274,["gjx16@GJXAIOU",[[1,15919,"32"]],[15919,15919],[15921,15921]]],[1542107416841,[null,[[-1,14974,"内存对齐"],[1,14978,"```\n"],[-1,14985,"："],[1,14986,"\n"],[-1,15007,"相当于使用空间换时"],[1,15016,"- 结构体字节对齐"],[-1,15033,"间"],[1,15034,"\n"],[-1,15922,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[14974,14974],[15922,15922]]],[1542107416841,[null,[[1,14974,"内存对齐"],[-1,14974,"```\n"],[1,14985,"："],[-1,14985,"\n"],[1,15007,"相当于使用空间换时"],[-1,15007,"- 结构体字节对齐"],[1,15033,"间"],[-1,15033,"\n"],[1,15922,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[15922,15922],[14974,14974]]],[1542107368280,["gjx16@GJXAIOU",[[1,15753,"    "]],[15753,15753],[15757,15757]]],[1542107371375,["gjx16@GJXAIOU",[[-1,15783,"  "]],[15785,15785],[15783,15783]]],[1542107378719,["gjx16@GJXAIOU",[[-1,15789,"1"]],[15790,15790],[15789,15789]]],[1542107380285,["gjx16@GJXAIOU",[[1,15789,"*"]],[15789,15789],[15790,15790]]],[1542107391370,["gjx16@GJXAIOU",[[-1,15787,"1"]],[15788,15788],[15787,15787]]],[1542107393380,["gjx16@GJXAIOU",[[1,15787,"*"]],[15787,15787],[15788,15788]]],[1542107401408,["gjx16@GJXAIOU",[[-1,15531,"2"]],[15532,15532],[15531,15531]]],[1542107402725,["gjx16@GJXAIOU",[[1,15531,"0"]],[15531,15531],[15532,15532]]],[1542107476847,[null,[[-1,14974,"内存对齐"],[1,14978,"```\n"],[-1,14985,"："],[1,14986,"\n"],[-1,15007,"相当于使用空间换时"],[1,15016,"- 结构体字节对齐"],[-1,15033,"间"],[1,15034,"\n"],[-1,15924,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[14974,14974],[15924,15924]]],[1542107476847,[null,[[1,14974,"内存对齐"],[-1,14974,"```\n"],[1,14985,"："],[-1,14985,"\n"],[1,15007,"相当于使用空间换时"],[-1,15007,"- 结构体字节对齐"],[1,15033,"间"],[-1,15033,"\n"],[1,15924,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[15924,15924],[14974,14974]]],[1542107449587,["gjx16@GJXAIOU",[[1,15924,"\n\n"]],[15924,15924],[15925,15925]]],[1542107449776,["gjx16@GJXAIOU",[[1,15926,"\n"]],[15925,15925],[15926,15926]]],[1542107454114,["gjx16@GJXAIOU",[[1,15926,"  - dang "]],[15926,15926],[15935,15935]]],[1542107456339,["gjx16@GJXAIOU",[[-1,15930,"dang "]],[15935,15935],[15930,15930]]],[1542107464975,["gjx16@GJXAIOU",[[1,15930,"当结构体中嵌套结构体的时候"]],[15930,15930],[15943,15943]]],[1542107465475,["gjx16@GJXAIOU",[[1,15944,"  - \n"]],[15943,15943],[15948,15948]]],[1542107467641,["gjx16@GJXAIOU",[[-1,15944,"  - "]],[15948,15948],[15944,15944]]],[1542107468232,["gjx16@GJXAIOU",[[-1,15944,"\n"]],[15944,15944],[15943,15943]]],[1542107469449,["gjx16@GJXAIOU",[[1,15944,"  - \n"]],[15943,15943],[15948,15948]]],[1542107471851,["gjx16@GJXAIOU",[[-1,15944,"  - "]],[15948,15948],[15944,15944]]],[1542107474038,["gjx16@GJXAIOU",[[-1,15944,"\n"],[1,15945,"`"]],[15944,15944],[15945,15945]]],[1542107474502,["gjx16@GJXAIOU",[[1,15945,"``"]],[15945,15945],[15947,15947]]],[1542107474548,["gjx16@GJXAIOU",[[1,15947,"language\n```\n"]],[15947,15947],[15947,15955]]],[1542107476173,["gjx16@GJXAIOU",[[-1,15947,"language"],[1,15955,"c"]],[15947,15955],[15948,15948]]],[1542107476449,["gjx16@GJXAIOU",[[1,15949,"\n"]],[15948,15948],[15949,15949]]],[1542107536846,[null,[[-1,14974,"内存对齐"],[1,14978,"```\n"],[-1,14985,"："],[1,14986,"\n"],[-1,15007,"相当于使用空间换时"],[1,15016,"- 结构体字节对齐"],[-1,15033,"间"],[1,15034,"\n"],[-1,15954,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[14974,14974],[15954,15954]]],[1542107536846,[null,[[1,14974,"内存对齐"],[-1,14974,"```\n"],[1,14985,"："],[-1,14985,"\n"],[1,15007,"相当于使用空间换时"],[-1,15007,"- 结构体字节对齐"],[1,15033,"间"],[-1,15033,"\n"],[1,15954,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[15954,15954],[14974,14974]]],[1542107481307,["gjx16@GJXAIOU",[[1,15949,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\n//内存对齐：相当于使用空间换时间\n/*\n\t默认情况下：对齐单位以最长的那个，例如double为8，但是数组类型：char[39] 本质上长度为1，只是连起来放置39个，\n\n\t第一个的偏移量为0，相当于是从头开始排\n\n*/\ntypedef struct Teacher\n{\n\t\n\tint age;\n\tdouble haa;\n\tchar name[10];\n\n}Teacher;\n\n\ntypedef struct Teacher1\n{\n\n\tint age;\n\tdouble haa;\n\tchar name[10];\n\n\t//这前面所占的空间，最后一排就是没有占满也要自动的填满，这下面嵌套的结构体从下一行开始的时候添加\n\tTeacher a;\n}Teacher1;\n\n\nint main(void)\n{\n\tTeacher1 A;\n\tprintf(\"%d\\n\", sizeof(A));\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n\n\n\n\n"]],[15949,15949],[16446,16446]]],[1542107896848,[null,[[-1,14974,"内存对齐"],[1,14978,"```\n"],[-1,14985,"："],[1,14986,"\n"],[-1,15007,"相当于使用空间换时"],[1,15016,"- 结构体字节对齐"],[-1,15033,"间"],[1,15034,"\n"],[-1,16451,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[14974,14974],[16451,16451]]],[1542107896848,[null,[[1,14974,"内存对齐"],[-1,14974,"```\n"],[1,14985,"："],[-1,14985,"\n"],[1,15007,"相当于使用空间换时"],[-1,15007,"- 结构体字节对齐"],[1,15033,"间"],[-1,15033,"\n"],[1,16451,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[16451,16451],[14974,14974]]],[1542107894409,["gjx16@GJXAIOU",[[1,15944,"  - \n"]],[15943,15943],[15948,15948]]],[1542108136848,[null,[[-1,14974,"内存对齐"],[1,14978,"```\n"],[-1,14985,"："],[1,14986,"\n"],[-1,15007,"相当于使用空间换时"],[1,15016,"- 结构体字节对齐"],[-1,15033,"间"],[1,15034,"\n"],[-1,16456,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[14974,14974],[16456,16456]]],[1542108136848,[null,[[1,14974,"内存对齐"],[-1,14974,"```\n"],[1,14985,"："],[-1,14985,"\n"],[1,15007,"相当于使用空间换时"],[-1,15007,"- 结构体字节对齐"],[1,15033,"间"],[-1,15033,"\n"],[1,16456,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[16456,16456],[14974,14974]]],[1542108120138,["gjx16@GJXAIOU",[[-1,16451,"\n"]],[16451,16451],[16450,16450]]],[1542108120327,["gjx16@GJXAIOU",[[-1,16450,"\n"]],[16450,16450],[16449,16449]]],[1542108120536,["gjx16@GJXAIOU",[[-1,16449,"\n"]],[16449,16449],[16448,16448]]],[1542108121051,["gjx16@GJXAIOU",[[-1,16448,"\n"]],[16448,16448],[16447,16447]]],[1542108123907,["gjx16@GJXAIOU",[[1,16452,"\n"]],[16451,16451],[16452,16452]]],[1542108125332,["gjx16@GJXAIOU",[[-1,16452,"\n"],[1,16453,"c"]],[16452,16452],[16453,16453]]],[1542108125968,["gjx16@GJXAIOU",[[-1,16452,"c"],[1,16453,"\n"]],[16453,16453],[16452,16452]]],[1542108127911,["gjx16@GJXAIOU",[[-1,16452,"\n"],[1,16453,"程序"]],[16452,16452],[16454,16454]]],[1542108130687,["gjx16@GJXAIOU",[[1,16454,"运行结果："]],[16454,16454],[16459,16459]]],[1542108196863,[null,[[-1,14974,"内存对齐"],[1,14978,"```\n"],[-1,14985,"："],[1,14986,"\n"],[-1,15007,"相当于使用空间换时"],[1,15016,"- 结构体字节对齐"],[-1,15033,"间"],[1,15034,"\n"],[-1,16459,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[14974,14974],[16459,16459]]],[1542108196863,[null,[[1,14974,"内存对齐"],[-1,14974,"```\n"],[1,14985,"："],[-1,14985,"\n"],[1,15007,"相当于使用空间换时"],[-1,15007,"- 结构体字节对齐"],[1,15033,"间"],[-1,15033,"\n"],[1,16459,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[16459,16459],[14974,14974]]],[1542108138000,["gjx16@GJXAIOU",[[1,16459,"``"]],[16459,16459],[16461,16461]]],[1542108143330,["gjx16@GJXAIOU",[[1,16460,"64"]],[16460,16460],[16462,16462]]],[1542108145197,["gjx16@GJXAIOU",[[1,16463,"\n\n"]],[16463,16463],[16464,16464]]],[1542108145359,["gjx16@GJXAIOU",[[1,16465,"\n"]],[16464,16464],[16465,16465]]],[1542108145522,["gjx16@GJXAIOU",[[1,16466,"\n"]],[16465,16465],[16466,16466]]],[1542108436856,[null,[[-1,14974,"内存对齐"],[1,14978,"```\n"],[-1,14985,"："],[1,14986,"\n"],[-1,15007,"相当于使用空间换时"],[1,15016,"- 结构体字节对齐"],[-1,15033,"间"],[1,15034,"\n"],[-1,16467,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[14974,14974],[16467,16467]]],[1542108436856,[null,[[1,14974,"内存对齐"],[-1,14974,"```\n"],[1,14985,"："],[-1,14985,"\n"],[1,15007,"相当于使用空间换时"],[-1,15007,"- 结构体字节对齐"],[1,15033,"间"],[-1,15033,"\n"],[1,16467,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[16467,16467],[14974,14974]]],[1542108398811,["gjx16@GJXAIOU",[[1,16467,"\n"]],[16464,16464],[16465,16465]]],[1542108398981,["gjx16@GJXAIOU",[[1,16468,"\n"]],[16465,16465],[16466,16466]]],[1542108402598,["gjx16@GJXAIOU",[[1,16466,"- heng"]],[16466,16466],[16472,16472]]],[1542108404729,["gjx16@GJXAIOU",[[-1,16468,"heng"]],[16472,16472],[16468,16468]]],[1542108407346,["gjx16@GJXAIOU",[[1,16468,"gengju"]],[16468,16468],[16474,16474]]],[1542108411029,["gjx16@GJXAIOU",[[-1,16468,"gengju"]],[16474,16474],[16468,16468]]],[1542108420814,["gjx16@GJXAIOU",[[1,16468,"根据指定的长度进行对齐"]],[16468,16468],[16479,16479]]],[1542108421266,["gjx16@GJXAIOU",[[1,16480,"- \n"]],[16479,16479],[16482,16482]]],[1542108424083,["gjx16@GJXAIOU",[[1,16480,"  "]],[16480,16480],[16482,16482]]],[1542108425188,["gjx16@GJXAIOU",[[1,16484," "]],[16483,16483],[16484,16484]]],[1542108436336,["gjx16@GJXAIOU",[[1,16484,"如果指定长度小于结构体"]],[16484,16484],[16495,16495]]],[1542108496860,[null,[[-1,14974,"内存对齐"],[1,14978,"```\n"],[-1,14985,"："],[1,14986,"\n"],[-1,15007,"相当于使用空间换时"],[1,15016,"- 结构体字节对齐"],[-1,15033,"间"],[1,15034,"\n"],[-1,16499,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[14974,14974],[16499,16499]]],[1542108496860,[null,[[1,14974,"内存对齐"],[-1,14974,"```\n"],[1,14985,"："],[-1,14985,"\n"],[1,15007,"相当于使用空间换时"],[-1,15007,"- 结构体字节对齐"],[1,15033,"间"],[-1,15033,"\n"],[1,16499,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[16499,16499],[14974,14974]]],[1542108454647,["gjx16@GJXAIOU",[[1,16495,"中最长的长度：按照指定长度对齐\n  -"]],[16495,16495],[16514,16514]]],[1542108454873,["gjx16@GJXAIOU",[[1,16515," "]],[16514,16514],[16515,16515]]],[1542108495301,["gjx16@GJXAIOU",[[1,16515,"如果指定的长度大于结构体中最长的长度：按照结构体中最长的长度进行"]],[16515,16515],[16547,16547]]],[1542108556859,[null,[[-1,14974,"内存对齐"],[1,14978,"```\n"],[-1,14985,"："],[1,14986,"\n"],[-1,15007,"相当于使用空间换时"],[1,15016,"- 结构体字节对齐"],[-1,15033,"间"],[1,15034,"\n"],[-1,16551,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[14974,14974],[16551,16551]]],[1542108556859,[null,[[1,14974,"内存对齐"],[-1,14974,"```\n"],[1,14985,"："],[-1,14985,"\n"],[1,15007,"相当于使用空间换时"],[-1,15007,"- 结构体字节对齐"],[1,15033,"间"],[-1,15033,"\n"],[1,16551,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[16551,16551],[14974,14974]]],[1542108497320,["gjx16@GJXAIOU",[[1,16547,"对齐"]],[16547,16547],[16549,16549]]],[1542108676877,[null,[[-1,14974,"内存对齐"],[1,14978,"```\n"],[-1,14985,"："],[1,14986,"\n"],[-1,15007,"相当于使用空间换时"],[1,15016,"- 结构体字节对齐"],[-1,15033,"间"],[1,15034,"\n"],[-1,16553,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[14974,14974],[16553,16553]]],[1542108676877,[null,[[1,14974,"内存对齐"],[-1,14974,"```\n"],[1,14985,"："],[-1,14985,"\n"],[1,15007,"相当于使用空间换时"],[-1,15007,"- 结构体字节对齐"],[1,15033,"间"],[-1,15033,"\n"],[1,16553,"\n```\n\n- - 结构体字节对齐\n\n\n"]],[16553,16553],[14974,14974]]],[1542108621410,["gjx16@GJXAIOU",[[1,16551,"  - \n"]],[16550,16550],[16555,16555]]],[1542108625841,["gjx16@GJXAIOU",[[-1,16551,"  - "]],[16555,16555],[16551,16551]]],[1542108628409,["gjx16@GJXAIOU",[[1,16551,"****"]],[16551,16551],[16553,16553]]],[1542108635219,["gjx16@GJXAIOU",[[1,16553,"示例程序："]],[16553,16553],[16558,16558]]],[1542108639966,["gjx16@GJXAIOU",[[1,16563,"\n"]],[16560,16560],[16561,16561]]],[1542108641992,["gjx16@GJXAIOU",[[1,16561,"```"]],[16561,16561],[16564,16564]]],[1542108642108,["gjx16@GJXAIOU",[[1,16564,"language\n```\n"]],[16564,16564],[16564,16572]]],[1542108643361,["gjx16@GJXAIOU",[[-1,16564,"language"],[1,16572,"c"]],[16564,16572],[16565,16565]]],[1542108643947,["gjx16@GJXAIOU",[[1,16566,"\n"]],[16565,16565],[16566,16566]]],[1542108645674,["gjx16@GJXAIOU",[[1,16566,"#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\n\n# pragma pack(2)  //以2个字节进行对齐（指定的长度必须为2的倍数）\n\ntypedef struct Teacher\n{\n\t\n\tint age;\n\tdouble haa;\n\tchar name[10];\n\n}Teacher;\n\n\nint main(void)\n{\n\tTeacher A;\n\tprintf(\"%d\\n\", sizeof(A));\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n\n\n\n\n"]],[16566,16566],[16853,16853]]],[1542108652535,["gjx16@GJXAIOU",[[1,16479,"()"]],[16479,16479],[16481,16481]]],[1542108666319,["gjx16@GJXAIOU",[[1,16480,"指定的长度必须为2的倍数"]],[16480,16480],[16492,16492]]],[1542108671321,["gjx16@GJXAIOU",[[-1,16867,"\n"]],[16867,16867],[16866,16866]]],[1542108671522,["gjx16@GJXAIOU",[[-1,16866,"\n"]],[16866,16866],[16865,16865]]],[1542108671717,["gjx16@GJXAIOU",[[-1,16865,"\n"]],[16865,16865],[16864,16864]]],[1542108672210,["gjx16@GJXAIOU",[[-1,16864,"\n"]],[16864,16864],[16863,16863]]]],null,"gjx16@GJXAIOU"],["70205d95-cbf5-4491-85ab-20a20d77bc63",1556458493637,"# day05 结构体\n\n\n## 一、结构体的基础操作\n\n- 结构体类型定义\n```c\n#include<stdio.h>\n\n//结构体类型的定义\n\t/*\n\t首先struct为关键字\n\tstruct Teacher 结合在一起才是类型\n\t{}后面有；\n\t*/\n\t\n\tstruct Teacher\n\t{\n\t\tchar name[50];\n\t\tint age;\n\t};\n\n\nint main()\n{\n\t\n\t\n\treturn 0;\n}\n```\n\n- 结构体变量定义\n  - 方法一： \n```c\n#include<stdio.h>\n\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n};\n\n\n//结构体变量的定义\n//第一种：先定义类型，在定义变量--最常用的方法\nstruct Teacher t1;  //这里定义的就是全局变量\n\nint main()\n{\n\tstruct Teacher t2;//这里定义的就是局部变量\n\n\treturn 0;\n}\n```\n   \n  - 方法二：方法三：\n```c\n#include<stdio.h>\n//第2种：定义类型的时候同时定义变量\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n}t2,t3;\n\n//第三种：可以不用名字\nstruct \n{\n\tchar name[50];\n\tint age;\n}t2, t3;\n\n\nint main()\n{\n\n\treturn 0;\n}\n```\n\n- 结构体变量的初始化\n```c\n#include<stdio.h>\n//定义的同时进行初始化\nstruct Teacher\n{\n\tchar name[50];\n\tint age;\n}t1 = {\"hello\",18};\n\n//或者定义同时进行初始化，这里对应的是另一种定义方法：\nstruct Teacher t2 = { \"hello\",19 };\n\nint main()\n{\n\t//使用\n\tprintf(\"%s,%d\\n\", t2.name, t2.age);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n- 使用typedef该类型名\n```c\n#include<stdio.h>\n\ntypedef struct Teacher2\n{\n\tchar name[3];\n\tint age;\n}Teacher2;//将struct Teacher 定义为Teacher2\n//对应的使用\nTeacher2 t3;\n\nint main()\n{\n\t//使用\n\tprintf(\"%s,%d\\n\", t3.name, t3.age);\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n- 点运算符和指针法操作结构体\n```c\n#include<stdio.h>\n\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;//将struct Teacher 定义为Teacher2\n//对应的使用\nTeacher2 t3;\n\nint main()\n{\n\t//使用点运算符进行操作赋值\n\tstrcpy(t3.name, \"xiaoming\");\n\tt3.age = 28;\n\tprintf(\"%s,%d\\n\", t3.name, t3.age);\n\n\t//使用指针操作赋值\n\tstruct Teacher2 *p = NULL; //不能直接向指针赋值，因为这个指针只占四个字节\n\tp = &t3;\n\tstrcpy(p->name, \"xiaoli\");\n\tp->age = 25;\n\tprintf(\"%s,%d\\n\", p->name, p->age);\n\treturn 0;\n}\n```\n\n- 结构体也是一种数据类型，复合类型，自定义类型\n\n\n- 结构体变量相互赋值\n```c\n//在main函数内部，不需要调用函数\n#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;\n\nint main()\n{\n\tTeacher2 t1 = { \"zhanger\",15 };\n\tTeacher2 t2 = t1;//相同类型的两个结构体之间可以进行相互赋值\n\t//把t1成员变量内存的值拷贝给t2成员变量的内存，本质上t1和t2已经没有关系了\n\tprintf(\"%s,%d\\n\", t2.name, t2.age);\n\treturn 0;\n}\n```\n程序运行结果：`zhanger,15`\n```c\n#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher2\n{\n\tchar name[40];\n\tint age;\n}Teacher2;\n\nvoid copyTeacher(Teacher2 *to, Teacher2 *from)\n{\n\t*to = *from;\n\tprintf(\"[copyTeacher] %s ,%d\\n\", to->name, to->age);\n}\n\nint main()\n{\n\tTeacher2 t1 = { \"zhanger\",15 };\n\tTeacher2 t2;\n\tmemset(&t2, 0, sizeof(t2));\n\tcopyTeacher(&t2, &t1);//这里需要传址\n\treturn 0;\n}\n```\n\n- 结构体静态数组\n```c\n#include<stdio.h>\n//结构体只是另一个类型，还没有分配空间，\n//只有根据其类型定义变量的时候，才进行分配空间，有空间之后才能赋值\ntypedef struct Teacher\n{\n\tchar name[40];\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\t//定义静态数组和使用静态数组\n\n\tTeacher a[5] = { {\"zhangsan\",34},{\"xiaoli\",23},{\"zhaoliu\",12} };\n\tTeacher b[5] = { \"wangqi\",23,\"qianba\",11,\"liuliuliu\",94 };\n\n\t//使用\n\tint i = 0;\n\tfor (i = 0; i < 5; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", a[i].name, a[i].age);\n\n\t}\n\treturn 0;\n}\n```\n\n- 结构体动态数组\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name[40];\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\t//定义和使用动态数组\n\tTeacher *p = (Teacher *)malloc(3 * sizeof(Teacher));\n\tif (p == NULL)\n\t{\n\t\treturn -1;\n\t}\n\n\tchar buf[10];\n\tint i = 0;\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i]. age = 20 + i;\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"num of %d:%s,%d\\n\", i + 1, p[i].name, p[i].age);\n\n\t}\n\tprintf(\"\\n\");\n\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\n\treturn 0;\n}\n```\n程序运行结果：\n`num of 1:name 000,20`\n`num of 2:name 111,21`\n`num of 3:name 222,22`\n\n- 结构体嵌套一级指针问题\n```c\n//结构体变量为普通变量名的时候：\n\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher t;\n\tt.name = (char *)malloc(30); //必须先分配空间\n\tstrcpy(t.name, \"lily\");\n\tt.age = 22;\n\tprintf(\"name = %s ,age = %d\\n\", t.name, t.age);\n\n\tif (t.name != NULL)\n\t{\n\t\tfree(t.name);\n\t\tt.name = NULL;\n\t}\n\n\treturn 0;\n}\n\n```\n程序运行结果：`name = lily ,age = 22`\n```c\n//结构体变量为指针的时候\n\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher));//首先为p分配空间\n\tp->name = (char *)malloc(30); //再为p.name 分配空间\n\tstrcpy(p->name, \"lilei\");\n\tp->age = 22;\n\tprintf(\"name = %s ,age = %d\\n\", p->name, p->age);\n\n\tif (p->name != NULL)\n\t{\n\t\tfree(p->name);\n\t\tp->name = NULL;\n\t}\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\n\n\t}\n\treturn 0;\n}\n```\n程序运行结果为：`name = lilei ,age = 22`\n\n程序运行内存结构图：\n![搜狗截图20181109154732]($resource/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20181109154732.png)\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher)*3);\n\t\n\tint i = 0;\n\tchar buf[30];\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tp[i].name = (char *)malloc(30);\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i].age = 20 + 2 * i;\n\n\t}\n\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", p[i].name, p[i].age);\n\t}\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tif (p[i].name != NULL)\n\t\t{\n\t\t\tfree(p[i].name);\n\t\t\tp[i].name = NULL;\n\t\t}\n\n\n\t}\n\n\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\treturn 0;\n}\n```\n程序运行结果：\n`name 000,20`\n`name 111,22`\n`name 222,24`\n\n\n- 结构体做函数参数(例子等于上面程序进行函数封装)\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar name1[40];//这里name已经分配了40个字节的空间了\n\tchar *name;//这时候并没有分配空间\n\tint age;\n}Teacher;\n\n\n//就是打印的功能\nvoid showTeacher(Teacher *p, int n)\n{\n\tint i = 0;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%s,%d\\n\", p[i].name, p[i].age);//虽然P是指针，但是这里使用的是里面的元素，这里的p[i].name 等价于  (*(p+i)).name\n\t}\n\n}\n\n//释放功能的实现\nvoid freeTeacher(Teacher *p, int n)\n{\n\tint i = 0;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (p[i].name != NULL)\n\t\t{\n\t\t\tfree(p[i].name);\n\t\t\tp[i].name = NULL;\n\t\t}\n\t}\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n}\n\n\n  \nint main()\n{\n\tTeacher *p = NULL;\n\tp = (Teacher *)malloc(sizeof(Teacher)*3);\n\t\n\tint i = 0;\n\tchar buf[30];\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tp[i].name = (char *)malloc(30);\n\t\tsprintf(buf, \"name %d%d%d\", i, i, i);\n\t\tstrcpy(p[i].name, buf);\n\t\tp[i].age = 20 + 2 * i;\n\n\t}\n\n\n\n\tshowTeacher(p, 3);//传地址\n\n\t//释放空间\n\tfreeTeacher(p, 3);\n\n\tp = NULL;\n\t\n\treturn 0;\n}\n```\n\n- 结构体嵌套二级指针\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar **stu;//二维内存\n}Teacher;\n\n\n\n\nint main()\n{\n\tchar **name = NULL;\n\tint n = 3;\n\tint i = 0;\n\tname = (char **)malloc(n * sizeof(char *));\n\t//下面为name 中每一个变量进行赋值\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tname[i] = (char *)malloc(30);\n\t\tstrcpy(name[i], \"lily\");\n\t}\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%s\\n\", name[i]);\n\n\t}\n\n\t//用完需要释放\n\t//先释放里面的\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (name[i] != NULL)\n\t\t{\n\t\t\tfree(name[i]);\n\t\t\tname[i] = NULL;\n\t\t}\n\t}\n\n\t//释放外面的\n\tif (name != NULL)\n\t{\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\n\treturn 0;\n}\n```\n//使用第一个\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar **stu;//二维内存\n}Teacher;\n\n\n\n\nint main()\n{\n\t\n\n\t//使用结构体的时候\n\n\t//1.\n\tTeacher t;\n\t//t.stu[3]  //t里面有三个成员\n\n\tint n = 3;\n\tint i = 0;\n\tt.stu = (char **)malloc(n * sizeof(char *));\n\t//下面为name 中每一个变量进行赋值\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tt.stu[i] = (char *)malloc(30);\n\t\tstrcpy(t.stu[i], \"lily\");\n\t}\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%s\\n\", t.stu[i]);\n\n\t}\n\n\t//用完需要释放\n\t//先释放里面的\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (t.stu[i] != NULL)\n\t\t{\n\t\t\tfree(t.stu[i]);\n\t\t\tt.stu[i] = NULL;\n\t\t}\n\t}\n\n\t//释放外面的\n\tif (t.stu != NULL)\n\t{\n\t\tfree(t.stu);\n\t\tt.stu = NULL;\n\t}\n\treturn 0;\n}\n```\n\n//使用第二个\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar **stu;//二维内存\n}Teacher;\n\n\n\n\nint main()\n{\n//相当于将1中的t.stu 改为p -> stu，然后增加释放P即可\n\n\t//2.\n\tTeacher *p = NULL;\n\t//p->stu[3]\n\n\tp = (Teacher *)malloc(sizeof(Teacher));\n\n\n\tint n = 3;\n\tint i = 0;\n\tp->stu = (char **)malloc(n * sizeof(char *));\n\t//下面为name 中每一个变量进行赋值\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tp->stu[i] = (char *)malloc(30);\n\t\tstrcpy(p->stu[i], \"lily\");\n\t}\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tprintf(\"%s\\n\", p->stu[i]);\n\n\t}\n\n\t//用完需要释放\n\t//先释放里面的\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (p->stu[i] != NULL)\n\t\t{\n\t\t\tfree(p->stu[i]);\n\t\t\tp->stu[i] = NULL;\n\t\t}\n\t}\n\n\t//释放外面的\n\tif (p->stu != NULL)\n\t{\n\t\tfree(p->stu);\n\t\tp->stu = NULL;\n\t}\n\t//上面只是释放了stu,还需要释放P\n\n\tif (p != NULL)\n\t{\n\t\tfree(p);\n\t\tp = NULL;\n\t}\n\n\treturn 0;\n}\n\n```\n//第三种方式\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar **stu;//二维内存\n}Teacher;\n\n\nint main()\n{\n\n\t//之前都是一个元素，现在是三个元素\n\t//3.\n\tTeacher *q = NULL;\n\t//相当于 Teacher q[3]  ,然后 q[i].stu[3]\n\tq = (Teacher *)malloc(sizeof(Teacher) * 3);\n\n\tint i = 0;\n\tint j = 0;\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tq[i].stu = (char **)malloc(3 * sizeof(char *));\n\t\t//相当于现在有三个指针，需要分别进行分配空间\n\t\tfor (j = 0; j < 3; j++)\n\t\t{\n\t\t\tq[i].stu[j] = (char *)malloc(30);\n\t\t\tchar buf[30];\n\t\t\tsprintf(buf, \"name %d%d%d%d\", i, i, j, j);\n\t\t\tstrcpy(q[i].stu[j], buf);\n\t\t}\n\n\t}\n\n\t//将结果进行打印输出\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tprintf(\"%s,%s,%s\\n\", q[i].stu[0], q[i].stu[1], q[i].stu[2]);\n\t}\n\n\tprintf(\"\\n\");\n\n\t//释放\n\t//先释放上面的三个指针，然后释放stu,最后释放q\n\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tfor (j = 0; j < 3; j++)\n\t\t{\n\t\t\t//先释放三个指针\n\t\t\tif (q[i].stu[j] != NULL)\n\t\t\t{\n\t\t\t\tfree(q[i].stu[j]);\n\t\t\t\tq[i].stu[j] = NULL;\n\t\t\t}\n\t\t}\n\n\t\t//然后释放stu\n\t\tif (q[i].stu != NULL)\n\t\t{\n\t\t\tfree(q[i].stu);\n\t\t\tq[i].stu = NULL;\n\t\t}\n\n\t}\n\n\tif (q != NULL)\n\t{\n\t\tfree(q);\n\t\tq = NULL;\n\t}\n\n\treturn 0;\n}\n```\n\n//将上面的第三个程序进行函数封装得到\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar **stu;//二维内存\n}Teacher;\n\n\n\n//n1表示老师的个数，n2表示学生的个数\nint createTeacher(Teacher **tmp, int n1 ,int n2)\n{\n\t//先做一个判断\n\tif(tmp == NULL)\n\t{\n\t\treturn -1;\n\t}\n\t\n\tTeacher *q = (Teacher *)malloc(sizeof(Teacher) * n1);\n\n\tint i = 0;\n\tint j = 0;\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tq[i].stu = (char **)malloc(n2 * sizeof(char *));\n\t\t//相当于现在有三个指针，需要分别进行分配空间\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tq[i].stu[j] = (char *)malloc(30);\n\t\t\tchar buf[30];\n\t\t\tsprintf(buf, \"name %d%d%d%d\", i, i, j, j);\n\t\t\tstrcpy(q[i].stu[j], buf);\n\t\t}\n\n\t}\n\n\t//间接赋值是指针存在的最大意义\n\t*tmp = q;\n\t\n\n\treturn 0;\n}\n\n\n\n//打印函数\n\nvoid showTeacher(Teacher *q, int n1, int n2)\n{\n\n\tif (q == NULL)\n\t{\n\t\treturn;\n\t}\n\tint i = 0;\n\tint j = 0;\n\t//将结果进行打印输出\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor(j= 0; j< n2; j++)\n\t\t{\n\t\t\tprintf(\"%s\\n\", q[i].stu[j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\n\n}\n\n\n//释放\n//先释放上面的三个指针，然后释放stu,最后释放q\n\nvoid freeTeacher(Teacher **tmp, int n1, int n2)\n{\n\tint i = 0;\n\tint j = 0;\n\tif (tmp == NULL)\n\t{\n\t\treturn;\n\t}\n\tTeacher *q = *tmp;\n\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\t//先释放三个指针\n\t\t\tif (q[i].stu[j] != NULL)\n\t\t\t{\n\t\t\t\tfree(q[i].stu[j]);\n\t\t\t\tq[i].stu[j] = NULL;\n\t\t\t}\n\t\t}\n\n\t\t//然后释放stu\n\t\tif (q[i].stu != NULL)\n\t\t{\n\t\t\tfree(q[i].stu);\n\t\t\tq[i].stu = NULL;\n\t\t}\n\n\t}\n\n\tif (q != NULL)\n\t{\n\t\tfree(q);\n\t\tq = NULL;\n\t\t*tmp = NULL;\n\t}\n\n\n\n\n}\n\n\n\n\nint main()\n{\n\n\t//之前都是一个元素，现在是三个元素\n\t//3.\n\tTeacher *q = NULL;\n\t//相当于 Teacher q[3]  ,然后 q[i].stu[3]\n\tint ret = 0;\n\n\tret = createTeacher(&q, 3,3);\n\t\n\tif (ret != 0)\n\t{\n\t\treturn ret;\n\t}\n\n\n\tshowTeacher(q, 3, 3);\n\n\n\tfreeTeacher(&q, 3, 3);\n\n\n\n\n\t\n\n\n\n\t\n\treturn 0;\n}\n```\n\n- 结构体的点运算符和指针法操作的区别\n普通变量后面用`.`加上成员名\n指针后面使用`->` 加上成员名\n\n\n- 结构体数组的排序\n将结构体中元素按照从小到大进行来排序\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tint age;\n\tchar **stu;//二维内存\n}Teacher;\n\n\n\n//n1表示老师的个数，n2表示学生的个数\nint createTeacher(Teacher **tmp, int n1 ,int n2)\n{\n\t//先做一个判断\n\tif(tmp == NULL)\n\t{\n\t\treturn -1;\n\t}\n\t\n\tTeacher *q = (Teacher *)malloc(sizeof(Teacher) * n1);\n\n\tint i = 0;\n\tint j = 0;\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tq[i].stu = (char **)malloc(n2 * sizeof(char *));\n\t\t//相当于现在有三个指针，需要分别进行分配空间\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\tq[i].stu[j] = (char *)malloc(30);\n\t\t\tchar buf[30];\n\t\t\tsprintf(buf, \"name %d%d%d%d\", i, i, j, j);\n\t\t\tstrcpy(q[i].stu[j], buf);\n\t\t}\n\t\t//首先对age进行赋值\n\t\tq[i].age = 20 + i;\n\t}\n\n\n\n\t//间接赋值是指针存在的最大意义\n\t*tmp = q;\n\t\n\n\n\treturn 0;\n}\n\n\n\n//打印函数\n\nvoid showTeacher(Teacher *q, int n1, int n2)\n{\n\n\tif (q == NULL)\n\t{\n\t\treturn;\n\t}\n\tint i = 0;\n\tint j = 0;\n\t//将结果进行打印输出\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tprintf(\"[age= %d]\\t \", q[i].age);\n\t\tfor(j= 0; j< n2; j++)\n\t\t{\n\t\t\tprintf(\"%s\\n\", q[i].stu[j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\n\n}\n\n\nvoid sortTeacher(Teacher *p, int n)\n{\n\tif (p == NULL)\n\t{\n\t\treturn;\n\t}\n\n\tint i = 0;\n\tint j = 0;\n\tTeacher tmp;\n\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\n\t\tfor (j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (p[i].age < p[j].age)\n\t\t\t{\n\t\t\t\ttmp = p[i];\n\t\t\t\tp[i] = p[j];\n\t\t\t\tp[j] = tmp;\n\t\t\t}\n\n\t\t}\n\t}\n}\n\n\n\n\n\n//释放\n//先释放上面的三个指针，然后释放stu,最后释放q\n\nvoid freeTeacher(Teacher **tmp, int n1, int n2)\n{\n\tint i = 0;\n\tint j = 0;\n\tif (tmp == NULL)\n\t{\n\t\treturn;\n\t}\n\tTeacher *q = *tmp;\n\n\tfor (i = 0; i < n1; i++)\n\t{\n\t\tfor (j = 0; j < n2; j++)\n\t\t{\n\t\t\t//先释放三个指针\n\t\t\tif (q[i].stu[j] != NULL)\n\t\t\t{\n\t\t\t\tfree(q[i].stu[j]);\n\t\t\t\tq[i].stu[j] = NULL;\n\t\t\t}\n\t\t}\n\n\t\t//然后释放stu\n\t\tif (q[i].stu != NULL)\n\t\t{\n\t\t\tfree(q[i].stu);\n\t\t\tq[i].stu = NULL;\n\t\t}\n\n\t}\n\n\tif (q != NULL)\n\t{\n\t\tfree(q);\n\t\tq = NULL;\n\t\t*tmp = NULL;\n\t}\n\n\n\n\n}\n\n\n\n\nint main()\n{\n\n\t//之前都是一个元素，现在是三个元素\n\t//3.\n\tTeacher *q = NULL;\n\t//相当于 Teacher q[3]  ,然后 q[i].stu[3]\n\tint ret = 0;\n\n\tret = createTeacher(&q, 3,3);\n\t\n\tif (ret != 0)\n\t{\n\t\treturn ret;\n\t}\n\n\t//排序前\n\tprintf(\"before:\\n\");\n\n\tshowTeacher(q, 3, 3);\n\t\n\tsortTeacher(q, 3);\n\n\t//排序后\n\tprintf(\"after:\\n\");\n\tshowTeacher(q, 3, 3);\n\n\n\tfreeTeacher(&q, 3, 3);\n\n\n\treturn 0;\n}\n```\n\n\n- 结构体的深拷贝和浅拷贝\n//浅拷贝\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar *name;\n\tint age;\n}Teacher;\n\n\n\nint main(void)\n{\n\n\tTeacher t1;\n\tt1.name = (char *)malloc(30);\n\tstrcpy(t1.name, \"lily\");\n\tt1.age = 22;\n\n\tTeacher t2;\n\tt2 = t1;\n\n\tprintf(\"[t2]= %s, %d\\n\", t2.name, t2.age);\n\n\n\t//浅拷贝的内存为同一块，所以只需要释放一次\n\tif (t1.name == NULL)\n\t{\n\t\tfree(t1.name);\n\t\tt1.name = NULL;\n\n\t}\n\n\n\tsystem(\"pause\");\n\n\treturn 0;\n\n}\n\n\n```\n\n![浅拷贝示例图]($resource/%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%A4%BA%E4%BE%8B%E5%9B%BE.png)\n\n//深拷贝：认为的增加一块内存，相当于再重新拷贝一份\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\ntypedef struct Teacher\n{\n\tchar *name;\n\tint age;\n}Teacher;\n\n\n\nint main(void)\n{\n\n\tTeacher t1;\n\tt1.name = (char *)malloc(30);\n\tstrcpy(t1.name, \"lily\");\n\tt1.age = 22;\n\n\tTeacher t2;\n\tt2 = t1;//已经复制了一遍\n\n\t//在人为的进行重新拷贝一次\n\tt2.name = (char *)malloc(30);\n\tstrcpy(t2.name, t1.name);\n\n\tprintf(\"[t2]= %s, %d\\n\", t2.name, t2.age);\n\n\n\t\n\tif (t1.name == NULL)\n\t{\n\t\tfree(t1.name);\n\t\tt1.name = NULL;\n\t}\n\n\n\tif (t2.name == NULL)\n\t{\n\t\tfree(t2.name);\n\t\tt2.name = NULL;\n\t}\n\n\tsystem(\"pause\");\n\n\treturn 0;\n\n}\n\n\n```\n\n\n\n- 结构体偏移\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\n\n//结构体类型定义下来之后，内部的成员变量的内存布局就已经确定了\ntypedef struct Teacher\n{\n\tchar name[64];//64\n\tint age;//4\n\tint id;//4\n}Teacher;\n\n\n\nint main(void)\n{\n\n\tTeacher t1;\n\tTeacher *p = NULL;\n\tp = &t1;\n\n\tint n1 = (int)(&p->age) - (int)p;  //这里求的是相对于结构体的首地址的偏移，使用int进行强制转换是因为整数便于比较偏移量\n\tprintf(\"n1 = %d\\n\", n1);\n\n\n\tint n2 = (int)&((Teacher *)0)->age;  //这是相对于绝对0 地址的偏移量\n\tprintf(\"n2 = %d\\n\", n2);\n\t\n\tsystem(\"pause\");\n\n\treturn 0;\n\n}\n\n```\n程序运行结果：\n`n1 = 64`\n`n2 = 64`\n\n- 结构体字节对齐（内存对齐相当于使用空间换取时间）\n  - 理论性知识点：\n  \n![结构体对齐1]($resource/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%901.png)\n\n![结构体对齐2]($resource/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%902.png)\n\n![结构体对齐3]($resource/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%903.png)\n\n\n   - 单一结构体内存大小\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\n//内存对齐：相当于使用空间换时间\n/*\n\t默认情况下：对齐单位以最长的那个，例如double为8，但是数组类型：char[39] 本质上长度为1，只是连起来放置39个，\n\n\t第一个的偏移量为0，相当于是从头开始排\n\n*/\ntypedef struct Teacher\n{\n\t\n\tint age;\n\tdouble haa;\n\tchar name[10];\n\tint id;\n}Teacher;\n\n/*分析：\n首先最长的单位为8\n首先age本身就是4个字节，相当于占4个位置,\n然后haa本身为8个字节，偏移即8*0 = 0,可是0有元素了，所以8*1 = 8 ，可以使用，则中间这4个位置为空\n然后name本身为1个字节，同时以8个长度对齐\n然后id为4个字节，正好补全\n\n\n\nage:      1 1 1 1 * * * *\nhaa:      1 1 1 1 1 1 1 1\nname：    1 1 1 1 1 1 1 1\n          1 1 * * 1 1 1 1\n\n最终结构体占32字节\n*/\n\n\n\nint main(void)\n{\n\tTeacher A;\n\tprintf(\"%d\\n\", sizeof(A));\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n\n\n```\n程序运行结果：`32`\n\n  - 当结构体中嵌套结构体的时候\n  - \n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\n//内存对齐：相当于使用空间换时间\n/*\n\t默认情况下：对齐单位以最长的那个，例如double为8，但是数组类型：char[39] 本质上长度为1，只是连起来放置39个，\n\n\t第一个的偏移量为0，相当于是从头开始排\n\n*/\ntypedef struct Teacher\n{\n\t\n\tint age;\n\tdouble haa;\n\tchar name[10];\n\n}Teacher;\n\n\ntypedef struct Teacher1\n{\n\n\tint age;\n\tdouble haa;\n\tchar name[10];\n\n\t//这前面所占的空间，最后一排就是没有占满也要自动的填满，这下面嵌套的结构体从下一行开始的时候添加\n\tTeacher a;\n}Teacher1;\n\n\nint main(void)\n{\n\tTeacher1 A;\n\tprintf(\"%d\\n\", sizeof(A));\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n\n```\n程序运行结果：`64`\n\n\n- 根据指定的长度进行对齐(指定的长度必须为2的倍数)\n  - 如果指定长度小于结构体中最长的长度：按照指定长度对齐\n  - 如果指定的长度大于结构体中最长的长度：按照结构体中最长的长度进行对齐 \n**示例程序：**\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n\n\n# pragma pack(2)  //以2个字节进行对齐（指定的长度必须为2的倍数）\n\ntypedef struct Teacher\n{\n\t\n\tint age;\n\tdouble haa;\n\tchar name[10];\n\n}Teacher;\n\n\nint main(void)\n{\n\tTeacher A;\n\tprintf(\"%d\\n\", sizeof(A));\n\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n\n```\n\n\n\n",[[1556458455238,["GJX@GJXAIOU",[[-1,198,"\t\n\t"]],[198,201],[198,198]]],[1556458456026,["GJX@GJXAIOU",[[-1,198,"\n"]],[198,198],[197,197]]],[1556458477158,["GJX@GJXAIOU",[[-1,331,"在"]],[332,332],[331,331]]],[1556458480602,["GJX@GJXAIOU",[[1,331,"再"]],[331,331],[332,332]]],[1556458504274,["GJX@GJXAIOU",[[1,274,"    、、"]],[274,274],[280,280]]],[1556458505747,["GJX@GJXAIOU",[[-1,278,"、、"]],[280,280],[278,278]]],[1556458512884,["GJX@GJXAIOU",[[1,278,"// 先定义类型"]],[278,278],[286,286]]],[1556458551927,["GJX@GJXAIOU",[[1,287,"  "]],[287,287],[289,289]]],[1556458554617,["GJX@GJXAIOU",[[-1,287,"  "]],[289,289],[287,287]]]],null,"GJX@GJXAIOU"]]}