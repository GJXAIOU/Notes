{"compress":true,"commitItems":[["96eff5c2-b043-4cde-bd55-72a48218a04c",1540628795055,"",[[1540628743398,["gjx16@GJXAIOU",[[1,0,"# 排序算法\n\n\n\n"]],[0,0],[9,9]]],[1540628751104,["gjx16@GJXAIOU",[[1,9,"```\n以下程序在win10 X64位操作系统，使用VS2017运行验证可行\n```\n排序是非常重要且很常用的一种操作，有冒泡排序、选择排序、插入排序、希尔排序、快速排序、堆排序等多种方法。\n\n\n\n\n## 实例1 冒泡法排序\n\n**1.前言：** 数组中有N个整数，用冒泡法将它们从小到大（或从大到小）排序。冒泡法较慢；\n\n**2.算法步骤：**\n冒泡法效率是最低的，但算法简单：\n- 从第一个数开始，相邻两个数两两比较，将大的交换到后面，然后继续比较第2、3个数…..,遍历结束之后最小的数就在最前面了；\n\n- 将最前面的最小的数排除在外，其余数重复步骤1。\n\n- 重复步骤2，直到所有数都排好为止。\n\n\n**3.示例程序：**\n```c\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\n\n//将数组中的元素进行排序\nvoid sort_array(int array[], int num)\n{\n\tint i;\n\tint j;\n\tfor (i = 0; i < num; i++)//这里等价于：for(i = 0; i < num -1; i++)\n\t{\n\t\tfor (j = 1; j < num - i; j++)//这里等价于：for(j = 0; i < num - i -1; j++)\n\t\t{\n\t\t\tif (array[j - 1] > array[j])\n\t\t\t{\n\t\t\t\tint tmp;\n\t\t\t\ttmp = array[j];\n\t\t\t\tarray[j] = array[j - 1];\n\t\t\t\tarray[j - 1] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n//将排序之后的数组打印出来\n\nvoid print_array(int array[], int num)\n{\n\tint i = 0;\n\tfor (i = 0; i < num; i++)\n\t{\n\t\tprintf(\"array[%d] = %d\\n\", i, array[i]);\n\t}\n\n}\n\n\nint main()\n{\n\tint array[] = { 1,4,8,0,9,34,98,100,5,3 };\n\tint num = sizeof(array) / sizeof(int);//求出数组元素的长度\n\n\tsort_array(array, num);\n\tprint_array(array, num);\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`array[0] = 0`\n`array[1] = 1`\n`array[2] = 3`\n`array[3] = 4`\n`array[4] = 5`\n`array[5] = 8`\n`array[6] = 9`\n`array[7] = 34`\n`array[8] = 98`\n`array[9] = 100`\n\n---\n\n## 实例2 选择法排序\n**1.前言：** 数组中有N个整数，用选择法将它们从小到大排序。其速度比冒泡法快；\n\n**2.算法步骤：**\n- 找出一个最小数，一般默认数组中的第一个元素为最小的元素，然后遍历后面的所有的元素，分别与这个最小的元素进行比较，如果比最小的元素还小就交换位置，一轮之后数组中最小的元素排到了最前面；\n\n- 在剩下的数里面，再找一个最小的，交换到剩下数的最前面；\n\n- 重复步骤2 ，直到所有数都已排好；\n\n\n3.**示例程序**\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n//打印数组中的元素\nvoid print_array(int *array, int num)\n{\n\tint i = 0;\n\tfor (i = 0; i < num; i++)\n\t{\n\t\tprintf(\"%d \\n\", array[i]);\n\t}\n}\n\n\n//选择法进行排序\n\n//如果数组作为函数参数，则数组形参退化为指针\nvoid sort_array(int *array, int num)//等价于：void sort_array(int array[],int num)\n{\n\tint i = 0;\n\tint j = 0;\n\tint tmp = 0;\n\tfor (i = 0; i < num - 1; i++)\n\t{\n\t\tfor (j = i + 1; j < num; j++)\n\t\t{\n\t\t\tif (array[i] > array[j])\n\t\t\t{\n\t\t\t\ttmp = array[i];\n\t\t\t\tarray[i] = array[j];\n\t\t\t\tarray[j] = tmp;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n\nint main(void)\n{\n\tint array[] = { 1,4,6,9,0,4,3,5,2 };\n\tint num = 0;\n\tnum = sizeof(array) / sizeof(array[0]);\n\n\n\n\tprintf(\"after = \\n\");\n\tsort_array(array, num);\n\tprint_array(array, num);\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n程序运行结果：\n`after =`\n`0`\n`1`\n`2`\n`3`\n`4`\n`4`\n`5`\n`6`\n`9`\n\n\n---\n\n## 实例3 插入排序\n数组中有N个整数，用插入排序实现它们由小到大的排列。\n\n实例解析：\n\n插入排序也是常用的一种排序方法，效率较冒泡法高（一趟即可完成），但比选择法低（移动数据次数多）。其基本思想是：将数组分成两个区：前面是已排序的区域（有序区），后面是没有排序的区域（无序区）。每次都从无序区中取第一个数插入到有序区中适当位置，直到所有数据插入完毕为止。\n\n算法的具体描述是：\n\n待排序的数据存放在数组A[0, 1, ...N-1]中，未排序前，A[0]自己是一个有序区，A[1, 2, ...N-1]是无序区。程序必须从i = 1开始，直到i = N-1为止，每次将A[i]插入到有序区中。\n\n插入排序与打扑克摸牌时的理牌过程很相似，当摸来第一张牌时，不需要排序，本身就是排好的（就一张），从第二张开始，每次摸来一张牌，必须插入到原来有序的扑克牌中的适当位置，而为了找到这个适当位置，需要将新摸来的牌与手中的牌进行比较。\n\n基本的插入排序：\n\n首先在有序区A[0,1,...i-1]中查找A[i]应该插入的位置k（0 <= k <= i-1），然后将A[k,k+1,...i-1]中的数据各自后移一个位置，腾出位置k插入A[i]。\n\n若有序区所有数据均小于A[i]时，A[i]就应该在原位置不变，不需要插入。\n\n改进后的插入排序：\n\n将待插入的数据A[i]自右至左依次与有序区的数据A[i-1,i-2,...0]进行比较，若A[i]小于某数据A[j]，则A[j]后移一个位置，继续与前面的数据比较......直到遇到比A[i]小的数据或前面已没有数据，则插入位置确定。\n\n若碰到一个数据A[j]比A[i]小，则A[i]应插入到位置j+1。\n\n若A[i-1]比A[i]小，则A[i]位置不变。\n\n若所有数据都比A[i]大，则A[i]应插入到位置0。\n\n下面是改进后插入排序的代码：\n\n#define  N 10\n\n#include <stdio.h>\n\nint main()\n\n{int  a[N] = {3,5,2,9,7,4,8,1,0,6}, i, j, t;\n\n for(i = 1; i <= N-1; i++){\n\n   t = a[i];                     //保存a[i]，因a[i]会被覆盖\n\nfor(j = i-1; a[j]>t && j>=0; j--) // a[j]>t不能写成a[j]> a[i]\n\n     a[j+1] = a[j];\n\n   a[j+1] = t;\n\n}\n\nfor(i = 0; i <= N-1; i++)\n\n   printf(“%3d”, a[i] );\n\n printf(“\\n”);\n\n getch();\n\nreturn 0;\n\n}\n"]],[9,9],[3457,3457]]],[1540640239826,["gjx16@GJXAIOU",[[1,2333,"算法的小龙女"]],[2333,2333],[2339,2339]]],[1540640240901,["gjx16@GJXAIOU",[[-1,2336,"小龙女"]],[2339,2339],[2336,2336]]],[1540640257531,["gjx16@GJXAIOU",[[1,2336,"效率介于冒泡法和选择法"]],[2336,2336],[2347,2347]]],[1540640258891,["gjx16@GJXAIOU",[[1,2347,"之间"]],[2347,2347],[2349,2349]]],[1540640276845,["gjx16@GJXAIOU",[[-1,2358,"插入排序也是常用的一种排序方法，效率较冒泡法高（一趟即可完成），但比选择法低（移动数据次数多）。"]],[2406,2406],[2358,2358]]],[1540640277045,["gjx16@GJXAIOU",[[-1,2357,"\n"]],[2358,2358],[2357,2357]]],[1540640277261,["gjx16@GJXAIOU",[[-1,2356,"\n"]],[2357,2357],[2356,2356]]],[1540640278310,["gjx16@GJXAIOU",[[-1,2351,"实例解析："]],[2356,2356],[2351,2351]]],[1540640281289,["gjx16@GJXAIOU",[[1,2351,"****"]],[2351,2351],[2353,2353]]],[1540640292595,["gjx16@GJXAIOU",[[1,2353,"2.算法过程："]],[2353,2353],[2360,2360]]],[1540640294560,["gjx16@GJXAIOU",[[1,2362," "]],[2362,2362],[2363,2363]]],[1540640302721,["gjx16@GJXAIOU",[[1,2307,"****"]],[2307,2307],[2309,2309]]],[1540640304064,["gjx16@GJXAIOU",[[1,2309,"1、"]],[2309,2309],[2311,2311]]],[1540640305093,["gjx16@GJXAIOU",[[-1,2310,"、"]],[2311,2311],[2310,2310]]],[1540640306309,["gjx16@GJXAIOU",[[1,2310,"。"]],[2310,2310],[2311,2311]]],[1540640308437,["gjx16@GJXAIOU",[[-1,2310,"。"]],[2311,2311],[2310,2310]]],[1540640309480,["gjx16@GJXAIOU",[[1,2310,"."]],[2310,2310],[2311,2311]]],[1540640321156,["gjx16@GJXAIOU",[[1,2311,"前言："]],[2311,2311],[2314,2314]]],[1540640323418,["gjx16@GJXAIOU",[[1,2316," "]],[2316,2316],[2317,2317]]],[1540640362494,["gjx16@GJXAIOU",[[-1,2579,"插入排序与打扑克摸牌时的理牌过程很相似，当摸来第一张牌时，不需要排序，本身就是排好的（就一张），从第二张开始，每次摸来一张牌，必须插入到原来有序的扑克牌中的适当位置，"]],[2662,2662],[2579,2579]]],[1540640362824,["gjx16@GJXAIOU",[[-1,2578,"\n"]],[2579,2579],[2578,2578]]],[1540640363214,["gjx16@GJXAIOU",[[-1,2577,"\n"]],[2578,2578],[2577,2577]]],[1540640363813,["gjx16@GJXAIOU",[[-1,2576,"。"]],[2577,2577],[2576,2576]]],[1540640364885,["gjx16@GJXAIOU",[[1,2576,"，"]],[2576,2576],[2577,2577]]],[1540640369433,["gjx16@GJXAIOU",[[-1,2592,"新摸来的牌"]],[2597,2597],[2592,2592]]],[1540640373514,["gjx16@GJXAIOU",[[1,2592,"A【"]],[2592,2592],[2594,2594]]],[1540640375997,["gjx16@GJXAIOU",[[-1,2593,"【"]],[2594,2594],[2593,2593]]],[1540640378327,["gjx16@GJXAIOU",[[1,2593,"[i["]],[2593,2593],[2596,2596]]],[1540640379088,["gjx16@GJXAIOU",[[-1,2595,"["]],[2596,2596],[2595,2595]]],[1540640379767,["gjx16@GJXAIOU",[[1,2595,"]"]],[2595,2595],[2596,2596]]],[1540640385255,["gjx16@GJXAIOU",[[-1,2597,"手中的牌"]],[2601,2601],[2597,2597]]],[1540640387435,["gjx16@GJXAIOU",[[1,2597,"youxuqu"]],[2597,2597],[2604,2604]]],[1540640389342,["gjx16@GJXAIOU",[[-1,2597,"youxuqu"]],[2604,2604],[2597,2597]]],[1540640400969,["gjx16@GJXAIOU",[[1,2597,"有序区的数据"]],[2597,2597],[2603,2603]]],[1540640421976,["gjx16@GJXAIOU",[[-1,2470,"\n"]],[2471,2471],[2470,2470]]],[1540640422110,["gjx16@GJXAIOU",[[-1,2469,"\n"]],[2470,2470],[2469,2469]]],[1540640423902,["gjx16@GJXAIOU",[[-1,2460,"算法的具体描述是："]],[2469,2469],[2460,2460]]],[1540640424383,["gjx16@GJXAIOU",[[-1,2459,"\n"]],[2460,2460],[2459,2459]]],[1540640424822,["gjx16@GJXAIOU",[[-1,2458,"\n"]],[2459,2459],[2458,2458]]],[1540640427137,["gjx16@GJXAIOU",[[1,2458,"例如："]],[2458,2458],[2461,2461]]],[1540640445727,["gjx16@GJXAIOU",[[-1,2704,"\n"]],[2705,2705],[2704,2704]]],[1540640470473,["gjx16@GJXAIOU",[[1,2600,"- "]],[2600,2600],[2602,2602]]],[1540640472577,["gjx16@GJXAIOU",[[1,2745,"- "]],[2745,2745],[2747,2747]]],[1540640476169,["gjx16@GJXAIOU",[[1,2612," "]],[2612,2612],[2613,2613]]],[1540640477681,["gjx16@GJXAIOU",[[-1,2612," "]],[2613,2613],[2612,2612]]],[1540640477935,["gjx16@GJXAIOU",[[1,2612,"·"]],[2612,2612],[2613,2613]]],[1540640478783,["gjx16@GJXAIOU",[[-1,2612,"·"]],[2613,2613],[2612,2612]]],[1540640480137,["gjx16@GJXAIOU",[[1,2612,"  "]],[2612,2612],[2614,2614]]],[1540640482198,["gjx16@GJXAIOU",[[1,2760,"  "]],[2760,2760],[2762,2762]]],[1540640498717,["gjx16@GJXAIOU",[[-1,2880,"\n"]],[2881,2881],[2880,2880]]],[1540640499029,["gjx16@GJXAIOU",[[-1,2879,"\n"]],[2880,2880],[2879,2879]]],[1540640502311,["gjx16@GJXAIOU",[[-1,2913,"\n"]],[2914,2914],[2913,2913]]],[1540640502656,["gjx16@GJXAIOU",[[-1,2912,"\n"]],[2913,2913],[2912,2912]]],[1540640504862,["gjx16@GJXAIOU",[[-1,2937,"\n"]],[2938,2938],[2937,2937]]],[1540640505272,["gjx16@GJXAIOU",[[-1,2936,"\n"]],[2937,2937],[2936,2936]]],[1540640522073,["gjx16@GJXAIOU",[[-1,2980,"#define  N 10\n\n#include <stdio.h>\n\nint main()\n\n{int  a[N] = {3,5,2,9,7,4,8,1,0,6}, i, j, t;\n\n for(i = 1; i <= N-1; i++){\n\n   t = a[i];                     //保存a[i]，因a[i]会被覆盖\n\nfor(j = i-1; a[j]>t && j>=0; j--) // a[j]>t不能写成a[j]> a[i]\n\n     a[j+1] = a[j];\n\n   a[j+1] = t;\n\n}\n\nfor(i = 0; i <= N-1; i++)\n\n   printf(“%3d”, a[i] );\n\n printf(“\\n”);\n\n getch();\n\nreturn 0;\n\n}"]],[2980,3346],[2980,2980]]],[1540641620299,["gjx16@GJXAIOU",[[1,2979,"```"]],[2979,2979],[2982,2982]]],[1540641620330,["gjx16@GJXAIOU",[[1,2982,"language\n```\n"]],[2982,2982],[2982,2990]]],[1540641621511,["gjx16@GJXAIOU",[[-1,2982,"language"],[1,2990,"c"]],[2982,2990],[2983,2983]]],[1540641621750,["gjx16@GJXAIOU",[[1,2984,"\n"]],[2983,2983],[2984,2984]]],[1540641623213,["gjx16@GJXAIOU",[[1,2985,"#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\n\nvoid print_array(int array[], int num)\n{\n\tint i = 0;\n\tfor (i = 0; i <= num - 1; i++)\n\t{\n\t\tprintf(\"%d  \", array[i]);\n\t}\n\treturn 0;\n}\nvoid sort_array(int array[], int num)\n{\n\tint i = 0;\n\tint tmp = 0;\n\tint j = 0;\n\tfor (i = 1; i <= num - 1; i++)\n\t{\n\t\ttmp = array[i];\n\t\tfor (j = i - 1; array[j] > tmp && j >= 0; j--)\n\t\t{\n\t\t\tarray[j + 1] = array[j];\n\t\t}\n\t\t\n\t\tarray[j + 1] = tmp;\n\t\t\t\n\t}\n}\n\nint main(void)\n{\n\tint  array[] = { 1,4,6,9,0,4,3,5,2 };\n\n\tint num = 0;\n\tnum = sizeof(array) / sizeof(int);\n\n\tsort_array(array, num);\n\tprint_array(array, num);\n\n\tprintf(\"\\n\");\n\tsystem(\"pause\");\n\treturn 0;\n\n}\n"]],[2984,2984],[3632,3632]]],[1540641629262,["gjx16@GJXAIOU",[[1,3640,"\n"]],[3636,3636],[3637,3637]]],[1540641634456,["gjx16@GJXAIOU",[[1,3637,"ch"]],[3637,3637],[3639,3639]]],[1540641635061,["gjx16@GJXAIOU",[[-1,3637,"ch"]],[3639,3639],[3637,3637]]],[1540641641858,["gjx16@GJXAIOU",[[1,3637,"程序运行结果；"]],[3637,3637],[3644,3644]]],[1540641642449,["gjx16@GJXAIOU",[[1,3648,"\n"]],[3644,3644],[3645,3645]]],[1540641642997,["gjx16@GJXAIOU",[[-1,3648,"\n"]],[3645,3645],[3644,3644]]],[1540641643150,["gjx16@GJXAIOU",[[-1,3643,"；"]],[3644,3644],[3643,3643]]],[1540641644434,["gjx16@GJXAIOU",[[1,3643,"："]],[3643,3643],[3644,3644]]],[1540641645310,["gjx16@GJXAIOU",[[1,3648,"\n"]],[3644,3644],[3645,3645]]],[1540641669158,["gjx16@GJXAIOU",[[1,3645,"0  1  2  3  4  4  5  6  9"]],[3645,3645],[3670,3670]]],[1540641671808,["gjx16@GJXAIOU",[[1,3645,"·"]],[3645,3645],[3646,3646]]],[1540641672750,["gjx16@GJXAIOU",[[-1,3645,"·"]],[3646,3646],[3645,3645]]],[1540641673387,["gjx16@GJXAIOU",[[1,3645,"`"]],[3645,3645],[3646,3646]]],[1540641683859,["gjx16@GJXAIOU",[[1,3671,"`"]],[3671,3671],[3672,3672]]],[1540641697263,["gjx16@GJXAIOU",[[1,3676,"\n"]],[3672,3672],[3673,3673]]],[1540641697401,["gjx16@GJXAIOU",[[1,3677,"\n"]],[3673,3673],[3674,3674]]],[1540641697520,["gjx16@GJXAIOU",[[1,3678,"\n"]],[3674,3674],[3675,3675]]]],null,"gjx16@GJXAIOU"]]}