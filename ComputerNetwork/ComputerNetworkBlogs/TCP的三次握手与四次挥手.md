---
flag: purple
---

# TCP的三次握手与四次挥手

## 一、前言
- TCP/IP 协议：是传输层协议，主要解决数据如何在网络中传输；
- HTTP 协议：是应用层协议，主要解决如何包装数据； 
- 套接字： TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种**端点我们叫作套接字（socket）**，它的定义为==端口号拼接到IP地址即构成了套接字==，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。


## 二、TCP 帧结构

![TCP帧结构]($resource/TCP%E5%B8%A7%E7%BB%93%E6%9E%84.png)

- 序列号seq：占4个字节，**用来标记数据段的顺序**，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；**序列号seq就是这个报文段中的第一个字节的数据编号**。

- 确认号ack：占4个字节，**期待收到对方下一个报文段的第一个数据字节的序号**；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；**因此当前报文段最后一个字节的编号+1即为确认号**（这里加上不携带数据）。

- 确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效

- 同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，**SYN=1表示这是一个连接请求，或连接接受报文**。SYN这个标志位只有在 TCP 建立连接时才会被置1，握手完成后SYN标志位被置0。

- 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接。

- 补充说明：
  - ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。
  - 序列号：指出段中数据在发送端数据流中的位置；序列号是上一个收包的确认号不变
  - 确认号：指出本机希望下一个接收的字节的序列号 ：确认号是上一个收包的序列号+上一个收包的数据段的大小；
 

字段 | 含义
---|---
URG  | 紧急指针是否有效。为1，表示某一位需要被优先处理
ACK | 确认号是否有效，一般置为1。
PSH  | 提示接收端应用程序立即从TCP缓冲区把数据读走。
RST  | 对方要求重新建立连接，复位。
SYN  | 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1
FIN   |   希望断开连接。



## 三、 三次握手过程理解

作用：通信双方都明确自己和对方的收发能力是正常的，同时利用数据包的选项来传输特殊的信息，交换初始序列号 ISN；

### （一）ISN
三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。
如果ISN是固定的，攻击者很容易猜出后续的确认号。
```text
ISN = M + F(localhost, localport, remotehost, remoteport)
```
M是一个计时器，每隔4毫秒加1。 F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。

### （二）三次握手过程
![](https://mmbiz.qpic.cn/mmbiz_png/9ZYzcsxnWicBoPZrQ8ZYQkkAODicGUXPgqMsV9cC6tEJAicgCNZibn9WKCQVEyfnThGDyIHt0iaaAVpeR75OBRFrTJg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 第一次握手（确认客户端的发送能力、服务端的接收能力是正常的）：建立连接时，客户端发送syn包（syn=x）（**即指明了客户端的初始序列号 ISN**）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

- 第二次握手（客户端角度确认服务端的发送能力、客户端的接收能力以及客户端的发送能力、服务端的接收能力是正常的）：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y）（**即指明客户端的初始序列号 ISN**），即SYN+ACK包，此时服务器进入SYN_RECV状态；

- 第三次握手：（服务端角度确认服务端的发送能力、客户端的接收能力以及客户端的发送能力、服务端的接收能力是正常的）客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1）（为了确认服务器端的 SYN），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。序列号是上一个同步请求数据包中的确认号值，确认号是服务器的初始序列号+1，注意：因为一个SYN将占用一个序号，所以要加1。


### （三）补充问题

- **2\. ACK +1的问题；**
序列号应该不是随机的，而是由双方协商的，协商之前最开始的值由TCP运输层生成。 它可能是上一个该端口的序列号+1 ， 原因是为了避免上次已断开的连接，还存在网络中延迟到达的TCP报文段的序号与当前连接中等待报文段的序号相同，以至于认为是这一次连接的包，发生错误。
 关于ACK+1，在文中“包2”中如下所述：
 “需要注意的是，尽管客户端没有发送任何有效数据，确认号还是被加1，这是因为接收的包中包含SYN或FIN标志位（并不会对有效数据的计数产生影响，因为含有SYN或FIN标志位的包并不携带有效数据）”这实际上是误解，因此误导了很多人。在停-等协议中，ACK确认的是当前包的序列号Seq=1 ，接收端会传回 ACK=1 。标识接收到了Seq=1的包，这是我们认为理所当然的。  但是在TCP协议中不是这样， **当发生Seq=1的包，接受端会传回ACK=2**， 也就是将接受到的Seq+1 ， 代表的是期望接受到的下一个包是 Seq=2的包。 （换句话说，和头部的标志位并没有任何关系）`

为什么要这样呢？.. 这么做比较违反我们的直觉。

因为TCP是以流水线发出的，比如发送端顺序的发出 Seq=1、Seq=2、Seq=3。 那么如果ACK确认的序号和收到的包的序号一致的话，那么需要发回 ACK=1、ACK=2、ACK=3 共三个包。但是TCP协议对此进行了优化，只需要发送一个ACK包就能代表说自己已经收到了前面三个包，
 那就是发送ACK=4 （期望收到Seq为4的包）。这样节省了ACK确认的数量。
 
 另外TCP是的序号是根据数据流编码的， 假设最开始Seq=0 Len=3， 那么 ACK=4的时候：
 第一个意思是想表明期待收到下一个Seq为4的包。
第二个意思实际上是说，想收到的包开始的那个比特位于数据流中的第四个比特。（下次从数据流中的第四个Byte开始发送）
（实际上上面两个意思是一样的 = = ，同时也再次说明这个ACK+1和头部的标志位无关）

以上问题在 计算机网络：自顶向下 中都有说到， 因为书中和文字有不一致的地方，然后我提出来纠正一下。


*   **序列号为什么是随机的**？ 
 随机是因为为了防止建立链接时数据错乱, 比如如果固定是从1开始, 第一轮链接超时了然后客户端重新发起链接, 又从1开始第二轮, 这样可能第一轮的包刚好传过来了所以导致数据错乱. 为了解决这个问题, 初始序号是一个随机的, 本质上是随时间变化而变化, 每4ms会+1, 所以等到下一个重复的序号出现时需要2^32 * 4 / 1000 / 3600 约等于 4000小时, 这么长的时间里第一轮的请求100%死掉了, 这就是"随机"序号的设计原因.


### （一）为什么TCP客户端最后还要发送一次确认呢？

 一句话，**主要防止已经失效的连接请求报文突然又传送到了服务器**从而产生错误。

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。**此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费**。
 
**如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接**。


## 四、传输数据的简要过程如下：

  1)  发送数据：服务器向客户端发送一个带有数据的数据包，该数据包中的序列号和确认号与建立连接第三步的数据包中的序列号和确认号相同；
2)  确认收到：客户端收到该数据包，向服务器发送一个确认数据包，该数据包中，序列号是为上一个数据包中的确认号值，而确认号为服务器发送的上一个数据包中的序列号+上一个数据包中所带数据的大小。 数据分段中的序列号可以保证所有传输的数据按照正常的次序进行重组，而且通过确认保证数据传输的完整性。




## 五、四次挥手过程理解 
TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解`“上层的意志”`。

![四次挥手过程]($resource/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B.png)

- 1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（**等于前面已经传送过来的数据的最后一个字节的序号加1**，确认一下之前的收到了），此时，客户端进入FIN-WAIT-1（终止等待1）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

- 2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

- 3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

- 4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

- 5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

- 6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

注意：因为FIN和SYN一样，也要占一个序号。理论上服务器在TCP连接关闭时发送的终止数据包中，只有终止位是置1，然后客户端进行确认。但是在实际的TCP实现中，在终止数据包中，确认位和终止位是同时置为1的，确认位置为1表示对最后一次传输的数据进行确认，终止位置为1表示关闭该方向的TCP连接。

### （一）为什么客户端最后还要等待2MSL？

MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

###  （二）为什么建立连接是三次握手，关闭连接确是四次挥手呢？

 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 
 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

### （三）如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。


### （四）ISN

三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。

如果ISN是固定的，攻击者很容易猜出后续的确认号。

```text
ISN = M + F(localhost, localport, remotehost, remoteport)
```

M是一个计时器，每隔4毫秒加1。 F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。

### （五）序列号回绕

因为ISN是随机的，后续是递增的，所以序列号容易就会超过2^31-1。 **而tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的**就是原则上不能后面的一个比前面的一个大。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。怎么解决？

```c
/*
* The next routines deal with comparing 32 bit unsigned ints
* and worry about wraparound (automatic with unsigned arithmetic).
*/
static inline int before(__u32 seq1, __u32 seq2)
{
    return (__s32)(seq1-seq2) < 0;
}

#define after(seq2, seq1) before(seq1, seq2)
```

上述代码是内核中的解决回绕问题代码。**s32是有符号整型的意思**，u32则是无符号整型。序列号发生回绕后，序列号变小，相减之后，把结果变成有符号数了，因此结果成了负数。

```text
假设seq1=255， seq2=1（发生了回绕）。
seq1 = 1111 1111 seq2 = 0000 0001
我们希望比较结果是
 seq1 - seq2=
 1111 1111
-0000 0001
-----------
 1111 1110

由于我们将结果转化成了有符号数，由于最高位是1，因此结果是一个负数，负数的绝对值为
 0000 0001 + 1 = 0000 0010 = 2

因此seq1 - seq2 < 0，这样 sq1 < sq2 ，保证不会后面的一个小于前面一个
```

### （六） syn flood攻击

最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。

如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。

常见的防攻击方法有：

## 无效连接的监视释放

监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。

## 延缓TCB分配方法

消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。

## Syn Cache技术

系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。

## Syn Cookie技术

Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。

## 使用SYN Proxy防火墙

一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c', 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。

## 连接队列

在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。

![](https://pic2.zhimg.com/80/v2-c4688fba5db30b31c913f549108c9735_hd.jpg)

对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。

```text
查看是否有连接溢出
netstat -s | grep LISTEN
```

## 半连接队列满了

在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了`request_sock`结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。

 目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s, 总共31s, 称为`指数退避`，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s, TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题，linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。

![](https://pic1.zhimg.com/80/v2-f998ee97330a3a258ad617ea10257c4c_hd.jpg)

## 全连接队列满

当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。

当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回`read timeout` 或者 `connection reset by peer`。另外，`tcp_abort_on_overflow`是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了`tcp_synack_retries`）。

服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到服务端

![](https://pic2.zhimg.com/80/v2-df71dbb7c5f6743eca7fba07d1a0b869_hd.jpg)

## 命令

netstat -s命令
```network
> [root@server ~]# netstat -s | egrep "listen|LISTEN" 667399 times the listen queue of a socket overflowed 667399 SYNs to LISTEN sockets ignored
> 比如上面看到的 667399 times ，表示全连接队列溢出的次数，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。
> [root@server ~]# netstat -s | grep TCPBacklogDrop 查看 Accept queue 是否有溢出
```
ss命令
```
> [root@server ~]# ss -lnt State Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 128 _:6379 _:_ LISTEN 0 128 _:22 _:_ 如果State是listen状态，Send-Q 表示第三列的listen端口上的全连接队列最大为50，第一列Recv-Q为全连接队列当前使用了多少。 非 LISTEN 状态中 Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。
```
## 小结

当外部连接请求到来时，TCP模块会首先查看`max_syn_backlog`，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据`tcp_abort_on_overflow`字段来决定是直接丢弃，还是直接reset.

从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。

一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据`tcp_abort_on_overflow`字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。

## “三次握手，四次挥手”redis实例分析

1.  我在dev机器上部署redis服务，端口号为6379,
2.  通过tcpdump工具获取数据包，使用如下命令

```text
tcpdump -w /tmp/a.cap port 6379 -s0
-w把数据写入文件，-s0设置每个数据包的大小默认为68字节，如果用-S 0则会抓到完整数据包
```

1.  在dev2机器上用redis-cli访问dev:6379, 发送一个ping, 得到回复pong
2.  停止抓包，用tcpdump读取捕获到的数据包

```text
tcpdump -r /tmp/a.cap -n -nn -A -x| vim -
（-x 以16进制形式展示，便于后面分析）
```

共收到了7个包。

抓到的是IP数据包，IP数据包分为IP头部和IP数据部分，IP数据部分是TCP头部加TCP数据部分。

IP的数据格式为：

![](https://pic4.zhimg.com/80/v2-a8702bdb6e9cf9fd29e824ac07542067_hd.jpg)

它由固定长度20B+可变长度构成。

```text
10:55:45.662077 IP dev2.39070 > dev.6379: Flags [S], seq 4133153791, win 29200, options [mss 1460,sackOK,TS val 2959270704 ecr 0,nop,wscale 7], length 0
        0x0000:  4500 003c 08cf 4000 3606 14a5 0ab3 b561
        0x0010:  0a60 5cd4 989e 18eb f65a ebff 0000 0000
        0x0020:  a002 7210 872f 0000 0204 05b4 0402 080a
        0x0030:  b062 e330 0000 0000 0103 0307
```

对着IP头部格式，来拆解数据包的具体含义。

![](https://pic3.zhimg.com/80/v2-1b33f99c890277f54fd15370635860ee_hd.jpg)

剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。

![](https://pic4.zhimg.com/80/v2-4949f0578dbde508f35ef4aef9a932b7_hd.jpg)

可变长度部分，协议如下：

![](https://pic1.zhimg.com/80/v2-82bc4c9a7d5ae823c09502c687d3b6e0_hd.jpg)

这样第一个包分析完了。dev2向dev发送SYN请求。`也就是三次握手中的第一次了。` `SYN seq(c)=4133153791`

第二个包，dev响应连接，ack=4133153792\. 表明dev下次准备接收这个序号的包，用于tcp字节注的顺序控制。dev（也就是server端）的初始序号为seq=4264776963, syn=1. `SYN ack=seq(c)+1 seq(s)=4264776963`

第三个包，client包确认，这里使用了相对值应答。seq=4133153792, 等于第二个包的ack. ack=4264776964. `ack=seq(s)+1, seq=seq(c)+1` 至此，三次握手完成。接下来就是发送ping和pong的数据了。

接着第四个包。

```text
10:55:48.090073 IP dev2.39070 > dev.6379: Flags [P.], seq 1:15, ack 1, win 229, options [nop,nop,TS val 2959273132 ecr 3132256230], length 14
        0x0000:  4500 0042 08d1 4000 3606 149d 0ab3 b561
        0x0010:  0a60 5cd4 989e 18eb f65a ec00 fe33 5504
        0x0020:  8018 00e5 4b5f 0000 0101 080a b062 ecac
        0x0030:  bab2 6fe6 2a31 0d0a 2434 0d0a 7069 6e67
        0x0040:  0d0a
```

tcp首部长度为32B, 可选长度为12B. IP报文的总长度为66B, 首部长度为20B, 因此TCP数据部分长度为14B. seq=0xf65a ec00=4133153792 ACK, PSH. 数据部分为2a31 0d0a 2434 0d0a 7069 6e67 0d0a

```text
0x2a31         -> *1
0x0d0a         -> \r\n
0x2434         -> $4
0x0d0a         -> \r\n
0x7069 0x6e67  -> ping
0x0d0a         -> \r\n
```

dev2向dev发送了ping数据，第四个包完毕。

第五个包，dev2向dev发送ack响应。 序列号为0xfe33 5504=4264776964, ack确认号为0xf65a ec0e=4133153806=(4133153792+14).

第六个包，dev向dev2响应pong消息。序列号fe33 5504，确认号f65a ec0e, TCP头部可选长度为12B, IP数据报总长度为59B, 首部长度为20B, 因此TCP数据长度为7B. 数据部分2b50 4f4e 470d 0a, 翻译过来就是`+PONG\r\n`.

至此，Redis客户端和Server端的三次握手过程分析完毕。



