{"compress":true,"commitItems":[["4afbcaa1-b2cc-4243-a6d0-2cc82cdf3ce4",1573826315381,"# 第十五章：代理模式\n\n \n\n## 一、代理模式(Proxy)\n\n### （一）代理模式的基本介绍\n\n \n\n- 代理模式：**为一个对象提供一个替身，以控制对这个对象（被代理的对象）的访问**。即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。\n\n- 被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象；\n\n- 代理模式有不同的形式, 主要有三种 **静态代理**、**动态代理** (JDK 代理、接口代理)和 **Cglib** **代理** (可以在内存动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴) 。\n\n- 代理模式示意图\n\n ![代理模式示意图](%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.resource/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)\n\n## 二、静态代理\n\n### （一）静态代码模式的基本介绍\n\n静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类\n\n### （二）应用实例\n\n具体要求\n\n- 定义一个接口：ITeacherDao\n\n- 目标对象 TeacherDAO 实现接口 ITeacherDAO\n\n- 使用静态代理方式,就需要在代理对象 TeacherDAOProxy 中也实现 ITeacherDAO\n\n- 调用的时候通过调用代理对象的方法来调用目标对象.\n\n- 特别提醒：代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法\n\n \n\n 思路分析图解(类图)\n\n ![静态代理思路分析图解](%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.resource/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%E5%9B%BE%E8%A7%A3.jpg)\n\n- 代码实现\n\n接口：ITeacherDao\n\n```java\npackage com.atguigu.proxy.staticproxy;\n\n//接口\npublic interface ITeacherDao {\n\tvoid teach(); // 授课的方法\n}\n\n```\n\n 实现接口：\n\n```java\npackage com.atguigu.proxy.staticproxy;\n\npublic class TeacherDao implements ITeacherDao {\n\n\t@Override\n\tpublic void teach() {\n\t\tSystem.out.println(\" 老师授课中  。。。。。\");\n\t}\n}\n\n```\n\n代理：\n\n```java\npackage com.atguigu.proxy.staticproxy;\n\n//代理对象,静态代理\npublic class TeacherDaoProxy implements ITeacherDao{\n\t\n\tprivate ITeacherDao target; // 目标对象，通过接口来聚合\n\t\n\t//构造器\n\tpublic TeacherDaoProxy(ITeacherDao target) {\n\t\tthis.target = target;\n\t}\n\t\n\t@Override\n\tpublic void teach() {\n\t\tSystem.out.println(\"开始代理  完成某些操作。。。。。 \");//方法\n\t\ttarget.teach();\n\t\tSystem.out.println(\"提交。。。。。\");//方法\n\t}\n}\n\n```\n\n客户端使用：\n\n```java\npackage com.atguigu.proxy.staticproxy;\n\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\t//创建目标对象(被代理对象)\n\t\tTeacherDao teacherDao = new TeacherDao();\n\t\t\n\t\t//创建代理对象, 同时将被代理对象传递给代理对象\n\t\tTeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);\n\t\t\n\t\t//通过代理对象，调用到被代理对象的方法\n\t\t//即：调用的是代理对象的方法，代理对象再去调用目标对象的方法 \n\t\tteacherDaoProxy.teach();\n\t}\n}\n\n```\n\n### （三）静态代理优缺点\n\n- 优点：在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展\n\n- 缺点：因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类\n\n- 一旦接口增加方法,目标对象与代理对象都要维护\n\n \n\n## 三、动态代理\n\n### （一）动态代理模式的基本介绍\n\n- 代理对象,不需要实现接口，但是**目标对象要实现接口**，否则不能用动态代理；\n\n- 代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象；\n\n- 动态代理也叫做：JDK 代理、接口代理；\n\n### （二）JDK 中生成代理对象的API\n\n- 代理类所在包:java.lang.reflect.Proxy；\n\n- JDK 实现代理只需要使用 **newProxyInstance** 方法,但是该方法需要接收三个参数,完整的写法是: static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h )\n\n### （三）动态代理应用实例\n\n-  应用实例要求\n\n  将前面的静态代理改进成动态代理模式(即：JDK 代理模式)\n\n- 思路图解(类图)\n\n​      ![思路图解](%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.resource/%E6%80%9D%E8%B7%AF%E5%9B%BE%E8%A7%A3.jpg)\n\n\n\n-  代码实现\n\n  接口方法：\n\n  ```java\n  package com.atguigu.proxy.dynamic;\n  \n  //接口\n  public interface ITeacherDao {\n  \n  \tvoid teach(); // 授课方法\n  \tvoid sayHello(String name);\n  }\n  \n  ```\n\n  具体的实现类：\n\n  ```java\n  package com.atguigu.proxy.dynamic;\n  \n  public class TeacherDao implements ITeacherDao {\n  \n  \t@Override\n  \tpublic void teach() {\n  \t\tSystem.out.println(\" 老师授课中.... \");\n  \t}\n  \n  \t@Override\n  \tpublic void sayHello(String name) {\n  \t\tSystem.out.println(\"hello \" + name);\n  \t}\n  }\n  \n  ```\n\n   代理类：\n\n  ```java\n  package com.atguigu.proxy.dynamic;\n  \n  import java.lang.reflect.InvocationHandler;\n  import java.lang.reflect.Method;\n  import java.lang.reflect.Proxy;\n  \n  public class ProxyFactory {\n  \n      //维护一个目标对象 , Object\n      private Object target;\n  \n      //构造器 ， 对target(目标对象) 进行初始化\n      public ProxyFactory(Object target) {\n          this.target = target;\n      }\n  \n      //给目标对象生成一个代理对象\n      public Object getProxyInstance() {\n  \n          //方法中参数说明\n  \t\t/*\n  \t\t *  public static Object newProxyInstance(ClassLoader loader,\n                                            Class<?>[] interfaces,\n                                            InvocationHandler h)\n                                            \n              //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定\n              //2. Class<?>[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型\n              //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入\n  \t\t */\n          return Proxy.newProxyInstance(target.getClass().getClassLoader(),\n                  target.getClass().getInterfaces(),\n                  new InvocationHandler() {\n  \n                      @Override\n                      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                          System.out.println(\"JDK代理开始~~\");\n                          //反射机制调用目标对象的方法\n                          Object returnVal = method.invoke(target, args);\n                          System.out.println(\"JDK代理提交\");\n                          return returnVal;\n                      }\n                  });\n      }\n  }\n  \n  ```\n\n  具体的使用\n\n  ```java\n  package com.atguigu.proxy.dynamic;\n  \n  public class Client {\n  \n  \tpublic static void main(String[] args) {\n  \t\t//创建目标对象\n  \t\tITeacherDao target = new TeacherDao();\n  \t\t\n  \t\t//给目标对象，创建代理对象, 可以转成 ITeacherDao\n  \t\tITeacherDao proxyInstance = (ITeacherDao)new ProxyFactory(target).getProxyInstance();\n  \t\n  \t\t// 下面语句结果为：proxyInstance=class com.sun.proxy.$Proxy0 表示内存中动态生成了代理对象\n  \t\tSystem.out.println(\"proxyInstance=\" + proxyInstance.getClass());\n  \t\t\n  \t\t//通过代理对象，调用目标对象的方法\n  \t\tproxyInstance.teach();\n  \t\t\n  \t\tproxyInstance.sayHello(\" tom \");\n  \t}\n  }\n  \n  ```\n\n  \n\n\n\n## 四、Cglib 代理\n\n### （一）Cglib 代理模式的基本介绍\n\n- 静态代理和JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个**单独的对象**,并没**有实现任何的接口**,这个时候可使用目标对象子类来实现代理-这就是 **Cglib** **代理**\n\n- Cglib 代理也叫作**子类代理****,**它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib 代理归属到动态代理。\n\n- Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展 Java 类与实现 Java接口.它广泛的被许多 AOP 的框架使用,例如 Spring AOP，实现方法拦截\n\n- 在 AOP 编程中如何选择代理模式：\n  - 目标对象需要实现接口，用 JDK 代理\n  - 目标对象不需要实现接口，用 Cglib 代理\n\n-  Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类\n\n\n\n###  (二) Cglib 代理模式实现步骤\n\n- 需要引入 cglib 的 jar 文件\n  - asm.jar\n  - asm-commons.jar\n  - asm-tree.jar\n  - cglib.jar\n\n- 在内存中动态构建子类，注意**代理的类不能为 final**，否则报错java.lang.IllegalArgumentException:\n\n- **目标对象的方法如果为 final/static**，那么就不会被拦截,即不会执行目标对象额外的业务方法；\n\n### （三）Cglib 代理模式应用实例\n\n- 应用实例要求\n\n  将前面的案例用 Cglib 代理模式实现\n\n- 思路图解(类图)\n\n​     ![cglib代理类图](%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.resource/cglib%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9B%BE.jpg)\n\n \n\n- 代码实现+Debug 源码[待 debug]\n\n\n 被代理的对象：\n\n```java\npackage com.atguigu.proxy.cglib;\n\npublic class TeacherDao {\n\n\tpublic String teach() {\n\t\tSystem.out.println(\" 老师授课中  ， 我是cglib代理，不需要实现接口 \");\n\t\treturn \"hello\";\n\t}\n}\n```\n\n 代理工厂：\n\n```java\npackage com.atguigu.proxy.cglib;\n\nimport java.lang.reflect.Method;\n\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\n// MethodIntercepter 是 cglib 中的\npublic class ProxyFactory implements MethodInterceptor {\n\n\t//维护一个目标对象\n\tprivate Object target;\n\t\n\t//构造器，作用是：传入一个被代理的对象\n\tpublic ProxyFactory(Object target) {\n\t\tthis.target = target;\n\t}\n\n\t//返回一个代理对象:  是 target 对象的代理对象\n\tpublic Object getProxyInstance() {\n\t\t//1. 创建一个工具类\n\t\tEnhancer enhancer = new Enhancer();\n\t\t//2. 设置父类\n\t\tenhancer.setSuperclass(target.getClass());\n\t\t//3. 设置回调函数\n\t\tenhancer.setCallback(this);\n\t\t//4. 创建子类对象，即代理对象\n\t\treturn enhancer.create();\n\t}\n\t\n\t//重写  intercept 方法，会调用目标对象的方法\n\t@Override\n\tpublic Object intercept(Object arg0, Method method, Object[] args, MethodProxy arg3) throws Throwable {\n\t\tSystem.out.println(\"Cglib代理模式 ~~ 开始\");\n\t\tObject returnVal = method.invoke(target, args);\n\t\tSystem.out.println(\"Cglib代理模式 ~~ 提交\");\n\t\treturn returnVal;\n\t}\n}\n\n```\n\n使用：\n\n```java\npackage com.atguigu.proxy.cglib;\n\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\t//创建目标对象\n\t\tTeacherDao target = new TeacherDao();\n\t\t//获取到代理对象，并且将目标对象传递给代理对象\n\t\tTeacherDao proxyInstance = (TeacherDao)new ProxyFactory(target).getProxyInstance();\n\n\t\t//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用\n\t\tString res = proxyInstance.teach();\n\t\tSystem.out.println(\"res=\" + res);\n\t}\n}\n\n```\n\n\n\n## 五、几种常见的代理模式介绍— 几种变体\n\n- 防火墙代理\n\n内网通过代理穿透防火墙，实现对公网的访问。\n\n- 缓存代理\n\n比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok,如果取不到资源，再到公网或者数据库取，然后缓存。\n\n- 远程代理\n\n远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。\n\n- 同步代理：主要使用在多线程编程中，完成多线程间同步工作同步代理：主要使用在多线程编程中，完成多线程间同步工作",[[1573826256940,["GJX@GJXAIOU",[[-1,1046,"atguig"],[1,1052,"gjxaio"]],[1046,1053],[1046,1053]]],[1573826257150,["GJX@GJXAIOU",[[-1,1170,"atguig"],[1,1176,"gjxaio"]],[1170,1177],[1170,1177]]],[1573826257429,["GJX@GJXAIOU",[[-1,1357,"atguig"],[1,1363,"gjxaio"]],[1357,1364],[1357,1364]]],[1573826257587,["GJX@GJXAIOU",[[-1,1757,"atguig"],[1,1763,"gjxaio"]],[1757,1764],[1757,1764]]],[1573826257848,["GJX@GJXAIOU",[[-1,2851,"atguig"],[1,2857,"gjxaio"]],[2851,2858],[2851,2858]]],[1573826258023,["GJX@GJXAIOU",[[-1,3025,"atguig"],[1,3031,"gjxaio"]],[3025,3032],[3025,3032]]],[1573826258287,["GJX@GJXAIOU",[[-1,3335,"atguig"],[1,3341,"gjxaio"]],[3335,3342],[3335,3342]]],[1573826258398,["GJX@GJXAIOU",[[-1,4947,"atguig"],[1,4953,"gjxaio"]],[4947,4954],[4947,4954]]],[1573826258703,["GJX@GJXAIOU",[[-1,6465,"atguig"],[1,6471,"gjxaio"]],[6465,6472],[6465,6472]]],[1573826258821,["GJX@GJXAIOU",[[-1,6649,"atguig"],[1,6655,"gjxaio"]],[6649,6656],[6649,6656]]],[1573826259116,["GJX@GJXAIOU",[[-1,7651,"atguig"],[1,7657,"gjxaio"]],[7651,7658],[7651,7658]]]],null,"GJX@GJXAIOU"],["ef7280e4-ace1-4e0d-b832-12dd764ad375",1573826689593,"# 第十五章：代理模式\n\n \n\n## 一、代理模式(Proxy)\n\n### （一）代理模式的基本介绍\n\n \n\n- 代理模式：**为一个对象提供一个替身，以控制对这个对象（被代理的对象）的访问**。即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。\n\n- 被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象；\n\n- 代理模式有不同的形式, 主要有三种 **静态代理**、**动态代理** (JDK 代理、接口代理)和 **Cglib** **代理** (可以在内存动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴) 。\n\n- 代理模式示意图\n\n ![代理模式示意图](%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.resource/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)\n\n## 二、静态代理\n\n### （一）静态代码模式的基本介绍\n\n静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类\n\n### （二）应用实例\n\n具体要求\n\n- 定义一个接口：ITeacherDao\n\n- 目标对象 TeacherDAO 实现接口 ITeacherDAO\n\n- 使用静态代理方式,就需要在代理对象 TeacherDAOProxy 中也实现 ITeacherDAO\n\n- 调用的时候通过调用代理对象的方法来调用目标对象.\n\n- 特别提醒：代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法\n\n \n\n 思路分析图解(类图)\n\n ![静态代理思路分析图解](%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.resource/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%E5%9B%BE%E8%A7%A3.jpg)\n\n- 代码实现\n\n接口：ITeacherDao\n\n```java\npackage com.gjxaiou.proxy.staticproxy;\n\n//接口\npublic interface ITeacherDao {\n\tvoid teach(); // 授课的方法\n}\n\n```\n\n 实现接口：\n\n```java\npackage com.gjxaiou.proxy.staticproxy;\n\npublic class TeacherDao implements ITeacherDao {\n\n\t@Override\n\tpublic void teach() {\n\t\tSystem.out.println(\" 老师授课中  。。。。。\");\n\t}\n}\n\n```\n\n代理：\n\n```java\npackage com.gjxaiou.proxy.staticproxy;\n\n//代理对象,静态代理\npublic class TeacherDaoProxy implements ITeacherDao{\n\t\n\tprivate ITeacherDao target; // 目标对象，通过接口来聚合\n\t\n\t//构造器\n\tpublic TeacherDaoProxy(ITeacherDao target) {\n\t\tthis.target = target;\n\t}\n\t\n\t@Override\n\tpublic void teach() {\n\t\tSystem.out.println(\"开始代理  完成某些操作。。。。。 \");//方法\n\t\ttarget.teach();\n\t\tSystem.out.println(\"提交。。。。。\");//方法\n\t}\n}\n\n```\n\n客户端使用：\n\n```java\npackage com.gjxaiou.proxy.staticproxy;\n\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\t//创建目标对象(被代理对象)\n\t\tTeacherDao teacherDao = new TeacherDao();\n\t\t\n\t\t//创建代理对象, 同时将被代理对象传递给代理对象\n\t\tTeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);\n\t\t\n\t\t//通过代理对象，调用到被代理对象的方法\n\t\t//即：调用的是代理对象的方法，代理对象再去调用目标对象的方法 \n\t\tteacherDaoProxy.teach();\n\t}\n}\n\n```\n\n### （三）静态代理优缺点\n\n- 优点：在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展\n\n- 缺点：因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类\n\n- 一旦接口增加方法,目标对象与代理对象都要维护\n\n \n\n## 三、动态代理\n\n### （一）动态代理模式的基本介绍\n\n- 代理对象,不需要实现接口，但是**目标对象要实现接口**，否则不能用动态代理；\n\n- 代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象；\n\n- 动态代理也叫做：JDK 代理、接口代理；\n\n### （二）JDK 中生成代理对象的API\n\n- 代理类所在包:java.lang.reflect.Proxy；\n\n- JDK 实现代理只需要使用 **newProxyInstance** 方法,但是该方法需要接收三个参数,完整的写法是: static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h )\n\n### （三）动态代理应用实例\n\n-  应用实例要求\n\n  将前面的静态代理改进成动态代理模式(即：JDK 代理模式)\n\n- 思路图解(类图)\n\n​      ![思路图解](%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.resource/%E6%80%9D%E8%B7%AF%E5%9B%BE%E8%A7%A3.jpg)\n\n\n\n-  代码实现\n\n  接口方法：\n\n  ```java\n  package com.gjxaiou.proxy.dynamic;\n  \n  //接口\n  public interface ITeacherDao {\n  \n  \tvoid teach(); // 授课方法\n  \tvoid sayHello(String name);\n  }\n  \n  ```\n\n  具体的实现类：\n\n  ```java\n  package com.gjxaiou.proxy.dynamic;\n  \n  public class TeacherDao implements ITeacherDao {\n  \n  \t@Override\n  \tpublic void teach() {\n  \t\tSystem.out.println(\" 老师授课中.... \");\n  \t}\n  \n  \t@Override\n  \tpublic void sayHello(String name) {\n  \t\tSystem.out.println(\"hello \" + name);\n  \t}\n  }\n  \n  ```\n\n   代理类：\n\n  ```java\n  package com.gjxaiou.proxy.dynamic;\n  \n  import java.lang.reflect.InvocationHandler;\n  import java.lang.reflect.Method;\n  import java.lang.reflect.Proxy;\n  \n  public class ProxyFactory {\n  \n      //维护一个目标对象 , Object\n      private Object target;\n  \n      //构造器 ， 对target(目标对象) 进行初始化\n      public ProxyFactory(Object target) {\n          this.target = target;\n      }\n  \n      //给目标对象生成一个代理对象\n      public Object getProxyInstance() {\n  \n          //方法中参数说明\n  \t\t/*\n  \t\t *  public static Object newProxyInstance(ClassLoader loader,\n                                            Class<?>[] interfaces,\n                                            InvocationHandler h)\n                                            \n              //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定\n              //2. Class<?>[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型\n              //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入\n  \t\t */\n          return Proxy.newProxyInstance(target.getClass().getClassLoader(),\n                  target.getClass().getInterfaces(),\n                  new InvocationHandler() {\n  \n                      @Override\n                      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                          System.out.println(\"JDK代理开始~~\");\n                          //反射机制调用目标对象的方法\n                          Object returnVal = method.invoke(target, args);\n                          System.out.println(\"JDK代理提交\");\n                          return returnVal;\n                      }\n                  });\n      }\n  }\n  \n  ```\n\n  具体的使用\n\n  ```java\n  package com.gjxaiou.proxy.dynamic;\n  \n  public class Client {\n  \n  \tpublic static void main(String[] args) {\n  \t\t//创建目标对象\n  \t\tITeacherDao target = new TeacherDao();\n  \t\t\n  \t\t//给目标对象，创建代理对象, 可以转成 ITeacherDao\n  \t\tITeacherDao proxyInstance = (ITeacherDao)new ProxyFactory(target).getProxyInstance();\n  \t\n  \t\t// 下面语句结果为：proxyInstance=class com.sun.proxy.$Proxy0 表示内存中动态生成了代理对象\n  \t\tSystem.out.println(\"proxyInstance=\" + proxyInstance.getClass());\n  \t\t\n  \t\t//通过代理对象，调用目标对象的方法\n  \t\tproxyInstance.teach();\n  \t\t\n  \t\tproxyInstance.sayHello(\" tom \");\n  \t}\n  }\n  \n  ```\n\n  \n\n\n\n## 四、Cglib 代理\n\n### （一）Cglib 代理模式的基本介绍\n\n- 静态代理和JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个**单独的对象**,并没**有实现任何的接口**,这个时候可使用目标对象子类来实现代理-这就是 **Cglib** **代理**\n\n- Cglib 代理也叫作**子类代理****,**它是在内存中构建一个子类对象从而实现对目标对象功能扩展, 有些书也将Cglib 代理归属到动态代理。\n\n- Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展 Java 类与实现 Java接口.它广泛的被许多 AOP 的框架使用,例如 Spring AOP，实现方法拦截\n\n- 在 AOP 编程中如何选择代理模式：\n  - 目标对象需要实现接口，用 JDK 代理\n  - 目标对象不需要实现接口，用 Cglib 代理\n\n-  Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类\n\n\n\n###  (二) Cglib 代理模式实现步骤\n\n- 需要引入 cglib 的 jar 文件\n  - asm.jar\n  - asm-commons.jar\n  - asm-tree.jar\n  - cglib.jar\n\n- 在内存中动态构建子类，注意**代理的类不能为 final**，否则报错java.lang.IllegalArgumentException:\n\n- **目标对象的方法如果为 final/static**，那么就不会被拦截,即不会执行目标对象额外的业务方法；\n\n### （三）Cglib 代理模式应用实例\n\n- 应用实例要求\n\n  将前面的案例用 Cglib 代理模式实现\n\n- 思路图解(类图)\n\n​     ![cglib代理类图](%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.resource/cglib%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9B%BE.jpg)\n\n \n\n- 代码实现+Debug 源码[待 debug]\n\n\n 被代理的对象：\n\n```java\npackage com.gjxaiou.proxy.cglib;\n\npublic class TeacherDao {\n\n\tpublic String teach() {\n\t\tSystem.out.println(\" 老师授课中  ， 我是cglib代理，不需要实现接口 \");\n\t\treturn \"hello\";\n\t}\n}\n```\n\n 代理工厂：\n\n```java\npackage com.gjxaiou.proxy.cglib;\n\nimport java.lang.reflect.Method;\n\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\n// MethodIntercepter 是 cglib 中的\npublic class ProxyFactory implements MethodInterceptor {\n\n\t//维护一个目标对象\n\tprivate Object target;\n\t\n\t//构造器，作用是：传入一个被代理的对象\n\tpublic ProxyFactory(Object target) {\n\t\tthis.target = target;\n\t}\n\n\t//返回一个代理对象:  是 target 对象的代理对象\n\tpublic Object getProxyInstance() {\n\t\t//1. 创建一个工具类\n\t\tEnhancer enhancer = new Enhancer();\n\t\t//2. 设置父类\n\t\tenhancer.setSuperclass(target.getClass());\n\t\t//3. 设置回调函数\n\t\tenhancer.setCallback(this);\n\t\t//4. 创建子类对象，即代理对象\n\t\treturn enhancer.create();\n\t}\n\t\n\t//重写  intercept 方法，会调用目标对象的方法\n\t@Override\n\tpublic Object intercept(Object arg0, Method method, Object[] args, MethodProxy arg3) throws Throwable {\n\t\tSystem.out.println(\"Cglib代理模式 ~~ 开始\");\n\t\tObject returnVal = method.invoke(target, args);\n\t\tSystem.out.println(\"Cglib代理模式 ~~ 提交\");\n\t\treturn returnVal;\n\t}\n}\n\n```\n\n使用：\n\n```java\npackage com.gjxaiou.proxy.cglib;\n\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\t//创建目标对象\n\t\tTeacherDao target = new TeacherDao();\n\t\t//获取到代理对象，并且将目标对象传递给代理对象\n\t\tTeacherDao proxyInstance = (TeacherDao)new ProxyFactory(target).getProxyInstance();\n\n\t\t//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用\n\t\tString res = proxyInstance.teach();\n\t\tSystem.out.println(\"res=\" + res);\n\t}\n}\n\n```\n\n\n\n## 五、几种常见的代理模式介绍— 几种变体\n\n- 防火墙代理\n\n内网通过代理穿透防火墙，实现对公网的访问。\n\n- 缓存代理\n\n比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok,如果取不到资源，再到公网或者数据库取，然后缓存。\n\n- 远程代理\n\n远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。\n\n- 同步代理：主要使用在多线程编程中，完成多线程间同步工作同步代理：主要使用在多线程编程中，完成多线程间同步工作",[[1573826645381,["GJX@GJXAIOU",[[-1,2827,"  "]],[2827,2829],[2827,2827]]],[1573826649316,["GJX@GJXAIOU",[[-1,2981,"  "]],[2981,2983],[2981,2981]]],[1573826653524,["GJX@GJXAIOU",[[-1,2997,"  "]],[2997,2999],[2997,2997]]],[1573826657421,["GJX@GJXAIOU",[[-1,3289,"  "]],[3289,3291],[3289,3289]]],[1573826660171,["GJX@GJXAIOU",[[-1,3303,"  "]],[3303,3305],[3303,3303]]],[1573826666798,["GJX@GJXAIOU",[[-1,4897,"  "]],[4897,4899],[4897,4897]]],[1573826673004,["GJX@GJXAIOU",[[-1,4911,"  "]],[4911,4913],[4911,4911]]],[1573826678348,["GJX@GJXAIOU",[[-1,5472,"  "]],[5472,5474],[5472,5472]]],[1573826688548,["GJX@GJXAIOU",[[-1,5482,"\n"]],[5480,5480],[5479,5479]]],[1573826689062,["GJX@GJXAIOU",[[-1,5478," "]],[5479,5479],[5478,5478]]],[1573826689681,["GJX@GJXAIOU",[[-1,5477," "]],[5478,5478],[5477,5477]]],[1573826691693,["GJX@GJXAIOU",[[-1,5479,"\n"]],[5478,5478],[5477,5477]]],[1573826692573,["GJX@GJXAIOU",[[-1,5478,"\n"]],[5477,5477],[5476,5476]]]],null,"GJX@GJXAIOU"]]}