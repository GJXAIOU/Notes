{"compress":true,"commitItems":[["81348c71-39f3-4273-bc4e-002db0275a14",1573826270512,"# 第二十二章：备忘录模式\n\n## 一、游戏角色状态恢复问题\n\n游戏角色有攻击力和防御力，在大战Boss 前保存自身的状态(攻击力和防御力)，当大战 Boss 后攻击力和防御力下降，从备忘录对象恢复到大战前的状态\n\n## 二、传统方案解决游戏角色恢复\n\n ![1573806723874](%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.resource/1573806723874.png)\n\n \n\n## 三、传统的方式的问题分析\n\n- 一个对象，就对应一个保存对象状态的对象， 这样当我们游戏的对象很多时，不利于管理，开销也很大.\n\n- 传统的方式是简单地做备份，new 出另外一个对象出来，再把需要备份的数据放到这个新对象，但这就暴露了对象内部的细节\n\n- 解决方案： => **备忘录**模式\n\n## 四、备忘录模式基本介绍\n\n基本介绍\n\n- 备忘录模式（Memento Pattern）在**不破坏封装性的前提**下，捕获**一个对象的内部状态**，并在该对象之外保存这个状态。这样以后就**可将该对象恢复到原先保存的状态**\n\n-  可以这里理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作\n\n- 备忘录模式属于行为型模式\n\n## 五、备忘录模式的原理类图\n\n​        ![1573806807607](%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.resource/1573806807607.png)\n \n\n- 对原理类图的说明-即(备忘录模式的角色及职责)\n  - originator :  对象(需要保存状态的对象)\n  - Memento ： 备忘录对象,负责保存好记录，即 Originator 内部状态\n  - Caretaker: 守护者对象,负责保存多个备忘录对象， 使用集合管理，提高效率\n  - 说明：如果希望保存多个 originator 对象的不同时间的状态，也可以，只需要要 HashMap <String, 集合>\n\n\n\n- 代码实现\n\n需要保存状态的对象\n\n```java\npackage com.atguigu.memento.theory;\n\npublic class Originator {\n\n\tprivate String state;//状态信息\n\n\tpublic String getState() {\n\t\treturn state;\n\t}\n\n\tpublic void setState(String state) {\n\t\tthis.state = state;\n\t}\n\t\n\t//编写一个方法，可以保存一个状态对象 Memento\n\t//因此编写一个方法，返回 Memento\n\tpublic Memento saveStateMemento() {\n\t\treturn new Memento(state);\n\t}\n\t\n\t//通过备忘录对象，恢复状态\n\tpublic void getStateFromMemento(Memento memento) {\n\t\tstate = memento.getState();\n\t}\n}\n\n```\n\n备忘录对象：\n\n```java\npackage com.atguigu.memento.theory;\n\npublic class Memento {\n\tprivate String state;\n\n\t//构造器\n\tpublic Memento(String state) {\n\t\tsuper();\n\t\tthis.state = state;\n\t}\n\n\tpublic String getState() {\n\t\treturn state;\n\t}\n}\n\n```\n\n守护者对象\n\n```java\npackage com.atguigu.memento.theory;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Caretaker {\n\t\n\t//在List 集合中会有很多的备忘录对象\n\tprivate List<Memento> mementoList = new ArrayList<Memento>();\n\t\n\tpublic void add(Memento memento) {\n\t\tmementoList.add(memento);\n\t}\n\t\n\t//获取到第index个Originator 的 备忘录对象(即保存状态)\n\tpublic Memento get(int index) {\n\t\treturn mementoList.get(index);\n\t}\n}\n\n```\n\n使用\n\n```java\npackage com.atguigu.memento.theory;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\tOriginator originator = new Originator();\n\t\tCaretaker caretaker = new Caretaker();\n\t\t\n\t\toriginator.setState(\" 状态#1 攻击力 100 \");\n\t\t\n\t\t//保存了当前的状态\n\t\tcaretaker.add(originator.saveStateMemento());\n\t\t\n\t\toriginator.setState(\" 状态#2 攻击力 80 \");\n\t\t\n\t\tcaretaker.add(originator.saveStateMemento());\n\t\t\n\t\toriginator.setState(\" 状态#3 攻击力 50 \");\n\t\tcaretaker.add(originator.saveStateMemento());\n\t\t\n\t\tSystem.out.println(\"当前的状态是 =\" + originator.getState());\n\t\t\n\t\t//希望得到状态 1, 将 originator 恢复到状态1\n\t\toriginator.getStateFromMemento(caretaker.get(0));\n\t\tSystem.out.println(\"恢复到状态1 , 当前的状态是\");\n\t\tSystem.out.println(\"当前的状态是 =\" + originator.getState());\n\t}\n}\n\n```\n\n\n\n## 六、游戏角色恢复状态实例\n\n- 应用实例要求\n\n游戏角色有攻击力和防御力，在大战 Boss 前保存自身的状态(攻击力和防御力)，当大战 Boss 后攻击力和防御力下降，从备忘录对象恢复到大战前的状态\n\n- 思路分析和图解(类图)\n\n​        ![1573807322350](%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.resource/1573807322350.png)\n\n \n\n- 代码实现\n\n游戏角色\n\n```java\npackage com.atguigu.memento.game;\n\npublic class GameRole {\n\n\tprivate int vit;\n\tprivate int def;\n\t\n\t//创建Memento ,即根据当前的状态得到Memento\n\tpublic Memento createMemento() {\n\t\treturn new Memento(vit, def);\n\t}\n\t\n\t//从备忘录对象，恢复GameRole的状态\n\tpublic void recoverGameRoleFromMemento(Memento memento) {\n\t\tthis.vit = memento.getVit();\n\t\tthis.def = memento.getDef();\n\t}\n\t\n\t//显示当前游戏角色的状态\n\tpublic void display() {\n\t\tSystem.out.println(\"游戏角色当前的攻击力：\" + this.vit + \" 防御力: \" + this.def);\n\t}\n\n\tpublic int getVit() {\n\t\treturn vit;\n\t}\n\n\tpublic void setVit(int vit) {\n\t\tthis.vit = vit;\n\t}\n\n\tpublic int getDef() {\n\t\treturn def;\n\t}\n\n\tpublic void setDef(int def) {\n\t\tthis.def = def;\n\t}\n}\n\n```\n\n\n\n备忘录对象\n\n```java\npackage com.atguigu.memento.game;\n\npublic class Memento {\n\n\t//攻击力\n\tprivate int vit;\n\t//防御力\n\tprivate int def;\n\tpublic Memento(int vit, int def) {\n\t\tsuper();\n\t\tthis.vit = vit;\n\t\tthis.def = def;\n\t}\n\tpublic int getVit() {\n\t\treturn vit;\n\t}\n\tpublic void setVit(int vit) {\n\t\tthis.vit = vit;\n\t}\n\tpublic int getDef() {\n\t\treturn def;\n\t}\n\tpublic void setDef(int def) {\n\t\tthis.def = def;\n\t}\n}\n\n```\n\n守护者对象\n\n```java\npackage com.atguigu.memento.game;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\n//守护者对象, 保存游戏角色的状态\npublic class Caretaker {\n\n\t//如果只保存一次状态\n\tprivate Memento  memento;\n\t//对GameRole 保存多次状态\n\t//private ArrayList<Memento> mementos;\n\t//对多个游戏角色保存多个状态\n\t//private HashMap<String, ArrayList<Memento>> rolesMementos;\n\n\tpublic Memento getMemento() {\n\t\treturn memento;\n\t}\n\n\tpublic void setMemento(Memento memento) {\n\t\tthis.memento = memento;\n\t}\n}\n\n```\n\n使用\n\n```java\npackage com.atguigu.memento.game;\n\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\t//创建游戏角色\n\t\tGameRole gameRole = new GameRole();\n\t\tgameRole.setVit(100);\n\t\tgameRole.setDef(100);\n\t\t\n\t\tSystem.out.println(\"和boss大战前的状态\");\n\t\tgameRole.display();\n\t\t\n\t\t//把当前状态保存caretaker\n\t\tCaretaker caretaker = new Caretaker();\n\t\tcaretaker.setMemento(gameRole.createMemento());\n\t\t\n\t\tSystem.out.println(\"和boss大战~~~\");\n\t\tgameRole.setDef(30);\n\t\tgameRole.setVit(30);\n\t\t\n\t\tgameRole.display();\n\t\t\n\t\tSystem.out.println(\"大战后，使用备忘录对象恢复到站前\");\n\t\t\n\t\tgameRole.recoverGameRoleFromMemento(caretaker.getMemento());\n\t\tSystem.out.println(\"恢复后的状态\");\n\t\tgameRole.display();\n\t}\n\n}\n\n```\n\n\n\n## 七、备忘录模式的注意事项和细节\n\n- 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态\n\n- 实现了信息的封装，使得用户不需要关心状态的保存细节\n\n-  如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存, 这个需要注意\n\n- 适用的应用场景：1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理\n\n- 为了节约内存，备忘录模式可以和原型模式配合使用",[[1573826212221,["GJX@GJXAIOU",[[-1,1137,"atguig"],[1,1143,"gjxaio"]],[1137,1144],[1137,1144]]],[1573826212463,["GJX@GJXAIOU",[[-1,1592,"atguig"],[1,1598,"gjxaio"]],[1592,1599],[1592,1599]]],[1573826212688,["GJX@GJXAIOU",[[-1,1822,"atguig"],[1,1828,"gjxaio"]],[1822,1829],[1822,1829]]],[1573826212858,["GJX@GJXAIOU",[[-1,2223,"atguig"],[1,2229,"gjxaio"]],[2223,2230],[2223,2230]]],[1573826213088,["GJX@GJXAIOU",[[-1,3319,"atguig"],[1,3325,"gjxaio"]],[3319,3326],[3319,3326]]],[1573826213243,["GJX@GJXAIOU",[[-1,3996,"atguig"],[1,4002,"gjxaio"]],[3996,4003],[3996,4003]]],[1573826213483,["GJX@GJXAIOU",[[-1,4398,"atguig"],[1,4404,"gjxaio"]],[4398,4405],[4398,4405]]],[1573826213702,["GJX@GJXAIOU",[[-1,4858,"atguig"],[1,4864,"gjxaio"]],[4858,4865],[4858,4865]]]],null,"GJX@GJXAIOU"]]}