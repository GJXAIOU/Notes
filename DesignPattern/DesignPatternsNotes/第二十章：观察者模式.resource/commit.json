{"compress":true,"commitItems":[["b4bc4f1c-0ff7-4f0f-b7d7-abf902e91791",1573826281675,"# 第二十章：观察者模式\n\n## 一、天气预报项目需求,具体要求如下：\n\n \n\n- 气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如发布到自己的网站或第三方)。\n\n- 需要设计开放型API，便于其他第三方也能接入气象站获取数据。\n\n- 提供温度、气压和湿度的接口\n\n- 测量数据更新时，要能实时的通知给第三方\n\n \n\n \n\n## 二、天气预报设计方案 1-普通方案\n\n### （一）WeatherData 类\n\n- 传统的设计方案\n\n ![1573802509193](%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.resource/1573802509193.png)\n\n![1573802516422](%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.resource/1573802516422.png)\n \n\n- 代码实现\n\n```java\npackage com.atguigu.observer;\n\n/**\n * 类是核心\n * 1. 包含最新的天气情况信息 \n * 2. 含有 CurrentConditions 对象\n * 3. 当数据有更新时，就主动的调用   CurrentConditions对象update方法(含 display), 这样他们（接入方）就看到最新的信息\n * @author Administrator\n *\n */\npublic class WeatherData {\n\tprivate float temperatrue;\n\tprivate float pressure;\n\tprivate float humidity;\n\tprivate CurrentConditions currentConditions;\n\t//加入新的第三方\n\n\tpublic WeatherData(CurrentConditions currentConditions) {\n\t\tthis.currentConditions = currentConditions;\n\t}\n\n\tpublic float getTemperature() {\n\t\treturn temperatrue;\n\t}\n\n\tpublic float getPressure() {\n\t\treturn pressure;\n\t}\n\n\tpublic float getHumidity() {\n\t\treturn humidity;\n\t}\n\n\tpublic void dataChange() {\n\t\t//调用 接入方的 update\n\t\tcurrentConditions.update(getTemperature(), getPressure(), getHumidity());\n\t}\n\n\t//当数据有更新时，就调用 setData\n\tpublic void setData(float temperature, float pressure, float humidity) {\n\t\tthis.temperatrue = temperature;\n\t\tthis.pressure = pressure;\n\t\tthis.humidity = humidity;\n\t\t//调用dataChange， 将最新的信息 推送给 接入方 currentConditions\n\t\tdataChange();\n\t}\n}\n\n```\n\n\n\n```java\npackage com.atguigu.observer;\n\n/**\n * 显示当前天气情况（可以理解成是气象站自己的网站）\n * @author Administrator\n *\n */\npublic class CurrentConditions {\n\t// 温度，气压，湿度\n\tprivate float temperature;\n\tprivate float pressure;\n\tprivate float humidity;\n\n\t//更新 天气情况，是由 WeatherData 来调用，我使用推送模式\n\tpublic void update(float temperature, float pressure, float humidity) {\n\t\tthis.temperature = temperature;\n\t\tthis.pressure = pressure;\n\t\tthis.humidity = humidity;\n\t\tdisplay();\n\t}\n\n\t//显示\n\tpublic void display() {\n\t\tSystem.out.println(\"***Today mTemperature: \" + temperature + \"***\");\n\t\tSystem.out.println(\"***Today mPressure: \" + pressure + \"***\");\n\t\tSystem.out.println(\"***Today mHumidity: \" + humidity + \"***\");\n\t}\n}\n\n```\n\n\n\n 使用：\n\n```java\npackage com.atguigu.observer;\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t//创建接入方 currentConditions\n\t\tCurrentConditions currentConditions = new CurrentConditions();\n\t\t//创建 WeatherData 并将 接入方 currentConditions 传递到 WeatherData中\n\t\tWeatherData weatherData = new WeatherData(currentConditions);\n\t\t\n\t\t//更新天气情况\n\t\tweatherData.setData(30, 150, 40);\n\t\t\n\t\t//天气情况变化\n\t\tSystem.out.println(\"============天气情况变化=============\");\n\t\tweatherData.setData(40, 160, 20);\n\t}\n}\n\n```\n\n\n\n- 问题分析\n  - 其他第三方接入气象站获取数据的问题\n  -  无法在运行时动态的添加第三方 (新浪网站)\n  - 违反 ocp 原则=>观察者模式\n\n  //在 WeatherData 中，当增加一个第三方，都需要创建一个对应的第三方的公告板对象，并加入到 dataChange, 不利于维护，也不是动态加入\n\npublic void dataChange() {\n\ncurrentConditions.update(getTemperature(), getPressure(), getHumidity());\n\n}\n\n## 三、观察者模式原理\n\n \n\n- 观察者模式类似订牛奶业务\n\n- 奶站/气象局：Subject\n\n- 用户/第三方网站：Observer\n\n \n\n-  Subject：登记注册、移除和通知\n  - registerObserver 注册\n  - removeObserver 移除\n  - notifyObservers() 通知所有的注册的用户，根据不同需求，可以是更新数据，让用户来取，也可能是实施推送， 看具体需求定\n\n-  Observer：接收输入\n\n- 观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为 Subject，依赖的对象为 Observer，Subject 通知 Observer 变化,比如这里的奶站是 Subject，是 1 的一方。用户时 Observer，是多的一方。\n\n## 四、观察者模式解决天气预报需求\n\n### （一） 类图说明\n\n\n ![1573802752778](%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.resource/1573802752778.png)\n\n \n\n   \n\n \n\n### （二）代码实现\n\n​       观察者接口：\n\n```java\npackage com.atguigu.observer.improve;\n\n//观察者接口，有观察者来实现\npublic interface Observer {\n\n\tpublic void update(float temperature, float pressure, float humidity);\n}\n\n```\n\n具体的观察者：\n\n```java\npackage com.atguigu.observer.improve;\n\npublic class CurrentConditions implements Observer {\n\n\t// 温度，气压，湿度\n\tprivate float temperature;\n\tprivate float pressure;\n\tprivate float humidity;\n\n\t// 更新 天气情况，是由 WeatherData 来调用，我使用推送模式\n\t@Override\n    public void update(float temperature, float pressure, float humidity) {\n\t\tthis.temperature = temperature;\n\t\tthis.pressure = pressure;\n\t\tthis.humidity = humidity;\n\t\tdisplay();\n\t}\n\n\t// 显示\n\tpublic void display() {\n\t\tSystem.out.println(\"***Today mTemperature: \" + temperature + \"***\");\n\t\tSystem.out.println(\"***Today mPressure: \" + pressure + \"***\");\n\t\tSystem.out.println(\"***Today mHumidity: \" + humidity + \"***\");\n\t}\n}\n\n//-------------------------------------------------------------\npackage com.atguigu.observer.improve;\n\npublic class BaiduSite implements Observer {\n\n\t// 温度，气压，湿度\n\tprivate float temperature;\n\tprivate float pressure;\n\tprivate float humidity;\n\n\t// 更新 天气情况，是由 WeatherData 来调用，我使用推送模式\n\t@Override\n    public void update(float temperature, float pressure, float humidity) {\n\t\tthis.temperature = temperature;\n\t\tthis.pressure = pressure;\n\t\tthis.humidity = humidity;\n\t\tdisplay();\n\t}\n\n\t// 显示\n\tpublic void display() {\n\t\tSystem.out.println(\"===百度网站====\");\n\t\tSystem.out.println(\"***百度网站 气温 : \" + temperature + \"***\");\n\t\tSystem.out.println(\"***百度网站 气压: \" + pressure + \"***\");\n\t\tSystem.out.println(\"***百度网站 湿度: \" + humidity + \"***\");\n\t}\n\n}\n\n```\n\n订阅对象抽象类和具体数据\n\n```java\npackage com.atguigu.observer.improve;\n\n//接口, 让WeatherData 来实现 \npublic interface Subject {\n\t\n\tpublic void registerObserver(Observer o);\n\tpublic void removeObserver(Observer o);\n\tpublic void notifyObservers();\n}\n\n//----------------------------------------------\npackage com.atguigu.observer.improve;\n\nimport java.util.ArrayList;\n\n/**\n * 类是核心\n * 1. 包含最新的天气情况信息 \n * 2. 含有 观察者集合，使用ArrayList管理\n * 3. 当数据有更新时，就主动的调用   ArrayList, 通知所有的（接入方）就看到最新的信息\n * @author Administrator\n *\n */\npublic class WeatherData implements Subject {\n\tprivate float temperatrue;\n\tprivate float pressure;\n\tprivate float humidity;\n\t//观察者集合\n\tprivate ArrayList<Observer> observers;\n\t\n\t//加入新的第三方\n\n\tpublic WeatherData() {\n\t\tobservers = new ArrayList<Observer>();\n\t}\n\n\tpublic float getTemperature() {\n\t\treturn temperatrue;\n\t}\n\n\tpublic float getPressure() {\n\t\treturn pressure;\n\t}\n\n\tpublic float getHumidity() {\n\t\treturn humidity;\n\t}\n\n\tpublic void dataChange() {\n\t\t//调用 接入方的 update\n\t\t\n\t\tnotifyObservers();\n\t}\n\n\t//当数据有更新时，就调用 setData\n\tpublic void setData(float temperature, float pressure, float humidity) {\n\t\tthis.temperatrue = temperature;\n\t\tthis.pressure = pressure;\n\t\tthis.humidity = humidity;\n\t\t//调用dataChange， 将最新的信息 推送给 接入方 currentConditions\n\t\tdataChange();\n\t}\n\n\t//注册一个观察者\n\t@Override\n\tpublic void registerObserver(Observer o) {\n\t\tobservers.add(o);\n\t}\n\n\t//移除一个观察者\n\t@Override\n\tpublic void removeObserver(Observer o) {\n\t\tif(observers.contains(o)) {\n\t\t\tobservers.remove(o);\n\t\t}\n\t}\n\n\t//遍历所有的观察者，并通知\n\t@Override\n\tpublic void notifyObservers() {\n\t\tfor(int i = 0; i < observers.size(); i++) {\n\t\t\tobservers.get(i).update(this.temperatrue, this.pressure, this.humidity);\n\t\t}\n\t}\n}\n\n```\n\n\n\n使用：\n\n```java\npackage com.atguigu.observer.improve;\n\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\t//创建一个WeatherData\n\t\tWeatherData weatherData = new WeatherData();\n\t\t\n\t\t//创建观察者\n\t\tCurrentConditions currentConditions = new CurrentConditions();\n\t\tBaiduSite baiduSite = new BaiduSite();\n\t\t\n\t\t//注册到weatherData\n\t\tweatherData.registerObserver(currentConditions);\n\t\tweatherData.registerObserver(baiduSite);\n\t\t\n\t\t//测试\n\t\tSystem.out.println(\"通知各个注册的观察者, 看看信息\");\n\t\tweatherData.setData(10f, 100f, 30.3f);\n\t\t\n\t\tweatherData.removeObserver(currentConditions);\n\t\t//测试\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"通知各个注册的观察者, 看看信息\");\n\t\tweatherData.setData(10f, 100f, 30.3f);\n\t}\n}\n\n```\n\n### （三）观察者模式的好处\n\n\n\n- 观察者模式设计后，会以集合的方式来管理用户(Observer)，包括注册，移除和通知。\n\n- 这样，我们增加观察者(这里可以理解成一个新的公告板)，就不需要去修改核心类 WeatherData 不会修改代码， 遵守了 ocp 原则。\n\n## 五、观察者模式在Jdk 应用的源码分析\n\n- Jdk 的 Observable 类就使用了观察者模式\n\n- 代码分析+模式角色分析\n\n\n ![1573803471001](%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.resource/1573803471001.png)\n\n- 模式角色分析\n  - Observable    的作用和地位等价于 我们前面讲过 Subject\n  - Observable 是类，不是接口，类中已经实现了核心的方法 ,即管理 Observer 的方法 add.. delete .. notify...\n  - Observer 的作用和地位等价于我们前面讲过的 Observer, 有 update\n  - Observable 和 Observer 的使用方法和前面讲过的一样，只是 Observable 是类，通过继承来实现观察者模式",[[1573826223208,["GJX@GJXAIOU",[[-1,533,"atguig"],[1,539,"gjxaio"]],[533,540],[533,540]]],[1573826223495,["GJX@GJXAIOU",[[-1,1577,"atguig"],[1,1583,"gjxaio"]],[1577,1584],[1577,1584]]],[1573826223728,["GJX@GJXAIOU",[[-1,2274,"atguig"],[1,2280,"gjxaio"]],[2274,2281],[2274,2281]]],[1573826223894,["GJX@GJXAIOU",[[-1,3602,"atguig"],[1,3608,"gjxaio"]],[3602,3609],[3602,3609]]],[1573826224181,["GJX@GJXAIOU",[[-1,3783,"atguig"],[1,3789,"gjxaio"]],[3783,3790],[3783,3790]]],[1573826224321,["GJX@GJXAIOU",[[-1,4504,"atguig"],[1,4510,"gjxaio"]],[4504,4511],[4504,4511]]],[1573826224567,["GJX@GJXAIOU",[[-1,5192,"atguig"],[1,5198,"gjxaio"]],[5192,5199],[5192,5199]]],[1573826224868,["GJX@GJXAIOU",[[-1,5452,"atguig"],[1,5458,"gjxaio"]],[5452,5459],[5452,5459]]],[1573826225072,["GJX@GJXAIOU",[[-1,6847,"atguig"],[1,6853,"gjxaio"]],[6847,6854],[6847,6854]]]],null,"GJX@GJXAIOU"]]}