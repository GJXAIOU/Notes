{"compress":true,"commitItems":[["108926e8-df7d-4ea7-aae4-b3b390566037",1573826355720,"# 第七章：原型模式\n\n## 克隆羊问题\n\n现在有一只羊 tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和 tom 羊 属性完全相同的 10\n\n只羊。\n\n## 二、传统方式解决克隆羊问题\n\n- 思路分析(图解)\n\n ![传统方式](%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.resource/%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F.png)\n\n \n\n- 看老师代码的演示\n\n  首先是 Sheep 实体类\n\n  ```java\n  package com.atguigu.prototype;\n  \n  public class Sheep {\n  \tprivate String name;\n  \tprivate int age;\n  \tprivate String color;\n  \tpublic Sheep(String name, int age, String color) {\n  \t\tsuper();\n  \t\tthis.name = name;\n  \t\tthis.age = age;\n  \t\tthis.color = color;\n  \t}\n  \tpublic String getName() {\n  \t\treturn name;\n  \t}\n  \tpublic void setName(String name) {\n  \t\tthis.name = name;\n  \t}\n  \tpublic int getAge() {\n  \t\treturn age;\n  \t}\n  \tpublic void setAge(int age) {\n  \t\tthis.age = age;\n  \t}\n  \tpublic String getColor() {\n  \t\treturn color;\n  \t}\n  \tpublic void setColor(String color) {\n  \t\tthis.color = color;\n  \t}\n  \t@Override\n  \tpublic String toString() {\n  \t\treturn \"Sheep [name=\" + name + \", age=\" + age + \", color=\" + color + \"]\";\n  \t}\n  }\n  \n  ```\n\n  然后创建同属性的 Sheep：\n\n ```java\npackage com.atguigu.prototype;\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\n\t\t//传统的方法\n\t\tSheep sheep = new Sheep(\"tom\", 1, \"白色\");\n\t\tSheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); \n    \tSheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); \n    \tSheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());\n\t\tSheep sheep5 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());\n\t\t//....\n\n\t\tSystem.out.println(sheep); \n    \tSystem.out.println(sheep2); \n    \tSystem.out.println(sheep3); \n    \tSystem.out.println(sheep4); \n    \tSystem.out.println(sheep5);\n\t\t//...\n\t}\n}\n\n ```\n\n\n\n## 三、传统的方式的优缺点\n\n-  优点是比较好理解，简单易操作。\n- 在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低\n- 总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活\n- 改进的思路分析\n\n\n\n**思路**：Java 中 Object 类是所有类的根类，Object 类提供了一个 clone()方法，该方法可以将一个 Java 对象复制一份，但是需要实现 clone 的Java 类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力 =>**原型模式**\n\n## 四、原型模式-基本介绍\n\n\n\n- 原型模式(Prototype 模式)是指：用**原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的**对象；\n\n- 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节；\n\n- 工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝；它们自己来实施创建，即 **对象.clone**()\n\n- 形象的理解：孙大圣拔出猴毛， 变出其它孙大圣；\n\n## 五、原型模式原理结构图-uml 类图\n\n​        ![原型模式](%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.resource/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.jpg)\n\n \n\n- 原理结构图说明\n  - Prototype : 原型类，声明一个克隆自己的接口\n  - ConcretePrototype: 具体的原型类,  实现一个克隆自己的操作\n  - Client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样）\n\n \n\n \n\n## 六、原型模式解决克隆羊问题的应用实例\n\n \n\n使用原型模式改进传统方式，让程序具有更高的效率和扩展性。\n\n代码实现\n\n 首先是 Sheep 实体类：\n\n```java\npackage com.atguigu.prototype.improve;\n\npublic class Sheep implements Cloneable {\n    private String name;\n    private int age;\n    private String color;\n    private String address = \"蒙古羊\";\n    public Sheep friend; //是对象, 克隆是会如何处理\n\n    public Sheep(String name, int age, String color) {\n        super();\n        this.name = name;\n        this.age = age;\n        this.color = color;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n\n    @Override\n    public String toString() {\n        return \"Sheep [name=\" + name + \", age=\" + age + \", color=\" + color + \", address=\" + address + \"]\";\n    }\n\n    //克隆该实例，使用默认的clone方法来完成，此处为浅复制\n    @Override\n    protected Object clone() {\n\n        Sheep sheep = null;\n        try {\n            sheep = (Sheep) super.clone();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n        return sheep;\n    }\n\n\n}\n\n```\n\n克隆方法与验证：\n\n```java\npackage com.atguigu.prototype.improve;\n\npublic class Client {\n\n    public static void main(String[] args) {\n        System.out.println(\"原型模式完成对象的创建\");\n        Sheep sheep = new Sheep(\"tom\", 1, \"白色\");\n        sheep.friend = new Sheep(\"jack\", 2, \"黑色\");\n\n        Sheep sheep2 = (Sheep) sheep.clone(); //克隆\n        Sheep sheep3 = (Sheep) sheep.clone(); //克隆\n        Sheep sheep4 = (Sheep) sheep.clone(); //克隆\n        Sheep sheep5 = (Sheep) sheep.clone(); //克隆\n\n        System.out.println(\"sheep2 =\" + sheep2 + \"sheep2.friend=\" + sheep2.friend.hashCode());\n        System.out.println(\"sheep3 =\" + sheep3 + \"sheep3.friend=\" + sheep3.friend.hashCode());\n        System.out.println(\"sheep4 =\" + sheep4 + \"sheep4.friend=\" + sheep4.friend.hashCode());\n        System.out.println(\"sheep5 =\" + sheep5 + \"sheep5.friend=\" + sheep5.friend.hashCode());\n    }\n}\n\n```\n\n\n\n\n\n## 七、原型模式在 Spring 框架中源码分析\n\n1)   Spring 中原型 bean 的创建，就是原型模式的应用\n\n P119\n\n## 八、深入讨论-浅拷贝和深拷贝\n\n### （一）浅拷贝的介绍\n\n1)   对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。\n\n2)   对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值\n\n3)   前面我们克隆羊就是浅拷贝\n\n4)   浅拷贝是使用默认的 clone()方法来实现sheep = (Sheep) super.clone();\n\n\n\n### （二）深拷贝基本介绍\n\n1)        复制对象的所有基本数据类型的成员变量值\n\n2)        为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，**对象进行深拷贝要对整个对象****(****包括对象的引用类型****)****进行拷**贝\n\n 3)        深拷贝实现方式 1：重写 **clone** 方法来实现深拷贝\n\n4)        深拷贝实现方式 2：通过**对象序列化**实现深拷贝(推荐)\n\n \n\n \n\n## 九、深拷贝应用实例\n\n 1)   使用 重写 clone 方法实现深拷贝\n\n2)   使用序列化来实现深拷贝\n\n3)   代码演示\n\n \n\n该类中仅仅有 String 类型的成员变量，因此直接使用 Clone 方法即可；\n\n```java\npackage com.atguigu.prototype.deepclone;\n\nimport java.io.Serializable;\n\npublic class DeepCloneableTarget implements Serializable, Cloneable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String cloneName;\n\n\tprivate String cloneClass;\n\n\t//构造器\n\tpublic DeepCloneableTarget(String cloneName, String cloneClass) {\n\t\tthis.cloneName = cloneName;\n\t\tthis.cloneClass = cloneClass;\n\t}\n\n\t//因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可\n\t@Override\n\tprotected Object clone() throws CloneNotSupportedException {\n\t\treturn super.clone();\n\t}\n}\n\n```\n\n\n\n该类中除了基本数据类型 和 String 之外，还包含对象，使用两种方式实现深克隆：\n\n```java\npackage com.atguigu.prototype.deepclone;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class DeepProtoType implements Serializable, Cloneable{\n\tpublic String name;\n\tpublic DeepCloneableTarget deepCloneableTarget;\n\tpublic DeepProtoType() {\n\t\tsuper();\n\t}\n\t\n\t\n\t//深拷贝 - 方式 1 使用clone 方法\n\t@Override\n\tprotected Object clone() throws CloneNotSupportedException {\n\t\tObject deep = null;\n\t\t//这里完成对基本数据类型(属性)和String的克隆\n\t\tdeep = super.clone(); \n\t\t//对引用类型的属性，进行单独处理\n\t\tDeepProtoType deepProtoType = (DeepProtoType)deep;\n\t\tdeepProtoType.deepCloneableTarget  = (DeepCloneableTarget)deepCloneableTarget.clone();\n\t\treturn deepProtoType;\n\t}\n\t\n\t//深拷贝 - 方式2 通过对象的序列化实现 (推荐)\n\tpublic Object deepClone() {\n\t\t//创建流对象\n\t\tByteArrayOutputStream bos = null;\n\t\tObjectOutputStream oos = null;\n\t\t// 字节输入流\n\t\tByteArrayInputStream bis = null;\n\t\t// 对象输入流\n\t\tObjectInputStream ois = null;\n\t\t\n\t\ttry {\n\t\t\t//序列化\n\t\t\tbos = new ByteArrayOutputStream();\n\t\t\t// 将字节数组输出流转换为对象输出流\n\t\t\toos = new ObjectOutputStream(bos);\n\t\t\t//当前这个对象以对象流的方式输出\n\t\t\toos.writeObject(this);\n\t\t\t\n\t\t\t//反序列化\n\t\t\t\t// 将输出流再反过来读进来，相当于对象的克隆\n\t\t\tbis = new ByteArrayInputStream(bos.toByteArray());\n\t\t\tois = new ObjectInputStream(bis);\n\t\t\tDeepProtoType copyObj = (DeepProtoType)ois.readObject();\n\t\t\treturn copyObj;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t} finally {\n\t\t\t//关闭流\n\t\t\ttry {\n\t\t\t\tbos.close();\n\t\t\t\toos.close();\n\t\t\t\tbis.close();\n\t\t\t\tois.close();\n\t\t\t} catch (Exception e2) {\n\t\t\t\tSystem.out.println(e2.getMessage());\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n分别对两种方式进行测试：\n\n```java\npackage com.atguigu.prototype.deepclone;\n\npublic class Client {\n\tpublic static void main(String[] args) throws Exception {\n\t\tDeepProtoType p = new DeepProtoType();\n\t\tp.name = \"宋江\";\n\t\tp.deepCloneableTarget = new DeepCloneableTarget(\"大牛\", \"小牛\");\n\t\t\n\t\t//方式1 完成深拷贝\n\t\t\n//\t\tDeepProtoType p2 = (DeepProtoType) p.clone();\n//\t\tSystem.out.println(\"p.name=\" + p.name + \"p.deepCloneableTarget=\" + p.deepCloneableTarget.hashCode());\n//\t\tSystem.out.println(\"p2.name=\" + p.name + \"p2.deepCloneableTarget=\" + p2.deepCloneableTarget.hashCode());\n\t\n\t\t//方式2 完成深拷贝\n\t\tDeepProtoType p2 = (DeepProtoType) p.deepClone();\n\t\tSystem.out.println(\"p.name=\" + p.name + \"p.deepCloneableTarget=\" + p.deepCloneableTarget.hashCode());\n\t\tSystem.out.println(\"p2.name=\" + p.name + \"p2.deepCloneableTarget=\" + p2.deepCloneableTarget.hashCode());\n\t}\n}\n\n```\n\n\n\n## 十、原型模式的注意事项和细节\n\n- 创建新的对象比较复杂时，可以利用原型模式简化**对象的创建过程，同时也能够提高**效率\n\n- 不用重新初始化对象，而是**动态地获得对象运行时**的状态\n\n- 如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码\n- 在实现深克隆的时候可能需要比较复杂的代码\n- **缺点**：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了 ocp 原则，这点请同学们注意.",[[1573826297524,["GJX@GJXAIOU",[[-1,308,"atguig"],[1,314,"gjxaio"]],[308,315],[308,315]]],[1573826297784,["GJX@GJXAIOU",[[-1,1082,"atguig"],[1,1088,"gjxaio"]],[1082,1089],[1082,1089]]],[1573826297985,["GJX@GJXAIOU",[[-1,2655,"atguig"],[1,2661,"gjxaio"]],[2655,2662],[2655,2662]]],[1573826298259,["GJX@GJXAIOU",[[-1,3900,"atguig"],[1,3906,"gjxaio"]],[3900,3907],[3900,3907]]],[1573826298465,["GJX@GJXAIOU",[[-1,5529,"atguig"],[1,5535,"gjxaio"]],[5529,5536],[5529,5536]]],[1573826298642,["GJX@GJXAIOU",[[-1,6125,"atguig"],[1,6131,"gjxaio"]],[6125,6132],[6125,6132]]],[1573826298875,["GJX@GJXAIOU",[[-1,7765,"atguig"],[1,7771,"gjxaio"]],[7765,7772],[7765,7772]]]],null,"GJX@GJXAIOU"],["44429623-485f-4cd0-9b66-f601e3283eed",1573827285601,"# 第七章：原型模式\n\n## 克隆羊问题\n\n现在有一只羊 tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和 tom 羊 属性完全相同的 10\n\n只羊。\n\n## 二、传统方式解决克隆羊问题\n\n- 思路分析(图解)\n\n ![传统方式](%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.resource/%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F.png)\n\n \n\n- 看老师代码的演示\n\n  首先是 Sheep 实体类\n\n  ```java\n  package com.gjxaiou.prototype;\n  \n  public class Sheep {\n  \tprivate String name;\n  \tprivate int age;\n  \tprivate String color;\n  \tpublic Sheep(String name, int age, String color) {\n  \t\tsuper();\n  \t\tthis.name = name;\n  \t\tthis.age = age;\n  \t\tthis.color = color;\n  \t}\n  \tpublic String getName() {\n  \t\treturn name;\n  \t}\n  \tpublic void setName(String name) {\n  \t\tthis.name = name;\n  \t}\n  \tpublic int getAge() {\n  \t\treturn age;\n  \t}\n  \tpublic void setAge(int age) {\n  \t\tthis.age = age;\n  \t}\n  \tpublic String getColor() {\n  \t\treturn color;\n  \t}\n  \tpublic void setColor(String color) {\n  \t\tthis.color = color;\n  \t}\n  \t@Override\n  \tpublic String toString() {\n  \t\treturn \"Sheep [name=\" + name + \", age=\" + age + \", color=\" + color + \"]\";\n  \t}\n  }\n  \n  ```\n\n  然后创建同属性的 Sheep：\n\n ```java\npackage com.gjxaiou.prototype;\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\n\t\t//传统的方法\n\t\tSheep sheep = new Sheep(\"tom\", 1, \"白色\");\n\t\tSheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); \n    \tSheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); \n    \tSheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());\n\t\tSheep sheep5 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());\n\t\t//....\n\n\t\tSystem.out.println(sheep); \n    \tSystem.out.println(sheep2); \n    \tSystem.out.println(sheep3); \n    \tSystem.out.println(sheep4); \n    \tSystem.out.println(sheep5);\n\t\t//...\n\t}\n}\n\n ```\n\n\n\n## 三、传统的方式的优缺点\n\n-  优点是比较好理解，简单易操作。\n- 在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低\n- 总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活\n- 改进的思路分析\n\n\n\n**思路**：Java 中 Object 类是所有类的根类，Object 类提供了一个 clone()方法，该方法可以将一个 Java 对象复制一份，但是需要实现 clone 的Java 类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力 =>**原型模式**\n\n## 四、原型模式-基本介绍\n\n\n\n- 原型模式(Prototype 模式)是指：用**原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的**对象；\n\n- 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节；\n\n- 工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝；它们自己来实施创建，即 **对象.clone**()\n\n- 形象的理解：孙大圣拔出猴毛， 变出其它孙大圣；\n\n## 五、原型模式原理结构图-uml 类图\n\n​        ![原型模式](%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.resource/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.jpg)\n\n \n\n- 原理结构图说明\n  - Prototype : 原型类，声明一个克隆自己的接口\n  - ConcretePrototype: 具体的原型类,  实现一个克隆自己的操作\n  - Client: 让一个原型对象克隆自己，从而创建一个新的对象(属性一样）\n\n \n\n \n\n## 六、原型模式解决克隆羊问题的应用实例\n\n \n\n使用原型模式改进传统方式，让程序具有更高的效率和扩展性。\n\n代码实现\n\n 首先是 Sheep 实体类：\n\n```java\npackage com.gjxaiou.prototype.improve;\n\npublic class Sheep implements Cloneable {\n    private String name;\n    private int age;\n    private String color;\n    private String address = \"蒙古羊\";\n    public Sheep friend; //是对象, 克隆是会如何处理\n\n    public Sheep(String name, int age, String color) {\n        super();\n        this.name = name;\n        this.age = age;\n        this.color = color;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n\n    @Override\n    public String toString() {\n        return \"Sheep [name=\" + name + \", age=\" + age + \", color=\" + color + \", address=\" + address + \"]\";\n    }\n\n    //克隆该实例，使用默认的clone方法来完成，此处为浅复制\n    @Override\n    protected Object clone() {\n\n        Sheep sheep = null;\n        try {\n            sheep = (Sheep) super.clone();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n        return sheep;\n    }\n\n\n}\n\n```\n\n克隆方法与验证：\n\n```java\npackage com.gjxaiou.prototype.improve;\n\npublic class Client {\n\n    public static void main(String[] args) {\n        System.out.println(\"原型模式完成对象的创建\");\n        Sheep sheep = new Sheep(\"tom\", 1, \"白色\");\n        sheep.friend = new Sheep(\"jack\", 2, \"黑色\");\n\n        Sheep sheep2 = (Sheep) sheep.clone(); //克隆\n        Sheep sheep3 = (Sheep) sheep.clone(); //克隆\n        Sheep sheep4 = (Sheep) sheep.clone(); //克隆\n        Sheep sheep5 = (Sheep) sheep.clone(); //克隆\n\n        System.out.println(\"sheep2 =\" + sheep2 + \"sheep2.friend=\" + sheep2.friend.hashCode());\n        System.out.println(\"sheep3 =\" + sheep3 + \"sheep3.friend=\" + sheep3.friend.hashCode());\n        System.out.println(\"sheep4 =\" + sheep4 + \"sheep4.friend=\" + sheep4.friend.hashCode());\n        System.out.println(\"sheep5 =\" + sheep5 + \"sheep5.friend=\" + sheep5.friend.hashCode());\n    }\n}\n\n```\n\n\n\n\n\n## 七、原型模式在 Spring 框架中源码分析\n\n1)   Spring 中原型 bean 的创建，就是原型模式的应用\n\n P119\n\n## 八、深入讨论-浅拷贝和深拷贝\n\n### （一）浅拷贝的介绍\n\n1)   对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。\n\n2)   对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值\n\n3)   前面我们克隆羊就是浅拷贝\n\n4)   浅拷贝是使用默认的 clone()方法来实现sheep = (Sheep) super.clone();\n\n\n\n### （二）深拷贝基本介绍\n\n1)        复制对象的所有基本数据类型的成员变量值\n\n2)        为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，**对象进行深拷贝要对整个对象****(****包括对象的引用类型****)****进行拷**贝\n\n 3)        深拷贝实现方式 1：重写 **clone** 方法来实现深拷贝\n\n4)        深拷贝实现方式 2：通过**对象序列化**实现深拷贝(推荐)\n\n \n\n \n\n## 九、深拷贝应用实例\n\n 1)   使用 重写 clone 方法实现深拷贝\n\n2)   使用序列化来实现深拷贝\n\n3)   代码演示\n\n \n\n该类中仅仅有 String 类型的成员变量，因此直接使用 Clone 方法即可；\n\n```java\npackage com.gjxaiou.prototype.deepclone;\n\nimport java.io.Serializable;\n\npublic class DeepCloneableTarget implements Serializable, Cloneable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String cloneName;\n\n\tprivate String cloneClass;\n\n\t//构造器\n\tpublic DeepCloneableTarget(String cloneName, String cloneClass) {\n\t\tthis.cloneName = cloneName;\n\t\tthis.cloneClass = cloneClass;\n\t}\n\n\t//因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可\n\t@Override\n\tprotected Object clone() throws CloneNotSupportedException {\n\t\treturn super.clone();\n\t}\n}\n\n```\n\n\n\n该类中除了基本数据类型 和 String 之外，还包含对象，使用两种方式实现深克隆：\n\n```java\npackage com.gjxaiou.prototype.deepclone;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class DeepProtoType implements Serializable, Cloneable{\n\tpublic String name;\n\tpublic DeepCloneableTarget deepCloneableTarget;\n\tpublic DeepProtoType() {\n\t\tsuper();\n\t}\n\t\n\t\n\t//深拷贝 - 方式 1 使用clone 方法\n\t@Override\n\tprotected Object clone() throws CloneNotSupportedException {\n\t\tObject deep = null;\n\t\t//这里完成对基本数据类型(属性)和String的克隆\n\t\tdeep = super.clone(); \n\t\t//对引用类型的属性，进行单独处理\n\t\tDeepProtoType deepProtoType = (DeepProtoType)deep;\n\t\tdeepProtoType.deepCloneableTarget  = (DeepCloneableTarget)deepCloneableTarget.clone();\n\t\treturn deepProtoType;\n\t}\n\t\n\t//深拷贝 - 方式2 通过对象的序列化实现 (推荐)\n\tpublic Object deepClone() {\n\t\t//创建流对象\n\t\tByteArrayOutputStream bos = null;\n\t\tObjectOutputStream oos = null;\n\t\t// 字节输入流\n\t\tByteArrayInputStream bis = null;\n\t\t// 对象输入流\n\t\tObjectInputStream ois = null;\n\t\t\n\t\ttry {\n\t\t\t//序列化\n\t\t\tbos = new ByteArrayOutputStream();\n\t\t\t// 将字节数组输出流转换为对象输出流\n\t\t\toos = new ObjectOutputStream(bos);\n\t\t\t//当前这个对象以对象流的方式输出\n\t\t\toos.writeObject(this);\n\t\t\t\n\t\t\t//反序列化\n\t\t\t\t// 将输出流再反过来读进来，相当于对象的克隆\n\t\t\tbis = new ByteArrayInputStream(bos.toByteArray());\n\t\t\tois = new ObjectInputStream(bis);\n\t\t\tDeepProtoType copyObj = (DeepProtoType)ois.readObject();\n\t\t\treturn copyObj;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t} finally {\n\t\t\t//关闭流\n\t\t\ttry {\n\t\t\t\tbos.close();\n\t\t\t\toos.close();\n\t\t\t\tbis.close();\n\t\t\t\tois.close();\n\t\t\t} catch (Exception e2) {\n\t\t\t\tSystem.out.println(e2.getMessage());\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n分别对两种方式进行测试：\n\n```java\npackage com.gjxaiou.prototype.deepclone;\n\npublic class Client {\n\tpublic static void main(String[] args) throws Exception {\n\t\tDeepProtoType p = new DeepProtoType();\n\t\tp.name = \"宋江\";\n\t\tp.deepCloneableTarget = new DeepCloneableTarget(\"大牛\", \"小牛\");\n\t\t\n\t\t//方式1 完成深拷贝\n\t\t\n//\t\tDeepProtoType p2 = (DeepProtoType) p.clone();\n//\t\tSystem.out.println(\"p.name=\" + p.name + \"p.deepCloneableTarget=\" + p.deepCloneableTarget.hashCode());\n//\t\tSystem.out.println(\"p2.name=\" + p.name + \"p2.deepCloneableTarget=\" + p2.deepCloneableTarget.hashCode());\n\t\n\t\t//方式2 完成深拷贝\n\t\tDeepProtoType p2 = (DeepProtoType) p.deepClone();\n\t\tSystem.out.println(\"p.name=\" + p.name + \"p.deepCloneableTarget=\" + p.deepCloneableTarget.hashCode());\n\t\tSystem.out.println(\"p2.name=\" + p.name + \"p2.deepCloneableTarget=\" + p2.deepCloneableTarget.hashCode());\n\t}\n}\n\n```\n\n\n\n## 十、原型模式的注意事项和细节\n\n- 创建新的对象比较复杂时，可以利用原型模式简化**对象的创建过程，同时也能够提高**效率\n\n- 不用重新初始化对象，而是**动态地获得对象运行时**的状态\n\n- 如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码\n- 在实现深克隆的时候可能需要比较复杂的代码\n- **缺点**：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了 ocp 原则，这点请同学们注意.",[[1573827248973,["GJX@GJXAIOU",[[-1,254,"\n"]],[254,254],[253,253]]],[1573827249364,["GJX@GJXAIOU",[[-1,252," "]],[253,253],[252,252]]],[1573827252524,["GJX@GJXAIOU",[[-1,282,"  "]],[282,284],[282,282]]],[1573827256364,["GJX@GJXAIOU",[[-1,1031,"  "]],[1031,1033],[1031,1031]]],[1573827259589,["GJX@GJXAIOU",[[-1,1055," "]],[1055,1056],[1055,1055]]],[1573827263295,["GJX@GJXAIOU",[[-1,1726," "]],[1726,1727],[1726,1726]]],[1573827265412,["GJX@GJXAIOU",[[-1,1862,"\n"]],[1862,1862],[1861,1861]]],[1573827265837,["GJX@GJXAIOU",[[-1,1861,"\n"]],[1861,1861],[1860,1860]]],[1573827267390,["GJX@GJXAIOU",[[-1,2024,"\n"]],[2024,2024],[2023,2023]]],[1573827267805,["GJX@GJXAIOU",[[-1,2023,"\n"]],[2023,2023],[2022,2022]]],[1573827268660,["GJX@GJXAIOU",[[-1,2084,"\n"]],[2084,2084],[2083,2083]]],[1573827269557,["GJX@GJXAIOU",[[-1,2134,"\n"]],[2134,2134],[2133,2133]]],[1573827270508,["GJX@GJXAIOU",[[-1,2212,"\n"]],[2212,2212],[2211,2211]]],[1573827282285,["GJX@GJXAIOU",[[-1,2406,"\n"]],[2406,2406],[2405,2405]]],[1573827282676,["GJX@GJXAIOU",[[-1,2404," "]],[2405,2405],[2404,2404]]],[1573827283171,["GJX@GJXAIOU",[[-1,2404,"\n"]],[2404,2404],[2403,2403]]],[1573827285492,["GJX@GJXAIOU",[[-1,2537,"\n"]],[2537,2537],[2536,2536]]],[1573827285793,["GJX@GJXAIOU",[[-1,2535," "]],[2536,2536],[2535,2535]]],[1573827286103,["GJX@GJXAIOU",[[-1,2535,"\n"]],[2535,2535],[2534,2534]]],[1573827286363,["GJX@GJXAIOU",[[-1,2534,"\n"]],[2534,2534],[2533,2533]]],[1573827288110,["GJX@GJXAIOU",[[-1,2559,"\n"]],[2559,2559],[2558,2558]]],[1573827288396,["GJX@GJXAIOU",[[-1,2557," "]],[2558,2558],[2557,2557]]],[1573827288859,["GJX@GJXAIOU",[[-1,2557,"\n"]],[2557,2557],[2556,2556]]],[1573827290516,["GJX@GJXAIOU",[[-1,2592,"\n"]],[2592,2592],[2591,2591]]],[1573827291343,["GJX@GJXAIOU",[[-1,2608,"\n"]],[2608,2608],[2607,2607]]],[1573827295310,["GJX@GJXAIOU",[[-1,3834,"\n"]],[3834,3834],[3833,3833]]],[1573827295686,["GJX@GJXAIOU",[[-1,3833,"\n"]],[3833,3833],[3832,3832]]],[1573827298068,["GJX@GJXAIOU",[[-1,3850,"\n"]],[3850,3850],[3849,3849]]],[1573827300702,["GJX@GJXAIOU",[[-1,4712,"\n"]],[4712,4712],[4711,4711]]],[1573827301035,["GJX@GJXAIOU",[[-1,4711,"\n"]],[4711,4711],[4710,4710]]],[1573827301405,["GJX@GJXAIOU",[[-1,4710,"\n"]],[4710,4710],[4709,4709]]],[1573827302421,["GJX@GJXAIOU",[[-1,4703,"\n"]],[4703,4703],[4702,4702]]],[1573827307212,["GJX@GJXAIOU",[[-1,4813,"1)   "]],[4813,4818],[4813,4813]]],[1573827309879,["GJX@GJXAIOU",[[1,4813,"- "]],[4813,4813],[4815,4815]]],[1573827312390,["GJX@GJXAIOU",[[-1,4866,"2)  "]],[4866,4870],[4866,4866]]],[1573827312814,["GJX@GJXAIOU",[[1,4866,"-"]],[4866,4866],[4867,4867]]],[1573827313233,["GJX@GJXAIOU",[[1,4868," "]],[4867,4867],[4868,4868]]],[1573827316164,["GJX@GJXAIOU",[[-1,5015,"3)   "]],[5015,5020],[5015,5015]]],[1573827317135,["GJX@GJXAIOU",[[1,5015,"- "]],[5015,5015],[5017,5017]]],[1573827318756,["GJX@GJXAIOU",[[-1,5030,"\n4)   "]],[5030,5036],[5030,5030]]],[1573827319489,["GJX@GJXAIOU",[[1,5030,"- "]],[5030,5030],[5032,5032]]],[1573827321671,["GJX@GJXAIOU",[[-1,5087,"\n"]],[5086,5086],[5085,5085]]],[1573827322273,["GJX@GJXAIOU",[[-1,5086,"\n"]],[5085,5085],[5084,5084]]],[1573827324859,["GJX@GJXAIOU",[[-1,5102,"1)        "]],[5102,5112],[5102,5102]]],[1573827326471,["GJX@GJXAIOU",[[1,5102,"- "]],[5102,5102],[5104,5104]]],[1573827329836,["GJX@GJXAIOU",[[-1,5125,"2)        "]],[5125,5135],[5125,5125]]],[1573827330910,["GJX@GJXAIOU",[[1,5125,"- "]],[5125,5125],[5127,5127]]],[1573827332860,["GJX@GJXAIOU",[[-1,5238," 3)        "]],[5238,5249],[5238,5238]]],[1573827333647,["GJX@GJXAIOU",[[1,5238,"- "]],[5238,5238],[5240,5240]]],[1573827335531,["GJX@GJXAIOU",[[-1,5273,"4)        "]],[5273,5283],[5273,5273]]],[1573827336663,["GJX@GJXAIOU",[[1,5273,"- "]],[5273,5273],[5275,5275]]],[1573827338820,["GJX@GJXAIOU",[[-1,5310," "]],[5311,5311],[5310,5310]]],[1573827339228,["GJX@GJXAIOU",[[-1,5311,"\n"]],[5310,5310],[5309,5309]]],[1573827339556,["GJX@GJXAIOU",[[-1,5310,"\n"]],[5309,5309],[5308,5308]]],[1573827339956,["GJX@GJXAIOU",[[-1,5307," "]],[5308,5308],[5307,5307]]],[1573827340412,["GJX@GJXAIOU",[[-1,5308,"\n"]],[5307,5307],[5306,5306]]],[1573827342036,["GJX@GJXAIOU",[[-1,5322," 1)   "]],[5322,5328],[5322,5322]]],[1573827343217,["GJX@GJXAIOU",[[1,5322,"- "]],[5322,5322],[5324,5324]]],[1573827345036,["GJX@GJXAIOU",[[-1,5344,"\n2)   "]],[5344,5350],[5344,5344]]],[1573827345527,["GJX@GJXAIOU",[[1,5344,"- "]],[5344,5344],[5346,5346]]],[1573827347606,["GJX@GJXAIOU",[[-1,5358,"\n3)   "]],[5358,5364],[5358,5358]]],[1573827348361,["GJX@GJXAIOU",[[1,5358,"- "]],[5358,5358],[5360,5360]]],[1573827349534,["GJX@GJXAIOU",[[1,5367,"-"]],[5367,5367],[5368,5368]]],[1573827350773,["GJX@GJXAIOU",[[-1,5366," -"]],[5368,5368],[5366,5366]]],[1573827351228,["GJX@GJXAIOU",[[-1,5367,"\n"]],[5366,5366],[5365,5365]]],[1573827352062,["GJX@GJXAIOU",[[-1,5366,"\n"]],[5366,5366],[5365,5365]]],[1573827352923,["GJX@GJXAIOU",[[-1,5407,"\n"]],[5407,5407],[5406,5406]]],[1573827355621,["GJX@GJXAIOU",[[-1,5951,"\n"]],[5951,5951],[5950,5950]]],[1573827356476,["GJX@GJXAIOU",[[-1,5957,"\n"]],[5957,5957],[5956,5956]]],[1573827356827,["GJX@GJXAIOU",[[-1,5959,"中"]],[5960,5960],[5959,5959]]],[1573827358858,["GJX@GJXAIOU",[[1,5959,"中"]],[5959,5959],[5960,5960]]],[1573827359695,["GJX@GJXAIOU",[[1,5957,"\n"]],[5956,5956],[5957,5957]]],[1573827361262,["GJX@GJXAIOU",[[-1,5957,"\n"]],[5957,5957],[5956,5956]]],[1573827361799,["GJX@GJXAIOU",[[-1,5956,"\n"]],[5956,5956],[5955,5955]]],[1573827363092,["GJX@GJXAIOU",[[-1,5999,"\n"]],[5999,5999],[5998,5998]]],[1573827369036,["GJX@GJXAIOU",[[-1,7619,"\n"]],[7619,7619],[7618,7618]]],[1573827371077,["GJX@GJXAIOU",[[-1,7637,"\n"]],[7637,7637],[7636,7636]]],[1573827375988,["GJX@GJXAIOU",[[-1,8458,"\n"]],[8458,8458],[8457,8457]]],[1573827378564,["GJX@GJXAIOU",[[-1,8464,"\n"]],[8463,8463],[8462,8462]]],[1573827380452,["GJX@GJXAIOU",[[-1,8529,"\n"]],[8529,8529],[8528,8528]]],[1573827381333,["GJX@GJXAIOU",[[-1,8561,"\n"]],[8561,8561],[8560,8560]]]],null,"GJX@GJXAIOU"]]}