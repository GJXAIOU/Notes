{"compress":true,"commitItems":[["c39a67e1-eacb-4bc2-ad0a-15ea2b84bb4a",1573826302444,"# 第十七章：命令模式\n\n \n\n## 一、智能生活项目需求\n\n​                                                                         \n 看一个具体的需求\n\n- 我们买了一套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装 app 就可以控制对这些家电工作。\n\n- 这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个 App，分别控制，我们希望只要一个 app\n\n  就可以控制全部智能家电。\n\n- 要实现一个 app 控制所有智能家电的需要，则每个智能家电厂家都要提供一个统一的接口给 app 调用，这时 就可以考虑使用命令模式。\n\n- 命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来.\n\n- 在我们的例子中，**动作的请求者是手机 app，动作的执行者是每个厂商的一个家电产品**\n\n## 17.2      命令模式基本介绍\n\n-  命令模式（Command Pattern）：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计；\n\n- 命名模式使得**请求发送者与请求接收者消除彼此之间的耦**合，让对象之间的调用关系更加灵活，实现解耦。\n\n- 在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时**命令模式也支持可撤销的操作**。\n\n- 通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色：将军（命令发布者）、士兵（命令的具体执行者）、命令(连接将军和士兵)。\n\n  Invoker 是调用者（将军），Receiver 是被调用者（士兵），MyCommand 是命令，实现了 Command 接口，持有接收对象\n\n## 17.3      命令模式的原理类图\n\n​       ![1573720090208](%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.resource/1573720090208.png)\n\n对原理类图的说明-即(命名模式的角色及职责)\n\n- Invoker 是调用者角色\n\n- Command: 是命令角色，需要执行的所有命令都在这里，可以是接口或抽象类\n\n- Receiver: 接受者角色，知道如何实施和执行一个请求相关的操作\n\n- ConcreteCommand: 将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现 execute\n\n## 四、 命令模式解决智能生活项目\n\n应用实例要求\n\n- 编写程序，使用命令模式 完成前面的智能家电项目\n\n- 思路分析和图解\n\n![1573721190827](%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.resource/1573721190827.png)\n \n\n- 代码实现\n\n  首先是命令接口：\n\n  ```java\n  package com.atguigu.command;\n  \n  //创建命令接口\n  public interface Command {\n  \t//执行动作(操作)\n  \tpublic void execute();\n  \t//撤销动作(操作)\n  \tpublic void undo();\n  }\n  \n  ```\n\n  命令接受者：\n\n  ```java\n  package com.atguigu.command;\n  \n  public class LightReceiver {\n  \n  \tpublic void on() {\n  \t\tSystem.out.println(\" 电灯打开了.. \");\n  \t}\n  \t\n  \tpublic void off() {\n  \t\tSystem.out.println(\" 电灯关闭了.. \");\n  \t}\n  }\n  \n  ```\n\n  开关方法：以及一个空命令\n\n  ```java\n  package com.atguigu.command;\n  \n  public class LightOnCommand implements Command {\n  \n  \t//聚合LightReceiver\n  \tLightReceiver light;\n  \t\n  \t//构造器\n  \tpublic LightOnCommand(LightReceiver light) {\n  \t\tsuper();\n  \t\tthis.light = light;\n  \t}\n  \t\n  \t@Override\n  \tpublic void execute() {\n  \t\t//调用接收者的方法\n  \t\tlight.on();\n  \t}\n  \n  \n  \t@Override\n  \tpublic void undo() {\n  \t\t//调用接收者的方法\n  \t\tlight.off();\n  \t}\n  }\n  \n  //----------------------------------------------\n  package com.atguigu.command;\n  \n  public class LightOffCommand implements Command {\n  \n  \t// 聚合LightReceiver\n  \tLightReceiver light;\n  \n  \t// 构造器\n  \tpublic LightOffCommand(LightReceiver light) {\n  \t\t\tsuper();\n  \t\t\tthis.light = light;\n  \t\t}\n  \n  \t@Override\n  \tpublic void execute() {\n  \t\t// 调用接收者的方法\n  \t\tlight.off();\n  \t}\n  \n  \t@Override\n  \tpublic void undo() {\n  \t\t// 调用接收者的方法\n  \t\tlight.on();\n  \t}\n  }\n  \n  //-----------------------------------------------------\n  package com.atguigu.command;\n  \n  /**\n   * 没有任何命令，即空执行: 用于初始化每个按钮, 当调用空命令时，对象什么都不做\n   * 其实，这样是一种设计模式, 可以省掉对空判断\n   */\n  public class NoCommand implements Command {\n  \n  \t@Override\n  \tpublic void execute() {\n  \t}\n  \n  \t@Override\n  \tpublic void undo() {\n  \t}\n  }\n  \n  ```\n\n  遥控器方法：\n\n  ```java\n  package com.atguigu.command;\n  \n  public class RemoteController {\n  \n  \t// 开、关 按钮的命令数组\n  \tCommand[] onCommands;\n  \tCommand[] offCommands;\n  \n  \t// 执行撤销的命令\n  \tCommand undoCommand;\n  \n  \t// 构造器，完成对按钮初始化\n  \tpublic RemoteController() {\n  \t\tonCommands = new Command[5];\n  \t\toffCommands = new Command[5];\n  \n  \t\tfor (int i = 0; i < 5; i++) {\n  \t\t\tonCommands[i] = new NoCommand();\n  \t\t\toffCommands[i] = new NoCommand();\n  \t\t}\n  \t}\n  \n  \t// 给我们的按钮设置你需要的命令\n  \tpublic void setCommand(int no, Command onCommand, Command offCommand) {\n  \t\tonCommands[no] = onCommand;\n  \t\toffCommands[no] = offCommand;\n  \t}\n  \n  \t// 按下开按钮\n  \tpublic void onButtonWasPushed(int no) {\n  \t\t// 找到你按下的开的按钮， 并调用对应方法\n  \t\tonCommands[no].execute();\n  \t\t// 记录这次的操作，用于撤销\n  \t\tundoCommand = onCommands[no];\n  \t}\n  \n  \t// 按下关按钮\n  \tpublic void offButtonWasPushed(int no) {\n  \t\t// 找到你按下的关的按钮， 并调用对应方法\n  \t\toffCommands[no].execute();\n  \t\t// 记录这次的操作，用于撤销\n  \t\tundoCommand = offCommands[no];\n  \n  \t}\n  \t\n  \t// 按下撤销按钮\n  \tpublic void undoButtonWasPushed() {\n  \t\tundoCommand.undo();\n  \t}\n  }\n  \n  ```\n\n  如果增加 TV 的操作，需要增加 TV 实体方法和 TV 接收\n\n  ```java\n  package com.atguigu.command;\n  \n  public class TVOnCommand implements Command {\n  \n  \t// 聚合TVReceiver\n  \tTVReceiver tv;\n  \n  \t// 构造器\n  \tpublic TVOnCommand(TVReceiver tv) {\n  \t\tsuper();\n  \t\tthis.tv = tv;\n  \t}\n  \n  \t@Override\n  \tpublic void execute() {\n  \t\t// 调用接收者的方法\n  \t\ttv.on();\n  \t}\n  \n  \t@Override\n  \tpublic void undo() {\n  \t\t// 调用接收者的方法\n  \t\ttv.off();\n  \t}\n  }\n  \n  //--------------------------------------------------------\n  package com.atguigu.command;\n  \n  public class TVOffCommand implements Command {\n  \n  \t// 聚合TVReceiver\n  \tTVReceiver tv;\n  \n  \t// 构造器\n  \tpublic TVOffCommand(TVReceiver tv) {\n  \t\tsuper();\n  \t\tthis.tv = tv;\n  \t}\n  \n  \t@Override\n  \tpublic void execute() {\n  \t\t// 调用接收者的方法\n  \t\ttv.off();\n  \t}\n  \n  \t@Override\n  \tpublic void undo() {\n  \t\t// 调用接收者的方法\n  \t\ttv.on();\n  \t}\n  }\n  \n  //---------------------------------------------\n  package com.atguigu.command;\n  \n  public class TVReceiver {\n  \t\n  \tpublic void on() {\n  \t\tSystem.out.println(\" 电视机打开了.. \");\n  \t}\n  \t\n  \tpublic void off() {\n  \t\tSystem.out.println(\" 电视机关闭了.. \");\n  \t}\n  }\n  \n  ```\n\n  \n\n  使用：\n\n  ```java\n  package com.atguigu.command;\n  \n  public class Client {\n  \n  \tpublic static void main(String[] args) {\n  \t\t//使用命令设计模式，完成通过遥控器，对电灯的操作\n  \t\t\n  \t\t//创建电灯的对象(接受者)\n  \t\tLightReceiver lightReceiver = new LightReceiver();\n  \t\t\n  \t\t//创建电灯相关的开关命令\n  \t\tLightOnCommand lightOnCommand = new LightOnCommand(lightReceiver);\n  \t\tLightOffCommand lightOffCommand = new LightOffCommand(lightReceiver);\n  \t\t\n  \t\t//需要一个遥控器\n  \t\tRemoteController remoteController = new RemoteController();\n  \t\t\n  \t\t//给我们的遥控器设置命令, 比如 no = 0 （即第一排）是电灯的开和关的操作\n  \t\tremoteController.setCommand(0, lightOnCommand, lightOffCommand);\n  \t\t\n  \t\tSystem.out.println(\"--------按下灯的开按钮-----------\");\n  \t\tremoteController.onButtonWasPushed(0);\n  \t\tSystem.out.println(\"--------按下灯的关按钮-----------\");\n  \t\tremoteController.offButtonWasPushed(0);\n  \t\tSystem.out.println(\"--------按下撤销按钮-----------\");\n  \t\tremoteController.undoButtonWasPushed();\n  \t\t\n  \t\t\n  \t\tSystem.out.println(\"=========使用遥控器操作电视机==========\");\n  \t\t\n  \t\tTVReceiver tvReceiver = new TVReceiver();\n  \t\t\n  \t\tTVOffCommand tvOffCommand = new TVOffCommand(tvReceiver);\n  \t\tTVOnCommand tvOnCommand = new TVOnCommand(tvReceiver);\n  \t\t\n  \t\t//给我们的遥控器设置命令, 比如 no = 1 （即第二排）是电视机的开和关的操作\n  \t\tremoteController.setCommand(1, tvOnCommand, tvOffCommand);\n  \t\t\n  \t\tSystem.out.println(\"--------按下电视机的开按钮-----------\");\n  \t\tremoteController.onButtonWasPushed(1);\n  \t\tSystem.out.println(\"--------按下电视机的关按钮-----------\");\n  \t\tremoteController.offButtonWasPushed(1);\n  \t\tSystem.out.println(\"--------按下撤销按钮-----------\");\n  \t\tremoteController.undoButtonWasPushed();\n  \n  \t}\n  \n  }\n  \n  ```\n\n  \n\n\n\n## 五、命令模式在 Spring 框架 JdbcTemplate 应用的源码分析\n\n \n\n- Spring 框架的 JdbcTemplate 就使用到了命令模式\n\n- 代码分析\n\n- 模式角色分析说明\n  -  StatementCallback 接口 ,类似命令接口(Command)\n  - class QueryStatementCallback implements StatementCallback<T>, SqlProvider , 匿名内部类， 实现了命令接口， 同时也充当命令接收者\n\n  - 命令调用者 是 JdbcTemplate , 其中 execute(StatementCallback<T> action) 方法中，调用 action.doInStatement 方法.  不同的 实现 StatementCallback 接口的对象，对应不同的 doInStatemnt  实现逻辑\n  - 另外实现 StatementCallback 命令接口的子类还有 QueryStatementCallback、\n\n​         \n\n## 六、命令模式的注意事项和细节\n\n \n\n- 将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的 execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：”请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。\n\n- 容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令\n\n- 容易实现对请求的撤销和重做\n\n- **命令模式不足**：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在在使用的时候要注意\n\n- **空命令也是一种设计模式**，它为我们**省去了判空的操作**。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。\n\n- 命令模式经典的应用场景：界面的一个按钮都是一条命令、模拟 CMD（DOS 命令）订单的撤销/恢复、触发- 反馈机制",[[1573826244160,["GJX@GJXAIOU",[[-1,1387,"atguig"],[1,1393,"gjxaio"]],[1387,1394],[1387,1394]]],[1573826244458,["GJX@GJXAIOU",[[-1,1572,"atguig"],[1,1578,"gjxaio"]],[1572,1579],[1572,1579]]],[1573826244576,["GJX@GJXAIOU",[[-1,1813,"atguig"],[1,1819,"gjxaio"]],[1813,1820],[1813,1820]]],[1573826244797,["GJX@GJXAIOU",[[-1,2267,"atguig"],[1,2273,"gjxaio"]],[2267,2274],[2267,2274]]],[1573826245078,["GJX@GJXAIOU",[[-1,2732,"atguig"],[1,2738,"gjxaio"]],[2732,2739],[2732,2739]]],[1573826245289,["GJX@GJXAIOU",[[-1,3024,"atguig"],[1,3030,"gjxaio"]],[3024,3031],[3024,3031]]],[1573826245505,["GJX@GJXAIOU",[[-1,4118,"atguig"],[1,4124,"gjxaio"]],[4118,4125],[4118,4125]]],[1573826245769,["GJX@GJXAIOU",[[-1,4548,"atguig"],[1,4554,"gjxaio"]],[4548,4555],[4548,4555]]],[1573826245870,["GJX@GJXAIOU",[[-1,4969,"atguig"],[1,4975,"gjxaio"]],[4969,4976],[4969,4976]]],[1573826246095,["GJX@GJXAIOU",[[-1,5205,"atguig"],[1,5211,"gjxaio"]],[5205,5212],[5205,5212]]]],null,"GJX@GJXAIOU"],["d35b3801-07de-4285-b988-b27423e3553c",1573826565488,"# 第十七章：命令模式\n\n \n\n## 一、智能生活项目需求\n\n​                                                                         \n 看一个具体的需求\n\n- 我们买了一套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装 app 就可以控制对这些家电工作。\n\n- 这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个 App，分别控制，我们希望只要一个 app\n\n  就可以控制全部智能家电。\n\n- 要实现一个 app 控制所有智能家电的需要，则每个智能家电厂家都要提供一个统一的接口给 app 调用，这时 就可以考虑使用命令模式。\n\n- 命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来.\n\n- 在我们的例子中，**动作的请求者是手机 app，动作的执行者是每个厂商的一个家电产品**\n\n## 17.2      命令模式基本介绍\n\n-  命令模式（Command Pattern）：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计；\n\n- 命名模式使得**请求发送者与请求接收者消除彼此之间的耦**合，让对象之间的调用关系更加灵活，实现解耦。\n\n- 在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时**命令模式也支持可撤销的操作**。\n\n- 通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色：将军（命令发布者）、士兵（命令的具体执行者）、命令(连接将军和士兵)。\n\n  Invoker 是调用者（将军），Receiver 是被调用者（士兵），MyCommand 是命令，实现了 Command 接口，持有接收对象\n\n## 17.3      命令模式的原理类图\n\n​       ![1573720090208](%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.resource/1573720090208.png)\n\n对原理类图的说明-即(命名模式的角色及职责)\n\n- Invoker 是调用者角色\n\n- Command: 是命令角色，需要执行的所有命令都在这里，可以是接口或抽象类\n\n- Receiver: 接受者角色，知道如何实施和执行一个请求相关的操作\n\n- ConcreteCommand: 将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现 execute\n\n## 四、 命令模式解决智能生活项目\n\n应用实例要求\n\n- 编写程序，使用命令模式 完成前面的智能家电项目\n\n- 思路分析和图解\n\n![1573721190827](%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.resource/1573721190827.png)\n \n\n- 代码实现\n\n  首先是命令接口：\n\n  ```java\n  package com.gjxaiou.command;\n  \n  //创建命令接口\n  public interface Command {\n  \t//执行动作(操作)\n  \tpublic void execute();\n  \t//撤销动作(操作)\n  \tpublic void undo();\n  }\n  \n  ```\n\n  命令接受者：\n\n  ```java\n  package com.gjxaiou.command;\n  \n  public class LightReceiver {\n  \n  \tpublic void on() {\n  \t\tSystem.out.println(\" 电灯打开了.. \");\n  \t}\n  \t\n  \tpublic void off() {\n  \t\tSystem.out.println(\" 电灯关闭了.. \");\n  \t}\n  }\n  \n  ```\n\n  开关方法：以及一个空命令\n\n  ```java\n  package com.gjxaiou.command;\n  \n  public class LightOnCommand implements Command {\n  \n  \t//聚合LightReceiver\n  \tLightReceiver light;\n  \t\n  \t//构造器\n  \tpublic LightOnCommand(LightReceiver light) {\n  \t\tsuper();\n  \t\tthis.light = light;\n  \t}\n  \t\n  \t@Override\n  \tpublic void execute() {\n  \t\t//调用接收者的方法\n  \t\tlight.on();\n  \t}\n  \n  \n  \t@Override\n  \tpublic void undo() {\n  \t\t//调用接收者的方法\n  \t\tlight.off();\n  \t}\n  }\n  \n  //----------------------------------------------\n  package com.gjxaiou.command;\n  \n  public class LightOffCommand implements Command {\n  \n  \t// 聚合LightReceiver\n  \tLightReceiver light;\n  \n  \t// 构造器\n  \tpublic LightOffCommand(LightReceiver light) {\n  \t\t\tsuper();\n  \t\t\tthis.light = light;\n  \t\t}\n  \n  \t@Override\n  \tpublic void execute() {\n  \t\t// 调用接收者的方法\n  \t\tlight.off();\n  \t}\n  \n  \t@Override\n  \tpublic void undo() {\n  \t\t// 调用接收者的方法\n  \t\tlight.on();\n  \t}\n  }\n  \n  //-----------------------------------------------------\n  package com.gjxaiou.command;\n  \n  /**\n   * 没有任何命令，即空执行: 用于初始化每个按钮, 当调用空命令时，对象什么都不做\n   * 其实，这样是一种设计模式, 可以省掉对空判断\n   */\n  public class NoCommand implements Command {\n  \n  \t@Override\n  \tpublic void execute() {\n  \t}\n  \n  \t@Override\n  \tpublic void undo() {\n  \t}\n  }\n  \n  ```\n\n  遥控器方法：\n\n  ```java\n  package com.gjxaiou.command;\n  \n  public class RemoteController {\n  \n  \t// 开、关 按钮的命令数组\n  \tCommand[] onCommands;\n  \tCommand[] offCommands;\n  \n  \t// 执行撤销的命令\n  \tCommand undoCommand;\n  \n  \t// 构造器，完成对按钮初始化\n  \tpublic RemoteController() {\n  \t\tonCommands = new Command[5];\n  \t\toffCommands = new Command[5];\n  \n  \t\tfor (int i = 0; i < 5; i++) {\n  \t\t\tonCommands[i] = new NoCommand();\n  \t\t\toffCommands[i] = new NoCommand();\n  \t\t}\n  \t}\n  \n  \t// 给我们的按钮设置你需要的命令\n  \tpublic void setCommand(int no, Command onCommand, Command offCommand) {\n  \t\tonCommands[no] = onCommand;\n  \t\toffCommands[no] = offCommand;\n  \t}\n  \n  \t// 按下开按钮\n  \tpublic void onButtonWasPushed(int no) {\n  \t\t// 找到你按下的开的按钮， 并调用对应方法\n  \t\tonCommands[no].execute();\n  \t\t// 记录这次的操作，用于撤销\n  \t\tundoCommand = onCommands[no];\n  \t}\n  \n  \t// 按下关按钮\n  \tpublic void offButtonWasPushed(int no) {\n  \t\t// 找到你按下的关的按钮， 并调用对应方法\n  \t\toffCommands[no].execute();\n  \t\t// 记录这次的操作，用于撤销\n  \t\tundoCommand = offCommands[no];\n  \n  \t}\n  \t\n  \t// 按下撤销按钮\n  \tpublic void undoButtonWasPushed() {\n  \t\tundoCommand.undo();\n  \t}\n  }\n  \n  ```\n\n  如果增加 TV 的操作，需要增加 TV 实体方法和 TV 接收\n\n  ```java\n  package com.gjxaiou.command;\n  \n  public class TVOnCommand implements Command {\n  \n  \t// 聚合TVReceiver\n  \tTVReceiver tv;\n  \n  \t// 构造器\n  \tpublic TVOnCommand(TVReceiver tv) {\n  \t\tsuper();\n  \t\tthis.tv = tv;\n  \t}\n  \n  \t@Override\n  \tpublic void execute() {\n  \t\t// 调用接收者的方法\n  \t\ttv.on();\n  \t}\n  \n  \t@Override\n  \tpublic void undo() {\n  \t\t// 调用接收者的方法\n  \t\ttv.off();\n  \t}\n  }\n  \n  //--------------------------------------------------------\n  package com.gjxaiou.command;\n  \n  public class TVOffCommand implements Command {\n  \n  \t// 聚合TVReceiver\n  \tTVReceiver tv;\n  \n  \t// 构造器\n  \tpublic TVOffCommand(TVReceiver tv) {\n  \t\tsuper();\n  \t\tthis.tv = tv;\n  \t}\n  \n  \t@Override\n  \tpublic void execute() {\n  \t\t// 调用接收者的方法\n  \t\ttv.off();\n  \t}\n  \n  \t@Override\n  \tpublic void undo() {\n  \t\t// 调用接收者的方法\n  \t\ttv.on();\n  \t}\n  }\n  \n  //---------------------------------------------\n  package com.gjxaiou.command;\n  \n  public class TVReceiver {\n  \t\n  \tpublic void on() {\n  \t\tSystem.out.println(\" 电视机打开了.. \");\n  \t}\n  \t\n  \tpublic void off() {\n  \t\tSystem.out.println(\" 电视机关闭了.. \");\n  \t}\n  }\n  \n  ```\n\n  \n\n  使用：\n\n  ```java\n  package com.gjxaiou.command;\n  \n  public class Client {\n  \n  \tpublic static void main(String[] args) {\n  \t\t//使用命令设计模式，完成通过遥控器，对电灯的操作\n  \t\t\n  \t\t//创建电灯的对象(接受者)\n  \t\tLightReceiver lightReceiver = new LightReceiver();\n  \t\t\n  \t\t//创建电灯相关的开关命令\n  \t\tLightOnCommand lightOnCommand = new LightOnCommand(lightReceiver);\n  \t\tLightOffCommand lightOffCommand = new LightOffCommand(lightReceiver);\n  \t\t\n  \t\t//需要一个遥控器\n  \t\tRemoteController remoteController = new RemoteController();\n  \t\t\n  \t\t//给我们的遥控器设置命令, 比如 no = 0 （即第一排）是电灯的开和关的操作\n  \t\tremoteController.setCommand(0, lightOnCommand, lightOffCommand);\n  \t\t\n  \t\tSystem.out.println(\"--------按下灯的开按钮-----------\");\n  \t\tremoteController.onButtonWasPushed(0);\n  \t\tSystem.out.println(\"--------按下灯的关按钮-----------\");\n  \t\tremoteController.offButtonWasPushed(0);\n  \t\tSystem.out.println(\"--------按下撤销按钮-----------\");\n  \t\tremoteController.undoButtonWasPushed();\n  \t\t\n  \t\t\n  \t\tSystem.out.println(\"=========使用遥控器操作电视机==========\");\n  \t\t\n  \t\tTVReceiver tvReceiver = new TVReceiver();\n  \t\t\n  \t\tTVOffCommand tvOffCommand = new TVOffCommand(tvReceiver);\n  \t\tTVOnCommand tvOnCommand = new TVOnCommand(tvReceiver);\n  \t\t\n  \t\t//给我们的遥控器设置命令, 比如 no = 1 （即第二排）是电视机的开和关的操作\n  \t\tremoteController.setCommand(1, tvOnCommand, tvOffCommand);\n  \t\t\n  \t\tSystem.out.println(\"--------按下电视机的开按钮-----------\");\n  \t\tremoteController.onButtonWasPushed(1);\n  \t\tSystem.out.println(\"--------按下电视机的关按钮-----------\");\n  \t\tremoteController.offButtonWasPushed(1);\n  \t\tSystem.out.println(\"--------按下撤销按钮-----------\");\n  \t\tremoteController.undoButtonWasPushed();\n  \n  \t}\n  \n  }\n  \n  ```\n\n  \n\n\n\n## 五、命令模式在 Spring 框架 JdbcTemplate 应用的源码分析\n\n \n\n- Spring 框架的 JdbcTemplate 就使用到了命令模式\n\n- 代码分析\n\n- 模式角色分析说明\n  -  StatementCallback 接口 ,类似命令接口(Command)\n  - class QueryStatementCallback implements StatementCallback<T>, SqlProvider , 匿名内部类， 实现了命令接口， 同时也充当命令接收者\n\n  - 命令调用者 是 JdbcTemplate , 其中 execute(StatementCallback<T> action) 方法中，调用 action.doInStatement 方法.  不同的 实现 StatementCallback 接口的对象，对应不同的 doInStatemnt  实现逻辑\n  - 另外实现 StatementCallback 命令接口的子类还有 QueryStatementCallback、\n\n​         \n\n## 六、命令模式的注意事项和细节\n\n \n\n- 将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的 execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：”请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。\n\n- 容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令\n\n- 容易实现对请求的撤销和重做\n\n- **命令模式不足**：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在在使用的时候要注意\n\n- **空命令也是一种设计模式**，它为我们**省去了判空的操作**。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。\n\n- 命令模式经典的应用场景：界面的一个按钮都是一条命令、模拟 CMD（DOS 命令）订单的撤销/恢复、触发- 反馈机制",[[1573826511149,["GJX@GJXAIOU",[[-1,5182," "]],[5183,5183],[5182,5182]]],[1573826515844,["GJX@GJXAIOU",[[-1,6750,"  "]],[6752,6752],[6750,6750]]],[1573826522094,["GJX@GJXAIOU",[[-1,5181," "]],[5182,5182],[5181,5181]]],[1573826527150,["GJX@GJXAIOU",[[-1,5163,"  "]],[5163,5165],[5163,5163]]],[1573826537973,["GJX@GJXAIOU",[[-1,4094,"  "]],[4096,4096],[4094,4094]]],[1573826540461,["GJX@GJXAIOU",[[-1,4053," "]],[4054,4054],[4053,4053]]],[1573826545628,["GJX@GJXAIOU",[[-1,3000,"  "]],[3002,3002],[3000,3000]]],[1573826549828,["GJX@GJXAIOU",[[-1,4050," "]],[4051,4051],[4050,4050]]],[1573826556052,["GJX@GJXAIOU",[[-1,2983,"  "]],[2983,2985],[2983,2983]]],[1573826563079,["GJX@GJXAIOU",[[-1,1789,"  "]],[1789,1791],[1789,1789]]],[1573826574672,["GJX@GJXAIOU",[[-1,1766,"  "]],[1766,1768],[1766,1766]]],[1573826580884,["GJX@GJXAIOU",[[-1,1548,"  "]],[1548,1550],[1548,1548]]],[1573826584588,["GJX@GJXAIOU",[[-1,1531,"  "]],[1531,1533],[1531,1531]]],[1573826590095,["GJX@GJXAIOU",[[-1,1363,"  "]],[1363,1365],[1363,1363]]]],null,"GJX@GJXAIOU"]]}