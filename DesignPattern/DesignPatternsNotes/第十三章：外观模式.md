# 第 13  章外观模式

 

## 13.1      影院管理项目

组建一个家庭影院：

DVD 播放器、投影仪、自动屏幕、环绕立体声、爆米花机,要求完成使用家庭影院的功能，其过程为： 直接用遥控器：统筹各设备开关
开爆米花机
放下屏幕 
开投影仪 
开音响
开 DVD，选 dvd
去拿爆米花
调暗灯光 
播放
观影结束后，关闭各种设备

## 二、传统方式解决影院管理

​      ![传统方式解决影院问题](%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.resource/%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%BD%B1%E9%99%A2%E9%97%AE%E9%A2%98.png)                                            

## 三、传统方式解决影院管理问题分析

- 在 ClientTest 的 main 方法中，创建各个子系统的对象，并直接去调用子系统(对象)相关方法，会造成调用过程混乱，没有清晰的过程；

- 不利于在 ClientTest 中，去维护对子系统的操作；

- 解决思路：**定义一个高层接口**，给**子系统中的一组接口提供一个一致的界面**(比如在高层接口提供四个方法

ready, play, pause, end )，用来访问子系统中的一群接口

**- 也就是说 就是通过定义一个一致的接口(界面类)，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节 => **外观模式**

## 四、外观模式基本介绍

- 外观模式（Facade），也叫“过程模式：外观模式为子系统中的一组接口**提供一个一致的界面**，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用；

- 外观模式通过定义一个一致的接口，用**以==屏蔽内部子系统的细节==**，使得**调用端只需跟这个接口发生调用**，而无需关心这个子系统的内部细节；

 
## 五、外观模式原理类图

​      ![外观模式原理类图](%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.resource/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E7%B1%BB%E5%9B%BE.png) 

对类图说明(分类外观模式的角色)

- 外观类(Facade): 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代理给适当子系统对象
- 调用者(Client): 外观接口的调用者
- 子系统的集合：指模块或者子系统，处理 Facade 对象指派的任务，他是功能的实际提供者

## 六、外观模式解决影院管理

### （一）传统方式解决影院管理说明

- 外观模式可以理解为转换一群接口，客户只要调用一个接口，而不用调用多个接口才能达到目的。比如：在 pc 上安装软件的时候经常有一键安装选项（省去选择安装目录、安装的组件等等），还有就是手机的重启功能（把关机和启动合为一个操作）。

- 外观模式就是解决多个复杂接口带来的使用困难，起到简化用户操作的作用

- 示意图说明

​       ![使用外观模式解决影院问题](%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.resource/%E4%BD%BF%E7%94%A8%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%BD%B1%E9%99%A2%E9%97%AE%E9%A2%98.jpg)

 

### （二） 外观模式应用实例

- 应用实例要求

  使用外观模式来完成家庭影院项目

- 思路分析和图解(类图)

​       ![外观模式解决影院问题的思路和类图](%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.resource/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E5%BD%B1%E9%99%A2%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF%E5%92%8C%E7%B1%BB%E5%9B%BE.jpg)

- 代码实现

   具体的实体类：

```java
package com.gjxaiou.facade;

public class DVDPlayer {
	
	//使用单例模式, 使用饿汉式
	private static DVDPlayer instance = new DVDPlayer();
	
	public static DVDPlayer getInstanc() {
		return instance;
	}
	
	public void on() {
		System.out.println(" dvd on ");
	}
	public void off() {
		System.out.println(" dvd off ");
	}
	
	public void play() {
		System.out.println(" dvd is playing ");
	}
	
	//....
	public void pause() {
		System.out.println(" dvd pause ..");
	}
}

//-------------------------------------------
package com.gjxaiou.facade;

public class Popcorn {
	
	private static Popcorn instance = new Popcorn();
	
	public static Popcorn getInstance() {
		return instance;
	}
	
	public void on() {
		System.out.println(" popcorn on ");
	}
	
	public void off() {
		System.out.println(" popcorn ff ");
	}
	
	public void pop() {
		System.out.println(" popcorn is poping  ");
	}
}

//----------------------------------------------
package com.gjxaiou.facade;

public class Projector {

	private static Projector instance = new Projector();
	
	public static Projector getInstance() {
		return instance;
	}
	
	public void on() {
		System.out.println(" Projector on ");
	}
	
	public void off() {
		System.out.println(" Projector ff ");
	}
	
	public void focus() {
		System.out.println(" Projector is Projector  ");
	}
	
	//...
}

//--------------------------------------------------
 package com.gjxaiou.facade;

public class Screen {

	private static Screen instance = new Screen();
	
	public static Screen getInstance() {
		return instance;
	}
	
	public void up() {
		System.out.println(" Screen up ");
	}
	
	public void down() {
		System.out.println(" Screen down ");
	}
}

//-----------------------------------------------------
package com.gjxaiou.facade;

public class Stereo {

	private static Stereo instance = new Stereo();
	
	public static Stereo getInstance() {
		return instance;
	}
	
	public void on() {
		System.out.println(" Stereo on ");
	}
	
	public void off() {
		System.out.println(" Stereo off ");
	}
	
	public void up() {
		System.out.println(" Stereo up.. ");
	}
	
	//...
}

//---------------------------------------------
package com.gjxaiou.facade;

public class TheaterLight {

	private static TheaterLight instance = new TheaterLight();

	public static TheaterLight getInstance() {
		return instance;
	}

	public void on() {
		System.out.println(" TheaterLight on ");
	}

	public void off() {
		System.out.println(" TheaterLight off ");
	}

	public void dim() {
		System.out.println(" TheaterLight dim.. ");
	}

	public void bright() {
		System.out.println(" TheaterLight bright.. ");
	}
}

```

中间的外观类：

```java
package com.gjxaiou.facade;

public class HomeTheaterFacade {
	
	//定义各个子系统对象
	private TheaterLight theaterLight;
	private Popcorn popcorn;
	private Stereo stereo;
	private Projector projector;
	private Screen screen;
	private DVDPlayer dVDPlayer;
	
	
	//构造器
	public HomeTheaterFacade() {
		super();
		this.theaterLight = TheaterLight.getInstance();
		this.popcorn = Popcorn.getInstance();
		this.stereo = Stereo.getInstance();
		this.projector = Projector.getInstance();
		this.screen = Screen.getInstance();
		this.dVDPlayer = DVDPlayer.getInstanc();
	}

	//操作分成 4 步
	
	public void ready() {
		popcorn.on();
		popcorn.pop();
		screen.down();
		projector.on();
		stereo.on();
		dVDPlayer.on();
		theaterLight.dim();
	}
	
	public void play() {
		dVDPlayer.play();
	}
	
	public void pause() {
		dVDPlayer.pause();
	}
	
	public void end() {
		popcorn.off();
		theaterLight.bright();
		screen.up();
		projector.off();
		stereo.off();
		dVDPlayer.off();
	}	
}

```





## 七、外观模式在 MyBatis 框架应用的源码分析

- MyBatis 中的 Configuration 去创建 MetaObject   对象使用到外观模式

- 代码分析+Debug **源码**+示意图

- 对源码中使用到的外观模式的角色类图


 

## 八、外观模式的注意事项和细节

- 外观模式**对外屏蔽了子系统的细节**，因此外观模式降低了客户端对子系统使用的复杂性

- 外观模式对客户端与子系统的耦合关系 - 解耦，让子系统内部的模块更易维护和扩展

- 通过合理的使用外观模式，可以帮我们更好的**划分访问的层次**

- 当系统需要进行分层设计时，可以考虑使用 Facade 模式

- 在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个

Facade 类，来提供遗留系统的比较清晰简单的接口，让新系统与 Facade 类交互，提高复用性

- 不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。