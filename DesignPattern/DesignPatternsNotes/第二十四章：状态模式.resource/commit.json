{"compress":true,"commitItems":[["2f5ec58f-607d-4651-b0f7-8dd9803df0e7",1573826258697,"# 第二十四章：状态模式\n\n## 一、APP 抽奖活动问题\n\n请编写程序完成 APP 抽奖活动 具体要求如下:\n\n- 假如每参加一次这个活动要扣除用户 50 积分，中奖概率是 10%\n\n- 奖品数量固定，抽完就不能抽奖\n\n- 活动有四个状态: 可以抽奖、不能抽奖、发放奖品和奖品领完\n\n- 活动的四个状态转换关系图(右图)\n\n​      ![1573821472424](%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.resource/1573821472424.png)                                                                   \n\n\n## 二、状态模式基本介绍\n\n基本介绍\n\n- 状态模式（**State Pattern**）：它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换\n\n- 当一个**对象的内在状态改变时，允许改变其行为**，这个对象看起来像是改变了其类\n\n## 三、状态模式的原理类图\n\n![1573822954906](%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.resource/1573822954906.png)\n\n\n对原理类图的说明-即(状态模式的角色及职责)\n\n- Context 类为环境角色,  用于维护 State 实例,这个实例定义当前状态\n\n- State 是抽象状态角色,定义一个接口封装与 Context  的一个特点接口相关行为\n\n- ConcreteState 具体的状态角色，每个子类实现一个与 Context 的一个状态相关行为\n\n## 状态模式解决APP 抽奖问\n\n-  应用实例要求\n\n完成 APP 抽奖活动项目，使用状态模式.\n\n- 思路分析和图解(类图)\n  - 定义出一个接口叫状态接口，每个状态都实现它。\n  - 接口有扣除积分方法、抽奖方法、发放奖品方法\n\n​        ![1573823176968](%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.resource/1573823176968.png)\n\n\n\n \n\n- 代码实现\n\nState 抽象类\n\n```java\npackage com.atguigu.state;\n\n/**\n * 状态抽象类\n */\npublic abstract class State {\n\t\n\t// 扣除积分 - 50\n    public abstract void deductMoney();\n\n    // 是否抽中奖品\n    public abstract boolean raffle();\n\n    // 发放奖品\n    public abstract  void dispensePrize();\n}\n\n```\n\n具体的实现类\n\n```java\npackage com.atguigu.state;\n\nimport java.util.Random;\n\n/**\n * 可以抽奖的状态\n * @author Administrator\n *\n */\npublic class CanRaffleState extends State {\n\n    RaffleActivity activity;\n\n    public CanRaffleState(RaffleActivity activity) {\n        this.activity = activity;\n    }\n\n    //已经扣除了积分，不能再扣\n    @Override\n    public void deductMoney() {\n        System.out.println(\"已经扣取过了积分\");\n    }\n\n    //可以抽奖, 抽完奖后，根据实际情况，改成新的状态\n    @Override\n    public boolean raffle() {\n        System.out.println(\"正在抽奖，请稍等！\");\n        Random r = new Random();\n        int num = r.nextInt(10);\n        // 10%中奖机会\n        if(num == 0){\n            // 改变活动状态为发放奖品 context\n            activity.setState(activity.getDispenseState());\n            return true;\n        }else{\n            System.out.println(\"很遗憾没有抽中奖品！\");\n            // 改变状态为不能抽奖\n            activity.setState(activity.getNoRafflleState());\n            return false;\n        }\n    }\n\n    // 不能发放奖品\n    @Override\n    public void dispensePrize() {\n        System.out.println(\"没中奖，不能发放奖品\");\n    }\n}\n\n//-------------------------------------------------------\npackage com.atguigu.state;\n\n/**\n * 不能抽奖状态\n * @author Administrator\n *\n */\npublic class NoRaffleState extends State {\n\n\t // 初始化时传入活动引用，扣除积分后改变其状态\n    RaffleActivity activity;\n\n    public NoRaffleState(RaffleActivity activity) {\n        this.activity = activity;\n    }\n\n    // 当前状态可以扣积分 , 扣除后，将状态设置成可以抽奖状态\n    @Override\n    public void deductMoney() {\n        System.out.println(\"扣除50积分成功，您可以抽奖了\");\n        activity.setState(activity.getCanRaffleState());\n    }\n\n    // 当前状态不能抽奖\n    @Override\n    public boolean raffle() {\n        System.out.println(\"扣了积分才能抽奖喔！\");\n        return false;\n    }\n\n    // 当前状态不能发奖品\n    @Override\n    public void dispensePrize() {\n        System.out.println(\"不能发放奖品\");\n    }\n}\n\n//-----------------------------------------------------------\npackage com.atguigu.state;\n\n/**\n * 发放奖品的状态\n * @author Administrator\n *\n */\npublic class DispenseState extends State {\n\n\t // 初始化时传入活动引用，发放奖品后改变其状态\n    RaffleActivity activity;\n\n    public DispenseState(RaffleActivity activity) {\n        this.activity = activity;\n    }\n\n    @Override\n    public void deductMoney() {\n        System.out.println(\"不能扣除积分\");\n    }\n\n    @Override\n    public boolean raffle() {\n        System.out.println(\"不能抽奖\");\n        return false;\n    }\n\n    //发放奖品\n    @Override\n    public void dispensePrize() {\n        if(activity.getCount() > 0){\n            System.out.println(\"恭喜中奖了\");\n            // 改变状态为不能抽奖\n            activity.setState(activity.getNoRafflleState());\n        }else{\n            System.out.println(\"很遗憾，奖品发送完了\");\n            // 改变状态为奖品发送完毕, 后面我们就不可以抽奖\n            activity.setState(activity.getDispensOutState());\n            //System.out.println(\"抽奖活动结束\");\n            //System.exit(0);\n        }\n    }\n}\n\n//------------------------------------------------------\npackage com.atguigu.state;\n\n/**\n * 奖品发放完毕状态\n * 说明，当我们activity 改变成 DispenseOutState， 抽奖活动结束\n * @author Administrator\n *\n */\npublic class DispenseOutState extends State {\n\n\t// 初始化时传入活动引用\n    RaffleActivity activity;\n\n    public DispenseOutState(RaffleActivity activity) {\n        this.activity = activity;\n    }\n    @Override\n    public void deductMoney() {\n        System.out.println(\"奖品发送完了，请下次再参加\");\n    }\n\n    @Override\n    public boolean raffle() {\n        System.out.println(\"奖品发送完了，请下次再参加\");\n        return false;\n    }\n\n    @Override\n    public void dispensePrize() {\n        System.out.println(\"奖品发送完了，请下次再参加\");\n    }\n}\n\n```\n\n抽奖活动\n\n```java\npackage com.atguigu.state;\n\n/**\n * 抽奖活动 //\n * \n * @author Administrator\n *\n */\npublic class RaffleActivity {\n\n\t// state 表示活动当前的状态，是变化\n    State state = null;\n    // 奖品数量\n    int count = 0;\n    \n    // 四个属性，表示四种状态\n    State noRafflleState = new NoRaffleState(this);\n    State canRaffleState = new CanRaffleState(this);\n    \n    State dispenseState =   new DispenseState(this);\n    State dispensOutState = new DispenseOutState(this);\n\n    //构造器\n    //1. 初始化当前的状态为 noRafflleState（即不能抽奖的状态）\n    //2. 初始化奖品的数量 \n    public RaffleActivity( int count) {\n        this.state = getNoRafflleState();\n        this.count = count;\n    }\n\n    //扣分, 调用当前状态的 deductMoney\n    public void debuctMoney(){\n        state.deductMoney();\n    }\n\n    //抽奖 \n    public void raffle(){\n    \t// 如果当前的状态是抽奖成功\n        if(state.raffle()){\n        \t//领取奖品\n            state.dispensePrize();\n        }\n\n    }\n\n    public State getState() {\n        return state;\n    }\n\n    public void setState(State state) {\n        this.state = state;\n    }\n\n    //这里请大家注意，每领取一次奖品，count--\n    public int getCount() {\n    \tint curCount = count; \n    \tcount--;\n        return curCount;\n    }\n\n    public void setCount(int count) {\n        this.count = count;\n    }\n\n    public State getNoRafflleState() {\n        return noRafflleState;\n    }\n\n    public void setNoRafflleState(State noRafflleState) {\n        this.noRafflleState = noRafflleState;\n    }\n\n    public State getCanRaffleState() {\n        return canRaffleState;\n    }\n\n    public void setCanRaffleState(State canRaffleState) {\n        this.canRaffleState = canRaffleState;\n    }\n\n    public State getDispenseState() {\n        return dispenseState;\n    }\n\n    public void setDispenseState(State dispenseState) {\n        this.dispenseState = dispenseState;\n    }\n\n    public State getDispensOutState() {\n        return dispensOutState;\n    }\n\n    public void setDispensOutState(State dispensOutState) {\n        this.dispensOutState = dispensOutState;\n    }\n}\n\n```\n\n测试类\n\n```java\npackage com.atguigu.state;\n\n/**\n * 状态模式测试类\n */\npublic class ClientTest {\n\n\tpublic static void main(String[] args) {\n\t\t// 创建活动对象，奖品有1个奖品\n        RaffleActivity activity = new RaffleActivity(1);\n\n        // 我们连续抽300次奖\n        for (int i = 0; i < 30; i++) {\n            System.out.println(\"--------第\" + (i + 1) + \"次抽奖----------\");\n            // 参加抽奖，第一步点击扣除积分\n            activity.debuctMoney();\n\n            // 第二步抽奖\n            activity.raffle();\n        }\n\t}\n}\n\n```\n\n\n\n\n## 五、状态模式在实际项目-借贷平台 源码剖析\n\n \n\n- 借贷平台的订单，有审核-发布-抢单 等等 步骤，随着操作的不同，会改变订单的状态, 项目中的这个模块实现就会使用到状态模式\n\n-  通常通过 if/else 判断订单的状态，从而实现不同的逻辑，伪代码如下\n\n  ![1573823682396](%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.resource/1573823682396.png)\n\n- 使用状态模式完成 借贷平台项目的审核模块  [设计+代码]\n\n   状态接口\n\n```java\npackage com.atguigu.state.money;\n\n/**\n * 状态接口\n * @author Administrator\n *\n */\npublic interface State {\n\n\t/**\n     * 电审\n     */\n    void checkEvent(Context context);\n\n    /**\n     * 电审失败\n     */\n    void checkFailEvent(Context context);\n\n    /**\n     * 定价发布\n     */\n    void makePriceEvent(Context context);\n\n    /**\n     * 接单\n     */\n    void acceptOrderEvent(Context context);\n\n    /**\n     * 无人接单失效\n     */\n    void notPeopleAcceptEvent(Context context);\n\n    /**\n     * 付款\n     */\n    void payOrderEvent(Context context);\n\n    /**\n     * 接单有人支付失效\n     */\n    void orderFailureEvent(Context context);\n\n    /**\n     * 反馈\n     */\n    void feedBackEvent(Context context);\n    \n    String getCurrentState();\n}\n\n```\n\n状态枚举类\n\n```java\npackage com.atguigu.state.money;\n\n/**\n * 状态枚举类\n * @author Administrator\n *\n */\npublic enum StateEnum {\n\n\t //订单生成\n    GENERATE(1, \"GENERATE\"),\n\n    //已审核\n    REVIEWED(2, \"REVIEWED\"),\n\n    //已发布\n    PUBLISHED(3, \"PUBLISHED\"),\n\n    //待付款\n    NOT_PAY(4, \"NOT_PAY\"),\n\n    //已付款\n    PAID(5, \"PAID\"),\n\n    //已完结\n    FEED_BACKED(6, \"FEED_BACKED\");\n\n    private int key;\n    private String value;\n\n    StateEnum(int key, String value) {\n        this.key = key;\n        this.value = value;\n    }\n    public int getKey() {return key;}\n    public String getValue() {return value;}\n}\n\n```\n\n抽象 State 的默认实现类\n\n```java\npackage com.atguigu.state.money;\n\npublic abstract class AbstractState implements State {\n\n\tprotected static final RuntimeException EXCEPTION = new RuntimeException(\"操作流程不允许\");\n\n\t//抽象类，默认实现了 State 接口的所有方法\n\t//该类的所有方法，其子类(具体的状态类)，可以有选择的进行重写\n\t\n    @Override\n    public void checkEvent(Context context) {\n        throw EXCEPTION;\n    }\n\n    @Override\n    public void checkFailEvent(Context context) {\n        throw EXCEPTION;\n    }\n\n    @Override\n    public void makePriceEvent(Context context) {\n        throw EXCEPTION;\n    }\n\n    @Override\n    public void acceptOrderEvent(Context context) {\n        throw EXCEPTION;\n    }\n\n    @Override\n    public void notPeopleAcceptEvent(Context context) {\n        throw EXCEPTION;\n    }\n\n    @Override\n    public void payOrderEvent(Context context) {\n        throw EXCEPTION;\n    }\n\n    @Override\n    public void orderFailureEvent(Context context) {\n        throw EXCEPTION;\n    }\n\n    @Override\n    public void feedBackEvent(Context context) {\n        throw EXCEPTION;\n    }\n}\n\n```\n\n环境上下文\n\n```java\npackage com.atguigu.state.money;\n\n//环境上下文\npublic class Context extends AbstractState{\n\t//当前的状态 state, 根据我们的业务流程处理，不停的变化\n\tprivate State state;\n\n    @Override\n    public void checkEvent(Context context) {\n        state.checkEvent(this);\n        getCurrentState();\n    }\n\n    @Override\n    public void checkFailEvent(Context context) {\n        state.checkFailEvent(this);\n        getCurrentState();\n    }\n\n    @Override\n    public void makePriceEvent(Context context) {\n        state.makePriceEvent(this);\n        getCurrentState();\n    }\n\n    @Override\n    public void acceptOrderEvent(Context context) {\n        state.acceptOrderEvent(this);\n        getCurrentState();\n    }\n\n    @Override\n    public void notPeopleAcceptEvent(Context context) {\n        state.notPeopleAcceptEvent(this);\n        getCurrentState();\n    }\n\n    @Override\n    public void payOrderEvent(Context context) {\n        state.payOrderEvent(this);\n        getCurrentState();\n    }\n\n    @Override\n    public void orderFailureEvent(Context context) {\n        state.orderFailureEvent(this);\n        getCurrentState();\n    }\n\n    @Override\n    public void feedBackEvent(Context context) {\n        state.feedBackEvent(this);\n        getCurrentState();\n    }\n\n    public State getState() {\n        return state;\n    }\n\n    public void setState(State state) {\n        this.state = state;\n    }\n\n    @Override\n    public String getCurrentState() {\n        System.out.println(\"当前状态 : \" + state.getCurrentState());\n        return state.getCurrentState();\n    }\n}\n\n```\n\n具体的环境上下文\n\n```java\npackage com.atguigu.state.money;\n\n//环境上下文\npublic class Context extends AbstractState{\n\t//当前的状态 state, 根据我们的业务流程处理，不停的变化\n\tprivate State state;\n\n    @Override\n    public void checkEvent(Context context) {\n        state.checkEvent(this);\n        getCurrentState();\n    }\n\n    @Override\n    public void checkFailEvent(Context context) {\n        state.checkFailEvent(this);\n        getCurrentState();\n    }\n\n    @Override\n    public void makePriceEvent(Context context) {\n        state.makePriceEvent(this);\n        getCurrentState();\n    }\n\n    @Override\n    public void acceptOrderEvent(Context context) {\n        state.acceptOrderEvent(this);\n        getCurrentState();\n    }\n\n    @Override\n    public void notPeopleAcceptEvent(Context context) {\n        state.notPeopleAcceptEvent(this);\n        getCurrentState();\n    }\n\n    @Override\n    public void payOrderEvent(Context context) {\n        state.payOrderEvent(this);\n        getCurrentState();\n    }\n\n    @Override\n    public void orderFailureEvent(Context context) {\n        state.orderFailureEvent(this);\n        getCurrentState();\n    }\n\n    @Override\n    public void feedBackEvent(Context context) {\n        state.feedBackEvent(this);\n        getCurrentState();\n    }\n\n    public State getState() {\n        return state;\n    }\n\n    public void setState(State state) {\n        this.state = state;\n    }\n\n    @Override\n    public String getCurrentState() {\n        System.out.println(\"当前状态 : \" + state.getCurrentState());\n        return state.getCurrentState();\n    }\n}\n\n```\n\n测试类\n\n```java\npackage com.atguigu.state.money;\n\n/**测试类*/\npublic class ClientTest {\n\n\tpublic static void main(String[] args) {\n\t\t//创建context 对象\n\t\tContext context = new Context();\n        //将当前状态设置为 PublishState\n\t\tcontext.setState(new PublishState());\n        System.out.println(context.getCurrentState());\n        \n//        //publish --> not pay\n        context.acceptOrderEvent(context);\n//        //not pay --> paid\n        context.payOrderEvent(context);\n//        // 失败, 检测失败时，会抛出异常\n//        try {\n//        \tcontext.checkFailEvent(context);\n//        \tSystem.out.println(\"流程正常..\");\n//\t\t} catch (Exception e) {\n//\t\t\tSystem.out.println(e.getMessage());\n//\t\t}\n\t}\n}\n\n```\n\n\n\n\n## 六、状态模式的注意事项和细节\n\n- 代码有很强的**可读性**。状态模式将每个状态的行为封装到对应的一个类中\n\n- **方便维护**。将容易产生问题的 if-else 语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多 if-else 语句，而且容易出错\n\n- 符合“开闭原则”。容易增删状态\n\n- 会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多类，加大维护难度\n\n- 应用场景：当一个事件或者对象有很多种状态，状态之间会相互转换，对不同的状态要求有不同的行为的时候， 可以考虑使用状态模式",[[1573826200950,["GJX@GJXAIOU",[[-1,1157,"atguig"],[1,1163,"gjxaio"]],[1157,1164],[1157,1164]]],[1573826201140,["GJX@GJXAIOU",[[-1,1421,"atguig"],[1,1427,"gjxaio"]],[1421,1428],[1421,1428]]],[1573826201503,["GJX@GJXAIOU",[[-1,2507,"atguig"],[1,2513,"gjxaio"]],[2507,2514],[2507,2514]]],[1573826201627,["GJX@GJXAIOU",[[-1,3273,"atguig"],[1,3279,"gjxaio"]],[3273,3280],[3273,3280]]],[1573826201796,["GJX@GJXAIOU",[[-1,4277,"atguig"],[1,4283,"gjxaio"]],[4277,4284],[4277,4284]]],[1573826202089,["GJX@GJXAIOU",[[-1,4924,"atguig"],[1,4930,"gjxaio"]],[4924,4931],[4924,4931]]],[1573826202212,["GJX@GJXAIOU",[[-1,6909,"atguig"],[1,6915,"gjxaio"]],[6909,6916],[6909,6916]]],[1573826202663,["GJX@GJXAIOU",[[-1,7704,"atguig"],[1,7710,"gjxaio"]],[7704,7711],[7704,7711]]],[1573826202777,["GJX@GJXAIOU",[[-1,8433,"atguig"],[1,8439,"gjxaio"]],[8433,8440],[8433,8440]]],[1573826202878,["GJX@GJXAIOU",[[-1,9035,"atguig"],[1,9041,"gjxaio"]],[9035,9042],[9035,9042]]],[1573826203251,["GJX@GJXAIOU",[[-1,10070,"atguig"],[1,10076,"gjxaio"]],[10070,10077],[10070,10077]]],[1573826203453,["GJX@GJXAIOU",[[-1,11618,"atguig"],[1,11624,"gjxaio"]],[11618,11625],[11618,11625]]],[1573826203726,["GJX@GJXAIOU",[[-1,13161,"atguig"],[1,13167,"gjxaio"]],[13161,13168],[13161,13168]]]],null,"GJX@GJXAIOU"]]}