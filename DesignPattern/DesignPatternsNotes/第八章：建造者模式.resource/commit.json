{"compress":true,"commitItems":[["fb195841-1eba-4bb8-8db5-ab460d9d55d1",1573826349859,"# 第八章：建造者模式\n\n \n\n## 一、盖房项目需求\n\n- 需要建房子：这一过程为打桩、砌墙、封顶\n\n- 房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的.\n\n- 请编写程序，完成需求.\n\n \n\n \n\n## 传统方式解决盖房需求\n\n \n\n- 思路分析(图解)\n\n  ![传统方式](%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.resource/%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F.jpg)                                                                        \n\n- 看老师代码的演示\n\n ```java\npackage com.atguigu.builder;\n\npublic abstract class AbstractHouse {\n\t\n\t//打地基\n\tpublic abstract void buildBasic();\n\t//砌墙\n\tpublic abstract void buildWalls();\n\t//封顶\n\tpublic abstract void roofed();\n\n\t/**\n\t * 在构造方法中调用方法，使其在初始化时候有顺序执行\n\t */\n\tpublic void build() {\n\t\tbuildBasic();\n\t\tbuildWalls();\n\t\troofed();\n\t}\n}\n\n ```\n\n这里以  commonHouse 为例，实现上面的接口，其他实体类类型：\n\n```java\npackage com.atguigu.builder;\n\npublic class CommonHouse extends AbstractHouse {\n\n\t@Override\n\tpublic void buildBasic() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\" 普通房子打地基 \");\n\t}\n\n\t@Override\n\tpublic void buildWalls() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\" 普通房子砌墙 \");\n\t}\n\n\t@Override\n\tpublic void roofed() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\" 普通房子封顶 \");\n\t}\n}\n\n```\n\n测试方法：\n\n```java\npackage com.atguigu.builder;\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tCommonHouse commonHouse = new CommonHouse();\n\t\tcommonHouse.build();\n\t}\n}\n\n```\n\n\n\n\n\n## 三、传统方式的问题分析\n\n- 优点是比较好理解，简单易操作。\n\n- 设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好. 也就是说，这种设计方案，把产品(即：房子) 和 创建产品的过程(即：建房子流程) 封装在一起，耦合性增强了。\n\n-  解决方案：将产品和产品建造过程解耦 =>    **建造者模式**.\n\n\n\n## 四、建造者模式基本介绍\n\n- 建造者模式（**Builder Pattern**） 又叫**生成器模式**，是一种对象**构建模式**。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。\n\n- 建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们， 用户不需要知道内部的具体构建细节。\n\n \n\n## 五、建造者模式的四个角色\n\n- Product（产品角色）： 一个具体的产品对象。\n\n- Builder（抽象建造者）： 创建一个 Product 对象的各个部件指定的 **接口/抽象类**。【指定建造的流程，不负责具体的构造细节】\n\n- ConcreteBuilder（具体建造者）： 实现接口，构建和装配各个部件。\n\n- Director（指挥者）： 构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。\n\n## 六、建造者模式原理类图\n\n\n ![建造者模式](%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.resource/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg)\n\n \n\n \n\n## 七、建造者模式解决盖房需求应用实例\n\n \n\n- 需要建房子：这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都需要经历这些过程，下面我们使用建造者模式(Builder Pattern)来完成\n\n- 思路分析图解(类图)\n\n ![建造者模式思路](%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.resource/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E6%80%9D%E8%B7%AF.jpg)\n\n\n\n-  代码实现\n\n  建造指挥者：\n\n  ```java\n  package com.atguigu.builder.improve;\n  \n  //指挥者，这里去指定制作流程，返回产品\n  public class HouseDirector {\n  \t\n  \tHouseBuilder houseBuilder = null;\n  // 下面采用了两种方式传入 houseBuilder\n  \t//构造器传入 houseBuilder\n  \tpublic HouseDirector(HouseBuilder houseBuilder) {\n  \t\tthis.houseBuilder = houseBuilder;\n  \t}\n  \n  \t//通过setter 传入 houseBuilder\n  \tpublic void setHouseBuilder(HouseBuilder houseBuilder) {\n  \t\tthis.houseBuilder = houseBuilder;\n  \t}\n  \t\n  \t//如何处理建造房子的流程，交给指挥者\n  \tpublic House constructHouse() {\n  \t\thouseBuilder.buildBasic();\n  \t\thouseBuilder.buildWalls();\n  \t\thouseBuilder.roofed();\n  \t\treturn houseBuilder.buildHouse();\n  \t}\n  }\n  \n  ```\n\n  抽象建造者和具体类的建造者：\n\n  ```java\n  package com.atguigu.builder.improve;\n  \n  // 抽象的建造者\n  public abstract class HouseBuilder {\n  \n  \tprotected House house = new House();\n  \t\n  \t//将建造的流程写好, 抽象的方法\n  \tpublic abstract void buildBasic();\n  \tpublic abstract void buildWalls();\n  \tpublic abstract void roofed();\n  \t\n  \t//建造房子好， 将产品(房子) 返回\n  \tpublic House buildHouse() {\n  \t\treturn house;\n  \t}\n  }\n  \n  //-----------------------------------------------\n  package com.atguigu.builder.improve;\n  \n  public class CommonHouse extends HouseBuilder {\n  \t@Override\n  \tpublic void buildBasic() {\n  \t\tSystem.out.println(\" 普通房子打地基5米 \");\n  \t}\n  \n  \t@Override\n  \tpublic void buildWalls() {\n  \t\tSystem.out.println(\" 普通房子砌墙10cm \");\n  \t}\n  \n  \t@Override\n  \tpublic void roofed() {\n  \t\tSystem.out.println(\" 普通房子屋顶 \");\n  \t}\n  }\n  \n  //-----------------------------------------------\n  package com.atguigu.builder.improve;\n  \n  public class HighBuilding extends HouseBuilder {\n  \n  \t@Override\n  \tpublic void buildBasic() {\n  \t\tSystem.out.println(\" 高楼的打地基100米 \");\n  \t}\n  \n  \t@Override\n  \tpublic void buildWalls() {\n  \t\tSystem.out.println(\" 高楼的砌墙20cm \");\n  \t}\n  \n  \t@Override\n  \tpublic void roofed() {\n  \t\tSystem.out.println(\" 高楼的透明屋顶 \");\n  \t}\n  }\n  \n  ```\n\n  具体的建造产品：\n\n  ```java\n  package com.atguigu.builder.improve;\n  \n  //产品->Product\n  public class House {\n  \tprivate String baise;\n  \tprivate String wall;\n  \tprivate String roofed;\n  \tpublic String getBaise() {\n  \t\treturn baise;\n  \t}\n  \tpublic void setBaise(String baise) {\n  \t\tthis.baise = baise;\n  \t}\n  \tpublic String getWall() {\n  \t\treturn wall;\n  \t}\n  \tpublic void setWall(String wall) {\n  \t\tthis.wall = wall;\n  \t}\n  \tpublic String getRoofed() {\n  \t\treturn roofed;\n  \t}\n  \tpublic void setRoofed(String roofed) {\n  \t\tthis.roofed = roofed;\n  \t}\n  }\n  \n  ```\n\n  应用于测试：\n\n  ```java\n  package com.atguigu.builder.improve;\n  \n  public class Client {\n  \tpublic static void main(String[] args) {\n  \t\t\n  \t\t//盖普通房子\n  \t\tCommonHouse commonHouse = new CommonHouse();\n  \t\t//准备创建房子的指挥者【指挥者只要有一个就行】\n  \t\tHouseDirector houseDirector = new HouseDirector(commonHouse);\n  \t\t\n  \t\t//完成盖房子，返回产品(普通房子)\n  \t\tHouse house = houseDirector.constructHouse();\n  \t\t\n  \t\t//System.out.println(\"输出流程\");\n  \t\t\n  \t\tSystem.out.println(\"--------------------------\");\n  \t\t//盖高楼\n  \t\tHighBuilding highBuilding = new HighBuilding();\n  \t\t//重置建造者\n  \t\thouseDirector.setHouseBuilder(highBuilding);\n  \t\t//完成盖房子，返回产品(高楼)\n  \t\thouseDirector.constructHouse();\n  \t}\n  }\n  \n  ```\n\n  \n\n\n\n## 八、建造者模式在JDK 的应用和源码分析P138\n\n- java.lang.StringBuilder 中的建造者模式\n\n- 代码说明+Debug 源码\n\n-  源码中建造者模式角色分析\n  - Appendable 接口定义了多个 append 方法(抽象方法), 即 Appendable 为抽象建造者,  定义了抽象方法\n  - AbstractStringBuilder  实现了 Appendable  接口方法，这里的 AbstractStringBuilder 已经是建造者，只是不能实例化\n  - StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由 AbstractStringBuilder 完成, 而 StringBuilder     继承了 AbstractStringBuilder\n\n \n\n## 九、建造者模式的注意事项和细节\n\n \n\n- 客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象\n\n- 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象\n\n- 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰， 也更方便使用程序来控制创建过程\n\n- 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”\n\n- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。\n\n- 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.\n\n-  抽象工厂模式 VS 建造者模式\n\n  抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品",[[1573826291752,["GJX@GJXAIOU",[[-1,399,"atguig"],[1,405,"gjxaio"]],[399,406],[399,406]]],[1573826292001,["GJX@GJXAIOU",[[-1,757,"atguig"],[1,763,"gjxaio"]],[757,764],[757,764]]],[1573826292254,["GJX@GJXAIOU",[[-1,1198,"atguig"],[1,1204,"gjxaio"]],[1198,1205],[1198,1205]]],[1573826292444,["GJX@GJXAIOU",[[-1,2511,"atguig"],[1,2517,"gjxaio"]],[2511,2518],[2511,2518]]],[1573826292645,["GJX@GJXAIOU",[[-1,3170,"atguig"],[1,3176,"gjxaio"]],[3170,3177],[3170,3177]]],[1573826292856,["GJX@GJXAIOU",[[-1,3581,"atguig"],[1,3587,"gjxaio"]],[3581,3588],[3581,3588]]],[1573826293090,["GJX@GJXAIOU",[[-1,3993,"atguig"],[1,3999,"gjxaio"]],[3993,4000],[3993,4000]]],[1573826293288,["GJX@GJXAIOU",[[-1,4387,"atguig"],[1,4393,"gjxaio"]],[4387,4394],[4387,4394]]],[1573826293532,["GJX@GJXAIOU",[[-1,4943,"atguig"],[1,4949,"gjxaio"]],[4943,4950],[4943,4950]]]],null,"GJX@GJXAIOU"],["8640a927-34b2-44bb-898c-5452bf274f94",1573827175420,"# 第八章：建造者模式\n\n \n\n## 一、盖房项目需求\n\n- 需要建房子：这一过程为打桩、砌墙、封顶\n\n- 房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的.\n\n- 请编写程序，完成需求.\n\n \n\n \n\n## 传统方式解决盖房需求\n\n \n\n- 思路分析(图解)\n\n  ![传统方式](%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.resource/%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F.jpg)                                                                        \n\n- 看老师代码的演示\n\n ```java\npackage com.gjxaiou.builder;\n\npublic abstract class AbstractHouse {\n\t\n\t//打地基\n\tpublic abstract void buildBasic();\n\t//砌墙\n\tpublic abstract void buildWalls();\n\t//封顶\n\tpublic abstract void roofed();\n\n\t/**\n\t * 在构造方法中调用方法，使其在初始化时候有顺序执行\n\t */\n\tpublic void build() {\n\t\tbuildBasic();\n\t\tbuildWalls();\n\t\troofed();\n\t}\n}\n\n ```\n\n这里以  commonHouse 为例，实现上面的接口，其他实体类类型：\n\n```java\npackage com.gjxaiou.builder;\n\npublic class CommonHouse extends AbstractHouse {\n\n\t@Override\n\tpublic void buildBasic() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\" 普通房子打地基 \");\n\t}\n\n\t@Override\n\tpublic void buildWalls() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\" 普通房子砌墙 \");\n\t}\n\n\t@Override\n\tpublic void roofed() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\" 普通房子封顶 \");\n\t}\n}\n\n```\n\n测试方法：\n\n```java\npackage com.gjxaiou.builder;\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tCommonHouse commonHouse = new CommonHouse();\n\t\tcommonHouse.build();\n\t}\n}\n\n```\n\n\n\n\n\n## 三、传统方式的问题分析\n\n- 优点是比较好理解，简单易操作。\n\n- 设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好. 也就是说，这种设计方案，把产品(即：房子) 和 创建产品的过程(即：建房子流程) 封装在一起，耦合性增强了。\n\n-  解决方案：将产品和产品建造过程解耦 =>    **建造者模式**.\n\n\n\n## 四、建造者模式基本介绍\n\n- 建造者模式（**Builder Pattern**） 又叫**生成器模式**，是一种对象**构建模式**。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。\n\n- 建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们， 用户不需要知道内部的具体构建细节。\n\n \n\n## 五、建造者模式的四个角色\n\n- Product（产品角色）： 一个具体的产品对象。\n\n- Builder（抽象建造者）： 创建一个 Product 对象的各个部件指定的 **接口/抽象类**。【指定建造的流程，不负责具体的构造细节】\n\n- ConcreteBuilder（具体建造者）： 实现接口，构建和装配各个部件。\n\n- Director（指挥者）： 构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。\n\n## 六、建造者模式原理类图\n\n\n ![建造者模式](%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.resource/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg)\n\n \n\n \n\n## 七、建造者模式解决盖房需求应用实例\n\n \n\n- 需要建房子：这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都需要经历这些过程，下面我们使用建造者模式(Builder Pattern)来完成\n\n- 思路分析图解(类图)\n\n ![建造者模式思路](%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.resource/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E6%80%9D%E8%B7%AF.jpg)\n\n\n\n-  代码实现\n\n  建造指挥者：\n\n  ```java\n  package com.gjxaiou.builder.improve;\n  \n  //指挥者，这里去指定制作流程，返回产品\n  public class HouseDirector {\n  \t\n  \tHouseBuilder houseBuilder = null;\n  // 下面采用了两种方式传入 houseBuilder\n  \t//构造器传入 houseBuilder\n  \tpublic HouseDirector(HouseBuilder houseBuilder) {\n  \t\tthis.houseBuilder = houseBuilder;\n  \t}\n  \n  \t//通过setter 传入 houseBuilder\n  \tpublic void setHouseBuilder(HouseBuilder houseBuilder) {\n  \t\tthis.houseBuilder = houseBuilder;\n  \t}\n  \t\n  \t//如何处理建造房子的流程，交给指挥者\n  \tpublic House constructHouse() {\n  \t\thouseBuilder.buildBasic();\n  \t\thouseBuilder.buildWalls();\n  \t\thouseBuilder.roofed();\n  \t\treturn houseBuilder.buildHouse();\n  \t}\n  }\n  \n  ```\n\n  抽象建造者和具体类的建造者：\n\n  ```java\n  package com.gjxaiou.builder.improve;\n  \n  // 抽象的建造者\n  public abstract class HouseBuilder {\n  \n  \tprotected House house = new House();\n  \t\n  \t//将建造的流程写好, 抽象的方法\n  \tpublic abstract void buildBasic();\n  \tpublic abstract void buildWalls();\n  \tpublic abstract void roofed();\n  \t\n  \t//建造房子好， 将产品(房子) 返回\n  \tpublic House buildHouse() {\n  \t\treturn house;\n  \t}\n  }\n  \n  //-----------------------------------------------\n  package com.gjxaiou.builder.improve;\n  \n  public class CommonHouse extends HouseBuilder {\n  \t@Override\n  \tpublic void buildBasic() {\n  \t\tSystem.out.println(\" 普通房子打地基5米 \");\n  \t}\n  \n  \t@Override\n  \tpublic void buildWalls() {\n  \t\tSystem.out.println(\" 普通房子砌墙10cm \");\n  \t}\n  \n  \t@Override\n  \tpublic void roofed() {\n  \t\tSystem.out.println(\" 普通房子屋顶 \");\n  \t}\n  }\n  \n  //-----------------------------------------------\n  package com.gjxaiou.builder.improve;\n  \n  public class HighBuilding extends HouseBuilder {\n  \n  \t@Override\n  \tpublic void buildBasic() {\n  \t\tSystem.out.println(\" 高楼的打地基100米 \");\n  \t}\n  \n  \t@Override\n  \tpublic void buildWalls() {\n  \t\tSystem.out.println(\" 高楼的砌墙20cm \");\n  \t}\n  \n  \t@Override\n  \tpublic void roofed() {\n  \t\tSystem.out.println(\" 高楼的透明屋顶 \");\n  \t}\n  }\n  \n  ```\n\n  具体的建造产品：\n\n  ```java\n  package com.gjxaiou.builder.improve;\n  \n  //产品->Product\n  public class House {\n  \tprivate String baise;\n  \tprivate String wall;\n  \tprivate String roofed;\n  \tpublic String getBaise() {\n  \t\treturn baise;\n  \t}\n  \tpublic void setBaise(String baise) {\n  \t\tthis.baise = baise;\n  \t}\n  \tpublic String getWall() {\n  \t\treturn wall;\n  \t}\n  \tpublic void setWall(String wall) {\n  \t\tthis.wall = wall;\n  \t}\n  \tpublic String getRoofed() {\n  \t\treturn roofed;\n  \t}\n  \tpublic void setRoofed(String roofed) {\n  \t\tthis.roofed = roofed;\n  \t}\n  }\n  \n  ```\n\n  应用于测试：\n\n  ```java\n  package com.gjxaiou.builder.improve;\n  \n  public class Client {\n  \tpublic static void main(String[] args) {\n  \t\t\n  \t\t//盖普通房子\n  \t\tCommonHouse commonHouse = new CommonHouse();\n  \t\t//准备创建房子的指挥者【指挥者只要有一个就行】\n  \t\tHouseDirector houseDirector = new HouseDirector(commonHouse);\n  \t\t\n  \t\t//完成盖房子，返回产品(普通房子)\n  \t\tHouse house = houseDirector.constructHouse();\n  \t\t\n  \t\t//System.out.println(\"输出流程\");\n  \t\t\n  \t\tSystem.out.println(\"--------------------------\");\n  \t\t//盖高楼\n  \t\tHighBuilding highBuilding = new HighBuilding();\n  \t\t//重置建造者\n  \t\thouseDirector.setHouseBuilder(highBuilding);\n  \t\t//完成盖房子，返回产品(高楼)\n  \t\thouseDirector.constructHouse();\n  \t}\n  }\n  \n  ```\n\n  \n\n\n\n## 八、建造者模式在JDK 的应用和源码分析P138\n\n- java.lang.StringBuilder 中的建造者模式\n\n- 代码说明+Debug 源码\n\n-  源码中建造者模式角色分析\n  - Appendable 接口定义了多个 append 方法(抽象方法), 即 Appendable 为抽象建造者,  定义了抽象方法\n  - AbstractStringBuilder  实现了 Appendable  接口方法，这里的 AbstractStringBuilder 已经是建造者，只是不能实例化\n  - StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由 AbstractStringBuilder 完成, 而 StringBuilder     继承了 AbstractStringBuilder\n\n \n\n## 九、建造者模式的注意事项和细节\n\n \n\n- 客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象\n\n- 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象\n\n- 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰， 也更方便使用程序来控制创建过程\n\n- 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”\n\n- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。\n\n- 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.\n\n-  抽象工厂模式 VS 建造者模式\n\n  抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品",[[1573827118342,["GJX@GJXAIOU",[[-1,4919,"  "]],[4919,4921],[4919,4919]]],[1573827120357,["GJX@GJXAIOU",[[-1,4902,"  "]],[4902,4904],[4902,4902]]],[1573827123063,["GJX@GJXAIOU",[[-1,5564,"  "]],[5564,5566],[5564,5564]]],[1573827125917,["GJX@GJXAIOU",[[-1,5638,"\n"]],[5638,5638],[5637,5637]]],[1573827126804,["GJX@GJXAIOU",[[-1,5654,"\n"]],[5654,5654],[5653,5653]]],[1573827131062,["GJX@GJXAIOU",[[-1,5977,"\n"]],[5977,5977],[5976,5976]]],[1573827131508,["GJX@GJXAIOU",[[-1,5975," "]],[5976,5976],[5975,5975]]],[1573827132030,["GJX@GJXAIOU",[[-1,5975,"\n"]],[5975,5975],[5974,5974]]],[1573827133062,["GJX@GJXAIOU",[[-1,6037,"\n"]],[6037,6037],[6036,6036]]],[1573827134132,["GJX@GJXAIOU",[[-1,6117,"\n"]],[6117,6117],[6116,6116]]],[1573827135187,["GJX@GJXAIOU",[[-1,6185,"\n"]],[6185,6185],[6184,6184]]],[1573827137638,["GJX@GJXAIOU",[[-1,6239,"\n"]],[6239,6239],[6238,6238]]],[1573827138638,["GJX@GJXAIOU",[[-1,6312,"\n"]],[6312,6312],[6311,6311]]],[1573827140133,["GJX@GJXAIOU",[[-1,6384,"\n"]],[6384,6384],[6383,6383]]],[1573827141483,["GJX@GJXAIOU",[[-1,6403,"\n"]],[6403,6403],[6402,6402]]],[1573827143596,["GJX@GJXAIOU",[[-1,5952," "]],[5953,5953],[5952,5952]]],[1573827144015,["GJX@GJXAIOU",[[-1,5953,"\n"]],[5952,5952],[5951,5951]]],[1573827146140,["GJX@GJXAIOU",[[-1,5574,"\n"]],[5573,5573],[5572,5572]]],[1573827146404,["GJX@GJXAIOU",[[-1,5573,"\n"]],[5572,5572],[5571,5571]]],[1573827147207,["GJX@GJXAIOU",[[-1,5569,"  "]],[5571,5571],[5569,5569]]],[1573827147644,["GJX@GJXAIOU",[[-1,5570,"\n"]],[5569,5569],[5568,5568]]],[1573827156164,["GJX@GJXAIOU",[[-1,4363,"  "]],[4363,4365],[4363,4363]]],[1573827158500,["GJX@GJXAIOU",[[-1,4344,"  "]],[4344,4346],[4344,4344]]],[1573827164268,["GJX@GJXAIOU",[[-1,3146,"  "]],[3146,3148],[3146,3146]]],[1573827168476,["GJX@GJXAIOU",[[-1,3121,"  "]],[3121,3123],[3121,3121]]],[1573827172204,["GJX@GJXAIOU",[[-1,2487,"  "]],[2487,2489],[2487,2487]]],[1573827174660,["GJX@GJXAIOU",[[-1,2486,"\n"]],[2486,2486],[2485,2485]]],[1573827176469,["GJX@GJXAIOU",[[-1,2467,"\n"]],[2466,2466],[2465,2465]]],[1573827176868,["GJX@GJXAIOU",[[-1,2466,"\n"]],[2465,2465],[2464,2464]]],[1573827178804,["GJX@GJXAIOU",[[-1,2278,"\n"]],[2278,2278],[2277,2277]]],[1573827179612,["GJX@GJXAIOU",[[-1,2199,"\n"]],[2199,2199],[2198,2198]]],[1573827179988,["GJX@GJXAIOU",[[-1,2197," "]],[2198,2198],[2197,2197]]],[1573827180437,["GJX@GJXAIOU",[[-1,2197,"\n"]],[2197,2197],[2196,2196]]],[1573827182780,["GJX@GJXAIOU",[[-1,2172," "]],[2173,2173],[2172,2172]]],[1573827183097,["GJX@GJXAIOU",[[-1,2173,"\n"]],[2172,2172],[2171,2171]]],[1573827183469,["GJX@GJXAIOU",[[-1,2172,"\n"]],[2171,2171],[2170,2170]]],[1573827183884,["GJX@GJXAIOU",[[-1,2169," "]],[2170,2170],[2169,2169]]],[1573827184374,["GJX@GJXAIOU",[[-1,2170,"\n"]],[2169,2169],[2168,2168]]],[1573827185004,["GJX@GJXAIOU",[[-1,2169,"\n"]],[2168,2168],[2167,2167]]],[1573827186741,["GJX@GJXAIOU",[[-1,2015,"\n"]],[2015,2015],[2014,2014]]],[1573827187149,["GJX@GJXAIOU",[[-1,2014,"\n"]],[2014,2014],[2013,2013]]],[1573827190643,["GJX@GJXAIOU",[[-1,1899,"\n"]],[1899,1899],[1898,1898]]],[1573827191309,["GJX@GJXAIOU",[[-1,1856,"\n"]],[1856,1856],[1855,1855]]],[1573827192013,["GJX@GJXAIOU",[[-1,1781,"\n"]],[1781,1781],[1780,1780]]],[1573827193686,["GJX@GJXAIOU",[[-1,1661,"\n"]],[1661,1661],[1660,1660]]],[1573827195372,["GJX@GJXAIOU",[[-1,1533,"\n"]],[1532,1532],[1531,1531]]],[1573827195612,["GJX@GJXAIOU",[[-1,1532,"\n"]],[1531,1531],[1530,1530]]],[1573827196467,["GJX@GJXAIOU",[[-1,1730," "]],[1731,1731],[1730,1730]]],[1573827196692,["GJX@GJXAIOU",[[-1,1731,"\n"]],[1730,1730],[1729,1729]]],[1573827198575,["GJX@GJXAIOU",[[-1,1492,"\n"]],[1492,1492],[1491,1491]]],[1573827199375,["GJX@GJXAIOU",[[-1,1399,"\n"]],[1399,1399],[1398,1398]]],[1573827200127,["GJX@GJXAIOU",[[-1,1364,"\n"]],[1363,1363],[1362,1362]]],[1573827200349,["GJX@GJXAIOU",[[-1,1363,"\n"]],[1362,1362],[1361,1361]]],[1573827200692,["GJX@GJXAIOU",[[-1,1362,"\n"]],[1361,1361],[1360,1360]]],[1573827204654,["GJX@GJXAIOU",[[-1,693," "]],[693,694],[693,693]]],[1573827207508,["GJX@GJXAIOU",[[-1,378," "]],[378,379],[378,378]]],[1573827211036,["GJX@GJXAIOU",[[-1,135," "]],[136,136],[135,135]]],[1573827212812,["GJX@GJXAIOU",[[-1,136,"\n"]],[136,136],[135,135]]],[1573827213574,["GJX@GJXAIOU",[[-1,135,"\n"]],[135,135],[134,134]]],[1573827215467,["GJX@GJXAIOU",[[-1,119,"\n"]],[119,119],[118,118]]],[1573827215724,["GJX@GJXAIOU",[[-1,117," "]],[118,118],[117,117]]],[1573827216203,["GJX@GJXAIOU",[[-1,117,"\n"]],[117,117],[116,116]]],[1573827217156,["GJX@GJXAIOU",[[-1,116,"\n"]],[116,116],[115,115]]],[1573827217579,["GJX@GJXAIOU",[[-1,114," "]],[115,115],[114,114]]],[1573827218031,["GJX@GJXAIOU",[[-1,114,"\n"]],[114,114],[113,113]]],[1573827219029,["GJX@GJXAIOU",[[-1,98,"\n"]],[98,98],[97,97]]],[1573827220109,["GJX@GJXAIOU",[[-1,51,"\n"]],[51,51],[50,50]]],[1573827222469,["GJX@GJXAIOU",[[-1,15,"\n"]],[15,15],[14,14]]],[1573827222836,["GJX@GJXAIOU",[[-1,13," "]],[14,14],[13,13]]],[1573827223310,["GJX@GJXAIOU",[[-1,13,"\n"]],[13,13],[12,12]]]],null,"GJX@GJXAIOU"]]}