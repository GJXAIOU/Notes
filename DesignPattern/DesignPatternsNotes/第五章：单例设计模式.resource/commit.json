{"compress":true,"commitItems":[["f31fab28-fb38-40cf-b8bb-6fdb429969c4",1573475417929,"",[[1573475369489,["GJX@GJXAIOU",[[1,0,"# 第五章：单例设计模式\n\n\n\n"]],[0,0],[15,15]]],[1573475407986,["GJX@GJXAIOU",[[1,15,"## 5.1 单例设计模式介绍\n\n所谓类的单例设计模式，就是**采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例**， 并且该类只提供一个取得其对象实例的方法(静态方法)。\n\n比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。\n\n## 5.2 单例设计模式八种方式\n\n单例模式有八种方式：\n\n**1)** **饿汉式****(****静态常量****)**\n\n**2)** **饿汉式（静态代码块）**\n\n**3)** 懒汉式(线程不安全)\n\n**4)** 懒汉式(线程安全，同步方法)\n\n**5)** 懒汉式(线程安全，同步代码块)\n\n**6)** **双重检查**\n\n**7)** **静态内部类**\n\n**8)** **枚举**\n\n## 5.3 饿汉式（静态常量）\n\n饿汉式（静态常量）应用实例**步骤如下**：\n\n1) 构造器私有化 (防止 new )\n\n2) 类的内部创建对象\n\n3) 向外暴露一个静态的公共方法。getInstance\n\n4) 代码实现\n\n| \n\npackage com.atguigu.singleton.type1;\n\npublic class SingletonTest01 {\n\npublic static void main(String[] args) {\n\n//测试\n\nSingleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true\n\nSystem.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\n}\n\n}\n\n//饿汉式(静态变量)\n\nclass Singleton {\n\n//1. 构造器私有化, 外部能 new private Singleton() {\n\n |\n\n| \n\n}\n\n//2.本类内部创建对象实例\n\nprivate final static Singleton instance = new Singleton();\n\n//3. 提供一个公有的静态方法，返回实例对象\n\npublic static Singleton getInstance() { return instance;\n\n}\n\n}\n\n |\n\n#### Ø 优缺点说明：\n\n1) 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。\n\n2) 缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费\n\n3) 这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法， 但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果\n\n4) 结论：这种单例模式可用，可能造成内存浪费\n\n## 5.4 饿汉式（静态代码块）\n\nØ 代码演示：\n\n| \n\npackage com.atguigu.singleton.type2;\n\npublic class SingletonTest02 {\n\npublic static void main(String[] args) {\n\n//测试\n\nSingleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true\n\nSystem.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\n}\n\n}\n\n//饿汉式(静态变量)\n\nclass Singleton {\n\n//1. 构造器私有化, 外部能 new private Singleton() {\n\n}\n\n//2.本类内部创建对象实例\n\n |\n\n| \n\nprivate static Singleton  instance;\n\nstatic { // 在静态代码块中，创建单例对象\n\ninstance = new Singleton();\n\n}\n\n//3. 提供一个公有的静态方法，返回实例对象\n\npublic static Singleton getInstance() { return instance;\n\n}\n\n}\n\n |\n\nØ 优缺点说明：\n\n1) 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。\n\n2) 结论：这种单例模式可用，但是可能造成内存浪费\n\n## 5.5 懒汉式(线程不安全)\n\nØ 代码演示：\n\n| \n\npackage com.atguigu.singleton.type3;\n\npublic class SingletonTest03 {\n\n |\n\n| \n\npublic static void main(String[] args) { System.out.println(\"懒汉式 1 ， 线程不安全~\"); Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true\n\nSystem.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\n}\n\n}\n\nclass Singleton {\n\nprivate static Singleton instance;\n\nprivate Singleton() {}\n\n//提供一个静态的公有方法，当使用到该方法时，才去创建 instance\n\n//即懒汉式\n\npublic static Singleton getInstance() { if(instance == null) {\n\ninstance = new Singleton();\n\n}\n\nreturn instance;\n\n}\n\n}\n\n |\n\nØ 优缺点说明：\n\n1) 起到了 **Lazy Loading** 的效果，但是只能在单线程下使用。\n\n2) 如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会**产生多个实例**。所以在多线程环境下不可使用这种方式\n\n3) 结论：在实际开发中，**不要使用**这种方式.\n\n## 5.6 懒汉式(线程安全，同步方法)\n\nØ 代码演示：\n\n| \n\npackage com.atguigu.singleton.type4;\n\npublic class SingletonTest04 {\n\npublic static void main(String[] args) { System.out.println(\"懒汉式 2 ， 线程安全~\"); Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true\n\nSystem.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\n}\n\n}\n\n |\n\n| \n\n// 懒汉式(线程安全，同步方法) class Singleton {\n\nprivate static Singleton instance;\n\nprivate Singleton() {}\n\n//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题\n\n//即懒汉式\n\npublic static **synchronized** Singleton getInstance() { if(instance == null) {\n\ninstance = new Singleton();\n\n}\n\nreturn instance;\n\n}\n\n}\n\n |\n\nØ 优缺点说明：\n\n1) 解决了**线程安全**问题\n\n2) 效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。**方法进行同步效率太**低\n\n3) 结论：在实际开发中，**不推荐**使用这种方式\n\n## 5.7 懒汉式(线程安全，同步代码块)\n\n不推荐使用\n\n## 5.8 双重检查\n\nØ 代码演示\n\n| \n\npackage com.atguigu.singleton.type6;\n\npublic class SingletonTest06 {\n\npublic static void main(String[] args) { System.out.println(\"双重检查\");\n\nSingleton instance = Singleton.getInstance();\n\nSingleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\n |\n\n| \n\n}\n\n}\n\n// 懒汉式(线程安全，同步方法) class Singleton {\n\nprivate static volatile Singleton instance;\n\nprivate Singleton() {}\n\n//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题\n\n//同时保证了效率, 推荐使用\n\npublic static synchronized Singleton getInstance() { if(instance == null) {\n\nsynchronized (Singleton.class) { if(instance == null) {\n\ninstance = new Singleton();\n\n}\n\n}\n\n}\n\nreturn instance;\n\n}\n\n}\n\n |\n\nØ 优缺点说明：\n\n1) Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这样就可以保证线程安全了。\n\n2) 这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象，也避免的反复进行方法同步.\n\n#### 3) 线程安全；延迟加载；效率较高\n\n4) 结论：在实际开发中，**推荐使用这种单例设计模**式\n\n## 5.9 静态内部类\n\nØ 代码演示：\n\n| \n\npackage com.atguigu.singleton.type7;\n\npublic class SingletonTest07 {\n\npublic static void main(String[] args) { System.out.println(\"使用静态内部类完成单例模式\"); Singleton instance = Singleton.getInstance();\n\nSingleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\n}\n\n |\n\n| \n\n}\n\n// 静态内部类完成， 推荐使用\n\nclass Singleton {\n\nprivate static volatile Singleton instance;\n\n//构造器私有化private Singleton() {}\n\n//写一个静态内部类,该类中有一个静态属性 Singleton private static class SingletonInstance {\n\nprivate static final Singleton INSTANCE = new Singleton();\n\n}\n\n//提供一个静态的公有方法，直接返回 SingletonInstance.INSTANCE\n\npublic static synchronized Singleton getInstance() {\n\nreturn SingletonInstance.INSTANCE;\n\n}\n\n}\n\n |\n\nØ 优缺点说明：\n\n1) 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。\n\n2) 静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。\n\n3) 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM  帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。\n\n#### 4) 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高\n\n5) 结论：**推荐**使用.\n\n## 5.10 枚举\n\nØ 代码演示\n\n| \n\npackage com.atguigu.singleton.type8;\n\npublic class SingletonTest08 {\n\npublic static void main(String[] args) { Singleton instance =  Singleton.INSTANCE;\n\nSingleton instance2 =  Singleton.INSTANCE; System.out.println(instance ==  instance2);\n\nSystem.out.println(instance.hashCode()); System.out.println(instance2.hashCode());\n\ninstance.sayOK();\n\n}\n\n}\n\n//使用枚举，可以实现单例, 推荐\n\nenum Singleton {\n\n |\n\n| \n\nINSTANCE; //属性public void sayOK() {\n\nSystem.out.println(\"ok~\");\n\n}\n\n}\n\n |\n\nØ 优缺点说明：\n\n1) 这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。\n\n2) 这种方式是 **Effective  Java** **作者** **Josh  Bloch** **提倡**的方式\n\n3) 结论：**推荐**使用\n\n## 5.11 单例模式在 JDK 应用的源码分析\n\n### 5.11.1 单例模式在JDK 应用的源码分析\n\n1) 我们 JDK 中，java.lang.Runtime 就是经典的单例模式(饿汉式)\n\n2) 代码分析+Debug 源码+代码说明\n\n## 5.12 单例模式注意事项和细节说明\n\n1) 单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能\n\n2) 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new\n\n3) 单例模式**使用的场景**：需要**频繁的进行创建和销毁的对象**、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、**工具类对象**、频繁访问数据库或文件的对象(比如**数据源、****session** **工厂**等)"]],[15,15],[7487,7487]]],[1573475777124,["GJX@GJXAIOU",[[-1,287,"****"]],[287,291],[287,287]]],[1573475780452,["GJX@GJXAIOU",[[-1,288,"****"]],[292,292],[288,288]]],[1573475786690,["GJX@GJXAIOU",[[-1,292,"****"]],[296,296],[292,292]]],[1573475917045,["GJX@GJXAIOU",[[-1,551,"| \n\npackage com.atguigu.singleton.type1;\n\npublic class SingletonTest01 {\n\npublic static void main(String[] args) {\n\n//测试\n\nSingleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true\n\nSystem.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\n}\n\n}\n\n//饿汉式(静态变量)\n\nclass Singleton {\n\n//1. 构造器私有化, 外部能 new private Singleton() {\n\n |\n\n| \n\n}\n\n//2.本类内部创建对象实例\n\nprivate final static Singleton instance = new Singleton();\n\n//3. 提供一个公有的静态方法，返回实例对象\n\npublic static Singleton getInstance() { return instance;\n\n}\n\n}\n\n |"]],[551,1209],[551,551]]],[1573475917773,["GJX@GJXAIOU",[[1,551,"···"]],[551,551],[554,554]]],[1573475919149,["GJX@GJXAIOU",[[-1,551,"···"]],[554,554],[551,551]]],[1573475919603,["GJX@GJXAIOU",[[-1,552,"\n"]],[551,551],[550,550]]],[1573475920492,["GJX@GJXAIOU",[[1,552,"\n"]],[550,550],[551,551]]],[1573475920884,["GJX@GJXAIOU",[[1,551,"·"]],[551,551],[552,552]]],[1573475921867,["GJX@GJXAIOU",[[-1,551,"·"]],[552,552],[551,551]]],[1573475922693,["GJX@GJXAIOU",[[1,551,"```"]],[551,551],[554,554]]],[1573475922798,["GJX@GJXAIOU",[[1,554,"language\n```\n"]],[554,554],[554,562]]],[1573475924380,["GJX@GJXAIOU",[[-1,554,"language"],[1,562,"j"]],[554,562],[555,555]]],[1573475924921,["GJX@GJXAIOU",[[1,555,"ava"]],[555,555],[558,558]]],[1573475925157,["GJX@GJXAIOU",[[1,559,"\n"]],[558,558],[559,559]]],[1573475926726,["GJX@GJXAIOU",[[1,559,"| \n\npackage com.atguigu.singleton.type1;\n\npublic class SingletonTest01 {\n\npublic static void main(String[] args) {\n\n//测试\n\nSingleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true\n\nSystem.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\n}\n\n}\n\n//饿汉式(静态变量)\n\nclass Singleton {\n\n//1. 构造器私有化, 外部能 new private Singleton() {\n\n |\n\n| \n\n}\n\n//2.本类内部创建对象实例\n\nprivate final static Singleton instance = new Singleton();\n\n//3. 提供一个公有的静态方法，返回实例对象\n\npublic static Singleton getInstance() { return instance;\n\n}\n\n}\n\n |"]],[559,559],[1217,1217]]],[1573475929073,["GJX@GJXAIOU",[[-1,559,"| \n\npackage com.atguigu.singleton.type1;\n\npublic class SingletonTest01 {\n\npublic static void main(String[] args) {\n\n//测试\n\nSingleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true\n\nSystem.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\n}\n\n}\n\n//饿汉式(静态变量)\n\nclass Singleton {\n\n//1. 构造器私有化, 外部能 new private Singleton() {\n\n |\n\n| \n\n}\n\n//2.本类内部创建对象实例\n\nprivate final static Singleton instance = new Singleton();\n\n//3. 提供一个公有的静态方法，返回实例对象\n\npublic static Singleton getInstance() { return instance;\n\n}\n\n}\n\n |"]],[1217,1217],[559,559]]],[1573475931352,["GJX@GJXAIOU",[[1,559,"package com.atguigu.singleton.type1;\n\n\npublic class SingletonTest01 {\n\n\npublic static void main(String[] args) {\n//测试\nSingleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true\nSystem.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n}\n\n\n}\n\n\n//饿汉式(静态变量)\n\n\nclass Singleton {\n\n\n//1. 构造器私有化, 外部能 new private Singleton() {\n \n\n}\n\n\n//2.本类内部创建对象实例\nprivate final static Singleton instance = new Singleton();\n\n\n//3. 提供一个公有的静态方法，返回实例对象\npublic static Singleton getInstance() { return instance;\n}\n\n\n}\n"]],[559,559],[1206,1206]]],[1573475935738,["GJX@GJXAIOU",[[-1,478,"1) "]],[478,481],[478,478]]],[1573475936189,["GJX@GJXAIOU",[[1,478,"- "]],[478,478],[480,480]]],[1573475941858,["GJX@GJXAIOU",[[-1,498,"2) "]],[501,501],[498,498]]],[1573475942227,["GJX@GJXAIOU",[[-1,497,"\n"]],[498,498],[497,497]]],[1573475943163,["GJX@GJXAIOU",[[1,497,"- "]],[497,497],[499,499]]],[1573475946388,["GJX@GJXAIOU",[[-1,509,"3) "]],[512,512],[509,509]]],[1573475946860,["GJX@GJXAIOU",[[-1,508,"\n"]],[509,509],[508,508]]],[1573475948015,["GJX@GJXAIOU",[[1,508,"- "]],[508,508],[510,510]]],[1573475953346,["GJX@GJXAIOU",[[-1,592,"\n"]],[592,592],[591,591]]],[1573475953552,["GJX@GJXAIOU",[[-1,591,"\n"]],[591,591],[590,590]]],[1573475956938,["GJX@GJXAIOU",[[1,591,"\n"]],[590,590],[591,591]]],[1573475962700,["GJX@GJXAIOU",[[-1,624,"\n"]],[624,624],[623,623]]],[1573475965114,["GJX@GJXAIOU",[[-1,965,"\n"]],[965,965],[964,964]]],[1573475966044,["GJX@GJXAIOU",[[-1,964,"\n"]],[964,964],[963,963]]],[1573475968675,["GJX@GJXAIOU",[[-1,983,"\n"]],[983,983],[982,982]]],[1573475973619,["GJX@GJXAIOU",[[1,1004,"\n"]],[1004,1004],[1005,1005]]],[1573475975501,["GJX@GJXAIOU",[[1,1005,"   "]],[1005,1005],[1008,1008]]],[1573475977373,["GJX@GJXAIOU",[[1,983,"    "]],[983,983],[987,987]]],[1573476014115,["GJX@GJXAIOU",[[1,624,"\t"],[1,665,"\t\t"],[1,670,"\t\t"],[-1,715," "],[1,716,"\n\t\t"],[-1,762," "],[1,763,"\n\t\t"],[1,814,"\t\t"],[-1,877," "],[1,878,"\n\t\t"],[1,944,"\t"],[-1,945,"\n"],[-1,951,"\n"],[1,963,"\n"],[-1,982,"\n    "],[1,987,"\t\n\t"],[-1,1003," "],[-1,1007," \n   "],[1,1012,"\n\t"],[-1,1034," \n\n}\n\n\n"],[1,1041,"\t\t\n\t}\n\t\n\t"],[1,1056,"\t"],[-1,1115,"\n\n"],[1,1117,"\t\n\t"],[1,1141,"\t"],[-1,1180," "],[1,1181,"\n\t\t"],[1,1198,"\t"],[-1,1200,"\n"],[1,1201,"\t"],[-1,1203,"\n"]],[554,1204],[1218,1218]]],[1573476019715,["GJX@GJXAIOU",[[-1,566,"atguigu"]],[573,573],[566,566]]],[1573476021944,["GJX@GJXAIOU",[[1,566,"gjxaiou"]],[566,566],[573,573]]],[1573476060811,["GJX@GJXAIOU",[[-1,1040,"\n"]],[1041,1041],[1040,1040]]],[1573476063314,["GJX@GJXAIOU",[[-1,995,"\t"]],[996,996],[995,995]]],[1573476063780,["GJX@GJXAIOU",[[-1,995,"\n"]],[995,995],[994,994]]],[1573476065834,["GJX@GJXAIOU",[[-1,976,"\n"]],[976,976],[975,975]]],[1573476068034,["GJX@GJXAIOU",[[-1,1210,"\n"]],[1211,1211],[1210,1210]]],[1573476140251,["GJX@GJXAIOU",[[1,1214,"\n"]],[1213,1213],[1214,1214]]],[1573476140472,["GJX@GJXAIOU",[[1,1215,"\n"]],[1214,1214],[1215,1215]]],[1573476145341,["GJX@GJXAIOU",[[1,1215,"// output:"]],[1215,1215],[1225,1225]]],[1573476145701,["GJX@GJXAIOU",[[1,1226,"\n"]],[1225,1225],[1226,1226]]],[1573476151420,["GJX@GJXAIOU",[[1,1226,"true\ninstance.hashCode=325040804\ninstance2.hashCode=325040804"]],[1226,1226],[1287,1287]]],[1573476165217,["GJX@GJXAIOU",[[-1,18,"5.1 "]],[18,22],[18,18]]],[1573476165866,["GJX@GJXAIOU",[[1,18,"yi"]],[18,18],[20,20]]],[1573476165886,["GJX@GJXAIOU",[[-1,19,"i"],[1,20," "]],[20,20],[19,19]]],[1573476166050,["GJX@GJXAIOU",[[1,19,"i"]],[19,19],[20,20]]],[1573476166790,["GJX@GJXAIOU",[[-1,18,"yi"]],[20,20],[18,18]]],[1573476168579,["GJX@GJXAIOU",[[1,18,"一、"]],[18,18],[20,20]]],[1573476172163,["GJX@GJXAIOU",[[-1,246,"5.2 "]],[250,250],[246,246]]],[1573476173381,["GJX@GJXAIOU",[[1,246,"二、"]],[246,246],[248,248]]],[1573476178875,["GJX@GJXAIOU",[[-1,436,"5.3 "]],[440,440],[436,436]]],[1573476180181,["GJX@GJXAIOU",[[1,436,"三、"]],[436,436],[438,438]]],[1573476186587,["GJX@GJXAIOU",[[-1,1289,"#### Ø "]],[1289,1296],[1289,1289]]],[1573476191756,["GJX@GJXAIOU",[[1,449,"（）"]],[449,449],[451,451]]],[1573476193548,["GJX@GJXAIOU",[[1,450,"一"]],[450,450],[451,451]]],[1573476196051,["GJX@GJXAIOU",[[1,449,"### "]],[450,450],[478,478]]],[1573476198894,["GJX@GJXAIOU",[[-1,469,"**"]],[471,471],[469,469]]],[1573476201571,["GJX@GJXAIOU",[[-1,471,"如下**"]],[475,475],[471,471]]],[1573476205963,["GJX@GJXAIOU",[[1,1290,"### "]],[1290,1290],[1300,1300]]],[1573476210250,["GJX@GJXAIOU",[[-1,533,"4) "]],[536,536],[533,533]]],[1573476211235,["GJX@GJXAIOU",[[1,533,"\n"]],[533,533],[534,534]]],[1573476212971,["GJX@GJXAIOU",[[-1,533,"\n"]],[534,534],[533,533]]],[1573476214330,["GJX@GJXAIOU",[[-1,538,"\n"]],[538,538],[537,537]]],[1573476218893,["GJX@GJXAIOU",[[1,1290,"（）"]],[1290,1290],[1292,1292]]],[1573476220111,["GJX@GJXAIOU",[[1,1291,"二"]],[1291,1291],[1292,1292]]],[1573476222747,["GJX@GJXAIOU",[[-1,1298,"："]],[1299,1299],[1298,1298]]],[1573476231258,["GJX@GJXAIOU",[[-1,1300,"1) "]],[1300,1303],[1300,1300]]],[1573476231814,["GJX@GJXAIOU",[[1,1300,"- "]],[1300,1300],[1302,1302]]],[1573476236028,["GJX@GJXAIOU",[[-1,1342,"2) "]],[1342,1345],[1342,1342]]],[1573476236700,["GJX@GJXAIOU",[[-1,1341,"\n"]],[1342,1342],[1341,1341]]],[1573476237905,["GJX@GJXAIOU",[[1,1341,"- "]],[1341,1341],[1343,1343]]],[1573476245619,["GJX@GJXAIOU",[[1,1346,"**"],[1,1407,"**"]],[1346,1407],[1346,1411]]],[1573476250571,["GJX@GJXAIOU",[[-1,1412,"\n3)"]],[1412,1415],[1412,1412]]],[1573476250833,["GJX@GJXAIOU",[[1,1412,"-"]],[1412,1412],[1413,1413]]],[1573476251010,["GJX@GJXAIOU",[[1,1414," "]],[1413,1413],[1414,1414]]],[1573476265763,["GJX@GJXAIOU",[[-1,1583,"4)"]],[1583,1585],[1583,1583]]],[1573476266018,["GJX@GJXAIOU",[[1,1583,"-"]],[1583,1583],[1584,1584]]],[1573476266191,["GJX@GJXAIOU",[[1,1585," "]],[1584,1584],[1585,1585]]],[1573476269637,["GJX@GJXAIOU",[[1,1346,"\n"]],[1346,1346],[1347,1347]]],[1573476270129,["GJX@GJXAIOU",[[1,1347,"- "]],[1347,1347],[1349,1349]]],[1573476271179,["GJX@GJXAIOU",[[1,1347,"  "]],[1349,1349],[1351,1351]]],[1573476273170,["GJX@GJXAIOU",[[1,1417,"  "]],[1421,1421],[1423,1423]]],[1573476276834,["GJX@GJXAIOU",[[1,1617,"#"]],[1617,1617],[1633,1633]]],[1573476279796,["GJX@GJXAIOU",[[-1,1619,"5.4 "]],[1619,1623],[1619,1619]]],[1573476282461,["GJX@GJXAIOU",[[1,1619,"二、"]],[1619,1619],[1621,1621]]],[1573476283083,["GJX@GJXAIOU",[[-1,1619,"二、"]],[1621,1621],[1619,1619]]],[1573476285084,["GJX@GJXAIOU",[[1,1619,"四、"]],[1619,1619],[1621,1621]]],[1573476312835,["GJX@GJXAIOU",[[-1,1633,"Ø"]],[1633,1634],[1633,1633]]],[1573476317826,["GJX@GJXAIOU",[[-1,1641,"| \n\npackage com.atguigu.singleton.type2;\n\npublic class SingletonTest02 {\n\npublic static void main(String[] args) {\n\n//测试\n\nSingleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true\n\nSystem.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\n}\n\n}\n\n//饿汉式(静态变量)\n\nclass Singleton {\n\n//1. 构造器私有化, 外部能 new private Singleton() {\n\n}\n\n//2.本类内部创建对象实例\n\n |\n\n| \n\nprivate static Singleton  instance;\n\nstatic { // 在静态代码块中，创建单例对象\n\ninstance = new Singleton();\n\n}\n\n//3. 提供一个公有的静态方法，返回实例对象\n\npublic static Singleton getInstance() { return instance;\n\n}\n\n}\n\n |\n\n"]],[1640,2337],[1640,1640]]],[1573476318506,["GJX@GJXAIOU",[[1,1640,"··"]],[1640,1640],[1642,1642]]],[1573476319463,["GJX@GJXAIOU",[[-1,1640,"··"]],[1642,1642],[1640,1640]]],[1573476320976,["GJX@GJXAIOU",[[1,1640,"```"]],[1640,1640],[1643,1643]]],[1573476321072,["GJX@GJXAIOU",[[1,1643,"language\n```\n"]],[1643,1643],[1643,1651]]],[1573476322084,["GJX@GJXAIOU",[[-1,1643,"language"],[1,1651,"j"]],[1643,1651],[1644,1644]]],[1573476322482,["GJX@GJXAIOU",[[1,1644,"ava"]],[1644,1644],[1647,1647]]],[1573476322643,["GJX@GJXAIOU",[[1,1648,"\n"]],[1647,1647],[1648,1648]]],[1573476325956,["GJX@GJXAIOU",[[1,1648,"package com.atguigu.singleton.type2;\n\npublic class SingletonTest02 {\n\n\tpublic static void main(String[] args) {\n\t\t//测试\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n\n}\n\n//饿汉式(静态变量)\n\nclass Singleton {\n\t\n\t//1. 构造器私有化, 外部能new\n\tprivate Singleton() {\n\t\t\n\t}\n\t\n\n\t//2.本类内部创建对象实例\n\tprivate  static Singleton instance;\n\t\n\tstatic { // 在静态代码块中，创建单例对象\n\t\tinstance = new Singleton();\n\t}\n\t\n\t//3. 提供一个公有的静态方法，返回实例对象\n\tpublic static Singleton getInstance() {\n\t\treturn instance;\n\t}\n\t\n}"]],[1648,1648],[2353,2353]]],[1573476330315,["GJX@GJXAIOU",[[-1,2089,"\t"]],[2090,2090],[2089,2089]]],[1573476331018,["GJX@GJXAIOU",[[-1,2089,"\n"]],[2089,2089],[2088,2088]]],[1573476333259,["GJX@GJXAIOU",[[-1,2070,"\n"]],[2070,2070],[2069,2069]]],[1573476335603,["GJX@GJXAIOU",[[-1,2133,"\t"]],[2133,2133],[2132,2132]]],[1573476336098,["GJX@GJXAIOU",[[-1,2131,"\n"]],[2132,2132],[2131,2131]]],[1573476355458,["GJX@GJXAIOU",[[-1,2354,"Ø "]],[2354,2356],[2354,2354]]],[1573476356251,["GJX@GJXAIOU",[[1,2354,"### "]],[2354,2354],[2364,2364]]],[1573476362373,["GJX@GJXAIOU",[[-1,1617,"#"]],[1617,1617],[1630,1630]]],[1573476379378,["GJX@GJXAIOU",[[-1,2478,"5.5 "]],[2478,2482],[2478,2478]]],[1573476380259,["GJX@GJXAIOU",[[1,2478,"()"]],[2478,2478],[2480,2480]]],[1573476381965,["GJX@GJXAIOU",[[-1,2478,"()"]],[2480,2480],[2478,2478]]],[1573476383174,["GJX@GJXAIOU",[[1,2478,"（0 "]],[2478,2478],[2480,2480]]],[1573476386178,["GJX@GJXAIOU",[[-1,2479,"0"]],[2480,2480],[2479,2479]]],[1573476386621,["GJX@GJXAIOU",[[1,2479,"）"]],[2479,2479],[2480,2480]]],[1573476388150,["GJX@GJXAIOU",[[1,2479,"一"]],[2479,2479],[2480,2480]]],[1573476407458,["GJX@GJXAIOU",[[-1,2503,"| \n\npackage com.atguigu.singleton.type3;\n\npublic class SingletonTest03 {\n\n |\n\n| \n\npublic static void main(String[] args) { System.out.println(\"懒汉式 1 ， 线程不安全~\"); Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true\n\nSystem.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\n}\n\n}\n\nclass Singleton {\n\nprivate static Singleton instance;\n\nprivate Singleton() {}\n\n//提供一个静态的公有方法，当使用到该方法时，才去创建 instance\n\n//即懒汉式\n\npublic static Singleton getInstance() { if(instance == null) {\n\ninstance = new Singleton();\n\n}\n\nreturn instance;\n\n}\n\n}\n\n |\n\n"]],[2502,3194],[2502,2502]]],[1573476408446,["GJX@GJXAIOU",[[1,2502,"···"]],[2502,2502],[2505,2505]]],[1573476410044,["GJX@GJXAIOU",[[-1,2502,"···"]],[2505,2505],[2502,2502]]],[1573476411574,["GJX@GJXAIOU",[[1,2502,"```"]],[2502,2502],[2505,2505]]],[1573476411660,["GJX@GJXAIOU",[[1,2505,"language\n```\n"]],[2505,2505],[2505,2513]]],[1573476413588,["GJX@GJXAIOU",[[-1,2505,"language"],[1,2513,"j"]],[2505,2513],[2506,2506]]],[1573476414076,["GJX@GJXAIOU",[[1,2506,"ava"]],[2506,2506],[2509,2509]]],[1573476414178,["GJX@GJXAIOU",[[1,2510,"\n"]],[2509,2509],[2510,2510]]],[1573476417295,["GJX@GJXAIOU",[[1,2510,"package com.atguigu.singleton.type3;\n\n\npublic class SingletonTest03 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"懒汉式1 ， 线程不安全~\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n\n}\n\nclass Singleton {\n\tprivate static Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\t//提供一个静态的公有方法，当使用到该方法时，才去创建 instance\n\t//即懒汉式\n\tpublic static Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}"]],[2510,2510],[3205,3205]]],[1573476448874,["GJX@GJXAIOU",[[-1,3211,"Ø "]],[3211,3213],[3211,3211]]],[1573476449371,["GJX@GJXAIOU",[[1,3211,"- "]],[3211,3211],[3213,3213]]],[1573476452394,["GJX@GJXAIOU",[[-1,3221,"1)"]],[3221,3223],[3221,3221]]],[1573476452718,["GJX@GJXAIOU",[[1,3221,"-"]],[3221,3221],[3222,3222]]],[1573476452967,["GJX@GJXAIOU",[[1,3223," "]],[3222,3222],[3223,3223]]],[1573476455339,["GJX@GJXAIOU",[[-1,3211,"- "]],[3211,3213],[3211,3211]]],[1573476455716,["GJX@GJXAIOU",[[1,3211,"### "]],[3211,3211],[3221,3221]]],[1573476459340,["GJX@GJXAIOU",[[-1,3265,"2) "]],[3265,3268],[3265,3265]]],[1573476459796,["GJX@GJXAIOU",[[1,3265,"- "]],[3265,3265],[3267,3267]]],[1573476465514,["GJX@GJXAIOU",[[-1,3370,"\n3) "]],[3370,3374],[3370,3370]]],[1573476466805,["GJX@GJXAIOU",[[1,3370,"- "]],[3370,3370],[3372,3372]]],[1573476489372,["GJX@GJXAIOU",[[-1,3429,"| \n\npackage com.atguigu.singleton.type4;\n\npublic class SingletonTest04 {\n\npublic static void main(String[] args) { System.out.println(\"懒汉式 2 ， 线程安全~\"); Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true\n\nSystem.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\n}\n\n}\n\n |\n\n| \n\n// 懒汉式(线程安全，同步方法) class Singleton {\n\nprivate static Singleton instance;\n\nprivate Singleton() {}\n\n//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题\n\n//即懒汉式\n\npublic static **synchronized** Singleton getInstance() { if(instance == null) {\n\ninstance = new Singleton();\n\n}\n\nreturn instance;\n\n}\n\n}\n\n |\n"]],[3429,4150],[3429,3429]]],[1573476497284,["GJX@GJXAIOU",[[1,3429,"```"]],[3429,3429],[3432,3432]]],[1573476497379,["GJX@GJXAIOU",[[1,3432,"language\n```\n"]],[3432,3432],[3432,3440]]],[1573476498837,["GJX@GJXAIOU",[[-1,3432,"language"],[1,3440,"j"]],[3432,3440],[3433,3433]]],[1573476499264,["GJX@GJXAIOU",[[1,3433,"ava"]],[3433,3433],[3436,3436]]],[1573476499461,["GJX@GJXAIOU",[[1,3437,"\n"]],[3436,3436],[3437,3437]]],[1573476502040,["GJX@GJXAIOU",[[1,3437,"package com.atguigu.singleton.type4;\n\n\npublic class SingletonTest04 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"懒汉式2 ， 线程安全~\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n\n}\n\n// 懒汉式(线程安全，同步方法)\nclass Singleton {\n\tprivate static Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\t//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题\n\t//即懒汉式\n\tpublic static synchronized Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}"]],[3437,3437],[4158,4158]]],[1573476504308,["GJX@GJXAIOU",[[-1,3475,"\n"]],[3475,3475],[3474,3474]]],[1573476506170,["GJX@GJXAIOU",[[-1,3874,"\n"]],[3874,3874],[3873,3873]]],[1573476560763,["GJX@GJXAIOU",[[-1,4172,"1) "]],[4172,4175],[4172,4172]]],[1573476561178,["GJX@GJXAIOU",[[1,4172,"- "]],[4172,4172],[4174,4174]]],[1573476563538,["GJX@GJXAIOU",[[-1,4162,"Ø "]],[4162,4164],[4162,4162]]],[1573476564363,["GJX@GJXAIOU",[[1,4162,"### "]],[4162,4162],[4172,4172]]],[1573476567139,["GJX@GJXAIOU",[[-1,4191,"2) "]],[4191,4194],[4191,4191]]],[1573476567958,["GJX@GJXAIOU",[[1,4191,"- "]],[4191,4191],[4193,4193]]],[1573476570059,["GJX@GJXAIOU",[[-1,4301,"3) "]],[4301,4304],[4301,4301]]],[1573476570545,["GJX@GJXAIOU",[[1,4301,"- "]],[4301,4301],[4303,4303]]],[1573476585258,["GJX@GJXAIOU",[[-1,4331,"5.7 "]],[4331,4335],[4331,4331]]],[1573476585917,["GJX@GJXAIOU",[[1,4331,"()"]],[4331,4331],[4333,4333]]],[1573476587211,["GJX@GJXAIOU",[[-1,4331,"()"]],[4333,4333],[4331,4331]]],[1573476587851,["GJX@GJXAIOU",[[1,4331,"()"]],[4331,4331],[4333,4333]]],[1573476589288,["GJX@GJXAIOU",[[-1,4331,"()"]],[4333,4333],[4331,4331]]],[1573476590025,["GJX@GJXAIOU",[[1,4331,"()"]],[4331,4331],[4333,4333]]],[1573476591240,["GJX@GJXAIOU",[[-1,4330," ()"]],[4333,4333],[4330,4330]]],[1573476594344,["GJX@GJXAIOU",[[1,4330," （）"]],[4330,4330],[4333,4333]]],[1573476596338,["GJX@GJXAIOU",[[1,4332,"其"]],[4332,4332],[4333,4333]]],[1573476597397,["GJX@GJXAIOU",[[-1,4331,"（其"]],[4333,4333],[4331,4331]]],[1573476599806,["GJX@GJXAIOU",[[1,4331,"七"]],[4331,4331],[4332,4332]]],[1573476602693,["GJX@GJXAIOU",[[1,4331,"（"]],[4331,4331],[4332,4332]]],[1573476616475,["GJX@GJXAIOU",[[-1,4361,"5.8"]],[4361,4364],[4361,4361]]],[1573476617051,["GJX@GJXAIOU",[[1,4361,"（）"]],[4361,4361],[4363,4363]]],[1573476619847,["GJX@GJXAIOU",[[1,4362,"八"]],[4362,4362],[4363,4363]]],[1573476658891,["GJX@GJXAIOU",[[-1,4379,"| \n\npackage com.atguigu.singleton.type6;\n\npublic class SingletonTest06 {\n\npublic static void main(String[] args) { System.out.println(\"双重检查\");\n\nSingleton instance = Singleton.getInstance();\n\nSingleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\n |\n\n| \n\n}\n\n}\n\n// 懒汉式(线程安全，同步方法) class Singleton {\n\nprivate static volatile Singleton instance;\n\nprivate Singleton() {}\n\n//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题\n\n//同时保证了效率, 推荐使用\n\npublic static synchronized Singleton getInstance() { if(instance == null) {\n\nsynchronized (Singleton.class) { if(instance == null) {\n\ninstance = new Singleton();\n\n}\n\n}\n\n}\n\nreturn instance;\n\n}\n\n}\n\n |\n\n"]],[4378,5179],[4378,4378]]],[1573476659438,["GJX@GJXAIOU",[[1,4378,"··"]],[4378,4378],[4380,4380]]],[1573476660346,["GJX@GJXAIOU",[[-1,4378,"··"]],[4380,4380],[4378,4378]]],[1573476661732,["GJX@GJXAIOU",[[1,4378,"```"]],[4378,4378],[4381,4381]]],[1573476661825,["GJX@GJXAIOU",[[1,4381,"language\n```\n"]],[4381,4381],[4381,4389]]],[1573476662404,["GJX@GJXAIOU",[[-1,4381,"language"],[1,4389,"j"]],[4381,4389],[4382,4382]]],[1573476662828,["GJX@GJXAIOU",[[1,4382,"ava"]],[4382,4382],[4385,4385]]],[1573476663005,["GJX@GJXAIOU",[[1,4386,"\n"]],[4385,4385],[4386,4386]]],[1573476669567,["GJX@GJXAIOU",[[1,4386,"package com.atguigu.singleton.type6;\n\n\npublic class SingletonTest06 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"双重检查\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t\t\n\t}\n\n}\n\n// 懒汉式(线程安全，同步方法)\nclass Singleton {\n\tprivate static volatile Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\t//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题\n\t//同时保证了效率, 推荐使用\n\t\n\tpublic static synchronized Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tsynchronized (Singleton.class) {\n\t\t\t\tif(instance == null) {\n\t\t\t\t\tinstance = new Singleton();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn instance;\n\t}\n}"]],[4386,4386],[5212,5212]]],[1573476674860,["GJX@GJXAIOU",[[-1,5218,"Ø "]],[5218,5220],[5218,5218]]],[1573476675227,["GJX@GJXAIOU",[[1,5218,"### "]],[5218,5218],[5228,5228]]],[1573476678171,["GJX@GJXAIOU",[[-1,5230,"1) "]],[5230,5233],[5230,5230]]],[1573476678616,["GJX@GJXAIOU",[[1,5230,"- "]],[5230,5230],[5232,5232]]],[1573476682875,["GJX@GJXAIOU",[[-1,5315,"2)"]],[5315,5317],[5315,5315]]],[1573476683111,["GJX@GJXAIOU",[[1,5315,"-"]],[5315,5315],[5316,5316]]],[1573476683332,["GJX@GJXAIOU",[[1,5317," "]],[5316,5316],[5317,5317]]],[1573476687226,["GJX@GJXAIOU",[[-1,5398,"#### 3)"]],[5398,5405],[5398,5398]]],[1573476687445,["GJX@GJXAIOU",[[1,5398,"-"]],[5398,5398],[5399,5399]]],[1573476690955,["GJX@GJXAIOU",[[-1,5416,"4) "]],[5416,5419],[5416,5416]]],[1573476691804,["GJX@GJXAIOU",[[1,5416,"- "]],[5416,5416],[5418,5418]]],[1573476727147,["GJX@GJXAIOU",[[-1,5469,"| \n\npackage com.atguigu.singleton.type7;\n\npublic class SingletonTest07 {\n\npublic static void main(String[] args) { System.out.println(\"使用静态内部类完成单例模式\"); Singleton instance = Singleton.getInstance();\n\nSingleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(\"instance.hashCode=\" + instance.hashCode()); System.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\n}\n\n |\n\n| \n\n}\n\n// 静态内部类完成， 推荐使用\n\nclass Singleton {\n\nprivate static volatile Singleton instance;\n\n//构造器私有化private Singleton() {}\n\n//写一个静态内部类,该类中有一个静态属性 Singleton private static class SingletonInstance {\n\nprivate static final Singleton INSTANCE = new Singleton();\n\n}\n\n//提供一个静态的公有方法，直接返回 SingletonInstance.INSTANCE\n\npublic static synchronized Singleton getInstance() {\n\nreturn SingletonInstance.INSTANCE;\n\n}\n\n}\n\n |\n"]],[5469,6308],[5469,5469]]],[1573476728042,["GJX@GJXAIOU",[[1,5469,"```"]],[5469,5469],[5472,5472]]],[1573476728141,["GJX@GJXAIOU",[[1,5472,"language\n```\n"]],[5472,5472],[5472,5480]]],[1573476729109,["GJX@GJXAIOU",[[-1,5472,"language"],[1,5480,"j"]],[5472,5480],[5473,5473]]],[1573476729613,["GJX@GJXAIOU",[[1,5473,"ava"]],[5473,5473],[5476,5476]]],[1573476729681,["GJX@GJXAIOU",[[1,5477,"\n"]],[5476,5476],[5477,5477]]],[1573476732375,["GJX@GJXAIOU",[[1,5477,"package com.atguigu.singleton.type7;\n\n\npublic class SingletonTest07 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"使用静态内部类完成单例模式\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t\t\n\t}\n\n}\n\n// 静态内部类完成， 推荐使用\nclass Singleton {\n\tprivate static volatile Singleton instance;\n\t\n\t//构造器私有化\n\tprivate Singleton() {}\n\t\n\t//写一个静态内部类,该类中有一个静态属性 Singleton\n\tprivate static class SingletonInstance {\n\t\tprivate static final Singleton INSTANCE = new Singleton(); \n\t}\n\t\n\t//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE\n\t\n\tpublic static synchronized Singleton getInstance() {\n\t\t\n\t\treturn SingletonInstance.INSTANCE;\n\t}\n}"]],[5477,5477],[6329,6329]]],[1573476737436,["GJX@GJXAIOU",[[-1,6335,"Ø "]],[6335,6337],[6335,6335]]],[1573476738028,["GJX@GJXAIOU",[[1,6335,"### "]],[6335,6335],[6345,6345]]],[1573476741404,["GJX@GJXAIOU",[[-1,5460,"Ø"]],[5460,5461],[5460,5460]]],[1573476742483,["GJX@GJXAIOU",[[1,5460,"### "]],[5460,5460],[5470,5470]]],[1573476749115,["GJX@GJXAIOU",[[-1,5449,"5.9 "]],[5449,5453],[5449,5449]]],[1573476749646,["GJX@GJXAIOU",[[1,5449,"ji"]],[5449,5449],[5451,5451]]],[1573476749669,["GJX@GJXAIOU",[[-1,5450,"i"],[1,5451," "]],[5451,5451],[5450,5450]]],[1573476749832,["GJX@GJXAIOU",[[1,5450,"u"]],[5450,5450],[5451,5451]]],[1573476749900,["GJX@GJXAIOU",[[-1,5450,"u"],[1,5451,"i"]],[5451,5451],[5451,5451]]],[1573476750690,["GJX@GJXAIOU",[[-1,5449,"ji"]],[5451,5451],[5449,5449]]],[1573476753144,["GJX@GJXAIOU",[[1,5449,"九、"]],[5449,5449],[5451,5451]]],[1573476754706,["GJX@GJXAIOU",[[-1,5451," "]],[5452,5452],[5451,5451]]],[1573476760194,["GJX@GJXAIOU",[[-1,4331,"（七）"]],[4332,4334],[4331,4331]]],[1573476761550,["GJX@GJXAIOU",[[1,4331,"七、"]],[4331,4331],[4333,4333]]],[1573476764642,["GJX@GJXAIOU",[[-1,4360,"（八） "]],[4364,4364],[4360,4360]]],[1573476766796,["GJX@GJXAIOU",[[1,4360,"八、"]],[4360,4360],[4362,4362]]],[1573476772474,["GJX@GJXAIOU",[[-1,6345,"1)"]],[6345,6347],[6345,6345]]],[1573476772711,["GJX@GJXAIOU",[[1,6345,"-"]],[6345,6345],[6346,6346]]],[1573476773410,["GJX@GJXAIOU",[[-1,6345,"-"]],[6346,6346],[6345,6345]]],[1573476774397,["GJX@GJXAIOU",[[1,6345,"-"]],[6345,6345],[6346,6346]]],[1573476774568,["GJX@GJXAIOU",[[1,6347," "]],[6346,6346],[6347,6347]]],[1573476776802,["GJX@GJXAIOU",[[-1,6379,"2) "]],[6379,6382],[6379,6379]]],[1573476777216,["GJX@GJXAIOU",[[1,6379,"- "]],[6379,6379],[6381,6381]]],[1573476779411,["GJX@GJXAIOU",[[-1,6489,"3) "]],[6489,6492],[6489,6489]]],[1573476779859,["GJX@GJXAIOU",[[1,6489,"- "]],[6489,6489],[6491,6491]]],[1573476783545,["GJX@GJXAIOU",[[-1,6560,"#### 4) "]],[6560,6568],[6560,6560]]],[1573476784008,["GJX@GJXAIOU",[[1,6560,"- "]],[6560,6560],[6562,6562]]],[1573476786001,["GJX@GJXAIOU",[[-1,6595,"5)"]],[6595,6597],[6595,6595]]],[1573476786216,["GJX@GJXAIOU",[[1,6595,"-"]],[6595,6595],[6596,6596]]],[1573476801668,["GJX@GJXAIOU",[[-1,6631,"| \n\npackage com.atguigu.singleton.type8;\n\npublic class SingletonTest08 {\n\npublic static void main(String[] args) { Singleton instance =  Singleton.INSTANCE;\n\nSingleton instance2 =  Singleton.INSTANCE; System.out.println(instance ==  instance2);\n\nSystem.out.println(instance.hashCode()); System.out.println(instance2.hashCode());\n\ninstance.sayOK();\n\n}\n\n}\n\n//使用枚举，可以实现单例, 推荐\n\nenum Singleton {\n\n |\n\n| \n\nINSTANCE; //属性public void sayOK() {\n\nSystem.out.println(\"ok~\");\n\n}\n\n}\n\n |\n"]],[6631,7105],[6631,6631]]],[1573476802842,["GJX@GJXAIOU",[[1,6631,"···"]],[6631,6631],[6634,6634]]],[1573476803835,["GJX@GJXAIOU",[[-1,6631,"···"]],[6634,6634],[6631,6631]]],[1573476804258,["GJX@GJXAIOU",[[-1,6631,"\n"]],[6631,6631],[6630,6630]]],[1573476805616,["GJX@GJXAIOU",[[1,6630,"```"]],[6630,6630],[6633,6633]]],[1573476805708,["GJX@GJXAIOU",[[1,6633,"language\n```\n"]],[6633,6633],[6633,6641]]],[1573476806030,["GJX@GJXAIOU",[[-1,6633,"language"],[1,6641,"j"]],[6633,6641],[6634,6634]]],[1573476806558,["GJX@GJXAIOU",[[1,6634,"ava"]],[6634,6634],[6637,6637]]],[1573476806620,["GJX@GJXAIOU",[[1,6638,"\n"]],[6637,6637],[6638,6638]]],[1573476809539,["GJX@GJXAIOU",[[1,6638,"package com.atguigu.singleton.type8;\n\npublic class SingletonTest08 {\n\tpublic static void main(String[] args) {\n\t\tSingleton instance = Singleton.INSTANCE;\n\t\tSingleton instance2 = Singleton.INSTANCE;\n\t\tSystem.out.println(instance == instance2);\n\t\t\n\t\tSystem.out.println(instance.hashCode());\n\t\tSystem.out.println(instance2.hashCode());\n\t\t\n\t\tinstance.sayOK();\n\t}\n}\n\n//使用枚举，可以实现单例, 推荐\nenum Singleton {\n\tINSTANCE; //属性\n\tpublic void sayOK() {\n\t\tSystem.out.println(\"ok~\");\n\t}\n}"]],[6638,6638],[7107,7107]]],[1573476813108,["GJX@GJXAIOU",[[-1,7113,"Ø "]],[7113,7115],[7113,7113]]],[1573476813555,["GJX@GJXAIOU",[[1,7113,"### "]],[7113,7113],[7123,7123]]],[1573476816114,["GJX@GJXAIOU",[[-1,6623,"Ø "]],[6623,6625],[6623,6623]]],[1573476816857,["GJX@GJXAIOU",[[1,6623,"### "]],[6623,6623],[6631,6631]]],[1573476821981,["GJX@GJXAIOU",[[1,7268,"\n"]],[7268,7268],[7269,7269]]],[1573476825921,["GJX@GJXAIOU",[[-1,6614,"5.10 "]],[6614,6619],[6614,6614]]],[1573476826445,["GJX@GJXAIOU",[[1,6614,"sh"]],[6614,6614],[6616,6616]]],[1573476826466,["GJX@GJXAIOU",[[-1,6615,"h"],[1,6616," "]],[6616,6616],[6615,6615]]],[1573476826610,["GJX@GJXAIOU",[[1,6615,"i"]],[6615,6615],[6616,6616]]],[1573476826679,["GJX@GJXAIOU",[[-1,6615,"i"],[1,6616,"h"]],[6616,6616],[6616,6616]]],[1573476827248,["GJX@GJXAIOU",[[-1,6614,"sh"]],[6616,6616],[6614,6614]]],[1573476831862,["GJX@GJXAIOU",[[1,6614,"十、"]],[6614,6614],[6616,6616]]],[1573476833378,["GJX@GJXAIOU",[[-1,6616," "]],[6617,6617],[6616,6616]]],[1573476838700,["GJX@GJXAIOU",[[-1,7269,"5.11 "]],[7269,7274],[7269,7269]]],[1573476840486,["GJX@GJXAIOU",[[1,7269,"十一、"]],[7269,7269],[7272,7272]]],[1573476845266,["GJX@GJXAIOU",[[-1,7294," 5.11.1 "]],[7294,7302],[7294,7294]]],[1573476846149,["GJX@GJXAIOU",[[1,7294,"（）"]],[7294,7294],[7296,7296]]],[1573476848200,["GJX@GJXAIOU",[[1,7295,"一"]],[7295,7295],[7296,7296]]],[1573476850670,["GJX@GJXAIOU",[[1,7294," "]],[7294,7294],[7295,7295]]],[1573476854324,["GJX@GJXAIOU",[[-1,7388,"5.12 "]],[7388,7393],[7388,7388]]],[1573476854886,["GJX@GJXAIOU",[[1,7388,"（）"]],[7388,7388],[7390,7390]]],[1573476856079,["GJX@GJXAIOU",[[1,7389,"二"]],[7389,7389],[7390,7390]]]],null,"GJX@GJXAIOU"],["ba5b97d2-3584-4ff6-8436-3860909bb4b2",1573561185829,"# 第五章：单例设计模式\n\n\n## 一、 单例设计模式介绍\n\n所谓类的单例设计模式，就是**采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例**， 并且该类只提供一个取得其对象实例的方法(静态方法)。\n\n比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。\n\n## 二、单例设计模式八种方式\n\n单例模式有八种方式：\n\n**1)** **饿汉式(静态常量)**\n\n**2)** **饿汉式（静态代码块）**\n\n**3)** 懒汉式(线程不安全)\n\n**4)** 懒汉式(线程安全，同步方法)\n\n**5)** 懒汉式(线程安全，同步代码块)\n\n**6)** **双重检查**\n\n**7)** **静态内部类**\n\n**8)** **枚举**\n\n## 三、饿汉式（静态常量）\n\n### （一）饿汉式（静态常量）应用实例步骤：\n\n- 构造器私有化 (防止 new )\n- 类的内部创建对象\n- 向外暴露一个静态的公共方法。getInstance\n\n代码实现\n```java\npackage com.gjxaiou.singleton.type1;\n\npublic class SingletonTest01 {\n\n\tpublic static void main(String[] args) {\n\t\t//测试\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n\n}\n\n//饿汉式(静态变量)\nclass Singleton {\n\t//1. 构造器私有化, 外部能new\n\tprivate Singleton() {\t\t\n\t}\n\t\n\t//2.本类内部创建对象实例\n\tprivate final static Singleton instance = new Singleton();\n\t\n\t//3. 提供一个公有的静态方法，返回实例对象\n\tpublic static Singleton getInstance() {\n\t\treturn instance;\n\t}\t\n}\n\n// output:\ntrue\ninstance.hashCode=325040804\ninstance2.hashCode=325040804\n```\n\n\n### （二）优缺点说明\n\n- 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。\n- 缺点：\n  - **在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费**\n  -  这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法， 但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果\n\n-  结论：这种单例模式可用，可能造成内存浪费\n\n## 四、饿汉式（静态代码块）\n\n 代码演示：\n```java\npackage com.atguigu.singleton.type2;\n\npublic class SingletonTest02 {\n\n\tpublic static void main(String[] args) {\n\t\t//测试\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n\n}\n\n//饿汉式(静态变量)\nclass Singleton {\n\t//1. 构造器私有化, 外部能new\n\tprivate Singleton() {\t\n\t}\n\t\n\n\t//2.本类内部创建对象实例\n\tprivate  static Singleton instance;\n\t\n\tstatic { // 在静态代码块中，创建单例对象\n\t\tinstance = new Singleton();\n\t}\n\t\n\t//3. 提供一个公有的静态方法，返回实例对象\n\tpublic static Singleton getInstance() {\n\t\treturn instance;\n\t}\n\t\n}\n```\n\n### 优缺点说明：\n\n1) 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。\n\n2) 结论：这种单例模式可用，但是可能造成内存浪费\n\n## （一） 懒汉式(线程不安全)\n\nØ 代码演示：\n```java\npackage com.atguigu.singleton.type3;\n\n\npublic class SingletonTest03 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"懒汉式1 ， 线程不安全~\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n\n}\n\nclass Singleton {\n\tprivate static Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\t//提供一个静态的公有方法，当使用到该方法时，才去创建 instance\n\t//即懒汉式\n\tpublic static Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n### 优缺点说明：\n\n-  起到了 **Lazy Loading** 的效果，但是只能在单线程下使用。\n\n- 如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会**产生多个实例**。所以在多线程环境下不可使用这种方式\n- 结论：在实际开发中，**不要使用**这种方式.\n\n## 5.6 懒汉式(线程安全，同步方法)\n\nØ 代码演示：\n\n```java\npackage com.atguigu.singleton.type4;\n\npublic class SingletonTest04 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"懒汉式2 ， 线程安全~\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n}\n\n// 懒汉式(线程安全，同步方法)\nclass Singleton {\n\tprivate static Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\t//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题\n\t//即懒汉式\n\tpublic static synchronized Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n### 优缺点说明：\n\n- 解决了**线程安全**问题\n\n- 效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。**方法进行同步效率太**低\n\n- 结论：在实际开发中，**不推荐**使用这种方式\n\n## 七、懒汉式(线程安全，同步代码块)\n\n不推荐使用\n\n## 八、双重检查\n\nØ 代码演示\n```java\npackage com.atguigu.singleton.type6;\n\n\npublic class SingletonTest06 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"双重检查\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t\t\n\t}\n\n}\n\n// 懒汉式(线程安全，同步方法)\nclass Singleton {\n\tprivate static volatile Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\t//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题\n\t//同时保证了效率, 推荐使用\n\t\n\tpublic static synchronized Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tsynchronized (Singleton.class) {\n\t\t\t\tif(instance == null) {\n\t\t\t\t\tinstance = new Singleton();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n### 优缺点说明：\n\n- Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这样就可以保证线程安全了。\n\n-  这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象，也避免的反复进行方法同步.\n\n- 线程安全；延迟加载；效率较高\n\n- 结论：在实际开发中，**推荐使用这种单例设计模**式\n\n## 九、静态内部类\n\n###  代码演示：\n\n```java\npackage com.atguigu.singleton.type7;\n\n\npublic class SingletonTest07 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"使用静态内部类完成单例模式\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t\t\n\t}\n\n}\n\n// 静态内部类完成， 推荐使用\nclass Singleton {\n\tprivate static volatile Singleton instance;\n\t\n\t//构造器私有化\n\tprivate Singleton() {}\n\t\n\t//写一个静态内部类,该类中有一个静态属性 Singleton\n\tprivate static class SingletonInstance {\n\t\tprivate static final Singleton INSTANCE = new Singleton(); \n\t}\n\t\n\t//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE\n\t\n\tpublic static synchronized Singleton getInstance() {\n\t\t\n\t\treturn SingletonInstance.INSTANCE;\n\t}\n}\n```\n\n### 优缺点说明：\n\n-  这种方式采用了类装载的机制来保证初始化实例时只有一个线程。\n\n- 静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。\n\n- 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM  帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。\n\n- 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高\n\n- 结论：**推荐**使用.\n\n## 十、枚举\n\n### 代码演示\n```java\npackage com.atguigu.singleton.type8;\n\npublic class SingletonTest08 {\n\tpublic static void main(String[] args) {\n\t\tSingleton instance = Singleton.INSTANCE;\n\t\tSingleton instance2 = Singleton.INSTANCE;\n\t\tSystem.out.println(instance == instance2);\n\t\t\n\t\tSystem.out.println(instance.hashCode());\n\t\tSystem.out.println(instance2.hashCode());\n\t\t\n\t\tinstance.sayOK();\n\t}\n}\n\n//使用枚举，可以实现单例, 推荐\nenum Singleton {\n\tINSTANCE; //属性\n\tpublic void sayOK() {\n\t\tSystem.out.println(\"ok~\");\n\t}\n}\n```\n\n### 优缺点说明：\n\n1) 这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。\n\n2) 这种方式是 **Effective  Java** **作者** **Josh  Bloch** **提倡**的方式\n\n3) 结论：**推荐**使用\n\n\n## 十一、单例模式在 JDK 应用的源码分析\n\n### （一）单例模式在JDK 应用的源码分析\n\n1) 我们 JDK 中，java.lang.Runtime 就是经典的单例模式(饿汉式)\n\n2) 代码分析+Debug 源码+代码说明\n\n## （二）单例模式注意事项和细节说明\n\n1) 单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能\n\n2) 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new\n\n3) 单例模式**使用的场景**：需要**频繁的进行创建和销毁的对象**、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、**工具类对象**、频繁访问数据库或文件的对象(比如**数据源、****session** **工厂**等)\n",[[1573561137105,["GJX@GJXAIOU",[[1,6558,"()"]],[6558,6558],[6560,6560]]],[1573561138730,["GJX@GJXAIOU",[[-1,6558,"()"]],[6560,6560],[6558,6558]]],[1573561139316,["GJX@GJXAIOU",[[1,6558,"（）"]],[6558,6558],[6560,6560]]],[1573561141259,["GJX@GJXAIOU",[[1,6559,"类"]],[6559,6559],[6560,6560]]],[1573561141688,["GJX@GJXAIOU",[[-1,6559,"类"]],[6560,6560],[6559,6559]]],[1573561153675,["GJX@GJXAIOU",[[1,6559,"装载类的时候是安全的"]],[6559,6559],[6569,6569]]],[1573561689821,["GJX@GJXAIOU",[[-1,7224,"** **"]],[7229,7229],[7224,7224]]],[1573561695278,["GJX@GJXAIOU",[[-1,7226,"** **"]],[7231,7231],[7226,7226]]],[1573561698759,["GJX@GJXAIOU",[[1,7224," "]],[7224,7224],[7225,7225]]],[1573561700039,["GJX@GJXAIOU",[[1,7227," "]],[7227,7227],[7228,7228]]],[1573561705204,["GJX@GJXAIOU",[[-1,7239,"** **"]],[7244,7244],[7239,7239]]],[1573561705735,["GJX@GJXAIOU",[[1,7239," "]],[7239,7239],[7240,7240]]],[1573561713316,["GJX@GJXAIOU",[[-1,7634,"** **"]],[7634,7639],[7634,7634]]],[1573561713737,["GJX@GJXAIOU",[[1,7634," "]],[7634,7634],[7635,7635]]],[1573561716772,["GJX@GJXAIOU",[[-1,7623,"****"]],[7627,7627],[7623,7623]]]],null,"GJX@GJXAIOU"],["932d06ac-fe11-48aa-9b81-19fa1397f262",1573826385365,"# 第五章：单例设计模式\n\n\n## 一、 单例设计模式介绍\n\n所谓类的单例设计模式，就是**采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例**， 并且该类只提供一个取得其对象实例的方法(静态方法)。\n\n比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。\n\n## 二、单例设计模式八种方式\n\n单例模式有八种方式：\n\n**1)** **饿汉式(静态常量)**\n\n**2)** **饿汉式（静态代码块）**\n\n**3)** 懒汉式(线程不安全)\n\n**4)** 懒汉式(线程安全，同步方法)\n\n**5)** 懒汉式(线程安全，同步代码块)\n\n**6)** **双重检查**\n\n**7)** **静态内部类**\n\n**8)** **枚举**\n\n## 三、饿汉式（静态常量）\n\n### （一）饿汉式（静态常量）应用实例步骤：\n\n- 构造器私有化 (防止 new )\n- 类的内部创建对象\n- 向外暴露一个静态的公共方法。getInstance\n\n代码实现\n```java\npackage com.gjxaiou.singleton.type1;\n\npublic class SingletonTest01 {\n\n\tpublic static void main(String[] args) {\n\t\t//测试\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n\n}\n\n//饿汉式(静态变量)\nclass Singleton {\n\t//1. 构造器私有化, 外部能new\n\tprivate Singleton() {\t\t\n\t}\n\t\n\t//2.本类内部创建对象实例\n\tprivate final static Singleton instance = new Singleton();\n\t\n\t//3. 提供一个公有的静态方法，返回实例对象\n\tpublic static Singleton getInstance() {\n\t\treturn instance;\n\t}\t\n}\n\n// output:\ntrue\ninstance.hashCode=325040804\ninstance2.hashCode=325040804\n```\n\n\n### （二）优缺点说明\n\n- 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。\n- 缺点：\n  - **在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费**\n  -  这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法， 但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果\n\n-  结论：这种单例模式可用，可能造成内存浪费\n\n## 四、饿汉式（静态代码块）\n\n 代码演示：\n```java\npackage com.atguigu.singleton.type2;\n\npublic class SingletonTest02 {\n\n\tpublic static void main(String[] args) {\n\t\t//测试\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n\n}\n\n//饿汉式(静态变量)\nclass Singleton {\n\t//1. 构造器私有化, 外部能new\n\tprivate Singleton() {\t\n\t}\n\t\n\n\t//2.本类内部创建对象实例\n\tprivate  static Singleton instance;\n\t\n\tstatic { // 在静态代码块中，创建单例对象\n\t\tinstance = new Singleton();\n\t}\n\t\n\t//3. 提供一个公有的静态方法，返回实例对象\n\tpublic static Singleton getInstance() {\n\t\treturn instance;\n\t}\n\t\n}\n```\n\n### 优缺点说明：\n\n1) 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。\n\n2) 结论：这种单例模式可用，但是可能造成内存浪费\n\n## （一） 懒汉式(线程不安全)\n\nØ 代码演示：\n```java\npackage com.atguigu.singleton.type3;\n\n\npublic class SingletonTest03 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"懒汉式1 ， 线程不安全~\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n\n}\n\nclass Singleton {\n\tprivate static Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\t//提供一个静态的公有方法，当使用到该方法时，才去创建 instance\n\t//即懒汉式\n\tpublic static Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n### 优缺点说明：\n\n-  起到了 **Lazy Loading** 的效果，但是只能在单线程下使用。\n\n- 如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会**产生多个实例**。所以在多线程环境下不可使用这种方式\n- 结论：在实际开发中，**不要使用**这种方式.\n\n## 5.6 懒汉式(线程安全，同步方法)\n\nØ 代码演示：\n\n```java\npackage com.atguigu.singleton.type4;\n\npublic class SingletonTest04 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"懒汉式2 ， 线程安全~\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n}\n\n// 懒汉式(线程安全，同步方法)\nclass Singleton {\n\tprivate static Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\t//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题\n\t//即懒汉式\n\tpublic static synchronized Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n### 优缺点说明：\n\n- 解决了**线程安全**问题\n\n- 效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。**方法进行同步效率太**低\n\n- 结论：在实际开发中，**不推荐**使用这种方式\n\n## 七、懒汉式(线程安全，同步代码块)\n\n不推荐使用\n\n## 八、双重检查\n\nØ 代码演示\n```java\npackage com.atguigu.singleton.type6;\n\n\npublic class SingletonTest06 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"双重检查\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t\t\n\t}\n\n}\n\n// 懒汉式(线程安全，同步方法)\nclass Singleton {\n\tprivate static volatile Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\t//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题\n\t//同时保证了效率, 推荐使用\n\t\n\tpublic static synchronized Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tsynchronized (Singleton.class) {\n\t\t\t\tif(instance == null) {\n\t\t\t\t\tinstance = new Singleton();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n### 优缺点说明：\n\n- Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这样就可以保证线程安全了。\n\n-  这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象，也避免的反复进行方法同步.\n\n- 线程安全；延迟加载；效率较高\n\n- 结论：在实际开发中，**推荐使用这种单例设计模**式\n\n## 九、静态内部类\n\n###  代码演示：\n\n```java\npackage com.atguigu.singleton.type7;\n\n\npublic class SingletonTest07 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"使用静态内部类完成单例模式\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t\t\n\t}\n\n}\n\n// 静态内部类完成， 推荐使用\nclass Singleton {\n\tprivate static volatile Singleton instance;\n\t\n\t//构造器私有化\n\tprivate Singleton() {}\n\t\n\t//写一个静态内部类,该类中有一个静态属性 Singleton\n\tprivate static class SingletonInstance {\n\t\tprivate static final Singleton INSTANCE = new Singleton(); \n\t}\n\t\n\t//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE\n\t\n\tpublic static synchronized Singleton getInstance() {\n\t\t\n\t\treturn SingletonInstance.INSTANCE;\n\t}\n}\n```\n\n### 优缺点说明：\n\n-  这种方式采用了类装载的机制来保证初始化实例时只有一个线程。\n\n- 静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。\n\n- 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM  帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。（装载类的时候是安全的）\n\n- 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高\n\n- 结论：**推荐**使用.\n\n## 十、枚举\n\n### 代码演示\n```java\npackage com.atguigu.singleton.type8;\n\npublic class SingletonTest08 {\n\tpublic static void main(String[] args) {\n\t\tSingleton instance = Singleton.INSTANCE;\n\t\tSingleton instance2 = Singleton.INSTANCE;\n\t\tSystem.out.println(instance == instance2);\n\t\t\n\t\tSystem.out.println(instance.hashCode());\n\t\tSystem.out.println(instance2.hashCode());\n\t\t\n\t\tinstance.sayOK();\n\t}\n}\n\n//使用枚举，可以实现单例, 推荐\nenum Singleton {\n\tINSTANCE; //属性\n\tpublic void sayOK() {\n\t\tSystem.out.println(\"ok~\");\n\t}\n}\n```\n\n### 优缺点说明：\n\n1) 这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。\n\n2) 这种方式是 **Effective  Java 作者 Josh  Bloch 提倡**的方式\n\n3) 结论：**推荐**使用\n\n\n## 十一、单例模式在 JDK 应用的源码分析\n\n### （一）单例模式在JDK 应用的源码分析\n\n1) 我们 JDK 中，java.lang.Runtime 就是经典的单例模式(饿汉式)\n\n2) 代码分析+Debug 源码+代码说明\n\n## （二）单例模式注意事项和细节说明\n\n1) 单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能\n\n2) 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new\n\n3) 单例模式**使用的场景**：需要**频繁的进行创建和销毁的对象**、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、**工具类对象**、频繁访问数据库或文件的对象(比如**数据源、session 工厂**等)\n",[[1573826328225,["GJX@GJXAIOU",[[-1,1659,"atguig"],[1,1665,"gjxaio"]],[1659,1666],[1659,1666]]],[1573826328460,["GJX@GJXAIOU",[[-1,2522,"atguig"],[1,2528,"gjxaio"]],[2522,2529],[2522,2529]]],[1573826328726,["GJX@GJXAIOU",[[-1,3449,"atguig"],[1,3455,"gjxaio"]],[3449,3456],[3449,3456]]],[1573826328937,["GJX@GJXAIOU",[[-1,4395,"atguig"],[1,4401,"gjxaio"]],[4395,4402],[4395,4402]]],[1573826329095,["GJX@GJXAIOU",[[-1,5487,"atguig"],[1,5493,"gjxaio"]],[5487,5494],[5487,5494]]],[1573826329380,["GJX@GJXAIOU",[[-1,6661,"atguig"],[1,6667,"gjxaio"]],[6661,6668],[6661,6668]]]],null,"GJX@GJXAIOU"],["024922df-fb0e-4add-ba97-1f7912f403e0",1573827522736,"# 第五章：单例设计模式\n\n\n## 一、 单例设计模式介绍\n\n所谓类的单例设计模式，就是**采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例**， 并且该类只提供一个取得其对象实例的方法(静态方法)。\n\n比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。\n\n## 二、单例设计模式八种方式\n\n单例模式有八种方式：\n\n**1)** **饿汉式(静态常量)**\n\n**2)** **饿汉式（静态代码块）**\n\n**3)** 懒汉式(线程不安全)\n\n**4)** 懒汉式(线程安全，同步方法)\n\n**5)** 懒汉式(线程安全，同步代码块)\n\n**6)** **双重检查**\n\n**7)** **静态内部类**\n\n**8)** **枚举**\n\n## 三、饿汉式（静态常量）\n\n### （一）饿汉式（静态常量）应用实例步骤：\n\n- 构造器私有化 (防止 new )\n- 类的内部创建对象\n- 向外暴露一个静态的公共方法。getInstance\n\n代码实现\n```java\npackage com.gjxaiou.singleton.type1;\n\npublic class SingletonTest01 {\n\n\tpublic static void main(String[] args) {\n\t\t//测试\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n\n}\n\n//饿汉式(静态变量)\nclass Singleton {\n\t//1. 构造器私有化, 外部能new\n\tprivate Singleton() {\t\t\n\t}\n\t\n\t//2.本类内部创建对象实例\n\tprivate final static Singleton instance = new Singleton();\n\t\n\t//3. 提供一个公有的静态方法，返回实例对象\n\tpublic static Singleton getInstance() {\n\t\treturn instance;\n\t}\t\n}\n\n// output:\ntrue\ninstance.hashCode=325040804\ninstance2.hashCode=325040804\n```\n\n\n### （二）优缺点说明\n\n- 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。\n- 缺点：\n  - **在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费**\n  -  这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法， 但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果\n\n-  结论：这种单例模式可用，可能造成内存浪费\n\n## 四、饿汉式（静态代码块）\n\n 代码演示：\n```java\npackage com.gjxaiou.singleton.type2;\n\npublic class SingletonTest02 {\n\n\tpublic static void main(String[] args) {\n\t\t//测试\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n\n}\n\n//饿汉式(静态变量)\nclass Singleton {\n\t//1. 构造器私有化, 外部能new\n\tprivate Singleton() {\t\n\t}\n\t\n\n\t//2.本类内部创建对象实例\n\tprivate  static Singleton instance;\n\t\n\tstatic { // 在静态代码块中，创建单例对象\n\t\tinstance = new Singleton();\n\t}\n\t\n\t//3. 提供一个公有的静态方法，返回实例对象\n\tpublic static Singleton getInstance() {\n\t\treturn instance;\n\t}\n\t\n}\n```\n\n### 优缺点说明：\n\n1) 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。\n\n2) 结论：这种单例模式可用，但是可能造成内存浪费\n\n## （一） 懒汉式(线程不安全)\n\nØ 代码演示：\n```java\npackage com.gjxaiou.singleton.type3;\n\n\npublic class SingletonTest03 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"懒汉式1 ， 线程不安全~\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n\n}\n\nclass Singleton {\n\tprivate static Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\t//提供一个静态的公有方法，当使用到该方法时，才去创建 instance\n\t//即懒汉式\n\tpublic static Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n### 优缺点说明：\n\n-  起到了 **Lazy Loading** 的效果，但是只能在单线程下使用。\n\n- 如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会**产生多个实例**。所以在多线程环境下不可使用这种方式\n- 结论：在实际开发中，**不要使用**这种方式.\n\n## 5.6 懒汉式(线程安全，同步方法)\n\nØ 代码演示：\n\n```java\npackage com.gjxaiou.singleton.type4;\n\npublic class SingletonTest04 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"懒汉式2 ， 线程安全~\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n}\n\n// 懒汉式(线程安全，同步方法)\nclass Singleton {\n\tprivate static Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\t//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题\n\t//即懒汉式\n\tpublic static synchronized Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n### 优缺点说明：\n\n- 解决了**线程安全**问题\n\n- 效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。**方法进行同步效率太**低\n\n- 结论：在实际开发中，**不推荐**使用这种方式\n\n## 七、懒汉式(线程安全，同步代码块)\n\n不推荐使用\n\n## 八、双重检查\n\nØ 代码演示\n```java\npackage com.gjxaiou.singleton.type6;\n\n\npublic class SingletonTest06 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"双重检查\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t\t\n\t}\n\n}\n\n// 懒汉式(线程安全，同步方法)\nclass Singleton {\n\tprivate static volatile Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\t//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题\n\t//同时保证了效率, 推荐使用\n\t\n\tpublic static synchronized Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tsynchronized (Singleton.class) {\n\t\t\t\tif(instance == null) {\n\t\t\t\t\tinstance = new Singleton();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n### 优缺点说明：\n\n- Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这样就可以保证线程安全了。\n\n-  这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象，也避免的反复进行方法同步.\n\n- 线程安全；延迟加载；效率较高\n\n- 结论：在实际开发中，**推荐使用这种单例设计模**式\n\n## 九、静态内部类\n\n###  代码演示：\n\n```java\npackage com.gjxaiou.singleton.type7;\n\n\npublic class SingletonTest07 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"使用静态内部类完成单例模式\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t\t\n\t}\n\n}\n\n// 静态内部类完成， 推荐使用\nclass Singleton {\n\tprivate static volatile Singleton instance;\n\t\n\t//构造器私有化\n\tprivate Singleton() {}\n\t\n\t//写一个静态内部类,该类中有一个静态属性 Singleton\n\tprivate static class SingletonInstance {\n\t\tprivate static final Singleton INSTANCE = new Singleton(); \n\t}\n\t\n\t//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE\n\t\n\tpublic static synchronized Singleton getInstance() {\n\t\t\n\t\treturn SingletonInstance.INSTANCE;\n\t}\n}\n```\n\n### 优缺点说明：\n\n-  这种方式采用了类装载的机制来保证初始化实例时只有一个线程。\n\n- 静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。\n\n- 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM  帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。（装载类的时候是安全的）\n\n- 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高\n\n- 结论：**推荐**使用.\n\n## 十、枚举\n\n### 代码演示\n```java\npackage com.gjxaiou.singleton.type8;\n\npublic class SingletonTest08 {\n\tpublic static void main(String[] args) {\n\t\tSingleton instance = Singleton.INSTANCE;\n\t\tSingleton instance2 = Singleton.INSTANCE;\n\t\tSystem.out.println(instance == instance2);\n\t\t\n\t\tSystem.out.println(instance.hashCode());\n\t\tSystem.out.println(instance2.hashCode());\n\t\t\n\t\tinstance.sayOK();\n\t}\n}\n\n//使用枚举，可以实现单例, 推荐\nenum Singleton {\n\tINSTANCE; //属性\n\tpublic void sayOK() {\n\t\tSystem.out.println(\"ok~\");\n\t}\n}\n```\n\n### 优缺点说明：\n\n1) 这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。\n\n2) 这种方式是 **Effective  Java 作者 Josh  Bloch 提倡**的方式\n\n3) 结论：**推荐**使用\n\n\n## 十一、单例模式在 JDK 应用的源码分析\n\n### （一）单例模式在JDK 应用的源码分析\n\n1) 我们 JDK 中，java.lang.Runtime 就是经典的单例模式(饿汉式)\n\n2) 代码分析+Debug 源码+代码说明\n\n## （二）单例模式注意事项和细节说明\n\n1) 单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能\n\n2) 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new\n\n3) 单例模式**使用的场景**：需要**频繁的进行创建和销毁的对象**、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、**工具类对象**、频繁访问数据库或文件的对象(比如**数据源、session 工厂**等)\n",[[1573827475750,["GJX@GJXAIOU",[[-1,272,"**1)** **"]],[272,281],[272,272]]],[1573827476487,["GJX@GJXAIOU",[[1,272,"- "]],[272,272],[274,274]]],[1573827479123,["GJX@GJXAIOU",[[-1,283,"**"]],[285,285],[283,283]]],[1573827482606,["GJX@GJXAIOU",[[-1,287,"2)** **"]],[285,292],[285,285]]],[1573827483266,["GJX@GJXAIOU",[[1,285,"- "]],[285,285],[287,287]]],[1573827486251,["GJX@GJXAIOU",[[-1,303,"**3)** "]],[303,310],[303,303]]],[1573827486742,["GJX@GJXAIOU",[[1,303,"- "]],[303,303],[305,305]]],[1573827491235,["GJX@GJXAIOU",[[-1,316,"\n**4)** "]],[316,324],[316,316]]],[1573827491823,["GJX@GJXAIOU",[[1,316,"- "]],[316,316],[318,318]]],[1573827494972,["GJX@GJXAIOU",[[-1,302,"\n"]],[302,302],[301,301]]],[1573827496622,["GJX@GJXAIOU",[[-1,284,"\n"]],[284,284],[283,283]]],[1573827501476,["GJX@GJXAIOU",[[-1,331,"\n**5)** "]],[331,339],[331,331]]],[1573827502000,["GJX@GJXAIOU",[[1,331,"- "]],[331,331],[333,333]]],[1573827508228,["GJX@GJXAIOU",[[-1,349,"\n**6)** "]],[349,357],[349,349]]],[1573827508706,["GJX@GJXAIOU",[[1,349,"- "]],[349,349],[351,351]]],[1573827513188,["GJX@GJXAIOU",[[-1,360,"\n**7)** "]],[360,368],[360,360]]],[1573827513698,["GJX@GJXAIOU",[[1,360,"- "]],[360,360],[362,362]]],[1573827517020,["GJX@GJXAIOU",[[-1,372,"\n**8)** "]],[372,380],[372,372]]],[1573827517641,["GJX@GJXAIOU",[[1,372,"- "]],[372,372],[374,374]]],[1573827521780,["GJX@GJXAIOU",[[1,274,"**"],[1,283,"**"]],[274,283],[274,287]]]],null,"GJX@GJXAIOU"],["8cd05f4b-6888-4909-8c62-673a0c89d33c",1573979513866,"# 第五章：单例设计模式\n\n\n## 一、 单例设计模式介绍\n\n所谓类的单例设计模式，就是**采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例**， 并且该类只提供一个取得其对象实例的方法(静态方法)。\n\n比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。\n\n## 二、单例设计模式八种方式\n\n单例模式有八种方式：\n\n- **饿汉式(静态常量)**\n- **饿汉式（静态代码块）**\n- 懒汉式(线程不安全)\n- 懒汉式(线程安全，同步方法)\n- 懒汉式(线程安全，同步代码块)\n- **双重检查**\n- **静态内部类**\n- **枚举**\n\n## 三、饿汉式（静态常量）\n\n### （一）饿汉式（静态常量）应用实例步骤：\n\n- 构造器私有化 (防止 new )\n- 类的内部创建对象\n- 向外暴露一个静态的公共方法。getInstance\n\n代码实现\n```java\npackage com.gjxaiou.singleton.type1;\n\npublic class SingletonTest01 {\n\n\tpublic static void main(String[] args) {\n\t\t//测试\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n\n}\n\n//饿汉式(静态变量)\nclass Singleton {\n\t//1. 构造器私有化, 外部能new\n\tprivate Singleton() {\t\t\n\t}\n\t\n\t//2.本类内部创建对象实例\n\tprivate final static Singleton instance = new Singleton();\n\t\n\t//3. 提供一个公有的静态方法，返回实例对象\n\tpublic static Singleton getInstance() {\n\t\treturn instance;\n\t}\t\n}\n\n// output:\ntrue\ninstance.hashCode=325040804\ninstance2.hashCode=325040804\n```\n\n\n### （二）优缺点说明\n\n- 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。\n- 缺点：\n  - **在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费**\n  -  这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法， 但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果\n\n-  结论：这种单例模式可用，可能造成内存浪费\n\n## 四、饿汉式（静态代码块）\n\n 代码演示：\n```java\npackage com.gjxaiou.singleton.type2;\n\npublic class SingletonTest02 {\n\n\tpublic static void main(String[] args) {\n\t\t//测试\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n\n}\n\n//饿汉式(静态变量)\nclass Singleton {\n\t//1. 构造器私有化, 外部能new\n\tprivate Singleton() {\t\n\t}\n\t\n\n\t//2.本类内部创建对象实例\n\tprivate  static Singleton instance;\n\t\n\tstatic { // 在静态代码块中，创建单例对象\n\t\tinstance = new Singleton();\n\t}\n\t\n\t//3. 提供一个公有的静态方法，返回实例对象\n\tpublic static Singleton getInstance() {\n\t\treturn instance;\n\t}\n\t\n}\n```\n\n### 优缺点说明：\n\n1) 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。\n\n2) 结论：这种单例模式可用，但是可能造成内存浪费\n\n## （一） 懒汉式(线程不安全)\n\nØ 代码演示：\n```java\npackage com.gjxaiou.singleton.type3;\n\n\npublic class SingletonTest03 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"懒汉式1 ， 线程不安全~\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n\n}\n\nclass Singleton {\n\tprivate static Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\t//提供一个静态的公有方法，当使用到该方法时，才去创建 instance\n\t//即懒汉式\n\tpublic static Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n### 优缺点说明：\n\n-  起到了 **Lazy Loading** 的效果，但是只能在单线程下使用。\n\n- 如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会**产生多个实例**。所以在多线程环境下不可使用这种方式\n- 结论：在实际开发中，**不要使用**这种方式.\n\n## 5.6 懒汉式(线程安全，同步方法)\n\nØ 代码演示：\n\n```java\npackage com.gjxaiou.singleton.type4;\n\npublic class SingletonTest04 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"懒汉式2 ， 线程安全~\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t}\n}\n\n// 懒汉式(线程安全，同步方法)\nclass Singleton {\n\tprivate static Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\t//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题\n\t//即懒汉式\n\tpublic static synchronized Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n### 优缺点说明：\n\n- 解决了**线程安全**问题\n\n- 效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。**方法进行同步效率太**低\n\n- 结论：在实际开发中，**不推荐**使用这种方式\n\n## 七、懒汉式(线程安全，同步代码块)\n\n不推荐使用\n\n## 八、双重检查\n\nØ 代码演示\n```java\npackage com.gjxaiou.singleton.type6;\n\n\npublic class SingletonTest06 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"双重检查\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t\t\n\t}\n\n}\n\n// 懒汉式(线程安全，同步方法)\nclass Singleton {\n\tprivate static volatile Singleton instance;\n\t\n\tprivate Singleton() {}\n\t\n\t//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题\n\t//同时保证了效率, 推荐使用\n\t\n\tpublic static synchronized Singleton getInstance() {\n\t\tif(instance == null) {\n\t\t\tsynchronized (Singleton.class) {\n\t\t\t\tif(instance == null) {\n\t\t\t\t\tinstance = new Singleton();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n### 优缺点说明：\n\n- Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这样就可以保证线程安全了。\n\n-  这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象，也避免的反复进行方法同步.\n\n- 线程安全；延迟加载；效率较高\n\n- 结论：在实际开发中，**推荐使用这种单例设计模**式\n\n## 九、静态内部类\n\n###  代码演示：\n\n```java\npackage com.gjxaiou.singleton.type7;\n\n\npublic class SingletonTest07 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"使用静态内部类完成单例模式\");\n\t\tSingleton instance = Singleton.getInstance();\n\t\tSingleton instance2 = Singleton.getInstance();\n\t\tSystem.out.println(instance == instance2); // true\n\t\tSystem.out.println(\"instance.hashCode=\" + instance.hashCode());\n\t\tSystem.out.println(\"instance2.hashCode=\" + instance2.hashCode());\n\t\t\n\t}\n\n}\n\n// 静态内部类完成， 推荐使用\nclass Singleton {\n\tprivate static volatile Singleton instance;\n\t\n\t//构造器私有化\n\tprivate Singleton() {}\n\t\n\t//写一个静态内部类,该类中有一个静态属性 Singleton\n\tprivate static class SingletonInstance {\n\t\tprivate static final Singleton INSTANCE = new Singleton(); \n\t}\n\t\n\t//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE\n\t\n\tpublic static synchronized Singleton getInstance() {\n\t\t\n\t\treturn SingletonInstance.INSTANCE;\n\t}\n}\n```\n\n### 优缺点说明：\n\n-  这种方式采用了类装载的机制来保证初始化实例时只有一个线程。\n\n- 静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。\n\n- 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM  帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。（装载类的时候是安全的）\n\n- 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高\n\n- 结论：**推荐**使用.\n\n## 十、枚举\n\n### 代码演示\n```java\npackage com.gjxaiou.singleton.type8;\n\npublic class SingletonTest08 {\n\tpublic static void main(String[] args) {\n\t\tSingleton instance = Singleton.INSTANCE;\n\t\tSingleton instance2 = Singleton.INSTANCE;\n\t\tSystem.out.println(instance == instance2);\n\t\t\n\t\tSystem.out.println(instance.hashCode());\n\t\tSystem.out.println(instance2.hashCode());\n\t\t\n\t\tinstance.sayOK();\n\t}\n}\n\n//使用枚举，可以实现单例, 推荐\nenum Singleton {\n\tINSTANCE; //属性\n\tpublic void sayOK() {\n\t\tSystem.out.println(\"ok~\");\n\t}\n}\n```\n\n### 优缺点说明：\n\n1) 这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。\n\n2) 这种方式是 **Effective  Java 作者 Josh  Bloch 提倡**的方式\n\n3) 结论：**推荐**使用\n\n\n## 十一、单例模式在 JDK 应用的源码分析\n\n### （一）单例模式在JDK 应用的源码分析\n\n1) 我们 JDK 中，java.lang.Runtime 就是经典的单例模式(饿汉式)\n\n2) 代码分析+Debug 源码+代码说明\n\n## （二）单例模式注意事项和细节说明\n\n1) 单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能\n\n2) 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new\n\n3) 单例模式**使用的场景**：需要**频繁的进行创建和销毁的对象**、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、**工具类对象**、频繁访问数据库或文件的对象(比如**数据源、session 工厂**等)\n",[[1573979461110,["GJX@GJXAIOUPC",[[1,0,"\n"]],[0,0],[1,1]]],[1573979462054,["GJX@GJXAIOUPC",[[1,0,"---\nflag: purple\n---"]],[0,0],[20,20]]]],null,"GJX@GJXAIOUPC"]]}