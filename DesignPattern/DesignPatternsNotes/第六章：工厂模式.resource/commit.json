{"compress":true,"commitItems":[["c83d87c5-259a-40fd-8b53-6b8091295768",1573562014899,"# 第 6 章  工厂模式\n\n## 6.1 简单工厂模式\n\n### 6.1.1 看一个具体的需求\n\n看一个披萨的项目：要便于披萨种类的扩展，要便于维护\n\n1) 披萨的种类很多(比如 GreekPizz、CheesePizz 等)\n\n2) 披萨的制作有 prepare，bake, cut, box\n\n3) 完成披萨店订购功能。\n\n### 6.1.2 使用传统的方式来完成\n\n1) 思路分析(类图)\n\n编写 OrderPizza.java 去订购需要的各种 Pizza\n\n2) 看老师代码的演示\n\n| \n\npublic class OrderPizza {\n\n |\n\n| \n\n// 构造器\n\n// public OrderPizza()  {\n\n// Pizza pizza =  null;\n\n// String  orderType; // 订购披萨的类型\n\n// do {\n\n// orderType =  getType();\n\n// if (orderType.equals(\"greek\"))  {\n\n// pizza = new  GreekPizza();\n\n// pizza.setName(\" 希腊披萨 \");\n\n// } else if (orderType.equals(\"cheese\"))  {\n\n// pizza = new  CheesePizza();\n\n// pizza.setName(\" 奶酪披萨 \");\n\n// } else if (orderType.equals(\"pepper\"))  {\n\n// pizza = new  PepperPizza();\n\n// pizza.setName(\"胡椒披萨\");\n\n// } else  {\n\n// break;\n\n// }\n\n// //输出 pizza 制作过程\n\n// pizza.prepare();\n\n// pizza.bake();\n\n// pizza.cut();\n\n// pizza.box();\n\n//\n\n// } while  (true);\n\n// }\n\n |\n\n### 6.1.3 传统的方式的优缺点\n\n1) 优点是比较好理解，简单易操作。\n\n2) 缺点是违反了设计模式的 **ocp** **原则**，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.\n\n3) 比如我们这时**要新增加一个** **Pizza** **的种类****(Pepper** **披萨****)**，我们需要做如下修改. 如果我们增加一个 Pizza 类，只要是订购 Pizza 的代码都需要修改.\n\n4) 改进的思路分析\n\n分析：修改代码可以接受，但是如果我们在其它的地方也有创建 Pizza 的代码，就意味着，也需要修改，而创建 Pizza\n\n的代码，往往有多处。\n\n思路：**把创建** **Pizza** **对象封装到一个类中，这样我们有新的** **Pizza** **种类时，只需要修改该类就可**，其它有创建到 Pizza\n\n对象的代码就不需要修改了.-> **简单工厂**模式\n\n### 6.1.4 基本介绍\n\n1) 简单工厂模式是属于**创建型模式**，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是**工厂模式家族中最简单实用的**模式\n\n2) 简单工厂模式：定义了一个创建对象的类，由这个类来**封装实例化对象的行为**(代码)\n\n3) 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.\n\n### 6.1.5 使用简单工厂模式\n\n1) 简单工厂模式的设计方案: 定义一个可以实例化 Pizaa 对象的类，封装创建对象的代码。\n\n2) 看代码示例\n\n| \n\npackage com.atguigu.factory.simplefactory.pizzastore.order;\n\nimport com.atguigu.factory.simplefactory.pizzastore.pizza.CheesePizza; import com.atguigu.factory.simplefactory.pizzastore.pizza.GreekPizza; import com.atguigu.factory.simplefactory.pizzastore.pizza.PepperPizza; import com.atguigu.factory.simplefactory.pizzastore.pizza.Pizza;\n\n |\n\n| \n\n//简单工厂类\n\npublic class **SimpleFactory** {\n\n//更加 orderType 返回对应的 Pizza 对象\n\npublic Pizza createPizza(String orderType) {\n\nPizza pizza = null;\n\nSystem.out.println(\"使用简单工厂模式\"); if (orderType.equals(\"greek\")) {\n\npizza = new GreekPizza(); pizza.setName(\" 希腊披萨 \");\n\n} else if (orderType.equals(\"cheese\")) {\n\npizza = new CheesePizza(); pizza.setName(\" 奶酪披萨 \");\n\n} else if (orderType.equals(\"pepper\")) {\n\npizza = new PepperPizza(); pizza.setName(\"胡椒披萨\");\n\n}\n\nreturn pizza;\n\n}\n\n//简单工厂模式 也叫 静态工厂模式\n\n |\n\n| \n\npublic static Pizza createPizza2(String orderType) {\n\nPizza pizza = null;\n\nSystem.out.println(\"使用简单工厂模式 2\"); if (orderType.equals(\"greek\")) {\n\npizza = new GreekPizza(); pizza.setName(\" 希腊披萨 \");\n\n} else if (orderType.equals(\"cheese\")) {\n\npizza = new CheesePizza(); pizza.setName(\" 奶酪披萨 \");\n\n} else if (orderType.equals(\"pepper\")) {\n\npizza = new PepperPizza(); pizza.setName(\"胡椒披萨\");\n\n}\n\nreturn pizza;\n\n}\n\n}\n\n |\n| \n\n//OrderPizza.java\n\npackage com.atguigu.factory.simplefactory.pizzastore.order;\n\nimport java.io.BufferedReader;\n\n |\n\n| \n\nimport java.io.IOException; import  java.io.InputStreamReader;\n\nimport com.atguigu.factory.simplefactory.pizzastore.pizza.Pizza;\n\npublic class OrderPizza {\n\n// 构造器\n\n// public OrderPizza()  {\n\n// Pizza pizza =  null;\n\n// String  orderType; // 订购披萨的类型\n\n// do {\n\n// orderType =  getType();\n\n// if (orderType.equals(\"greek\"))  {\n\n// pizza = new  GreekPizza();\n\n// pizza.setName(\" 希腊披萨 \");\n\n// } else if (orderType.equals(\"cheese\"))  {\n\n// pizza = new  CheesePizza();\n\n// pizza.setName(\" 奶酪披萨 \");\n\n// } else if (orderType.equals(\"pepper\"))  {\n\n// pizza = new  PepperPizza();\n\n// pizza.setName(\"胡椒披萨\");\n\n// } else  {\n\n// break;\n\n// }\n\n |\n\n| \n\n// //输出 pizza 制作过程\n\n// pizza.prepare();\n\n// pizza.bake();\n\n// pizza.cut();\n\n// pizza.box();\n\n//\n\n// } while  (true);\n\n// }\n\n//定义一个简单工厂对象SimpleFactory simpleFactory; Pizza pizza = null;\n\n//构造器\n\npublic OrderPizza(SimpleFactory simpleFactory) { setFactory(simpleFactory);\n\n}\n\npublic void setFactory(SimpleFactory simpleFactory) {\n\nString orderType = \"\"; //用户输入的\n\nthis.simpleFactory = simpleFactory; //设置简单工厂对象\n\ndo {\n\norderType = getType();\n\npizza = this.simpleFactory.createPizza(orderType);\n\n |\n\n| \n\n//输出 pizza\n\nif(pizza != null) { //订购成功pizza.prepare(); pizza.bake();\n\npizza.cut();\n\npizza.box();\n\n} else {\n\nSystem.out.println(\" 订购披萨失败 \"); break;\n\n}\n\n}while(true);\n\n}\n\n// 写一个方法，可以获取客户希望订购的披萨种类\n\nprivate String getType() { try {\n\nBufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\");\n\nString str = strin.readLine();\n\nreturn str;\n\n} catch (IOException e) { e.printStackTrace(); return \"\";\n\n}\n\n}\n\n |\n\n| \n\n}\n\n |\n\n## 6.2 工厂方法模式\n\n### 6.2.1 看一个新的需求\n\n披萨项目新的需求：客户在点披萨时，可以点**不同口味的披萨**，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza。\n\n### 6.2.2 思路 1\n\n使用**简单工厂模式**，创建**不同的简单工厂类**，比如 BJPizzaSimpleFactory、LDPizzaSimpleFactory 等等.从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好\n\n### 6.2.3 思路 2\n\n使用工厂方法模式\n\n### 6.2.4 工厂方法模式介绍\n\n1) 工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。\n\n2) 工厂方法模式：**定义了一个创建对象的抽象方法**，由子**类决定要实例化的类**。工厂方法模式将**对象的实例化推迟到子类**。\n\n### 6.2.5 工厂方法模式应用案例\n\n1) 披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza\n\n2) 思路分析图解\n\n3) 看老师代码实现\n\n| \n\n//OrderPizza.java 类\n\npackage com.atguigu.factory.factorymethod.pizzastore.order;\n\nimport java.io.BufferedReader; import java.io.IOException; import  java.io.InputStreamReader;\n\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.Pizza;\n\n |\n\n| \n\npublic abstract class OrderPizza {\n\n//定义一个抽象方法，createPizza , 让各个工厂子类自己实现\n\nabstract Pizza createPizza(String orderType);\n\n// 构造器\n\npublic OrderPizza() { Pizza pizza = null;\n\nString orderType; // 订购披萨的类型\n\ndo {\n\norderType = getType();\n\npizza = createPizza(orderType); //抽象方法，由工厂子类完成\n\n//输出 pizza 制作过程pizza.prepare(); pizza.bake();\n\npizza.cut();\n\npizza.box();\n\n} while (true);\n\n}\n\n |\n\n| \n\n// 写一个方法，可以获取客户希望订购的披萨种类\n\nprivate String getType() { try {\n\nBufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\");\n\nString str = strin.readLine();\n\nreturn str;\n\n} catch (IOException e) { e.printStackTrace(); return \"\";\n\n}\n\n}\n\n}\n\n |\n| \n\npackage com.atguigu.factory.factorymethod.pizzastore.order;\n\nimport  com.atguigu.factory.factorymethod.pizzastore.pizza.BJCheesePizza; import com.atguigu.factory.factorymethod.pizzastore.pizza.BJPepperPizza; import  com.atguigu.factory.factorymethod.pizzastore.pizza.Pizza;\n\npublic class **BJOrderPizza** extends OrderPizza {\n\n |\n\n| \n\n@Override\n\nPizza createPizza(String orderType) {\n\nPizza pizza = null; if(orderType.equals(\"cheese\")) {\n\npizza = new  BJCheesePizza();\n\n} else if (orderType.equals(\"pepper\"))  { pizza = new  BJPepperPizza();\n\n}\n\n// TODO Auto-generated method stub return pizza;\n\n}\n\n}\n\n |\n| \n\npackage com.atguigu.factory.factorymethod.pizzastore.order;\n\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.BJCheesePizza; import com.atguigu.factory.factorymethod.pizzastore.pizza.BJPepperPizza; import  com.atguigu.factory.factorymethod.pizzastore.pizza.LDCheesePizza; import com.atguigu.factory.factorymethod.pizzastore.pizza.LDPepperPizza; import  com.atguigu.factory.factorymethod.pizzastore.pizza.Pizza;\n\npublic class LDOrderPizza extends OrderPizza {\n\n |\n\n| \n\n@Override\n\nPizza createPizza(String orderType) {\n\nPizza pizza = null; if(orderType.equals(\"cheese\")) {\n\npizza = new  LDCheesePizza();\n\n} else if (orderType.equals(\"pepper\"))  { pizza = new  LDPepperPizza();\n\n}\n\n// TODO Auto-generated method stub return pizza;\n\n}\n\n}\n\n |\n\n## 6.3 抽象工厂模式\n\n### 6.3.1 基本介绍\n\n1) 抽象工厂模式：定义了一个 **interface** **用于创建相关或有依赖关系的对象簇**，而无需指明具体的类\n\n2) 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。\n\n3) 从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。\n\n4) 将工厂抽象成**两层**，**AbsFactory(****抽象工厂****)** 和 **具体实现的工厂子类**。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。\n\n5) 类图\n\n### 6.3.2 抽象工厂模式应用实例\n\n使用抽象工厂模式来完成披萨项目.\n\n| \n\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\nimport com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;\n\n//一个抽象工厂模式的抽象层(接口) public interface AbsFactory {\n\n//让下面的工厂子类来 具体实现\n\npublic Pizza createPizza(String orderType);\n\n}\n\n |\n\n| \n\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\nimport  com.atguigu.factory.absfactory.pizzastore.pizza.BJCheesePizza; import  com.atguigu.factory.absfactory.pizzastore.pizza.BJPepperPizza; import  com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;\n\n//这是工厂子类\n\npublic class BJFactory implements AbsFactory {\n\n@Override\n\npublic Pizza createPizza(String orderType) { System.out.println(\"~使用的是抽象工厂模式~\");\n\n// TODO Auto-generated method stub\n\nPizza pizza = null; if(orderType.equals(\"cheese\")) {\n\npizza = new  BJCheesePizza();\n\n} else if  (orderType.equals(\"pepper\")){ pizza = new  BJPepperPizza();\n\n}\n\nreturn pizza;\n\n}\n\n}\n\n |\n| \n\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\n |\n\n| \n\nimport  com.atguigu.factory.absfactory.pizzastore.pizza.LDCheesePizza; import  com.atguigu.factory.absfactory.pizzastore.pizza.LDPepperPizza; import  com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;\n\npublic class LDFactory implements AbsFactory {\n\n@Override\n\npublic Pizza createPizza(String orderType) { System.out.println(\"~使用的是抽象工厂模式~\"); Pizza pizza = null;\n\nif (orderType.equals(\"cheese\")) { pizza = new  LDCheesePizza();\n\n} else if (orderType.equals(\"pepper\"))  { pizza = new  LDPepperPizza();\n\n}\n\nreturn pizza;\n\n}\n\n}\n\n |\n| \n\n//OrderPizza.java\n\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\nimport java.io.BufferedReader;\n\n |\n\n| \n\nimport java.io.IOException; import  java.io.InputStreamReader;\n\nimport com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;\n\npublic class OrderPizza {\n\nAbsFactory factory;\n\n// 构造器\n\npublic OrderPizza(AbsFactory factory) { setFactory(factory);\n\n}\n\nprivate void setFactory(AbsFactory factory) { Pizza pizza = null;\n\nString orderType = \"\"; // 用户输入\n\nthis.factory = factory; do {\n\norderType = getType();\n\n// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类\n\npizza = factory.createPizza(orderType); if (pizza != null) { // 订购 ok\n\npizza.prepare();\n\npizza.bake();\n\npizza.cut();\n\n |\n\n| \n\npizza.box();\n\n} else {\n\nSystem.out.println(\"订购失败\"); break;\n\n}\n\n} while (true);\n\n}\n\n// 写一个方法，可以获取客户希望订购的披萨种类\n\nprivate String getType() { try {\n\nBufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\");\n\nString str = strin.readLine();\n\nreturn str;\n\n} catch (IOException e) { e.printStackTrace(); return \"\";\n\n}\n\n}\n\n}\n\n |\n\n## 6.4 工厂模式在 JDK-Calendar 应用的源码分析\n\n1) JDK 中的 Calendar 类中，就使用了简单工厂模式\n\n2) 源码分析+Debug 源码+说明\n\nØ 源码部分\n\n| \n\npackage  com.atguigu.jdk;\n\nimport  java.util.Calendar;\n\npublic class Factory {\n\npublic static void main(String[] args) {\n\n// TODO Auto-generated method stub\n\n// getInstance 是 Calendar 静态方法\n\nCalendar cal = **Calendar.getInstance**();\n\n// 注意月份下标从 0 开始，所以取月份要+1 System.out.println(\" 年 :\" + cal.get(Calendar.YEAR)); System.out.println(\" 月 :\" + (cal.get(Calendar.MONTH) + 1)); System.out.println(\"日:\" + cal.get(Calendar.DAY_OF_MONTH)); System.out.println(\"时:\" + cal.get(Calendar.HOUR_OF_DAY)); System.out.println(\" 分 :\" + cal.get(Calendar.MINUTE)); System.out.println(\"秒:\" + cal.get(Calendar.SECOND));\n\n}\n\n}\n\n |\n| \n\n//Calendar.java\n\n |\n\n| \n\npublic static Calendar getInstance()\n\n{\n\nreturn createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));\n\n}\n\n |\n| \n\nprivate static Calendar createCalendar(TimeZone zone,\n\nLocale aLocale) //根据 TimeZone zone, locale 创建对应的实例\n\n{\n\nCalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)\n\n.getCalendarProvider();\n\nif (provider != null) { try {\n\nreturn provider.getInstance(zone, aLocale);\n\n} catch (IllegalArgumentException iae) {\n\n// fall back to the default instantiation\n\n}\n\n}\n\nCalendar cal = null;\n\nif (aLocale.hasExtensions()) {\n\nString caltype = aLocale.getUnicodeLocaleType(\"ca\"); if (caltype != null) {\n\n |\n\n| \n\nswitch (caltype) { case \"buddhist\":\n\ncal = **new BuddhistCalendar(zone, aLocale);**\n\nbreak;\n\ncase \"japanese\":\n\ncal = **new JapaneseImperialCalendar(zone, aLocale);**\n\nbreak; case \"gregory\":\n\ncal = **new GregorianCalendar(zone, aLocale);**\n\nbreak;\n\n}\n\n}\n\n}\n\nif (cal == null) {\n\n// If no known calendar type is explicitly  specified,\n\n// perform the traditional way to create a  Calendar:\n\n// create a BuddhistCalendar for th_TH locale,\n\n// a JapaneseImperialCalendar for ja_JP_JP locale, or\n\n// a GregorianCalendar for any other locales.\n\n// NOTE: The language, country and variant strings are interned.\n\nif (aLocale.getLanguage() == \"th\" && aLocale.getCountry() == \"TH\") { cal = new BuddhistCalendar(zone, aLocale);\n\n} else if (aLocale.getVariant() == \"JP\" && aLocale.getLanguage() == \"ja\" && aLocale.getCountry() == \"JP\") {\n\ncal = new JapaneseImperialCalendar(zone, aLocale);\n\n} else {\n\n |\n\n| \n\ncal = new GregorianCalendar(zone, aLocale);\n\n}\n\n}\n\nreturn cal;\n\n}\n\n |\n\n## 6.5 工厂模式小结\n\n1) 工厂模式的意义\n\n将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。\n\n2) 三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)\n\n3) 设计模式的依赖抽象原则\n\nØ 创建对象实例时，不要直接 new 类, 而是把这个 new 类的动作放在一个工厂的方法中，并返回。有的书上说， 变量不要直接持有具体类的引用。\n\nØ 不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)\n\nØ 不要覆盖基类中已经实现的方法。",[[1573562013872,["GJX@GJXAIOU",[[-1,3," 6 "]],[6,6],[3,3]]],[1573562015992,["GJX@GJXAIOU",[[1,3,"六"]],[3,3],[4,4]]],[1573562022197,["GJX@GJXAIOU",[[-1,5,"  "]],[7,7],[5,5]]],[1573562023424,["GJX@GJXAIOU",[[1,5,"："]],[5,5],[6,6]]],[1573562027541,["GJX@GJXAIOU",[[-1,15,"6.1 "]],[15,19],[15,15]]],[1573562029303,["GJX@GJXAIOU",[[1,15,"一、"]],[15,15],[17,17]]],[1573562119508,["GJX@GJXAIOU",[[-1,29,"6.1.1 "]],[35,35],[29,29]]],[1573562120504,["GJX@GJXAIOU",[[1,29,"（）"]],[29,29],[31,31]]],[1573562122240,["GJX@GJXAIOU",[[1,30,"一"]],[30,30],[31,31]]],[1573562129779,["GJX@GJXAIOU",[[-1,161,"6.1.2 "]],[161,167],[161,161]]],[1573562130751,["GJX@GJXAIOU",[[1,161,"（）"]],[161,161],[163,163]]],[1573562132266,["GJX@GJXAIOU",[[1,162,"二"]],[162,162],[163,163]]],[1573562230018,["GJX@GJXAIOU",[[1,116,"步骤"]],[116,116],[118,118]]],[1573562232752,["GJX@GJXAIOU",[[1,119,"："]],[119,119],[120,120]]],[1573562239499,["GJX@GJXAIOU",[[-1,108,"2)"]],[110,110],[108,108]]],[1573562240533,["GJX@GJXAIOU",[[1,108,"-"]],[108,108],[109,109]]],[1573562240927,["GJX@GJXAIOU",[[1,110," "]],[109,109],[110,110]]],[1573562242557,["GJX@GJXAIOU",[[-1,110," "]],[111,111],[110,110]]],[1573562244933,["GJX@GJXAIOU",[[-1,144,"3)"]],[146,146],[144,144]]],[1573562245347,["GJX@GJXAIOU",[[-1,143,"\n"]],[144,144],[143,143]]],[1573562246271,["GJX@GJXAIOU",[[1,143,"-"]],[143,143],[144,144]]],[1573562248228,["GJX@GJXAIOU",[[-1,107,"\n"]],[107,107],[106,106]]],[1573562254506,["GJX@GJXAIOU",[[-1,69,"1)"]],[71,71],[69,69]]],[1573562255479,["GJX@GJXAIOU",[[1,69,"-"]],[69,69],[70,70]]],[1573562257709,["GJX@GJXAIOU",[[-1,68,"\n"]],[68,68],[67,67]]],[1573562462908,["GJX@GJXAIOU",[[-1,186,"编写 OrderPizza.java 去订购需要的各种 Pizza"]],[186,219],[186,186]]],[1573562465701,["GJX@GJXAIOU",[[-1,173,"1)"]],[173,175],[173,173]]],[1573562466106,["GJX@GJXAIOU",[[1,173,"-"]],[173,173],[174,174]]],[1573562474026,["GJX@GJXAIOU",[[1,185,"![传统思路]($resource/%E4%BC%A0%E7%BB%9F%E6%80%9D%E8%B7%AF.jpg)"]],[185,185],[245,245]]],[1573562534628,["GJX@GJXAIOU",[[-1,259,"| \n\npublic class OrderPizza {\n\n |\n\n| \n\n// 构造器\n\n// public OrderPizza()  {\n\n// Pizza pizza =  null;\n\n// String  orderType; // 订购披萨的类型\n\n// do {\n\n// orderType =  getType();\n\n// if (orderType.equals(\"greek\"))  {\n\n// pizza = new  GreekPizza();\n\n// pizza.setName(\" 希腊披萨 \");\n\n// } else if (orderType.equals(\"cheese\"))  {\n\n// pizza = new  CheesePizza();\n\n// pizza.setName(\" 奶酪披萨 \");\n\n// } else if (orderType.equals(\"pepper\"))  {\n\n// pizza = new  PepperPizza();\n\n// pizza.setName(\"胡椒披萨\");\n\n// } else  {\n\n// break;\n\n// }\n\n// //输出 pizza 制作过程\n\n// pizza.prepare();\n\n// pizza.bake();\n\n// pizza.cut();\n\n// pizza.box();\n\n//\n\n// } while  (true);\n\n// }\n\n |"]],[259,896],[259,259]]],[1573562540248,["GJX@GJXAIOU",[[1,259,"·"]],[259,259],[260,260]]],[1573562541059,["GJX@GJXAIOU",[[-1,259,"·"]],[260,260],[259,259]]],[1573562541531,["GJX@GJXAIOU",[[-1,260,"\n"]],[259,259],[258,258]]],[1573562543798,["GJX@GJXAIOU",[[1,258,"```"]],[258,258],[261,261]]],[1573562543936,["GJX@GJXAIOU",[[1,261,"language\n```\n"]],[261,261],[261,269]]],[1573562545608,["GJX@GJXAIOU",[[-1,261,"language"],[1,269,"j"]],[261,269],[262,262]]],[1573562546170,["GJX@GJXAIOU",[[1,262,"ava"]],[262,262],[265,265]]],[1573562546518,["GJX@GJXAIOU",[[1,266,"\n"]],[265,265],[266,266]]],[1573562723918,["GJX@GJXAIOU",[[1,266,"public calss"]],[266,266],[278,278]]],[1573562725734,["GJX@GJXAIOU",[[-1,274,"alss"]],[278,278],[274,274]]],[1573562727005,["GJX@GJXAIOU",[[1,274,"lass"]],[274,274],[278,278]]],[1573562731685,["GJX@GJXAIOU",[[-1,273,"class"]],[278,278],[273,273]]],[1573562734503,["GJX@GJXAIOU",[[1,273,"abstract"]],[273,273],[281,281]]],[1573562744798,["GJX@GJXAIOU",[[1,281," class Pizzz"]],[281,281],[293,293]]],[1573562745717,["GJX@GJXAIOU",[[-1,292,"z"]],[293,293],[292,292]]],[1573562747370,["GJX@GJXAIOU",[[1,292,"a{}"]],[292,292],[295,295]]],[1573562748637,["GJX@GJXAIOU",[[1,294,"\n"]],[294,294],[295,295]]],[1573562749437,["GJX@GJXAIOU",[[1,295,"\n"]],[295,295],[296,296]]],[1573562750884,["GJX@GJXAIOU",[[1,296,"\n"]],[296,296],[297,297]]],[1573562755907,["GJX@GJXAIOU",[[1,295,"    pritec"]],[295,295],[305,305]]],[1573562760627,["GJX@GJXAIOU",[[-1,301,"itec"]],[305,305],[301,301]]],[1573562764198,["GJX@GJXAIOU",[[1,301,"otect s"]],[301,301],[308,308]]],[1573562764612,["GJX@GJXAIOU",[[-1,307,"s"]],[308,308],[307,307]]],[1573562771010,["GJX@GJXAIOU",[[1,307,"String name;"]],[307,307],[319,319]]],[1573562772149,["GJX@GJXAIOU",[[1,320,"    \n"]],[319,319],[324,324]]],[1573562775031,["GJX@GJXAIOU",[[1,324,"po"]],[324,324],[326,326]]],[1573562776077,["GJX@GJXAIOU",[[-1,325,"o"]],[326,326],[325,325]]],[1573562779737,["GJX@GJXAIOU",[[1,325,"ublic a"]],[325,325],[332,332]]]],null,"GJX@GJXAIOU"],["3da2f7ef-e344-4bf0-9e2d-59e3b34dc657",1573612670553,"# 第六章：工厂模式\n\n## 一、简单工厂模式\n\n### （一）看一个具体的需求\n\n看一个披萨的项目：要便于披萨种类的扩展，要便于维护\n- 披萨的种类很多(比如 GreekPizz、CheesePizz 等)\n- 披萨的制作步骤有： prepare，bake, cut, box\n- 完成披萨店订购功能。\n\n### （二）使用传统的方式来完成\n\n- 思路分析(类图)\n\n![传统思路]($resource/%E4%BC%A0%E7%BB%9F%E6%80%9D%E8%B7%AF.jpg)\n\n2) 看老师代码的演示\n\n```java\npublic abstract class Pizza{\n    protect String name;\n    // 因为不同的 Pizza 准备方法不同，因此做成抽象方法\n    public abstract void perpard();\n    public void bake(){\n        // XXXXX\n    }\n    public void cut(){\n        // XXXXX\n    }\n    public void box(){\n        // XXXXX\n    }\n}\n//-------------------------------------------------------\n// 然后具体的 Pizza 实体继承 Pizza\npublic void CheessPizza extends Pizza(){\n    //实现 prepare 方法\n}\n//-------------------------------------------------------\npublic void GreekPizza extends Pizza(){\n    //实现 prepare 方法\n}\n\n//-------------------------------------------------------\n// 然后实现最终的 OrderPizza 类\npublic class OrderPizza {\n\t// 构造器\n\tpublic OrderPizza() {\n\t\tPizza pizza = null;\n\t\tString orderType; //  订购披萨的类型\n\t\tdo {\n\t\t\torderType = getType();\n\t\t\tif (orderType.equals(\"greek\")) {\n\t\t\t\tpizza = new GreekPizza();\n\t\t\t\tpizza.setName(\" 希腊披萨 \");\n\t\t\t} else if (orderType.equals(\"cheese\")) {\n\t\t\t\tpizza = new CheesePizza();\n\t\t\t\tpizza.setName(\" 奶酪披萨 \");\n\t\t\t} else if (orderType.equals(\"pepper\")) {\n\t\t\t\tpizza = new PepperPizza();\n\t\t\t\tpizza.setName(\"胡椒披萨\");\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//输出 pizza 制作过程\n\t\t\tpizza.prepare();\n\t\t\tpizza.bake();\n\t\t\tpizza.cut();\n\t\t\tpizza.box();\n\n\t\t} while (true);\n\t}\n```\n\n\n### （三）传统的方式的优缺点\n\n- 优点是比较好理解，简单易操作。\n\n- 缺点是违反了设计模式的 **ocp** **原则**，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.\n\n- 比如我们这时**要新增加一个** **Pizza** 的种类(Peppe披萨)，我们需要做如下修改. 如果我们增加一个 Pizza 类，只要是订购 Pizza 的代码都需要修改。\n\n- 改进的思路分析\n\n  - 分析：修改代码可以接受，但是如果我们在其它的地方也有创建 Pizza 的代码，就意味着，也需要修改，而创建 Pizza的代码，往往有多处。\n\n  - 思路：**把创建** **Pizza** **对象封装到一个类中，这样我们有新的** **Pizza** **种类时，只需要修改该类就可**，其它有创建到 Pizza对象的代码就不需要修改了.-> **简单工厂**模式\n\n### （四）基本介绍\n\n- 简单工厂模式是属于**创建型模式**，是工厂模式的一种。简单工厂（静态工厂）模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是**工厂模式家族中最简单实用的**模式；\n\n- 简单工厂模式：定义了一个创建对象的类，由这个类来**封装实例化对象的行为**(代码)；\n\n- 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式；\n\n### 6.1.5 使用简单工厂模式\n\n1) 简单工厂模式的设计方案: 定义一个可以实例化 Pizaa 对象的类，封装创建对象的代码。\n\n![简单工厂模式](%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.resource/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png)\n\n\n\n- 看代码示例\n\n  下面是 Pizza 抽象类和三个具体的实现类\n\n  ```java\n  package com.atguigu.factory.simplefactory.pizzastore.pizza;\n  \n  //将Pizza 类做成抽象\n  public abstract class Pizza {\n  \tprotected String name; //名字\n  \n  \t//准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n  \tpublic abstract void prepare();\n  \n  \t\n  \tpublic void bake() {\n  \t\tSystem.out.println(name + \" baking;\");\n  \t}\n  \n  \tpublic void cut() {\n  \t\tSystem.out.println(name + \" cutting;\");\n  \t}\n  \n  \t//打包\n  \tpublic void box() {\n  \t\tSystem.out.println(name + \" boxing;\");\n  \t}\n  \n  \tpublic void setName(String name) {\n  \t\tthis.name = name;\n  \t}\n  }\n  \n  //----------------------------------------------------\n  package com.atguigu.factory.simplefactory.pizzastore.pizza;\n  \n  public class CheesePizza extends Pizza {\n  \t@Override\n  \tpublic void prepare() {\n  \t\tSystem.out.println(\" 给制作奶酪披萨 准备原材料 \");\n  \t}\n  }\n  //----------------------------------------------------\n  package com.atguigu.factory.simplefactory.pizzastore.pizza;\n  public class GreekPizza extends Pizza {\n  \t@Override\n  \tpublic void prepare() {\n  \t\tSystem.out.println(\" 给希腊披萨 准备原材料 \");\n  \t}\n  }\n  //----------------------------------------------------\n  package com.atguigu.factory.simplefactory.pizzastore.pizza;\n  \n  public class CheesePizza extends Pizza {\n  \t@Override\n  \tpublic void prepare() {\n  \t\tSystem.out.println(\" 给制作奶酪披萨 准备原材料 \");\n  \t}\n  }\n  \n  \n  ```\n\n  简单的工厂类：因为工厂类中可以使用一般方法，也可以使用静态方法，代码中两种都实现了：\n\n  ```java\n  package com.atguigu.factory.simplefactory.pizzastore.order;\n  \n  import com.atguigu.factory.simplefactory.pizzastore.pizza.CheesePizza;\n  import com.atguigu.factory.simplefactory.pizzastore.pizza.GreekPizza;\n  import com.atguigu.factory.simplefactory.pizzastore.pizza.PepperPizza;\n  import com.atguigu.factory.simplefactory.pizzastore.pizza.Pizza;\n  \n  //简单工厂类\n  public class SimpleFactory {\n  \n  \t//更加orderType 返回对应的Pizza 对象\n  \tpublic Pizza createPizza(String orderType) {\n  \n  \t\tPizza pizza = null;\n  \n  \t\tSystem.out.println(\"使用简单工厂模式\");\n  \t\tif (orderType.equals(\"greek\")) {\n  \t\t\tpizza = new GreekPizza();\n  \t\t\tpizza.setName(\" 希腊披萨 \");\n  \t\t} else if (orderType.equals(\"cheese\")) {\n  \t\t\tpizza = new CheesePizza();\n  \t\t\tpizza.setName(\" 奶酪披萨 \");\n  \t\t} else if (orderType.equals(\"pepper\")) {\n  \t\t\tpizza = new PepperPizza();\n  \t\t\tpizza.setName(\"胡椒披萨\");\n  \t\t}\n  \t\treturn pizza;\n  \t}\n  \t\n  \t//简单工厂模式 也叫 静态工厂模式 \n  \t\n  \tpublic static Pizza createPizza2(String orderType) {\n  \t\tPizza pizza = null;\n  \n  \t\tSystem.out.println(\"使用简单工厂模式2\");\n  \t\tif (orderType.equals(\"greek\")) {\n  \t\t\tpizza = new GreekPizza();\n  \t\t\tpizza.setName(\" 希腊披萨 \");\n  \t\t} else if (orderType.equals(\"cheese\")) {\n  \t\t\tpizza = new CheesePizza();\n  \t\t\tpizza.setName(\" 奶酪披萨 \");\n  \t\t} else if (orderType.equals(\"pepper\")) {\n  \t\t\tpizza = new PepperPizza();\n  \t\t\tpizza.setName(\"胡椒披萨\");\n  \t\t}\n  \t\treturn pizza;\n  \t}\n  }\n  \n  ```\n\n  一般工厂方法对应的 Order 程序：\n\n  ```java\n  package com.atguigu.factory.simplefactory.pizzastore.order;\n  \n  import java.io.BufferedReader;\n  import java.io.IOException;\n  import java.io.InputStreamReader;\n  \n  \n  import com.atguigu.factory.simplefactory.pizzastore.pizza.Pizza;\n  \n  public class OrderPizza {\n  \t//定义一个简单工厂对象\n  \tSimpleFactory simpleFactory;\n  \tPizza pizza = null;\n  \t\n  \t//构造器\n  \tpublic OrderPizza(SimpleFactory simpleFactory) {\n  \t\tsetFactory(simpleFactory);\n  \t}\n  \t\n  \tpublic void setFactory(SimpleFactory simpleFactory) {\n  \t\tString orderType = \"\"; //用户输入的\n  \t\t\n  \t\tthis.simpleFactory = simpleFactory; //设置简单工厂对象\n  \t\t\n  \t\tdo {\n  \t\t\torderType = getType(); \n  \t\t\tpizza = this.simpleFactory.createPizza(orderType);\n  \t\t\t\n  \t\t\t//输出pizza\n  \t\t\tif(pizza != null) { //订购成功\n  \t\t\t\tpizza.prepare();\n  \t\t\t\tpizza.bake();\n  \t\t\t\tpizza.cut();\n  \t\t\t\tpizza.box();\n  \t\t\t} else {\n  \t\t\t\tSystem.out.println(\" 订购披萨失败 \");\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}while(true);\n  \t}\n  \t\n  \t// 写一个方法，可以获取客户希望订购的披萨种类\n  \tprivate String getType() {\n  \t\ttry {\n  \t\t\tBufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n  \t\t\tSystem.out.println(\"input pizza 种类:\");\n  \t\t\tString str = strin.readLine();\n  \t\t\treturn str;\n  \t\t} catch (IOException e) {\n  \t\t\te.printStackTrace();\n  \t\t\treturn \"\";\n  \t\t}\n  \t}\n  }\n  \n  ```\n\n  静态工厂对应的 ORDER 方法：\n\n  ```java\n  package com.atguigu.factory.simplefactory.pizzastore.order;\n  \n  import java.io.BufferedReader;\n  import java.io.IOException;\n  import java.io.InputStreamReader;\n  \n  import com.atguigu.factory.simplefactory.pizzastore.pizza.Pizza;\n  \n  public class OrderPizza2 {\n  \n  \tPizza pizza = null;\n  \tString orderType = \"\";\n  \t// 构造器\n  \tpublic OrderPizza2() {\n  \t\t\n  \t\tdo {\n  \t\t\torderType = getType();\n  \t\t\tpizza = SimpleFactory.createPizza2(orderType);\n  \n  \t\t\t// 输出pizza\n  \t\t\tif (pizza != null) { // 订购成功\n  \t\t\t\tpizza.prepare();\n  \t\t\t\tpizza.bake();\n  \t\t\t\tpizza.cut();\n  \t\t\t\tpizza.box();\n  \t\t\t} else {\n  \t\t\t\tSystem.out.println(\" 订购披萨失败 \");\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t} while (true);\n  \t}\n  \n  \t// 写一个方法，可以获取客户希望订购的披萨种类\n  \tprivate String getType() {\n  \t\ttry {\n  \t\t\tBufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n  \t\t\tSystem.out.println(\"input pizza 种类:\");\n  \t\t\tString str = strin.readLine();\n  \t\t\treturn str;\n  \t\t} catch (IOException e) {\n  \t\t\te.printStackTrace();\n  \t\t\treturn \"\";\n  \t\t}\n  \t}\n  }\n  \n  ```\n\n  执行测试上面方法：\n\n```java\npackage com.atguigu.factory.simplefactory.pizzastore.order;\n\n//相当于一个客户端，发出订购\npublic class PizzaStore {\n    public static void main(String[] args) {\n\t\t// 使用简单工厂模式\n        new OrderPizza(new SimpleFactory());\n        // 使用静态工厂模式\n        new OrderPizza2();\n    }\n}\n\n```\n\n\n\n## 二、工厂方法模式\n\n==部分抽象==\n\n### （一）看一个新的需求\n\n披萨项目新的需求：客户在点披萨时，可以点**不同口味的披萨**，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza。\n\n-  思路 1\n\n使用**简单工厂模式**，创建**不同的简单工厂类**，比如 BJPizzaSimpleFactory、LDPizzaSimpleFactory 等等.从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好\n\n- 思路 2\n\n使用工厂方法模式\n\n### （二）工厂方法模式介绍\n\n- 工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。\n\n- 工厂方法模式：**定义了一个创建对象的抽象方法**，由子**类决定要实例化的类**。工厂方法模式将**对象的实例化推迟到子类**。\n\n### （三）工厂方法模式应用案例\n\n1) 披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza\n\n2) 思路分析图解\n\n![工厂方法模式](%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.resource/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.jpg)\n\n- 看老师代码实现\n\n下面是 Pizza 抽象类和三个具体的实现类\n\n```java\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\n//将Pizza 类做成抽象\npublic abstract class Pizza {\n\tprotected String name; //名字\n\n\t//准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n\tpublic abstract void prepare();\n\n\tpublic void bake() {\n\t\tSystem.out.println(name + \" baking;\");\n\t}\n\n\tpublic void cut() {\n\t\tSystem.out.println(name + \" cutting;\");\n\t}\n\n\t//打包\n\tpublic void box() {\n\t\tSystem.out.println(name + \" boxing;\");\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}\n\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\npublic class BJCheesePizza extends Pizza {\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"北京的奶酪pizza\");\n\t\tSystem.out.println(\" 北京的奶酪pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\npublic class BJPepperPizza extends Pizza {\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"北京的胡椒pizza\");\n\t\tSystem.out.println(\" 北京的胡椒pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\npublic class LDCheesePizza extends Pizza{\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"伦敦的奶酪pizza\");\n\t\tSystem.out.println(\" 伦敦的奶酪pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\npublic class LDPepperPizza extends Pizza{\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"伦敦的胡椒pizza\");\n\t\tSystem.out.println(\" 伦敦的胡椒pizza 准备原材料\");\n\t}\n}\n\n```\n\n具体的工厂实现\n\n```java\npackage com.atguigu.factory.factorymethod.pizzastore.order;\n\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.BJCheesePizza;\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.BJPepperPizza;\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.Pizza;\n\npublic class BJOrderPizza extends OrderPizza {\n\t@Override\n\tPizza createPizza(String orderType) {\n\t\n\t\tPizza pizza = null;\n\t\tif(orderType.equals(\"cheese\")) {\n\t\t\tpizza = new BJCheesePizza();\n\t\t} else if (orderType.equals(\"pepper\")) {\n\t\t\tpizza = new BJPepperPizza();\n\t\t}\n\t\treturn pizza;\n\t}\n}\n\n//----------------------------------------------------\npackage com.atguigu.factory.factorymethod.pizzastore.order;\n\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.BJCheesePizza;\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.BJPepperPizza;\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.LDCheesePizza;\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.LDPepperPizza;\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.Pizza;\n\npublic class LDOrderPizza extends OrderPizza {\n\t@Override\n\tPizza createPizza(String orderType) {\n\t\n\t\tPizza pizza = null;\n\t\tif(orderType.equals(\"cheese\")) {\n\t\t\tpizza = new LDCheesePizza();\n\t\t} else if (orderType.equals(\"pepper\")) {\n\t\t\tpizza = new LDPepperPizza();\n\t\t}\n\t\treturn pizza;\n\t}\n}\n\n```\n\n订购 Order \n\n```java\npackage com.atguigu.factory.factorymethod.pizzastore.order;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.Pizza;\n\npublic abstract class OrderPizza {\n\n    //定义一个抽象方法，createPizza , 让各个工厂子类自己实现\n    abstract Pizza createPizza(String orderType);\n\t\n    // 构造器\n    public OrderPizza() {\n        Pizza pizza = null;\n        String orderType; // 订购披萨的类型\n        do {\n            orderType = getType();\n            pizza = createPizza(orderType); //抽象方法，由工厂子类完成\n            //输出pizza 制作过程\n            pizza.prepare();\n            pizza.bake();\n            pizza.cut();\n            pizza.box();\n\n        } while (true);\n    }\n\n    // 写一个方法，可以获取客户希望订购的披萨种类\n    private String getType() {\n        try {\n            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n            System.out.println(\"input pizza 种类:\");\n            String str = strin.readLine();\n            return str;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n}\n```\n\n测试方法\n\n```java\npackage com.atguigu.factory.factorymethod.pizzastore.order;\n\npublic class PizzaStore {\n    public static void main(String[] args) {\n        String loc = \"bj\";\n        if (loc.equals(\"bj\")) {\n            //创建北京口味的各种Pizza\n            new BJOrderPizza();\n        } else {\n            //创建伦敦口味的各种Pizza\n            new LDOrderPizza();\n        }\n    }\n}\n```\n\n\n\n## 三、抽象工厂模式\n\n==完全抽象==\n\n### （一）基本介绍\n\n- 抽象工厂模式：定义了一个 **interface** **用于创建相关或有依赖关系的对象簇**，而无需指明具体的类\n\n-  抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。\n\n- 从设计层面看，**抽象工厂模式就是对简单工厂模式的改进**(或者称为进一步的抽象)。\n\n- 将工厂抽象成**两层**，**AbsFactory(抽象工厂) 和 具体实现的工厂子类**。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。\n\n5) 类图\n\n![抽象工厂模式](%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.resource/抽象工厂模式.png)\n\n### （二）抽象工厂模式应用实例\n\n下面是 Pizza 抽象类和三个具体的实现类\n\n```java\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\n//将Pizza 类做成抽象\npublic abstract class Pizza {\n\tprotected String name; //名字\n\n\t//准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n\tpublic abstract void prepare();\n\n\tpublic void bake() {\n\t\tSystem.out.println(name + \" baking;\");\n\t}\n\n\tpublic void cut() {\n\t\tSystem.out.println(name + \" cutting;\");\n\t}\n\n\t//打包\n\tpublic void box() {\n\t\tSystem.out.println(name + \" boxing;\");\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}\n\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\npublic class BJCheesePizza extends Pizza {\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"北京的奶酪pizza\");\n\t\tSystem.out.println(\" 北京的奶酪pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\npublic class BJPepperPizza extends Pizza {\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"北京的胡椒pizza\");\n\t\tSystem.out.println(\" 北京的胡椒pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\npublic class LDCheesePizza extends Pizza{\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"伦敦的奶酪pizza\");\n\t\tSystem.out.println(\" 伦敦的奶酪pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\npublic class LDPepperPizza extends Pizza{\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"伦敦的胡椒pizza\");\n\t\tSystem.out.println(\" 伦敦的胡椒pizza 准备原材料\");\n\t}\n}\n\n```\n\n工厂抽象化和具体的工厂实现\n\n```java\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\nimport com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;\n\n//一个抽象工厂模式的抽象层(接口)\npublic interface AbsFactory {\n\t//让下面的工厂子类来 具体实现\n\tpublic Pizza createPizza(String orderType);\n}\n\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\nimport com.atguigu.factory.absfactory.pizzastore.pizza.BJCheesePizza;\nimport com.atguigu.factory.absfactory.pizzastore.pizza.BJPepperPizza;\nimport com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;\n\n//这是工厂子类\npublic class BJFactory implements AbsFactory {\n\t@Override\n\tpublic Pizza createPizza(String orderType) {\n\t\tSystem.out.println(\"~使用的是抽象工厂模式~\");\n\t\tPizza pizza = null;\n\t\tif(orderType.equals(\"cheese\")) {\n\t\t\tpizza = new BJCheesePizza();\n\t\t} else if (orderType.equals(\"pepper\")){\n\t\t\tpizza = new BJPepperPizza();\n\t\t}\n\t\treturn pizza;\n\t}\n}\n\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\nimport com.atguigu.factory.absfactory.pizzastore.pizza.LDCheesePizza;\nimport com.atguigu.factory.absfactory.pizzastore.pizza.LDPepperPizza;\nimport com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;\n\npublic class LDFactory implements AbsFactory {\n\t@Override\n\tpublic Pizza createPizza(String orderType) {\n\t\tSystem.out.println(\"~使用的是抽象工厂模式~\");\n\t\tPizza pizza = null;\n\t\tif (orderType.equals(\"cheese\")) {\n\t\t\tpizza = new LDCheesePizza();\n\t\t} else if (orderType.equals(\"pepper\")) {\n\t\t\tpizza = new LDPepperPizza();\n\t\t}\n\t\treturn pizza;\n\t}\n}\n\n```\n\n订购 Order \n\n```java\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;\n\npublic class OrderPizza {\n\n\tAbsFactory factory;\n\n\t// 构造器\n\tpublic OrderPizza(AbsFactory factory) {\n\t\tsetFactory(factory);\n\t}\n\n\tprivate void setFactory(AbsFactory factory) {\n\t\tPizza pizza = null;\n\t\tString orderType = \"\"; // 用户输入\n\t\tthis.factory = factory;\n\t\tdo {\n\t\t\torderType = getType();\n\t\t\t// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类\n\t\t\tpizza = factory.createPizza(orderType);\n\t\t\tif (pizza != null) { // 订购ok\n\t\t\t\tpizza.prepare();\n\t\t\t\tpizza.bake();\n\t\t\t\tpizza.cut();\n\t\t\t\tpizza.box();\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"订购失败\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (true);\n\t}\n\n\t// 写一个方法，可以获取客户希望订购的披萨种类\n\tprivate String getType() {\n\t\ttry {\n\t\t\tBufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tSystem.out.println(\"input pizza 种类:\");\n\t\t\tString str = strin.readLine();\n\t\t\treturn str;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"\";\n\t\t}\n\t}\n}\n\n```\n\n测试方法\n\n```java\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\npublic class PizzaStore {\n\n\tpublic static void main(String[] args) {\n\t\t//new OrderPizza(new BJFactory());\n\t\tnew OrderPizza(new LDFactory());\n\t}\n}\n\n```\n\n\n\n\n\n\n\n\n\n## （四）工厂模式在 JDK-Calendar 应用的源码分析\n\n1) JDK 中的 Calendar 类中，就使用了简单工厂模式\n\n\n\n## （五）工厂模式小结\n\n- 工厂模式的意义\n\n将实例化对象的代码提取出来，放到一个类（工厂类）中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。\n\n- 三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)\n\n- 设计模式的依赖抽象原则\n  - 创建对象实例时，不要直接 new 类（使用工厂获取）, 而是把这个 new 类的动作放在一个工厂的方法中，并返回。有的书上说， 变量不要直接持有具体类的引用。\n  - 不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)- \n  -  不要覆盖基类中已经实现的方法。",[[1573612627122,["GJX@GJXAIOU",[[-1,2339,"  "]],[2341,2341],[2339,2339]]]],null,"GJX@GJXAIOU"],["da33c078-23ca-4fa8-af75-fe9d2e9b6a50",1573826360702,"# 第六章：工厂模式\n\n## 一、简单工厂模式\n\n### （一）看一个具体的需求\n\n看一个披萨的项目：要便于披萨种类的扩展，要便于维护\n- 披萨的种类很多(比如 GreekPizz、CheesePizz 等)\n- 披萨的制作步骤有： prepare，bake, cut, box\n- 完成披萨店订购功能。\n\n### （二）使用传统的方式来完成\n\n- 思路分析(类图)\n\n![传统思路]($resource/%E4%BC%A0%E7%BB%9F%E6%80%9D%E8%B7%AF.jpg)\n\n2) 看老师代码的演示\n\n```java\npublic abstract class Pizza{\n    protect String name;\n    // 因为不同的 Pizza 准备方法不同，因此做成抽象方法\n    public abstract void perpard();\n    public void bake(){\n        // XXXXX\n    }\n    public void cut(){\n        // XXXXX\n    }\n    public void box(){\n        // XXXXX\n    }\n}\n//-------------------------------------------------------\n// 然后具体的 Pizza 实体继承 Pizza\npublic void CheessPizza extends Pizza(){\n    //实现 prepare 方法\n}\n//-------------------------------------------------------\npublic void GreekPizza extends Pizza(){\n    //实现 prepare 方法\n}\n\n//-------------------------------------------------------\n// 然后实现最终的 OrderPizza 类\npublic class OrderPizza {\n\t// 构造器\n\tpublic OrderPizza() {\n\t\tPizza pizza = null;\n\t\tString orderType; //  订购披萨的类型\n\t\tdo {\n\t\t\torderType = getType();\n\t\t\tif (orderType.equals(\"greek\")) {\n\t\t\t\tpizza = new GreekPizza();\n\t\t\t\tpizza.setName(\" 希腊披萨 \");\n\t\t\t} else if (orderType.equals(\"cheese\")) {\n\t\t\t\tpizza = new CheesePizza();\n\t\t\t\tpizza.setName(\" 奶酪披萨 \");\n\t\t\t} else if (orderType.equals(\"pepper\")) {\n\t\t\t\tpizza = new PepperPizza();\n\t\t\t\tpizza.setName(\"胡椒披萨\");\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//输出 pizza 制作过程\n\t\t\tpizza.prepare();\n\t\t\tpizza.bake();\n\t\t\tpizza.cut();\n\t\t\tpizza.box();\n\n\t\t} while (true);\n\t}\n```\n\n\n### （三）传统的方式的优缺点\n\n- 优点是比较好理解，简单易操作。\n\n- 缺点是违反了设计模式的 **ocp** **原则**，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.\n\n- 比如我们这时**要新增加一个** **Pizza** 的种类(Peppe披萨)，我们需要做如下修改. 如果我们增加一个 Pizza 类，只要是订购 Pizza 的代码都需要修改。\n\n- 改进的思路分析\n\n  - 分析：修改代码可以接受，但是如果我们在其它的地方也有创建 Pizza 的代码，就意味着，也需要修改，而创建 Pizza的代码，往往有多处。\n\n  - 思路：**把创建** **Pizza** **对象封装到一个类中，这样我们有新的** **Pizza** **种类时，只需要修改该类就可**，其它有创建到 Pizza对象的代码就不需要修改了.-> **简单工厂**模式\n\n### （四）基本介绍\n\n- 简单工厂模式是属于**创建型模式**，是工厂模式的一种。简单工厂（静态工厂）模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是**工厂模式家族中最简单实用的**模式；\n\n- 简单工厂模式：定义了一个创建对象的类，由这个类来**封装实例化对象的行为**(代码)；\n\n- 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式；\n\n### 6.1.5 使用简单工厂模式\n\n1) 简单工厂模式的设计方案: 定义一个可以实例化 Pizaa 对象的类，封装创建对象的代码。\n\n![简单工厂模式](%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.resource/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png)\n\n\n\n- 看代码示例\n\n  下面是 Pizza 抽象类和三个具体的实现类\n\n```java\n  package com.atguigu.factory.simplefactory.pizzastore.pizza;\n  \n  //将Pizza 类做成抽象\n  public abstract class Pizza {\n  \tprotected String name; //名字\n  \n  \t//准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n  \tpublic abstract void prepare();\n  \n  \t\n  \tpublic void bake() {\n  \t\tSystem.out.println(name + \" baking;\");\n  \t}\n  \n  \tpublic void cut() {\n  \t\tSystem.out.println(name + \" cutting;\");\n  \t}\n  \n  \t//打包\n  \tpublic void box() {\n  \t\tSystem.out.println(name + \" boxing;\");\n  \t}\n  \n  \tpublic void setName(String name) {\n  \t\tthis.name = name;\n  \t}\n  }\n  \n  //----------------------------------------------------\n  package com.atguigu.factory.simplefactory.pizzastore.pizza;\n  \n  public class CheesePizza extends Pizza {\n  \t@Override\n  \tpublic void prepare() {\n  \t\tSystem.out.println(\" 给制作奶酪披萨 准备原材料 \");\n  \t}\n  }\n  //----------------------------------------------------\n  package com.atguigu.factory.simplefactory.pizzastore.pizza;\n  public class GreekPizza extends Pizza {\n  \t@Override\n  \tpublic void prepare() {\n  \t\tSystem.out.println(\" 给希腊披萨 准备原材料 \");\n  \t}\n  }\n  //----------------------------------------------------\n  package com.atguigu.factory.simplefactory.pizzastore.pizza;\n  \n  public class CheesePizza extends Pizza {\n  \t@Override\n  \tpublic void prepare() {\n  \t\tSystem.out.println(\" 给制作奶酪披萨 准备原材料 \");\n  \t}\n  }\n  \n  \n  ```\n\n  简单的工厂类：因为工厂类中可以使用一般方法，也可以使用静态方法，代码中两种都实现了：\n\n  ```java\n  package com.atguigu.factory.simplefactory.pizzastore.order;\n  \n  import com.atguigu.factory.simplefactory.pizzastore.pizza.CheesePizza;\n  import com.atguigu.factory.simplefactory.pizzastore.pizza.GreekPizza;\n  import com.atguigu.factory.simplefactory.pizzastore.pizza.PepperPizza;\n  import com.atguigu.factory.simplefactory.pizzastore.pizza.Pizza;\n  \n  //简单工厂类\n  public class SimpleFactory {\n  \n  \t//更加orderType 返回对应的Pizza 对象\n  \tpublic Pizza createPizza(String orderType) {\n  \n  \t\tPizza pizza = null;\n  \n  \t\tSystem.out.println(\"使用简单工厂模式\");\n  \t\tif (orderType.equals(\"greek\")) {\n  \t\t\tpizza = new GreekPizza();\n  \t\t\tpizza.setName(\" 希腊披萨 \");\n  \t\t} else if (orderType.equals(\"cheese\")) {\n  \t\t\tpizza = new CheesePizza();\n  \t\t\tpizza.setName(\" 奶酪披萨 \");\n  \t\t} else if (orderType.equals(\"pepper\")) {\n  \t\t\tpizza = new PepperPizza();\n  \t\t\tpizza.setName(\"胡椒披萨\");\n  \t\t}\n  \t\treturn pizza;\n  \t}\n  \t\n  \t//简单工厂模式 也叫 静态工厂模式 \n  \t\n  \tpublic static Pizza createPizza2(String orderType) {\n  \t\tPizza pizza = null;\n  \n  \t\tSystem.out.println(\"使用简单工厂模式2\");\n  \t\tif (orderType.equals(\"greek\")) {\n  \t\t\tpizza = new GreekPizza();\n  \t\t\tpizza.setName(\" 希腊披萨 \");\n  \t\t} else if (orderType.equals(\"cheese\")) {\n  \t\t\tpizza = new CheesePizza();\n  \t\t\tpizza.setName(\" 奶酪披萨 \");\n  \t\t} else if (orderType.equals(\"pepper\")) {\n  \t\t\tpizza = new PepperPizza();\n  \t\t\tpizza.setName(\"胡椒披萨\");\n  \t\t}\n  \t\treturn pizza;\n  \t}\n  }\n  \n  ```\n\n  一般工厂方法对应的 Order 程序：\n\n  ```java\n  package com.atguigu.factory.simplefactory.pizzastore.order;\n  \n  import java.io.BufferedReader;\n  import java.io.IOException;\n  import java.io.InputStreamReader;\n  \n  \n  import com.atguigu.factory.simplefactory.pizzastore.pizza.Pizza;\n  \n  public class OrderPizza {\n  \t//定义一个简单工厂对象\n  \tSimpleFactory simpleFactory;\n  \tPizza pizza = null;\n  \t\n  \t//构造器\n  \tpublic OrderPizza(SimpleFactory simpleFactory) {\n  \t\tsetFactory(simpleFactory);\n  \t}\n  \t\n  \tpublic void setFactory(SimpleFactory simpleFactory) {\n  \t\tString orderType = \"\"; //用户输入的\n  \t\t\n  \t\tthis.simpleFactory = simpleFactory; //设置简单工厂对象\n  \t\t\n  \t\tdo {\n  \t\t\torderType = getType(); \n  \t\t\tpizza = this.simpleFactory.createPizza(orderType);\n  \t\t\t\n  \t\t\t//输出pizza\n  \t\t\tif(pizza != null) { //订购成功\n  \t\t\t\tpizza.prepare();\n  \t\t\t\tpizza.bake();\n  \t\t\t\tpizza.cut();\n  \t\t\t\tpizza.box();\n  \t\t\t} else {\n  \t\t\t\tSystem.out.println(\" 订购披萨失败 \");\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}while(true);\n  \t}\n  \t\n  \t// 写一个方法，可以获取客户希望订购的披萨种类\n  \tprivate String getType() {\n  \t\ttry {\n  \t\t\tBufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n  \t\t\tSystem.out.println(\"input pizza 种类:\");\n  \t\t\tString str = strin.readLine();\n  \t\t\treturn str;\n  \t\t} catch (IOException e) {\n  \t\t\te.printStackTrace();\n  \t\t\treturn \"\";\n  \t\t}\n  \t}\n  }\n  \n  ```\n\n  静态工厂对应的 ORDER 方法：\n\n  ```java\n  package com.atguigu.factory.simplefactory.pizzastore.order;\n  \n  import java.io.BufferedReader;\n  import java.io.IOException;\n  import java.io.InputStreamReader;\n  \n  import com.atguigu.factory.simplefactory.pizzastore.pizza.Pizza;\n  \n  public class OrderPizza2 {\n  \n  \tPizza pizza = null;\n  \tString orderType = \"\";\n  \t// 构造器\n  \tpublic OrderPizza2() {\n  \t\t\n  \t\tdo {\n  \t\t\torderType = getType();\n  \t\t\tpizza = SimpleFactory.createPizza2(orderType);\n  \n  \t\t\t// 输出pizza\n  \t\t\tif (pizza != null) { // 订购成功\n  \t\t\t\tpizza.prepare();\n  \t\t\t\tpizza.bake();\n  \t\t\t\tpizza.cut();\n  \t\t\t\tpizza.box();\n  \t\t\t} else {\n  \t\t\t\tSystem.out.println(\" 订购披萨失败 \");\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t} while (true);\n  \t}\n  \n  \t// 写一个方法，可以获取客户希望订购的披萨种类\n  \tprivate String getType() {\n  \t\ttry {\n  \t\t\tBufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n  \t\t\tSystem.out.println(\"input pizza 种类:\");\n  \t\t\tString str = strin.readLine();\n  \t\t\treturn str;\n  \t\t} catch (IOException e) {\n  \t\t\te.printStackTrace();\n  \t\t\treturn \"\";\n  \t\t}\n  \t}\n  }\n  \n  ```\n\n  执行测试上面方法：\n\n```java\npackage com.atguigu.factory.simplefactory.pizzastore.order;\n\n//相当于一个客户端，发出订购\npublic class PizzaStore {\n    public static void main(String[] args) {\n\t\t// 使用简单工厂模式\n        new OrderPizza(new SimpleFactory());\n        // 使用静态工厂模式\n        new OrderPizza2();\n    }\n}\n\n```\n\n\n\n## 二、工厂方法模式\n\n==部分抽象==\n\n### （一）看一个新的需求\n\n披萨项目新的需求：客户在点披萨时，可以点**不同口味的披萨**，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza。\n\n-  思路 1\n\n使用**简单工厂模式**，创建**不同的简单工厂类**，比如 BJPizzaSimpleFactory、LDPizzaSimpleFactory 等等.从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好\n\n- 思路 2\n\n使用工厂方法模式\n\n### （二）工厂方法模式介绍\n\n- 工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。\n\n- 工厂方法模式：**定义了一个创建对象的抽象方法**，由子**类决定要实例化的类**。工厂方法模式将**对象的实例化推迟到子类**。\n\n### （三）工厂方法模式应用案例\n\n1) 披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza\n\n2) 思路分析图解\n\n![工厂方法模式](%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.resource/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.jpg)\n\n- 看老师代码实现\n\n下面是 Pizza 抽象类和三个具体的实现类\n\n```java\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\n//将Pizza 类做成抽象\npublic abstract class Pizza {\n\tprotected String name; //名字\n\n\t//准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n\tpublic abstract void prepare();\n\n\tpublic void bake() {\n\t\tSystem.out.println(name + \" baking;\");\n\t}\n\n\tpublic void cut() {\n\t\tSystem.out.println(name + \" cutting;\");\n\t}\n\n\t//打包\n\tpublic void box() {\n\t\tSystem.out.println(name + \" boxing;\");\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}\n\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\npublic class BJCheesePizza extends Pizza {\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"北京的奶酪pizza\");\n\t\tSystem.out.println(\" 北京的奶酪pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\npublic class BJPepperPizza extends Pizza {\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"北京的胡椒pizza\");\n\t\tSystem.out.println(\" 北京的胡椒pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\npublic class LDCheesePizza extends Pizza{\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"伦敦的奶酪pizza\");\n\t\tSystem.out.println(\" 伦敦的奶酪pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\npublic class LDPepperPizza extends Pizza{\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"伦敦的胡椒pizza\");\n\t\tSystem.out.println(\" 伦敦的胡椒pizza 准备原材料\");\n\t}\n}\n\n```\n\n具体的工厂实现\n\n```java\npackage com.atguigu.factory.factorymethod.pizzastore.order;\n\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.BJCheesePizza;\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.BJPepperPizza;\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.Pizza;\n\npublic class BJOrderPizza extends OrderPizza {\n\t@Override\n\tPizza createPizza(String orderType) {\n\t\n\t\tPizza pizza = null;\n\t\tif(orderType.equals(\"cheese\")) {\n\t\t\tpizza = new BJCheesePizza();\n\t\t} else if (orderType.equals(\"pepper\")) {\n\t\t\tpizza = new BJPepperPizza();\n\t\t}\n\t\treturn pizza;\n\t}\n}\n\n//----------------------------------------------------\npackage com.atguigu.factory.factorymethod.pizzastore.order;\n\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.BJCheesePizza;\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.BJPepperPizza;\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.LDCheesePizza;\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.LDPepperPizza;\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.Pizza;\n\npublic class LDOrderPizza extends OrderPizza {\n\t@Override\n\tPizza createPizza(String orderType) {\n\t\n\t\tPizza pizza = null;\n\t\tif(orderType.equals(\"cheese\")) {\n\t\t\tpizza = new LDCheesePizza();\n\t\t} else if (orderType.equals(\"pepper\")) {\n\t\t\tpizza = new LDPepperPizza();\n\t\t}\n\t\treturn pizza;\n\t}\n}\n\n```\n\n订购 Order \n\n```java\npackage com.atguigu.factory.factorymethod.pizzastore.order;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport com.atguigu.factory.factorymethod.pizzastore.pizza.Pizza;\n\npublic abstract class OrderPizza {\n\n    //定义一个抽象方法，createPizza , 让各个工厂子类自己实现\n    abstract Pizza createPizza(String orderType);\n\t\n    // 构造器\n    public OrderPizza() {\n        Pizza pizza = null;\n        String orderType; // 订购披萨的类型\n        do {\n            orderType = getType();\n            pizza = createPizza(orderType); //抽象方法，由工厂子类完成\n            //输出pizza 制作过程\n            pizza.prepare();\n            pizza.bake();\n            pizza.cut();\n            pizza.box();\n\n        } while (true);\n    }\n\n    // 写一个方法，可以获取客户希望订购的披萨种类\n    private String getType() {\n        try {\n            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n            System.out.println(\"input pizza 种类:\");\n            String str = strin.readLine();\n            return str;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n}\n```\n\n测试方法\n\n```java\npackage com.atguigu.factory.factorymethod.pizzastore.order;\n\npublic class PizzaStore {\n    public static void main(String[] args) {\n        String loc = \"bj\";\n        if (loc.equals(\"bj\")) {\n            //创建北京口味的各种Pizza\n            new BJOrderPizza();\n        } else {\n            //创建伦敦口味的各种Pizza\n            new LDOrderPizza();\n        }\n    }\n}\n```\n\n\n\n## 三、抽象工厂模式\n\n==完全抽象==\n\n### （一）基本介绍\n\n- 抽象工厂模式：定义了一个 **interface** **用于创建相关或有依赖关系的对象簇**，而无需指明具体的类\n\n-  抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。\n\n- 从设计层面看，**抽象工厂模式就是对简单工厂模式的改进**(或者称为进一步的抽象)。\n\n- 将工厂抽象成**两层**，**AbsFactory(抽象工厂) 和 具体实现的工厂子类**。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。\n\n5) 类图\n\n![抽象工厂模式](%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.resource/抽象工厂模式.png)\n\n### （二）抽象工厂模式应用实例\n\n下面是 Pizza 抽象类和三个具体的实现类\n\n```java\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\n//将Pizza 类做成抽象\npublic abstract class Pizza {\n\tprotected String name; //名字\n\n\t//准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n\tpublic abstract void prepare();\n\n\tpublic void bake() {\n\t\tSystem.out.println(name + \" baking;\");\n\t}\n\n\tpublic void cut() {\n\t\tSystem.out.println(name + \" cutting;\");\n\t}\n\n\t//打包\n\tpublic void box() {\n\t\tSystem.out.println(name + \" boxing;\");\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}\n\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\npublic class BJCheesePizza extends Pizza {\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"北京的奶酪pizza\");\n\t\tSystem.out.println(\" 北京的奶酪pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\npublic class BJPepperPizza extends Pizza {\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"北京的胡椒pizza\");\n\t\tSystem.out.println(\" 北京的胡椒pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\npublic class LDCheesePizza extends Pizza{\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"伦敦的奶酪pizza\");\n\t\tSystem.out.println(\" 伦敦的奶酪pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.pizza;\n\npublic class LDPepperPizza extends Pizza{\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"伦敦的胡椒pizza\");\n\t\tSystem.out.println(\" 伦敦的胡椒pizza 准备原材料\");\n\t}\n}\n\n```\n\n工厂抽象化和具体的工厂实现\n\n```java\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\nimport com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;\n\n//一个抽象工厂模式的抽象层(接口)\npublic interface AbsFactory {\n\t//让下面的工厂子类来 具体实现\n\tpublic Pizza createPizza(String orderType);\n}\n\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\nimport com.atguigu.factory.absfactory.pizzastore.pizza.BJCheesePizza;\nimport com.atguigu.factory.absfactory.pizzastore.pizza.BJPepperPizza;\nimport com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;\n\n//这是工厂子类\npublic class BJFactory implements AbsFactory {\n\t@Override\n\tpublic Pizza createPizza(String orderType) {\n\t\tSystem.out.println(\"~使用的是抽象工厂模式~\");\n\t\tPizza pizza = null;\n\t\tif(orderType.equals(\"cheese\")) {\n\t\t\tpizza = new BJCheesePizza();\n\t\t} else if (orderType.equals(\"pepper\")){\n\t\t\tpizza = new BJPepperPizza();\n\t\t}\n\t\treturn pizza;\n\t}\n}\n\n//----------------------------------------------------\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\nimport com.atguigu.factory.absfactory.pizzastore.pizza.LDCheesePizza;\nimport com.atguigu.factory.absfactory.pizzastore.pizza.LDPepperPizza;\nimport com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;\n\npublic class LDFactory implements AbsFactory {\n\t@Override\n\tpublic Pizza createPizza(String orderType) {\n\t\tSystem.out.println(\"~使用的是抽象工厂模式~\");\n\t\tPizza pizza = null;\n\t\tif (orderType.equals(\"cheese\")) {\n\t\t\tpizza = new LDCheesePizza();\n\t\t} else if (orderType.equals(\"pepper\")) {\n\t\t\tpizza = new LDPepperPizza();\n\t\t}\n\t\treturn pizza;\n\t}\n}\n\n```\n\n订购 Order \n\n```java\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport com.atguigu.factory.absfactory.pizzastore.pizza.Pizza;\n\npublic class OrderPizza {\n\n\tAbsFactory factory;\n\n\t// 构造器\n\tpublic OrderPizza(AbsFactory factory) {\n\t\tsetFactory(factory);\n\t}\n\n\tprivate void setFactory(AbsFactory factory) {\n\t\tPizza pizza = null;\n\t\tString orderType = \"\"; // 用户输入\n\t\tthis.factory = factory;\n\t\tdo {\n\t\t\torderType = getType();\n\t\t\t// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类\n\t\t\tpizza = factory.createPizza(orderType);\n\t\t\tif (pizza != null) { // 订购ok\n\t\t\t\tpizza.prepare();\n\t\t\t\tpizza.bake();\n\t\t\t\tpizza.cut();\n\t\t\t\tpizza.box();\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"订购失败\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (true);\n\t}\n\n\t// 写一个方法，可以获取客户希望订购的披萨种类\n\tprivate String getType() {\n\t\ttry {\n\t\t\tBufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tSystem.out.println(\"input pizza 种类:\");\n\t\t\tString str = strin.readLine();\n\t\t\treturn str;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"\";\n\t\t}\n\t}\n}\n\n```\n\n测试方法\n\n```java\npackage com.atguigu.factory.absfactory.pizzastore.order;\n\npublic class PizzaStore {\n\n\tpublic static void main(String[] args) {\n\t\t//new OrderPizza(new BJFactory());\n\t\tnew OrderPizza(new LDFactory());\n\t}\n}\n\n```\n\n\n\n\n\n\n\n\n\n## （四）工厂模式在 JDK-Calendar 应用的源码分析\n\n1) JDK 中的 Calendar 类中，就使用了简单工厂模式\n\n\n\n## （五）工厂模式小结\n\n- 工厂模式的意义\n\n将实例化对象的代码提取出来，放到一个类（工厂类）中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。\n\n- 三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)\n\n- 设计模式的依赖抽象原则\n  - 创建对象实例时，不要直接 new 类（使用工厂获取）, 而是把这个 new 类的动作放在一个工厂的方法中，并返回。有的书上说， 变量不要直接持有具体类的引用。\n  - 不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)- \n  -  不要覆盖基类中已经实现的方法。",[[1573826303088,["GJX@GJXAIOU",[[-1,2361,"atguig"],[1,2367,"gjxaio"]],[2361,2368],[2361,2368]]],[1573826303367,["GJX@GJXAIOU",[[-1,2945,"atguig"],[1,2951,"gjxaio"]],[2945,2952],[2945,2952]]],[1573826303595,["GJX@GJXAIOU",[[-1,3202,"atguig"],[1,3208,"gjxaio"]],[3202,3209],[3202,3209]]],[1573826303984,["GJX@GJXAIOU",[[-1,3453,"atguig"],[1,3459,"gjxaio"]],[3453,3460],[3453,3460]]],[1573826304126,["GJX@GJXAIOU",[[-1,3722,"atguig"],[1,3728,"gjxaio"]],[3722,3729],[3722,3729]]],[1573826304319,["GJX@GJXAIOU",[[-1,3786,"atguig"],[1,3792,"gjxaio"]],[3786,3793],[3786,3793]]],[1573826304530,["GJX@GJXAIOU",[[-1,3859,"atguig"],[1,3865,"gjxaio"]],[3859,3866],[3859,3866]]],[1573826304893,["GJX@GJXAIOU",[[-1,3931,"atguig"],[1,3937,"gjxaio"]],[3931,3938],[3931,3938]]],[1573826305084,["GJX@GJXAIOU",[[-1,4004,"atguig"],[1,4010,"gjxaio"]],[4004,4011],[4004,4011]]],[1573826305267,["GJX@GJXAIOU",[[-1,5140,"atguig"],[1,5146,"gjxaio"]],[5140,5147],[5140,5147]]],[1573826305461,["GJX@GJXAIOU",[[-1,5309,"atguig"],[1,5315,"gjxaio"]],[5309,5316],[5309,5316]]],[1573826306061,["GJX@GJXAIOU",[[-1,6439,"atguig"],[1,6445,"gjxaio"]],[6439,6446],[6439,6446]]],[1573826306209,["GJX@GJXAIOU",[[-1,6605,"atguig"],[1,6611,"gjxaio"]],[6605,6612],[6605,6612]]],[1573826306374,["GJX@GJXAIOU",[[-1,7484,"atguig"],[1,7490,"gjxaio"]],[7484,7491],[7484,7491]]],[1573826306503,["GJX@GJXAIOU",[[-1,8481,"atguig"],[1,8487,"gjxaio"]],[8481,8488],[8481,8488]]],[1573826306927,["GJX@GJXAIOU",[[-1,9002,"atguig"],[1,9008,"gjxaio"]],[9002,9009],[9002,9009]]],[1573826307246,["GJX@GJXAIOU",[[-1,9267,"atguig"],[1,9273,"gjxaio"]],[9267,9274],[9267,9274]]],[1573826308719,["GJX@GJXAIOU",[[-1,9532,"atguig"],[1,9538,"gjxaio"]],[9532,9539],[9532,9539]]],[1573826309374,["GJX@GJXAIOU",[[-1,9796,"atguig"],[1,9802,"gjxaio"]],[9796,9803],[9796,9803]]],[1573826309844,["GJX@GJXAIOU",[[-1,10028,"atguig"],[1,10034,"gjxaio"]],[10028,10035],[10028,10035]]],[1573826310232,["GJX@GJXAIOU",[[-1,10088,"atguig"],[1,10094,"gjxaio"]],[10088,10095],[10088,10095]]],[1573826310373,["GJX@GJXAIOU",[[-1,10161,"atguig"],[1,10167,"gjxaio"]],[10161,10168],[10161,10168]]],[1573826310869,["GJX@GJXAIOU",[[-1,10234,"atguig"],[1,10240,"gjxaio"]],[10234,10241],[10234,10241]]],[1573826311368,["GJX@GJXAIOU",[[-1,10645,"atguig"],[1,10651,"gjxaio"]],[10645,10652],[10645,10652]]],[1573826311800,["GJX@GJXAIOU",[[-1,10705,"atguig"],[1,10711,"gjxaio"]],[10705,10712],[10705,10712]]],[1573826312148,["GJX@GJXAIOU",[[-1,10778,"atguig"],[1,10784,"gjxaio"]],[10778,10785],[10778,10785]]],[1573826312312,["GJX@GJXAIOU",[[-1,10851,"atguig"],[1,10857,"gjxaio"]],[10851,10858],[10851,10858]]],[1573826312736,["GJX@GJXAIOU",[[-1,10924,"atguig"],[1,10930,"gjxaio"]],[10924,10931],[10924,10931]]],[1573826312898,["GJX@GJXAIOU",[[-1,10997,"atguig"],[1,11003,"gjxaio"]],[10997,11004],[10997,11004]]],[1573826313339,["GJX@GJXAIOU",[[-1,11377,"atguig"],[1,11383,"gjxaio"]],[11377,11384],[11377,11384]]],[1573826313585,["GJX@GJXAIOU",[[-1,11531,"atguig"],[1,11537,"gjxaio"]],[11531,11538],[11531,11538]]],[1573826313707,["GJX@GJXAIOU",[[-1,12508,"atguig"],[1,12514,"gjxaio"]],[12508,12515],[12508,12515]]],[1573826314082,["GJX@GJXAIOU",[[-1,13304,"atguig"],[1,13310,"gjxaio"]],[13304,13311],[13304,13311]]],[1573826314265,["GJX@GJXAIOU",[[-1,13825,"atguig"],[1,13831,"gjxaio"]],[13825,13832],[13825,13832]]],[1573826314384,["GJX@GJXAIOU",[[-1,14090,"atguig"],[1,14096,"gjxaio"]],[14090,14097],[14090,14097]]],[1573826314797,["GJX@GJXAIOU",[[-1,14355,"atguig"],[1,14361,"gjxaio"]],[14355,14362],[14355,14362]]],[1573826316127,["GJX@GJXAIOU",[[-1,14619,"atguig"],[1,14625,"gjxaio"]],[14619,14626],[14619,14626]]],[1573826316558,["GJX@GJXAIOU",[[-1,14857,"atguig"],[1,14863,"gjxaio"]],[14857,14864],[14857,14864]]],[1573826316943,["GJX@GJXAIOU",[[-1,14914,"atguig"],[1,14920,"gjxaio"]],[14914,14921],[14914,14921]]],[1573826317428,["GJX@GJXAIOU",[[-1,15148,"atguig"],[1,15154,"gjxaio"]],[15148,15155],[15148,15155]]],[1573826319671,["GJX@GJXAIOU",[[-1,15205,"atguig"],[1,15211,"gjxaio"]],[15205,15212],[15205,15212]]],[1573826320140,["GJX@GJXAIOU",[[-1,15275,"atguig"],[1,15281,"gjxaio"]],[15275,15282],[15275,15282]]],[1573826320274,["GJX@GJXAIOU",[[-1,15345,"atguig"],[1,15351,"gjxaio"]],[15345,15352],[15345,15352]]],[1573826320699,["GJX@GJXAIOU",[[-1,15804,"atguig"],[1,15810,"gjxaio"]],[15804,15811],[15804,15811]]],[1573826320854,["GJX@GJXAIOU",[[-1,15861,"atguig"],[1,15867,"gjxaio"]],[15861,15868],[15861,15868]]],[1573826321073,["GJX@GJXAIOU",[[-1,15931,"atguig"],[1,15937,"gjxaio"]],[15931,15938],[15931,15938]]],[1573826321490,["GJX@GJXAIOU",[[-1,16001,"atguig"],[1,16007,"gjxaio"]],[16001,16008],[16001,16008]]],[1573826321649,["GJX@GJXAIOU",[[-1,16422,"atguig"],[1,16428,"gjxaio"]],[16422,16429],[16422,16429]]],[1573826322111,["GJX@GJXAIOU",[[-1,16573,"atguig"],[1,16579,"gjxaio"]],[16573,16580],[16573,16580]]],[1573826322249,["GJX@GJXAIOU",[[-1,17518,"atguig"],[1,17524,"gjxaio"]],[17518,17525],[17518,17525]]]],null,"GJX@GJXAIOU"],["dd6eebf5-be54-4903-8a25-1511ad3b67c1",1573827444017,"# 第六章：工厂模式\n\n## 一、简单工厂模式\n\n### （一）看一个具体的需求\n\n看一个披萨的项目：要便于披萨种类的扩展，要便于维护\n- 披萨的种类很多(比如 GreekPizz、CheesePizz 等)\n- 披萨的制作步骤有： prepare，bake, cut, box\n- 完成披萨店订购功能。\n\n### （二）使用传统的方式来完成\n\n- 思路分析(类图)\n\n![传统思路]($resource/%E4%BC%A0%E7%BB%9F%E6%80%9D%E8%B7%AF.jpg)\n\n2) 看老师代码的演示\n\n```java\npublic abstract class Pizza{\n    protect String name;\n    // 因为不同的 Pizza 准备方法不同，因此做成抽象方法\n    public abstract void perpard();\n    public void bake(){\n        // XXXXX\n    }\n    public void cut(){\n        // XXXXX\n    }\n    public void box(){\n        // XXXXX\n    }\n}\n//-------------------------------------------------------\n// 然后具体的 Pizza 实体继承 Pizza\npublic void CheessPizza extends Pizza(){\n    //实现 prepare 方法\n}\n//-------------------------------------------------------\npublic void GreekPizza extends Pizza(){\n    //实现 prepare 方法\n}\n\n//-------------------------------------------------------\n// 然后实现最终的 OrderPizza 类\npublic class OrderPizza {\n\t// 构造器\n\tpublic OrderPizza() {\n\t\tPizza pizza = null;\n\t\tString orderType; //  订购披萨的类型\n\t\tdo {\n\t\t\torderType = getType();\n\t\t\tif (orderType.equals(\"greek\")) {\n\t\t\t\tpizza = new GreekPizza();\n\t\t\t\tpizza.setName(\" 希腊披萨 \");\n\t\t\t} else if (orderType.equals(\"cheese\")) {\n\t\t\t\tpizza = new CheesePizza();\n\t\t\t\tpizza.setName(\" 奶酪披萨 \");\n\t\t\t} else if (orderType.equals(\"pepper\")) {\n\t\t\t\tpizza = new PepperPizza();\n\t\t\t\tpizza.setName(\"胡椒披萨\");\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//输出 pizza 制作过程\n\t\t\tpizza.prepare();\n\t\t\tpizza.bake();\n\t\t\tpizza.cut();\n\t\t\tpizza.box();\n\n\t\t} while (true);\n\t}\n```\n\n\n### （三）传统的方式的优缺点\n\n- 优点是比较好理解，简单易操作。\n\n- 缺点是违反了设计模式的 **ocp** **原则**，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.\n\n- 比如我们这时**要新增加一个** **Pizza** 的种类(Peppe披萨)，我们需要做如下修改. 如果我们增加一个 Pizza 类，只要是订购 Pizza 的代码都需要修改。\n\n- 改进的思路分析\n\n  - 分析：修改代码可以接受，但是如果我们在其它的地方也有创建 Pizza 的代码，就意味着，也需要修改，而创建 Pizza的代码，往往有多处。\n\n  - 思路：**把创建** **Pizza** **对象封装到一个类中，这样我们有新的** **Pizza** **种类时，只需要修改该类就可**，其它有创建到 Pizza对象的代码就不需要修改了.-> **简单工厂**模式\n\n### （四）基本介绍\n\n- 简单工厂模式是属于**创建型模式**，是工厂模式的一种。简单工厂（静态工厂）模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是**工厂模式家族中最简单实用的**模式；\n\n- 简单工厂模式：定义了一个创建对象的类，由这个类来**封装实例化对象的行为**(代码)；\n\n- 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式；\n\n### 6.1.5 使用简单工厂模式\n\n1) 简单工厂模式的设计方案: 定义一个可以实例化 Pizaa 对象的类，封装创建对象的代码。\n\n![简单工厂模式](%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.resource/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png)\n\n\n\n- 看代码示例\n\n  下面是 Pizza 抽象类和三个具体的实现类\n\n```java\n  package com.gjxaiou.factory.simplefactory.pizzastore.pizza;\n  \n  //将Pizza 类做成抽象\n  public abstract class Pizza {\n  \tprotected String name; //名字\n  \n  \t//准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n  \tpublic abstract void prepare();\n  \n  \t\n  \tpublic void bake() {\n  \t\tSystem.out.println(name + \" baking;\");\n  \t}\n  \n  \tpublic void cut() {\n  \t\tSystem.out.println(name + \" cutting;\");\n  \t}\n  \n  \t//打包\n  \tpublic void box() {\n  \t\tSystem.out.println(name + \" boxing;\");\n  \t}\n  \n  \tpublic void setName(String name) {\n  \t\tthis.name = name;\n  \t}\n  }\n  \n  //----------------------------------------------------\n  package com.gjxaiou.factory.simplefactory.pizzastore.pizza;\n  \n  public class CheesePizza extends Pizza {\n  \t@Override\n  \tpublic void prepare() {\n  \t\tSystem.out.println(\" 给制作奶酪披萨 准备原材料 \");\n  \t}\n  }\n  //----------------------------------------------------\n  package com.gjxaiou.factory.simplefactory.pizzastore.pizza;\n  public class GreekPizza extends Pizza {\n  \t@Override\n  \tpublic void prepare() {\n  \t\tSystem.out.println(\" 给希腊披萨 准备原材料 \");\n  \t}\n  }\n  //----------------------------------------------------\n  package com.gjxaiou.factory.simplefactory.pizzastore.pizza;\n  \n  public class CheesePizza extends Pizza {\n  \t@Override\n  \tpublic void prepare() {\n  \t\tSystem.out.println(\" 给制作奶酪披萨 准备原材料 \");\n  \t}\n  }\n  \n  \n  ```\n\n  简单的工厂类：因为工厂类中可以使用一般方法，也可以使用静态方法，代码中两种都实现了：\n\n  ```java\n  package com.gjxaiou.factory.simplefactory.pizzastore.order;\n  \n  import com.gjxaiou.factory.simplefactory.pizzastore.pizza.CheesePizza;\n  import com.gjxaiou.factory.simplefactory.pizzastore.pizza.GreekPizza;\n  import com.gjxaiou.factory.simplefactory.pizzastore.pizza.PepperPizza;\n  import com.gjxaiou.factory.simplefactory.pizzastore.pizza.Pizza;\n  \n  //简单工厂类\n  public class SimpleFactory {\n  \n  \t//更加orderType 返回对应的Pizza 对象\n  \tpublic Pizza createPizza(String orderType) {\n  \n  \t\tPizza pizza = null;\n  \n  \t\tSystem.out.println(\"使用简单工厂模式\");\n  \t\tif (orderType.equals(\"greek\")) {\n  \t\t\tpizza = new GreekPizza();\n  \t\t\tpizza.setName(\" 希腊披萨 \");\n  \t\t} else if (orderType.equals(\"cheese\")) {\n  \t\t\tpizza = new CheesePizza();\n  \t\t\tpizza.setName(\" 奶酪披萨 \");\n  \t\t} else if (orderType.equals(\"pepper\")) {\n  \t\t\tpizza = new PepperPizza();\n  \t\t\tpizza.setName(\"胡椒披萨\");\n  \t\t}\n  \t\treturn pizza;\n  \t}\n  \t\n  \t//简单工厂模式 也叫 静态工厂模式 \n  \t\n  \tpublic static Pizza createPizza2(String orderType) {\n  \t\tPizza pizza = null;\n  \n  \t\tSystem.out.println(\"使用简单工厂模式2\");\n  \t\tif (orderType.equals(\"greek\")) {\n  \t\t\tpizza = new GreekPizza();\n  \t\t\tpizza.setName(\" 希腊披萨 \");\n  \t\t} else if (orderType.equals(\"cheese\")) {\n  \t\t\tpizza = new CheesePizza();\n  \t\t\tpizza.setName(\" 奶酪披萨 \");\n  \t\t} else if (orderType.equals(\"pepper\")) {\n  \t\t\tpizza = new PepperPizza();\n  \t\t\tpizza.setName(\"胡椒披萨\");\n  \t\t}\n  \t\treturn pizza;\n  \t}\n  }\n  \n  ```\n\n  一般工厂方法对应的 Order 程序：\n\n  ```java\n  package com.gjxaiou.factory.simplefactory.pizzastore.order;\n  \n  import java.io.BufferedReader;\n  import java.io.IOException;\n  import java.io.InputStreamReader;\n  \n  \n  import com.gjxaiou.factory.simplefactory.pizzastore.pizza.Pizza;\n  \n  public class OrderPizza {\n  \t//定义一个简单工厂对象\n  \tSimpleFactory simpleFactory;\n  \tPizza pizza = null;\n  \t\n  \t//构造器\n  \tpublic OrderPizza(SimpleFactory simpleFactory) {\n  \t\tsetFactory(simpleFactory);\n  \t}\n  \t\n  \tpublic void setFactory(SimpleFactory simpleFactory) {\n  \t\tString orderType = \"\"; //用户输入的\n  \t\t\n  \t\tthis.simpleFactory = simpleFactory; //设置简单工厂对象\n  \t\t\n  \t\tdo {\n  \t\t\torderType = getType(); \n  \t\t\tpizza = this.simpleFactory.createPizza(orderType);\n  \t\t\t\n  \t\t\t//输出pizza\n  \t\t\tif(pizza != null) { //订购成功\n  \t\t\t\tpizza.prepare();\n  \t\t\t\tpizza.bake();\n  \t\t\t\tpizza.cut();\n  \t\t\t\tpizza.box();\n  \t\t\t} else {\n  \t\t\t\tSystem.out.println(\" 订购披萨失败 \");\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}while(true);\n  \t}\n  \t\n  \t// 写一个方法，可以获取客户希望订购的披萨种类\n  \tprivate String getType() {\n  \t\ttry {\n  \t\t\tBufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n  \t\t\tSystem.out.println(\"input pizza 种类:\");\n  \t\t\tString str = strin.readLine();\n  \t\t\treturn str;\n  \t\t} catch (IOException e) {\n  \t\t\te.printStackTrace();\n  \t\t\treturn \"\";\n  \t\t}\n  \t}\n  }\n  \n  ```\n\n  静态工厂对应的 ORDER 方法：\n\n  ```java\n  package com.gjxaiou.factory.simplefactory.pizzastore.order;\n  \n  import java.io.BufferedReader;\n  import java.io.IOException;\n  import java.io.InputStreamReader;\n  \n  import com.gjxaiou.factory.simplefactory.pizzastore.pizza.Pizza;\n  \n  public class OrderPizza2 {\n  \n  \tPizza pizza = null;\n  \tString orderType = \"\";\n  \t// 构造器\n  \tpublic OrderPizza2() {\n  \t\t\n  \t\tdo {\n  \t\t\torderType = getType();\n  \t\t\tpizza = SimpleFactory.createPizza2(orderType);\n  \n  \t\t\t// 输出pizza\n  \t\t\tif (pizza != null) { // 订购成功\n  \t\t\t\tpizza.prepare();\n  \t\t\t\tpizza.bake();\n  \t\t\t\tpizza.cut();\n  \t\t\t\tpizza.box();\n  \t\t\t} else {\n  \t\t\t\tSystem.out.println(\" 订购披萨失败 \");\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t} while (true);\n  \t}\n  \n  \t// 写一个方法，可以获取客户希望订购的披萨种类\n  \tprivate String getType() {\n  \t\ttry {\n  \t\t\tBufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n  \t\t\tSystem.out.println(\"input pizza 种类:\");\n  \t\t\tString str = strin.readLine();\n  \t\t\treturn str;\n  \t\t} catch (IOException e) {\n  \t\t\te.printStackTrace();\n  \t\t\treturn \"\";\n  \t\t}\n  \t}\n  }\n  \n  ```\n\n  执行测试上面方法：\n\n```java\npackage com.gjxaiou.factory.simplefactory.pizzastore.order;\n\n//相当于一个客户端，发出订购\npublic class PizzaStore {\n    public static void main(String[] args) {\n\t\t// 使用简单工厂模式\n        new OrderPizza(new SimpleFactory());\n        // 使用静态工厂模式\n        new OrderPizza2();\n    }\n}\n\n```\n\n\n\n## 二、工厂方法模式\n\n==部分抽象==\n\n### （一）看一个新的需求\n\n披萨项目新的需求：客户在点披萨时，可以点**不同口味的披萨**，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza。\n\n-  思路 1\n\n使用**简单工厂模式**，创建**不同的简单工厂类**，比如 BJPizzaSimpleFactory、LDPizzaSimpleFactory 等等.从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好\n\n- 思路 2\n\n使用工厂方法模式\n\n### （二）工厂方法模式介绍\n\n- 工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。\n\n- 工厂方法模式：**定义了一个创建对象的抽象方法**，由子**类决定要实例化的类**。工厂方法模式将**对象的实例化推迟到子类**。\n\n### （三）工厂方法模式应用案例\n\n1) 披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza\n\n2) 思路分析图解\n\n![工厂方法模式](%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.resource/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.jpg)\n\n- 看老师代码实现\n\n下面是 Pizza 抽象类和三个具体的实现类\n\n```java\npackage com.gjxaiou.factory.absfactory.pizzastore.pizza;\n\n//将Pizza 类做成抽象\npublic abstract class Pizza {\n\tprotected String name; //名字\n\n\t//准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n\tpublic abstract void prepare();\n\n\tpublic void bake() {\n\t\tSystem.out.println(name + \" baking;\");\n\t}\n\n\tpublic void cut() {\n\t\tSystem.out.println(name + \" cutting;\");\n\t}\n\n\t//打包\n\tpublic void box() {\n\t\tSystem.out.println(name + \" boxing;\");\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}\n\n//----------------------------------------------------\npackage com.gjxaiou.factory.absfactory.pizzastore.pizza;\n\npublic class BJCheesePizza extends Pizza {\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"北京的奶酪pizza\");\n\t\tSystem.out.println(\" 北京的奶酪pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.gjxaiou.factory.absfactory.pizzastore.pizza;\n\npublic class BJPepperPizza extends Pizza {\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"北京的胡椒pizza\");\n\t\tSystem.out.println(\" 北京的胡椒pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.gjxaiou.factory.absfactory.pizzastore.pizza;\n\npublic class LDCheesePizza extends Pizza{\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"伦敦的奶酪pizza\");\n\t\tSystem.out.println(\" 伦敦的奶酪pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.gjxaiou.factory.absfactory.pizzastore.pizza;\n\npublic class LDPepperPizza extends Pizza{\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"伦敦的胡椒pizza\");\n\t\tSystem.out.println(\" 伦敦的胡椒pizza 准备原材料\");\n\t}\n}\n\n```\n\n具体的工厂实现\n\n```java\npackage com.gjxaiou.factory.factorymethod.pizzastore.order;\n\nimport com.gjxaiou.factory.factorymethod.pizzastore.pizza.BJCheesePizza;\nimport com.gjxaiou.factory.factorymethod.pizzastore.pizza.BJPepperPizza;\nimport com.gjxaiou.factory.factorymethod.pizzastore.pizza.Pizza;\n\npublic class BJOrderPizza extends OrderPizza {\n\t@Override\n\tPizza createPizza(String orderType) {\n\t\n\t\tPizza pizza = null;\n\t\tif(orderType.equals(\"cheese\")) {\n\t\t\tpizza = new BJCheesePizza();\n\t\t} else if (orderType.equals(\"pepper\")) {\n\t\t\tpizza = new BJPepperPizza();\n\t\t}\n\t\treturn pizza;\n\t}\n}\n\n//----------------------------------------------------\npackage com.gjxaiou.factory.factorymethod.pizzastore.order;\n\nimport com.gjxaiou.factory.factorymethod.pizzastore.pizza.BJCheesePizza;\nimport com.gjxaiou.factory.factorymethod.pizzastore.pizza.BJPepperPizza;\nimport com.gjxaiou.factory.factorymethod.pizzastore.pizza.LDCheesePizza;\nimport com.gjxaiou.factory.factorymethod.pizzastore.pizza.LDPepperPizza;\nimport com.gjxaiou.factory.factorymethod.pizzastore.pizza.Pizza;\n\npublic class LDOrderPizza extends OrderPizza {\n\t@Override\n\tPizza createPizza(String orderType) {\n\t\n\t\tPizza pizza = null;\n\t\tif(orderType.equals(\"cheese\")) {\n\t\t\tpizza = new LDCheesePizza();\n\t\t} else if (orderType.equals(\"pepper\")) {\n\t\t\tpizza = new LDPepperPizza();\n\t\t}\n\t\treturn pizza;\n\t}\n}\n\n```\n\n订购 Order \n\n```java\npackage com.gjxaiou.factory.factorymethod.pizzastore.order;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport com.gjxaiou.factory.factorymethod.pizzastore.pizza.Pizza;\n\npublic abstract class OrderPizza {\n\n    //定义一个抽象方法，createPizza , 让各个工厂子类自己实现\n    abstract Pizza createPizza(String orderType);\n\t\n    // 构造器\n    public OrderPizza() {\n        Pizza pizza = null;\n        String orderType; // 订购披萨的类型\n        do {\n            orderType = getType();\n            pizza = createPizza(orderType); //抽象方法，由工厂子类完成\n            //输出pizza 制作过程\n            pizza.prepare();\n            pizza.bake();\n            pizza.cut();\n            pizza.box();\n\n        } while (true);\n    }\n\n    // 写一个方法，可以获取客户希望订购的披萨种类\n    private String getType() {\n        try {\n            BufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n            System.out.println(\"input pizza 种类:\");\n            String str = strin.readLine();\n            return str;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n}\n```\n\n测试方法\n\n```java\npackage com.gjxaiou.factory.factorymethod.pizzastore.order;\n\npublic class PizzaStore {\n    public static void main(String[] args) {\n        String loc = \"bj\";\n        if (loc.equals(\"bj\")) {\n            //创建北京口味的各种Pizza\n            new BJOrderPizza();\n        } else {\n            //创建伦敦口味的各种Pizza\n            new LDOrderPizza();\n        }\n    }\n}\n```\n\n\n\n## 三、抽象工厂模式\n\n==完全抽象==\n\n### （一）基本介绍\n\n- 抽象工厂模式：定义了一个 **interface** **用于创建相关或有依赖关系的对象簇**，而无需指明具体的类\n\n-  抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。\n\n- 从设计层面看，**抽象工厂模式就是对简单工厂模式的改进**(或者称为进一步的抽象)。\n\n- 将工厂抽象成**两层**，**AbsFactory(抽象工厂) 和 具体实现的工厂子类**。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。\n\n5) 类图\n\n![抽象工厂模式](%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.resource/抽象工厂模式.png)\n\n### （二）抽象工厂模式应用实例\n\n下面是 Pizza 抽象类和三个具体的实现类\n\n```java\npackage com.gjxaiou.factory.absfactory.pizzastore.pizza;\n\n//将Pizza 类做成抽象\npublic abstract class Pizza {\n\tprotected String name; //名字\n\n\t//准备原材料, 不同的披萨不一样，因此，我们做成抽象方法\n\tpublic abstract void prepare();\n\n\tpublic void bake() {\n\t\tSystem.out.println(name + \" baking;\");\n\t}\n\n\tpublic void cut() {\n\t\tSystem.out.println(name + \" cutting;\");\n\t}\n\n\t//打包\n\tpublic void box() {\n\t\tSystem.out.println(name + \" boxing;\");\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}\n\n//----------------------------------------------------\npackage com.gjxaiou.factory.absfactory.pizzastore.pizza;\n\npublic class BJCheesePizza extends Pizza {\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"北京的奶酪pizza\");\n\t\tSystem.out.println(\" 北京的奶酪pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.gjxaiou.factory.absfactory.pizzastore.pizza;\n\npublic class BJPepperPizza extends Pizza {\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"北京的胡椒pizza\");\n\t\tSystem.out.println(\" 北京的胡椒pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.gjxaiou.factory.absfactory.pizzastore.pizza;\n\npublic class LDCheesePizza extends Pizza{\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"伦敦的奶酪pizza\");\n\t\tSystem.out.println(\" 伦敦的奶酪pizza 准备原材料\");\n\t}\n}\n//----------------------------------------------------\npackage com.gjxaiou.factory.absfactory.pizzastore.pizza;\n\npublic class LDPepperPizza extends Pizza{\n\t@Override\n\tpublic void prepare() {\n\t\tsetName(\"伦敦的胡椒pizza\");\n\t\tSystem.out.println(\" 伦敦的胡椒pizza 准备原材料\");\n\t}\n}\n\n```\n\n工厂抽象化和具体的工厂实现\n\n```java\npackage com.gjxaiou.factory.absfactory.pizzastore.order;\n\nimport com.gjxaiou.factory.absfactory.pizzastore.pizza.Pizza;\n\n//一个抽象工厂模式的抽象层(接口)\npublic interface AbsFactory {\n\t//让下面的工厂子类来 具体实现\n\tpublic Pizza createPizza(String orderType);\n}\n\n//----------------------------------------------------\npackage com.gjxaiou.factory.absfactory.pizzastore.order;\n\nimport com.gjxaiou.factory.absfactory.pizzastore.pizza.BJCheesePizza;\nimport com.gjxaiou.factory.absfactory.pizzastore.pizza.BJPepperPizza;\nimport com.gjxaiou.factory.absfactory.pizzastore.pizza.Pizza;\n\n//这是工厂子类\npublic class BJFactory implements AbsFactory {\n\t@Override\n\tpublic Pizza createPizza(String orderType) {\n\t\tSystem.out.println(\"~使用的是抽象工厂模式~\");\n\t\tPizza pizza = null;\n\t\tif(orderType.equals(\"cheese\")) {\n\t\t\tpizza = new BJCheesePizza();\n\t\t} else if (orderType.equals(\"pepper\")){\n\t\t\tpizza = new BJPepperPizza();\n\t\t}\n\t\treturn pizza;\n\t}\n}\n\n//----------------------------------------------------\npackage com.gjxaiou.factory.absfactory.pizzastore.order;\n\nimport com.gjxaiou.factory.absfactory.pizzastore.pizza.LDCheesePizza;\nimport com.gjxaiou.factory.absfactory.pizzastore.pizza.LDPepperPizza;\nimport com.gjxaiou.factory.absfactory.pizzastore.pizza.Pizza;\n\npublic class LDFactory implements AbsFactory {\n\t@Override\n\tpublic Pizza createPizza(String orderType) {\n\t\tSystem.out.println(\"~使用的是抽象工厂模式~\");\n\t\tPizza pizza = null;\n\t\tif (orderType.equals(\"cheese\")) {\n\t\t\tpizza = new LDCheesePizza();\n\t\t} else if (orderType.equals(\"pepper\")) {\n\t\t\tpizza = new LDPepperPizza();\n\t\t}\n\t\treturn pizza;\n\t}\n}\n\n```\n\n订购 Order \n\n```java\npackage com.gjxaiou.factory.absfactory.pizzastore.order;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport com.gjxaiou.factory.absfactory.pizzastore.pizza.Pizza;\n\npublic class OrderPizza {\n\n\tAbsFactory factory;\n\n\t// 构造器\n\tpublic OrderPizza(AbsFactory factory) {\n\t\tsetFactory(factory);\n\t}\n\n\tprivate void setFactory(AbsFactory factory) {\n\t\tPizza pizza = null;\n\t\tString orderType = \"\"; // 用户输入\n\t\tthis.factory = factory;\n\t\tdo {\n\t\t\torderType = getType();\n\t\t\t// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类\n\t\t\tpizza = factory.createPizza(orderType);\n\t\t\tif (pizza != null) { // 订购ok\n\t\t\t\tpizza.prepare();\n\t\t\t\tpizza.bake();\n\t\t\t\tpizza.cut();\n\t\t\t\tpizza.box();\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"订购失败\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (true);\n\t}\n\n\t// 写一个方法，可以获取客户希望订购的披萨种类\n\tprivate String getType() {\n\t\ttry {\n\t\t\tBufferedReader strin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tSystem.out.println(\"input pizza 种类:\");\n\t\t\tString str = strin.readLine();\n\t\t\treturn str;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"\";\n\t\t}\n\t}\n}\n\n```\n\n测试方法\n\n```java\npackage com.gjxaiou.factory.absfactory.pizzastore.order;\n\npublic class PizzaStore {\n\n\tpublic static void main(String[] args) {\n\t\t//new OrderPizza(new BJFactory());\n\t\tnew OrderPizza(new LDFactory());\n\t}\n}\n\n```\n\n\n\n\n\n\n\n\n\n## （四）工厂模式在 JDK-Calendar 应用的源码分析\n\n1) JDK 中的 Calendar 类中，就使用了简单工厂模式\n\n\n\n## （五）工厂模式小结\n\n- 工厂模式的意义\n\n将实例化对象的代码提取出来，放到一个类（工厂类）中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。\n\n- 三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)\n\n- 设计模式的依赖抽象原则\n  - 创建对象实例时，不要直接 new 类（使用工厂获取）, 而是把这个 new 类的动作放在一个工厂的方法中，并返回。有的书上说， 变量不要直接持有具体类的引用。\n  - 不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)- \n  -  不要覆盖基类中已经实现的方法。",[[1573827388294,["GJX@GJXAIOU",[[-1,17719,"\n\n\n\n\n"]],[17716,17721],[17716,17716]]],[1573827405884,["GJX@GJXAIOU",[[-1,7444,"  "]],[7444,7446],[7444,7444]]],[1573827413509,["GJX@GJXAIOU",[[-1,7732,"\n"]],[7732,7732],[7731,7731]]]],null,"GJX@GJXAIOU"]]}