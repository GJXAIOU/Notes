{"compress":true,"commitItems":[["1c8950da-86ee-4557-b309-6c00ccacceaa",1573826249164,"# 第二十五章：策略模式\n\n## 一、编写鸭子项目，具体要求如下:\n\n- 有各种鸭子(比如 野鸭、北京鸭、水鸭等， 鸭子有各种行为，比如 叫、飞行等)\n\n- 显示鸭子的信息\n\n## 二、传统方案解决鸭子问题的分析和代码实现\n\n-  传统的设计方案(类图)\n\n  ![1573819644065](%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.resource/1573819644065.png)\n\n- 代码实现-看老师演示\n\nDuck 抽象类\n\n```java\npackage com.atguigu.strategy;\n\npublic abstract class Duck {\n\n\tpublic Duck() {\n\t}\n\n\tpublic abstract void display();//显示鸭子信息\n\t\n\tpublic void quack() {\n\t\tSystem.out.println(\"鸭子嘎嘎叫~~\");\n\t}\n\t\n\tpublic void swim() {\n\t\tSystem.out.println(\"鸭子会游泳~~\");\n\t}\n\t\n\tpublic void fly() {\n\t\tSystem.out.println(\"鸭子会飞翔~~~\");\n\t}\n}\n\n```\n\n具体的 Duck 类\n\n```java\npackage com.atguigu.strategy;\n\npublic class PekingDuck extends Duck {\n\n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(\"~~北京鸭~~~\");\n\t}\n\t\n\t//因为北京鸭不能飞翔，因此需要重写fly\n\t@Override\n\tpublic void fly() {\n\t\tSystem.out.println(\"北京鸭不能飞翔\");\n\t}\n}\n\n//-------------------------------------------------------\npackage com.atguigu.strategy;\n\npublic class ToyDuck extends Duck{\n\n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(\"玩具鸭\");\n\t}\n\n\t//需要重写父类的所有方法\n\t@Override\n    public void quack() {\n\t\tSystem.out.println(\"玩具鸭不能叫~~\");\n\t}\n\t\n\t@Override\n\tpublic void swim() {\n\t\tSystem.out.println(\"玩具鸭不会游泳~~\");\n\t}\n\t\n\t@Override\n\tpublic void fly() {\n\t\tSystem.out.println(\"玩具鸭不会飞翔~~~\");\n\t}\n}\n\n//-------------------------------------------------------------\npackage com.atguigu.strategy;\n\npublic class WildDuck extends Duck {\n\n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(\" 这是野鸭 \");\n\t}\n}\n\n```\n\n使用\n\n```java\npackage com.atguigu.strategy;\n\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\t//测试\n\t}\n}\n```\n\n\n\n## 三、传统的方式实现的问题分析和解决方案\n\n- 其它鸭子，都继承了 Duck 类，所以 fly 让所有子类都会飞了，这是不正确的\n\n- 上面说的 1 的问题，其实是继承带来的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。会有溢出效应\n\n- 为了改进 1 问题，我们可以通过覆盖 fly  方法来解决 => **覆盖**解决\n\n- 问题又来了，如果我们有一个玩具鸭子 ToyDuck, 这样就需要 **ToyDuck** **去覆盖** **Duck** **的所有实现的方法** => 解决思路 -》 **策略模式** (strategy pattern)\n\n## 四、策略模式基本介绍\n\n- 策略模式（Strategy Pattern）中，定义**算法族（策略组）**，分别封装起来，让他们之间可以互相替换，此模式让**算法的变化**独立于**使用算法的客**户\n\n- 这算法体现了几个设计原则，第一、把变化的代码从不变的代码中分离出来；第二、针对接口编程而不是具体类（定义了策略接口）；第三、多用组合/聚合，少用继承（客户通过组合方式使用策略）。\n\n## 五、策略模式的原理类图\n\n​       ![1573819990625](%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.resource/1573819990625.png)\n\n说明：从上图可以看到，客户 context 有成员变量 strategy 或者其他的策略接口，至于需要使用到哪个策略，我们可以在构造器中指定\n\n## 六、策略模式解决鸭子问题\n\n-  应用实例要求\n\n  编写程序完成前面的鸭子项目，要求使用策略模式\n\n- 思路分析(类图)\n\n​        策略模式：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。原则就是： 分离变化部分，封装接口，基于接口编程各种功能。此模式让行为的变化独立于算法的使用者\n\n![1573820082393](%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.resource/1573820082393.png)\n\n- 代码实现\n\n  Duck 抽象类\n\n ```java\npackage com.atguigu.strategy.improve;\n\npublic abstract class Duck {\n\n\t//属性, 策略接口\n\tFlyBehavior flyBehavior;\n\t//其它属性<->策略接口\n\tQuackBehavior quackBehavior;\n\t\n\tpublic Duck() {\n\t}\n\n\tpublic abstract void display();//显示鸭子信息\n\t\n\tpublic void quack() {\n\t\tSystem.out.println(\"鸭子嘎嘎叫~~\");\n\t}\n\t\n\tpublic void swim() {\n\t\tSystem.out.println(\"鸭子会游泳~~\");\n\t}\n\t\n\tpublic void fly() {\n\t\t//改进\n\t\tif(flyBehavior != null) {\n\t\t\tflyBehavior.fly();\n\t\t}\n\t}\n\n\tpublic void setFlyBehavior(FlyBehavior flyBehavior) {\n\t\tthis.flyBehavior = flyBehavior;\n\t}\n\t\n\tpublic void setQuackBehavior(QuackBehavior quackBehavior) {\n\t\tthis.quackBehavior = quackBehavior;\n\t}\n}\n\n ```\n\n具体实体类\n\n```java\npackage com.atguigu.strategy.improve;\n\npublic class PekingDuck extends Duck {\n\t\n\t//假如北京鸭可以飞翔，但是飞翔技术一般\n\tpublic PekingDuck() {\n\t\tflyBehavior = new BadFlyBehavior();\n\t}\n\t\n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(\"~~北京鸭~~~\");\n\t}\n}\n\n//----------------------------------------------\npackage com.atguigu.strategy.improve;\n\npublic class ToyDuck extends Duck{\n\t\n\tpublic ToyDuck() {\n\t\tflyBehavior = new NoFlyBehavior();\n\t}\n\t\n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(\"玩具鸭\");\n\t}\n\n\t//需要重写父类的所有方法\n\t@Override\n    public void quack() {\n\t\tSystem.out.println(\"玩具鸭不能叫~~\");\n\t}\n\t\n\t@Override\n\tpublic void swim() {\n\t\tSystem.out.println(\"玩具鸭不会游泳~~\");\n\t}\n}\n\n//--------------------------------------------------\npackage com.atguigu.strategy.improve;\n\npublic class WildDuck extends Duck {\n\t\n\t//构造器，传入FlyBehavor 的对象\n\tpublic  WildDuck() {\n\t\tflyBehavior = new GoodFlyBehavior();\n\t}\n\t\n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(\" 这是野鸭 \");\n\t}\n}\n\n```\n\n飞行行为抽象类和实体类\n\n```java\npackage com.atguigu.strategy.improve;\n\npublic interface FlyBehavior {\n\t\n\tvoid fly(); // 子类具体实现\n}\n\n//----------------------------------------------\npackage com.atguigu.strategy.improve;\n\npublic class GoodFlyBehavior implements FlyBehavior {\n\n\t@Override\n\tpublic void fly() {\n\t\tSystem.out.println(\" 飞翔技术高超 ~~~\");\n\t}\n}\n\n//---------------------------------------------\npackage com.atguigu.strategy.improve;\n\npublic class BadFlyBehavior implements FlyBehavior {\n\n\t@Override\n\tpublic void fly() {\n\t\tSystem.out.println(\" 飞翔技术一般 \");\n\t}\n}\n\n//------------------------------------------------------\npackage com.atguigu.strategy.improve;\n\npublic class NoFlyBehavior implements FlyBehavior{\n\n\t@Override\n\tpublic void fly() {\n\t\tSystem.out.println(\" 不会飞翔  \");\n\t}\n}\n\n```\n\n使用\n\n```java\npackage com.atguigu.strategy.improve;\n\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\tWildDuck wildDuck = new WildDuck();\n\t\twildDuck.fly();//\n\t\t\n\t\tToyDuck toyDuck = new ToyDuck();\n\t\ttoyDuck.fly();\n\t\t\n\t\tPekingDuck pekingDuck = new PekingDuck();\n\t\tpekingDuck.fly();\n\t\t\n\t\t//动态改变某个对象的行为, 北京鸭 不能飞\n\t\tpekingDuck.setFlyBehavior(new NoFlyBehavior());\n\t\tSystem.out.println(\"北京鸭的实际飞翔能力\");\n\t\tpekingDuck.fly();\n\t}\n}\n\n```\n\n\n\n## 七、策略模式在 JDK-Arrays 应用的源码分析\n\n- JDK 的 Arrays 的 Comparator 就使用了策略模式\n\n-  代码分析+Debug 源码+模式角色分析\n\n​         ![1573821245124](%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.resource/1573821245124.png)\n\n- 代码\n\n\n\n## 八、策略模式的注意事项和细节\n\n- 策略模式的关键是：分析项目中变化部分与不变部分\n\n- 策略模式的核心思想是：多用组合/聚合 少用继承；用行为类组合，而不是行为的继承。更有弹性\n\n- 体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略（或者行为） 即可，避免了使用多重转移语句（if..else if..else）\n\n- 提供了可以替换继承关系的办法： 策略模式将算法封装在独立的Strategy 类中使得你可以独立于其Context 改变它，使它易于切换、易于理解、易于扩展\n\n- **需要注意的是**：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞",[[1573826191865,["GJX@GJXAIOU",[[-1,312,"atguig"],[1,318,"gjxaio"]],[312,319],[312,319]]],[1573826192101,["GJX@GJXAIOU",[[-1,644,"atguig"],[1,650,"gjxaio"]],[644,651],[644,651]]],[1573826192323,["GJX@GJXAIOU",[[-1,942,"atguig"],[1,948,"gjxaio"]],[942,949],[942,949]]],[1573826192571,["GJX@GJXAIOU",[[-1,1380,"atguig"],[1,1386,"gjxaio"]],[1380,1387],[1380,1387]]],[1573826192759,["GJX@GJXAIOU",[[-1,1540,"atguig"],[1,1546,"gjxaio"]],[1540,1547],[1540,1547]]],[1573826192993,["GJX@GJXAIOU",[[-1,2707,"atguig"],[1,2713,"gjxaio"]],[2707,2714],[2707,2714]]],[1573826193236,["GJX@GJXAIOU",[[-1,3352,"atguig"],[1,3358,"gjxaio"]],[3352,3359],[3352,3359]]],[1573826193459,["GJX@GJXAIOU",[[-1,3645,"atguig"],[1,3651,"gjxaio"]],[3645,3652],[3645,3652]]],[1573826193858,["GJX@GJXAIOU",[[-1,4070,"atguig"],[1,4076,"gjxaio"]],[4070,4077],[4070,4077]]],[1573826194207,["GJX@GJXAIOU",[[-1,4338,"atguig"],[1,4344,"gjxaio"]],[4338,4345],[4338,4345]]],[1573826194428,["GJX@GJXAIOU",[[-1,4485,"atguig"],[1,4491,"gjxaio"]],[4485,4492],[4485,4492]]],[1573826194649,["GJX@GJXAIOU",[[-1,4702,"atguig"],[1,4708,"gjxaio"]],[4702,4709],[4702,4709]]],[1573826194897,["GJX@GJXAIOU",[[-1,4924,"atguig"],[1,4930,"gjxaio"]],[4924,4931],[4924,4931]]],[1573826195066,["GJX@GJXAIOU",[[-1,5103,"atguig"],[1,5109,"gjxaio"]],[5103,5110],[5103,5110]]]],null,"GJX@GJXAIOU"],["6d2f8ae0-0aef-488d-8a3f-41006b1805be",1573826428648,"# 第二十五章：策略模式\n\n## 一、编写鸭子项目，具体要求如下:\n\n- 有各种鸭子(比如 野鸭、北京鸭、水鸭等， 鸭子有各种行为，比如 叫、飞行等)\n\n- 显示鸭子的信息\n\n## 二、传统方案解决鸭子问题的分析和代码实现\n\n-  传统的设计方案(类图)\n\n  ![1573819644065](%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.resource/1573819644065.png)\n\n- 代码实现-看老师演示\n\nDuck 抽象类\n\n```java\npackage com.gjxaiou.strategy;\n\npublic abstract class Duck {\n\n\tpublic Duck() {\n\t}\n\n\tpublic abstract void display();//显示鸭子信息\n\t\n\tpublic void quack() {\n\t\tSystem.out.println(\"鸭子嘎嘎叫~~\");\n\t}\n\t\n\tpublic void swim() {\n\t\tSystem.out.println(\"鸭子会游泳~~\");\n\t}\n\t\n\tpublic void fly() {\n\t\tSystem.out.println(\"鸭子会飞翔~~~\");\n\t}\n}\n\n```\n\n具体的 Duck 类\n\n```java\npackage com.gjxaiou.strategy;\n\npublic class PekingDuck extends Duck {\n\n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(\"~~北京鸭~~~\");\n\t}\n\t\n\t//因为北京鸭不能飞翔，因此需要重写fly\n\t@Override\n\tpublic void fly() {\n\t\tSystem.out.println(\"北京鸭不能飞翔\");\n\t}\n}\n\n//-------------------------------------------------------\npackage com.gjxaiou.strategy;\n\npublic class ToyDuck extends Duck{\n\n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(\"玩具鸭\");\n\t}\n\n\t//需要重写父类的所有方法\n\t@Override\n    public void quack() {\n\t\tSystem.out.println(\"玩具鸭不能叫~~\");\n\t}\n\t\n\t@Override\n\tpublic void swim() {\n\t\tSystem.out.println(\"玩具鸭不会游泳~~\");\n\t}\n\t\n\t@Override\n\tpublic void fly() {\n\t\tSystem.out.println(\"玩具鸭不会飞翔~~~\");\n\t}\n}\n\n//-------------------------------------------------------------\npackage com.gjxaiou.strategy;\n\npublic class WildDuck extends Duck {\n\n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(\" 这是野鸭 \");\n\t}\n}\n\n```\n\n使用\n\n```java\npackage com.gjxaiou.strategy;\n\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\t//测试\n\t}\n}\n```\n\n\n\n## 三、传统的方式实现的问题分析和解决方案\n\n- 其它鸭子，都继承了 Duck 类，所以 fly 让所有子类都会飞了，这是不正确的\n\n- 上面说的 1 的问题，其实是继承带来的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。会有溢出效应\n\n- 为了改进 1 问题，我们可以通过覆盖 fly  方法来解决 => **覆盖**解决\n\n- 问题又来了，如果我们有一个玩具鸭子 ToyDuck, 这样就需要 **ToyDuck** **去覆盖** **Duck** **的所有实现的方法** => 解决思路 -》 **策略模式** (strategy pattern)\n\n## 四、策略模式基本介绍\n\n- 策略模式（Strategy Pattern）中，定义**算法族（策略组）**，分别封装起来，让他们之间可以互相替换，此模式让**算法的变化**独立于**使用算法的客**户\n\n- 这算法体现了几个设计原则，第一、把变化的代码从不变的代码中分离出来；第二、针对接口编程而不是具体类（定义了策略接口）；第三、多用组合/聚合，少用继承（客户通过组合方式使用策略）。\n\n## 五、策略模式的原理类图\n\n​       ![1573819990625](%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.resource/1573819990625.png)\n\n说明：从上图可以看到，客户 context 有成员变量 strategy 或者其他的策略接口，至于需要使用到哪个策略，我们可以在构造器中指定\n\n## 六、策略模式解决鸭子问题\n\n-  应用实例要求\n\n  编写程序完成前面的鸭子项目，要求使用策略模式\n\n- 思路分析(类图)\n\n​        策略模式：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。原则就是： 分离变化部分，封装接口，基于接口编程各种功能。此模式让行为的变化独立于算法的使用者\n\n![1573820082393](%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.resource/1573820082393.png)\n\n- 代码实现\n\n  Duck 抽象类\n\n ```java\npackage com.gjxaiou.strategy.improve;\n\npublic abstract class Duck {\n\n\t//属性, 策略接口\n\tFlyBehavior flyBehavior;\n\t//其它属性<->策略接口\n\tQuackBehavior quackBehavior;\n\t\n\tpublic Duck() {\n\t}\n\n\tpublic abstract void display();//显示鸭子信息\n\t\n\tpublic void quack() {\n\t\tSystem.out.println(\"鸭子嘎嘎叫~~\");\n\t}\n\t\n\tpublic void swim() {\n\t\tSystem.out.println(\"鸭子会游泳~~\");\n\t}\n\t\n\tpublic void fly() {\n\t\t//改进\n\t\tif(flyBehavior != null) {\n\t\t\tflyBehavior.fly();\n\t\t}\n\t}\n\n\tpublic void setFlyBehavior(FlyBehavior flyBehavior) {\n\t\tthis.flyBehavior = flyBehavior;\n\t}\n\t\n\tpublic void setQuackBehavior(QuackBehavior quackBehavior) {\n\t\tthis.quackBehavior = quackBehavior;\n\t}\n}\n\n ```\n\n具体实体类\n\n```java\npackage com.gjxaiou.strategy.improve;\n\npublic class PekingDuck extends Duck {\n\t\n\t//假如北京鸭可以飞翔，但是飞翔技术一般\n\tpublic PekingDuck() {\n\t\tflyBehavior = new BadFlyBehavior();\n\t}\n\t\n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(\"~~北京鸭~~~\");\n\t}\n}\n\n//----------------------------------------------\npackage com.gjxaiou.strategy.improve;\n\npublic class ToyDuck extends Duck{\n\t\n\tpublic ToyDuck() {\n\t\tflyBehavior = new NoFlyBehavior();\n\t}\n\t\n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(\"玩具鸭\");\n\t}\n\n\t//需要重写父类的所有方法\n\t@Override\n    public void quack() {\n\t\tSystem.out.println(\"玩具鸭不能叫~~\");\n\t}\n\t\n\t@Override\n\tpublic void swim() {\n\t\tSystem.out.println(\"玩具鸭不会游泳~~\");\n\t}\n}\n\n//--------------------------------------------------\npackage com.gjxaiou.strategy.improve;\n\npublic class WildDuck extends Duck {\n\t\n\t//构造器，传入FlyBehavor 的对象\n\tpublic  WildDuck() {\n\t\tflyBehavior = new GoodFlyBehavior();\n\t}\n\t\n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(\" 这是野鸭 \");\n\t}\n}\n\n```\n\n飞行行为抽象类和实体类\n\n```java\npackage com.gjxaiou.strategy.improve;\n\npublic interface FlyBehavior {\n\t\n\tvoid fly(); // 子类具体实现\n}\n\n//----------------------------------------------\npackage com.gjxaiou.strategy.improve;\n\npublic class GoodFlyBehavior implements FlyBehavior {\n\n\t@Override\n\tpublic void fly() {\n\t\tSystem.out.println(\" 飞翔技术高超 ~~~\");\n\t}\n}\n\n//---------------------------------------------\npackage com.gjxaiou.strategy.improve;\n\npublic class BadFlyBehavior implements FlyBehavior {\n\n\t@Override\n\tpublic void fly() {\n\t\tSystem.out.println(\" 飞翔技术一般 \");\n\t}\n}\n\n//------------------------------------------------------\npackage com.gjxaiou.strategy.improve;\n\npublic class NoFlyBehavior implements FlyBehavior{\n\n\t@Override\n\tpublic void fly() {\n\t\tSystem.out.println(\" 不会飞翔  \");\n\t}\n}\n\n```\n\n使用\n\n```java\npackage com.gjxaiou.strategy.improve;\n\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\tWildDuck wildDuck = new WildDuck();\n\t\twildDuck.fly();//\n\t\t\n\t\tToyDuck toyDuck = new ToyDuck();\n\t\ttoyDuck.fly();\n\t\t\n\t\tPekingDuck pekingDuck = new PekingDuck();\n\t\tpekingDuck.fly();\n\t\t\n\t\t//动态改变某个对象的行为, 北京鸭 不能飞\n\t\tpekingDuck.setFlyBehavior(new NoFlyBehavior());\n\t\tSystem.out.println(\"北京鸭的实际飞翔能力\");\n\t\tpekingDuck.fly();\n\t}\n}\n\n```\n\n\n\n## 七、策略模式在 JDK-Arrays 应用的源码分析\n\n- JDK 的 Arrays 的 Comparator 就使用了策略模式\n\n-  代码分析+Debug 源码+模式角色分析\n\n​         ![1573821245124](%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.resource/1573821245124.png)\n\n- 代码\n\n\n\n## 八、策略模式的注意事项和细节\n\n- 策略模式的关键是：分析项目中变化部分与不变部分\n\n- 策略模式的核心思想是：多用组合/聚合 少用继承；用行为类组合，而不是行为的继承。更有弹性\n\n- 体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略（或者行为） 即可，避免了使用多重转移语句（if..else if..else）\n\n- 提供了可以替换继承关系的办法： 策略模式将算法封装在独立的Strategy 类中使得你可以独立于其Context 改变它，使它易于切换、易于理解、易于扩展\n\n- **需要注意的是**：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞",[[1573826379484,["GJX@GJXAIOU",[[-1,3319," "]],[3319,3320],[3319,3319]]],[1573826383660,["GJX@GJXAIOU",[[-1,2686," "]],[2686,2687],[2686,2686]]]],null,"GJX@GJXAIOU"]]}