{"compress":true,"commitItems":[["0b729de8-0d04-441c-890e-9ae8023f9608",1573826308994,"# 第十六章：模板方法模式\n\n## 一、豆浆制作问题\n\n编写制作豆浆的程序，说明如下:\n\n- 制作豆浆的流程 选材--->添加配料--->浸泡--->放到豆浆机打碎\n\n- 通过添加不同的配料，可以制作出不同口味的豆浆\n\n- 选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的\n\n- 请使用 模板方法模式 完成  (说明：因为模板方法模式，比较简单，很容易就想到这个方案，因此就直接使用， 不再使用传统的方案来引出模板方法模式 )\n\n \n\n## 二、模板方法模式基本介绍\n\n基本介绍\n\n- 模板方法模式（Template Method Pattern），又叫模板模式(Template    Pattern)，z 在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。\n\n- 简单说，模板方法模式 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤\n\n- 这种类型的设计模式属于行为型模式。\n\n \n\n## 三、模板方法模式原理类图\n\n### （一）模板方法模式的原理类图\n\n![模板模式类图](%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F.resource/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.jpg)\n\n 对原理类图的说明-即(模板方法模式的角色及职责)\n\n- AbstractClass 抽象类， 类中实现了模板方法(template)，定义了算法的骨架，具体子类需要去实现 其它的抽象方法 operationr2,3,4\n\n-  ConcreteClass 实现抽象方法 operationr2,3,4,  以完成算法中特点子类的步骤\n\n \n\n \n\n## 四、模板方法模式解决豆浆制作问题\n\n-  应用实例要求\n\n编写制作豆浆的程序，说明如下:\n\n制作豆浆的流程 选材--->添加配料--->浸泡--->放到豆浆机打碎通过添加不同的配料，可以制作出不同口味的豆浆\n\n选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的(红豆、花生豆浆。。。)\n\n- 思路分析和图解(类图)\n\n\n ![模板方法解决豆浆问题](%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F.resource/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E8%B1%86%E6%B5%86%E9%97%AE%E9%A2%98.jpg)\n\n \n\n   \n\n \n\n \n\n- 代码实现\n\n抽象类：\n\n```java\npackage com.atguigu.template;\n\n//抽象类，表示豆浆\npublic abstract class SoyaMilk {\n\n\t//模板方法, make , 模板方法可以做成final , 不让子类去覆盖.\n\tfinal void make() {\n\t\t\n\t\tselect(); \n\t\taddCondiments();\n\t\tsoak();\n\t\tbeat();\n\t\t\n\t}\n\t\n\t//选材料\n\tvoid select() {\n\t\tSystem.out.println(\"第一步：选择好的新鲜黄豆  \");\n\t}\n\t\n\t//添加不同的配料， 抽象方法, 子类具体实现\n\tabstract void addCondiments();\n\t\n\t//浸泡\n\tvoid soak() {\n\t\tSystem.out.println(\"第三步， 黄豆和配料开始浸泡， 需要3小时 \");\n\t}\n\t \n\tvoid beat() {\n\t\tSystem.out.println(\"第四步：黄豆和配料放到豆浆机去打碎  \");\n\t}\n}\n\n```\n\n\n\n 具体的实体类：\n\n```java\npackage com.atguigu.template;\n\npublic class PeanutSoyaMilk extends SoyaMilk {\n\n\t@Override\n\tvoid addCondiments() {\n\t\tSystem.out.println(\" 加入上好的花生 \");\n\t}\n}\n\n//-----------------------------------------------\npackage com.atguigu.template;\n\npublic class RedBeanSoyaMilk extends SoyaMilk {\n\n\t@Override\n\tvoid addCondiments() {\n\t\tSystem.out.println(\" 加入上好的红豆 \");\n\t}\n}\n\n```\n\n使用：\n\n```java\npackage com.atguigu.template;\n\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\t//制作红豆豆浆\n\t\tSystem.out.println(\"----制作红豆豆浆----\");\n\t\tSoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk();\n\t\tredBeanSoyaMilk.make();\n\t\t\n\t\tSystem.out.println(\"----制作花生豆浆----\");\n\t\tSoyaMilk peanutSoyaMilk = new PeanutSoyaMilk();\n\t\tpeanutSoyaMilk.make();\n\t}\n}\n\n```\n\n \n\n## 五、模板方法模式的钩子方法\n\n- 在模板方法模式的**父类**中，我们可以**定义一个方法**，它**默认不做任何事**，子类可以视情况要不要覆盖它，该方法称为“钩子”。\n\n- 还是用上面做豆浆的例子来讲解，比如，我们还希望**制作纯豆浆**，**不添加任何的配料**，请使用钩子方法对前面的模板方法进行改造\n\n- 看老师代码演示：\n\n抽象类：\n\n```java\npackage com.atguigu.template.improve;\n\n//抽象类，表示豆浆\npublic abstract class SoyaMilk {\n\n\t//模板方法, make , 模板方法可以做成final , 不让子类去覆盖.\n\tfinal void make() {\n\t\t\n\t\tselect(); \n\t\tif(customerWantCondiments()) {\n\t\t\taddCondiments();\n\t\t}\n\t\tsoak();\n\t\tbeat();\n\t}\n\t\n\t//选材料\n\tvoid select() {\n\t\tSystem.out.println(\"第一步：选择好的新鲜黄豆  \");\n\t}\n\t\n\t//添加不同的配料， 抽象方法, 子类具体实现\n\tabstract void addCondiments();\n\t\n\t//浸泡\n\tvoid soak() {\n\t\tSystem.out.println(\"第三步， 黄豆和配料开始浸泡， 需要3小时 \");\n\t}\n\t \n\tvoid beat() {\n\t\tSystem.out.println(\"第四步：黄豆和配料放到豆浆机去打碎  \");\n\t}\n\t\n\t//钩子方法，决定是否需要添加配料\n\tboolean customerWantCondiments() {\n\t\treturn true;\n\t}\n}\n```\n\n\n\n 具体的实体类：\n\n```java\npackage com.atguigu.template;\n\npublic class PeanutSoyaMilk extends SoyaMilk {\n\n\t@Override\n\tvoid addCondiments() {\n\t\tSystem.out.println(\" 加入上好的花生 \");\n\t}\n}\n\n//-----------------------------------------------\npackage com.atguigu.template;\n\npublic class RedBeanSoyaMilk extends SoyaMilk {\n\n\t@Override\n\tvoid addCondiments() {\n\t\tSystem.out.println(\" 加入上好的红豆 \");\n\t}\n}\n\n//-------------------------------------------------\npackage com.atguigu.template.improve;\n\npublic class PureSoyaMilk extends SoyaMilk{\n\n\t@Override\n\tvoid addCondiments() {\n\t\t//空实现\n\t}\n\t\n\t@Override\n\tboolean customerWantCondiments() {\n\t\treturn false;\n\t}\n}\n\n```\n\n使用：\n\n```java\npackage com.atguigu.template.improve;\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t//制作红豆豆浆\n\t\tSystem.out.println(\"----制作红豆豆浆----\");\n\t\tSoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk();\n\t\tredBeanSoyaMilk.make();\n\t\t\n\t\tSystem.out.println(\"----制作花生豆浆----\");\n\t\tSoyaMilk peanutSoyaMilk = new PeanutSoyaMilk();\n\t\tpeanutSoyaMilk.make();\n\t\t\n\t\tSystem.out.println(\"----制作纯豆浆----\");\n\t\tSoyaMilk pureSoyaMilk = new PureSoyaMilk();\n\t\tpureSoyaMilk.make();\n\t}\n}\n```\n\n \n\n## 六、模板方法模式在Spring 框架应用的源码分析 P241\n\n \n\n- Spring IOC 容器初始化时运用到的模板方法模式\n\n- 代码分析+角色分析+说明类图\n\n-  针对源码的类图(说明层次关系)\n\n ![1573719777063](%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F.resource/1573719777063.png)\n\n## 七、模板方法模式的注意事项和细节\n\n \n\n- 基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改\n\n- 实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用。\n\n- 既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。\n\n- 该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大\n\n- 一般模板方法都加上 final 关键字， 防止子类重写模板方法.\n\n- 模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤 ，这**一系列的步骤基本相同**，但其个别步骤在实现时 可能不同，通常考虑用模板方法模式来处理",[[1573826250722,["GJX@GJXAIOU",[[-1,1267,"atguig"],[1,1273,"gjxaio"]],[1267,1274],[1267,1274]]],[1573826250942,["GJX@GJXAIOU",[[-1,1762,"atguig"],[1,1768,"gjxaio"]],[1762,1769],[1762,1769]]],[1573826251174,["GJX@GJXAIOU",[[-1,1967,"atguig"],[1,1973,"gjxaio"]],[1967,1974],[1967,1974]]],[1573826251404,["GJX@GJXAIOU",[[-1,2141,"atguig"],[1,2147,"gjxaio"]],[2141,2148],[2141,2148]]],[1573826251634,["GJX@GJXAIOU",[[-1,2683,"atguig"],[1,2689,"gjxaio"]],[2683,2690],[2683,2690]]],[1573826251864,["GJX@GJXAIOU",[[-1,3295,"atguig"],[1,3301,"gjxaio"]],[3295,3302],[3295,3302]]],[1573826252098,["GJX@GJXAIOU",[[-1,3500,"atguig"],[1,3506,"gjxaio"]],[3500,3507],[3500,3507]]],[1573826252272,["GJX@GJXAIOU",[[-1,3708,"atguig"],[1,3714,"gjxaio"]],[3708,3715],[3708,3715]]],[1573826252501,["GJX@GJXAIOU",[[-1,3927,"atguig"],[1,3933,"gjxaio"]],[3927,3934],[3927,3934]]]],null,"GJX@GJXAIOU"]]}