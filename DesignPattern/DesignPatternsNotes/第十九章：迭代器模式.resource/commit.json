{"compress":true,"commitItems":[["226979de-e31f-4076-88b1-5dba1b804a2e",1573826289753,"# 第十九章：迭代器模式\n\n \n\n## 一、看一个具体的需求\n\n 编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系。如图：\n\n ![1573778720987](%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.resource/1573778720987.png)\n\n## 传统的设计方案(类图)\n\n​      学校\n\n​    学院\n\n 系 \n\n## 三、传统的方式的问题分析\n\n \n\n- 将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的\n\n- 实际上我们的要求是 ：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系， 因此这种方案，==不能很好实现的遍历的操作==\n\n-  解决方案：=> **迭代器**模式\n\n## 四、迭代器模式基本介绍\n\n- 迭代器模式（Iterator Pattern）是**常用的设计模式**，属于行为型模式\n\n- 如果我们的**集合元素是用不同的方式实现的**，有数组，还有 java 的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。\n\n- 迭代器模式，**提供一种遍历集合元素的统一接口**，用**一致的方法遍历集合元素**，不需要知道**集合对象的底层**表示，即：不暴露其内部的结构。\n\n## 五、迭代器模式的原理类图\n\n​        ![1573778980140](%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.resource/1573778980140.png)\n\n 对原理类图的说明-即(迭代器模式的角色及职责)\n\n- Iterator ： 迭代器接口，是系统提供，含义 hasNext, next, remove\n\n- ConcreteIterator :  具体的迭代器类，管理迭代\n\n- Aggregate :一个统一的聚合接口， 将客户端和具体聚合解耦\n\n- ConcreteAggreage : 具体的聚合持有对象集合， 并提供一个方法，返回一个迭代器， 该迭代器可以正确遍历集合\n\n- Client :客户端， 通过 Iterator 和  Aggregate 依赖子类\n\n## 六、迭代器模式应用实例\n\n- 应用实例要求\n\n编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系。\n\n- 设计思路分析\n\n  这里假设两个学院存放系方式不同\n\n  ![1573779628866](%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.resource/1573779628866.png)\n\n- 代码实现\n\niterator 抽象类：是系统的接口\n\n首先是基本实体类：\n\n```java\npackage com.atguigu.iterator;\n\n//ϵ\npublic class Department {\n\n\tprivate String name;\n\tprivate String desc;\n\tpublic Department(String name, String desc) {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.desc = desc;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic String getDesc() {\n\t\treturn desc;\n\t}\n\tpublic void setDesc(String desc) {\n\t\tthis.desc = desc;\n\t}\n}\n\n```\n\n\n\n具体的迭代器：\n\n```java\npackage com.atguigu.iterator;\n\nimport java.util.Iterator;\n\npublic class ComputerCollegeIterator implements Iterator {\n\n\t//这里我们需要Department 是以怎样的方式存放=>数组\n\tDepartment[] departments;\n\tint position = 0; //遍历的位置\n\n\tpublic ComputerCollegeIterator(Department[] departments) {\n\t\tthis.departments = departments;\n\t}\n\n\t//判断是否还有下一个元素\n\t@Override\n\tpublic boolean hasNext() {\n\t\tif(position >= departments.length || departments[position] == null) {\n\t\t\treturn false;\n\t\t}else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object next() {\n\t\tDepartment department = departments[position];\n\t\tposition += 1;\n\t\treturn department;\n\t}\n\t\n\t//删除的方法，默认空实现\n\t@Override\n\tpublic void remove() {\n\t}\n}\n\n//-----------------------------------------------------------------\npackage com.atguigu.iterator;\n\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class InfoColleageIterator implements Iterator {\n\n\tList<Department> departmentList; // 信息工程学院是以List方式存放系\n\tint index = -1;//索引\n\n\tpublic InfoColleageIterator(List<Department> departmentList) {\n\t\tthis.departmentList = departmentList;\n\t}\n\n\t//判断list中还有没有下一个元素\n\t@Override\n\tpublic boolean hasNext() {\n\t\tif(index >= departmentList.size() - 1) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tindex += 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object next() {\n\t\treturn departmentList.get(index);\n\t}\n\t\n\t//空实现remove\n\t@Override\n\tpublic void remove() {\n\t}\n}\n\n```\n\n\n\n数据接口和实体类\n\n```java\npackage com.atguigu.iterator;\n\nimport java.util.Iterator;\n\npublic interface College {\n\t\n\tpublic String getName();\n\t\n\t//增加系的方法\n\tpublic void addDepartment(String name, String desc);\n\t\n\t//返回一个迭代器,遍历\n\tpublic Iterator  createIterator();\n}\n\n//---------------------------------------------------\npackage com.atguigu.iterator;\n\nimport java.util.Iterator;\n\npublic class ComputerCollege implements College {\n\n\tDepartment[] departments;\n\tint numOfDepartment = 0 ;// 保存当前数组的对象个数\n\t\n\tpublic ComputerCollege() {\n\t\tdepartments = new Department[5];\n\t\taddDepartment(\"Java专业\", \" Java专业 \");\n\t\taddDepartment(\"PHP专业\", \" PHP专业 \");\n\t\taddDepartment(\"大数据专业\", \" 大数据专业 \");\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn \"计算机学院\";\n\t}\n\n\t@Override\n\tpublic void addDepartment(String name, String desc) {\n\t\tDepartment department = new Department(name, desc);\n\t\tdepartments[numOfDepartment] = department;\n\t\tnumOfDepartment += 1;\n\t}\n\n\t@Override\n\tpublic Iterator createIterator() {\n\t\treturn new ComputerCollegeIterator(departments);\n\t}\n}\n\n//---------------------------------------------------\npackage com.atguigu.iterator;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class InfoCollege implements College {\n\n\tList<Department> departmentList;\n\n\tpublic InfoCollege() {\n\t\tdepartmentList = new ArrayList<Department>();\n\t\taddDepartment(\"信息安全专业\", \" 信息安全专业 \");\n\t\taddDepartment(\"网络安全专业\", \" 网络安全专业 \");\n\t\taddDepartment(\"服务器安全专业\", \" 服务器安全专业 \");\n\t}\n\t\n\t@Override\n\tpublic String getName() {\n\t\treturn \"信息工程学院\";\n\t}\n\n\t@Override\n\tpublic void addDepartment(String name, String desc) {\n\t\tDepartment department = new Department(name, desc);\n\t\tdepartmentList.add(department);\n\t}\n\n\t@Override\n\tpublic Iterator createIterator() {\n\t\treturn new InfoColleageIterator(departmentList);\n\t}\n}\n\n\n```\n\n输出方法：\n\n```java\npackage com.atguigu.iterator;\n\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class OutPutImpl {\n\t\n\t//学院集合\n\tList<College> collegeList;\n\n\tpublic OutPutImpl(List<College> collegeList) {\n\t\t\n\t\tthis.collegeList = collegeList;\n\t}\n\t//遍历所有学院,然后调用printDepartment 输出各个学院的系\n\tpublic void printCollege() {\n\t\t\n\t\t//从collegeList 取出所有学院, Java 中的 List 已经实现Iterator\n\t\tIterator<College> iterator = collegeList.iterator();\n\t\t\n\t\twhile(iterator.hasNext()) {\n\t\t\t//取出一个学院\n\t\t\tCollege college = iterator.next();\n\t\t\tSystem.out.println(\"=== \"+college.getName() +\"=====\" );\n\t\t\tprintDepartment(college.createIterator()); //得到对应迭代器\n\t\t}\n\t}\n\n\t//输出 学院输出 系\n\tpublic void printDepartment(Iterator iterator) {\n\t\twhile(iterator.hasNext()) {\n\t\t\tDepartment d = (Department)iterator.next();\n\t\t\tSystem.out.println(d.getName());\n\t\t}\n\t}\n}\n\n```\n\n使用：\n\n```java\npackage com.atguigu.iterator;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\t//创建学院\n\t\tList<College> collegeList = new ArrayList<College>();\n\t\t\n\t\tComputerCollege computerCollege = new ComputerCollege();\n\t\tInfoCollege infoCollege = new InfoCollege();\n\t\t\n\t\tcollegeList.add(computerCollege);\n\t\t//collegeList.add(infoCollege);\n\t\t\n\t\tOutPutImpl outPutImpl = new OutPutImpl(collegeList);\n\t\toutPutImpl.printCollege();\n\t}\n}\n```\n\n\n\n \n\n## 七、迭代器模式在JDK-ArrayList 集合应用的源码分析 P272\n\n- JDK 的 ArrayList  集合中就使用了迭代器模式\n\n- 代码分析+类图+说明\n\n​       ![1573802182552](%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.resource/1573802182552.png)\n\n\n\n- 对类图的角色分析和说明\n  - 内部类 Itr 充当具体实现迭代器 Iterator 的类， 作为 ArrayList  内部类\n  - List 就是充当了聚合接口，含有一个 iterator() 方法，返回一个迭代器对象\n  - ArrayList 是实现聚合接口 List  的子类，实现了 iterator()\n  - Iterator 接口系统提供\n  - 迭代器模式解决了 不同集合(ArrayList ,LinkedList) 统一遍历问题\n\n \n\n## 八、迭代器模式的注意事项和细节\n\n \n\n- 优点\n  - 提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了。\n  - 隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成。\n  -  提供了一种**设计思想**，就是一个类应该只有一个引起变化的原因（叫做单一责任原则）。在聚合类中，我们把迭代器分开，就是要把**管理对象集合**和**遍历对象集合**的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到了迭代器。\n  - 当要展示一组相似对象，或者遍历一组相同对象时使用, 适合使用迭代器模式\n\n- 缺点\n  - 每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类",[[1573826232451,["GJX@GJXAIOU",[[-1,1425,"atguig"],[1,1431,"gjxaio"]],[1425,1432],[1425,1432]]],[1573826232728,["GJX@GJXAIOU",[[-1,1867,"atguig"],[1,1873,"gjxaio"]],[1867,1874],[1867,1874]]],[1573826232910,["GJX@GJXAIOU",[[-1,2601,"atguig"],[1,2607,"gjxaio"]],[2601,2608],[2601,2608]]],[1573826233165,["GJX@GJXAIOU",[[-1,3249,"atguig"],[1,3255,"gjxaio"]],[3249,3256],[3249,3256]]],[1573826233396,["GJX@GJXAIOU",[[-1,3538,"atguig"],[1,3544,"gjxaio"]],[3538,3545],[3538,3545]]],[1573826233662,["GJX@GJXAIOU",[[-1,4309,"atguig"],[1,4315,"gjxaio"]],[4309,4316],[4309,4316]]],[1573826233923,["GJX@GJXAIOU",[[-1,5041,"atguig"],[1,5047,"gjxaio"]],[5041,5048],[5041,5048]]],[1573826234160,["GJX@GJXAIOU",[[-1,5864,"atguig"],[1,5870,"gjxaio"]],[5864,5871],[5864,5871]]]],null,"GJX@GJXAIOU"]]}