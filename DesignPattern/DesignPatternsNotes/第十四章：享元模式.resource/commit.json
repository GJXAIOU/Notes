{"compress":true,"commitItems":[["4c09df74-463f-4bbd-b277-18868e8125c2",1573826321644,"# 第十四章：享元模式\n\n## 一、展示网站项目需求\n\n小型的外包项目，给客户 A 做一个产品展示网站，客户 A 的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：\n\n- 有客户要求以新闻的形式发布\n\n- 有客户人要求以博客的形式发布\n\n- 有客户希望以微信公众号的形式发布\n\n \n\n \n\n## 二、传统方案解决网站展现项目\n\n \n\n- 直接复制粘贴一份，然后根据客户不同要求，进行定制修改\n\n- 给每个网站租用一个空间\n\n- 方案设计示意图\n\n​       ![传统方案解决网站展示](%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.resource/%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%A1%88%E8%A7%A3%E5%86%B3%E7%BD%91%E7%AB%99%E5%B1%95%E7%A4%BA.jpg) \n\n \n\n## 14.3      传统方案解决网站展现项目-问题分析\n\n- 需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，造成服务器的资源浪费\n\n- 解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源\n\n- 对于代码来说，由于是一份实例，维护和扩展都更加容易\n\n- 上面的解决思路就可以使用 享元模式 来解决\n\n## 14.4      享元模式基本介绍\n\n\n\n- 享元模式（Flyweight Pattern） 也叫 蝇量模式: 运用共享技术有效地支持大量细粒度的对象\n\n- 常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个\n\n- 享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率\n\n- 享元模式经典的应用场景就是池技术了，String 常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式\n\n ![String 中的享元模式](%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.resource/String%20%E4%B8%AD%E7%9A%84%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.jpg)\n\n## 享元模式的原理类图\n\n![享元模式原理类图](%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.resource/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E7%B1%BB%E5%9B%BE.jpg)\n \n\n对原理图的说明-即(模式的角色及职责)\n\n- FlyWeight 是抽象的享元角色, 他是产品的抽象类, 同时定义出对象的外部状态和内部状态(后面介绍)  的接口或实现\n\n- ConcreteFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务\n\n- UnSharedConcreteFlyWeight 是不可共享的角色，一般不会出现在享元工厂。\n\n- FlyWeightFactory    享元工厂类，用于构建一个池容器(集合)， 同时提供从池中获取对象方法\n\n \n\n## 六、内部状态和外部状态\n\n比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态\n\n- 享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分：内部状态和外部状态\n\n- **内部状态**指对象共享出来的信息，**存储在享元对象内部且不会随环境的改变而改**变\n\n- 外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。\n\n- 举个例子：围棋理论上有 361 个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题\n\n \n\n## 七、享元模式解决网站展现项目\n\n- 应用实例要求\n\n  使用享元模式完成，前面提出的网站外包问题\n\n- 思路分析和图解(类图)\n\n​       ![享元模式解决网站问题](%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.resource/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E7%BD%91%E7%AB%99%E9%97%AE%E9%A2%98.jpg) \n\n- 代码实现\n\n   首先是 WebSite 的抽象类：\n\n```java\npackage com.atguigu.flyweight;\n\npublic abstract class WebSite {\n\n\tpublic abstract void use(User user);//抽象方法\n}\n\n```\n\n具体的网站：\n\n```java\npackage com.atguigu.flyweight;\n\n//具体网站\npublic class ConcreteWebSite extends WebSite {\n\n\t//共享的部分，内部状态\n\tprivate String type = \"\"; //网站发布的形式(类型)\n\n\t//构造器\n\tpublic ConcreteWebSite(String type) {\n\t\tthis.type = type;\n\t}\n\n\t@Override\n\tpublic void use(User user) {\n\t\tSystem.out.println(\"网站的发布形式为:\" + type + \" 在使用中 .. 使用者是\" + user.getName());\n\t}\n}\n\n```\n\n外部状态：\n\n```java\npackage com.atguigu.flyweight;\n\npublic class User {\n\t\n\tprivate String name;\n\tpublic User(String name) {\n\t\tsuper();\n\t\tthis.name = name;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}\n\n```\n\n工厂类：\n\n```java\npackage com.atguigu.flyweight;\n\nimport java.util.HashMap;\n\n// 网站工厂类，根据需要返回压一个网站\npublic class WebSiteFactory {\n\n\t//集合， 充当池的作用\n\tprivate HashMap<String, ConcreteWebSite> pool = new HashMap<>();\n\t\n\t//根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回\n\tpublic WebSite getWebSiteCategory(String type) {\n\t\tif(!pool.containsKey(type)) {\n\t\t\t//就创建一个网站，并放入到池中\n\t\t\tpool.put(type, new ConcreteWebSite(type));\n\t\t}\n\t\treturn (WebSite)pool.get(type);\n\t}\n\t\n\t//获取网站分类的总数 (池中有多少个网站类型)\n\tpublic int getWebSiteCount() {\n\t\treturn pool.size();\n\t}\n}\n\n```\n\n客户端和使用：\n\n```java\npackage com.atguigu.flyweight;\n\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\t// 创建一个工厂类\n\t\tWebSiteFactory factory = new WebSiteFactory();\n\n\t\t// 客户要一个以新闻形式发布的网站\n\t\tWebSite webSite1 = factory.getWebSiteCategory(\"新闻\");\n\t\twebSite1.use(new User(\"tom\"));\n\n\t\t// 客户要一个以博客形式发布的网站\n\t\tWebSite webSite2 = factory.getWebSiteCategory(\"博客\");\n\t\twebSite2.use(new User(\"jack\"));\n\n\t\t// 客户要一个以博客形式发布的网站\n\t\tWebSite webSite3 = factory.getWebSiteCategory(\"博客\");\n\t\twebSite3.use(new User(\"smith\"));\n\n\t\t// 客户要一个以博客形式发布的网站\n\t\tWebSite webSite4 = factory.getWebSiteCategory(\"博客\");\n\t\twebSite4.use(new User(\"king\"));\n\t\t\n\t\tSystem.out.println(\"网站的分类共=\" + factory.getWebSiteCount());\n\t}\n}\n \n```\n\n## 八、享元模式在 JDK-Interger 的应用源码分析\n\n \n\n- Integer 中的享元模式\n\n- 代码分析+Debug 源码+说明\n\n- 代码说明：\n\n```java\npackage com.atguigu.jdk;\n\npublic class FlyWeight {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t//如果 Integer.valueOf(x) x 在  -128 --- 127 直接，就是使用享元模式返回,如果不在\n\t\t//范围类，则仍然 new \n\t\t\n\t\t//小结:\n\t\t//1. 在valueOf 方法中，先判断值是否在 IntegerCache 中，如果不在，就创建新的Integer(new), 否则，就直接从 缓存池返回\n\t\t//2. valueOf 方法，就使用到享元模式\n\t\t//3. 如果使用valueOf 方法得到一个Integer 实例，范围在 -128 - 127 ，执行速度比 new 快\t\n\t\t\n\t\tInteger x = Integer.valueOf(127); // 得到 x实例，类型 Integer\n\t\tInteger y = new Integer(127); // 得到 y 实例，类型 Integer\n\t\tInteger z = Integer.valueOf(127);//..\n\t\tInteger w = new Integer(127);\n\t\t\t\n\t\tSystem.out.println(x.equals(y)); // 大小，true\n\t\tSystem.out.println(x == y ); //  false\n\t\tSystem.out.println(x == z ); // true\n\t\tSystem.out.println(w == x ); // false\n\t\tSystem.out.println(w == y ); // false\n\t\t\t\t\n\t\tInteger x1 = Integer.valueOf(200);\n\t\tInteger x2 = Integer.valueOf(200);\n\t\tSystem.out.println(\"x1==x2\" + (x1 == x2)); // false\n\t}\n}\n \n```\n\n \n\n## 九、享元模式的注意事项和细节\n\n \n\n- 在享元模式这样理解，“享”就表示共享，“元”表示对象\n\n- 系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式\n\n- 用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用 HashMap/HashTable 存储\n\n- 享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率\n\n- 享元模式提高了**系统的复杂度**。需要分离出**内部状态和外部状态**，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方.\n\n- 使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。\n\n- 享元模式经典的应用场景是需要缓冲池的场景，比如 String 常量池、数据库连接池",[[1573826262704,["GJX@GJXAIOU",[[-1,2360,"atguig"],[1,2366,"gjxaio"]],[2360,2367],[2360,2367]]],[1573826262953,["GJX@GJXAIOU",[[-1,2493,"atguig"],[1,2499,"gjxaio"]],[2493,2500],[2493,2500]]],[1573826263315,["GJX@GJXAIOU",[[-1,2850,"atguig"],[1,2856,"gjxaio"]],[2850,2857],[2850,2857]]],[1573826263547,["GJX@GJXAIOU",[[-1,3116,"atguig"],[1,3122,"gjxaio"]],[3116,3123],[3116,3123]]],[1573826263786,["GJX@GJXAIOU",[[-1,3650,"atguig"],[1,3656,"gjxaio"]],[3650,3657],[3650,3657]]],[1573826264043,["GJX@GJXAIOU",[[-1,4420,"atguig"],[1,4426,"gjxaio"]],[4420,4427],[4420,4427]]]],null,"GJX@GJXAIOU"]]}