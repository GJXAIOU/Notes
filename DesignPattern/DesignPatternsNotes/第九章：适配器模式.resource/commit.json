{"compress":true,"commitItems":[["0c490e4d-8d1e-4cfd-8cc0-5d5311d305b2",1573826343721,"# 第九章：适配器模式\n\n## 现实生活中的适配器例子\n\n 泰国插座用的是两孔的（欧标），可以买个多功能转换插头 (适配器) ，这样就可以使用了。\n\n​                                                                         \n\n## 二、基本介绍\n\n \n\n- 适配器模式(Adapter Pattern)**将某个类的接口转换成客户端期望的另一个接口表示**，**主的目的是兼容性**，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)\n\n- 适配器模式属于结构型模式\n\n- 主要分为三类：**类适配器模式、对象适配器模式、接口适配器模**式\n\n\n\n## 工作原理\n\n- 适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容\n\n- 从用户的角度看不到被适配者，是解耦的【 A -> 适配器 -> B(被适配者)】\n\n- 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法\n\n- 用户收到反馈结果，感觉只是和目标接口交互，如图\n\n![适配器示例](%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.resource/%E9%80%82%E9%85%8D%E5%99%A8%E7%A4%BA%E4%BE%8B.png)\n\n\n\n## 四、类适配器模式\n\n###  （一）类适配器模式介绍\n\n基本介绍：Adapter 类，通过**继承 src 类，实现 dst  类接口**，完成 src->dst 的适配。\n\n\n\n### （二）类适配器模式应用实例\n\n- 应用实例说明\n\n以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们的目 dst(即 目标)是 5V 直流电\n\n- 思路分析(类图)\n\n   ![类适配器模式应用实例](%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.resource/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B.jpg)  \n\n- 代码实现\n\n被适配的类：\n\n```java\npackage com.atguigu.adapter.classadapter;\n\n//被适配的类\npublic class Voltage220V {\n\t//输出220V的电压\n\tpublic int output220V() {\n\t\tint src = 220;\n\t\tSystem.out.println(\"电压=\" + src + \"伏\");\n\t\treturn src;\n\t}\n}\n```\n\n目标适配接口：\n\n```java\npackage com.atguigu.adapter.classadapter;\n\n//适配接口\npublic interface IVoltage5V {\n\tpublic int output5V();\n}\n\n```\n\n适配器：\n\n```java\npackage com.atguigu.adapter.classadapter;\n\n//适配器类\npublic class VoltageAdapter extends Voltage220V implements IVoltage5V {\n\n\t@Override\n\tpublic int output5V() {\n\t\t//获取到220V电压【通过继承的方式】\n\t\tint srcV = output220V();\n\t\t//转成 5v\n\t\tint dstV = srcV / 44 ; \n\t\treturn dstV;\n\t}\n}\n\n```\n\n使用：\n\n```java\npackage com.atguigu.adapter.classadapter;\n\npublic class Phone {\n\t//充电\n\tpublic void charging(IVoltage5V iVoltage5V) {\n\t\tif(iVoltage5V.output5V() == 5) {\n\t\t\tSystem.out.println(\"电压为5V, 可以充电~~\");\n\t\t} else if (iVoltage5V.output5V() > 5) {\n\t\t\tSystem.out.println(\"电压大于5V, 不能充电~~\");\n\t\t}\n\t}\n}\n\n```\n\n客户端测试：\n\n```java\npackage com.atguigu.adapter.classadapter;\n\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\" === 类适配器模式 ====\");\n\t\tPhone phone = new Phone();\n\t\tphone.charging(new VoltageAdapter());\n\t}\n}\n\n```\n\n\n\n### （三）类适配器模式注意事项和细节\n\n-  **Java 是单继承机制**，所以类适配器需要继承 src 类这一点算是一个缺点, 因为这要求 dst 必须是接口，有一定局限性;\n\n-  src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本。\n\n- 由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得 Adapter 的灵活性增强了。\n\n \n\n## 五、对象适配器模式\n\n### （一） 对象适配器模式介绍\n\n- 基本思路和类的适配器模式相同，只是将 Adapter 类作修改，**不是继承 src 类，而是持有 src 类的实例**【即采用聚合的方式】，以解决兼容性的问题。 即：持有 src 类，实现 dst  类接口，完成 src->dst 的适配\n\n- 根据“**合成复用原则**”，在系统中尽量使用**关联关系（聚合）来替代继承**关系。\n\n- 对象适配器模式是适配器模式常用的一种\n\n### （二）对象适配器模式应用实例\n\n- 应用实例说明\n\n以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们的目 dst(即目标)是 5V 直流电，使用对象适配器模式完成。\n\n- 思路分析(类图)：只需修改适配器即可, 如下:\n\n ![对象适配器模式实例](%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.resource/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B.jpg)\n\n- 代码实现：\n\n  适配接口和被适配的类：\n\n  ```java\n  package com.atguigu.adapter.objectadapter;\n  \n  //适配接口\n  public interface IVoltage5V {\n  \tpublic int output5V();\n  }\n  \n  // -------------------------------------------------\n  package com.atguigu.adapter.objectadapter;\n  \n  //被适配的类\n  public class Voltage220V {\n  \t//输出220V的电压，不变\n  \tpublic int output220V() {\n  \t\tint src = 220;\n  \t\tSystem.out.println(\"电压=\" + src + \"伏\");\n  \t\treturn src;\n  \t}\n  }\n  \n  ```\n\n\n### （三）对象适配器模式注意事项和细节\n\n- 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。\n\n根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承 src 的局限性问题，也不再要求 dst\n\n必须是接口。\n\n- 使用成本更低，更灵活。\n\n \n\n \n\n## 六、接口适配器模式\n\n### （一）接口适配器模式介绍\n\n-  一些书籍称为：适配器模式(Default Adapter Pattern)或**缺省适配器模式**。\n\n- 核心思路：当**不需要全部实现接口提供的方法**时，可先**设计一个抽象类**实现**接口**，并为该接口中每个方法提供一个**默认实现（空方法）**，那么该**抽象类的子类可有选择地覆盖父类的某些方法**来实现需求\n\n- 适用于一个接口不想使用其所有的方法的情况。\n\n### （二）接口适配器模式应用实例 P150\n\n- Android 中的属性动画 ValueAnimator 类可以通过 addListener(AnimatorListener listener)方法添加监听器， 那么常规写法如右：\n\n- 有时候我们不想实现 Animator.AnimatorListener 接口的全部方法，我们只想监听 onAnimationStart，我们会如下写\n\n- AnimatorListenerAdapter 类，就是一个接口适配器，代码如右图:它空实现了Animator.AnimatorListener 类(src)的所有方法.\n\n- AnimatorListener 是一个接口.\n\n- 程序里的匿名内部类就是 Listener 具体实现类\n\n​       \n\n- 案例说明\n\n​        首先提供一个接口:\n\n```java\npackage com.atguigu.adapter.interfaceadapter;\n\npublic interface Interface4 {\n\tpublic void m1();\n\tpublic void m2();\n\tpublic void m3();\n\tpublic void m4();\n}\n\n```\n\n然后对接口中的方法进行默认实现：\n\n```java\npackage com.atguigu.adapter.interfaceadapter;\n\n//在AbsAdapter 我们将 Interface4 的方法进行默认实现\npublic abstract class AbsAdapter implements Interface4 {\n\n\t//默认实现\n\t@Override\n\tpublic void m1() {\n\t}\n\n\t@Override\n\tpublic void m2() {\n\t}\n\n\t@Override\n\tpublic void m3() {\n\t}\n\n\t@Override\n\tpublic void m4() {\n\t}\n}\n```\n\n使用的时候，需要使用什么方法只要重写该方法即可：\n\n```java\npackage com.atguigu.adapter.interfaceadapter;\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t\n\t\tAbsAdapter absAdapter = new AbsAdapter() {\n\t\t\t//只需要去覆盖我们 需要使用 接口方法\n\t\t\t@Override\n\t\t\tpublic void m1() {\n\t\t\t\tSystem.out.println(\"使用了m1的方法\");\n\t\t\t}\n\t\t};\n\t\t\n\t\tabsAdapter.m1();\n\t}\n}\n```\n\n\n\n## 七、适配器模式在 SpringMVC 框架应用的源码剖析 P153\n\n- SpringMvc 中的 **HandlerAdapter,** 就使用了适配器模式\n\n- SpringMVC 处理请求的流程回顾\n\n- 使用 HandlerAdapter 的原因分析:\n\n可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用 Controller 方法，需要调用的时候就得不断是使用 if else 来进行判断是哪一种子类然后执行。那么如果后面要扩展 Controller， 就得修改原来的代码，这样违背了 OCP 原则。\n\n- 代码分析+Debug 源码\n\n- 动手写 SpringMVC 通过适配器设计模式获取到对应的 Controller 的源码\n\n\n\n## 八、适配器模式的注意事项和细节\n\n- 三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）来命名的。\n\n- 类适配器：以类给到，在 Adapter 里，就是将 src 当做类，继承\n\n- 对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，持有\n- 接口适配器：以接口给到，在 Adapter 里，将 src 作为一个接口，实现\n\n- Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作。\n\n- 实际开发中，实现起来不拘泥于我们讲解的三种经典形式",[[1573826285720,["GJX@GJXAIOU",[[-1,1102,"atguig"],[1,1108,"gjxaio"]],[1102,1109],[1102,1109]]],[1573826285965,["GJX@GJXAIOU",[[-1,1319,"atguig"],[1,1325,"gjxaio"]],[1319,1326],[1319,1326]]],[1573826286174,["GJX@GJXAIOU",[[-1,1445,"atguig"],[1,1451,"gjxaio"]],[1445,1452],[1445,1452]]],[1573826286393,["GJX@GJXAIOU",[[-1,1729,"atguig"],[1,1735,"gjxaio"]],[1729,1736],[1729,1736]]],[1573826286651,["GJX@GJXAIOU",[[-1,2035,"atguig"],[1,2041,"gjxaio"]],[2035,2042],[2035,2042]]],[1573826286827,["GJX@GJXAIOU",[[-1,3067,"atguig"],[1,3073,"gjxaio"]],[3067,3074],[3067,3074]]],[1573826287096,["GJX@GJXAIOU",[[-1,3244,"atguig"],[1,3250,"gjxaio"]],[3244,3251],[3244,3251]]],[1573826287333,["GJX@GJXAIOU",[[-1,4230,"atguig"],[1,4236,"gjxaio"]],[4230,4237],[4230,4237]]],[1573826287713,["GJX@GJXAIOU",[[-1,4417,"atguig"],[1,4423,"gjxaio"]],[4417,4424],[4417,4424]]],[1573826288123,["GJX@GJXAIOU",[[-1,4749,"atguig"],[1,4755,"gjxaio"]],[4749,4756],[4749,4756]]]],null,"GJX@GJXAIOU"],["943dedd5-09ce-4896-8cf0-408cf9b8619d",1573827079870,"# 第九章：适配器模式\n\n## 现实生活中的适配器例子\n\n 泰国插座用的是两孔的（欧标），可以买个多功能转换插头 (适配器) ，这样就可以使用了。\n\n​                                                                         \n\n## 二、基本介绍\n\n \n\n- 适配器模式(Adapter Pattern)**将某个类的接口转换成客户端期望的另一个接口表示**，**主的目的是兼容性**，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)\n\n- 适配器模式属于结构型模式\n\n- 主要分为三类：**类适配器模式、对象适配器模式、接口适配器模**式\n\n\n\n## 工作原理\n\n- 适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容\n\n- 从用户的角度看不到被适配者，是解耦的【 A -> 适配器 -> B(被适配者)】\n\n- 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法\n\n- 用户收到反馈结果，感觉只是和目标接口交互，如图\n\n![适配器示例](%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.resource/%E9%80%82%E9%85%8D%E5%99%A8%E7%A4%BA%E4%BE%8B.png)\n\n\n\n## 四、类适配器模式\n\n###  （一）类适配器模式介绍\n\n基本介绍：Adapter 类，通过**继承 src 类，实现 dst  类接口**，完成 src->dst 的适配。\n\n\n\n### （二）类适配器模式应用实例\n\n- 应用实例说明\n\n以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们的目 dst(即 目标)是 5V 直流电\n\n- 思路分析(类图)\n\n   ![类适配器模式应用实例](%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.resource/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B.jpg)  \n\n- 代码实现\n\n被适配的类：\n\n```java\npackage com.gjxaiou.adapter.classadapter;\n\n//被适配的类\npublic class Voltage220V {\n\t//输出220V的电压\n\tpublic int output220V() {\n\t\tint src = 220;\n\t\tSystem.out.println(\"电压=\" + src + \"伏\");\n\t\treturn src;\n\t}\n}\n```\n\n目标适配接口：\n\n```java\npackage com.gjxaiou.adapter.classadapter;\n\n//适配接口\npublic interface IVoltage5V {\n\tpublic int output5V();\n}\n\n```\n\n适配器：\n\n```java\npackage com.gjxaiou.adapter.classadapter;\n\n//适配器类\npublic class VoltageAdapter extends Voltage220V implements IVoltage5V {\n\n\t@Override\n\tpublic int output5V() {\n\t\t//获取到220V电压【通过继承的方式】\n\t\tint srcV = output220V();\n\t\t//转成 5v\n\t\tint dstV = srcV / 44 ; \n\t\treturn dstV;\n\t}\n}\n\n```\n\n使用：\n\n```java\npackage com.gjxaiou.adapter.classadapter;\n\npublic class Phone {\n\t//充电\n\tpublic void charging(IVoltage5V iVoltage5V) {\n\t\tif(iVoltage5V.output5V() == 5) {\n\t\t\tSystem.out.println(\"电压为5V, 可以充电~~\");\n\t\t} else if (iVoltage5V.output5V() > 5) {\n\t\t\tSystem.out.println(\"电压大于5V, 不能充电~~\");\n\t\t}\n\t}\n}\n\n```\n\n客户端测试：\n\n```java\npackage com.gjxaiou.adapter.classadapter;\n\npublic class Client {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\" === 类适配器模式 ====\");\n\t\tPhone phone = new Phone();\n\t\tphone.charging(new VoltageAdapter());\n\t}\n}\n\n```\n\n\n\n### （三）类适配器模式注意事项和细节\n\n-  **Java 是单继承机制**，所以类适配器需要继承 src 类这一点算是一个缺点, 因为这要求 dst 必须是接口，有一定局限性;\n\n-  src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本。\n\n- 由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得 Adapter 的灵活性增强了。\n\n \n\n## 五、对象适配器模式\n\n### （一） 对象适配器模式介绍\n\n- 基本思路和类的适配器模式相同，只是将 Adapter 类作修改，**不是继承 src 类，而是持有 src 类的实例**【即采用聚合的方式】，以解决兼容性的问题。 即：持有 src 类，实现 dst  类接口，完成 src->dst 的适配\n\n- 根据“**合成复用原则**”，在系统中尽量使用**关联关系（聚合）来替代继承**关系。\n\n- 对象适配器模式是适配器模式常用的一种\n\n### （二）对象适配器模式应用实例\n\n- 应用实例说明\n\n以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们的目 dst(即目标)是 5V 直流电，使用对象适配器模式完成。\n\n- 思路分析(类图)：只需修改适配器即可, 如下:\n\n ![对象适配器模式实例](%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.resource/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B.jpg)\n\n- 代码实现：\n\n  适配接口和被适配的类：\n\n  ```java\n  package com.gjxaiou.adapter.objectadapter;\n  \n  //适配接口\n  public interface IVoltage5V {\n  \tpublic int output5V();\n  }\n  \n  // -------------------------------------------------\n  package com.gjxaiou.adapter.objectadapter;\n  \n  //被适配的类\n  public class Voltage220V {\n  \t//输出220V的电压，不变\n  \tpublic int output220V() {\n  \t\tint src = 220;\n  \t\tSystem.out.println(\"电压=\" + src + \"伏\");\n  \t\treturn src;\n  \t}\n  }\n  \n  ```\n\n\n### （三）对象适配器模式注意事项和细节\n\n- 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。\n\n根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承 src 的局限性问题，也不再要求 dst\n\n必须是接口。\n\n- 使用成本更低，更灵活。\n\n \n\n \n\n## 六、接口适配器模式\n\n### （一）接口适配器模式介绍\n\n-  一些书籍称为：适配器模式(Default Adapter Pattern)或**缺省适配器模式**。\n\n- 核心思路：当**不需要全部实现接口提供的方法**时，可先**设计一个抽象类**实现**接口**，并为该接口中每个方法提供一个**默认实现（空方法）**，那么该**抽象类的子类可有选择地覆盖父类的某些方法**来实现需求\n\n- 适用于一个接口不想使用其所有的方法的情况。\n\n### （二）接口适配器模式应用实例 P150\n\n- Android 中的属性动画 ValueAnimator 类可以通过 addListener(AnimatorListener listener)方法添加监听器， 那么常规写法如右：\n\n- 有时候我们不想实现 Animator.AnimatorListener 接口的全部方法，我们只想监听 onAnimationStart，我们会如下写\n\n- AnimatorListenerAdapter 类，就是一个接口适配器，代码如右图:它空实现了Animator.AnimatorListener 类(src)的所有方法.\n\n- AnimatorListener 是一个接口.\n\n- 程序里的匿名内部类就是 Listener 具体实现类\n\n​       \n\n- 案例说明\n\n​        首先提供一个接口:\n\n```java\npackage com.gjxaiou.adapter.interfaceadapter;\n\npublic interface Interface4 {\n\tpublic void m1();\n\tpublic void m2();\n\tpublic void m3();\n\tpublic void m4();\n}\n\n```\n\n然后对接口中的方法进行默认实现：\n\n```java\npackage com.gjxaiou.adapter.interfaceadapter;\n\n//在AbsAdapter 我们将 Interface4 的方法进行默认实现\npublic abstract class AbsAdapter implements Interface4 {\n\n\t//默认实现\n\t@Override\n\tpublic void m1() {\n\t}\n\n\t@Override\n\tpublic void m2() {\n\t}\n\n\t@Override\n\tpublic void m3() {\n\t}\n\n\t@Override\n\tpublic void m4() {\n\t}\n}\n```\n\n使用的时候，需要使用什么方法只要重写该方法即可：\n\n```java\npackage com.gjxaiou.adapter.interfaceadapter;\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t\n\t\tAbsAdapter absAdapter = new AbsAdapter() {\n\t\t\t//只需要去覆盖我们 需要使用 接口方法\n\t\t\t@Override\n\t\t\tpublic void m1() {\n\t\t\t\tSystem.out.println(\"使用了m1的方法\");\n\t\t\t}\n\t\t};\n\t\t\n\t\tabsAdapter.m1();\n\t}\n}\n```\n\n\n\n## 七、适配器模式在 SpringMVC 框架应用的源码剖析 P153\n\n- SpringMvc 中的 **HandlerAdapter,** 就使用了适配器模式\n\n- SpringMVC 处理请求的流程回顾\n\n- 使用 HandlerAdapter 的原因分析:\n\n可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用 Controller 方法，需要调用的时候就得不断是使用 if else 来进行判断是哪一种子类然后执行。那么如果后面要扩展 Controller， 就得修改原来的代码，这样违背了 OCP 原则。\n\n- 代码分析+Debug 源码\n\n- 动手写 SpringMVC 通过适配器设计模式获取到对应的 Controller 的源码\n\n\n\n## 八、适配器模式的注意事项和细节\n\n- 三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）来命名的。\n\n- 类适配器：以类给到，在 Adapter 里，就是将 src 当做类，继承\n\n- 对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，持有\n- 接口适配器：以接口给到，在 Adapter 里，将 src 作为一个接口，实现\n\n- Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作。\n\n- 实际开发中，实现起来不拘泥于我们讲解的三种经典形式",[[1573827022954,["GJX@GJXAIOU",[[-1,5118,"\n"]],[5118,5118],[5117,5117]]],[1573827024149,["GJX@GJXAIOU",[[-1,5140,"\n"]],[5140,5140],[5139,5139]]],[1573827026300,["GJX@GJXAIOU",[[-1,5327,"\n"]],[5327,5327],[5326,5326]]],[1573827032052,["GJX@GJXAIOU",[[-1,5453,"\n"]],[5453,5453],[5452,5452]]],[1573827032924,["GJX@GJXAIOU",[[-1,5492,"\n"]],[5492,5492],[5491,5491]]],[1573827033795,["GJX@GJXAIOU",[[-1,5576,"\n"]],[5576,5576],[5575,5575]]],[1573827034852,["GJX@GJXAIOU",[[-1,5613,"\n"]],[5613,5613],[5612,5612]]],[1573827045326,["GJX@GJXAIOU",[[-1,4172,"​       "]],[4180,4180],[4172,4172]]],[1573827046316,["GJX@GJXAIOU",[[-1,4173,"\n"]],[4172,4172],[4171,4171]]],[1573827047703,["GJX@GJXAIOU",[[-1,4200,"\n"]],[4200,4200],[4199,4199]]],[1573827049429,["GJX@GJXAIOU",[[-1,4141,"\n"]],[4141,4141],[4140,4140]]],[1573827050124,["GJX@GJXAIOU",[[-1,4114,"\n"]],[4114,4114],[4113,4113]]],[1573827050900,["GJX@GJXAIOU",[[-1,4025,"\n"]],[4025,4025],[4024,4024]]],[1573827051605,["GJX@GJXAIOU",[[-1,3947,"\n"]],[3947,3947],[3946,3946]]],[1573827053348,["GJX@GJXAIOU",[[-1,3802,"\n"]],[3802,3802],[3801,3801]]],[1573827054220,["GJX@GJXAIOU",[[-1,3690,"\n"]],[3690,3690],[3689,3689]]],[1573827058132,["GJX@GJXAIOU",[[-1,3574,"\n"]],[3575,3575],[3574,3574]]],[1573827058596,["GJX@GJXAIOU",[[-1,3573,"\n"]],[3574,3574],[3573,3573]]],[1573827061564,["GJX@GJXAIOU",[[-1,3518,"\n"]],[3519,3519],[3518,3518]]],[1573827064092,["GJX@GJXAIOU",[[-1,3597,"\n"]],[3597,3597],[3596,3596]]],[1573827064452,["GJX@GJXAIOU",[[-1,3595," "]],[3596,3596],[3595,3595]]],[1573827064999,["GJX@GJXAIOU",[[-1,3595,"\n"]],[3595,3595],[3594,3594]]],[1573827065836,["GJX@GJXAIOU",[[-1,3595," "]],[3596,3596],[3595,3595]]],[1573827066820,["GJX@GJXAIOU",[[-1,3579,"\n"]],[3579,3579],[3578,3578]]],[1573827067628,["GJX@GJXAIOU",[[-1,3595,"\n"]],[3594,3594],[3593,3593]]],[1573827070525,["GJX@GJXAIOU",[[-1,3454,"  "]],[3454,3456],[3454,3454]]],[1573827074853,["GJX@GJXAIOU",[[-1,3043,"  "]],[3043,3045],[3043,3043]]],[1573827079123,["GJX@GJXAIOU",[[-1,2704,"\n"]],[2704,2704],[2703,2703]]],[1573827081886,["GJX@GJXAIOU",[[-1,2652,"\n"]],[2652,2652],[2651,2651]]],[1573827082628,["GJX@GJXAIOU",[[-1,2605,"\n"]],[2605,2605],[2604,2604]]],[1573827084564,["GJX@GJXAIOU",[[-1,2446," "]],[2447,2447],[2446,2446]]],[1573827084935,["GJX@GJXAIOU",[[-1,2447,"\n"]],[2446,2446],[2445,2445]]],[1573827085853,["GJX@GJXAIOU",[[-1,2388,"\n"]],[2388,2388],[2387,2387]]],[1573827086724,["GJX@GJXAIOU",[[-1,2347,"\n"]],[2347,2347],[2346,2346]]],[1573827091956,["GJX@GJXAIOU",[[-1,764,"\n"]],[764,764],[763,763]]],[1573827094735,["GJX@GJXAIOU",[[-1,461,"\n"]],[461,461],[460,460]]],[1573827095396,["GJX@GJXAIOU",[[-1,421,"\n"]],[421,421],[420,420]]],[1573827096453,["GJX@GJXAIOU",[[-1,377,"\n"]],[377,377],[376,376]]],[1573827098869,["GJX@GJXAIOU",[[-1,289,"\n"]],[289,289],[288,288]]],[1573827100580,["GJX@GJXAIOU",[[-1,273,"\n"]],[273,273],[272,272]]],[1573827104348,["GJX@GJXAIOU",[[-1,162," "]],[163,163],[162,162]]],[1573827104693,["GJX@GJXAIOU",[[-1,163,"\n"]],[162,162],[161,161]]],[1573827106252,["GJX@GJXAIOU",[[-1,162,"\n"]],[162,162],[161,161]]],[1573827112069,["GJX@GJXAIOU",[[-1,75,"​          "]],[86,86],[75,75]]],[1573827112814,["GJX@GJXAIOU",[[-1,74,"\n"]],[75,75],[74,74]]]],null,"GJX@GJXAIOU"]]}