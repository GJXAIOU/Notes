{"compress":true,"commitItems":[["26a43e34-40a9-4a4c-9e9d-7412c396be3f",1571216575094,"",[[1571216526111,["GJX@GJXAIOU",[[1,0,"# 第二章：设计模式七大原则\n\n\n\n"]],[0,0],[17,17]]],[1571216539799,["GJX@GJXAIOU",[[1,16,"## 2.1 设计模式的目的\n\n编写软件过程中，程序员面临着来自 **耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性** 等多方面的挑战，设计模式是为了让程序(软件)，具有更好\n\n1) 代码重用性 (即：相同功能的代码，不用多次编写)\n\n2) 可读性 (即：编程规范性, 便于其他程序员的阅读和理解)\n\n3) 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)\n\n4) 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)\n\n5) 使程序呈现高内聚，低耦合的特性**分享金句**：\n\n6) 设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要”\n\n7) Scott  Mayers 在其巨著《Effective  C++》就曾经说过：C++老手和 C++新手的区别就是前者手背上有很多伤疤\n\n## 2.2 设计模式七大原则\n\n设计模式原则，其实就是**程序员在编程时，应当遵守的原则**，也是各种**设计模式的基础**(即：**设计模式为什么这样设计的依据**)\n\nØ 设计模式常用的七大原则有:\n\n1) 单一职责原则\n\n2) 接口隔离原则\n\n3) 依赖倒转(倒置)原则\n\n4) 里氏替换原则\n\n5) 开闭原则\n\n6) 迪米特法则\n\n7) 合成复用原则\n\n## 2.3 单一职责原则\n\n### 2.3.1 基本介绍\n\n对类来说的，**即一个类应该只负责一项职责**。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2\n\n### 2.3.2 应用实例\n\n以交通工具案例讲解看老师代码演示"]],[16,16],[742,742]]],[1571216544872,["GJX@GJXAIOU",[[-1,19,"2.1 "]],[23,23],[19,19]]],[1571216546166,["GJX@GJXAIOU",[[1,19,"（*"]],[19,19],[21,21]]],[1571216546824,["GJX@GJXAIOU",[[-1,19,"（*"]],[21,21],[19,19]]],[1571216548904,["GJX@GJXAIOU",[[1,19,"一、"]],[19,19],[21,21]]],[1571216570542,["GJX@GJXAIOU",[[-1,107,"1) "]],[107,110],[107,107]]],[1571216571295,["GJX@GJXAIOU",[[1,107,"- "]],[107,107],[109,109]]],[1571216573296,["GJX@GJXAIOU",[[-1,135,"2) "]],[135,138],[135,135]]],[1571216573616,["GJX@GJXAIOU",[[-1,134,"\n"]],[135,135],[134,134]]],[1571216574650,["GJX@GJXAIOU",[[1,134,"- "]],[134,134],[136,136]]],[1571216578688,["GJX@GJXAIOU",[[-1,165,"\n3)"]],[165,168],[165,165]]],[1571216579147,["GJX@GJXAIOU",[[1,165,"-"]],[165,165],[166,166]]],[1571216582145,["GJX@GJXAIOU",[[-1,199,"\n4) "]],[199,203],[199,199]]],[1571216583048,["GJX@GJXAIOU",[[1,199,"- "]],[199,199],[201,201]]],[1571216585569,["GJX@GJXAIOU",[[-1,231,"\n5) "]],[231,235],[231,231]]],[1571216585936,["GJX@GJXAIOU",[[1,231,"- "]],[231,231],[233,233]]],[1571216589417,["GJX@GJXAIOU",[[-1,258,"\n6) "]],[258,262],[258,258]]],[1571216590809,["GJX@GJXAIOU",[[1,258," - "]],[258,258],[261,261]]],[1571216593558,["GJX@GJXAIOU",[[-1,258," "]],[258,259],[258,258]]],[1571216605790,["GJX@GJXAIOU",[[-1,309,"7) Scott  Mayers 在其巨著《Effective  C++》就曾经说过：C++老手和 C++新手的区别就是前者手背上有很多伤疤"]],[309,379],[309,309]]],[1571216607929,["GJX@GJXAIOU",[[-1,248,"**分享金句**："]],[248,257],[248,248]]],[1571216615718,["GJX@GJXAIOU",[[-1,305,"2.2 "]],[309,309],[305,305]]],[1571216617103,["GJX@GJXAIOU",[[1,305,"二、"]],[305,305],[307,307]]],[1571216626145,["GJX@GJXAIOU",[[-1,387,"Ø "]],[387,389],[387,387]]],[1571216628903,["GJX@GJXAIOU",[[-1,449,"\n"]],[449,449],[448,448]]],[1571216629735,["GJX@GJXAIOU",[[-1,457,"\n"]],[457,457],[456,456]]],[1571216630336,["GJX@GJXAIOU",[[-1,466,"\n"]],[466,466],[465,465]]],[1571216631031,["GJX@GJXAIOU",[[-1,438,"\n"]],[438,438],[437,437]]],[1571216631553,["GJX@GJXAIOU",[[-1,423,"\n"]],[423,423],[422,422]]],[1571216632161,["GJX@GJXAIOU",[[-1,412,"\n"]],[412,412],[411,411]]],[1571216632999,["GJX@GJXAIOU",[[-1,401,"\n"]],[401,401],[400,400]]],[1571216634479,["GJX@GJXAIOU",[[-1,401,"1) "]],[401,404],[401,401]]],[1571216635424,["GJX@GJXAIOU",[[-1,410," "]],[411,411],[410,410]]],[1571216636616,["GJX@GJXAIOU",[[-1,417,"3) "]],[417,420],[417,417]]],[1571216637744,["GJX@GJXAIOU",[[-1,408,"2)"]],[408,410],[408,408]]],[1571216638823,["GJX@GJXAIOU",[[-1,426,"4) "]],[426,429],[426,426]]],[1571216639904,["GJX@GJXAIOU",[[-1,433,"5) "]],[433,436],[433,433]]],[1571216640823,["GJX@GJXAIOU",[[-1,438,"6) "]],[438,441],[438,438]]],[1571216641720,["GJX@GJXAIOU",[[-1,444,"7) "]],[444,447],[444,444]]],[1571216643866,["GJX@GJXAIOU",[[1,401,"* "],[1,408,"* "],[1,415,"* "],[1,426,"* "],[1,433,"* "],[1,438,"* "],[1,444,"* "]],[401,450],[403,464]]],[1571216658952,["GJX@GJXAIOU",[[1,466,"\n"]],[465,465],[466,466]]],[1571216663250,["GJX@GJXAIOU",[[1,466,"## 三、设计"]],[466,466],[473,473]]],[1571216668601,["GJX@GJXAIOU",[[-1,466,"## 三、设计"]],[473,473],[466,466]]],[1571216669047,["GJX@GJXAIOU",[[-1,466,"\n"]],[466,466],[465,465]]],[1571216673490,["GJX@GJXAIOU",[[1,468,"#"]],[469,469],[480,480]]],[1571216675474,["GJX@GJXAIOU",[[-1,470,"2.3"]],[473,473],[470,470]]],[1571216678985,["GJX@GJXAIOU",[[1,470,"（）"]],[470,470],[472,472]]],[1571216680658,["GJX@GJXAIOU",[[1,471,"一"]],[471,471],[472,472]]],[1571216682184,["GJX@GJXAIOU",[[-1,473," "]],[474,474],[473,473]]],[1571216685703,["GJX@GJXAIOU",[[1,484,"#"]],[490,490],[496,496]]],[1571216688751,["GJX@GJXAIOU",[[-1,486,"2.3.1 "]],[492,492],[486,486]]],[1571216689912,["GJX@GJXAIOU",[[1,486,"1 "]],[486,486],[487,487]]],[1571216690088,["GJX@GJXAIOU",[[1,487,"."]],[487,487],[488,488]]],[1571216697935,["GJX@GJXAIOU",[[-1,529,"同"]],[529,529],[529,529]]],[1571216699935,["GJX@GJXAIOU",[[1,529,"同"]],[529,529],[529,529]]],[1571216966161,["GJX@GJXAIOU",[[-1,614,"以交通工具案例讲解看老师代码演示"]],[614,630],[614,614]]],[1571216969260,["GJX@GJXAIOU",[[1,614,"不是抵用"]],[614,614],[618,618]]],[1571216970559,["GJX@GJXAIOU",[[-1,614,"不是抵用"]],[618,618],[614,614]]],[1571216978570,["GJX@GJXAIOU",[[1,614,"不使用单一职责原则："]],[614,614],[624,624]]],[1571216978818,["GJX@GJXAIOU",[[1,626,"\n"]],[624,624],[625,625]]],[1571216980321,["GJX@GJXAIOU",[[1,625,"```"]],[625,625],[628,628]]],[1571216980346,["GJX@GJXAIOU",[[1,628,"language\n```\n"]],[628,628],[628,636]]],[1571216980856,["GJX@GJXAIOU",[[-1,628,"language"],[1,636,"j"]],[628,636],[629,629]]],[1571216981272,["GJX@GJXAIOU",[[1,629,"ava"]],[629,629],[632,632]]],[1571216981350,["GJX@GJXAIOU",[[1,633,"\n"]],[632,632],[633,633]]],[1571216984829,["GJX@GJXAIOU",[[1,633,"package com.atguigu.principle.singleresponsibility;\n\npublic class SingleResponsibility1 {\n\tpublic static void main(String[] args) {\n\t\tVehicle vehicle = new Vehicle();\n\t\tvehicle.run(\"摩托车\");\n\t\tvehicle.run(\"汽车\");\n\t\tvehicle.run(\"飞机\");\n\t}\n}\n\n/**\n * 方式1：只使用一个交通工具类\n * \t1. 在方式 1 的 run方法中，违反了单一职责原则\n * \t2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可\n */\nclass Vehicle {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + \" 在公路上运行....\");\n\t}\n}\n"]],[633,633],[1071,1071]]]],null,"GJX@GJXAIOU"],["025cea50-2153-4778-ba36-56df0691a07f",1571217369694,"# 第二章：设计模式七大原则\n\n## 一、设计模式的目的\n\n编写软件过程中，程序员面临着来自 **耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性** 等多方面的挑战，设计模式是为了让程序(软件)，具有更好\n\n- 代码重用性 (即：相同功能的代码，不用多次编写)\n- 可读性 (即：编程规范性, 便于其他程序员的阅读和理解)\n- 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)\n- 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)\n- 使程序呈现高内聚，低耦合的特性\n- 设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要”\n\n\n\n## 二、设计模式七大原则\n\n设计模式原则，其实就是**程序员在编程时，应当遵守的原则**，也是各种**设计模式的基础**(即：**设计模式为什么这样设计的依据**)\n\n设计模式常用的七大原则有:\n* 单一职责原则\n* 接口隔离原则\n* 依赖倒转(倒置)原则\n* 里氏替换原则\n* 开闭原则\n* 迪米特法则\n* 合成复用原则\n\n### （一）单一职责原则\n\n#### 1. 基本介绍\n\n对类来说的，**即一个类应该只负责一项职责**。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2\n\n### 2.3.2 应用实例\n\n不使用单一职责原则：\n```java\npackage com.atguigu.principle.singleresponsibility;\n\npublic class SingleResponsibility1 {\n\tpublic static void main(String[] args) {\n\t\tVehicle vehicle = new Vehicle();\n\t\tvehicle.run(\"摩托车\");\n\t\tvehicle.run(\"汽车\");\n\t\tvehicle.run(\"飞机\");\n\t}\n}\n\n/**\n * 方式1：只使用一个交通工具类\n * \t1. 在方式 1 的 run方法中，违反了单一职责原则\n * \t2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可\n */\nclass Vehicle {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + \" 在公路上运行....\");\n\t}\n}\n\n```\n\n\n",[[1571217319697,["GJX@GJXAIOU",[[1,1078,"\n"]],[1076,1076],[1077,1077]]],[1571217324640,["GJX@GJXAIOU",[[1,1077,"改进方式："]],[1077,1077],[1082,1082]]],[1571217325290,["GJX@GJXAIOU",[[1,1084,"\n"]],[1082,1082],[1083,1083]]],[1571217327418,["GJX@GJXAIOU",[[1,1083,"```"]],[1083,1083],[1086,1086]]],[1571217327444,["GJX@GJXAIOU",[[1,1086,"language\n```\n"]],[1086,1086],[1086,1094]]],[1571217328495,["GJX@GJXAIOU",[[-1,1086,"language"],[1,1094,"j"]],[1086,1094],[1087,1087]]],[1571217328929,["GJX@GJXAIOU",[[1,1087,"ava"]],[1087,1087],[1090,1090]]],[1571217329022,["GJX@GJXAIOU",[[1,1091,"\n"]],[1090,1090],[1091,1091]]],[1571217331502,["GJX@GJXAIOU",[[1,1091,"package com.atguigu.principle.singleresponsibility;\n\npublic class SingleResponsibility2 {\n\n\tpublic static void main(String[] args) {\n\t\tRoadVehicle roadVehicle = new RoadVehicle();\n\t\troadVehicle.run(\"摩托车\");\n\t\troadVehicle.run(\"汽车\");\n\t\t\n\t\tAirVehicle airVehicle = new AirVehicle();\n\t\tairVehicle.run(\"飞机\");\n\t}\n\n}\n\n//方案2的分析\n//1. 遵守单一职责原则\n//2. 但是这样做的改动很大，即要将类分解，同时修改客户端\n//3. 改进：直接修改Vehicle 类，改动的代码会比较少=>方案3\n\nclass RoadVehicle {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + \"公路运行\");\n\t}\n}\n\nclass AirVehicle {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + \"天空运行\");\n\t}\n}\n\nclass WaterVehicle {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + \"水中运行\");\n\t}\n}"]],[1091,1091],[1793,1793]]],[1571217334273,["GJX@GJXAIOU",[[1,1800,"\n"]],[1797,1797],[1798,1798]]],[1571217334398,["GJX@GJXAIOU",[[1,1801,"\n"]],[1798,1798],[1799,1799]]],[1571217335294,["GJX@GJXAIOU",[[1,1799,"shiyo"]],[1799,1799],[1804,1804]]],[1571217336368,["GJX@GJXAIOU",[[-1,1799,"shiyo"]],[1804,1804],[1799,1799]]],[1571217348857,["GJX@GJXAIOU",[[1,1799,"使用单一职责原则："]],[1799,1799],[1808,1808]]],[1571217349473,["GJX@GJXAIOU",[[-1,1807,"："]],[1808,1808],[1807,1807]]],[1571217349952,["GJX@GJXAIOU",[[1,1810,"\n"]],[1807,1807],[1808,1808]]],[1571217350639,["GJX@GJXAIOU",[[1,1808,"1"]],[1808,1808],[1809,1809]]],[1571217351262,["GJX@GJXAIOU",[[-1,1808,"1"]],[1809,1809],[1808,1808]]],[1571217351903,["GJX@GJXAIOU",[[1,1808,"···"]],[1808,1808],[1811,1811]]],[1571217352633,["GJX@GJXAIOU",[[-1,1808,"···"]],[1811,1811],[1808,1808]]],[1571217353784,["GJX@GJXAIOU",[[1,1808,"```"]],[1808,1808],[1811,1811]]],[1571217353809,["GJX@GJXAIOU",[[1,1811,"language\n```\n"]],[1811,1811],[1811,1819]]],[1571217353992,["GJX@GJXAIOU",[[-1,1811,"language"],[1,1819,"j"]],[1811,1819],[1812,1812]]],[1571217354553,["GJX@GJXAIOU",[[1,1812,"ava"]],[1812,1812],[1815,1815]]],[1571217354695,["GJX@GJXAIOU",[[1,1816,"\n"]],[1815,1815],[1816,1816]]],[1571217467074,["GJX@GJXAIOU",[[1,1816,"package com.atguigu.principle.singleresponsibility;\n\npublic class SingleResponsibility3 {\n\tpublic static void main(String[] args) {\n\t\tVehicle2 vehicle2  = new Vehicle2();\n\t\tvehicle2.run(\"汽车\");\n\t\tvehicle2.runWater(\"轮船\");\n\t\tvehicle2.runAir(\"飞机\");\n\t}\n}\n\n//方式3的分析\n//1. 这种修改方法没有对原来的类做大的修改，只是增加方法\n//2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责\nclass Vehicle2 {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + \" 在公路上运行....\");\n\t}\n\t\n\tpublic void runAir(String vehicle) {\n\t\tSystem.out.println(vehicle + \" 在天空上运行....\");\n\t}\n\t\n\tpublic void runWater(String vehicle) {\n\t\tSystem.out.println(vehicle + \" 在水中行....\");\n\t}\n\n\t// 对于拓展的功能只需要在这里新增功能即可\n}\n"]],[1816,1816],[2462,2462]]],[1571217470741,["GJX@GJXAIOU",[[-1,2462,"\n"]],[2462,2462],[2461,2461]]],[1571217489564,["GJX@GJXAIOU",[[1,2467,"### 2.1.1 单一职责原则注意事项和细节\n\n1) ![](file:///C:/Users/gjx16/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)![](file:///C:/Users/gjx16/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)![](file:///C:/Users/gjx16/AppData/Local/Temp/msohtmlclip1/01/clip_image003.gif)![](file:///C:/Users/gjx16/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)![](file:///C:/Users/gjx16/AppData/Local/Temp/msohtmlclip1/01/clip_image005.gif)降低类的复杂度，一个类只负责一项职责。\n\n2) 提高类的可读性，可维护性\n\n3) 降低变更引起的风险\n\n通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则"]],[2467,2467],[2990,2990]]],[1571217494241,["GJX@GJXAIOU",[[-1,2492,"1) ![](file:///C:/Users/gjx16/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)![](file:///C:/Users/gjx16/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)![](file:///C:/Users/gjx16/AppData/Local/Temp/msohtmlclip1/01/clip_image003.gif)![](file:///C:/Users/gjx16/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)![](file:///C:/Users/gjx16/AppData/Local/Temp/msohtmlclip1/01/clip_image005.gif)"]],[2492,2895],[2492,2492]]],[1571217495640,["GJX@GJXAIOU",[[1,2492,"- "]],[2492,2492],[2494,2494]]],[1571217507214,["GJX@GJXAIOU",[[-1,602,"2.3.2"]],[602,607],[602,602]]],[1571217508719,["GJX@GJXAIOU",[[1,601,"#"]],[602,602],[608,608]]],[1571217509127,["GJX@GJXAIOU",[[1,608,"23"]],[608,608],[610,610]]],[1571217510350,["GJX@GJXAIOU",[[1,608," "],[-1,608," 32"]],[610,610],[608,608]]],[1571217513302,["GJX@GJXAIOU",[[1,604,"2 "]],[604,604],[605,605]]],[1571217513488,["GJX@GJXAIOU",[[1,605,"."]],[605,605],[606,606]]],[1571217519320,["GJX@GJXAIOU",[[1,2469,"#"]],[2469,2469],[2490,2490]]],[1571217522110,["GJX@GJXAIOU",[[-1,2471,"2.1.1 "]],[2477,2477],[2471,2471]]],[1571217522973,["GJX@GJXAIOU",[[1,2471,"3 "]],[2471,2471],[2472,2472]]],[1571217523119,["GJX@GJXAIOU",[[1,2472,"."]],[2472,2472],[2473,2473]]],[1571217526606,["GJX@GJXAIOU",[[-1,2512,"2)"]],[2512,2514],[2512,2512]]],[1571217526774,["GJX@GJXAIOU",[[-1,2511,"\n"]],[2512,2512],[2511,2511]]],[1571217527039,["GJX@GJXAIOU",[[1,2511,"-"]],[2511,2511],[2512,2512]]],[1571217527415,["GJX@GJXAIOU",[[1,2513," "]],[2512,2512],[2513,2513]]],[1571217528616,["GJX@GJXAIOU",[[-1,2513," "]],[2513,2513],[2512,2512]]],[1571217531568,["GJX@GJXAIOU",[[-1,2526,"\n3) "]],[2526,2530],[2526,2526]]],[1571217531913,["GJX@GJXAIOU",[[-1,2525,"\n"]],[2526,2526],[2525,2525]]],[1571217533087,["GJX@GJXAIOU",[[1,2525,"\n"]],[2525,2525],[2526,2526]]],[1571217534129,["GJX@GJXAIOU",[[1,2526,"- "]],[2526,2526],[2528,2528]]],[1571217543249,["GJX@GJXAIOU",[[1,2582,";"]],[2582,2582],[2583,2583]]],[1571217548307,["GJX@GJXAIOU",[[-1,2582,";"]],[2583,2583],[2582,2582]]],[1571217608628,[null,[[-1,611," "],[1,612,"\n"]],[611,611],[613,613]]],[1571217608628,[null,[[1,611," "],[-1,611,"\n"]],[613,613],[611,611]]],[1571217561204,["GJX@GJXAIOU",[[1,2582,"；1) 只有类中方法数量足够少，可以在方法级别保持单一职责原则"]],[2582,2582],[2613,2613]]],[1571217568087,["GJX@GJXAIOU",[[-1,2583,"1) "]],[2586,2586],[2583,2583]]],[1571217572920,["GJX@GJXAIOU",[[1,2612,"\n"]],[2611,2611],[2612,2612]]],[1571217573048,["GJX@GJXAIOU",[[1,2613,"\n"]],[2612,2612],[2613,2613]]],[1571217573195,["GJX@GJXAIOU",[[1,2614,"\n"]],[2613,2613],[2614,2614]]],[1571217573293,["GJX@GJXAIOU",[[1,2615,"\n"]],[2614,2614],[2615,2615]]],[1571217586039,["GJX@GJXAIOU",[[1,2613,"## 2.1 接口隔离原则(Interface Segregation Principle)\n\n### 2.1.1 基本介绍\n\n1) 客户端不应该依赖它不需要的接口，即**一个类对另一个类的依赖应该建立在最小的接口**上\n\n2) 先看一张图:\n\n |  |  |  |  |  |  |\n|  |  | ![](file:///C:/Users/gjx16/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif) |  | ![](file:///C:/Users/gjx16/AppData/Local/Temp/msohtmlclip1/01/clip_image003.gif) |\n|  | ![](file:///C:/Users/gjx16/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif) |\n|  |\n|  | \n\n3) 类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C\n\n来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。\n\n4) 按隔离原则应当这样处理：\n\n**将接口** **Interface1** 拆分为**独立的几个接口****(****这里我们拆分成** **3** **个接口****)**，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则\n\n### 2.1.2 应用实例\n\n1) 类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，请编写代码完成此应用实例。\n\n2) 看老师代码-没有使用接口隔离原则代码"]],[2613,2613],[3389,3389]]],[1571217588263,["GJX@GJXAIOU",[[1,2615,"#"]],[2615,2615],[2660,2660]]],[1571217591117,["GJX@GJXAIOU",[[-1,2617,"2.1"]],[2617,2620],[2617,2617]]],[1571217591968,["GJX@GJXAIOU",[[1,2617,"（）"]],[2617,2617],[2619,2619]]],[1571217593131,["GJX@GJXAIOU",[[1,2618,"二"]],[2618,2618],[2619,2619]]],[1571217595633,["GJX@GJXAIOU",[[-1,2620," "]],[2621,2621],[2620,2620]]],[1571217606241,["GJX@GJXAIOU",[[-1,2665,"2.1.1 "]],[2665,2671],[2665,2665]]],[1571217606879,["GJX@GJXAIOU",[[1,2665,"1 "]],[2665,2665],[2666,2666]]],[1571217607048,["GJX@GJXAIOU",[[1,2666,"."]],[2666,2666],[2667,2667]]],[1571217608494,["GJX@GJXAIOU",[[-1,2667," "]],[2668,2668],[2667,2667]]],[1571217668632,[null,[[-1,611," "],[1,612,"\n"]],[611,611],[613,613]]],[1571217668632,[null,[[1,611," "],[-1,611,"\n"]],[613,613],[611,611]]],[1571217609279,["GJX@GJXAIOU",[[1,2664,"#"]],[2667,2667],[2672,2672]]],[1571217612165,["GJX@GJXAIOU",[[-1,2675,") "]],[2677,2677],[2675,2675]]],[1571217612463,["GJX@GJXAIOU",[[1,2675,"-"]],[2675,2675],[2676,2676]]],[1571217613150,["GJX@GJXAIOU",[[-1,2675,"-"]],[2676,2676],[2675,2675]]],[1571217613178,["GJX@GJXAIOU",[[1,2675,"="]],[2675,2675],[2676,2676]]],[1571217613744,["GJX@GJXAIOU",[[-1,2674,"1="]],[2676,2676],[2674,2674]]],[1571217614883,["GJX@GJXAIOU",[[1,2674,"- "]],[2674,2674],[2676,2676]]],[1571217622992,["GJX@GJXAIOU",[[1,2719,"；"]],[2719,2719],[2720,2720]]],[1571217848636,[null,[[-1,611," "],[1,612,"\n"]],[611,611],[613,613]]],[1571217848636,[null,[[1,611," "],[-1,611,"\n"]],[613,613],[611,611]]],[1571217801070,["GJX@GJXAIOU",[[-1,2733," |  |  |  |  |  |  |\n|  |  | ![](file:///C:/Users/gjx16/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif) |  | ![](file:///C:/Users/gjx16/AppData/Local/Temp/msohtmlclip1/01/clip_image003.gif) |\n|  | ![](file:///C:/Users/gjx16/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif) |\n|  |\n|  | \n"]],[2733,3030],[2733,2733]]],[1571217803670,["GJX@GJXAIOU",[[-1,2722,"2) "]],[2722,2725],[2722,2722]]],[1571217811993,["GJX@GJXAIOU",[[1,2729,"![接口隔离原则]($resource/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.jpg)"]],[2729,2729],[2809,2809]]],[1571217816406,["GJX@GJXAIOU",[[-1,2810,"3) "]],[2810,2813],[2810,2810]]],[1571217847789,["GJX@GJXAIOU",[[-1,2889,"\n"]],[2890,2890],[2889,2889]]],[1571217848165,["GJX@GJXAIOU",[[-1,2888,"\n"]],[2889,2889],[2888,2888]]],[1571217908637,[null,[[-1,611," "],[1,612,"\n"]],[611,611],[613,613]]],[1571217908637,[null,[[1,611," "],[-1,611,"\n"]],[613,613],[611,611]]],[1571217859802,["GJX@GJXAIOU",[[1,2862,"，"]],[2862,2862],[2863,2863]]],[1571217866449,["GJX@GJXAIOU",[[1,2862,"其中类B"]],[2862,2862],[2866,2866]]],[1571217866479,["GJX@GJXAIOU",[[1,2865," "]],[2866,2866],[2867,2867]]],[1571217870261,["GJX@GJXAIOU",[[1,2867," 和类D"]],[2867,2867],[2871,2871]]],[1571217870290,["GJX@GJXAIOU",[[1,2870," "]],[2871,2871],[2872,2872]]],[1571217874843,["GJX@GJXAIOU",[[1,2872,"实现"]],[2872,2872],[2874,2874]]],[1571217874871,["GJX@GJXAIOU",[[1,2872," "]],[2874,2874],[2875,2875]]],[1571217888817,["GJX@GJXAIOU",[[1,2875,"了接口 Interface1"]],[2875,2875],[2889,2889]]],[1571217901961,["GJX@GJXAIOU",[[-1,2974,"** **"]],[2978,2978],[2974,2974]]],[1571217904752,["GJX@GJXAIOU",[[-1,2984,"** "]],[2987,2987],[2984,2984]]],[1571217905977,["GJX@GJXAIOU",[[-1,2988,"*"]],[2988,2988],[2987,2987]]],[1571217906983,["GJX@GJXAIOU",[[-1,2987,"*"]],[2988,2988],[2987,2987]]],[1571217908263,["GJX@GJXAIOU",[[-1,2995,"***"]],[2997,2997],[2994,2994]]],[1571217968633,[null,[[-1,611," "],[1,612,"\n"]],[611,611],[613,613]]],[1571217968633,[null,[[1,611," "],[-1,611,"\n"]],[613,613],[611,611]]],[1571217909111,["GJX@GJXAIOU",[[-1,2994,"*"]],[2995,2995],[2994,2994]]],[1571217910735,["GJX@GJXAIOU",[[-1,2995,"****"]],[2999,2999],[2995,2995]]],[1571217912650,["GJX@GJXAIOU",[[-1,3002,"** **"]],[3007,3007],[3002,3002]]],[1571217914719,["GJX@GJXAIOU",[[-1,3003,"** **"]],[3008,3008],[3003,3003]]],[1571217916553,["GJX@GJXAIOU",[[-1,3006,"****"]],[3010,3010],[3006,3006]]],[1571217917735,["GJX@GJXAIOU",[[-1,3007,"**"]],[3009,3009],[3007,3007]]],[1571217919243,["GJX@GJXAIOU",[[1,3002," "]],[3002,3002],[3003,3003]]],[1571217919899,["GJX@GJXAIOU",[[1,3004," "]],[3004,3004],[3005,3005]]],[1571217921279,["GJX@GJXAIOU",[[-1,2969,"**"]],[2971,2971],[2969,2969]]],[1571217926982,["GJX@GJXAIOU",[[-1,2952,"4) "]],[2952,2955],[2952,2952]]],[1571217927442,["GJX@GJXAIOU",[[1,2952,"\n"]],[2952,2952],[2953,2953]]],[1571217929027,["GJX@GJXAIOU",[[1,2953,"- "]],[2953,2953],[2955,2955]]],[1571217931062,["GJX@GJXAIOU",[[-1,2968,"\n将接"]],[2968,2971],[2968,2968]]],[1571217935168,["GJX@GJXAIOU",[[1,2810,"- "]],[2810,2810],[2812,2812]]],[1571217941718,["GJX@GJXAIOU",[[1,3049,"#"]],[3053,3053],[3061,3061]]],[1571217944918,["GJX@GJXAIOU",[[-1,3051,"2.1.2 "]],[3057,3057],[3051,3051]]],[1571217945835,["GJX@GJXAIOU",[[1,3051,"2 "]],[3051,3051],[3052,3052]]],[1571217946015,["GJX@GJXAIOU",[[1,3052,"."]],[3052,3052],[3053,3053]]],[1571217951014,["GJX@GJXAIOU",[[-1,3060,"1) "]],[3060,3063],[3060,3060]]],[1571218028637,[null,[[-1,611," "],[1,612,"\n"]],[611,611],[613,613]]],[1571218028637,[null,[[1,611," "],[-1,611,"\n"]],[613,613],[611,611]]],[1571217973918,["GJX@GJXAIOU",[[-1,3060,"类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，请编写代码完成此应用实例。\n\n2) 看老师代码-没有使用接口隔离原则代码"]],[3112,3148],[3060,3060]]],[1571217981459,["GJX@GJXAIOU",[[1,3060,"没有使用接口隔离原则的代码"]],[3060,3060],[3073,3073]]],[1571217982145,["GJX@GJXAIOU",[[1,3076,"\n"]],[3073,3073],[3074,3074]]],[1571217983448,["GJX@GJXAIOU",[[1,3074,"```"]],[3074,3074],[3077,3077]]],[1571217983475,["GJX@GJXAIOU",[[1,3077,"language\n```\n"]],[3077,3077],[3077,3085]]],[1571217983680,["GJX@GJXAIOU",[[-1,3077,"language"],[1,3085,"j"]],[3077,3085],[3078,3078]]],[1571217984055,["GJX@GJXAIOU",[[1,3078,"av"]],[3078,3078],[3080,3080]]],[1571217984134,["GJX@GJXAIOU",[[1,3081,"\n"]],[3080,3080],[3081,3081]]],[1571217984173,["GJX@GJXAIOU",[[1,3081,"a"]],[3081,3081],[3082,3082]]],[1571217984902,["GJX@GJXAIOU",[[-1,3081,"a"]],[3082,3082],[3081,3081]]],[1571217985225,["GJX@GJXAIOU",[[-1,3081,"\n"]],[3081,3081],[3080,3080]]],[1571217985441,["GJX@GJXAIOU",[[1,3080,"a"]],[3080,3080],[3081,3081]]],[1571217985962,["GJX@GJXAIOU",[[1,3082,"\n"]],[3081,3081],[3082,3082]]]],null,"GJX@GJXAIOU"],["8e654333-17bb-42c0-b5f8-c54f80422f3f",1571226754842,"# 第二章：设计模式七大原则\n\n## 一、设计模式的目的\n\n编写软件过程中，程序员面临着来自 **耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性** 等多方面的挑战，设计模式是为了让程序(软件)，具有更好\n\n- 代码重用性 (即：相同功能的代码，不用多次编写)\n- 可读性 (即：编程规范性, 便于其他程序员的阅读和理解)\n- 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)\n- 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)\n- 使程序呈现高内聚，低耦合的特性\n- 设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要”\n\n\n\n## 二、设计模式七大原则\n\n设计模式原则，其实就是**程序员在编程时，应当遵守的原则**，也是各种**设计模式的基础**(即：**设计模式为什么这样设计的依据**)\n\n设计模式常用的七大原则有:\n* 单一职责原则\n* 接口隔离原则\n* 依赖倒转(倒置)原则\n* 里氏替换原则\n* 开闭原则\n* 迪米特法则\n* 合成复用原则\n\n### （一）单一职责原则\n\n#### 1. 基本介绍\n\n对类来说的，**即一个类应该只负责一项职责**。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2\n\n####  2. 应用实例\n\n不使用单一职责原则：\n```java\npackage com.atguigu.principle.singleresponsibility;\n\npublic class SingleResponsibility1 {\n\tpublic static void main(String[] args) {\n\t\tVehicle vehicle = new Vehicle();\n\t\tvehicle.run(\"摩托车\");\n\t\tvehicle.run(\"汽车\");\n\t\tvehicle.run(\"飞机\");\n\t}\n}\n\n/**\n * 方式1：只使用一个交通工具类\n * \t1. 在方式 1 的 run方法中，违反了单一职责原则\n * \t2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可\n */\nclass Vehicle {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + \" 在公路上运行....\");\n\t}\n}\n\n```\n\n改进方式：\n```java\npackage com.atguigu.principle.singleresponsibility;\n\npublic class SingleResponsibility2 {\n\n\tpublic static void main(String[] args) {\n\t\tRoadVehicle roadVehicle = new RoadVehicle();\n\t\troadVehicle.run(\"摩托车\");\n\t\troadVehicle.run(\"汽车\");\n\t\t\n\t\tAirVehicle airVehicle = new AirVehicle();\n\t\tairVehicle.run(\"飞机\");\n\t}\n\n}\n\n//方案2的分析\n//1. 遵守单一职责原则\n//2. 但是这样做的改动很大，即要将类分解，同时修改客户端\n//3. 改进：直接修改Vehicle 类，改动的代码会比较少=>方案3\n\nclass RoadVehicle {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + \"公路运行\");\n\t}\n}\n\nclass AirVehicle {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + \"天空运行\");\n\t}\n}\n\nclass WaterVehicle {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + \"水中运行\");\n\t}\n}\n```\n\n使用单一职责原则\n```java\npackage com.atguigu.principle.singleresponsibility;\n\npublic class SingleResponsibility3 {\n\tpublic static void main(String[] args) {\n\t\tVehicle2 vehicle2  = new Vehicle2();\n\t\tvehicle2.run(\"汽车\");\n\t\tvehicle2.runWater(\"轮船\");\n\t\tvehicle2.runAir(\"飞机\");\n\t}\n}\n\n//方式3的分析\n//1. 这种修改方法没有对原来的类做大的修改，只是增加方法\n//2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责\nclass Vehicle2 {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + \" 在公路上运行....\");\n\t}\n\t\n\tpublic void runAir(String vehicle) {\n\t\tSystem.out.println(vehicle + \" 在天空上运行....\");\n\t}\n\t\n\tpublic void runWater(String vehicle) {\n\t\tSystem.out.println(vehicle + \" 在水中行....\");\n\t}\n\n\t// 对于拓展的功能只需要在这里新增功能即可\n}\n```\n\n#### 3. 单一职责原则注意事项和细节\n\n- 降低类的复杂度，一个类只负责一项职责。\n- 提高类的可读性，可维护性\n- 降低变更引起的风险\n\n通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则\n\n\n### （二）接口隔离原则(Interface Segregation Principle)\n\n#### 1.基本介绍\n\n- 客户端不应该依赖它不需要的接口，即**一个类对另一个类的依赖应该建立在最小的接口**上；\n\n先看一张图:\n![接口隔离原则]($resource/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.jpg)\n\n- 类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，其中类 B 和类 D 实现了接口 Interface1，如果接口 Interface1 对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。\n\n\n- 按隔离原则应当这样处理：\n口Interface1拆分为独立的几个接口(这里我们拆分成 3 个接口)，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则\n\n#### 2. 应用实例\n\n没有使用接口隔离原则的代码\n```java\n\n```\n\n\n\n",[[1571226720760,["GJX@GJXAIOU",[[1,3044,"【【【【【【【【"]],[3044,3044],[3052,3052]]],[1571226722121,["GJX@GJXAIOU",[[-1,3044,"【【【【【【【【"]],[3052,3052],[3044,3044]]],[1571226723039,["GJX@GJXAIOU",[[1,3044,"】"]],[3044,3044],[3045,3045]]],[1571226723995,["GJX@GJXAIOU",[[-1,3044,"】"]],[3045,3045],[3044,3044]]],[1571227964350,["GJX@GJXAIOU",[[1,3082,"package com.atguigu.principle.segregation;\n\npublic class Segregation1 {\n\tpublic static void main(String[] args) {\n\t}\n}\n\n// 接口 Interface1\ninterface Interface1 {\n\tvoid operation1();\n\tvoid operation2();\n\tvoid operation3();\n\tvoid operation4();\n\tvoid operation5();\n}\n\n/**\n *  类 B 实现了接口 Interface1\n */\nclass B implements Interface1 {\n\t@Override\n\tpublic void operation1() {\n\t\tSystem.out.println(\"B 实现了 operation1\");\n\t}\n\t@Override\n\tpublic void operation2() {\n\t\tSystem.out.println(\"B 实现了 operation2\");\n\t}\n\t@Override\n\tpublic void operation3() {\n\t\tSystem.out.println(\"B 实现了 operation3\");\n\t}\n\t@Override\n\tpublic void operation4() {\n\t\tSystem.out.println(\"B 实现了 operation4\");\n\t}\n\t@Override\n\tpublic void operation5() {\n\t\tSystem.out.println(\"B 实现了 operation5\");\n\t}\n}\n\n/**\n * 类 D 实现了接口 Interface1\n */\nclass D implements Interface1 {\n\t@Override\n\tpublic void operation1() {\n\t\tSystem.out.println(\"D 实现了 operation1\");\n\t}\n\t@Override\n\tpublic void operation2() {\n\t\tSystem.out.println(\"D 实现了 operation2\");\n\t}\n\t@Override\n\tpublic void operation3() {\n\t\tSystem.out.println(\"D 实现了 operation3\");\n\t}\n\t@Override\n\tpublic void operation4() {\n\t\tSystem.out.println(\"D 实现了 operation4\");\n\t}\n\t@Override\n\tpublic void operation5() {\n\t\tSystem.out.println(\"D 实现了 operation5\");\n\t}\n}\n\n/**\n * A 类通过接口 Interface1 依赖(使用) B 类，但是只会用到 1,2,3 方法\n */\nclass A {\n\tpublic void depend1(Interface1 i) {\n\t\ti.operation1();\n\t}\n\tpublic void depend2(Interface1 i) {\n\t\ti.operation2();\n\t}\n\tpublic void depend3(Interface1 i) {\n\t\ti.operation3();\n\t}\n}\n\n/**\n *  C 类通过接口 Interface1 依赖(使用) D 类，但是只会用到 1,4,5 方法\n */\nclass C {\n\tpublic void depend1(Interface1 i) {\n\t\ti.operation1();\n\t}\n\tpublic void depend4(Interface1 i) {\n\t\ti.operation4();\n\t}\n\tpublic void depend5(Interface1 i) {\n\t\ti.operation5();\n\t}\n}"]],[3082,3082],[4807,4807]]],[1571227968229,["GJX@GJXAIOU",[[1,4815,"\n"]],[4811,4811],[4812,4812]]],[1571227968366,["GJX@GJXAIOU",[[1,4816,"\n"]],[4812,4812],[4813,4813]]],[1571227992288,["GJX@GJXAIOU",[[1,4813,"### 2.1.1 应传统方法的问题和使用接口隔离原则改进\n\n1) 类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C\n\n来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法\n\n2) 将接口 **Interface1** **拆分为独立的几个接口**，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则\n\n3) 接口 Interface1 中出现的方法，根据实际情况拆分为**三个**接口"]],[4813,4813],[5079,5079]]],[1571228005796,["GJX@GJXAIOU",[[-1,4812,"\n### 2.1.1 应"]],[4812,4823],[4812,4812]]],[1571228006075,["GJX@GJXAIOU",[[1,4812,"\n"]],[4812,4812],[4813,4813]]],[1571228012136,["GJX@GJXAIOU",[[1,4813,"使用"]],[4813,4813],[4815,4815]]],[1571228016790,["GJX@GJXAIOU",[[-1,4834,"\n1) "]],[4834,4838],[4834,4834]]],[1571228025052,["GJX@GJXAIOU",[[-1,4913,"\n"]],[4914,4914],[4913,4913]]],[1571228025526,["GJX@GJXAIOU",[[-1,4912,"\n"]],[4913,4913],[4912,4912]]],[1571228027340,["GJX@GJXAIOU",[[1,4912," "]],[4912,4912],[4913,4913]]],[1571228029228,["GJX@GJXAIOU",[[1,4834,"\n"]],[4834,4834],[4835,4835]]],[1571228029698,["GJX@GJXAIOU",[[1,4835,"- "]],[4835,4835],[4837,4837]]],[1571228032181,["GJX@GJXAIOU",[[-1,4950,"\n2)"]],[4950,4953],[4950,4950]]],[1571228032438,["GJX@GJXAIOU",[[1,4950,"-"]],[4950,4950],[4951,4951]]],[1571228032646,["GJX@GJXAIOU",[[1,4952," "]],[4951,4951],[4952,4952]]],[1571228035691,["GJX@GJXAIOU",[[-1,4969,"** **"]],[4969,4974],[4969,4969]]],[1571228036710,["GJX@GJXAIOU",[[1,4969," "]],[4969,4969],[4970,4970]]],[1571228043987,["GJX@GJXAIOU",[[-1,5022,"3) "]],[5022,5025],[5022,5022]]],[1571228048449,["GJX@GJXAIOU",[[1,5022,"本为题"]],[5022,5022],[5025,5025]]],[1571228049588,["GJX@GJXAIOU",[[-1,5023,"为题"]],[5025,5025],[5023,5023]]],[1571228050718,["GJX@GJXAIOU",[[1,5023,"文职"]],[5023,5023],[5025,5025]]],[1571228051427,["GJX@GJXAIOU",[[-1,5023,"文职"]],[5025,5025],[5023,5023]]],[1571228054775,["GJX@GJXAIOU",[[1,5023,"问题中，"]],[5023,5023],[5027,5027]]],[1571228235534,["GJX@GJXAIOU",[[1,5067,"![接口隔离原则改进]($resource/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E6%94%B9%E8%BF%9B.jpg)"]],[5067,5067],[5167,5167]]],[1571228393826,["GJX@GJXAIOU",[[1,5168,"\n"]],[5167,5167],[5168,5168]]],[1571228394168,["GJX@GJXAIOU",[[-1,5168,"\n"],[1,5169,"·"]],[5168,5168],[5169,5169]]],[1571228394543,["GJX@GJXAIOU",[[1,5169,"··"]],[5169,5169],[5171,5171]]],[1571228395714,["GJX@GJXAIOU",[[-1,5169,"··"]],[5171,5171],[5169,5169]]],[1571228395885,["GJX@GJXAIOU",[[-1,5168,"·"],[1,5169,"\n"]],[5169,5169],[5168,5168]]],[1571228396582,["GJX@GJXAIOU",[[-1,5168,"\n"],[1,5169,"`"]],[5168,5168],[5169,5169]]],[1571228396976,["GJX@GJXAIOU",[[1,5169,"][``"]],[5169,5169],[5173,5173]]],[1571228398667,["GJX@GJXAIOU",[[-1,5169,"][``"]],[5173,5173],[5169,5169]]],[1571228399189,["GJX@GJXAIOU",[[-1,5168,"`"],[1,5169,"\n"]],[5169,5169],[5168,5168]]],[1571228399502,["GJX@GJXAIOU",[[-1,5168,"\n"],[1,5169,"`"]],[5168,5168],[5169,5169]]],[1571228399871,["GJX@GJXAIOU",[[1,5169,"``"]],[5169,5169],[5171,5171]]],[1571228399935,["GJX@GJXAIOU",[[1,5171,"language\n```\n"]],[5171,5171],[5171,5179]]],[1571228401318,["GJX@GJXAIOU",[[-1,5171,"language"],[1,5179,"j"]],[5171,5179],[5172,5172]]],[1571228401749,["GJX@GJXAIOU",[[1,5172,"ava"]],[5172,5172],[5175,5175]]],[1571228401910,["GJX@GJXAIOU",[[1,5176,"\n"]],[5175,5175],[5176,5176]]],[1571228405714,["GJX@GJXAIOU",[[1,5176,"package com.atguigu.principle.segregation.improve;\n\npublic class Segregation1 {\n\n\tpublic static void main(String[] args) {\n        // A类通过接口去依赖B类\n\t\tA a = new A();\n\t\ta.depend1(new B()); \n\t\ta.depend2(new B());\n\t\ta.depend3(new B());\n\n        // C类通过接口去依赖(使用)D类\n\t\tC c = new C();\n\t\tc.depend1(new D()); \n\t\tc.depend4(new D());\n\t\tc.depend5(new D());\n\n\t}\n\n}\n\n// 接口1\ninterface Interface1 {\n\tvoid operation1();\n}\n\n// 接口2\ninterface Interface2 {\n\tvoid operation2();\n\tvoid operation3();\n}\n\n// 接口3\ninterface Interface3 {\n\tvoid operation4();\n\tvoid operation5();\n}\n\nclass B implements Interface1, Interface2 {\n\t@Override\n    public void operation1() {\n\t\tSystem.out.println(\"B 实现了 operation1\");\n\t}\n\n\t@Override\n    public void operation2() {\n\t\tSystem.out.println(\"B 实现了 operation2\");\n\t}\n\n\t@Override\n    public void operation3() {\n\t\tSystem.out.println(\"B 实现了 operation3\");\n\t}\n\n}\n\nclass D implements Interface1, Interface3 {\n\t@Override\n    public void operation1() {\n\t\tSystem.out.println(\"D 实现了 operation1\");\n\t}\n\n\t@Override\n    public void operation4() {\n\t\tSystem.out.println(\"D 实现了 operation4\");\n\t}\n\n\t@Override\n    public void operation5() {\n\t\tSystem.out.println(\"D 实现了 operation5\");\n\t}\n}\n\n// A 类通过接口Interface1,Interface2 依赖(使用) B类，但是只会用到1,2,3方法\nclass A {\n\tpublic void depend1(Interface1 i) {\n\t\ti.operation1();\n\t}\n\n\tpublic void depend2(Interface2 i) {\n\t\ti.operation2();\n\t}\n\n\tpublic void depend3(Interface2 i) {\n\t\ti.operation3();\n\t}\n}\n\n// C 类通过接口Interface1,Interface3 依赖(使用) D类，但是只会用到1,4,5方法\nclass C { \n\tpublic void depend1(Interface1 i) {\n\t\ti.operation1();\n\t}\n\n\tpublic void depend4(Interface3 i) {\n\t\ti.operation4();\n\t}\n\n\tpublic void depend5(Interface3 i) {\n\t\ti.operation5();\n\t}\n}"]],[5176,5176],[6835,6835]]],[1571228410861,["GJX@GJXAIOU",[[1,6840,"\n"]],[6839,6839],[6840,6840]]],[1571228411050,["GJX@GJXAIOU",[[1,6841,"\n"]],[6840,6840],[6841,6841]]],[1571228581557,["GJX@GJXAIOU",[[1,6842,"\n"]],[6841,6841],[6842,6842]]],[1571228582157,["GJX@GJXAIOU",[[1,6842,"## 2.1 依赖倒转原则\n\n### 2.1.1 基本介绍\n\n依赖倒转原则(Dependence Inversion Principle)是指：\n\n1) 高层模块不应该依赖低层模块，二者都应该依赖其抽象\n\n#### 2) 抽象不应该依赖细节，细节应该依赖抽象\n\n**3)** 依赖倒转(倒置)的中心思想是**面向接口编程**\n\n4) 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类\n\n5) 使用**接口或抽象类**的目的是制定好**规范**，而不涉及任何具体的操作，把**展现细节的任务交给他们的实现类**去完成\n\n### 2.1.2 应用实例\n\n请编程完成 Person 接收消息 的功能。\n\n1) 实现方案 1 + 分析说明"]],[6842,6842],[7229,7229]]],[1571228585613,["GJX@GJXAIOU",[[-1,6842,"## 2.1 "]],[6842,6849],[6842,6842]]],[1571228589682,["GJX@GJXAIOU",[[1,6842,"### ()"]],[6842,6842],[6848,6848]]],[1571228590873,["GJX@GJXAIOU",[[-1,6846,"()"]],[6848,6848],[6846,6846]]],[1571228591444,["GJX@GJXAIOU",[[1,6846,"（）"]],[6846,6846],[6848,6848]]],[1571228593720,["GJX@GJXAIOU",[[1,6847,"三"]],[6847,6847],[6848,6848]]],[1571228597120,["GJX@GJXAIOU",[[-1,6861,"2..1"]],[6865,6865],[6861,6861]]],[1571228598485,["GJX@GJXAIOU",[[1,6860,"#"]],[6861,6861],[6868,6868]]],[1571228606531,["GJX@GJXAIOU",[[-1,6913,"1) "]],[6913,6916],[6913,6913]]],[1571228607063,["GJX@GJXAIOU",[[1,6913,"- "]],[6913,6913],[6915,6915]]],[1571228610684,["GJX@GJXAIOU",[[-1,6941,"#### 2) "]],[6941,6949],[6941,6941]]],[1571228611237,["GJX@GJXAIOU",[[-1,6940,"\n"]],[6941,6941],[6940,6940]]],[1571228612252,["GJX@GJXAIOU",[[1,6940,"- "]],[6940,6940],[6942,6942]]],[1571228620324,["GJX@GJXAIOU",[[-1,6962,"**3)** "]],[6962,6969],[6962,6962]]],[1571228620509,["GJX@GJXAIOU",[[-1,6961,"\n"]],[6962,6962],[6961,6961]]],[1571228620960,["GJX@GJXAIOU",[[1,6961,"- "]],[6961,6961],[6963,6963]]],[1571228623859,["GJX@GJXAIOU",[[-1,6977,"**"]],[6979,6979],[6977,6977]]],[1571228624295,["GJX@GJXAIOU",[[1,6977," "]],[6977,6977],[6978,6978]]],[1571228625485,["GJX@GJXAIOU",[[-1,6977," "]],[6978,6978],[6977,6977]]],[1571228628348,["GJX@GJXAIOU",[[-1,6983,"**"]],[6985,6985],[6983,6983]]],[1571228629126,["GJX@GJXAIOU",[[1,6983,"；"]],[6983,6983],[6984,6984]]],[1571228630423,["GJX@GJXAIOU",[[1,6960,"；"]],[6960,6960],[6961,6961]]],[1571228633153,["GJX@GJXAIOU",[[1,6939,"；"]],[6939,6939],[6940,6940]]],[1571228642565,["GJX@GJXAIOU",[[-1,6988,"4) "]],[6991,6991],[6988,6988]]],[1571228643012,["GJX@GJXAIOU",[[-1,6987,"\n"]],[6988,6988],[6987,6987]]],[1571228643803,["GJX@GJXAIOU",[[1,6987,"- "]],[6987,6987],[6989,6989]]],[1571228658207,["GJX@GJXAIOU",[[1,7085,"；"]],[7085,7085],[7086,7086]]],[1571228661479,["GJX@GJXAIOU",[[-1,7088,"5)"]],[7090,7090],[7088,7088]]],[1571228661932,["GJX@GJXAIOU",[[-1,7087,"\n"]],[7088,7088],[7087,7087]]],[1571228662873,["GJX@GJXAIOU",[[1,7087,"-"]],[7087,7087],[7088,7088]]],[1571228670368,["GJX@GJXAIOU",[[1,7150,"；"]],[7150,7150],[7151,7151]]],[1571228675841,["GJX@GJXAIOU",[[1,6863,"。"]],[6863,6863],[6864,6864]]],[1571228676462,["GJX@GJXAIOU",[[-1,6863,"。"]],[6864,6864],[6863,6863]]],[1571228676638,["GJX@GJXAIOU",[[1,6863,"="]],[6863,6863],[6864,6864]]],[1571228677604,["GJX@GJXAIOU",[[-1,6863,"="]],[6864,6864],[6863,6863]]],[1571228678262,["GJX@GJXAIOU",[[1,6863,"."]],[6863,6863],[6864,6864]]],[1571228682829,["GJX@GJXAIOU",[[-1,7160,"1.2 "]],[7160,7164],[7160,7160]]],[1571228684421,["GJX@GJXAIOU",[[1,7157,"#"]],[7160,7160],[7165,7165]]],[1571228686998,["GJX@GJXAIOU",[[1,7161," "]],[7161,7161],[7162,7162]]],[1571228866125,["GJX@GJXAIOU",[[-1,7192,"1) 实现方案 1 + 分析说明"]],[7192,7208],[7192,7192]]],[1571228866711,["GJX@GJXAIOU",[[-1,7192,"\n"]],[7192,7192],[7191,7191]]],[1571228868137,["GJX@GJXAIOU",[[-1,7191,"\n"],[1,7192,"b"]],[7191,7191],[7192,7192]]],[1571228868313,["GJX@GJXAIOU",[[1,7192,"u"]],[7192,7192],[7193,7193]]],[1571228868828,["GJX@GJXAIOU",[[-1,7192,"u"]],[7193,7193],[7192,7192]]],[1571228869002,["GJX@GJXAIOU",[[-1,7191,"b"],[1,7192,"\n"]],[7192,7192],[7191,7191]]],[1571228870322,["GJX@GJXAIOU",[[-1,7191,"\n"],[1,7192,"一般"]],[7191,7191],[7193,7193]]],[1571228873585,["GJX@GJXAIOU",[[1,7193,"的实现方案"]],[7193,7193],[7198,7198]]],[1571228874013,["GJX@GJXAIOU",[[1,7198,"\n\n"]],[7198,7198],[7199,7199]]],[1571228875390,["GJX@GJXAIOU",[[-1,7199,"\n"],[1,7200,"`"]],[7199,7199],[7200,7200]]],[1571228875828,["GJX@GJXAIOU",[[1,7200,"``"]],[7200,7200],[7202,7202]]],[1571228875919,["GJX@GJXAIOU",[[1,7202,"language\n```\n"]],[7202,7202],[7202,7210]]],[1571228876599,["GJX@GJXAIOU",[[-1,7202,"language"],[1,7210,"j"]],[7202,7210],[7203,7203]]],[1571228877089,["GJX@GJXAIOU",[[1,7203,"ava"]],[7203,7203],[7206,7206]]],[1571228877147,["GJX@GJXAIOU",[[1,7207,"\n"]],[7206,7206],[7207,7207]]],[1571228880589,["GJX@GJXAIOU",[[1,7207,"package com.atguigu.principle.inversion;\n\n/**\n * 完成Person接收消息的功能\n * 问题：如果我们获取的对象是 微信，短信等等，则新增类，同时 Perons 也要增加相应的接收方法，因为 person 和 Email 绑定了\n * 解决思路：引入一个抽象的接口 IReceiver, 表示接收者, 这样 Person 类与接口 IReceiver 发生依赖\n * 因为 Email, WeiXin 等等属于接收的范围，他们各自实现 IReceiver 接口就 ok, 这样我们就符合依赖倒转原则\n */\npublic class DependecyInversion {\n\tpublic static void main(String[] args) {\n\t\tPerson person = new Person();\n\t\tperson.receive(new Email());\n\t}\n}\n\nclass Email {\n\tpublic String getInfo() {\n\t\treturn \"电子邮件信息: hello,world\";\n\t}\n}\n\nclass Person {\n\tpublic void receive(Email email ) {\n\t\tSystem.out.println(email.getInfo());\n\t}\n}\n"]],[7207,7207],[7805,7805]]],[1571228884366,["GJX@GJXAIOU",[[1,7810,"\n"]],[7809,7809],[7810,7810]]],[1571228884565,["GJX@GJXAIOU",[[1,7811,"\n"]],[7810,7810],[7811,7811]]],[1571229185591,["GJX@GJXAIOU",[[-1,7811,"\n"],[1,7812,"s"]],[7811,7811],[7812,7812]]],[1571229185840,["GJX@GJXAIOU",[[1,7812,"hi"]],[7812,7812],[7814,7814]]],[1571229186665,["GJX@GJXAIOU",[[-1,7812,"hi"]],[7814,7814],[7812,7812]]],[1571229186834,["GJX@GJXAIOU",[[-1,7811,"s"],[1,7812,"\n"]],[7812,7812],[7811,7811]]],[1571229188576,["GJX@GJXAIOU",[[-1,7811,"\n"],[1,7812,"使用"]],[7811,7811],[7813,7813]]],[1571229192514,["GJX@GJXAIOU",[[1,7813,"依赖反转之后"]],[7813,7813],[7819,7819]]],[1571229193238,["GJX@GJXAIOU",[[1,7819,"\n\n"]],[7819,7819],[7820,7820]]],[1571229194377,["GJX@GJXAIOU",[[-1,7820,"\n"],[1,7821,"`"]],[7820,7820],[7821,7821]]],[1571229194824,["GJX@GJXAIOU",[[1,7821,"``"]],[7821,7821],[7823,7823]]],[1571229194918,["GJX@GJXAIOU",[[1,7823,"language\n```\n"]],[7823,7823],[7823,7831]]],[1571229195491,["GJX@GJXAIOU",[[-1,7823,"language"],[1,7831,"j"]],[7823,7831],[7824,7824]]],[1571229195911,["GJX@GJXAIOU",[[1,7824,"ava"]],[7824,7824],[7827,7827]]],[1571229196001,["GJX@GJXAIOU",[[1,7828,"\n"]],[7827,7827],[7828,7828]]],[1571229198831,["GJX@GJXAIOU",[[1,7828,"package com.atguigu.principle.inversion.improve;\n\npublic class DependecyInversion {\n\tpublic static void main(String[] args) {\n\t\t//客户端无需改变\n\t\tPerson person = new Person();\n\t\tperson.receive(new Email());\n\t\tperson.receive(new WeiXin());\n\t}\n}\n\n/**\n * 定义接收消息统一接口\n */\ninterface IReceiver {\n\tpublic String getInfo();\n}\n\nclass Email implements IReceiver {\n\t@Override\n\tpublic String getInfo() {\n\t\treturn \"电子邮件信息: hello,world\";\n\t}\n}\n\n//增加微信\nclass WeiXin implements IReceiver {\n\t@Override\n\tpublic String getInfo() {\n\t\treturn \"微信信息: hello,ok\";\n\t}\n}\n\nclass Person {\n\t/**\n\t *  这里我们是对接口的依赖\n\t * @param receiver ：传入的参数是接口\n\t */\n\tpublic void receive(IReceiver receiver ) {\n\t\tSystem.out.println(receiver.getInfo());\n\t}\n}\n"]],[7828,7828],[8528,8528]]],[1571229201791,["GJX@GJXAIOU",[[1,8533,"\n"]],[8532,8532],[8533,8533]]],[1571229202013,["GJX@GJXAIOU",[[1,8534,"\n"]],[8533,8533],[8534,8534]]],[1571229224877,["GJX@GJXAIOU",[[1,8534,"#### 3.### 2.1.1 依赖关系传递的三种方式和应用案例\n\n1) 接口传递\n\n应用案例代码\n\n2) 构造方法传递应用案例代码\n\n3) setter 方式传递"]],[8534,8534],[8617,8617]]],[1571229228383,["GJX@GJXAIOU",[[-1,8541,"### 2.1.1 "]],[8541,8551],[8541,8541]]],[1571229228880,["GJX@GJXAIOU",[[1,8541," "]],[8541,8541],[8542,8542]]],[1571229238518,["GJX@GJXAIOU",[[-1,8560,"1) "]],[8560,8563],[8560,8560]]],[1571229241688,["GJX@GJXAIOU",[[1,8560,"- "]],[8560,8560],[8562,8562]]],[1571229243885,["GJX@GJXAIOU",[[-1,8576,"2) "]],[8576,8579],[8576,8576]]],[1571229244600,["GJX@GJXAIOU",[[1,8576,"-0  "]],[8576,8576],[8579,8579]]],[1571229245586,["GJX@GJXAIOU",[[-1,8577,"0 "]],[8579,8579],[8577,8577]]],[1571229246058,["GJX@GJXAIOU",[[1,8578," "]],[8577,8577],[8578,8578]]],[1571229247486,["GJX@GJXAIOU",[[-1,8578," "]],[8579,8579],[8578,8578]]],[1571229250549,["GJX@GJXAIOU",[[-1,8592,"3) "]],[8592,8595],[8592,8592]]],[1571229251472,["GJX@GJXAIOU",[[1,8592,"- "]],[8592,8592],[8594,8594]]],[1571229254318,["GJX@GJXAIOU",[[-1,8568,"应用案例代码"]],[8568,8574],[8568,8568]]],[1571229256158,["GJX@GJXAIOU",[[-1,8578,"应用案例代码"]],[8578,8584],[8578,8578]]],[1571229257238,["GJX@GJXAIOU",[[-1,8569,"\n"]],[8569,8569],[8568,8568]]],[1571229694551,["GJX@GJXAIOU",[[1,8567,"```]"]],[8567,8567],[8571,8571]]],[1571229694616,["GJX@GJXAIOU",[[-1,8570,"]"],[1,8571,"language\n```\n"]],[8571,8571],[8570,8578]]],[1571229694937,["GJX@GJXAIOU",[[-1,8570,"language"],[1,8578,"j"]],[8570,8578],[8571,8571]]],[1571229695113,["GJX@GJXAIOU",[[1,8571,"]"]],[8571,8571],[8572,8572]]],[1571229695901,["GJX@GJXAIOU",[[-1,8571,"]"]],[8572,8572],[8571,8571]]],[1571229696711,["GJX@GJXAIOU",[[1,8571,"ava"]],[8571,8571],[8574,8574]]],[1571229697033,["GJX@GJXAIOU",[[1,8575,"\n"]],[8574,8574],[8575,8575]]],[1571229698092,["GJX@GJXAIOU",[[1,8575,"[]["]],[8575,8575],[8578,8578]]],[1571229699910,["GJX@GJXAIOU",[[-1,8575,"[]["]],[8578,8578],[8575,8575]]],[1571229700118,["GJX@GJXAIOU",[[-1,8575,"\n"]],[8575,8575],[8574,8574]]],[1571229702983,["GJX@GJXAIOU",[[1,8575,"\n"]],[8574,8574],[8575,8575]]],[1571229705829,["GJX@GJXAIOU",[[1,8575,"package com.atguigu.principle.inversion.improve;\n\npublic class DependencyPass {\n\tpublic static void main(String[] args) {\n\t\tChangHong changHong = new ChangHong();\n\t\tOpenAndClose openAndClose = new OpenAndClose();\n\t\topenAndClose.open(changHong);\n\t\t\n\t\t//通过构造器进行依赖传递\n//\t\tOpenAndClose openAndClose = new OpenAndClose(changHong);\n//\t\topenAndClose.open();\n\n//\t\t//通过setter方法进行依赖传递\n//\t\tOpenAndClose openAndClose = new OpenAndClose();\n//\t\t// 如果不使用 setTV就没有对象，则会报空指针异常\n//\t\topenAndClose.setTv(changHong);\n//\t\topenAndClose.open();\n\n\t}\n\n}\n\n/**\n * 方式1： 通过接口传递实现依赖\n */\ninterface ITV {\n\tpublic void play();\n}\n\nclass ChangHong implements ITV {\n\t@Override\n\tpublic void play() {\n\t\tSystem.out.println(\"长虹电视机，打开\");\n\t}\n}\n\ninterface IOpenAndClose {\n\t//抽象方法,接收接口\n\tpublic void open(ITV tv); \n}\n\n// 实现接口\nclass OpenAndClose implements IOpenAndClose {\n\t@Override\n\tpublic void open(ITV tv) {\n\t\ttv.play();\n\t}\n}"]],[8575,8575],[9455,9455]]],[1571229710958,["GJX@GJXAIOU",[[-1,8823,"\t\t//通过构造器进行依赖传递\n//\t\tOpenAndClose openAndClose = new OpenAndClose(changHong);\n//\t\topenAndClose.open();\n\n//\t\t//通过setter方法进行依赖传递\n//\t\tOpenAndClose openAndClose = new OpenAndClose();\n//\t\t// 如果不使用 setTV就没有对象，则会报空指针异常\n//\t\topenAndClose.setTv(changHong);\n//\t\topenAndClose.open();\n"]],[8823,9094],[8823,8823]]],[1571229712534,["GJX@GJXAIOU",[[-1,8823,"\n"]],[8823,8823],[8822,8822]]],[1571229714416,["GJX@GJXAIOU",[[-1,8821,"\t"]],[8821,8821],[8820,8820]]],[1571229714950,["GJX@GJXAIOU",[[-1,8819,"\n"]],[8820,8820],[8819,8819]]],[1571229715959,["GJX@GJXAIOU",[[-1,8824,"\n"]],[8824,8824],[8823,8823]]],[1571229976882,["GJX@GJXAIOU",[[1,9196,"```"]],[9196,9196],[9199,9199]]],[1571229976991,["GJX@GJXAIOU",[[1,9199,"language\n```\n"]],[9199,9199],[9199,9207]]],[1571229977435,["GJX@GJXAIOU",[[-1,9199,"language"],[1,9207,"j"]],[9199,9207],[9200,9200]]],[1571229978067,["GJX@GJXAIOU",[[1,9200,"ava"]],[9200,9200],[9203,9203]]],[1571229978145,["GJX@GJXAIOU",[[1,9204,"\n"]],[9203,9203],[9204,9204]]],[1571229982344,["GJX@GJXAIOU",[[1,9204,"package com.atguigu.principle.inversion.improve;\n\npublic class DependencyPass {\n\tpublic static void main(String[] args) {\n\t\tChangHong changHong = new ChangHong();\n//\t\tOpenAndClose openAndClose = new OpenAndClose();\n//\t\topenAndClose.open(changHong);\n\t\t\n\t\t//通过构造器进行依赖传递\n\t\tOpenAndClose openAndClose = new OpenAndClose(changHong);\n\t\topenAndClose.open();\n\n//\t\t//通过setter方法进行依赖传递\n//\t\tOpenAndClose openAndClose = new OpenAndClose();\n//\t\t// 如果不使用 setTV就没有对象，则会报空指针异常\n//\t\topenAndClose.setTv(changHong);\n//\t\topenAndClose.open();\n\n\t}\n\n}\n//\n///**\n// * 方式1： 通过接口传递实现依赖\n// */\n//interface ITV {\n//\tpublic void play();\n//}\n//\n//class ChangHong implements ITV {\n//\t@Override\n//\tpublic void play() {\n//\t\tSystem.out.println(\"长虹电视机，打开\");\n//\t}\n//}\n//\n//interface IOpenAndClose {\n//\t//抽象方法,接收接口\n//\tpublic void open(ITV tv);\n//}\n//\n//// 实现接口\n//class OpenAndClose implements IOpenAndClose {\n//\t@Override\n//\tpublic void open(ITV tv) {\n//\t\ttv.play();\n//\t}\n//}\n\n\n/**\n * 方式 2：通过构造方法依赖传递\n */\ninterface ITV { \n\tpublic void play();\n}\n\nclass ChangHong implements ITV {\n\t@Override\n\tpublic void play() {\n\t\tSystem.out.println(\"长虹电视机，打开\");\n\t}\n}\n\ninterface IOpenAndClose {\n\tpublic void open();\n}\n\nclass OpenAndClose implements IOpenAndClose {\n\t// 成员变量\n\tpublic ITV tv; \n\n\t// 构造器\n\tpublic OpenAndClose(ITV tv) { \n\t\tthis.tv = tv;\n\t}\n\n\t@Override\n\tpublic void open() {\n\t\tthis.tv.play();\n\t}\n}"]],[9204,9204],[10552,10552]]],[1571229986246,["GJX@GJXAIOU",[[-1,9367,"//\t\tOpenAndClose openAndClose = new OpenAndClose();\n//\t\topenAndClose.open(changHong);"]],[9367,9452],[9367,9367]]],[1571229986864,["GJX@GJXAIOU",[[-1,9367,"\n"]],[9367,9367],[9366,9366]]],[1571229988318,["GJX@GJXAIOU",[[-1,9368,"\t"]],[9369,9369],[9368,9368]]],[1571229991143,["GJX@GJXAIOU",[[-1,9468,"//\t\t//通过setter方法进行依赖传递\n//\t\tOpenAndClose openAndClose = new OpenAndClose();\n//\t\t// 如果不使用 setTV就没有对象，则会报空指针异常\n//\t\topenAndClose.setTv(changHong);\n//\t\topenAndClose.open();\n"]],[9468,9636],[9468,9468]]],[1571229991680,["GJX@GJXAIOU",[[-1,9468,"\n"]],[9468,9468],[9467,9467]]],[1571229992175,["GJX@GJXAIOU",[[-1,9467,"\n"]],[9467,9467],[9466,9466]]],[1571229993143,["GJX@GJXAIOU",[[-1,9470,"\n"]],[9470,9470],[9469,9469]]],[1571229999294,["GJX@GJXAIOU",[[-1,9472,"//\n///**\n// * 方式1： 通过接口传递实现依赖\n// */\n//interface ITV {\n//\tpublic void play();\n//}\n//\n//class ChangHong implements ITV {\n//\t@Override\n//\tpublic void play() {\n//\t\tSystem.out.println(\"长虹电视机，打开\");\n//\t}\n//}\n//\n//interface IOpenAndClose {\n//\t//抽象方法,接收接口\n//\tpublic void open(ITV tv);\n//}\n//\n//// 实现接口\n//class OpenAndClose implements IOpenAndClose {\n//\t@Override\n//\tpublic void open(ITV tv) {\n//\t\ttv.play();\n//\t}\n//}\n\n"]],[9472,9881],[9472,9472]]],[1571230006456,["GJX@GJXAIOU",[[1,9905,"- \n"]],[9904,9904],[9907,9907]]],[1571230006717,["GJX@GJXAIOU",[[-1,9905,"- "]],[9907,9907],[9906,9906]]],[1571230008416,["GJX@GJXAIOU",[[1,9906,"\n"]],[9905,9905],[9906,9906]]],[1571230089161,["GJX@GJXAIOU",[[1,9905,"]```["]],[9905,9905],[9910,9910]]],[1571230090135,["GJX@GJXAIOU",[[1,9905,"`"],[1,9910,"`"]],[9905,9910],[9905,9912]]],[1571230090375,["GJX@GJXAIOU",[[-1,9905,"`"],[-1,9907,"`"]],[9905,9912],[9905,9906]]],[1571230091696,["GJX@GJXAIOU",[[-1,9905,"]"]],[9905,9906],[9905,9905]]],[1571230092114,["GJX@GJXAIOU",[[1,9907,"`"]],[9905,9905],[9906,9906]]],[1571230095134,["GJX@GJXAIOU",[[-1,9905,"```[`"]],[9905,9910],[9905,9905]]],[1571230095863,["GJX@GJXAIOU",[[1,9905,"```"]],[9905,9905],[9908,9908]]],[1571230096047,["GJX@GJXAIOU",[[1,9908,"language\n```\n"]],[9908,9908],[9908,9916]]],[1571230096914,["GJX@GJXAIOU",[[-1,9908,"language"],[1,9916,"j"]],[9908,9916],[9909,9909]]],[1571230097417,["GJX@GJXAIOU",[[1,9909,"ava"]],[9909,9909],[9912,9912]]],[1571230097832,["GJX@GJXAIOU",[[1,9913,"\n"]],[9912,9912],[9913,9913]]],[1571230100900,["GJX@GJXAIOU",[[1,9913,"package com.atguigu.principle.inversion.improve;\n\npublic class DependencyPass {\n\tpublic static void main(String[] args) {\n\t\tChangHong changHong = new ChangHong();\n//\t\tOpenAndClose openAndClose = new OpenAndClose();\n//\t\topenAndClose.open(changHong);\n\t\t\n//\t\t//通过构造器进行依赖传递\n//\t\tOpenAndClose openAndClose = new OpenAndClose(changHong);\n//\t\topenAndClose.open();\n\n\t\t//通过setter方法进行依赖传递\n\t\tOpenAndClose openAndClose = new OpenAndClose();\n\t\t// 如果不使用 setTV就没有对象，则会报空指针异常\n\t\topenAndClose.setTv(changHong);\n\t\topenAndClose.open();\n\t}\n}\n\n\n///**\n// * 方式1： 通过接口传递实现依赖\n// */\n//interface ITV {\n//\tpublic void play();\n//}\n//\n//class ChangHong implements ITV {\n//\t@Override\n//\tpublic void play() {\n//\t\tSystem.out.println(\"长虹电视机，打开\");\n//\t}\n//}\n//\n//interface IOpenAndClose {\n//\t//抽象方法,接收接口\n//\tpublic void open(ITV tv);\n//}\n//\n//// 实现接口\n//class OpenAndClose implements IOpenAndClose {\n//\t@Override\n//\tpublic void open(ITV tv) {\n//\t\ttv.play();\n//\t}\n//}\n\n\n///**\n// * 方式 2：通过构造方法依赖传递\n// */\n//interface ITV {\n//\tpublic void play();\n//}\n//\n//class ChangHong implements ITV {\n//\t@Override\n//\tpublic void play() {\n//\t\tSystem.out.println(\"长虹电视机，打开\");\n//\t}\n//}\n//\n//interface IOpenAndClose {\n//\tpublic void open();\n//}\n//\n//class OpenAndClose implements IOpenAndClose {\n//\t// 成员变量\n//\tpublic ITV tv;\n//\n//\t// 构造器\n//\tpublic OpenAndClose(ITV tv) {\n//\t\tthis.tv = tv;\n//\t}\n//\n//\t@Override\n//\tpublic void open() {\n//\t\tthis.tv.play();\n//\t}\n//}\n\n\n\n// 方式3 , 通过setter方法传递\ninterface IOpenAndClose {\n\tpublic void open(); // 抽象方法\n\tpublic void setTv(ITV tv);\n}\n\nclass OpenAndClose implements IOpenAndClose {\n\tprivate ITV tv;\n\n\t@Override\n\tpublic void setTv(ITV tv) {\n\t\tthis.tv = tv;\n\t}\n\n\t@Override\n\tpublic void open() {\n\t\tthis.tv.play();\n\t}\n}\n\ninterface ITV { // ITV接口\n\tpublic void play();\n}\n\nclass ChangHong implements ITV {\n\t@Override\n\tpublic void play() {\n\t\tSystem.out.println(\"长虹电视机，打开\");\n\t}\n\n}"]],[9913,9913],[11762,11762]]],[1571230106072,["GJX@GJXAIOU",[[-1,10076,"//\t\tOpenAndClose openAndClose = new OpenAndClose();\n//\t\topenAndClose.open(changHong);\n\t\t\n//\t\t//通过构造器进行依赖传递\n//\t\tOpenAndClose openAndClose = new OpenAndClose(changHong);\n//\t\topenAndClose.open();\n"]],[10076,10269],[10076,10076]]],[1571230113864,["GJX@GJXAIOU",[[-1,10242,"///**\n// * 方式1： 通过接口传递实现依赖\n// */\n//interface ITV {\n//\tpublic void play();\n//}\n//\n//class ChangHong implements ITV {\n//\t@Override\n//\tpublic void play() {\n//\t\tSystem.out.println(\"长虹电视机，打开\");\n//\t}\n//}\n//\n//interface IOpenAndClose {\n//\t//抽象方法,接收接口\n//\tpublic void open(ITV tv);\n//}\n//\n//// 实现接口\n//class OpenAndClose implements IOpenAndClose {\n//\t@Override\n//\tpublic void open(ITV tv) {\n//\t\ttv.play();\n//\t}\n//}\n\n\n///**\n// * 方式 2：通过构造方法依赖传递\n// */\n//interface ITV {\n//\tpublic void play();\n//}\n//\n//class ChangHong implements ITV {\n//\t@Override\n//\tpublic void play() {\n//\t\tSystem.out.println(\"长虹电视机，打开\");\n//\t}\n//}\n//\n//interface IOpenAndClose {\n//\tpublic void open();\n//}\n//\n//class OpenAndClose implements IOpenAndClose {\n//\t// 成员变量\n//\tpublic ITV tv;\n//\n//\t// 构造器\n//\tpublic OpenAndClose(ITV tv) {\n//\t\tthis.tv = tv;\n//\t}\n//\n//\t@Override\n//\tpublic void open() {\n//\t\tthis.tv.play();\n//\t}\n//}\n\n\n"]],[10241,11124],[10241,10241]]],[1571230115591,["GJX@GJXAIOU",[[-1,10242,"\n"]],[10242,10242],[10241,10241]]],[1571230116278,["GJX@GJXAIOU",[[-1,10241,"\n"]],[10241,10241],[10240,10240]]],[1571230142266,["GJX@GJXAIOU",[[1,10690,"#### ### 2.1.1 依赖倒转原则的注意事项和细节\n\n1) 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.\n\n2) 变量的**声明类型尽量是抽象类或接口**, 这样我们的变量引用和实际对象间，就存在**一个缓冲层**，利于程序扩展和优化\n\n3) 继承时遵循**里氏替换**原则"]],[10690,10690],[10840,10840]]],[1571230152262,["GJX@GJXAIOU",[[-1,10695,"### 2.1.1 "]],[10695,10705],[10695,10695]]],[1571230154194,["GJX@GJXAIOU",[[1,10695,"4 "]],[10695,10695],[10696,10696]]],[1571230154410,["GJX@GJXAIOU",[[1,10696,"."]],[10696,10696],[10697,10697]]],[1571230164623,["GJX@GJXAIOU",[[-1,10713,"\n1) "]],[10713,10717],[10713,10713]]],[1571230165427,["GJX@GJXAIOU",[[1,10713,"- "]],[10713,10713],[10715,10715]]],[1571230167338,["GJX@GJXAIOU",[[1,10713,"\n"]],[10713,10713],[10714,10714]]],[1571230170417,["GJX@GJXAIOU",[[-1,10748,"\n2)"]],[10748,10751],[10748,10748]]],[1571230170761,["GJX@GJXAIOU",[[1,10748,"-"]],[10748,10748],[10749,10749]]],[1571230174337,["GJX@GJXAIOU",[[-1,10811,"\n3) "]],[10811,10815],[10811,10811]]],[1571230174668,["GJX@GJXAIOU",[[1,10811,"-"]],[10811,10811],[10812,10812]]],[1571230175547,["GJX@GJXAIOU",[[1,10812," "]],[10812,10812],[10813,10813]]],[1571230177980,["GJX@GJXAIOU",[[1,10828,";"]],[10828,10828],[10829,10829]]],[1571230179095,["GJX@GJXAIOU",[[-1,10828,";"]],[10829,10829],[10828,10828]]],[1571230179577,["GJX@GJXAIOU",[[1,10828,"；"]],[10828,10828],[10829,10829]]],[1571230181867,["GJX@GJXAIOU",[[1,10810,"；"]],[10810,10810],[10811,10811]]],[1571230184632,["GJX@GJXAIOU",[[-1,10746,"."]],[10747,10747],[10746,10746]]],[1571230185137,["GJX@GJXAIOU",[[1,10746,"；"]],[10746,10746],[10747,10747]]],[1571230226784,["GJX@GJXAIOU",[[1,10831,"- \n"]],[10830,10830],[10833,10833]]],[1571230227021,["GJX@GJXAIOU",[[-1,10831,"- "]],[10833,10833],[10832,10832]]],[1571230227318,["GJX@GJXAIOU",[[1,10832,"\n"]],[10832,10832],[10833,10833]]],[1571230227414,["GJX@GJXAIOU",[[1,10833,"\n"]],[10833,10833],[10834,10834]]],[1571230229960,["GJX@GJXAIOU",[[1,10834,"### "]],[10834,10834],[10837,10837]]],[1571230231921,["GJX@GJXAIOU",[[1,10837,"（）"]],[10837,10837],[10839,10839]]],[1571230233884,["GJX@GJXAIOU",[[1,10838,"四"]],[10838,10838],[10839,10839]]],[1571230234931,["GJX@GJXAIOU",[[1,10837," "]],[10837,10837],[10838,10838]]],[1571230237231,["GJX@GJXAIOU",[[1,10841,"## 2.1 里氏替换原则\n\n### 2.1.1 OO 中的继承性的思考和说明\n\n1) 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。\n\n2) **继承在给程序设计带来便利的同时，也带来了弊端**。比如使用继承会给程序带来**侵入性**，程序的可移植性降低， 增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障\n\n3) 问题提出：**在编程中，如何正确的使用继承**? => **里氏替换**原则\n\n### 2.1.2 基本介绍\n\n1) 里氏替换原则(Liskov  Substitution  Principle)在 1988 年，由麻省理工学院的以为姓里的女士提出的。\n\n2) 如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型T2 是类型 T1 的子类型。**换句话说，所有引用基类的地方必须能透明地使用其子类的对象**。\n\n**3)** 在使用继承时，遵循里氏替换原则，在**子类中尽量不要重写父类的方法**\n\n4) 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过**聚合，组合，依赖 来****解决问题**。.\n\n### 2.1.3 一个程序引出的问题和思考\n\n该看个程序, 思考下问题和解决思路"]],[10841,10841],[11545,11545]]],[1571230240944,["GJX@GJXAIOU",[[-1,10841,"## 2.1 "]],[10841,10848],[10841,10841]]],[1571230245072,["GJX@GJXAIOU",[[-1,10853,"2..1"]],[10857,10857],[10853,10853]]],[1571230246802,["GJX@GJXAIOU",[[1,10854,"。"]],[10854,10854],[10855,10855]]],[1571230249052,["GJX@GJXAIOU",[[-1,10854,"。 "]],[10856,10856],[10854,10854]]],[1571230250802,["GJX@GJXAIOU",[[1,10854,". "]],[10854,10854],[10856,10856]]],[1571230938224,["GJX@GJXAIOU",[[-1,10872,"1) "]],[10872,10875],[10872,10872]]],[1571230951833,["GJX@GJXAIOU",[[-1,10969,"2) "]],[10969,10972],[10969,10969]]],[1571230953060,["GJX@GJXAIOU",[[1,10969,"- "]],[10969,10969],[10971,10971]]],[1571230955776,["GJX@GJXAIOU",[[1,10872,"- "]],[10872,10872],[10874,10874]]],[1571230969579,["GJX@GJXAIOU",[[1,11103,";"]],[11103,11103],[11104,11104]]],[1571230971887,["GJX@GJXAIOU",[[-1,11103,";"]],[11104,11104],[11103,11103]]],[1571230972701,["GJX@GJXAIOU",[[1,11103,"；"]],[11103,11103],[11104,11104]]],[1571230989699,["GJX@GJXAIOU",[[-1,11106,"3) "]],[11106,11109],[11106,11106]]],[1571230991267,["GJX@GJXAIOU",[[1,11106,"- "]],[11106,11106],[11108,11108]]],[1571230998419,["GJX@GJXAIOU",[[1,11151,"#"]],[11151,11151],[11163,11163]]],[1571231001338,["GJX@GJXAIOU",[[-1,11155,"1.2"]],[11158,11158],[11155,11155]]],[1571231006193,["GJX@GJXAIOU",[[-1,11162,"1) "]],[11162,11165],[11162,11162]]],[1571231006891,["GJX@GJXAIOU",[[1,11162,"- "]],[11162,11162],[11164,11164]]],[1571231018466,["GJX@GJXAIOU",[[1,10847,"(Liskov  Substitution  Principle)"]],[10847,10847],[10880,10880]]],[1571231025978,["GJX@GJXAIOU",[[-1,11195,"- 里氏替换原则(Liskov  Substitution  Principle)在 1988 年，由麻省理工学院的以为姓里的女士提出的。\n\n2) "]],[11195,11264],[11195,11195]]],[1571231027875,["GJX@GJXAIOU",[[1,11195,"- "]],[11195,11195],[11197,11197]]],[1571231051113,["GJX@GJXAIOU",[[-1,11338,"**3)**"]],[11338,11344],[11338,11338]]],[1571231051474,["GJX@GJXAIOU",[[1,11338,"-"]],[11338,11338],[11339,11339]]],[1571231054983,["GJX@GJXAIOU",[[1,11375,"；"]],[11375,11375],[11376,11376]]],[1571231064651,["GJX@GJXAIOU",[[-1,11378,"4) "]],[11378,11381],[11378,11378]]],[1571231065365,["GJX@GJXAIOU",[[1,11378,"- "]],[11378,11378],[11380,11380]]],[1571231069487,["GJX@GJXAIOU",[[-1,11431,"****"]],[11435,11435],[11431,11431]]],[1571231077168,["GJX@GJXAIOU",[[-1,11445,"2.1."]],[11449,11449],[11445,11445]]],[1571231079013,["GJX@GJXAIOU",[[1,11446,"。"]],[11446,11446],[11447,11447]]],[1571231079969,["GJX@GJXAIOU",[[-1,11446,"。"]],[11447,11447],[11446,11446]]],[1571231080660,["GJX@GJXAIOU",[[1,11446,"."]],[11446,11446],[11447,11447]]],[1571231082018,["GJX@GJXAIOU",[[1,11444,"#"]],[11447,11447],[11461,11461]]],[1571231672403,["GJX@GJXAIOU",[[1,11480,"\n"]],[11480,11480],[11481,11481]]],[1571231672663,["GJX@GJXAIOU",[[-1,11481," "],[1,11482,"\n"]],[11481,11481],[11482,11482]]],[1571231675207,["GJX@GJXAIOU",[[-1,11481,"\n"],[1,11482,"😁"]],[11482,11482],[11481,11483]]],[1571231675499,["GJX@GJXAIOU",[[1,11483,"😁"]],[11481,11483],[11481,11485]]],[1571231682825,["GJX@GJXAIOU",[[-1,11483,"😁"]],[11485,11485],[11483,11483]]],[1571231683117,["GJX@GJXAIOU",[[-1,11481,"😁"],[1,11483,"\n"]],[11483,11483],[11481,11481]]],[1571231683211,["GJX@GJXAIOU",[[-1,11481,"\n"]],[11481,11481],[11480,11480]]],[1571231964802,["GJX@GJXAIOU",[[-1,11464,"看个程序, 思考下问题和解决思路\n"]],[11465,11482],[11464,11464]]],[1571231965098,["GJX@GJXAIOU",[[-1,11463,"该"],[1,11464,"\n"]],[11464,11464],[11463,11463]]],[1571231966725,["GJX@GJXAIOU",[[-1,11463,"\n"],[1,11464,"·"]],[11463,11463],[11464,11464]]],[1571231967266,["GJX@GJXAIOU",[[1,11464,"··"]],[11464,11464],[11466,11466]]],[1571231968239,["GJX@GJXAIOU",[[-1,11464,"··"]],[11466,11466],[11464,11464]]],[1571231968329,["GJX@GJXAIOU",[[-1,11463,"·"],[1,11464,"\n"]],[11464,11464],[11463,11463]]],[1571231968777,["GJX@GJXAIOU",[[-1,11463,"\n"]],[11463,11463],[11462,11462]]],[1571231969670,["GJX@GJXAIOU",[[-1,11462,"\n"],[1,11463,"`"]],[11462,11462],[11463,11463]]],[1571231970175,["GJX@GJXAIOU",[[1,11463,"``"]],[11463,11463],[11465,11465]]],[1571231970234,["GJX@GJXAIOU",[[1,11465,"language\n```\n"]],[11465,11465],[11465,11473]]],[1571231971614,["GJX@GJXAIOU",[[-1,11465,"language"],[1,11473,"j"]],[11465,11473],[11466,11466]]],[1571231972198,["GJX@GJXAIOU",[[1,11466,"ava"]],[11466,11466],[11469,11469]]],[1571231972293,["GJX@GJXAIOU",[[1,11470,"\n"]],[11469,11469],[11470,11470]]],[1571231974701,["GJX@GJXAIOU",[[1,11470,"package com.atguigu.principle.liskov;\n\npublic class Liskov {\n\tpublic static void main(String[] args) {\n\t\tA a = new A();\n\t\tSystem.out.println(\"11-3=\" + a.func1(11, 3));\n\t\tSystem.out.println(\"1-8=\" + a.func1(1, 8));\n\t\tSystem.out.println(\"-----------------------\");\n\t\t\n\t\tB b = new B();\n\t\t//这里本意是求出11-3，但是因为方法被重写了，因此结果为 14\n\t\tSystem.out.println(\"11-3=\" + b.func1(11, 3));\n\t\tSystem.out.println(\"11+3+9=\" + b.func2(11, 3));\n\t}\n}\n\n/**\n * A类：返回两个数的差\n  */\nclass A {\n\tpublic int func1(int num1, int num2) {\n\t\treturn num1 - num2;\n\t}\n}\n\n/**\n * B 类继承了 A 增加了一个新功能：完成两个数相加,然后和9求和\n * 同时 B 类中不小心将 A 类中的 func1() 进行了重写\n  */\n\nclass B extends A {\n\t// 这里，重写了A类的方法, 可能是无意识\n\t@Override\n\tpublic int func1(int a, int b) {\n\t\treturn a + b;\n\t}\n\n\tpublic int func2(int a, int b) {\n\t\treturn func1(a, b) + 9;\n\t}\n}\n"]],[11470,11470],[12249,12249]]],[1571231976491,["GJX@GJXAIOU",[[1,11462,"\n"]],[11461,11461],[11462,11462]]],[1571231985464,["GJX@GJXAIOU",[[1,11462,"如果在继承类"]],[11462,11462],[11468,11468]]],[1571231987506,["GJX@GJXAIOU",[[-1,11467,"类"]],[11468,11468],[11467,11467]]],[1571231992113,["GJX@GJXAIOU",[[1,11467,"子类中重写了弗雷德额"]],[11467,11467],[11477,11477]]],[1571231993699,["GJX@GJXAIOU",[[-1,11473,"弗雷德额"]],[11477,11477],[11473,11473]]],[1571232000766,["GJX@GJXAIOU",[[1,11473,"父类的方法则容易报错；"]],[11473,11473],[11484,11484]]],[1571232007266,["GJX@GJXAIOU",[[-1,12272,"\n"]],[12272,12272],[12271,12271]]],[1571232009309,["GJX@GJXAIOU",[[1,12276,"\n"]],[12275,12275],[12276,12276]]],[1571232009582,["GJX@GJXAIOU",[[1,12277,"\n"]],[12276,12276],[12277,12277]]],[1571232042916,["GJX@GJXAIOU",[[1,12278,"\n"]],[12275,12275],[12276,12276]]],[1571232043240,["GJX@GJXAIOU",[[1,12279,"\n"]],[12276,12276],[12277,12277]]],[1571232043606,["GJX@GJXAIOU",[[1,12277,"### 2.1.1 解决方法\n\n1) 我们发现原来运行正常的相减功能发生了错误。原因就是类 B 无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的\n\n复用性会比较差。特别是运行多态比较频繁的时候\n\n2) 通用的做法是：**原来的父类和子类都继承一个更通俗的基类**，原有的继承关系去掉，采用**依赖，聚合，组合**等关系代替.\n\n3) 改进方案"]],[12277,12277],[12493,12493]]],[1571232046965,["GJX@GJXAIOU",[[1,12280,"#"]],[12279,12279],[12292,12292]]],[1571232049604,["GJX@GJXAIOU",[[-1,12277,"#### 2.1.1"]],[12277,12287],[12277,12277]]],[1571232056123,["GJX@GJXAIOU",[[1,12277,"#### "]],[12277,12277],[12287,12287]]],[1571232058813,["GJX@GJXAIOU",[[1,12283,"4 "]],[12283,12283],[12284,12284]]],[1571232059098,["GJX@GJXAIOU",[[1,12284,"."]],[12284,12284],[12285,12285]]],[1571232062825,["GJX@GJXAIOU",[[-1,12292,"1) "]],[12292,12295],[12292,12292]]],[1571232063438,["GJX@GJXAIOU",[[1,12292,"- "]],[12292,12292],[12294,12294]]],[1571232101900,["GJX@GJXAIOU",[[1,12307,"】【【】"]],[12307,12307],[12311,12311]]],[1571232103781,["GJX@GJXAIOU",[[-1,12307,"】【【】"]],[12311,12311],[12307,12307]]],[1571232130261,["GJX@GJXAIOU",[[-1,12393,"\n"]],[12394,12394],[12393,12393]]],[1571232130770,["GJX@GJXAIOU",[[-1,12392,"\n"]],[12393,12393],[12392,12392]]],[1571232134140,["GJX@GJXAIOU",[[1,12414,"；"]],[12414,12414],[12415,12415]]],[1571232198411,["GJX@GJXAIOU",[[-1,12416,"\n2) "]],[12416,12420],[12416,12416]]],[1571232199935,["GJX@GJXAIOU",[[1,12416,"- "]],[12416,12416],[12418,12418]]],[1571232206635,["GJX@GJXAIOU",[[-1,12478,"."]],[12479,12479],[12478,12478]]],[1571232207125,["GJX@GJXAIOU",[[1,12478,"；"]],[12478,12478],[12479,12479]]],[1571232212228,["GJX@GJXAIOU",[[-1,12481,"3) 改进方案"]],[12481,12488],[12481,12481]]],[1571232256236,["GJX@GJXAIOU",[[1,12481,"![里氏原则改进]($resource/%E9%87%8C%E6%B0%8F%E5%8E%9F%E5%88%99%E6%94%B9%E8%BF%9B.jpg)"]],[12481,12481],[12561,12561]]],[1571232259349,["GJX@GJXAIOU",[[1,12563,"\n"]],[12561,12561],[12562,12562]]],[1571232656342,["GJX@GJXAIOU",[[1,12562,"1"]],[12562,12562],[12563,12563]]],[1571232656853,["GJX@GJXAIOU",[[-1,12562,"1"]],[12563,12563],[12562,12562]]],[1571232657978,["GJX@GJXAIOU",[[1,12562,"···"]],[12562,12562],[12565,12565]]],[1571232659348,["GJX@GJXAIOU",[[-1,12562,"···"]],[12565,12565],[12562,12562]]],[1571232660469,["GJX@GJXAIOU",[[1,12562,"```"]],[12562,12562],[12565,12565]]],[1571232660694,["GJX@GJXAIOU",[[1,12565,"language\n```\n"]],[12565,12565],[12565,12573]]],[1571232661094,["GJX@GJXAIOU",[[-1,12565,"language"],[1,12573,"j"]],[12565,12573],[12566,12566]]],[1571232662548,["GJX@GJXAIOU",[[1,12566,"ava"]],[12566,12566],[12569,12569]]],[1571232663007,["GJX@GJXAIOU",[[1,12570,"\n"]],[12569,12569],[12570,12570]]],[1571232665704,["GJX@GJXAIOU",[[1,12570,"package com.atguigu.principle.liskov.improve;\n\npublic class Liskov {\n\tpublic static void main(String[] args) {\n\t\tA a = new A();\n\t\tSystem.out.println(\"11-3=\" + a.func1(11, 3));\n\t\tSystem.out.println(\"-----------------------\");\n\n\t\tB b = new B();\n\t\t//因为B类不再继承A类，因此调用者，不会再func1是求减法\n\t\t//调用完成的功能就会很明确\n\t\tSystem.out.println(\"11+3=\" + b.func1(11, 3));\n\t\tSystem.out.println(\"1+8=\" + b.func1(1, 8));\n\n\t\t//使用组合仍然可以使用到A类相关方法\n\t\tSystem.out.println(\"11-3=\" + b.func3(11, 3));\n\t}\n}\n\n/**\n * 创建一个更加基础的基类，然后把更加基础的方法和成员写到Base类\n */\nclass Base {\n}\n\n/**\n * \tA 类：返回两个数的差\n */\nclass A extends Base {\n\tpublic int func1(int num1, int num2) {\n\t\treturn num1 - num2;\n\t}\n}\n\nclass B extends Base {\n\t//如果 B 需要使用 A 类的方法,使用组合关系\n\tprivate A a = new A();\n\n\t// 我们仍然想使用 A 的方法，因为这里参数和对象名重了，因此使用 this\n\tpublic int func3(int a, int b) {\n\t\treturn this.a.func1(a, b);\n\t}\n\n\tpublic int func1(int a, int b) {\n\t\treturn a + b;\n\t}\n\n\tpublic int func2(int a, int b) {\n\t\treturn func1(a, b) + 9;\n\t}\n}\n"]],[12570,12570],[13512,13512]]],[1571232668869,["GJX@GJXAIOU",[[-1,13512,"\n"]],[13512,13512],[13511,13511]]],[1571232693558,["GJX@GJXAIOU",[[1,13518,"\n"]],[13517,13517],[13518,13518]]],[1571232694254,["GJX@GJXAIOU",[[1,13518,"## 2.1 开闭原则\n\n### 2.1.1 基本介绍\n\n1) 开闭原则（Open  Closed Principle）是编程中**最基础、最重要**的设计原则\n\n2) 一个软件实体如类，模块和函数应该**对扩展开放****(****对提供方****)**，对**修改关闭****(****对使用方****)**。用抽象构建框架，用实现扩展细节。\n\n3) 当软件需要变化时，尽量**通过扩展软件**实体的行为来实现变化，而不是**通过修改**已有的代码来实现变化。\n\n4) 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。\n\n### 2.1.2 看下面一段代码\n\nØ 看一个画图形的功能。"]],[13518,13518],[13818,13818]]],[1571232698367,["GJX@GJXAIOU",[[-1,13521,"2.1 "]],[13525,13525],[13521,13521]]],[1571232699597,["GJX@GJXAIOU",[[1,13520,"#"]],[13521,13521],[13526,13526]]],[1571232702677,["GJX@GJXAIOU",[[1,13522,"()"]],[13522,13522],[13524,13524]]],[1571232704257,["GJX@GJXAIOU",[[-1,13522,"()"]],[13524,13524],[13522,13522]]],[1571232704810,["GJX@GJXAIOU",[[1,13522,"（）"]],[13522,13522],[13524,13524]]],[1571232706985,["GJX@GJXAIOU",[[1,13523,"五"]],[13523,13523],[13524,13524]]],[1571233010526,["GJX@GJXAIOU",[[-1,13535,"2..1"]],[13539,13539],[13535,13535]]],[1571233012320,["GJX@GJXAIOU",[[1,13536,"。"]],[13536,13536],[13537,13537]]],[1571233013651,["GJX@GJXAIOU",[[-1,13536,"。"]],[13537,13537],[13536,13536]]],[1571233014422,["GJX@GJXAIOU",[[1,13536,"."]],[13536,13536],[13537,13537]]],[1571233018692,["GJX@GJXAIOU",[[1,13534,"#"]],[13534,13534],[13543,13543]]],[1571233021339,["GJX@GJXAIOU",[[-1,13545,"1) "]],[13545,13548],[13545,13545]]],[1571233022041,["GJX@GJXAIOU",[[1,13545,"- "]],[13545,13545],[13547,13547]]],[1571233076580,["GJX@GJXAIOU",[[-1,13597,"2) "]],[13597,13600],[13597,13597]]],[1571233077062,["GJX@GJXAIOU",[[1,13597,"- "]],[13597,13597],[13599,13599]]],[1571233083567,["GJX@GJXAIOU",[[-1,13627,"****"]],[13631,13631],[13627,13627]]],[1571233085252,["GJX@GJXAIOU",[[-1,13622,"****"]],[13622,13626],[13622,13622]]],[1571233087668,["GJX@GJXAIOU",[[-1,13627,"****"]],[13627,13631],[13627,13627]]],[1571233090091,["GJX@GJXAIOU",[[-1,13638,"****"]],[13638,13642],[13638,13638]]],[1571233091716,["GJX@GJXAIOU",[[-1,13639,"****"]],[13639,13643],[13639,13639]]],[1571233093771,["GJX@GJXAIOU",[[-1,13643,"****"]],[13643,13647],[13643,13643]]],[1571233109316,["GJX@GJXAIOU",[[-1,13665,"3)"]],[13665,13667],[13665,13665]]],[1571233109670,["GJX@GJXAIOU",[[1,13665,"-"]],[13665,13665],[13666,13666]]],[1571233113947,["GJX@GJXAIOU",[[-1,13723,"4) "]],[13723,13726],[13723,13723]]],[1571233114297,["GJX@GJXAIOU",[[1,13723,"-"]],[13723,13723],[13724,13724]]],[1571233115576,["GJX@GJXAIOU",[[1,13724," "]],[13724,13724],[13725,13725]]],[1571233125790,["GJX@GJXAIOU",[[-1,13763,"1.2"]],[13765,13766],[13763,13763]]],[1571233130315,["GJX@GJXAIOU",[[-1,13773,"Ø 看"]],[13773,13775],[13773,13773]]],[1571233133989,["GJX@GJXAIOU",[[-1,13781,"。"]],[13782,13782],[13781,13781]]],[1571233134336,["GJX@GJXAIOU",[[1,13782,"\n"]],[13781,13781],[13782,13782]]],[1571233163249,["GJX@GJXAIOU",[[1,13782,"![开闭原则]($resource/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99.jpg)\n"]],[13782,13782],[13842,13842]]],[1571233166544,["GJX@GJXAIOU",[[1,13843,"\n"]],[13842,13842],[13843,13843]]],[1571233166925,["GJX@GJXAIOU",[[1,13844,"\n"]],[13843,13843],[13844,13844]]],[1571233167040,["GJX@GJXAIOU",[[1,13845,"\n"]],[13844,13844],[13845,13845]]],[1571233167151,["GJX@GJXAIOU",[[1,13846,"\n"]],[13845,13845],[13846,13846]]],[1571233167249,["GJX@GJXAIOU",[[1,13847,"\n"]],[13846,13846],[13847,13847]]],[1571233167544,["GJX@GJXAIOU",[[1,13848,"\n"]],[13847,13847],[13848,13848]]],[1571233167657,["GJX@GJXAIOU",[[1,13849,"\n"]],[13848,13848],[13849,13849]]],[1571233476733,["GJX@GJXAIOU",[[1,13843,"···"]],[13843,13843],[13846,13846]]],[1571233478199,["GJX@GJXAIOU",[[-1,13843,"···"]],[13846,13846],[13843,13843]]],[1571233479631,["GJX@GJXAIOU",[[1,13843,"```"]],[13843,13843],[13846,13846]]],[1571233479893,["GJX@GJXAIOU",[[1,13846,"language\n```\n"]],[13846,13846],[13846,13854]]],[1571233480324,["GJX@GJXAIOU",[[-1,13846,"language"],[1,13854,"j"]],[13846,13854],[13847,13847]]],[1571233480886,["GJX@GJXAIOU",[[1,13847,"ava"]],[13847,13847],[13850,13850]]],[1571233480997,["GJX@GJXAIOU",[[1,13851,"\n"]],[13850,13850],[13851,13851]]],[1571233484029,["GJX@GJXAIOU",[[1,13851,"package com.atguigu.principle.ocp;\n\npublic class Ocp {\n\tpublic static void main(String[] args) {\n\t\t//使用看看存在的问题\n\t\tGraphicEditor graphicEditor = new GraphicEditor();\n\t\tgraphicEditor.drawShape(new Rectangle());\n\t\tgraphicEditor.drawShape(new Circle());\n\t\tgraphicEditor.drawShape(new Triangle());\n\t}\n}\n\n//这是一个用于绘图的类 [使用方]：接收Shape对象，然后根据type，来绘制不同的图形\nclass GraphicEditor {\n\tpublic void drawShape(Shape s) {\n\t\tif (s.m_type == 1) {\n\t\t\tdrawRectangle(s);\n\t\t} else if (s.m_type == 2) {\n\t\t\tdrawCircle(s);\n\t\t} else if (s.m_type == 3) {\n\t\t\tdrawTriangle(s);\n\t\t}\n\t}\n\n\t//绘制矩形\n\tpublic void drawRectangle(Shape r) {\n\t\tSystem.out.println(\" 绘制矩形 \");\n\t}\n\n\t//绘制圆形\n\tpublic void drawCircle(Shape r) {\n\t\tSystem.out.println(\" 绘制圆形 \");\n\t}\n\t\n\t//这里需要增加：绘制三角形\n\tpublic void drawTriangle(Shape r) {\n\t\tSystem.out.println(\" 绘制三角形 \");\n\t}\n}\n\n//Shape类，基类\nclass Shape {\n\tint m_type;\n}\n\nclass Rectangle extends Shape {\n\tRectangle() {\n\t\tsuper.m_type = 1;\n\t}\n}\n\nclass Circle extends Shape {\n\tCircle() {\n\t\tsuper.m_type = 2;\n\t}\n}\n\n//新增画三角形\nclass Triangle extends Shape {\n\tTriangle() {\n\t\tsuper.m_type = 3;\n\t}\n}\n"]],[13851,13851],[14917,14917]]],[1571233487841,["GJX@GJXAIOU",[[1,14929,"\n"]],[14921,14921],[14922,14922]]],[1571233487971,["GJX@GJXAIOU",[[1,14930,"\n"]],[14922,14922],[14923,14923]]],[1571233514920,["GJX@GJXAIOU",[[1,14923,"1) 优点是比较好理解，简单易操作。\n\n2) 缺点是违反了设计模式的ocp 原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.\n\n3) 比如我们这时要新增加一个图形种类 三角形，我们需要做如下修改，修改的地方较多\n\n4) 代码演示\n\n方式 1 的改进的思路分析\n\n### 2.1.1 改进的思路分析\n\n**思路**：把创建 **Shape** **类做成抽象类**，并提供一个**抽象的** **draw** 方法，让**子类去实现即可**，这样我们有新的图形种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，**使用方的代码就不需要修** -> 满足了开闭原则\n\n#### 改进后的代码："]],[14923,14923],[15264,15264]]],[1571233517173,["GJX@GJXAIOU",[[1,14923,"\n"]],[14922,14922],[14923,14923]]],[1571233518356,["GJX@GJXAIOU",[[1,14923,"****"]],[14923,14923],[14925,14925]]],[1571233519810,["GJX@GJXAIOU",[[1,14925,"shang"]],[14925,14925],[14930,14930]]],[1571233521892,["GJX@GJXAIOU",[[-1,14925,"shang"]],[14930,14930],[14925,14925]]],[1571233528656,["GJX@GJXAIOU",[[1,14925,"上面方式的优劣："]],[14925,14925],[14933,14933]]],[1571233532684,["GJX@GJXAIOU",[[-1,14936,"1) "]],[14936,14939],[14936,14936]]],[1571233533591,["GJX@GJXAIOU",[[1,14936,"- "]],[14936,14936],[14938,14938]]],[1571233537291,["GJX@GJXAIOU",[[-1,14954,"\n2) "]],[14954,14958],[14954,14954]]],[1571233538205,["GJX@GJXAIOU",[[1,14954,"- "]],[14954,14954],[14956,14956]]],[1571233585060,["GJX@GJXAIOU",[[-1,13948,"\t\t//使用看看存在的问题"]],[13948,13961],[13948,13948]]],[1571233588612,["GJX@GJXAIOU",[[-1,13948,"\n"]],[13948,13948],[13947,13947]]],[1571233598780,["GJX@GJXAIOU",[[-1,15019,"3)"]],[15019,15021],[15019,15019]]],[1571233599315,["GJX@GJXAIOU",[[-1,15018,"\n"]],[15019,15019],[15018,15018]]],[1571233602888,["GJX@GJXAIOU",[[-1,15018," "]],[15019,15019],[15018,15018]]],[1571233611516,["GJX@GJXAIOU",[[-1,15043,"做如下修改"]],[15048,15048],[15043,15043]]],[1571233625865,["GJX@GJXAIOU",[[1,15043,"同时在提供方和使用方做修改"]],[15043,15043],[15056,15056]]],[1571233628945,["GJX@GJXAIOU",[[1,15064,"；"]],[15064,15064],[15065,15065]]],[1571233636844,["GJX@GJXAIOU",[[-1,15067,"4) 代码演示\n\n方式 1 的改进的思路分析\n"]],[15066,15089],[15066,15066]]],[1571233638942,["GJX@GJXAIOU",[[1,15067,"#### "]],[15067,15067],[15072,15072]]],[1571233641109,["GJX@GJXAIOU",[[1,15076,"#"]],[15076,15076],[15091,15091]]],[1571233642597,["GJX@GJXAIOU",[[-1,15067,"#### "]],[15067,15072],[15067,15067]]],[1571233643509,["GJX@GJXAIOU",[[-1,15067,"\n"]],[15067,15067],[15066,15066]]],[1571233652142,["GJX@GJXAIOU",[[1,13760,"#"]],[13771,13771],[13772,13772]]],[1571233658796,["GJX@GJXAIOU",[[-1,15073,"2.1.1"]],[15078,15078],[15073,15073]]],[1571233659832,["GJX@GJXAIOU",[[1,15073,"4"]],[15073,15073],[15074,15074]]],[1571233660399,["GJX@GJXAIOU",[[-1,15073,"4"]],[15074,15074],[15073,15073]]],[1571233661706,["GJX@GJXAIOU",[[1,15073,"3."]],[15073,15073],[15075,15075]]],[1571233668549,["GJX@GJXAIOU",[[-1,15228,"#### 改进后的代码："]],[15228,15240],[15228,15228]]],[1571233677996,["GJX@GJXAIOU",[[-1,15103,"** **"]],[15108,15108],[15103,15103]]],[1571233685462,["GJX@GJXAIOU",[[-1,15122,"** **"]],[15127,15127],[15122,15122]]],[1571233693172,["GJX@GJXAIOU",[[-1,15202,"修"]],[15203,15203],[15202,15202]]],[1571233695625,["GJX@GJXAIOU",[[1,15202,"x"]],[15202,15202],[15203,15203]]],[1571233695815,["GJX@GJXAIOU",[[1,15202," "]],[15203,15203],[15204,15204]]],[1571233696130,["GJX@GJXAIOU",[[-1,15203,"x"]],[15204,15204],[15203,15203]]],[1571233697298,["GJX@GJXAIOU",[[1,15203,"修改"]],[15203,15203],[15205,15205]]],[1571233699574,["GJX@GJXAIOU",[[-1,15202," "]],[15203,15203],[15202,15202]]],[1571233921168,["GJX@GJXAIOU",[[1,15219,"···"]],[15219,15219],[15222,15222]]],[1571233922196,["GJX@GJXAIOU",[[-1,15219,"···"]],[15222,15222],[15219,15219]]],[1571233924489,["GJX@GJXAIOU",[[1,15219,"```"]],[15219,15219],[15222,15222]]],[1571233924680,["GJX@GJXAIOU",[[1,15222,"language\n```\n"]],[15222,15222],[15222,15230]]],[1571233925360,["GJX@GJXAIOU",[[-1,15222,"language"],[1,15230,"j"]],[15222,15230],[15223,15223]]],[1571233925974,["GJX@GJXAIOU",[[1,15223,"ava"]],[15223,15223],[15226,15226]]],[1571233926142,["GJX@GJXAIOU",[[1,15227,"\n"]],[15226,15226],[15227,15227]]],[1571233930509,["GJX@GJXAIOU",[[1,15227,"package com.atguigu.principle.ocp.improve;\n\npublic class Ocp {\n\n\tpublic static void main(String[] args) {\n\t\tGraphicEditor graphicEditor = new GraphicEditor();\n\t\tgraphicEditor.drawShape(new Rectangle());\n\t\tgraphicEditor.drawShape(new Circle());\n\t\tgraphicEditor.drawShape(new Triangle());\n\t\tgraphicEditor.drawShape(new OtherGraphic());\n\t}\n}\n\n//这是一个用于绘图的类 [使用方]：接收Shape对象，调用draw方法\nclass GraphicEditor {\n\tpublic void drawShape(Shape s) {\n\t\ts.draw();\n\t}\n}\n\n//Shape类，基类\nabstract class Shape {\n\tint m_type;\n\tpublic abstract void draw();//抽象方法\n}\n\nclass Rectangle extends Shape {\n\tRectangle() {\n\t\tsuper.m_type = 1;\n\t}\n\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\" 绘制矩形 \");\n\t}\n}\n\nclass Circle extends Shape {\n\tCircle() {\n\t\tsuper.m_type = 2;\n\t}\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\" 绘制圆形 \");\n\t}\n}\n\n//新增画三角形\nclass Triangle extends Shape {\n\tTriangle() {\n\t\tsuper.m_type = 3;\n\t}\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\" 绘制三角形 \");\n\t}\n}\n\n//新增一个图形\nclass OtherGraphic extends Shape {\n\tOtherGraphic() {\n\t\tsuper.m_type = 4;\n\t}\n\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\" 绘制其它图形 \");\n\t}\n}\n"]],[15227,15227],[16350,16350]]],[1571233960395,["GJX@GJXAIOU",[[1,16356,"2.1 迪米特法则\n\n### 2.1.1 基本介绍\n\n1) 一个对象应该对其他对象保持最少的了解\n\n2) 类与类关系越密切，耦合度越大\n\n3) 迪米特法则(Demeter  Principle)又叫**最少知道原则**，即一个类**对自己依赖的类知道的越少越好**。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息\n\n4) 迪米特法则还有个更简单的定义：只与直接的朋友通信\n\n5) **直接的朋友**：每个对象都会与其他对象有**耦合关系**，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现**成员变量**，**方法参数**，**方法返回值**中的类为直接的朋友，而出现在**局部变量中的类不是直接的朋友**。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。\n\n### 2.1.2 应用实例\n\n1) 有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 ID 和学院员工的 id\n\n2) 编程实现上面的功能, 看代码演示\n\n3) 代码演示"]],[16356,16356],[16856,16856]]],[1571233963981,["GJX@GJXAIOU",[[1,16356,"### "]],[16356,16359],[16369,16369]]],[1571233974247,["GJX@GJXAIOU",[[-1,16360,"2.1 "]],[16364,16364],[16360,16360]]],[1571233975794,["GJX@GJXAIOU",[[1,16360,"()"]],[16360,16360],[16362,16362]]],[1571233977107,["GJX@GJXAIOU",[[-1,16360,"()"]],[16362,16362],[16360,16360]]],[1571233977962,["GJX@GJXAIOU",[[1,16360,"（）"]],[16360,16360],[16362,16362]]],[1571233979797,["GJX@GJXAIOU",[[1,16361,"六"]],[16361,16361],[16362,16362]]],[1571233984338,["GJX@GJXAIOU",[[-1,16374,"2.1.1 "]],[16375,16380],[16374,16374]]],[1571233985960,["GJX@GJXAIOU",[[1,16374,"1 "]],[16374,16374],[16375,16375]]],[1571233986317,["GJX@GJXAIOU",[[1,16375,"."]],[16375,16375],[16376,16376]]],[1571233988910,["GJX@GJXAIOU",[[1,16373,"#"]],[16373,16373],[16382,16382]]],[1571233996486,["GJX@GJXAIOU",[[-1,16384,"1) "]],[16384,16387],[16384,16384]]],[1571233997071,["GJX@GJXAIOU",[[1,16384,"- "]],[16384,16384],[16386,16386]]],[1571234000141,["GJX@GJXAIOU",[[-1,16405,"\n2) "]],[16405,16409],[16405,16405]]],[1571234001124,["GJX@GJXAIOU",[[1,16405,"- "]],[16405,16405],[16407,16407]]],[1571234004845,["GJX@GJXAIOU",[[-1,16423,"3)"]],[16423,16425],[16423,16423]]],[1571234005268,["GJX@GJXAIOU",[[1,16423,"-"]],[16423,16423],[16424,16424]]],[1571234005410,["GJX@GJXAIOU",[[1,16425," "]],[16424,16424],[16425,16425]]],[1571234507191,["GJX@GJXAIOU",[[-1,16549,"4) "]],[16549,16552],[16549,16549]]],[1571234508088,["GJX@GJXAIOU",[[1,16549,"- "]],[16549,16549],[16551,16551]]],[1571234511041,["GJX@GJXAIOU",[[-1,16577,"5)"]],[16577,16579],[16577,16577]]],[1571234511507,["GJX@GJXAIOU",[[1,16577,"-"]],[16577,16577],[16578,16578]]],[1571234511942,["GJX@GJXAIOU",[[1,16579," "]],[16578,16578],[16579,16579]]],[1571234521826,["GJX@GJXAIOU",[[1,16707,"（）"]],[16707,16707],[16709,16709]]],[1571234525141,["GJX@GJXAIOU",[[1,16708,"即在A"]],[16708,16708],[16711,16711]]],[1571234525349,["GJX@GJXAIOU",[[1,16710," "]],[16711,16711],[16712,16712]]],[1571234525880,["GJX@GJXAIOU",[[1,16712,"类"]],[16712,16712],[16713,16713]]],[1571234526107,["GJX@GJXAIOU",[[1,16712," "]],[16713,16713],[16714,16714]]],[1571234537387,["GJX@GJXAIOU",[[1,16714,"中出现：B b = 。。。"]],[16714,16714],[16727,16727]]],[1571234538230,["GJX@GJXAIOU",[[-1,16724,"。。。"]],[16727,16727],[16724,16724]]],[1571234547980,["GJX@GJXAIOU",[[1,16724,"XXX，或者 fun()"]],[16724,16724],[16736,16736]]],[1571234552202,["GJX@GJXAIOU",[[1,16735,"B  b"]],[16735,16735],[16739,16739]]],[1571234555063,["GJX@GJXAIOU",[[1,16740," 或者"]],[16740,16740],[16743,16743]]],[1571234562003,["GJX@GJXAIOU",[[1,16743," return B  b;"]],[16743,16743],[16756,16756]]],[1571234570110,["GJX@GJXAIOU",[[-1,16818,"1.2 "]],[16818,16822],[16818,16818]]],[1571234572488,["GJX@GJXAIOU",[[1,16815,"#"]],[16814,16814],[16823,16823]]],[1571234577486,["GJX@GJXAIOU",[[-1,16893,"3) 代码演示"]],[16893,16900],[16893,16893]]],[1571234578804,["GJX@GJXAIOU",[[-1,16872,"2) 编程实现上面的功能, 看代码演示"]],[16872,16891],[16872,16872]]],[1571234581724,["GJX@GJXAIOU",[[-1,16825,"1) "]],[16828,16828],[16825,16825]]],[1571234617156,["GJX@GJXAIOU",[[1,16869,"···"]],[16869,16869],[16872,16872]]],[1571234619283,["GJX@GJXAIOU",[[-1,16869,"···"]],[16872,16872],[16869,16869]]],[1571234619973,["GJX@GJXAIOU",[[-1,16877,"\n"]],[16869,16869],[16868,16868]]],[1571234621090,["GJX@GJXAIOU",[[1,16877,"\n"]],[16868,16868],[16869,16869]]],[1571234622141,["GJX@GJXAIOU",[[1,16869,"```"]],[16869,16869],[16872,16872]]],[1571234622515,["GJX@GJXAIOU",[[1,16872,"language\n```\n"]],[16872,16872],[16872,16880]]],[1571234623259,["GJX@GJXAIOU",[[-1,16872,"language"],[1,16880,"k"]],[16872,16880],[16873,16873]]],[1571234623795,["GJX@GJXAIOU",[[-1,16872,"k"]],[16873,16873],[16872,16872]]],[1571234625318,["GJX@GJXAIOU",[[1,16872,"java"]],[16872,16872],[16876,16876]]],[1571234625431,["GJX@GJXAIOU",[[1,16877,"\n"]],[16876,16876],[16877,16877]]],[1571234628320,["GJX@GJXAIOU",[[1,16877,"package com.atguigu.principle.demeter;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n//客户端\npublic class Demeter1 {\n\n\tpublic static void main(String[] args) {\n\t\t//创建了一个 SchoolManager 对象\n\t\tSchoolManager schoolManager = new SchoolManager();\n\t\t//输出学院的员工id 和  学校总部的员工信息\n\t\tschoolManager.printAllEmployee(new CollegeManager());\n\n\t}\n\n}\n\n\n//学校总部员工类\nclass Employee {\n\tprivate String id;\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n}\n\n\n//学院的员工类\nclass CollegeEmployee {\n\tprivate String id;\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n}\n\n\n//管理学院员工的管理类\nclass CollegeManager {\n\t//返回学院的所有员工\n\tpublic List<CollegeEmployee> getAllEmployee() {\n\t\tList<CollegeEmployee> list = new ArrayList<CollegeEmployee>();\n\t\tfor (int i = 0; i < 10; i++) { //这里我们增加了10个员工到 list\n\t\t\tCollegeEmployee emp = new CollegeEmployee();\n\t\t\temp.setId(\"学院员工id= \" + i);\n\t\t\tlist.add(emp);\n\t\t}\n\t\treturn list;\n\t}\n}\n\n//学校管理类\n\n//分析 SchoolManager 类的直接朋友类有哪些： Employee、CollegeManager\n//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 \nclass SchoolManager {\n\t//返回学校总部的员工\n\tpublic List<Employee> getAllEmployee() {\n\t\tList<Employee> list = new ArrayList<Employee>();\n\t\t\n\t\tfor (int i = 0; i < 5; i++) { //这里我们增加了5个员工到 list\n\t\t\tEmployee emp = new Employee();\n\t\t\temp.setId(\"学校总部员工id= \" + i);\n\t\t\tlist.add(emp);\n\t\t}\n\t\treturn list;\n\t}\n\n\t//该方法完成输出学校总部和学院员工信息(id)\n\tvoid printAllEmployee(CollegeManager sub) {\n\t\t\n\t\t//分析问题\n\t\t//1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友\n\t\t//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager\n\t\t//3. 违反了 迪米特法则 \n\t\t\n\t\t//获取到学院员工\n\t\tList<CollegeEmployee> list1 = sub.getAllEmployee();\n\t\tSystem.out.println(\"------------学院员工------------\");\n\t\tfor (CollegeEmployee e : list1) {\n\t\t\tSystem.out.println(e.getId());\n\t\t}\n\t\t//获取到学校总部员工\n\t\tList<Employee> list2 = this.getAllEmployee();\n\t\tSystem.out.println(\"------------学校总部员工------------\");\n\t\tfor (Employee e : list2) {\n\t\t\tSystem.out.println(e.getId());\n\t\t}\n\t}\n}\n"]],[16877,16877],[18836,18836]]],[1571234656376,["GJX@GJXAIOU",[[1,18842,"#### 3.### 2.1.1 应用实例改进\n\n1) 前面设计的问题在于 SchoolManager 中，**CollegeEmployee** **类并不是** **SchoolManager** 类的直接朋友 (分析)\n\n2) 按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合\n\n3) 对代码按照迪米特法则 进行改进. (看老师演示)"]],[18842,18842],[19016,19016]]],[1571234659639,["GJX@GJXAIOU",[[-1,18849,"### 2.1.1 "]],[18849,18859],[18849,18849]]],[1571234666863,["GJX@GJXAIOU",[[-1,18857,"1) "]],[18857,18860],[18857,18857]]],[1571234667983,["GJX@GJXAIOU",[[1,18857,"- "]],[18857,18857],[18859,18859]]],[1571234672677,["GJX@GJXAIOU",[[-1,18902,"** **"]],[18907,18907],[18902,18902]]],[1571234676751,["GJX@GJXAIOU",[[-1,18924,"**"]],[18926,18926],[18924,18924]]],[1571234678821,["GJX@GJXAIOU",[[-1,18906,"** **"]],[18906,18911],[18906,18906]]],[1571234679426,["GJX@GJXAIOU",[[1,18906," "]],[18906,18906],[18907,18907]]],[1571234682934,["GJX@GJXAIOU",[[-1,18885,"**"]],[18885,18887],[18885,18885]]],[1571234686159,["GJX@GJXAIOU",[[-1,18932,"2) "]],[18932,18935],[18932,18932]]],[1571234687717,["GJX@GJXAIOU",[[1,18932,"- "]],[18932,18932],[18934,18934]]],[1571234689702,["GJX@GJXAIOU",[[-1,18964,"3) "]],[18964,18967],[18964,18964]]],[1571234690798,["GJX@GJXAIOU",[[1,18964,"- "]],[18964,18964],[18966,18966]]],[1571234697574,["GJX@GJXAIOU",[[-1,18982," (看老师演示)"]],[18983,18990],[18982,18982]]],[1571234698053,["GJX@GJXAIOU",[[1,18983,"- \n"]],[18982,18982],[18985,18985]]],[1571234699401,["GJX@GJXAIOU",[[-1,18983,"- "]],[18985,18985],[18983,18983]]],[1571234701089,["GJX@GJXAIOU",[[1,18991,"\n"]],[18983,18983],[18984,18984]]],[1571234702363,["GJX@GJXAIOU",[[1,18984,"```"]],[18984,18984],[18987,18987]]],[1571234702490,["GJX@GJXAIOU",[[1,18987,"language\n```\n"]],[18987,18987],[18987,18995]]],[1571234703287,["GJX@GJXAIOU",[[-1,18987,"language"],[1,18995,"j"]],[18987,18995],[18988,18988]]],[1571234704066,["GJX@GJXAIOU",[[1,18988,"ava"]],[18988,18988],[18991,18991]]],[1571234704212,["GJX@GJXAIOU",[[1,18992,"\n"]],[18991,18991],[18992,18992]]],[1571234706358,["GJX@GJXAIOU",[[-1,18981,"."]],[18982,18982],[18981,18981]]],[1571234735136,["GJX@GJXAIOU",[[1,18991,"package com.atguigu.principle.demeter.improve;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n//客户端\npublic class Demeter1 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"~~~使用迪米特法则的改进~~~\");\n\t\t//创建了一个 SchoolManager 对象\n\t\tSchoolManager schoolManager = new SchoolManager();\n\t\t//输出学院的员工id 和  学校总部的员工信息\n\t\tschoolManager.printAllEmployee(new CollegeManager());\n\n\t}\n\n}\n\n\n//学校总部员工类\nclass Employee {\n\tprivate String id;\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n}\n\n\n//学院的员工类\nclass CollegeEmployee {\n\tprivate String id;\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n}\n\n\n//管理学院员工的管理类\nclass CollegeManager {\n\t//返回学院的所有员工\n\tpublic List<CollegeEmployee> getAllEmployee() {\n\t\tList<CollegeEmployee> list = new ArrayList<CollegeEmployee>();\n\t\tfor (int i = 0; i < 10; i++) { //这里我们增加了10个员工到 list\n\t\t\tCollegeEmployee emp = new CollegeEmployee();\n\t\t\temp.setId(\"学院员工id= \" + i);\n\t\t\tlist.add(emp);\n\t\t}\n\t\treturn list;\n\t}\n\t\n\t//输出学院员工的信息\n\tpublic void printEmployee() {\n\t\t//获取到学院员工\n\t\tList<CollegeEmployee> list1 = getAllEmployee();\n\t\tSystem.out.println(\"------------学院员工------------\");\n\t\tfor (CollegeEmployee e : list1) {\n\t\t\tSystem.out.println(e.getId());\n\t\t}\n\t}\n}\n\n//学校管理类\n\n//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager\n//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 \nclass SchoolManager {\n\t//返回学校总部的员工\n\tpublic List<Employee> getAllEmployee() {\n\t\tList<Employee> list = new ArrayList<Employee>();\n\t\t\n\t\tfor (int i = 0; i < 5; i++) { //这里我们增加了5个员工到 list\n\t\t\tEmployee emp = new Employee();\n\t\t\temp.setId(\"学校总部员工id= \" + i);\n\t\t\tlist.add(emp);\n\t\t}\n\t\treturn list;\n\t}\n\n\t//该方法完成输出学校总部和学院员工信息(id)\n\tvoid printAllEmployee(CollegeManager sub) {\n\t\t\n\t\t//分析问题\n\t\t//1. 将输出学院的员工方法，封装到CollegeManager\n\t\tsub.printEmployee();\n\t\n\t\t//获取到学校总部员工\n\t\tList<Employee> list2 = this.getAllEmployee();\n\t\tSystem.out.println(\"------------学校总部员工------------\");\n\t\tfor (Employee e : list2) {\n\t\t\tSystem.out.println(e.getId());\n\t\t}\n\t}\n}\n"]],[18991,18991],[20985,20985]]],[1571234756433,["GJX@GJXAIOU",[[1,20992,"#### ### 2.1.1 迪米特法则注意事项和细节\n\n1) 迪米特法则的核心是降低类之间的耦合\n\n2) 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系"]],[20992,20992],[21106,21106]]],[1571234759513,["GJX@GJXAIOU",[[-1,20997,"### 2.1.1 "]],[20997,21007],[20997,20997]]],[1571234760564,["GJX@GJXAIOU",[[1,20997,"4."]],[20997,20997],[20999,20999]]],[1571234760722,["GJX@GJXAIOU",[[-1,20998,"."],[1,20999," "]],[20999,20999],[20998,20998]]],[1571234763062,["GJX@GJXAIOU",[[1,20998,"."]],[20998,20998],[20999,20999]]],[1571234765823,["GJX@GJXAIOU",[[-1,21014,"1)"]],[21014,21016],[21014,21014]]],[1571234766347,["GJX@GJXAIOU",[[1,21014,"-"]],[21014,21014],[21015,21015]]],[1571234766862,["GJX@GJXAIOU",[[1,21016," "]],[21015,21015],[21016,21016]]],[1571234768603,["GJX@GJXAIOU",[[-1,21036,"2) "]],[21036,21039],[21036,21036]]],[1571234769279,["GJX@GJXAIOU",[[1,21036,"- "]],[21036,21036],[21038,21038]]],[1571234772171,["GJX@GJXAIOU",[[-1,21014,"- "]],[21016,21016],[21014,21014]]],[1571234774267,["GJX@GJXAIOU",[[1,21014,"-"]],[21014,21014],[21015,21015]]],[1571234776368,["GJX@GJXAIOU",[[-1,21034,"\n"]],[21034,21034],[21033,21033]]],[1571234796648,["GJX@GJXAIOU",[[1,21102,"\n"]],[21098,21098],[21099,21099]]],[1571234799506,["GJX@GJXAIOU",[[1,21099,"## 2.1 合成复用原则（Composite Reuse  Principle）\n\n### 2.1.1 基本介绍\n\n原则是尽量使用合成/聚合的方式，而不是使用继承\n\n## 2.2 设计原则核心思想\n\n1) 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。\n\n2) 针对接口编程，而不是针对实现编程。\n\n3) 为了交互对象之间的**松耦合设计而努**力"]],[21099,21099],[21291,21291]]],[1571234801920,["GJX@GJXAIOU",[[1,21101,"#"]],[21106,21106],[21141,21141]]],[1571234804062,["GJX@GJXAIOU",[[-1,21103,"2.1 "]],[21103,21107],[21103,21103]]],[1571234805424,["GJX@GJXAIOU",[[1,21103,"()"]],[21103,21103],[21105,21105]]],[1571234806770,["GJX@GJXAIOU",[[-1,21103,"()"]],[21105,21105],[21103,21103]]],[1571234807810,["GJX@GJXAIOU",[[1,21103,"（）"]],[21103,21103],[21105,21105]]],[1571234810676,["GJX@GJXAIOU",[[1,21104,"七"]],[21104,21104],[21105,21105]]],[1571234814120,["GJX@GJXAIOU",[[-1,21146,"2.1.1 "]],[21146,21152],[21146,21146]]],[1571234815280,["GJX@GJXAIOU",[[1,21146,"1 "]],[21146,21146],[21147,21147]]],[1571234815716,["GJX@GJXAIOU",[[1,21147,"."]],[21147,21147],[21148,21148]]],[1571234817032,["GJX@GJXAIOU",[[1,21145,"#"]],[21148,21148],[21154,21154]]],[1571234821296,["GJX@GJXAIOU",[[1,21183,"##"]],[21188,21188],[21198,21198]]],[1571234825202,["GJX@GJXAIOU",[[-1,21188,"2 "]],[21190,21190],[21188,21188]]],[1571234826455,["GJX@GJXAIOU",[[1,21188," "]],[21188,21188],[21189,21189]]],[1571234829968,["GJX@GJXAIOU",[[-1,21199,"1)"]],[21199,21201],[21199,21199]]],[1571234830490,["GJX@GJXAIOU",[[1,21199,"-"]],[21199,21199],[21200,21200]]],[1571234833369,["GJX@GJXAIOU",[[-1,21243,"2) "]],[21243,21246],[21243,21243]]],[1571234834665,["GJX@GJXAIOU",[[1,21243,"- "]],[21243,21243],[21245,21245]]],[1571234836767,["GJX@GJXAIOU",[[-1,21263,"\n3) "]],[21263,21267],[21263,21263]]],[1571234838132,["GJX@GJXAIOU",[[1,21263,"- "]],[21263,21263],[21265,21265]]],[1571234839760,["GJX@GJXAIOU",[[-1,21242,"\n"]],[21242,21242],[21241,21241]]],[1571234853031,["GJX@GJXAIOU",[[1,21181,"\n"]],[21181,21181],[21182,21182]]],[1571234853704,["GJX@GJXAIOU",[[1,21182,"\n"]],[21182,21182],[21183,21183]]],[1571235023546,["GJX@GJXAIOU",[[1,21181,"![合成复用原则]($resource/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99.jpg)"]],[21181,21181],[21261,21261]]],[1571235034160,["GJX@GJXAIOU",[[-1,21363,"**"]],[21363,21365],[21363,21363]]],[1571235036142,["GJX@GJXAIOU",[[1,21364,"**"]],[21364,21364],[21366,21366]]]],null,"GJX@GJXAIOU"],["651c41f6-49d6-4444-bf67-f82cffa2eba3",1573979428013,"# 第二章：设计模式七大原则\n\n## 一、设计模式的目的\n\n编写软件过程中，程序员面临着来自 **耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性** 等多方面的挑战，设计模式是为了让程序(软件)，具有更好的\n\n- 代码重用性 (即：相同功能的代码，不用多次编写)\n- 可读性 (即：编程规范性, 便于其他程序员的阅读和理解)\n- 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)\n- 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)\n- 使程序呈现高内聚，低耦合的特性\n- 设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要”\n\n\n\n## 二、设计模式七大原则\n\n设计模式原则，其实就是**程序员在编程时，应当遵守的原则**，也是各种**设计模式的基础**(即：**设计模式为什么这样设计的依据**)\n\n设计模式常用的七大原则有:\n* 单一职责原则\n* 接口隔离原则\n* 依赖倒转(倒置)原则\n* 里氏替换原则\n* 开闭原则\n* 迪米特法则\n* 合成复用原则\n\n### （一）单一职责原则\n\n#### 1. 基本介绍\n\n对类来说的，**即一个类应该只负责一项职责**。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2；\n\n####  2. 应用实例\n\n不使用单一职责原则：\n```java\npackage com.gjxaiou.principle.singleresponsibility;\n\npublic class SingleResponsibility1 {\n\tpublic static void main(String[] args) {\n\t\tVehicle vehicle = new Vehicle();\n\t\tvehicle.run(\"摩托车\");\n\t\tvehicle.run(\"汽车\");\n\t\tvehicle.run(\"飞机\");\n\t}\n}\n\n/**\n * 方式1：只使用一个交通工具类\n * \t1. 在方式 1 的 run方法中，违反了单一职责原则\n * \t2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可\n */\nclass Vehicle {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + \" 在公路上运行....\");\n\t}\n}\n\n```\n\n改进方式：\n```java\npackage com.gjxaiou.principle.singleresponsibility;\n\npublic class SingleResponsibility2 {\n\n\tpublic static void main(String[] args) {\n\t\tRoadVehicle roadVehicle = new RoadVehicle();\n\t\troadVehicle.run(\"摩托车\");\n\t\troadVehicle.run(\"汽车\");\n\t\t\n\t\tAirVehicle airVehicle = new AirVehicle();\n\t\tairVehicle.run(\"飞机\");\n\t}\n\n}\n\n//方案2的分析\n//1. 遵守单一职责原则\n//2. 但是这样做的改动很大，即要将类分解，同时修改客户端\n//3. 改进：直接修改Vehicle 类，改动的代码会比较少=>方案3\n\nclass RoadVehicle {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + \"公路运行\");\n\t}\n}\n\nclass AirVehicle {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + \"天空运行\");\n\t}\n}\n\nclass WaterVehicle {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + \"水中运行\");\n\t}\n}\n```\n\n使用单一职责原则\n```java\npackage com.gjxaiou.principle.singleresponsibility;\n\npublic class SingleResponsibility3 {\n\tpublic static void main(String[] args) {\n\t\tVehicle2 vehicle2  = new Vehicle2();\n\t\tvehicle2.run(\"汽车\");\n\t\tvehicle2.runWater(\"轮船\");\n\t\tvehicle2.runAir(\"飞机\");\n\t}\n}\n\n//方式3的分析\n//1. 这种修改方法没有对原来的类做大的修改，只是增加方法\n//2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责\nclass Vehicle2 {\n\tpublic void run(String vehicle) {\n\t\tSystem.out.println(vehicle + \" 在公路上运行....\");\n\t}\n\t\n\tpublic void runAir(String vehicle) {\n\t\tSystem.out.println(vehicle + \" 在天空上运行....\");\n\t}\n\t\n\tpublic void runWater(String vehicle) {\n\t\tSystem.out.println(vehicle + \" 在水中行....\");\n\t}\n\n\t// 对于拓展的功能只需要在这里新增功能即可\n}\n```\n\n#### 3. 单一职责原则注意事项和细节\n\n- 降低类的复杂度，一个类只负责一项职责。\n- 提高类的可读性，可维护性\n- 降低变更引起的风险\n\n通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则\n\n\n### （二）接口隔离原则(Interface Segregation Principle)\n\n#### 1.基本介绍\n\n- 客户端不应该依赖它不需要的接口，即**一个类对另一个类的依赖应该建立在最小的接口**上；\n\n先看一张图:\n![接口隔离原则]($resource/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.jpg)\n\n- 类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，其中类 B 和类 D 实现了接口 Interface1，如果接口 Interface1 对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。\n\n\n- 按隔离原则应当这样处理：\n口Interface1拆分为独立的几个接口(这里我们拆分成 3 个接口)，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则\n\n#### 2. 应用实例\n\n没有使用接口隔离原则的代码\n```java\npackage com.gjxaiou.principle.segregation;\n\npublic class Segregation1 {\n\tpublic static void main(String[] args) {\n\t}\n}\n\n// 接口 Interface1\ninterface Interface1 {\n\tvoid operation1();\n\tvoid operation2();\n\tvoid operation3();\n\tvoid operation4();\n\tvoid operation5();\n}\n\n/**\n *  类 B 实现了接口 Interface1\n */\nclass B implements Interface1 {\n\t@Override\n\tpublic void operation1() {\n\t\tSystem.out.println(\"B 实现了 operation1\");\n\t}\n\t@Override\n\tpublic void operation2() {\n\t\tSystem.out.println(\"B 实现了 operation2\");\n\t}\n\t@Override\n\tpublic void operation3() {\n\t\tSystem.out.println(\"B 实现了 operation3\");\n\t}\n\t@Override\n\tpublic void operation4() {\n\t\tSystem.out.println(\"B 实现了 operation4\");\n\t}\n\t@Override\n\tpublic void operation5() {\n\t\tSystem.out.println(\"B 实现了 operation5\");\n\t}\n}\n\n/**\n * 类 D 实现了接口 Interface1\n */\nclass D implements Interface1 {\n\t@Override\n\tpublic void operation1() {\n\t\tSystem.out.println(\"D 实现了 operation1\");\n\t}\n\t@Override\n\tpublic void operation2() {\n\t\tSystem.out.println(\"D 实现了 operation2\");\n\t}\n\t@Override\n\tpublic void operation3() {\n\t\tSystem.out.println(\"D 实现了 operation3\");\n\t}\n\t@Override\n\tpublic void operation4() {\n\t\tSystem.out.println(\"D 实现了 operation4\");\n\t}\n\t@Override\n\tpublic void operation5() {\n\t\tSystem.out.println(\"D 实现了 operation5\");\n\t}\n}\n\n/**\n * A 类通过接口 Interface1 依赖(使用) B 类，但是只会用到 1,2,3 方法\n */\nclass A {\n\tpublic void depend1(Interface1 i) {\n\t\ti.operation1();\n\t}\n\tpublic void depend2(Interface1 i) {\n\t\ti.operation2();\n\t}\n\tpublic void depend3(Interface1 i) {\n\t\ti.operation3();\n\t}\n}\n\n/**\n *  C 类通过接口 Interface1 依赖(使用) D 类，但是只会用到 1,4,5 方法\n */\nclass C {\n\tpublic void depend1(Interface1 i) {\n\t\ti.operation1();\n\t}\n\tpublic void depend4(Interface1 i) {\n\t\ti.operation4();\n\t}\n\tpublic void depend5(Interface1 i) {\n\t\ti.operation5();\n\t}\n}\n```\n\n使用传统方法的问题和使用接口隔离原则改进\n\n- 类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C 来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法\n-  将接口 **Interface1 拆分为独立的几个接口**，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则\n\n本问题中，接口 Interface1 中出现的方法，根据实际情况拆分为**三个**接口\n\n![接口隔离原则改进]($resource/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E6%94%B9%E8%BF%9B.jpg)\n\n```java\npackage com.gjxaiou.principle.segregation.improve;\n\npublic class Segregation1 {\n\n\tpublic static void main(String[] args) {\n        // A类通过接口去依赖B类\n\t\tA a = new A();\n\t\ta.depend1(new B()); \n\t\ta.depend2(new B());\n\t\ta.depend3(new B());\n\n        // C类通过接口去依赖(使用)D类\n\t\tC c = new C();\n\t\tc.depend1(new D()); \n\t\tc.depend4(new D());\n\t\tc.depend5(new D());\n\n\t}\n\n}\n\n// 接口1\ninterface Interface1 {\n\tvoid operation1();\n}\n\n// 接口2\ninterface Interface2 {\n\tvoid operation2();\n\tvoid operation3();\n}\n\n// 接口3\ninterface Interface3 {\n\tvoid operation4();\n\tvoid operation5();\n}\n\nclass B implements Interface1, Interface2 {\n\t@Override\n    public void operation1() {\n\t\tSystem.out.println(\"B 实现了 operation1\");\n\t}\n\n\t@Override\n    public void operation2() {\n\t\tSystem.out.println(\"B 实现了 operation2\");\n\t}\n\n\t@Override\n    public void operation3() {\n\t\tSystem.out.println(\"B 实现了 operation3\");\n\t}\n\n}\n\nclass D implements Interface1, Interface3 {\n\t@Override\n    public void operation1() {\n\t\tSystem.out.println(\"D 实现了 operation1\");\n\t}\n\n\t@Override\n    public void operation4() {\n\t\tSystem.out.println(\"D 实现了 operation4\");\n\t}\n\n\t@Override\n    public void operation5() {\n\t\tSystem.out.println(\"D 实现了 operation5\");\n\t}\n}\n\n// A 类通过接口Interface1,Interface2 依赖(使用) B类，但是只会用到1,2,3方法\nclass A {\n\tpublic void depend1(Interface1 i) {\n\t\ti.operation1();\n\t}\n\n\tpublic void depend2(Interface2 i) {\n\t\ti.operation2();\n\t}\n\n\tpublic void depend3(Interface2 i) {\n\t\ti.operation3();\n\t}\n}\n\n// C 类通过接口Interface1,Interface3 依赖(使用) D类，但是只会用到1,4,5方法\nclass C { \n\tpublic void depend1(Interface1 i) {\n\t\ti.operation1();\n\t}\n\n\tpublic void depend4(Interface3 i) {\n\t\ti.operation4();\n\t}\n\n\tpublic void depend5(Interface3 i) {\n\t\ti.operation5();\n\t}\n}\n```\n\n\n### （三）依赖倒转原则\n\n#### 1. 基本介绍\n\n依赖倒转原则(Dependence Inversion Principle)是指：\n\n- 高层模块不应该依赖低层模块，二者都应该依赖其抽象；\n- 抽象不应该依赖细节，细节应该依赖抽象；\n- 依赖倒转(倒置)的中心思想是面向接口编程；\n- 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类；\n- 使用**接口或抽象类**的目的是制定好**规范**，而不涉及任何具体的操作，把**展现细节的任务交给他们的实现类**去完成；\n\n#### 2. 应用实例\n\n请编程完成 Person 接收消息 的功能。\n一般的实现方案\n```java\npackage com.gjxaiou.principle.inversion;\n\n/**\n * 完成Person接收消息的功能\n * 问题：如果我们获取的对象是 微信，短信等等，则新增类，同时 Perons 也要增加相应的接收方法，因为 person 和 Email 绑定了\n * 解决思路：引入一个抽象的接口 IReceiver, 表示接收者, 这样 Person 类与接口 IReceiver 发生依赖\n * 因为 Email, WeiXin 等等属于接收的范围，他们各自实现 IReceiver 接口就 ok, 这样我们就符合依赖倒转原则\n */\npublic class DependecyInversion {\n\tpublic static void main(String[] args) {\n\t\tPerson person = new Person();\n\t\tperson.receive(new Email());\n\t}\n}\n\nclass Email {\n\tpublic String getInfo() {\n\t\treturn \"电子邮件信息: hello,world\";\n\t}\n}\n\nclass Person {\n\tpublic void receive(Email email ) {\n\t\tSystem.out.println(email.getInfo());\n\t}\n}\n\n```\n\n使用依赖反转之后\n```java\npackage com.gjxaiou.principle.inversion.improve;\n\npublic class DependecyInversion {\n\tpublic static void main(String[] args) {\n\t\t//客户端无需改变\n\t\tPerson person = new Person();\n\t\tperson.receive(new Email());\n\t\tperson.receive(new WeiXin());\n\t}\n}\n\n/**\n * 定义接收消息统一接口\n */\ninterface IReceiver {\n\tpublic String getInfo();\n}\n\nclass Email implements IReceiver {\n\t@Override\n\tpublic String getInfo() {\n\t\treturn \"电子邮件信息: hello,world\";\n\t}\n}\n\n//增加微信\nclass WeiXin implements IReceiver {\n\t@Override\n\tpublic String getInfo() {\n\t\treturn \"微信信息: hello,ok\";\n\t}\n}\n\nclass Person {\n\t/**\n\t *  这里我们是对接口的依赖\n\t * @param receiver ：传入的参数是接口\n\t */\n\tpublic void receive(IReceiver receiver ) {\n\t\tSystem.out.println(receiver.getInfo());\n\t}\n}\n\n```\n\n#### 3. 依赖关系传递的三种方式和应用案例\n\n- 接口传递\n```java\npackage com.gjxaiou.principle.inversion.improve;\n\npublic class DependencyPass {\n\tpublic static void main(String[] args) {\n\t\tChangHong changHong = new ChangHong();\n\t\tOpenAndClose openAndClose = new OpenAndClose();\n\t\topenAndClose.open(changHong);\t\n\t}\n}\n\n/**\n * 方式1： 通过接口传递实现依赖\n */\ninterface ITV {\n\tpublic void play();\n}\n\nclass ChangHong implements ITV {\n\t@Override\n\tpublic void play() {\n\t\tSystem.out.println(\"长虹电视机，打开\");\n\t}\n}\n\ninterface IOpenAndClose {\n\t//抽象方法,接收接口\n\tpublic void open(ITV tv); \n}\n\n// 实现接口\nclass OpenAndClose implements IOpenAndClose {\n\t@Override\n\tpublic void open(ITV tv) {\n\t\ttv.play();\n\t}\n}\n```\n\n\n- 构造方法传递\n```java\npackage com.gjxaiou.principle.inversion.improve;\n\npublic class DependencyPass {\n\tpublic static void main(String[] args) {\n\t\tChangHong changHong = new ChangHong();\n\t\n\t\t//通过构造器进行依赖传递\n\t\tOpenAndClose openAndClose = new OpenAndClose(changHong);\n\t\topenAndClose.open();\n\t}\n}\n\n/**\n * 方式 2：通过构造方法依赖传递\n */\ninterface ITV { \n\tpublic void play();\n}\n\nclass ChangHong implements ITV {\n\t@Override\n\tpublic void play() {\n\t\tSystem.out.println(\"长虹电视机，打开\");\n\t}\n}\n\ninterface IOpenAndClose {\n\tpublic void open();\n}\n\nclass OpenAndClose implements IOpenAndClose {\n\t// 成员变量\n\tpublic ITV tv; \n\n\t// 构造器\n\tpublic OpenAndClose(ITV tv) { \n\t\tthis.tv = tv;\n\t}\n\n\t@Override\n\tpublic void open() {\n\t\tthis.tv.play();\n\t}\n}\n```\n\n- setter 方式传递\n```java\npackage com.gjxaiou.principle.inversion.improve;\n\npublic class DependencyPass {\n\tpublic static void main(String[] args) {\n\t\tChangHong changHong = new ChangHong();\n\n\t\t//通过setter方法进行依赖传递\n\t\tOpenAndClose openAndClose = new OpenAndClose();\n\t\t// 如果不使用 setTV就没有对象，则会报空指针异常\n\t\topenAndClose.setTv(changHong);\n\t\topenAndClose.open();\n\t}\n}\n\n// 方式3 , 通过setter方法传递\ninterface IOpenAndClose {\n\tpublic void open(); // 抽象方法\n\tpublic void setTv(ITV tv);\n}\n\nclass OpenAndClose implements IOpenAndClose {\n\tprivate ITV tv;\n\n\t@Override\n\tpublic void setTv(ITV tv) {\n\t\tthis.tv = tv;\n\t}\n\n\t@Override\n\tpublic void open() {\n\t\tthis.tv.play();\n\t}\n}\n\ninterface ITV { // ITV接口\n\tpublic void play();\n}\n\nclass ChangHong implements ITV {\n\t@Override\n\tpublic void play() {\n\t\tSystem.out.println(\"长虹电视机，打开\");\n\t}\n\n}\n```\n\n#### 4. 依赖倒转原则的注意事项和细节\n\n- 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好；\n- 变量的**声明类型尽量是抽象类或接口**, 这样我们的变量引用和实际对象间，就存在**一个缓冲层**，利于程序扩展和优化；\n- 继承时遵循**里氏替换**原则；\n\n\n\n### （四）里氏替换原则(Liskov  Substitution  Principle)\n\n### 1. OO 中的继承性的思考和说明\n\n- 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。\n\n- **继承在给程序设计带来便利的同时，也带来了弊端**。比如使用继承会给程序带来**侵入性**，程序的可移植性降低， 增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障；\n\n- 问题提出：**在编程中，如何正确的使用继承**? => **里氏替换**原则\n\n#### 2. 基本介绍\n\n- 如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型T2 是类型 T1 的子类型。**换句话说，所有引用基类的地方必须能透明地使用其子类的对象**。\n\n- 在使用继承时，遵循里氏替换原则，在**子类中尽量不要重写父类的方法**；\n\n- 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过**聚合，组合，依赖 来解决问题**。.\n\n#### 3. 一个程序引出的问题和思考\n如果在继承子类中重写了父类的方法则容易报错；\n```java\npackage com.gjxaiou.principle.liskov;\n\npublic class Liskov {\n\tpublic static void main(String[] args) {\n\t\tA a = new A();\n\t\tSystem.out.println(\"11-3=\" + a.func1(11, 3));\n\t\tSystem.out.println(\"1-8=\" + a.func1(1, 8));\n\t\tSystem.out.println(\"-----------------------\");\n\t\t\n\t\tB b = new B();\n\t\t//这里本意是求出11-3，但是因为方法被重写了，因此结果为 14\n\t\tSystem.out.println(\"11-3=\" + b.func1(11, 3));\n\t\tSystem.out.println(\"11+3+9=\" + b.func2(11, 3));\n\t}\n}\n\n/**\n * A类：返回两个数的差\n  */\nclass A {\n\tpublic int func1(int num1, int num2) {\n\t\treturn num1 - num2;\n\t}\n}\n\n/**\n * B 类继承了 A 增加了一个新功能：完成两个数相加,然后和9求和\n * 同时 B 类中不小心将 A 类中的 func1() 进行了重写\n  */\n\nclass B extends A {\n\t// 这里，重写了A类的方法, 可能是无意识\n\t@Override\n\tpublic int func1(int a, int b) {\n\t\treturn a + b;\n\t}\n\n\tpublic int func2(int a, int b) {\n\t\treturn func1(a, b) + 9;\n\t}\n}\n```\n\n####  4. 解决方法\n\n- 我们发现原来运行正常的相减功能发生了错误。原因就是类 B 无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候；\n- 通用的做法是：**原来的父类和子类都继承一个更通俗的基类**，原有的继承关系去掉，采用**依赖，聚合，组合**等关系代替；\n\n![里氏原则改进]($resource/%E9%87%8C%E6%B0%8F%E5%8E%9F%E5%88%99%E6%94%B9%E8%BF%9B.jpg)\n\n```java\npackage com.gjxaiou.principle.liskov.improve;\n\npublic class Liskov {\n\tpublic static void main(String[] args) {\n\t\tA a = new A();\n\t\tSystem.out.println(\"11-3=\" + a.func1(11, 3));\n\t\tSystem.out.println(\"-----------------------\");\n\n\t\tB b = new B();\n\t\t//因为B类不再继承A类，因此调用者，不会再func1是求减法\n\t\t//调用完成的功能就会很明确\n\t\tSystem.out.println(\"11+3=\" + b.func1(11, 3));\n\t\tSystem.out.println(\"1+8=\" + b.func1(1, 8));\n\n\t\t//使用组合仍然可以使用到A类相关方法\n\t\tSystem.out.println(\"11-3=\" + b.func3(11, 3));\n\t}\n}\n\n/**\n * 创建一个更加基础的基类，然后把更加基础的方法和成员写到Base类\n */\nclass Base {\n}\n\n/**\n * \tA 类：返回两个数的差\n */\nclass A extends Base {\n\tpublic int func1(int num1, int num2) {\n\t\treturn num1 - num2;\n\t}\n}\n\nclass B extends Base {\n\t//如果 B 需要使用 A 类的方法,使用组合关系\n\tprivate A a = new A();\n\n\t// 我们仍然想使用 A 的方法，因为这里参数和对象名重了，因此使用 this\n\tpublic int func3(int a, int b) {\n\t\treturn this.a.func1(a, b);\n\t}\n\n\tpublic int func1(int a, int b) {\n\t\treturn a + b;\n\t}\n\n\tpublic int func2(int a, int b) {\n\t\treturn func1(a, b) + 9;\n\t}\n}\n```\n\n\n### （五）开闭原则\n\n#### 1. 基本介绍\n\n- 开闭原则（Open  Closed Principle）是编程中**最基础、最重要**的设计原则\n\n- 一个软件实体如类，模块和函数应该**对扩展开放(对提供方)**，对**修改关闭(对使用方)**。用抽象构建框架，用实现扩展细节。\n\n- 当软件需要变化时，尽量**通过扩展软件**实体的行为来实现变化，而不是**通过修改**已有的代码来实现变化。\n\n- 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。\n\n#### 2. 看下面一段代码\n\n一个画图形的功能\n![开闭原则]($resource/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99.jpg)\n\n```java\npackage com.gjxaiou.principle.ocp;\n\npublic class Ocp {\n\tpublic static void main(String[] args) {\n\t\tGraphicEditor graphicEditor = new GraphicEditor();\n\t\tgraphicEditor.drawShape(new Rectangle());\n\t\tgraphicEditor.drawShape(new Circle());\n\t\tgraphicEditor.drawShape(new Triangle());\n\t}\n}\n\n//这是一个用于绘图的类 [使用方]：接收Shape对象，然后根据type，来绘制不同的图形\nclass GraphicEditor {\n\tpublic void drawShape(Shape s) {\n\t\tif (s.m_type == 1) {\n\t\t\tdrawRectangle(s);\n\t\t} else if (s.m_type == 2) {\n\t\t\tdrawCircle(s);\n\t\t} else if (s.m_type == 3) {\n\t\t\tdrawTriangle(s);\n\t\t}\n\t}\n\n\t//绘制矩形\n\tpublic void drawRectangle(Shape r) {\n\t\tSystem.out.println(\" 绘制矩形 \");\n\t}\n\n\t//绘制圆形\n\tpublic void drawCircle(Shape r) {\n\t\tSystem.out.println(\" 绘制圆形 \");\n\t}\n\t\n\t//这里需要增加：绘制三角形\n\tpublic void drawTriangle(Shape r) {\n\t\tSystem.out.println(\" 绘制三角形 \");\n\t}\n}\n\n//Shape类，基类\nclass Shape {\n\tint m_type;\n}\n\nclass Rectangle extends Shape {\n\tRectangle() {\n\t\tsuper.m_type = 1;\n\t}\n}\n\nclass Circle extends Shape {\n\tCircle() {\n\t\tsuper.m_type = 2;\n\t}\n}\n\n//新增画三角形\nclass Triangle extends Shape {\n\tTriangle() {\n\t\tsuper.m_type = 3;\n\t}\n}\n\n```\n\n**上面方式的优劣：**\n- 优点是比较好理解，简单易操作。\n- 缺点是违反了设计模式的ocp 原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码.\n比如我们这时要新增加一个图形种类 三角形，我们需要同时在提供方和使用方做修改，修改的地方较多；\n\n#### 3. 改进的思路分析\n\n**思路**：把创建 **Shape类做成抽象类**，并提供一个**抽象的draw** 方法，让**子类去实现即可**，这样我们有新的图形种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，**使用方的代码就不需要修改** -> 满足了开闭原则\n\n```java\npackage com.gjxaiou.principle.ocp.improve;\n\npublic class Ocp {\n\n\tpublic static void main(String[] args) {\n\t\tGraphicEditor graphicEditor = new GraphicEditor();\n\t\tgraphicEditor.drawShape(new Rectangle());\n\t\tgraphicEditor.drawShape(new Circle());\n\t\tgraphicEditor.drawShape(new Triangle());\n\t\tgraphicEditor.drawShape(new OtherGraphic());\n\t}\n}\n\n//这是一个用于绘图的类 [使用方]：接收Shape对象，调用draw方法\nclass GraphicEditor {\n\tpublic void drawShape(Shape s) {\n\t\ts.draw();\n\t}\n}\n\n//Shape类，基类\nabstract class Shape {\n\tint m_type;\n\tpublic abstract void draw();//抽象方法\n}\n\nclass Rectangle extends Shape {\n\tRectangle() {\n\t\tsuper.m_type = 1;\n\t}\n\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\" 绘制矩形 \");\n\t}\n}\n\nclass Circle extends Shape {\n\tCircle() {\n\t\tsuper.m_type = 2;\n\t}\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\" 绘制圆形 \");\n\t}\n}\n\n//新增画三角形\nclass Triangle extends Shape {\n\tTriangle() {\n\t\tsuper.m_type = 3;\n\t}\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\" 绘制三角形 \");\n\t}\n}\n\n//新增一个图形\nclass OtherGraphic extends Shape {\n\tOtherGraphic() {\n\t\tsuper.m_type = 4;\n\t}\n\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\" 绘制其它图形 \");\n\t}\n}\n\n```\n\n### （六）迪米特法则\n\n#### 1. 基本介绍\n\n- 一个对象应该对其他对象保持最少的了解\n- 类与类关系越密切，耦合度越大\n\n-  迪米特法则(Demeter  Principle)又叫**最少知道原则**，即一个类**对自己依赖的类知道的越少越好**。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息\n\n- 迪米特法则还有个更简单的定义：只与直接的朋友通信\n\n-  **直接的朋友**：每个对象都会与其他对象有**耦合关系**，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现**成员变量**，**方法参数**，**方法返回值**中的类为直接的朋友（即在 A 类中出现：B b = XXX，或者 fun(B  b) 或者 return B  b;），而出现在**局部变量中的类不是直接的朋友**。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。\n\n#### 2.应用实例\n\n有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 ID 和学院员工的 id\n\n```java\npackage com.gjxaiou.principle.demeter;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n//客户端\npublic class Demeter1 {\n\n\tpublic static void main(String[] args) {\n\t\t//创建了一个 SchoolManager 对象\n\t\tSchoolManager schoolManager = new SchoolManager();\n\t\t//输出学院的员工id 和  学校总部的员工信息\n\t\tschoolManager.printAllEmployee(new CollegeManager());\n\n\t}\n\n}\n\n\n//学校总部员工类\nclass Employee {\n\tprivate String id;\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n}\n\n\n//学院的员工类\nclass CollegeEmployee {\n\tprivate String id;\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n}\n\n\n//管理学院员工的管理类\nclass CollegeManager {\n\t//返回学院的所有员工\n\tpublic List<CollegeEmployee> getAllEmployee() {\n\t\tList<CollegeEmployee> list = new ArrayList<CollegeEmployee>();\n\t\tfor (int i = 0; i < 10; i++) { //这里我们增加了10个员工到 list\n\t\t\tCollegeEmployee emp = new CollegeEmployee();\n\t\t\temp.setId(\"学院员工id= \" + i);\n\t\t\tlist.add(emp);\n\t\t}\n\t\treturn list;\n\t}\n}\n\n//学校管理类\n\n//分析 SchoolManager 类的直接朋友类有哪些： Employee、CollegeManager\n//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 \nclass SchoolManager {\n\t//返回学校总部的员工\n\tpublic List<Employee> getAllEmployee() {\n\t\tList<Employee> list = new ArrayList<Employee>();\n\t\t\n\t\tfor (int i = 0; i < 5; i++) { //这里我们增加了5个员工到 list\n\t\t\tEmployee emp = new Employee();\n\t\t\temp.setId(\"学校总部员工id= \" + i);\n\t\t\tlist.add(emp);\n\t\t}\n\t\treturn list;\n\t}\n\n\t//该方法完成输出学校总部和学院员工信息(id)\n\tvoid printAllEmployee(CollegeManager sub) {\n\t\t\n\t\t//分析问题\n\t\t//1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友\n\t\t//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager\n\t\t//3. 违反了 迪米特法则 \n\t\t\n\t\t//获取到学院员工\n\t\tList<CollegeEmployee> list1 = sub.getAllEmployee();\n\t\tSystem.out.println(\"------------学院员工------------\");\n\t\tfor (CollegeEmployee e : list1) {\n\t\t\tSystem.out.println(e.getId());\n\t\t}\n\t\t//获取到学校总部员工\n\t\tList<Employee> list2 = this.getAllEmployee();\n\t\tSystem.out.println(\"------------学校总部员工------------\");\n\t\tfor (Employee e : list2) {\n\t\t\tSystem.out.println(e.getId());\n\t\t}\n\t}\n}\n\n```\n\n#### 3.应用实例改进\n\n- 前面设计的问题在于 SchoolManager 中，CollegeEmployee类并不是 SchoolManager 类的直接朋友 (分析)\n\n- 按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合\n\n- 对代码按照迪米特法则 进行改进\n\n```java\npackage com.gjxaiou.principle.demeter.improve;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n//客户端\npublic class Demeter1 {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"~~~使用迪米特法则的改进~~~\");\n\t\t//创建了一个 SchoolManager 对象\n\t\tSchoolManager schoolManager = new SchoolManager();\n\t\t//输出学院的员工id 和  学校总部的员工信息\n\t\tschoolManager.printAllEmployee(new CollegeManager());\n\n\t}\n\n}\n\n\n//学校总部员工类\nclass Employee {\n\tprivate String id;\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n}\n\n\n//学院的员工类\nclass CollegeEmployee {\n\tprivate String id;\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n}\n\n\n//管理学院员工的管理类\nclass CollegeManager {\n\t//返回学院的所有员工\n\tpublic List<CollegeEmployee> getAllEmployee() {\n\t\tList<CollegeEmployee> list = new ArrayList<CollegeEmployee>();\n\t\tfor (int i = 0; i < 10; i++) { //这里我们增加了10个员工到 list\n\t\t\tCollegeEmployee emp = new CollegeEmployee();\n\t\t\temp.setId(\"学院员工id= \" + i);\n\t\t\tlist.add(emp);\n\t\t}\n\t\treturn list;\n\t}\n\t\n\t//输出学院员工的信息\n\tpublic void printEmployee() {\n\t\t//获取到学院员工\n\t\tList<CollegeEmployee> list1 = getAllEmployee();\n\t\tSystem.out.println(\"------------学院员工------------\");\n\t\tfor (CollegeEmployee e : list1) {\n\t\t\tSystem.out.println(e.getId());\n\t\t}\n\t}\n}\n\n//学校管理类\n\n//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager\n//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 \nclass SchoolManager {\n\t//返回学校总部的员工\n\tpublic List<Employee> getAllEmployee() {\n\t\tList<Employee> list = new ArrayList<Employee>();\n\t\t\n\t\tfor (int i = 0; i < 5; i++) { //这里我们增加了5个员工到 list\n\t\t\tEmployee emp = new Employee();\n\t\t\temp.setId(\"学校总部员工id= \" + i);\n\t\t\tlist.add(emp);\n\t\t}\n\t\treturn list;\n\t}\n\n\t//该方法完成输出学校总部和学院员工信息(id)\n\tvoid printAllEmployee(CollegeManager sub) {\n\t\t\n\t\t//分析问题\n\t\t//1. 将输出学院的员工方法，封装到CollegeManager\n\t\tsub.printEmployee();\n\t\n\t\t//获取到学校总部员工\n\t\tList<Employee> list2 = this.getAllEmployee();\n\t\tSystem.out.println(\"------------学校总部员工------------\");\n\t\tfor (Employee e : list2) {\n\t\t\tSystem.out.println(e.getId());\n\t\t}\n\t}\n}\n\n```\n\n\n#### 4. 迪米特法则注意事项和细节\n\n- 迪米特法则的核心是降低类之间的耦合\n- 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系\n\n\n### （七）合成复用原则（Composite Reuse  Principle）\n\n#### 1. 基本介绍\n\n原则是尽量使用合成/聚合的方式，而不是使用继承\n\n![合成复用原则]($resource/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99.jpg)\n\n#### 2. 设计原则核心思想\n\n- 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。\n- 针对接口编程，而不是针对实现编程。\n- 为了交互对象之间的**松耦合设计而努力**\n\n\n\n",[[1573979427814,["GJX@GJXAIOUPC",[[1,0,"\n"]],[0,0],[1,1]]],[1573979429282,["GJX@GJXAIOUPC",[[1,0,"-"]],[0,0],[1,1]]],[1573979429445,["GJX@GJXAIOUPC",[[1,0,"-"]],[1,1],[2,2]]],[1573979429607,["GJX@GJXAIOUPC",[[1,2,"-"]],[2,2],[3,3]]],[1573979430016,["GJX@GJXAIOUPC",[[1,4,"\n---\n\n"]],[3,3],[4,4]]],[1573979431334,["GJX@GJXAIOUPC",[[1,5,"\n"]],[4,4],[5,5]]],[1573979432200,["GJX@GJXAIOUPC",[[-1,5,"\n"]],[5,5],[4,4]]],[1573979443234,["GJX@GJXAIOUPC",[[1,4,"flag: red"]],[4,4],[13,13]]],[1573979446151,["GJX@GJXAIOUPC",[[-1,10,"red"]],[13,13],[10,10]]],[1573979451110,["GJX@GJXAIOUPC",[[1,10,"purple"]],[10,10],[16,16]]],[1573979483380,["GJX@GJXAIOUPC",[[1,410,"* "]],[410,423],[412,425]]],[1573979485739,["GJX@GJXAIOUPC",[[-1,410,"* "]],[412,425],[410,423]]],[1573979487076,["GJX@GJXAIOUPC",[[1,410,"=="],[1,423,"=="]],[410,423],[410,427]]],[1573979546145,["GJX@GJXAIOUPC",[[1,2998,"ji"]],[2998,2998],[3000,3000]]],[1573979546190,["GJX@GJXAIOUPC",[[-1,2999,"i"],[1,3000," "]],[3000,3000],[2999,2999]]],[1573979546415,["GJX@GJXAIOUPC",[[1,2999,"e"]],[2999,2999],[3000,3000]]],[1573979546596,["GJX@GJXAIOUPC",[[-1,2999,"e"],[1,3000,"i"]],[3000,3000],[3000,3000]]],[1573979547288,["GJX@GJXAIOUPC",[[-1,2999,"i"]],[3000,3000],[2999,2999]]],[1573979555813,["GJX@GJXAIOUPC",[[-1,2998,"j "]],[3000,3000],[2998,2998]]],[1573979559163,["GJX@GJXAIOUPC",[[1,2998,"接"]],[2998,2998],[2999,2999]]]],null,"GJX@GJXAIOUPC"]]}