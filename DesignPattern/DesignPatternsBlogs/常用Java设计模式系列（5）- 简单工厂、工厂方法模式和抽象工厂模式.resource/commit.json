{"compress":true,"commitItems":[["467361e8-6efb-4c9a-815b-3ac8767e12fe",1567426076032,"# 常用Java设计模式系列（5）- 简单工厂、工厂方法模式和抽象工厂模式\n\n2017年05月04日 17:07:53 [DreamMakers](https://me.csdn.net/andamajing) 阅读数 532更多\n\n分类专栏： [常用Java设计模式系列](https://blog.csdn.net/andamajing/article/category/9268779)\n\n[](http://creativecommons.org/licenses/by-sa/4.0/)版权声明：本文为博主原创文章，遵循[ CC 4.0 BY-SA ](http://creativecommons.org/licenses/by-sa/4.0/)版权协议，转载请附上原文出处链接和本声明。\n\n本文链接：[https://blog.csdn.net/andamajing/article/details/71171328](https://blog.csdn.net/andamajing/article/details/71171328) \n\n讲到设计模式，我想大家都会想到工厂模式，在之前的几篇文章中，我们没有探讨，在这篇文章中，我们就来简单的看一下。\n\n说道工厂模式，其实并不是指一种设计模式，从标题看就知道，其实有好几种，下面我们对这几种都简单的看看。\n\n我们假设现在我们需要生产一些产品，这些产品我们委托给工厂进行生产。\n\n（1）简单工厂模式\n\n简单工厂模式，简单的说就是从前有个工厂，因为规模比较小，所以在一个工厂里面有多个生产线，生产不同的产品，客户提交订单时根据订单的要求去生产不同的产品并提供给客户。\n\n简单工厂模式涉及的角色有：\n\n工厂角色：具体生产产品的类\n\n抽象产品角色：具体产品需要实现的接口；\n\n具体产品角色：具体产品，由工厂生产出来的实体对象；\n\n下面我们通过简单的Java代码来简单实现一下：\n\n抽象产品角色示例代码：\n\n```\npackage com.majing.test.designpattern.factory.simplefactory; public interface IProduct {\tvoid display();}\n```\n\n 具体产品角色示例代码：\n\n```\npackage com.majing.test.designpattern.factory.simplefactory; public class ProductA implements IProduct{ \t@Override\tpublic void display() {\t\tSystem.out.println(\"我是ProductA.\");\t}\t}\n```\n\n```\npackage com.majing.test.designpattern.factory.simplefactory; public class ProductB implements IProduct { \t@Override\tpublic void display() {\t\tSystem.out.println(\"我是ProductB.\");\t} }\n```\n\n 工厂角色示例代码：\n\n```\npackage com.majing.test.designpattern.factory.simplefactory; public class SimpleFactory {\tpublic static IProduct produce(String type){\t\tIProduct product = null;\t\tif(\"A\".equals(type)){\t\t\tproduct = new ProductA(); \t\t}else if(\"B\".equals(type)){\t\t\tproduct = new ProductB();\t\t}else{\t\t\treturn null;\t\t}\t\treturn product;\t}}\n```\n\n 测试用例示例代码：\n\n```\npackage com.majing.test.designpattern.factory.simplefactory; public class Client {\tpublic static void main(String[] args) {\t\tIProduct product = SimpleFactory.produce(\"A\");\t\tproduct.display();\t\tproduct = SimpleFactory.produce(\"B\");\t\tproduct.display();\t}}\n```\n\n 从上面的实现可以看到，工厂是一个集中生产产品的地方，根据客户的需求（这里是生产A产品，还是生产B产品），来生产出对应的产品。\n\n这种设计模式的缺点是，如果需要这个工厂去生产新的产品，那么就需要修改工厂类，增加新产品生产逻辑，很明显，这违背了开闭原则。但是这种模式的优点是设计简单，实现方便。\n\n但是随着科技的发展，原本的工厂需要生产的东西越来越多，这时候，工厂厂长决定将不同的产品生产线进行独立，同一类型产品生产线由单独一个工厂进行生产，这样不同的生产线之间就不会相互影响了，不用挤在一个拥挤的老工厂里了。于是就出现了工厂方法模式。\n\n（2）工厂方法模式\n\n工厂方法模式，是将不同的产品生产交由不同的工厂进行生产，这样的话，当我们把一个订单交给一个工厂生产时，我们就不需要去说给我生产什么产品了，毕竟这个工厂只会生产一种产品。\n\n工厂方法模式涉及的角色大概有：\n\n抽象产品角色：是具体产品角色的基类，包含所有具体产品共有的特性； \n\n具体产品角色：具体产品角色， \n\n抽象工厂角色：是具体工厂角色的基类，包含着所有具体工厂共有的特性，如生产产品； \n\n具体工厂角色：负责生产具体产品的工厂类；\n\n和前面一样，我们也给出相应的Java代码示例：\n\n抽象产品角色示例代码：\n\n```\npackage com.majing.test.designpattern.factory.factorymethod; public interface IProduct {\tvoid display();}\n```\n\n 具体产品角色示例代码：\n\n```\npackage com.majing.test.designpattern.factory.factorymethod; public class ProductA implements IProduct{ \t@Override\tpublic void display() {\t\tSystem.out.println(\"我是ProductA.\");\t}\t}\n```\n\n```\npackage com.majing.test.designpattern.factory.factorymethod; public class ProductB implements IProduct { \t@Override\tpublic void display() {\t\tSystem.out.println(\"我是ProductB.\");\t} }\n```\n\n 抽象工厂角色示例代码：\n\n```\npackage com.majing.test.designpattern.factory.factorymethod; public interface IFactory {\tIProduct produce();}\n```\n\n 具体工厂角色示例代码：\n\n```\npackage com.majing.test.designpattern.factory.factorymethod; public class ProductAFactory implements IFactory { \t@Override\tpublic IProduct produce() {\t\treturn new ProductA();\t} }\n```\n\n```\npackage com.majing.test.designpattern.factory.factorymethod; public class ProductBFactory implements IFactory { \t@Override\tpublic IProduct produce() {\t\treturn new ProductB();\t} }\n```\n\n 从上面的示例代码中，我们看到，每个工厂都只生产一类产品。这种设计模式的好处是符合开闭原则，即使后面需要生产新的产品，也不需要修改已有的工厂类，而是新建一个工厂类和新的产品。当然也存在缺点，那就是，每次有新产品时都要实现相应的产品和工厂类，类的数量会越来越多。\n\n此时的厂长还想继续增加效益，所以做出了决定，那就是每个工厂不仅仅生产一类产品，而是生产多个产品，所有的工厂都生产多个相同种类的产品，这就引出了我们下面要说的另一种设计模式----抽象工厂模式\n\n（3）抽象工厂模式\n\n抽象工厂模式，是对工厂方法模式的进一步抽象，它让每个工厂都生产同一个产品簇，产品簇内包含多个产品类型。这里的示例是让每个工厂都生产ProductA和ProductB。\n\n抽象工厂模式涉及的角色和工厂方法模式一样，这里就不赘述了。下面直接来看看抽象工厂模式的实现。\n\n抽象产品角色示例代码：\n\n```\npackage com.majing.test.designpattern.factory.abstractfactory; public interface IProduct {\tvoid display();}\n```\n\n```\npackage com.majing.test.designpattern.factory.abstractfactory; import com.majing.test.designpattern.factory.simplefactory.IProduct; public abstract class AbstractProductA implements IProduct {\t}\n```\n\n```\npackage com.majing.test.designpattern.factory.abstractfactory; import com.majing.test.designpattern.factory.simplefactory.IProduct; public abstract class AbstractProductB implements IProduct { }\n```\n\n具体产品角色示例代码： \n\n```\npackage com.majing.test.designpattern.factory.abstractfactory; public class ProductA1 extends AbstractProductA { \t@Override\tpublic void display() {\t\tSystem.out.println(\"我是工厂1生产的ProductA!\");\t} }\n```\n\n```\npackage com.majing.test.designpattern.factory.abstractfactory; public class ProductA2 extends AbstractProductA { \t@Override\tpublic void display() {\t\tSystem.out.println(\"我是工厂2生产的ProductA!\");\t} }\n```\n\n```\npackage com.majing.test.designpattern.factory.abstractfactory; public class ProductB1 extends AbstractProductB { \t@Override\tpublic void display() {\t\tSystem.out.println(\"我是工厂1生产的ProductB!\");\t} }\n```\n\n```\npackage com.majing.test.designpattern.factory.abstractfactory; public class ProductB2 extends AbstractProductB { \t@Override\tpublic void display() {\t\tSystem.out.println(\"我是工厂2生产的ProductB!\");\t} }\n```\n\n 抽象工厂角色示例代码：\n\n```\npackage com.majing.test.designpattern.factory.abstractfactory; public interface IFactory {\tAbstractProductA produceA();\tAbstractProductB produceB();}\n```\n\n 具体工厂角色示例代码：\n\n```\npackage com.majing.test.designpattern.factory.abstractfactory; public class Factory1 implements IFactory { \t@Override\tpublic AbstractProductA produceA() {\t\treturn new ProductA1();\t} \t@Override\tpublic AbstractProductB produceB() {\t\treturn new ProductB1();\t} }\n```\n\n```\npackage com.majing.test.designpattern.factory.abstractfactory;  public class Factory2 implements IFactory { \t@Override\tpublic AbstractProductA produceA() {\t\treturn new ProductA2();\t} \t@Override\tpublic AbstractProductB produceB() {\t\treturn new ProductB2();\t}\t}\n```\n\n 测试用例代码：\n\n```\npackage com.majing.test.designpattern.factory.abstractfactory; public class Client {\tpublic static void main(String[] args) {\t\tIFactory factory = new Factory1();\t\tAbstractProductA productA = factory.produceA();\t\tAbstractProductB productB = factory.produceB();\t\tproductA.display();\t\tproductB.display();\t}}\n```\n\n 至此，一个简单的抽象工厂设计模式的演示代码便结束了。直观的感觉，那就是类的数量激增啊！！！大家看下每种模式的文件数（也就是类和接口数）：\n\n![](https://img-blog.csdn.net/20170504170458163?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWFqaW5nZ29nb2dv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n从上截图就可以看出来，一个模式比一个模式复杂，大家还是根据自己的需要选择合适的实现吧。",[[1567426040527,["GJX@GJXAIOU",[[-1,39,"2017年05月04日 17:07:53 [DreamMakers](https://me.csdn.net/andamajing) 阅读数 532更多\n\n分类专栏： [常用Java设计模式系列](https://blog.csdn.net/andamajing/article/category/9268779)\n\n[](http://creativecommons.org/licenses/by-sa/4.0/)版权声明：本文为博主原创文章，遵循[ CC 4.0 BY-SA ](http://creativecommons.org/licenses/by-sa/4.0/)版权协议，转载请附上原文出处链接和本声明"]],[39,349],[39,39]]],[1567426065136,["GJX@GJXAIOU",[[1,586,"\n"],[1,587,"\n"],[1,614,"\n"],[1,630,"\n"]],[526,631],[635,635]]],[1567426072079,["GJX@GJXAIOU",[[1,719,"\n"],[1,720,"\n"],[1,762,"\n"],[1,763,"\n"],[1,773,"\n"],[1,797,"\n"],[1,833,"\n"],[1,835,"\n"],[1,836,"\n"]],[659,837],[846,846]]],[1567426083914,["GJX@GJXAIOU",[[1,916,"\n"],[1,917,"\n"],[1,960,"\n"],[1,961,"\n"],[1,971,"\n"],[1,995,"\n"],[1,1031,"\n"],[1,1033,"\n"],[1,1034,"\n}"]],[856,1034],[1044,1044]]],[1567426090710,["GJX@GJXAIOU",[[1,1127,"\n"],[1,1128,"\n"],[1,1156,"\n"],[1,1201,"\n"],[1,1227,"\n"],[1,1250,"\n"],[1,1279,"\n"],[1,1308,"\n"],[1,1336,"\n"],[1,1344,"\n"],[1,1359,"\n"],[1,1362,"\n"],[1,1379,"\n"],[1,1381,"\n"]],[1067,1382],[1396,1396]]],[1567426099560,["GJX@GJXAIOU",[[1,1478,"\n"],[1,1479,"\n"],[1,1500,"\n"],[1,1541,"\n"],[1,1589,"\n"],[1,1609,"\n"],[1,1648,"\n"],[1,1668,"\n"],[1,1670,"\n"]],[1418,1671],[1680,1680]]],[1567426107752,["GJX@GJXAIOU",[[1,2287,"\n"],[1,2288,"\n"],[1,2315,"\n"],[1,2331,"\n"]],[2227,2332],[2336,2336]]],[1567426117197,["GJX@GJXAIOU",[[1,2420,"\n"],[1,2421,"\n"],[1,2463,"\n"],[1,2464,"\n"],[1,2474,"\n"],[1,2498,"\n"],[1,2534,"\n"],[1,2536,"\n"],[1,2537,"\n"]],[2360,2538],[2547,2547]]],[1567426124559,["GJX@GJXAIOU",[[1,2617,"\n"],[1,2618,"\n"],[1,2661,"\n"],[1,2662,"\n"],[1,2672,"\n"],[1,2696,"\n"],[1,2732,"\n"],[1,2734,"\n"],[1,2735,"\n"]],[2557,2736],[2745,2745]]],[1567426131574,["GJX@GJXAIOU",[[1,2829,"\n"],[1,2830,"\n"],[1,2857,"\n"],[1,2877,"\n"]],[2769,2878],[2882,2882]]],[1567426138745,["GJX@GJXAIOU",[[1,2966,"\n"],[1,2967,"\n"],[1,3017,"\n"],[1,3018,"\n"],[1,3028,"\n"],[1,3056,"\n"],[1,3080,"\n"],[1,3082,"\n"],[1,3083,"\n"]],[2906,3084],[3093,3093]]],[1567426145209,["GJX@GJXAIOU",[[1,3163,"\n"],[1,3164,"\n"],[1,3214,"\n"],[1,3215,"\n"],[1,3225,"\n"],[1,3253,"\n"],[1,3277,"\n"],[1,3279,"\n"],[1,3280,"\n"]],[3103,3281],[3290,3290]]]],null,"GJX@GJXAIOU"]]}