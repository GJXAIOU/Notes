# 第二章 并发基础
##  一、CPU多级缓存

### （一）CPU 多级缓存概念和作用

![basic_1](%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.resource/basic_1.jpg)

**为什么加缓存**：CPU 的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU 常常需要等待主存，浪费资源。所以 Cache 的出现是为了缓解主存和 CPU 之间速度不匹配的问题（结构：cpu->cache->memory）

**CPU缓存的意义**：（缓存容量远远小于主存）

* 时间局部性：如果某个数据被访问，那么在不久的将来它可能会再次被访问。

* 空间局部性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问。

### （二）缓存一致性(MESI 原则)

- MESI 协议为了保证多个 CPU 的 Cache 之间缓存共享数据的一致，定义了 Cache Line 四种状态，而 CPU 对 Cache 的四种操作可能造成不一致的状态， 因此缓存控制器监听到本次操作和远程操作之后需要对地址一定的 Cache Line 的状态做出一定的修改，从而保证数据在缓多个位置的一致性。

- MESI 是指4种状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：

| 状态描述 | 说明 | 描述 |
| --- | --- | --- |
| M: Modified 修改 | 该 Cache line 有效，数据被修改了，**和内存中的数据不一致**，数据只存在于**本 Cache**中。 | 该缓存行中的内存需要在未来的某个时间点（允许其它CPU读取请主存中相应内存之前）写回（write back）主存。 当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。 |
| E：Exclusive 独享 | 该Cache line有效，数据**和内存中的数据一致**，数据只存在于**本Cache**中。 | 该状态可以在任何时刻当有其它 CPU读取该内存时变成共享状态（shared)。 同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态。 |
| S：Share 共享 | 该Cache line有效，数据**和内存中的数据一致**，数据存在于**很多Cache**中。 | 当有一个CPU修改该缓存行中，其它CPU中该缓存行可以被作废（变成无效状态（Invalid））。 |
| I:Invalid 无效 | 该Cache line无效。 | 无 |

* 触发事件:（CPU 对缓存的四种操作）

| 触发事件 | 描述 |
| --- | --- |
| 本地读取（Local read） | 本地 cache 读取本地 cache 数据 |
| 本地写入（Local write） | 本地 cache 写入本地 cache 数据 |
| 远端读取（Remote read） | 其他 cache 读取本地 cache 数据 |
| 远端写入（Remote write） | 其他 cache 写入本地 cache 数据 |

* cache 分类：

前提：所有的 cache 共同缓存了主内存中的某一条数据。

| cache分类 | 解释 |
| --- | --- |
| 本地 cache | 指当前 cpu 的 cache |
| 触发 cache | 触发读写事件的 cache |
| 其他 cache | 指既除了以上两种之外的 cache |

注意：本地的事件触发 本地 cache 和触发 cache 相同。


* MESI状态转换：

![basic_2](%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.resource/basic_2.png)

* 切换的解释：

![basic_3](%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.resource/basic_3.png)

### （三）CPU多级缓存的乱序执行优化：

处理器为提高运算速度而做出违背代码原有顺序的优化

![basic_4](%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.resource/basic_4.png)

导致的一个问题，如果我们不做任何处理，在多核的情况下，实际结果可能和逻辑运行结果大不相同，例如如果在一个核上执行数据写入操作，并在最后执行一个操作来标记数据已经写入好了，而在另外一个核上通过该标记位判定数据是否已经写入，这时候就可能出现不一致，标记位先被写入，但是实际的操作却并未完成，这个未完成既有可能是没有计算完成，也有可能是缓存没有被及时刷新到主存之中，使得其他核读到了错误的数据。

##  二、Java 内存模型（Java Memory Model，JMM）
* **Java 内存模型规范**了：

    * 规定了 JVM 和 计算机内存是如何协同工作的；

    - 规定了一个线程如何和何时可以看到其他线程修改过后的共享变量的值

    - 规定了在必须时候如何以及何时同步的访问共享变量


### （一）Java 内存模型

![basic_5](%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.resource/basic_5.jpg)

说明：

- Heap(堆)：java 里的堆是一个运行时的数据区，堆是由垃圾回收来负责的，堆的优势是可以动态的分配内存大小，生存期也不必事先告诉编译器，因为他是在运行时动态分配内存的，java的垃圾回收器会定时收走不用的数据，缺点是由于要在运行时动态分配，所有存取速度可能会慢一些。

- Stack(栈)：栈的优势是存取速度比堆要快，仅次于计算机里的寄存器，栈的数据是可以共享的，缺点是存在栈中的数据的大小与生存期必须是确定的，缺乏一些灵活性。栈中主要存放一些基本类型的变量，比如int，short，long，byte，double，float，boolean，char，对象句柄。

java内存模型要求调用栈和本地内存变量存放在线程栈（Thread Stack）上，对象存放在堆上。
一个本地变量可能存放一个对象的引用，这时引用变量存放在本地栈上，但是对象本身存放在堆上
成员变量跟随着对象存放在堆上，而不管是原始类型还是引用类型，
静态成员变量跟随着类的定义一起存在在堆上。

存在堆上的对象，可以被持有这个对象的引用的线程访问，
如果两个线程同时访问同一个对象的私有变量，这时他们获得的是这个对象的私有拷贝。

### （二）计算机硬件架构

![basic_6](%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.resource/basic_6.jpg)

说明：

- CPU：一个计算机一般有多个CPU，一个CPU还会有多核 

- CPU Registers（寄存器）：每个CPU都包含一系列的寄存器，
    他们是CPU内存的基础，CPU在寄存器上执行的速度远大于在主存上执行的速度。 

- CPU Cache（高速缓存）：由于计算机的存储设备与处理器的处理设备有着几个数量级的差距， 
    所以现代计算机都会加入一层读写速度与处理器处理速度接近想通的高级缓存来作为内存与处理器之间的缓冲， 
    将运算使用到的数据复制到缓存中，让运算能够快速的执行，
    当运算结束后，再从缓存同步到内存之中，这样，
    CPU就不需要等待缓慢的内存读写了 

- 主（内）存：一个计算机包含一个主存，所有的CPU都可以访问主存，主存比缓存容量大的多 

- 运作原理：通常情况下，当一个CPU要读取主存的时候，他会将主存中的数据读取到CPU缓存中，甚至将缓存中的内容读到内部寄存器里面，然后再寄存器执行操作， 当运行结束后，会将寄存器中的值刷新回缓存中并在某个时间点刷新回主存。 

* **内存模型与硬件架构之间的关联**：

![basic_7](%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.resource/basic_7.jpg)

所有线程栈和堆会被保存在主内存里面，部分可能会出现在CPU缓存中和CPU内部的寄存器里面

* **工作内存和主内存**

处理器上的的寄存器的读写熟读比内存快几个数量级，为了解决这种速度矛盾，
在他们之间加入了**高速缓存**。

加入高速缓存带来了一个新问题：**缓存一致性**。如果多个缓存共享同一块主存区域，
那么多个缓存的数据可能会不一致，需要一些协议来解决。

![basic_8](%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.resource/basic_8.png)

所有的变量都存储在主内存中，每个线程有自己的工作内存，**工作内存存储在缓存或者寄存器**中，
保存了该线程使用的变量的主内存副本拷贝。

线程只能直接操作工作内存中的变量，**不同线程之间的变量通过值传递需要通过主内存来完成**。

![basic_9](%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.resource/basic_9.png)

* **线程和主内存的抽象关系**

![basic_10](%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.resource/basic_10.jpg)

说明：

每个线程之间**共享变量都存放在主内存**里面，每个线程都有一个私有的本地内存 （工作内存），
本地内存是java内存模型中抽象的概念，并不是真实存在的（他涵盖了缓存写缓冲区、寄存器
以及其他硬件的优化） 本地内存中存储了以读或者写共享变量的拷贝的一个副本 。
从一个更低的层次来说，线程本地内存，他是cpu缓存，寄存器的一个抽象描述，
而JVM的静态内存存储模型，它只是一种对内存模型的物理划分而已，只局限在内存，而且只局限在JVM的内存 。

如果线程A和线程B要通信，必须经历两个过程： 

1、A将本地内存变量刷新到主内存 

2、B从主内存中读取变量 

* **八种同步操作**

![basic_11](%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.resource/basic_11.png)

1、lock（锁定）：作用于主内存的变量，把一个变量标识变为一条线程独占状态

2、unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定

3、read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用

4、load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入**工作内存的变量副本**中

5、use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎

6、assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接受到的值**赋值给工作内存的变量**

7、store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，
以便随后的write的操作

8、write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中



![image-20200122161059103](%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.resource/image-20200122161059103.png)

* **同步规则**

1、如果要把一个变量从主内存中赋值到工作内存，就需要按顺序得执行read和load操作，
如果把变量从工作内存中同步回主内存中，就要按顺序得执行store和write操作，
但java内存模型只要求上述操作必须按顺序执行，没有保证必须是连续执行。

2、不允许read和load、store和write操作之一单独出现。

3、不允许一个线程丢弃他的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。

4、不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步到主内存中。

5、一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。
即就是对一个变量实施use和store操作之前，必须先执行过了load和assign操作。

6、一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以同时被一条线程重复执行多次，
多次执行lock后，只有执行相同次数的unlock操作，变量才会解锁，lock和unlock必须成对出现。

7、如果一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎中使用这个变量前需要重新执行load或assign操作初始化变量的值。

8、如果一个变量事先没有被lock操作锁定，则不允许他执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。

9、对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

## 三、并发的优势和风险

优势：

* 1、速度：同时处理多个请求，响应更快；复杂的操作可以分为多个进程同时进行

* 2、设计：程序设计在某些情况下更简单，也可以更多的选择

* 3、资源利用：CPU能够在等待IO的时候，做一些其他的事情

风险：

* 1、安全性：多个线程共享数据时可能会产生与且期望不相符的结果

* 2、活跃性：某个操作无法继续进行下去时，就会发生活跃性问题。比如死锁、饥饿等问题。

* 3、性能：线程过多时会使CPU频繁切换，调度时间增多；同步机制；消耗过多内存
