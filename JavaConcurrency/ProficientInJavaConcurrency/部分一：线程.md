

# 线程

[TOC]



## 一、从 Thread 类与 Runnable 接口开始

### （一）两者关系

首先 Thread 类是实现了 Runnable 接口 `public class Thread implements Runnable {`

### （二）Thread 类分析

**下面为完整的 Thread 类的 JavaDoc 文档**

> 一个 Thread 是程序的一个执行线程，Java虚拟机允许应用程序同时运行多个执行线程。
>
> 每个线程都有一个优先级，优先级较高的线程优先于优先级较低的线程执行。每个线程也可以标记为守护进程，也可以不标记为守护进程。当在某个线程中运行的代码创建一个新的 Thread 对象时，新线程的优先级最初设置为等于创建线程的优先级（即如果在一个线程中创建另一个线程，则被创建线程初始优先级和创建它的线程优先级相同），并且仅当创建线程是守护进程时被创建的线程才是守护进程线程。
>
> 当Java虚拟机启动时，通常只有一个非守护进程线程（它通常调用某些指定类的名为 main 的方法，所以 main 方法是执行在线程上的）。Java虚拟机会继续执行线程，直到发生以下任一情况：
>
> - 类 Runtime 的 exit 方法被调用，并且类安全管理器允许退出操作发送；
>
>     - 不是守护进程线程的所有线程都已死亡，消亡原因可能是调用 run 方法返回了，或者抛出了超过 run 方法范围的异常。
>
> 有两种方法可以创建一个新的执行线程，一种是将类声明为 Thread 类的子类。这个子类应该覆盖重写Thread 类的 run 方法。然后可以分配并启动子类的实例。例如，计算大于指定值的素数的线程可以如下编写：
>
> ```java
> class PrimeThread extends Thread {
>    long minPrime;
>    PrimeThread(long minPrime) {
>        this.minPrime = minPrime;
>    }
>    public void run() {
>        // compute primes larger than minPrime
>        ...
>    }
> }
> ```
>
> 然后通过如下代码可以创建一个线程然后开始运行
>
> ```java
> PrimeThread p = new PrimeThread(143);
> p.start();
> ```
>
> 创建线程的另一种方法是声明一个实现  Runnable 接口的类。然后，该类实现 run 方法。然后可以分配类的实例（即可以创建该类的实例），在创建 Thread 时将该实例对象作为参数传递，然后启动。其他样式中的相同示例如下所示：
>
> ```java
> class PrimeRun implements Runnable {
>     long minPrime;
>     PrimeRun(long minPrime) {
>         this.minPrime = minPrime;
>     }
> 
>     public void run() {
>         // compute primes larger than minPrime
>         ......
>     }
> }
> ```
>
> 然后创建线程对象，启动
>
> ```java
> PrimeRun p = new PrimeRun(143);
> new Thread(p).start();
> ```
>
> 每个线程都有一个用于标识的名称。多个线程可能具有相同的名称。如果在创建线程时未指定名称，则会为其生成新名称。
>

---

**在 Thread 类的代码中同样含有设置了线程优先级代码，代码如下：**

```java
/**
* The minimum priority that a thread can have.
*/
public final static int MIN_PRIORITY = 1;

/**
* The default priority that is assigned to a thread.
*/
public final static int NORM_PRIORITY = 5;

/**
* The maximum priority that a thread can have.
*/
public final static int MAX_PRIORITY = 10;
```

注意构造方法中的参数含义，start 方法、run 方法。



### （三）Runnable 接口（函数型接口）

**下面为 Runnable 接口的 JavaDoc 文档**

> `Runnable` 接口应该由其实例要由线程执行的任何类实现。类必须定义一个没有参数的 run 方法。
>
> 此接口旨在为希望在活动时执行代码的对象提供通用协议。例如，Thread 类实现了 Runnable 接口。
>
> **处于活动状态只意味着线程已启动但尚未停止**。
>
> 此外，`Runnable` 提供了一种方法，使类在不子类化 `Thread` 类的情况下处于活动状态。实现 Runnable 接口的类可以通过实例化 Thread 实例并将其自身作为目标传入而运行，而无需子类化 Thread 类。在大多数情况下，如果您只计划重写 run（）方法，而不打算重写其他 Thread 类的方法，则应使用  Runnable 接口。这一点很重要，因为除非程序员打算修改或增强类的基本行为，否则不应该对类进行子类化（即不应该继承）。

```java
package java.lang;

/*
 * @author  Arthur van Hoff
 * @see     java.lang.Thread
 * @see     java.util.concurrent.Callable
 * @since   JDK1.0
 */
@FunctionalInterface
public interface Runnable {
    /**
    // 当实现 Runnable 接口的对象被用于创建一个线程的时候，启动该线程的时候会导致该对象的 run 方法在独立执行的线程中被调用。
     * When an object implementing interface <code>Runnable</code> is used
     * to create a thread, starting the thread causes the object's
     * <code>run</code> method to be called in that separately executing
     * thread.
     * <p>
     * The general contract of the method <code>run</code> is that it may
     * take any action whatsoever.
     *
     * @see     java.lang.Thread#run()
     */
    public abstract void run();
}

```



## 二、wait 和 sleep 方法字节码分析

### （一）Object 类中的关于线程的方法

主要包括 wait（） 、notify 、notifyAll 方法

```java
/*
 * Copyright (c) 1994, 2012, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

package java.lang;

/**
 * Class {@code Object} is the root of the class hierarchy.
 * Every class has {@code Object} as a superclass. All objects,
 * including arrays, implement the methods of this class.
 *
 * @author  unascribed
 * @see     java.lang.Class
 * @since   JDK1.0
 */
public class Object {

    public final native void notify();

    public final native void notifyAll();
   
    public final native void wait(long timeout) throws InterruptedException;
   
    public final void wait(long timeout, int nanos) throws InterruptedException {
        if (timeout < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (nanos < 0 || nanos > 999999) {
            throw new IllegalArgumentException(
                                "nanosecond timeout value out of range");
        }

        if (nanos >= 500000 || (nanos != 0 && timeout == 0)) {
            timeout++;
        }

        wait(timeout);
    }
}    
```
### （二）wait 方法详解

**wait 方法的 JavaDoc**，这里是针对无参数的 wait() 方法：

> 会使当前线程等待，直到另一个线程调用此对象的 `java.lang.Object.notify()` 方法或`java.lang.Object.notifyAll()` 方法。（因此 wait 和 notify或者 notifyall 方法总是成对出现的，wait 会使当前线程出现等待，直到另一个线程调用了当前这个对象的 notify 或者 notifyAll 方法才会使当前线程被唤醒）
>
> 换句话说，这个方法的行为就像它只是执行调用 wait（0）(因为 wait() 里面的参数为超时时间，如果不写或者是 wait(0) 就是一直等待)。
>
> 当前线程必须拥有此对象的监视器（通常就是指锁）。（当这个线程调用了 wait 方法之后）线程释放此监视器的所有权并等待，直到另一个线程通过调用 `notify` 方法或 `notifyAll` 方法通知等待此对象监视器唤醒的线程。然后线程还需等待，直到它可以重新获得监视器的所有权并继续执行。

上面总结：

  - 如果想调用 wait 方法，当前线程必须拥有这个对象的锁
  - 一旦调用 wait 方法之后，调用该方法的线程就会释放被他所调用的对象的锁，然后进入等待状态。
   - 一直等待到另外的线程去通知在这个对象的锁上面等待的所有的线程（因为有可能一个对象，有多个线程都调用了这个对象的 wait 方法，这样多个线程都会陷入等待的状态）

> 在单参数版本中，中断和虚假唤醒是可能的，此方法应始终在循环中使用：
>
> ```java
> synchronized (obj) {
>     while (<条件尚未满足>)
>         obj.wait();
>      ...//Perform action appropriate to condition
> } 
> ```
>
> **此方法只能由作为此对象监视器所有者的线程调用**。请参阅 notify方法，以了解线程成为监视器所有者的方式（线程如何获取对象的锁见 notify 方法）。

```java
/* @throws  IllegalMonitorStateException  if the current thread is not
     *               the owner of the object's monitor.
     * @throws  InterruptedException if any thread interrupted the
     *             current thread before or while the current thread
     *             was waiting for a notification.  The <i>interrupted
     *             status</i> of the current thread is cleared when
     *             this exception is thrown.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#notifyAll()
     */
public final void wait() throws InterruptedException {
    wait(0);
}
```
----

【针对上面的 wait 方法】所以当前线程必须持有对象的锁才能调用 wait 方法，而且一旦调用 wait 方法之后就会将调用了 wait 对象的锁释放掉。同时线程还有一个 sleep 方法（Thread 类中）。

### （三）Thread 类的 sleep 方法详解

从下面Thread 类的 sleep 方法对应的 JavaDoc 可以看出 sleep 会一直持有该对象的锁，不会释放掉。

> 会导致当前正在执行的线程进入休眠状态（临时的停止执行一段特定时间的毫秒数），它会受到系统定时器和调度器的精度的影响。线程并不会失去任何锁的所有权。

```java
/* @param  millis
     *         the length of time to sleep in milliseconds
     *
     * @throws  IllegalArgumentException
     *          if the value of {@code millis} is negative
     *
     * @throws  InterruptedException
     *          if any thread has interrupted the current thread. The
     *          <i>interrupted status</i> of the current thread is
     *          cleared when this exception is thrown.
     */
public static native void sleep(long millis) throws InterruptedException;
```



测试代码为：

```java
package com.gjxaiou;

/**
 * @Author GJXAIOU
 * @Date 2020/2/14 11:23
 */

/**
 * 在调用 wait 方法时，线程必须要持有被调用对象的锁，当调用 wait 方法后，线程就会释放掉该对象的锁
 * 在调用 Thread 类的 sleep 方法时候，线程是不会释放掉对象的锁的。
 */
public class MyTest1 {
    public static void main(String[] args) throws InterruptedException {

        Object object = new Object();
        // 测试：线程必须用于对象的锁才能调用 wait 方法，如果直接调用会报错
        // Exception in thread "main" java.lang.IllegalMonitorStateException
        // 即当前的线程一定要持有调用 wait 对象（这里是 object 对象）的锁才可以
        // 解决方法：可以将调用 wait 方法放入 synchronized 同步代码块，因为进入代码块中就相当于获取到对象的锁了
        // object.wait();
        synchronized (object) {
            // 进入代码块相当于已经获取到 object 对象的锁
            object.wait();
        }
    }
}

```

对编译之后的 MyTest1.class 进行反编译之后得到（下面仅仅为 main 方法中反编译结果）

```java
 public static void main(java.lang.String[]) throws java.lang.InterruptedException;
    Code:
       0: new           #2                  // class java/lang/Object
       3: dup
       4: invokespecial #1                  // Method java/lang/Object."<init>":()V
       7: astore_1
       8: aload_1
       9: dup
      10: astore_2
      11: monitorenter // 注：当执行 synchronized 代码块，一旦进入对应的字节码指令为 monitorenter
      12: aload_1
      13: invokevirtual #3                  // Method java/lang/Object.wait:()V
      16: aload_2
      17: monitorexit // 注：从 synchronized 代码块正常或非正常退出都对应着 monitorexit 指令
      18: goto          26
      21: astore_3
      22: aload_2
      23: monitorexit // 这是异常的退出对应的 monitoexit 指令
      24: aload_3
      25: athrow
      26: return

```



## 三、notify 方法详解以及线程获取锁的方式

上面分析的是不带参数的 wait 方法，该方法实际实际上是调用了带参数的 wait 方法（见下），传入的是参数 0，接下来分析带参数的 wait 方法

```java
  public final void wait() throws InterruptedException {
        wait(0);
    }
```

带参数 wait 方法分析（下面即为 wait 方法的 JavaDoc ）

-----

> 使当前线程等待，直到另一个线程调用此对象的 notify（）方法或 notifyAll（）方法，或者指定的时间已过。
> 当前线程必须拥有此对象的监视器（锁）。
>
> 此方法会导致当前线程（称为 T 线程）将自身放置在此对象的等待集合中，然后放弃此对象上的任何和所有同步声明（即是释放锁）。线程 T 出于线程调度目的被禁用，并处于休眠状态，直到发生以下四种情况之一：
>
> - 其他一些线程调用了此对象的 notify 方法，而线程 T 恰好被任意选择为要唤醒的线程（从等待集合中选择一个）。
> - 其他一些线程为此对象调用 notifyAll 方法。
> - 其他一些线程中断了线程 T 。
> - 指定的时间或多或少已经过去。但是，如果参数 timeout 为零，则不考虑实时性，线程只需等待通知。
>
> 然后从该对象的等待集合删除线程 T （因为已经被唤醒了），并重新启用线程调度。然后，它以通常的方式与其他线程去竞争对象上的同步权；一旦它获得了对象的控制权（可以对这个对象同步了），它对对象的所有同步声明都将恢复到原来的状态，也就是说，恢复到调用 wait 方法时的所处的状态。然后线程 T 从 wait方法的调用中返回。因此，从 wait 方法返回时，对象和线程 T 的同步状态与调用 wait 方法时完全相同。
>
> 线程也可以在不被通知、中断或超时的情况下唤醒，即所谓的“虚假唤醒”。虽然这种情况在实践中很少发生，但应用程序必须通过测试本应导致线程被唤醒的条件，并在条件不满足时继续等待来防范这种情况。换句话说，等待应该总是以循环的形式出现，如下所示
>
> ```java
> // 对 obj 对象同步和上锁
> synchronized (obj) {
>     while (<condition does not hold>)
>     // 当另一个线程调用 obj 的 notify 方法的时候，正好当前线程就是被唤醒的线程的话，就会从这里唤醒然后执行一系列操作，然后再次判断
>        obj.wait(timeout);
>        ... // Perform action appropriate to condition
> }
> ```
>
> 如果当前线程在等待之前或等待期间被任何线程中断，则抛出一个 InterruptedException。在还原此对象的锁定状态（如上所述）之前，不会引发此异常。
>
> 注意，wait 方法在将当前线程放入此对象的等待集合中时，只解锁此对象；在线程等待期间，当前线程可能同步的任何其他对象都将保持锁定状态（因为一个线程在执行的时候可能同时调用几个对象的 wait 方法，但是某个时刻通过 notify 方法唤醒线程之后，但是其他对象还保持锁定）。
>
> 此方法只能由作为此对象监视器所有者的线程调用。查看 notify 方法，了解线程成为监视器所有者的方式

----

```java

/*
     * @param      timeout   the maximum time to wait in milliseconds.// 超时时间，如果为 0 表示一直等待。
     * @throws  IllegalArgumentException      if the value of timeout is
     *               negative.
     * @throws  IllegalMonitorStateException  if the current thread is not
     *               the owner of the object's monitor.
     * @throws  InterruptedException if any thread interrupted the
     *             current thread before or while the current thread
     *             was waiting for a notification.  The <i>interrupted
     *             status</i> of the current thread is cleared when
     *             this exception is thrown.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#notifyAll()
     */
public final native void wait(long timeout) throws InterruptedException;
```

另一个 wait 方法和上面 wait 一样，只不多加了一个设置纳秒的参数，可以实现更加精确的时间，可以从下面代码中看出最后还是调用了上面的一个参数的 wait 方法；

```java
// 这里的 JavaDoc 和上面相似，只是多了 nanos 说明以及使用方式
public final void wait(long timeout, int nanos) throws InterruptedException {
    if (timeout < 0) {
        throw new IllegalArgumentException("timeout value is negative");
    }

    if (nanos < 0 || nanos > 999999) {
        throw new IllegalArgumentException(
            "nanosecond timeout value out of range");
    }

    if (nanos >= 500000 || (nanos != 0 && timeout == 0)) {
        timeout++;
    }

    wait(timeout);
}
```



因为 wait 方法总是和 notify 或者 notifyAll 方法成对出现，所以在此进行分析（下面为 notify 方法的 JavaDoc）

---

> 唤醒等待此对象锁的单个线程。如果有任何（多个）线程正在等待这个对象（的锁），则选择其中一个等待的线程被唤醒。选择是任意的，由实现者自行决定。线程通过调用 wait 方法中的一个（因为有多个 wait）来等待对象的监视器。
>
> 在当前线程放弃对该对象的锁定之前，唤醒的线程将无法继续（执行）。唤醒的线程将以通常的方式与任何其他线程竞争，这些线程竞争在此对象上的同步；例如，唤醒的线程在成为下一个锁定此对象的线程时没有可靠的特权或劣势（和其它线程地位相同）。
>
> 此方法只能由作为此对象监视器所有者的线程调用（即调用了 notify 方法的线程一定是持有当前对象锁的线程）。线程通过以下三种方式之一成为对象锁的持有者：
>
> - 通过执行该对象的同步实例方法（即被标记为 Synchronized 的实例方法）。
> - 通过执行在对象上同步的{@code synchronized}语句的主体（即执行 synchronized 的语句块）。
> - 对于 class 类型的对象，通过执行该类的同步静态方法(即被标记为 Synchronized 的静态方法)
>     在某一时刻只有一个线程可以拥有该对象的锁的。

----

```java
/*
 * @throws  IllegalMonitorStateException  if the current thread is not
 *               the owner of this object's monitor.
 * @see        java.lang.Object#notifyAll()
 * @see        java.lang.Object#wait()
 */
public final native void notify();
```



### wait 和 notify 方法与线程同步系统总结

首先是介绍 notifyAll 方法的 JavaDoc

>唤醒此对象监视器上等待的所有线程。线程通过调用 wait 方法之一来等待对象的监视器。
>
>在当前线程放弃对该对象的锁定之前，唤醒的线程将无法继续。唤醒的线程将以通常的方式与任何其他线程竞争，这些线程可能正在积极竞争以在此对象上同步；例如，唤醒的线程在成为下一个锁定此对象的线程时没有可靠的特权或劣势。
>
>此方法只能由作为此对象监视器所有者的线程调用。请参阅{@code notify}方法，以了解线程成为监视器所有者的方式。

```java

   /**
     * @throws  IllegalMonitorStateException  if the current thread is not
     *               the owner of this object's monitor.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#wait()
     */
public final native void notifyAll();
```





在调用 wait 方法时候，线程必须要持有被调用对象的锁，当调用 wait 方法之后，线程就会释放掉该对象的锁（monitor）。

在调用 Thread 类的 sleep 方法时候，线程是不会释放掉对象的锁的。

关于 wait 和 notify 和 notifyAll 方法的总结：

- 当调用 wait 方法时，首先需要确保**调用的 wait 方法的线程已经持有了对象的锁**；
- 当调用 wait 方法后，该线程就会释放掉这个对象的锁，然后进入到等待状态（或者成为等待集合：wait set)；
- 当线程调用了 wait 之后进入到等待状态时候，它就可以等待其他线程调用相同对象的 notify 或 notifyAll 方法来使得自己被唤醒；
- 一旦这个线程被其他线程唤醒之后，该线程就会与其他线程一同开始竞争这个对象的锁（公平竞争）；**只有当该线程获取到了这个对象的锁之后**，代码才会继续向下执行，没有获取到则继续等待。
- 调用 wait 方法的代码片段需要放在一个 synchronized 块或者是 synchronized 方法中，这样才可以确保线程在调用 wait 方法前已经获取到了对象的锁。
- 当调用对象的 notify 方法时，它会随机唤醒该对象等待集合（wait set) 中的任意一个线程，当某个线程被唤醒之后，他就会与其他线程一同竞争对象的锁。
- 当调用对象的 notifyAll 方法时候，他就会唤醒该对象等待集合（wait set) 中的所有线程，这些线程被唤醒之后，又会开始竞争对象的锁；
- 在某一个时刻，只有唯一一个线程可以拥有对象的锁。



**关于 synchronized 题目**

```java
public class Test{
    public synchronized void method1(){
    }
    
    public synchronized void method2(){
    }
}
// 当创建 Test 的唯一一个实例（对象）
Test test = new Test():
// 当一个线程执行这个对象的 method1 时候（还没有执行完），其他线程能不能执行该对象的 method2

```

不能，因为对于同一个对象来说，它的所有 synchronize 方法锁的对象是同一个东西，当一个线程正在执行其中的一个 synchronized 方法的时候，其他线程执行不了其他方法的，因为该 synchronized 方法已经被该线程进去了，已经获取该对象的锁了。

如果创建了两个对象就可以了，因为一个线程获取一个对象的锁并不妨碍另一个线程获取另一个对象的锁。

- 代码修改：

    ```java
    public class Test{
        public synchronized void method1(){
        }
        
        public static synchronized void method2(){
        }
    }
    // 当创建 Test 的唯一一个实例（对象）
    Test test = new Test():
    // 当一个线程执行这个对象的 method1 时候（还没有执行完），其他线程能不能执行该对象的 method2
    ```

    可以，因为第一个方法的 synchronized 关键字锁的是当前的  test 对象，而第二个 方法的synchronized 关键字锁的是当前 test 对象所对应的 Class 对象（因为本质上一个静态方法并不属于当前对象，属于当前对象所对应的 Class 对象），是两个独立的对象，两个对立的对象拥有各自独立的锁。

### wait 和 notify 方法案例剖析和详解

编写一个多线程程序，实现目标：

- 存在一个对象，该对象（即对象对应的类中）存在一个 int 类型的成员变量 counter，该成员变量的初始值为 0；
- 创建两个线程，其中一个线程对该对象的成员变量 counter 增1，另一个线程对该对象的成员变量减一；
- 输出该对象成员变量 counter 每次变化后的值；
- 最终输出的结果应该为：1010101010…



**分析**

- 需要两个线程，因为操作不同，所以需要两个线程类；

首先构造 MyObject 类

```java
package com.gjxaiou;

/**
 * @Author GJXAIOU
 * @Date 2020/2/15 10:51
 */
public class MyObject {
    private int counter;

    // 分别实现递增、递减方法，因为要调用 wait 方法，所以需要使用 synchronized
    public synchronized void increase() {
        // 进入 increase 方法之后，如果 counter 不为 0，则该线程等待
        while (counter != 0) {
            try {
                // 调用 wait 使得释放掉 counter 的锁，使得递减的线程拿到锁
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // 当另一个线程执行完递减之后，调用 notify 方法让递增线程唤醒了
        counter++;
        System.out.println(counter);
        // 通知其它线程起来（这里就是指递减的线程）
        notify();
    }

    // 下面的解释同上
    public synchronized void decrease() {
        while (counter == 0) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        counter--;
        System.out.println(counter);
        notify();
    }
}
```

然后分别实现递增和递减两个线程类

```java
package com.gjxaiou;

/**
 * @Author GJXAIOU
 * @Date 2020/2/15 11:18
 */
public class IncreaseThread extends Thread {
    private MyObject myObject;

    public IncreaseThread(MyObject myObject) {
        this.myObject = myObject;
    }

    // 重写 run 方法

    @Override
    public void run() {
        for (int i = 0; i < 30; i++) {
            // 每次先让线程休眠 0 ~ 1 秒
            try {
                Thread.sleep((long) (Math.random() * 1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            myObject.increase();
        }
    }
}

```

```java
package com.gjxaiou;

/**
 * @Author GJXAIOU
 * @Date 2020/2/15 11:24
 */
public class DecreaseThread extends Thread {
    private MyObject myObject;

    public DecreaseThread(MyObject myObject) {
        this.myObject = myObject;
    }

    // 重写 run 方法
    @Override
    public void run() {
        for (int i = 0; i < 30; i++) {
            // 每次先让线程休眠 0 ~ 1 秒
            try {
                Thread.sleep((long) (Math.random() * 1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            myObject.decrease();
        }
    }
}

```

最后在 main 方法中创建分别创建一个递增和递减线程，然后执行程序

```java
package com.gjxaiou;

/**
 * @Author GJXAIOU
 * @Date 2020/2/15 11:26
 */
public class Client {
    public static void main(String[] args) {
        // 只能创建一个对象，因为锁是加在对象上，如果两个线程操作两个对象就没有意义了MyObject myObject = new MyObject();
        MyObject myObject = new MyObject();
        Thread increaseThread = new IncreaseThread(myObject);
        Thread decreaseThread = new DecreaseThread(myObject);
        increaseThread.start();
        decreaseThread.start();
    }
}
```

程序运行结果：（这里选取前十结果）

```java
1
0
1
0
1
0
1
0
1
0
```



## 二、synchronized 关键字原理详解

```java
package com.gjxaiou;

/**
 * @Author GJXAIOU
 * @Date 2020/2/15 15:16
 */
public class MyThreadTest {
    public static void main(String[] args) {
        Runnable thread = new MyThread();
        // 因为创建线程 thread1 和 thread2 时候传入的是同一个 Runnable 实例对象
        Thread thread1 = new Thread(thread);
        Thread thread2 = new Thread(thread);
        // 因此当两个线程启动 start 方法时候都会去执行同一个 MyThread 对象里面的 run 方法
        thread1.start();
        thread2.start();
    }
}

// 该线程类实现了 Runnable 接口
class MyThread implements Runnable {
    int x;

    public void run() {
        x = 0;
        while (true) {
            System.out.println("result:" + x++);

            try {
                Thread.sleep((long) (Math.random() * 1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            if (x == 30) {
                break;
            }
        }
    }
}
```



程序执行结果：

```java
result:0
result:0
result:1
result:2
result:3
result:4
result:5
result:6
result:7
result:8
result:9
result:10
result:11
result:12
result:13
result:14
result:15
result:16
result:17
result:18
result:19
result:20
result:21
result:22
result:23
result:24
result:25
result:26
result:27
result:28
result:29

Process finished with exit code 0

```

通过下面一个小的框架示例来说明上面程序

```java
// struts2
public class LoginAction{
    private String username;
    private String password;
}
```

这两个成员变量分别对应着用户请求表单中对应的两个参数。参数的信息是以成员变量的形式放置到类中的，但是成员变量可能会被多线程修改的。所以 Struts 的 LoginAction 就是一个多实例的，就是用户每一次访问登录都会创建一个新的实例。这样只有一个线程会访问到同一个实例。

```java
public class LoginController{
	public void login(String username, String password){
	}
}
```

在 SpringMVC 中，当用户登录的时候，表单中的信息就会映射到方法的两个参数中，而对于一个方法而言，无论方法的参数还是方法内部代码声明的变量，都是局部变量。而局部变量是归一个线程所独有。所以在 Controller 中一般不会定义可以被修改的成员变量。一般都是放置只读的或者无状态的变量。



- 测试示例二：

    ```java
    package com.gjxaiou;
    
    /**
     * @Author GJXAIOU
     * @Date 2020/2/15 16:00
     */
    public class MyThreadTest2 {
        public static void main(String[] args) {
            // 使用此种方式输出为：hello,world
            MyClass myClass = new MyClass();
            Thread1 thread1 = new Thread1(myClass);
            Thread2 thread2 = new Thread2(myClass);
    
            // 测试方式二：
            // 如果使用以下代码代替上面代码，结果为 ：world,hello
    //        MyClass myClass = new MyClass();
    //        MyClass myClass1 = new MyClass();
    //        Thread1 thread1 = new Thread1(myClass);
    //        Thread2 thread2 = new Thread2(myClass1);
    
            thread1.start();
            // 休眠一段时间
            try {
                Thread.sleep(700);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            thread2.start();
        }
    }
    
    class MyClass {
        public synchronized void hello() {
            // thread1 首先进入 hello 方法，即是下面休眠了，但是不会释放对 myClass 对象的锁
            // 所以即是上面主线程在 700 毫秒之后恢复了，接着 thread2 启动，然后访问 world 方法，因为这时候 myClass 对象的锁还在 thread1 中，所以不能访问。
            try {
                Thread.sleep(4000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("hello");
        }
    
        public synchronized void world() {
            System.out.println("world");
        }
    }
    
    // 定义两个线程类
    class Thread1 extends Thread {
        private MyClass myClass;
    
        public Thread1(MyClass myClass) {
            this.myClass = myClass;
        }
    
        @Override
        public void run() {
            myClass.hello();
        }
    }
    
    class Thread2 extends Thread {
        private MyClass myClass;
    
        public Thread2(MyClass myClass) {
            
            
            this.myClass = myClass;
        }
    
        @Override
        public void run() {
            myClass.world();
        }
    }
    ```

如果一个对象中含有若干个 synchronized 方法，那么在某一个时刻只能有唯一的线程进入到其中一个 synchronized 方法。其他线程即使想访问其他 synchronized 方法也要等待。因为当一个线程想要访问其中一个 synchronized 方法的时候，要尝试着获取当前对象的锁（而当前对象只有唯一的一把锁）。



### 透过字节码理解 synchronized 关键字

- synchronized 关键字一般用于修饰一个方法或者修饰一个代码块

    - 修饰方法

        方法可以是静态或者非静态的，如果是修饰实例方法（不加 static 关键字），当线程去访问的该方法的时候，是给当前对象上锁。如果是修饰静态方法，线程访问该方法的的时候是给该对象对应的类的 Class 对象上锁。

    - 修饰代码块：

        synchronized 关键字 后面会跟上一个对象的名字（引用的名字），加上具体执行的代码逻辑。



**总结**：当我们使用 synchronized 关键字来修饰代码块时候，字节码层面上是通过 monitorenter 和 monitorexit 指令来实现锁的获取与释放动作。

当线程进入到 monitorenter 指令后，线程将会持有被同步的对象（就是 synchronized 关键值后面括号中的对象）的 monitor 对象，当退出 monitorenter 指令之后（即执行 monitorexit 指令），线程将会释放该 monitor 对象。

#### 1. synchronized 关键字修饰代码块

**测试程序**

```java
package com.gjxaiou.synchronize;

/**
 * 测试 synchronized 用法
 *
 * @Author GJXAIOU
 * @Date 2020/2/16 21:51
 */
public class MyTest1 {
    // 同步代码块（因为一个方法中可能只有几行需要上锁，所以关键字即可）
    private Object object = new Object();

    public void method() {
        // 表示对 object 对象上锁，当执行到这里的时候该线程会尝试获取 object 对象的锁，如果获取到就就行执行，如果获取不到就阻塞了。
        synchronized (object) {
            System.out.println("hello world");
        }
    }
}
```

**反编译之后的结果** 更加具体的反编译：包括常量池信息

```java
E:\Program\Java\Project\JavaConcurrency\ProficientInJavaConcurrency\target\classes\com\gjxai
ou\synchronize>javap -v MyTest1.class
Classfile /E:/Program/Java/Project/JavaConcurrency/ProficientInJavaConcurrency/target/classe
s/com/gjxaiou/synchronize/MyTest1.class
  Last modified 2020-2-16; size 624 bytes
  MD5 checksum 1f26b481eb5d16a1179ccfb6138ef19e
  Compiled from "MyTest1.java"
public class com.gjxaiou.synchronize.MyTest1
  minor version: 0
  major version: 49
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #2.#20         // java/lang/Object."<init>":()V
   #2 = Class              #21            // java/lang/Object
   #3 = Fieldref           #7.#22         // com/gjxaiou/synchronize/MyTest1.object:Ljava/la
ng/Object;
   #4 = Fieldref           #23.#24        // java/lang/System.out:Ljava/io/PrintStream;
   #5 = String             #25            // hello world
   #6 = Methodref          #26.#27        // java/io/PrintStream.println:(Ljava/lang/String;
)V
   #7 = Class              #28            // com/gjxaiou/synchronize/MyTest1
   #8 = Utf8               object
   #9 = Utf8               Ljava/lang/Object;
  #10 = Utf8               <init>
  #11 = Utf8               ()V
  #12 = Utf8               Code
  #13 = Utf8               LineNumberTable
  #14 = Utf8               LocalVariableTable
  #15 = Utf8               this
  #16 = Utf8               Lcom/gjxaiou/synchronize/MyTest1;
  #17 = Utf8               method
  #18 = Utf8               SourceFile
  #19 = Utf8               MyTest1.java
  #20 = NameAndType        #10:#11        // "<init>":()V
  #21 = Utf8               java/lang/Object
  #22 = NameAndType        #8:#9          // object:Ljava/lang/Object;
  #23 = Class              #29            // java/lang/System
  #24 = NameAndType        #30:#31        // out:Ljava/io/PrintStream;
  #25 = Utf8               hello world
  #26 = Class              #32            // java/io/PrintStream
  #27 = NameAndType        #33:#34        // println:(Ljava/lang/String;)V
  #28 = Utf8               com/gjxaiou/synchronize/MyTest1
  #29 = Utf8               java/lang/System
  #30 = Utf8               out
  #31 = Utf8               Ljava/io/PrintStream;
  #32 = Utf8               java/io/PrintStream
  #33 = Utf8               println
  #34 = Utf8               (Ljava/lang/String;)V
{
     // 编译器自动生成的构造方法
  public com.gjxaiou.synchronize.MyTest1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: new           #2                  // class java/lang/Object
         8: dup
         9: invokespecial #1                  // Method java/lang/Object."<init>":()V
        12: putfield      #3                  // Field object:Ljava/lang/Object;
        15: return
      LineNumberTable:
        line 9: 0
        line 11: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      16     0  this   Lcom/gjxaiou/synchronize/MyTest1;

  public void method();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1 // 最大栈深度、局部变量表的数量和参数的数量（因为 Java 中任何实例方法的第一个参数都是 this(不是在定义或者声明该方法的时候显式指定的，而是编译器在程序编译完成之后动态传入的)，所以我们可以在方法中使用 this 关键字来引用当前对象的成员变量或者其他方法）
         0: aload_0
         1: getfield      #3                  // Field object:Ljava/lang/Object; // 表示获取当前对象的成员变量（因为 synchronized 要对 object 对象进行同步，所以要先获取该对象） 
         4: dup
         5: astore_1
         6: monitorenter  // 执行完该行助记符之后就进入了同步方法里面了
         7: getstatic     #4   // Field java/lang/System.out:Ljava/io/PrintStream;
             // 首先要获取到 system.out 对象（该对象实际为一个 System 类中的静态变量，点进去看看，类型是 java.lang.PrintStream）
        10: ldc           #5                  // String hello world
        12: invokevirtual #6// Method java/io/PrintStream.println:(Ljava/lang /String;)V  // 调用了 out 对象中的 println 方法
        15: aload_1
        16: monitorexit  // 锁退出(正常退出）
        17: goto          25
        20: astore_2
        21: aload_1
        22: monitorexit  // 出现异常时候退出，保证该线程无论十分情况下都可以释放掉该对象的锁
        23: aload_2
        24: athrow
        25: return
      Exception table:
         from    to  target type
             7    17    20   any
            20    23    20   any
      LineNumberTable:
        line 15: 0
        line 16: 7
        line 17: 15
        line 18: 25
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      26     0  this   Lcom/gjxaiou/synchronize/MyTest1;
}
SourceFile: "MyTest1.java"
```

**示例修改**

```java
package com.gjxaiou.synchronize;

/**
 * 测试 synchronized 用法
 *
 * @Author GJXAIOU
 * @Date 2020/2/16 21:51
 */
public class MyTest1 {
    // 同步代码块（因为一个方法中可能只有几行需要上锁，所以关键字即可）
    private Object object = new Object();

    public void method() {
        // 表示对 object 对象上锁，当执行到这里的时候该线程会尝试获取 object 对象的锁，如果获取到就就行执行，如果获取不到就阻塞了。
        synchronized (object) {
            System.out.println("hello world");
        }
    }

    public void method2(){
        synchronized (object){
            System.out.println("welcome");
        }
    }
}

```

反编译之后的结果为：

```java
E:\Program\Java\Project\JavaConcurrency\ProficientInJavaConcurrency\target\classes\c
om\gjxaiou\synchronize>javap -v MyTest1.class
Classfile /E:/Program/Java/Project/JavaConcurrency/ProficientInJavaConcurrency/targe
t/classes/com/gjxaiou/synchronize/MyTest1.class
  Last modified 2020-2-17; size 757 bytes
  MD5 checksum 2908e6ef3bf3551cae84950f5a1bf947
  Compiled from "MyTest1.java"
public class com.gjxaiou.synchronize.MyTest1
  minor version: 0
  major version: 49
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #2.#22         // java/lang/Object."<init>":()V
   #2 = Class              #23            // java/lang/Object
   #3 = Fieldref           #8.#24         // com/gjxaiou/synchronize/MyTest1.object:
Ljava/lang/Object;
   #4 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStre
am;
   #5 = String             #27            // hello world
   #6 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljava/lang
/String;)V
   #7 = String             #30            // welcome
   #8 = Class              #31            // com/gjxaiou/synchronize/MyTest1
   #9 = Utf8               object
  #10 = Utf8               Ljava/lang/Object;
  #11 = Utf8               <init>
  #12 = Utf8               ()V
  #13 = Utf8               Code
  #14 = Utf8               LineNumberTable
  #15 = Utf8               LocalVariableTable
  #16 = Utf8               this
  #17 = Utf8               Lcom/gjxaiou/synchronize/MyTest1;
  #18 = Utf8               method
  #19 = Utf8               method2
  #20 = Utf8               SourceFile
  #21 = Utf8               MyTest1.java
  #22 = NameAndType        #11:#12        // "<init>":()V
  #23 = Utf8               java/lang/Object
  #24 = NameAndType        #9:#10         // object:Ljava/lang/Object;
  #25 = Class              #32            // java/lang/System
  #26 = NameAndType        #33:#34        // out:Ljava/io/PrintStream;
  #27 = Utf8               hello world
  #28 = Class              #35            // java/io/PrintStream
  #29 = NameAndType        #36:#37        // println:(Ljava/lang/String;)V
  #30 = Utf8               welcome
  #31 = Utf8               com/gjxaiou/synchronize/MyTest1
  #32 = Utf8               java/lang/System
  #33 = Utf8               out
  #34 = Utf8               Ljava/io/PrintStream;
  #35 = Utf8               java/io/PrintStream
  #36 = Utf8               println
  #37 = Utf8               (Ljava/lang/String;)V
{
  public com.gjxaiou.synchronize.MyTest1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()
V
         4: aload_0
         5: new           #2                  // class java/lang/Object
         8: dup
         9: invokespecial #1                  // Method java/lang/Object."<init>":()
V
        12: putfield      #3                  // Field object:Ljava/lang/Object;
        15: return
      LineNumberTable:
        line 9: 0
        line 11: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      16     0  this   Lcom/gjxaiou/synchronize/MyTest1;

  public void method();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: getfield      #3                  // Field object:Ljava/lang/Object;
         4: dup
         5: astore_1
         6: monitorenter
         7: getstatic     #4                  // Field java/lang/System.out:Ljava/io
/PrintStream;
        10: ldc           #5                  // String hello world
        12: invokevirtual #6                  // Method java/io/PrintStream.println:
(Ljava/lang/String;)V
        15: aload_1
        16: monitorexit
        17: goto          25
        20: astore_2
        21: aload_1
        22: monitorexit
        23: aload_2
        24: athrow
        25: return
      Exception table:
         from    to  target type
             7    17    20   any
            20    23    20   any
      LineNumberTable:
        line 15: 0
        line 16: 7
        line 17: 15
        line 18: 25
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      26     0  this   Lcom/gjxaiou/synchronize/MyTest1;

  public void method2();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: getfield      #3                  // Field object:Ljava/lang/Object;
         4: dup
         5: astore_1
         6: monitorenter
         7: getstatic     #4                  // Field java/lang/System.out:Ljava/io
/PrintStream;
        10: ldc           #7                  // String welcome
        12: invokevirtual #6                  // Method java/io/PrintStream.println:
(Ljava/lang/String;)V
        15: aload_1
        16: monitorexit
        17: goto          25
        20: astore_2
        21: aload_1
        22: monitorexit
        23: aload_2
        24: athrow
        25: return
      Exception table:
         from    to  target type
             7    17    20   any
            20    23    20   any
      LineNumberTable:
        line 21: 0
        line 22: 7
        line 23: 15
        line 24: 25
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      26     0  this   Lcom/gjxaiou/synchronize/MyTest1;
}
SourceFile: "MyTest1.java"

```



**补充**在上面代码中增加了抛出异常，字节码对应几个 monitorenter  和 monitorexit

```java
package com.gjxaiou.synchronize;

/**
 * 测试 synchronized 用法
 *
 * @Author GJXAIOU
 * @Date 2020/2/16 21:51
 */
public class MyTest1 {
    // 同步代码块（因为一个方法中可能只有几行需要上锁，所以关键字即可）
    private Object object = new Object();

    public void method() {
        // 表示对 object 对象上锁，当执行到这里的时候该线程会尝试获取 object 对象的锁，如果获取到就就行执行，如果获取不到就阻塞了。
        synchronized (object) {
            System.out.println("hello world");
            throw new RuntimeException();
        }
    }

    public void method2(){
        synchronized (object){
            System.out.println("welcome");
        }
    }
}
 	
```



反编译之后结果为：

**method1 方法对应字节码**为什么只有一个 monitorexit，因为代码块中代码无论是 print 语句还是 throw 语句抛出异常，该代码块最后都是以异常结束的。最终异常抛出对应 27 行的 athrow 助记符（ 22 行的 athrow 对应于显式的 throw new runtimeXX 动作。

**method2 方法对应字节码**中仍然为两个 monitorexit，因为程序有可能正常结束，正常结束的时候程序就从 17 行 goto 到 25 行（跳过了中间异常退出）直接 return，如果要是抛出异常的话，会在想 22 行那样先释放锁，然后在 24 行抛出异常。

```java
E:\Program\Java\Project\JavaConcurrency\ProficientInJavaConcurrency\target\classes\com\gjxaiou\synchronize>javap -v MyTest1.class
Classfile /E:/Program/Java/Project/JavaConcurrency/ProficientInJavaConcurrency/target/classes/com/gjxaiou/synchronize/MyTest1.class
  Last modified 2020-2-17; size 788 bytes
  MD5 checksum b98e0d981195ca3814a94fc4872ecb95
  Compiled from "MyTest1.java"
public class com.gjxaiou.synchronize.MyTest1
  minor version: 0
  major version: 49
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #2.#24         // java/lang/Object."<init>":()V
   #2 = Class              #25            // java/lang/Object
   #3 = Fieldref           #10.#26        // com/gjxaiou/synchronize/MyTest1.object:Ljava/lang/Object;
   #4 = Fieldref           #27.#28        // java/lang/System.out:Ljava/io/PrintStream;
   #5 = String             #29            // hello world
   #6 = Methodref          #30.#31        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #7 = Class              #32            // java/lang/RuntimeException
   #8 = Methodref          #7.#24         // java/lang/RuntimeException."<init>":()V
   #9 = String             #33            // welcome
  #10 = Class              #34            // com/gjxaiou/synchronize/MyTest1
  #11 = Utf8               object
  #12 = Utf8               Ljava/lang/Object;
  #13 = Utf8               <init>
  #14 = Utf8               ()V
  #15 = Utf8               Code
  #16 = Utf8               LineNumberTable
  #17 = Utf8               LocalVariableTable
  #18 = Utf8               this
  #19 = Utf8               Lcom/gjxaiou/synchronize/MyTest1;
  #20 = Utf8               method
  #21 = Utf8               method2
  #22 = Utf8               SourceFile
  #23 = Utf8               MyTest1.java
  #24 = NameAndType        #13:#14        // "<init>":()V
  #25 = Utf8               java/lang/Object
  #26 = NameAndType        #11:#12        // object:Ljava/lang/Object;
  #27 = Class              #35            // java/lang/System
  #28 = NameAndType        #36:#37        // out:Ljava/io/PrintStream;
  #29 = Utf8               hello world
  #30 = Class              #38            // java/io/PrintStream
  #31 = NameAndType        #39:#40        // println:(Ljava/lang/String;)V
  #32 = Utf8               java/lang/RuntimeException
  #33 = Utf8               welcome
  #34 = Utf8               com/gjxaiou/synchronize/MyTest1
  #35 = Utf8               java/lang/System
  #36 = Utf8               out
  #37 = Utf8               Ljava/io/PrintStream;
  #38 = Utf8               java/io/PrintStream
  #39 = Utf8               println
  #40 = Utf8               (Ljava/lang/String;)V
{
  public com.gjxaiou.synchronize.MyTest1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: new           #2                  // class java/lang/Object
         8: dup
         9: invokespecial #1                  // Method java/lang/Object."<init>":()V
        12: putfield      #3                  // Field object:Ljava/lang/Object;
        15: return
      LineNumberTable:
        line 9: 0
        line 11: 4
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      16     0  this   Lcom/gjxaiou/synchronize/MyTest1;

  public void method();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: getfield      #3                  // Field object:Ljava/lang/Object;
         4: dup
         5: astore_1
         6: monitorenter
         7: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
        10: ldc           #5                  // String hello world
        12: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        15: new           #7                  // class java/lang/RuntimeException
        18: dup
        19: invokespecial #8  // 因为 new 出来一个 RuntimeException 实例，所以调用其的构造方法                // Method java/lang/RuntimeException."<init>":()V
        22: athrow
        23: astore_2
        24: aload_1
        25: monitorexit // 代码块执行结束释放锁
        26: aload_2
        27: athrow
      Exception table:
         from    to  target type
             7    26    23   any
      LineNumberTable:
        line 15: 0
        line 16: 7
        line 17: 15
        line 18: 23
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      28     0  this   Lcom/gjxaiou/synchronize/MyTest1;

  public void method2();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: getfield      #3                  // Field object:Ljava/lang/Object;
         4: dup
         5: astore_1
         6: monitorenter
         7: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
        10: ldc           #9                  // String welcome
        12: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        15: aload_1
        16: monitorexit
        17: goto          25
        20: astore_2
        21: aload_1
        22: monitorexit
        23: aload_2
        24: athrow
        25: return
      Exception table:
         from    to  target type
             7    17    20   any
            20    23    20   any
      LineNumberTable:
        line 22: 0
        line 23: 7
        line 24: 15
        line 25: 25
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      26     0  this   Lcom/gjxaiou/synchronize/MyTest1;
}
SourceFile: "MyTest1.java"
```

### 同步方法访问标志与 synchronized 关键字之间的关系

#### 2.synchronized 关键字修饰方法

**总结**：synchronized 关键字修饰方法的时候，并没有出现 monitorenter 和 monitorexit 指令，而是在 JVM 层面通过方法的标识（flags)来标识这个是否为一个同步方法。从字节码中可以看出对应于：`ACC_SYNCHRONIZED`，当线程去调用该方法的时候首先就会去检验该方法是否含有 `ACC_SYNCHRONIZED` 标志位，如果有的话会该执行线程尝试获取当前方法所在的对象的锁（即对象的 monitor 对象），获取到锁之后才会正常的执行方法体。在该方法执行期间，其他任何线程均无法再获取到这个 monitor 对象（锁），当线程执行完方法之后或者抛出异常，它会释放掉这个 monitor 对象。

测试代码

```java
package com.gjxaiou.synchronize;

/**
 * @Author GJXAIOU
 * @Date 2020/2/17 20:51
 */
public class MyTest2 {
    public synchronized void method() {
        System.out.println("hello world");
    }
}

```

对应反编译结果



```java
E:\Program\Java\Project\JavaConcurrency\ProficientInJavaConcurrency\target\classes\com\gjxai
ou\synchronize>javap -v MyTest2.class
Classfile /E:/Program/Java/Project/JavaConcurrency/ProficientInJavaConcurrency/target/classe
s/com/gjxaiou/synchronize/MyTest2.class
  Last modified 2020-2-17; size 520 bytes
  MD5 checksum e31ae67e69b765315b9facb2b3d2e48d
  Compiled from "MyTest2.java"
public class com.gjxaiou.synchronize.MyTest2
  minor version: 0
  major version: 49
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #6.#17         // java/lang/Object."<init>":()V
   #2 = Fieldref           #18.#19        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = String             #20            // hello world
   #4 = Methodref          #21.#22        // java/io/PrintStream.println:(Ljava/lang/String;
)V
   #5 = Class              #23            // com/gjxaiou/synchronize/MyTest2
   #6 = Class              #24            // java/lang/Object
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               LocalVariableTable
  #12 = Utf8               this
  #13 = Utf8               Lcom/gjxaiou/synchronize/MyTest2;
  #14 = Utf8               method
  #15 = Utf8               SourceFile
  #16 = Utf8               MyTest2.java
  #17 = NameAndType        #7:#8          // "<init>":()V
  #18 = Class              #25            // java/lang/System
  #19 = NameAndType        #26:#27        // out:Ljava/io/PrintStream;
  #20 = Utf8               hello world
  #21 = Class              #28            // java/io/PrintStream
  #22 = NameAndType        #29:#30        // println:(Ljava/lang/String;)V
  #23 = Utf8               com/gjxaiou/synchronize/MyTest2
  #24 = Utf8               java/lang/Object
  #25 = Utf8               java/lang/System
  #26 = Utf8               out
  #27 = Utf8               Ljava/io/PrintStream;
  #28 = Utf8               java/io/PrintStream
  #29 = Utf8               println
  #30 = Utf8               (Ljava/lang/String;)V
{
  public com.gjxaiou.synchronize.MyTest2();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 7: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/gjxaiou/synchronize/MyTest2;

  public synchronized void method();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=2, locals=1, args_size=1
      0: getstatic     #2    // Field java/lang/System.out:Ljava/io/PrintStream;
      3: ldc           #3                  // String hello world
      5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      8: return
     LineNumberTable:
        line 9: 0
        line 10: 8
     LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  this   Lcom/gjxaiou/synchronize/MyTest2;
}
SourceFile: "MyTest2.java"

```



#### 3. synchronized 关键字修饰静态方法

同样通过 ACC_SYNCHRONIZED，标识，

当线程去调用该方法的时候首先就会去检验该方法是否含有 `ACC_SYNCHRONIZED`  和 `ACC_STATIC`标志位，如果有的话会该执行线程尝试获取当前方法所在的类的对应 Class 对象的锁（即 Class 对象的 monitor 对象），获取到锁之后才会正常的执行方法体。在该方法执行期间，其他任何线程均无法再获取到这个 monitor 对象（锁），当线程执行完方法之后或者抛出异常，它会释放掉这个 monitor 对象。

测试程序

```java
package com.gjxaiou.synchronize;

/**
 * @Author GJXAIOU
 * @Date 2020/2/17 21:12
 */
public class MyTest3 {
    public static synchronized void method() {
        System.out.println("hello world");
    }
}

```

对应的字节码为：

```java
E:\Program\Java\Project\JavaConcurrency\ProficientInJavaConcurrency\target\classes\com\gjxai
ou\synchronize>javap -v MyTest3.class
Classfile /E:/Program/Java/Project/JavaConcurrency/ProficientInJavaConcurrency/target/classe
s/com/gjxaiou/synchronize/MyTest3.class
  Last modified 2020-2-17; size 502 bytes
  MD5 checksum 02b9ebc1b02bd60130e038ace131515a
  Compiled from "MyTest3.java"
public class com.gjxaiou.synchronize.MyTest3
  minor version: 0
  major version: 49
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #6.#17         // java/lang/Object."<init>":()V
   #2 = Fieldref           #18.#19        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = String             #20            // hello world
   #4 = Methodref          #21.#22        // java/io/PrintStream.println:(Ljava/lang/String;
)V
   #5 = Class              #23            // com/gjxaiou/synchronize/MyTest3
   #6 = Class              #24            // java/lang/Object
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               LocalVariableTable
  #12 = Utf8               this
  #13 = Utf8               Lcom/gjxaiou/synchronize/MyTest3;
  #14 = Utf8               method
  #15 = Utf8               SourceFile
  #16 = Utf8               MyTest3.java
  #17 = NameAndType        #7:#8          // "<init>":()V
  #18 = Class              #25            // java/lang/System
  #19 = NameAndType        #26:#27        // out:Ljava/io/PrintStream;
  #20 = Utf8               hello world
  #21 = Class              #28            // java/io/PrintStream
  #22 = NameAndType        #29:#30        // println:(Ljava/lang/String;)V
  #23 = Utf8               com/gjxaiou/synchronize/MyTest3
  #24 = Utf8               java/lang/Object
  #25 = Utf8               java/lang/System
  #26 = Utf8               out
  #27 = Utf8               Ljava/io/PrintStream;
  #28 = Utf8               java/io/PrintStream
  #29 = Utf8               println
  #30 = Utf8               (Ljava/lang/String;)V
{
  public com.gjxaiou.synchronize.MyTest3();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 7: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/gjxaiou/synchronize/MyTest3;

  public static synchronized void method();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED
    Code:
      // 这是显示方法参数个数为 0，因为该方法是静态方法，原则上这个方法并不属于 MyTest3 这个类（我们可以在没有生成 MyTest3 对象的情况下使用类名直接调用该方法），
      stack=2, locals=0, args_size=0
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintSt
ream;
         3: ldc           #3                  // String hello world
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/l
ang/String;)V
         8: return
      LineNumberTable:
        line 9: 0
        line 10: 8
}
SourceFile: "MyTest3.java"
```



### 自旋对于 synchronized 关键字的底层意义与价值分析

> 注：一个线程调用了 wait 方法之后就会进入 waitset 中，当另一个线程调用了 notify/notifyAll 方法之后会将这个线程唤醒，唤醒之后争用锁，争到就执行，没争到就阻塞进入了 EntryList 中；阻塞的线程进入 EntryList 中。

JVM 中的同步是基于进入与退出监视器对象（即 Monitor 对象）（Monitor 也称为 管程）来实现的，每个对象实例都会有一个 Monitor 对象， Monitor 对象会和 Java 对象一同创建和销毁， Monitor 对象是由 C++ 来实现的。

当多个线程同时访问一段同步代码时，这些线程会被放入一个 EntryList 集合中，处于阻塞状态的线程都会被放到该列表当中，接下来，当线程获取到对象的 Monitor 时候， Monitor 是依赖于底层操作系统的 matex Lock 来实现互斥的，线程获取 mutex 成功，则会持有该 mutex，这时其他线程就无法在获取到该 mutex。

所以 synchronized 底层是基于操作系统的互斥锁实现的。

如果线程调用了 wait 方法，那么该线程就会释放掉所持有的 mutex，并且该线程会进入到 WaitSet （等待集合）中，等待下一次被其他线程调用 notify/notifyAll 唤醒，如果当初线程顺利的执行完毕方法，那么他也会释放所持有的 mutex。

当一个线程调用了 wait 方法，该线程就会进入 waitSet（等待集合）中，等待其他线程调用 notify 或者 notifyAll 方法来唤醒，如果被成功唤醒之后，就会尝试着获取对象的锁，如果成功获取了锁就拥有了该对象的 monitor 对象，然后正常执行。如果没有获得对象的锁，该线程就会进入到 EntryList 中（EntryList 中都是存放着被阻塞的线程，它们等待下次获取对象的 mutex）。

**总结**：同步锁在这种实现方式中，因为 monitor 是依赖于底层的操作系统实现，这样就存在用户态与内核态之间的切换（当线程真正执行业务代码的时候，是处于用户态的状态下，当没有获取到对象的锁而处于阻塞或者等待状态，因为 monitor 是由底层操作系统的 matex Lock 实现，所以就进入了内核态，如果该线程尝试获取对象的锁并且成功获取到的话就又转换为了用户态），所以会增加性能开销。通过对象互斥锁的概念来保证共享数据操作的完整性，每个对象都对应于一个可称为【互斥锁】的标记，这个标记用于保证在任何时刻，只能有一个线程访问该对象。

注：JVM 优化：当一个线程持有对象的锁并且正在执行相应的代码的时候，如果该线程发现该方法很快就执行完成，就不会让另一个等待线程进入内核态，而是让该线程进行自旋（空转等待正在执行的线程释放 monitor 对象）， 自旋占用 CPU 资源。因为该等待线程没有阻塞所有一直处于用户态，省去了用户态和内核态之间切换的时间。如果执行线程执行方法过长，等待线程自旋一段时间还是会转入内核态。

那些处于 EntryList 与 waitSet 中的线程均处于阻塞状态，阻塞操作是有操作系统来完成的，在 Linux 中是通过 pthread_mutex_lock 函数实现的。线程被阻塞之后就会进入到内核调度状态，这会导致系统在用户态和内核态之间来回切换，严重影响锁的性能。

解决上述问题的方法便是自旋（Spin）。其原理是：当发生对 monitor 的争用的时候，若拥有者能够在很短的时间内释放掉锁，则那些正在争用的线程就可以稍微等待（即所谓的自旋），在拥有者线程释放锁之后，争用线程可能会立即获取到锁，从而避免了系统阻塞。如果拥有者运行的时间超过了临界值之后，争用线程自旋一段时间后依然无法获取到锁，这是争用线程就会停止自旋而进入阻塞状态，所有总体思想是：先自旋，不成功再进行阻塞，尽量降低阻塞的可能性，这对那些执行时间很短的代码块来说有极大的性能提升。显然，自旋在多处理器（多核心）上才有意义。



### 互斥锁属性详解与 Monitor 对象特性解说

互斥锁的属性（类型）：从操作系统级别看

- PTHREAD_MUTEX_TIMED ；这是缺省值（默认值），也就是普通锁，当一个线程加锁之后，其余请求该锁的线程会形成一个等待队列，并且在解锁之后按照优先级获取到锁。这种策略可以确保资源分配的公平性。
- PTHREAD_MUTEX_RECURSIVE_NP：嵌套锁，允许一个线程对同一个锁成功获取多次，并通过 unlock 解锁（锁多少次就要调用多少次 unlock 来解锁）。如果是不同线程请求，则在加锁线程解锁时候重新进行竞争。
- PTHREAD_MUTEX_ERRORCHECK_NP：检错锁，如果一个线程请求同一个锁，则返回 EDEADLK，否则与 PTHREAD_MUTEX_TIMED 类型动作相同，这样就保证了当不允许多次加锁时候不会出现最简单情况下的死锁。
- PTHREAD_MUTEX_ADAPTIVE_NP：适应锁，是动作最简单的锁，仅仅等待解锁后所有线程公平竞争。

synchronized 是语言层面提供的一个关键字，从语言层面来解决并发问题。语言本身加上关键字之后，通过编译器编译之后遇到这个关键字就是生成对应的字节码指令（monitorenter、monitorexit、ACC_SYNCHROIZED 等），程序整整执行的时候是执行一条条的字节码，同时字节码最后映射落实到了操作系统层面的函数调用，例如上面阻塞操作是有操作系统来完成的，在 Linux 中是通过 pthread_mutex_lock 函数实现的。通过底层操作系统层面的函数调用来实现应用层面上的并发访问等功能。



### 通过 openjdk 源码分析 ObjectMonitor 底层实现

官网：openjdk.java.net，在左边栏选择 Mercurial （这是 openjdk 网站的版本管理工具），单击之后就可看到其所管理的所以项目代码，这里选择 jdk8u，选择其中之一然后选择 hotspot，然后选择左边的 browse 可以查看项目的整体架构。src/share/vm/runtime/objectMonitor.cpp（具体实现）和 objectMonitor.hpp（头文件）

[点击直达](http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/d975dfffada6/src/share/vm/runtime)

**首先 waitset 和 EntryList 关系**

在 hpp 头文件中

```cpp

// ObjectWaiter serves as a "proxy" or surrogate thread.
// TODO-FIXME: Eliminate ObjectWaiter and use the thread-specific
// ParkEvent instead.  Beware, however, that the JVMTI code
// knows about ObjectWaiters, so we'll have to reconcile that code.
// See next_waiter(), first_waiter(), etc.

// 是对阻塞在对象锁上的线程的封装，因为下面有 Thread* _thread；和ObjectWaiter next/pre 表示前后等待的线程，所以整个应该类似于一种链表的结构
class ObjectWaiter : public StackObj {
 public:
  enum TStates { TS_UNDEF, TS_READY, TS_RUN, TS_WAIT, TS_ENTER, TS_CXQ } ;
  enum Sorted  { PREPEND, APPEND, SORTED } ;
  ObjectWaiter * volatile _next;
  ObjectWaiter * volatile _prev;
  Thread*       _thread;
  jlong         _notifier_tid;
  ParkEvent *   _event;
  volatile int  _notified ;
  volatile TStates TState ;
  Sorted        _Sorted ;           // List placement disposition
  bool          _active ;           // Contention monitoring is enabled
 public:
  ObjectWaiter(Thread* thread);

  void wait_reenter_begin(ObjectMonitor *mon);
  void wait_reenter_end(ObjectMonitor *mon);
};


```

同样上面的 Monitor 对象对应于底层 C++ 代码：ObjectMonitor

里面就有 waitset 和 EntryList 成员变量。

```java

// WARNING:
//   This is a very sensitive and fragile class. DO NOT make any
// change unless you are fully aware of the underlying semantics.

//   This class can not inherit from any other class, because I have
// to let the displaced header be the very first word. Otherwise I
// have to let markOop include this file, which would export the
// monitor data structure to everywhere.
//
// The ObjectMonitor class is used to implement JavaMonitors which have
// transformed from the lightweight structure of the thread stack to a
// heavy weight lock due to contention

// It is also used as RawMonitor by the JVMTI


class ObjectMonitor {
 public:
  enum {
    OM_OK,                    // no error
    OM_SYSTEM_ERROR,          // operating system error
    OM_ILLEGAL_MONITOR_STATE, // IllegalMonitorStateException
    OM_INTERRUPTED,           // Thread.interrupt()
    OM_TIMED_OUT              // Object.wait() timed out
  };
    
 
  // initialize the monitor, exception the semaphore, all other fields
  // are simple integers or pointers
  ObjectMonitor() {
    _header       = NULL;
    _count        = 0;
    _waiters      = 0,
    _recursions   = 0;
    _object       = NULL;
    _owner        = NULL;
    _WaitSet      = NULL;
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ;
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
    _previous_owner_tid = 0;
  }

  ~ObjectMonitor() {
   // TODO: Add asserts ...
   // _cxq == 0 _succ == NULL _owner == NULL _waiters == 0
   // _count == 0 _EntryList  == NULL etc
  }

private:
  void Recycle () {
    // TODO: add stronger asserts ...
    // _cxq == 0 _succ == NULL _owner == NULL _waiters == 0
    // _count == 0 EntryList  == NULL
    // _recursions == 0 _WaitSet == NULL
    // TODO: assert (is_busy()|_recursions) == 0
    _succ          = NULL ;
    _EntryList     = NULL ;
    _cxq           = NULL ;
    _WaitSet       = NULL ;
    _recursions    = 0 ;
    _SpinFreq      = 0 ;
    _SpinClock     = 0 ;
    OwnerIsThread  = 0 ;
  }

public:

  void*     object() const;
  void*     object_addr();
  void      set_object(void* obj);

  bool      check(TRAPS);       // true if the thread owns the monitor.
  void      check_slow(TRAPS);
  void      clear();
  static void sanity_checks();  // public for -XX:+ExecuteInternalVMTests
                                // in PRODUCT for -XX:SyncKnobs=Verbose=1
#ifndef PRODUCT
  void      verify();
  void      print();
#endif

  bool      try_enter (TRAPS) ;
  void      enter(TRAPS);
  void      exit(bool not_suspended, TRAPS);
  void      wait(jlong millis, bool interruptable, TRAPS);
  void      notify(TRAPS);
  void      notifyAll(TRAPS);

// Use the following at your own risk
  intptr_t  complete_exit(TRAPS);
  void      reenter(intptr_t recursions, TRAPS);

 private:
  void      AddWaiter (ObjectWaiter * waiter) ;
  static    void DeferredInitialize();

  ObjectWaiter * DequeueWaiter () ;
  void      DequeueSpecificWaiter (ObjectWaiter * waiter) ;
  void      EnterI (TRAPS) ;
  void      ReenterI (Thread * Self, ObjectWaiter * SelfNode) ;
  void      UnlinkAfterAcquire (Thread * Self, ObjectWaiter * SelfNode) ;
  int       TryLock (Thread * Self) ;
  int       NotRunnable (Thread * Self, Thread * Owner) ;
  int       TrySpin_Fixed (Thread * Self) ;
  int       TrySpin_VaryFrequency (Thread * Self) ;
  int       TrySpin_VaryDuration  (Thread * Self) ;
  void      ctAsserts () ;
  void      ExitEpilog (Thread * Self, ObjectWaiter * Wakee) ;
  bool      ExitSuspendEquivalent (JavaThread * Self) ;
  void      post_monitor_wait_event(EventJavaMonitorWait * event,
                                                   jlong notifier_tid,
                                                   jlong timeout,
                                                   bool timedout);

 private:
  friend class ObjectSynchronizer;
  friend class ObjectWaiter;
  friend class VMStructs; 
```

画图演示：

![image-20200218213325708](%E9%83%A8%E5%88%86%E4%B8%80%EF%BC%9A%E7%BA%BF%E7%A8%8B.resource/image-20200218213325708.png)



### 通过 openjdk 源码分析 wait 与 notify 方法的本地实现

objectMonitor.cpp 1459行

java 中 Object 类中的 wait 方法就是下面 ObjectMonitor 类中 wait方法的一个实现。

```cpp
// -----------------------------------------------------------------------------
// Wait/Notify/NotifyAll
//
// Note: a subset of changes to ObjectMonitor::wait()
// will need to be replicated in complete_exit above
void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS) {
   Thread * const Self = THREAD ;
   assert(Self->is_Java_thread(), "Must be Java thread!");
   JavaThread *jt = (JavaThread *)THREAD;

   DeferredInitialize () ;

   // Throw IMSX or IEX.
   CHECK_OWNER();

   EventJavaMonitorWait event;

   // check for a pending interrupt
   if (interruptible && Thread::is_ interrupted(Self, true) && !HAS_PENDING_EXCEPTION) {
     // post monitor waited event.  Note that this is past-tense, we are done waiting.
     if (JvmtiExport::should_post_monitor_waited()) {
        // Note: 'false' parameter is passed here because the
        // wait was not timed out due to thread interrupt.
        JvmtiExport::post_monitor_waited(jt, this, false);

        // In this short circuit of the monitor wait protocol, the
        // current thread never drops ownership of the monitor and
        // never gets added to the wait queue so the current thread
        // cannot be made the successor. This means that the
        // JVMTI_EVENT_MONITOR_WAITED event handler cannot accidentally
        // consume an unpark() meant for the ParkEvent associated with
        // this ObjectMonitor.
     }
     if (event.should_commit()) {
       post_monitor_wait_event(&event, 0, millis, false);
     }
     TEVENT (Wait - Throw IEX) ;
     THROW(vmSymbols::java_lang_InterruptedException());
     return ;
   }

   TEVENT (Wait) ;

   assert (Self->_Stalled == 0, "invariant") ;
   Self->_Stalled = intptr_t(this) ;
   jt->set_current_waiting_monitor(this);

    // 将当前正在执行的线程封装成 ObjectWaiter 类型的结点，然后将其放入队列，这里的 self 根据上面 Line7可以看出是一个线程对象 
   // create a node to be put into the queue
   // Critically, after we reset() the event but prior to park(), we must check
   // for a pending interrupt.
   ObjectWaiter node(Self);
    // 将节点的状态设置为等待状态
   node.TState = ObjectWaiter::TS_WAIT ;
   Self->_ParkEvent->reset() ;
   OrderAccess::fence();          // ST into Event; membar ; LD interrupted-flag
// 这个注释重要
   // Enter the waiting queue, which is a circular doubly linked list in this case
   // but it could be a priority queue or any data structure.
   // _WaitSetLock protects the wait queue.  Normally the wait queue is accessed only
   // by the the owner of the monitor *except* in the case where park()
   // returns because of a timeout of interrupt.  Contention is exceptionally rare
   // so we use a simple spin-lock instead of a heavier-weight blocking lock.

   Thread::SpinAcquire (&_WaitSetLock, "WaitSet - add") ;
    // 调用 AddWaiter 将该结点放入 waitSet 中
   AddWaiter (&node) ；
       // AddWaiter 具体实现为 L2328：从方法中可以看出就是修改一系列的双向链表的指针
       /**
        inline void ObjectMonitor::AddWaiter(ObjectWaiter* node) {
          assert(node != NULL, "should not dequeue NULL node");
          assert(node->_prev == NULL, "node already in list");
          assert(node->_next == NULL, "node already in list");
          // put node at end of queue (circular doubly linked list)
          if (_WaitSet == NULL) {
            _WaitSet = node;
            node->_prev = node;
            node->_next = node;
          } else {
            ObjectWaiter* head = _WaitSet ;
            ObjectWaiter* tail = head->_prev;
            assert(tail->_next == head, "invariant check");
            tail->_next = node;
            head->_prev = node;
            node->_next = head;
            node->_prev = tail;
          }
        }
*/
       
       
   Thread::SpinRelease (&_WaitSetLock) ;

   if ((SyncFlags & 4) == 0) {
      _Responsible = NULL ;
   }
   intptr_t save = _recursions; // record the old recursion count
   _waiters++;                  // increment the number of waiters
   _recursions = 0;             // set the recursion level to be 1
    // 退出 monitor，即释放了锁
   exit (true, Self) ;                    // exit the monitor
    // exit 具体实现方法见：L956
    /**
    void ATTR ObjectMonitor::exit(bool not_suspended, TRAPS) {
   Thread * Self = THREAD ;
   if (THREAD != _owner) {
     if (THREAD->is_lock_owned((address) _owner)) {
       // Transmute _owner from a BasicLock pointer to a Thread address.
       // We don't need to hold _mutex for this transition.
       // Non-null to Non-null is safe as long as all readers can
       // tolerate either flavor.
       assert (_recursions == 0, "invariant") ;
       _owner = THREAD ;
       _recursions = 0 ;
       OwnerIsThread = 1 ;
     } else {
       // NOTE: we need to handle unbalanced monitor enter/exit
       // in native code by throwing an exception.
       // TODO: Throw an IllegalMonitorStateException ?
       TEVENT (Exit - Throw IMSX) ;
       assert(false, "Non-balanced monitor enter/exit!");
       if (false) {
          THROW(vmSymbols::java_lang_IllegalMonitorStateException());
       }
       return;
     }
   }
   */
   guarantee (_owner != Self, "invariant") ;

   // The thread is on the WaitSet list - now park() it.
   // On MP systems it's conceivable that a brief spin before we park
   // could be profitable.
   //
   // TODO-FIXME: change the following logic to a loop of the form
   //   while (!timeout && !interrupted && _notified == 0) park()

   int ret = OS_OK ;
   int WasNotified = 0 ;
   { // State transition wrappers
     OSThread* osthread = Self->osthread();
     OSThreadWaitState osts(osthread, true);
     {
       ThreadBlockInVM tbivm(jt);
       // Thread is in thread_blocked state and oop access is unsafe.
       jt->set_suspend_equivalent();

       if (interruptible && (Thread::is_interrupted(THREAD, false) || HAS_PENDING_EXCEPTION)) {
           // Intentionally empty
       } else
       if (node._notified == 0) {
         if (millis <= 0) {
            Self->_ParkEvent->park () ;
         } else {
            ret = Self->_ParkEvent->park (millis) ;
         }
       }

       // were we externally suspended while we were waiting?
       if (ExitSuspendEquivalent (jt)) {
          // TODO-FIXME: add -- if succ == Self then succ = null.
          jt->java_suspend_self();
       }

     } // Exit thread safepoint: transition _thread_blocked -> _thread_in_vm
       
       
```



**分析 notify 方法**

ObjectMonitor.cpp 中 L1698

```cpp
void ObjectMonitor::notify(TRAPS) {
  CHECK_OWNER();
    // 如果当前 waitSet 为 null，表示当前没有任何线程去调用了该对象的 wait 方法，直接返回了。
  if (_WaitSet == NULL) {
     TEVENT (Empty-Notify) ;
     return ;
  }
DTRACE_MONITOR_PROBE(notify, this, object(), THREAD);

  int Policy = Knob_MoveNotifyee ;

  Thread::SpinAcquire (&_WaitSetLock, "WaitSet - notify") ;
    // 如果 waitSet 不为空，通过 DequeueWaiter() 方法来唤醒线程
  ObjectWaiter * iterator = DequeueWaiter() ;
    // DequeueWaiter 方法的具体实现：L2348，它就是获取到 waitSet 集合中第一个对象
    /**
    inline ObjectWaiter* ObjectMonitor::DequeueWaiter() {
      // dequeue the very first waiter
      ObjectWaiter* waiter = _WaitSet;
      if (waiter) {
        DequeueSpecificWaiter(waiter);
      }
      return waiter;
    }
    */
    // 根据不同的调度策略，找到对应的要唤醒的线程对象，只会唤醒一个，不是将所有等待集合都唤醒然后竞争。具体唤醒是使用 L1793 的 unpark()；
  if (iterator != NULL) {
     TEVENT (Notify1 - Transfer) ;
     guarantee (iterator->TState == ObjectWaiter::TS_WAIT, "invariant") ;
     guarantee (iterator->_notified == 0, "invariant") ;
     if (Policy != 4) {
        iterator->TState = ObjectWaiter::TS_ENTER ;
     }
     iterator->_notified = 1 ;
     Thread * Self = THREAD;
     iterator->_notifier_tid = Self->osthread()->thread_id();

     ObjectWaiter * List = _EntryList ;
     if (List != NULL) {
        assert (List->_prev == NULL, "invariant") ;
        assert (List->TState == ObjectWaiter::TS_ENTER, "invariant") ;
        assert (List != iterator, "invariant") ;
     }

     if (Policy == 0) {       // prepend to EntryList
         if (List == NULL) {
             iterator->_next = iterator->_prev = NULL ;
             _EntryList = iterator ;
         } else {
             List->_prev = iterator ;
             iterator->_next = List ;
             iterator->_prev = NULL ;
             _EntryList = iterator ;
        }
     } else
     if (Policy == 1) {      // append to EntryList
         if (List == NULL) {
             iterator->_next = iterator->_prev = NULL ;
             _EntryList = iterator ;
         } else {
            // CONSIDER:  finding the tail currently requires a linear-time walk of
            // the EntryList.  We can make tail access constant-time by converting to
            // a CDLL instead of using our current DLL.
            ObjectWaiter * Tail ;
            for (Tail = List ; Tail->_next != NULL ; Tail = Tail->_next) ;
            assert (Tail != NULL && Tail->_next == NULL, "invariant") ;
            Tail->_next = iterator ;
            iterator->_prev = Tail ;
            iterator->_next = NULL ;
        }
     } else
     if (Policy == 2) {      // prepend to cxq
         // prepend to cxq
         if (List == NULL) {
             iterator->_next = iterator->_prev = NULL ;
             _EntryList = iterator ;
         } else {
            iterator->TState = ObjectWaiter::TS_CXQ ;
            for (;;) {
                ObjectWaiter * Front = _cxq ;
                iterator->_next = Front ;
                if (Atomic::cmpxchg_ptr (iterator, &_cxq, Front) == Front) {
                    break ;
                }
            }
         }
     } else
     if (Policy == 3) {      // append to cxq
        iterator->TState = ObjectWaiter::TS_CXQ ;
        for (;;) {
            ObjectWaiter * Tail ;
            Tail = _cxq ;
            if (Tail == NULL) {
                iterator->_next = NULL ;
                if (Atomic::cmpxchg_ptr (iterator, &_cxq, NULL) == NULL) {
                   break ;
                }
            } else {
                while (Tail->_next != NULL) Tail = Tail->_next ;
                Tail->_next = iterator ;
                iterator->_prev = Tail ;
                iterator->_next = NULL ;
                break ;
            }
        }
     } else {
        ParkEvent * ev = iterator->_event ;
        iterator->TState = ObjectWaiter::TS_RUN ;
        OrderAccess::fence() ;
        ev->unpark() ;
     }

     if (Policy < 4) {
       iterator->wait_reenter_begin(this);
     }

     // _WaitSetLock protects the wait queue, not the EntryList.  We could
     // move the add-to-EntryList operation, above, outside the critical section
     // protected by _WaitSetLock.  In practice that's not useful.  With the
     // exception of  wait() timeouts and interrupts the monitor owner
     // is the only thread that grabs _WaitSetLock.  There's almost no contention
     // on _WaitSetLock so it's not profitable to reduce the length of the
     // critical section.
  }

  Thread::SpinRelease (&_WaitSetLock) ;

  if (iterator != NULL && ObjectMonitor::_sync_Notifications != NULL) {
     ObjectMonitor::_sync_Notifications->inc() ;
  }
}
    
    
```



### 锁升级与偏向锁深入理解

**分析 synchronized 关键字底层**

在 jdk1.5 之前，我们若想实现线程同步，只能通过 synchronized 关键字这一种方式来实现；在底层 Java 也是通过 synchronized 关键字来做到数据的原子性维护（原子性维护是指该数据在同一时刻只能由一个线程来修改）的。synchronized 关键字是 JVM 实现的一种内置锁，从底层调度来说，这种锁的获取和释放都是有 JVM 帮助我们隐式实现的。

从 jdk1.5 之后，并发包引入了 Lock 锁（位于 java.util.concurrent.locks 包下），Lock 这种同步锁是基于 Java 来实现的，因此锁的获取与释放都是通过 Java 代码（程序开发者）来实现与控制的。然而 synchronized 是基于底层操作系统的 Mutex Lock（互斥锁）来实现的，每次对锁的获取与释放动作都会带来用户态和内核态之间的切换，这种切换会极大的增加系统的负担。在并发量较高时，也就是说锁的竞争比较激烈时候，synchronized 锁在性能的表现就非常差。

synchronized 在 jdk 1.6 之前都是重量级锁（需要用户态和内核态之间来回切换），从 jdk1.6 开始 synchronized 锁的实现上发生了极大的变化， JVM 引入了响应的优化手段来提升 synchronized  锁的性能，这种提升涉及到偏向锁，轻量级锁、重量级锁等，从而减少锁的竞争所带来的用户态与内核态之前的切换。这种锁的优化实际上是通过 Java 对象头中的一些标志位来实现的。对于锁的访问和改变，实际上都与 Java 对象息息相关。

从 JDK1.6 开始，对象实例在堆当中会被划分为三个组成部分：对象头、实例数据（对象本身持有的数据）和对齐填充（确保数据长度的一致性）。

对象头主要由三块内容组成：

- mark word：标记词
- 指向类的指针：（因为对象一定是归属于某一个类的，该标志位指向该对象实例是从哪个类创建出来的）
- 数组长度

其中 MarkWord （它记录了对象、锁以及垃圾回收相关的信息，在 64 位的 JVM 中，其长度也是 64 bit）的位信息包括了以下组成部分：

- 无锁标记：当前对象没有被上锁
- 偏向锁标记
- 轻量级锁标记
- 重量级锁标记
- 垃圾回收标记

对于 synchronized 锁来说，锁的升级主要都是通过 Mark word 中的锁标志位与是否为偏向锁标志位来达成的； synchronized 关键字所对应的锁都是先从偏向锁开始，随着锁的竞争的不断升级，逐步演化为轻量级锁，最后则变成了重量级锁。所以对了锁的演化来说，一般会经历如下阶段（可以在 JVM 启动参数中显式指定从而跳过某些阶段）：无锁——》偏向锁-》轻量级锁-》重量级锁。其中上面的自旋（锁）属于轻量级锁的一种实现方式。

**偏向锁**：是针对一个线程来说的（只有一个线程的情况下），如果去执行 synchronized 修饰的代码块或者方法，首先（也肯定能，因为只有一个线程）要获取到对象的锁，这样就实际到用户态与内核态的切换。执行完成之后，如果其再次执行同样的代码块或者方法，原则上还要获取该对象的锁。偏向锁改进：当一个线程去访问一个 synchronized 方法（代码块）的时候，第一次访问的时候，作为锁的对象，它就会将偏向锁标记标记上（表明该对象有一把偏向锁）还有一个字段指向拥有这把锁的线程的 ID。当又一个线程来访问该 synchronized 方法（代码块）的时候，想获取该对象的锁的时候，就会去该同步对象的 MarkWord 中判断一下，发现该对象已经有了偏向锁，同时指向的线程 ID 和该线程的 ID 一致。说明两次访问中间没有其他线程访问该对象，就不再获取该对象的锁，直接进入该方法（代码块）中，这样线程就需要再次因为获取锁而在用户态和内核态之间切换，只在用户态运行。

**偏向锁总结**：它的作用就是优化同一个线程多次获取一个锁的情况；如果一个synchronized 方法（关键字）被一个线程访问，那么这个方法所在的对象就会在其 Mark Word 中将偏向锁进行标记，同时还会有一个字段来存储该线程的 ID，当这个线程再次访问同一个 synchronized 方法时候，它会检测这个对象的 Mark Word 的偏向锁标记以及是否指向了其线程 ID，如果是的话，那么该线程就无需再次进入管程（Monitor）了，而是直接进入到该方法体中。

如果是另外的一个线程访问了这个 synchronized 方法（代码块），这个偏向锁就会被取消掉，因为偏向指的是偏向于上一个访问该同步方法（代码块）的线程。

当一个线程正在执行该 synchronized 方法（代码块） 还没有执行完的时候，其他线程来争抢该锁的时候（当然这时候抢不到）偏向锁会被取消掉，同时锁会升级为轻量级锁。如果已经执行执行完则同样取消偏向锁。因为锁的取消会带来更大的开销，所以大并发的时候可以配置 JVM 启动参数取消偏向锁的设定。



### 轻量级锁和重量级锁的变化深入理解

**轻量级锁**：如果第一个线程已经获取到了当前对象的锁，这时候第二个线程又开始尝试争抢该对象的锁，由于该对象的锁已经被第一个线程获取到，因此它是偏向锁，而第二个线程在争抢时候，会发现该对象头中的 Mark Word 已经是偏向锁，但是里面存储的线程 ID 并不是自己（是第一个线程），那么他就会进行 CAS（Compare and Swap），从而获取到锁。这里面存在两种情况。

- 获取锁成功：那么他就会直接将 Mark Word 中的线程 ID 由第一个线程变成自己（偏向锁的标记位不变），这样该对象依然会保持偏向锁的状态。
- 获取锁失败：则表示这时候可能会有多个线程同时在尝试争抢该对象的锁，这个线程获取锁失败，那么这时偏向锁就会进行升级，升级为轻量级锁。

轻量级锁适合两个线程轮流访问的情景，不适合很多线程同时竞争的情况。

**自旋锁**

如果自旋失败（依然无法获取到锁），那么锁就会升级为重量级锁，在这种情况下，无法获取到锁的线程就会进入 Monitor （即内核态）。

自旋最大的一个特点就是避免了线程从用户态进入内核态。

**重量级锁**

线程最终从用户态进入内核态。



### 锁粗化与锁消除技术实例演示与分析

编译器对于锁的优化措施：运行期优化，编译期形成的字节码还是没有改变。

- 优化一：锁消除

 JIT（Just In Time） 编译器（即时编译器）可以在动态编译同步代码时候，使用一种叫做逃逸分析的技术，通过该项技术判别程序中所使用的锁对象是否只被一个线程所使用，而没有散步到其他线程中；如果情况确实如此，那么 JIT 编译器在编译这个同步代码时就不会生成 synchronized 关键字所标识的锁的申请与释放机器码，从而消除了锁的使用流程。（反编译字节码含有 monitorenter 和 monitorexit，但是执行时候相当于没有）

**示例程序**

```java
package com.gjxaiou.synchronize;

/**
 * @Author GJXAIOU
 * @Date 2020/2/20 21:30
 */
public class MyTest4 {
    // 在 MyTest4 只有一个实例的情况下，这个实例的成员变量会被所有线程所共享
    // private Object object = new Object();

    public void method() {
        // 局部变量，每个线程都会有该 object 对象的引用，所以加不加 synchronized 没什么意义了
        Object object = new Object();
        synchronized (object) {
            System.out.println("hello world");
        }
    }
}

```

如上面这个程序中，本质上不需要上锁，所以执行的时候编译器进行了优化。

- 优化二：锁粗化

 JIT 编译器在执行动态编译的时候，如发现前后相邻的 synchronized 块使用的是同一个对象，那么就会把这几个 synchronized 块给合并为一个较大的同步块，这样做的好处在于线程在执行这些代码时候，就无须频繁的申请和释放锁了，从而达到申请与释放锁一次就可以执行完全部的同步代码块，从而提升了性能。

```java
package com.gjxaiou.synchronize;

/**
 * @Author GJXAIOU
 * @Date 2020/2/20 21:44
 */
public class MyTest5 {
    // 如果声明为成员变量,就被所有访问同一个 MyTest5 实例的线程所共享，所以同一时刻只有一个对象可以获取到 object 对象的锁。
    // 这种代码，每一个 synchronized 代码块线程都要争锁，浪费时间。
    Object object = new Object();

    public void method() {
        // 因为编译器使用 锁消除，相当于下面的 synchronized 关键字都不存在了，也就不需要锁获取与消除了，就是直接执行。（这里针对是锁消除的示例）
        // Object object = new Object();
        synchronized (object) {
            System.out.println("hello");
        }
        synchronized (object) {
            System.out.println("world");
        }
        synchronized (object) {
            System.out.println("person");
        }
    }
}
```



### 小结：锁与底层内容阶段性回顾与总结

### openjdk 源码剖析与锁升级技术回顾



### 死锁检测和相关工具详解

死锁：线程 1 等待线程 2 互斥持有的资源，而线程 2 也在等待线程 1 互斥持有的资源，两个线程都无法继续执行。

活锁：线程持续重试一个总是失败的操作，导致无法继续进行（针对一个线程）。                                                                 	

